
/Users/briangiori/dev/newt/blegpio/bin/blegpio/apps/blegpio/blegpio.elf:     file format elf32-littlearm
/Users/briangiori/dev/newt/blegpio/bin/blegpio/apps/blegpio/blegpio.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00008b4d

Program Header:
0x70000001 off    0x00022e7c vaddr 0x00022e7c paddr 0x00022e7c align 2**2
         filesz 0x00000018 memsz 0x00000018 flags r--
    LOAD off    0x00008000 vaddr 0x00008000 paddr 0x00008000 align 2**15
         filesz 0x00000000 memsz 0x00000020 flags rw-
    LOAD off    0x00008020 vaddr 0x00008020 paddr 0x00008020 align 2**15
         filesz 0x0001ae74 memsz 0x0001ae74 flags r-x
    LOAD off    0x000280d8 vaddr 0x200000d8 paddr 0x00022e94 align 2**15
         filesz 0x0000077c memsz 0x00000f28 flags rw-
    LOAD off    0x00029000 vaddr 0x20001000 paddr 0x00023dc0 align 2**15
         filesz 0x00000000 memsz 0x00002e14 flags rw-
    LOAD off    0x00030000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x000000d8 flags rw-
private flags = 5000202: [Version5 EABI] [soft-float ABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .imghdr       00000020  00008000  00008000  00008000  2**0  ALLOC
  1 .text         0001ae5c  00008020  00008020  00008020  2**3  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.extab    00000000  00022e7c  00022e7c  00028854  2**0  CONTENTS
  3 .ARM.exidx    00000018  00022e7c  00022e7c  00022e7c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .vector_relocation 000000d8  20000000  20000000  00030000  2**0  ALLOC
  5 .data         0000077c  200000d8  00022e94  000280d8  2**3  CONTENTS, ALLOC, LOAD, DATA
  6 .bssnz        000007ac  20000854  00023610  00028854  2**2  ALLOC
  7 .bss          00002e14  20001000  00023dc0  00029000  2**3  ALLOC
  8 .stack_dummy  000001b0  20003e18  20003e18  00028858  2**3  CONTENTS, READONLY
  9 .ARM.attributes 0000002a  00000000  00000000  00028a08  2**0  CONTENTS, READONLY
 10 .comment      00000070  00000000  00000000  00028a32  2**0  CONTENTS, READONLY
 11 .svc_table    00000004  00000000  00000000  00028aa2  2**0  CONTENTS, READONLY
 12 .debug_info   00075ec6  00000000  00000000  00028aa6  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00010f78  00000000  00000000  0009e96c  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000317c7  00000000  00000000  000af8e4  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00002f10  00000000  00000000  000e10b0  2**3  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00003ad0  00000000  00000000  000e3fc0  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0001dee6  00000000  00000000  000e7a90  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00010833  00000000  00000000  00105976  2**0  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  00008684  00000000  00000000  001161ac  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00008000 l    d  .imghdr	00000000 .imghdr
00008020 l    d  .text	00000000 .text
00022e7c l    d  .ARM.extab	00000000 .ARM.extab
00022e7c l    d  .ARM.exidx	00000000 .ARM.exidx
20000000 l    d  .vector_relocation	00000000 .vector_relocation
200000d8 l    d  .data	00000000 .data
20000854 l    d  .bssnz	00000000 .bssnz
20001000 l    d  .bss	00000000 .bss
20003e18 l    d  .stack_dummy	00000000 .stack_dummy
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .svc_table	00000000 .svc_table
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 gcc_startup_nrf52.o
000001b0 l       *ABS*	00000000 Stack_Size
00000000 l       *ABS*	00000000 Heap_Size
00000000 l    df *ABS*	00000000 /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/../lib/gcc/arm-none-eabi/4.9.3/../../../../arm-none-eabi/lib/armv7e-m/crt0.o
00000000 l    df *ABS*	00000000 main.c
0000816c l     F .text	000000bc bleprph_advertise
0000832c l     F .text	0000015c bleprph_gap_event
00008228 l     F .text	00000048 bleprph_task_handler
00008270 l     F .text	000000bc bleprph_print_conn_desc
20001000 l     O .bss	00000db0 bleprph_mbuf_mpool_data
20001db0 l     O .bss	0000001c bleprph_log_console_handler
00000000 l    df *ABS*	00000000 misc.c
00000000 l    df *ABS*	00000000 gatt_svr.c
00008714 l     F .text	00000014 gatt_svr_chr_access_gpio_notif
00008728 l     F .text	00000080 gatt_svr_uuid_to_s
000087a8 l     F .text	00000094 gatt_svr_register_cb
0000883c l     F .text	00000040 gatt_svr_chr_write.isra.1
0000887c l     F .text	0000014c gatt_svr_chr_access_gpio
000089c8 l     F .text	000000d8 gatt_svr_chr_access_alert
20001dcc l     O .bss	00000002 gatt_svr_unr_alert_stat
0001eeb0 l     O .text	00000030 gatt_svr_svcs
20000148 l     O .data	00000010 __compound_literal.0
20000188 l     O .data	00000090 __compound_literal.6
20000100 l     O .data	00000048 __compound_literal.7
200000de l     O .data	00000010 __compound_literal.1
20001dce l     O .bss	00000020 pin_vals
200000ee l     O .data	00000010 __compound_literal.3
20001dee l     O .bss	00000002 gatt_svr_gpio_read_val
20001df0 l     O .bss	00000002 gatt_svr_chr_gpio_notif_val_handle
0001eef0 l     O .text	00000001 gatt_svr_unr_alert_cat
20000158 l     O .data	00000010 __compound_literal.4
20000168 l     O .data	00000010 __compound_literal.2
20000178 l     O .data	00000010 __compound_literal.5
20001df2 l     O .bss	00000002 gatt_svr_gpio_instr
20001df4 l     O .bss	00000002 gatt_svr_alert_not_ctrl_pt
20001df6 l     O .bss	00000040 gatt_svr_new_alert_val
20001e36 l     O .bss	00000020 pin_inits
20001e56 l     O .bss	00000002 gatt_svr_new_alert_val_len
0001f046 l     O .text	00000001 gatt_svr_new_alert_cat
00000000 l    df *ABS*	00000000 system_nrf52.c
00000000 l    df *ABS*	00000000 hal_cputime.c
00000000 l    df *ABS*	00000000 hal_cputime.c
00008e20 l     F .text	0000003c cputime_isr
0001f058 l     O .text	00000040 CSWTCH.11
00000000 l    df *ABS*	00000000 hal_gpio.c
00000000 l    df *ABS*	00000000 inline.c
00000000 l    df *ABS*	00000000 lrand48.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 srand48.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 tinyprintf.c
00009064 l     F .text	000000d4 ui2a
00009138 l     F .text	0000002e putf
00009166 l     F .text	000000e8 putchw
0000924e l     F .text	00000030 intarg
00000000 l    df *ABS*	00000000 jrand48.c
00000000 l    df *ABS*	00000000 memfile.c
00000000 l    df *ABS*	00000000 cmsis_nvic.c
00000000 l    df *ABS*	00000000 cons_tty.c
00009534 l     F .text	00000014 console_add_char
00009548 l     F .text	00000008 console_blocking_tx
00009550 l     F .text	0000002c console_tx_flush
0000957c l     F .text	0000013e console_rx_char
000096bc l     F .text	0000004c console_queue_char
00009708 l     F .text	00000024 console_tx_char
00000000 l    df *ABS*	00000000 os.c
00000000 l    df *ABS*	00000000 os_arch_arm.c
00000000 l    df *ABS*	00000000 os_callout.c
00000000 l    df *ABS*	00000000 os_eventq.c
00000000 l    df *ABS*	00000000 os_fault.c
00000000 l    df *ABS*	00000000 os_mbuf.c
00009da8 l     F .text	00000014 _os_mbuf_trailingspace
00009dbc l     F .text	00000024 _os_msys_find_pool
00009de0 l     F .text	00000034 _os_mbuf_copypkthdr
00000000 l    df *ABS*	00000000 os_mempool.c
00000000 l    df *ABS*	00000000 os_sched.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
0000a77c l     F .text	00000044 os_deltatime
20001e60 l     O .bss	00000030 basetod
00000000 l    df *ABS*	00000000 HAL_CM4.S
0000a956 l       .text	00000000 SVC_User
0000a974 l       .text	00000000 SVC_Done
00000000 l    df *ABS*	00000000 os_sanity.c
0000a9e4 l     F .text	0000001c os_sanity_check_list_lock
0000aa00 l     F .text	00000018 os_sanity_check_list_unlock
00000000 l    df *ABS*	00000000 os_mutex.c
00000000 l    df *ABS*	00000000 ble_ll.c
0000ac04 l     F .text	0000001c ble_ll_flush_pkt_queue
00000000 l    df *ABS*	00000000 ble_ll_adv.c
0000b250 l     F .text	0000001c ble_ll_adv_tx_done
0000b26c l     F .text	0000006c ble_ll_adv_set_sched
0000b2d8 l     F .text	00000140 ble_ll_adv_tx_start_cb
0000b418 l     F .text	00000048 ble_ll_adv_sm_stop.constprop.4
00000000 l    df *ABS*	00000000 ble_ll_conn.c
0000bb88 l     F .text	0000001c ble_ll_conn_current_sm_over
0000bba4 l     F .text	0000001c ble_ll_conn_rxend_unencrypt
0000bbc0 l     F .text	0000001c ble_ll_conn_txend_encrypt
0000bbdc l     F .text	00000014 ble_ll_conn_wait_txend
0000bbf0 l     F .text	00000006 ble_ll_conn_req_txend
0000bbf6 l     F .text	00000030 ble_ll_conn_start_rx_encrypt
0000bc26 l     F .text	0000000c ble_ll_conn_start_rx_unencrypt
0000bc32 l     F .text	00000016 ble_ll_conn_continue_rx_encrypt
0000bc48 l     F .text	0000002e ble_ll_conn_get_next_sched_time
0000bc78 l     F .text	0000038c ble_ll_conn_tx_data_pdu
0000c004 l     F .text	000000f8 ble_ll_conn_event_start_cb
0000c0fc l     F .text	0000005e ble_ll_conn_chk_csm_flags
0000c296 l     F .text	00000198 ble_ll_conn_next_event
0000c430 l     F .text	000000b8 ble_ll_conn_created
0001f26e l     O .text	00000010 g_ble_sca_ppm_tbl
00000000 l    df *ABS*	00000000 ble_ll_conn_hci.c
20001e94 l     O .bss	00000004 g_ble_ll_next_num_comp_pkt_evt
00000000 l    df *ABS*	00000000 ble_ll_ctrl.c
0000de5c l     F .text	00000100 ble_ll_ctrl_conn_upd_make
0000df5c l     F .text	0000002a ble_ll_ctrl_datalen_upd_make
0000df88 l     F .text	000000cc ble_ll_ctrl_conn_param_pdu_make
0000e05c l     F .text	00000150 ble_ll_ctrl_proc_init
0000e1ac l     F .text	00000072 ble_ll_ctrl_len_proc
0000e21e l     F .text	00000038 ble_ll_ctrl_rx_feature_req
0000e2f8 l     F .text	0000014c ble_ll_ctrl_conn_param_pdu_proc
0001f2b4 l     O .text	00000012 CSWTCH.40
00000000 l    df *ABS*	00000000 ble_ll_hci.c
20001e98 l     O .bss	00000008 g_ble_ll_hci_event_mask2
20001ea0 l     O .bss	00000008 g_ble_ll_hci_event_mask
20001ea8 l     O .bss	00000008 g_ble_ll_hci_le_event_mask
00000000 l    df *ABS*	00000000 ble_ll_hci_ev.c
00000000 l    df *ABS*	00000000 ble_ll_rand.c
00000000 l    df *ABS*	00000000 ble_ll_resolv.c
0000f558 l     F .text	00000048 ble_ll_is_on_resolv_list
0000f5a0 l     F .text	00000034 ble_ll_resolv_list_chg_allowed
00000000 l    df *ABS*	00000000 ble_ll_scan.c
0000f900 l     F .text	0000004c ble_ll_scan_find_dup_adv
0000f94c l     F .text	00000044 ble_ll_scan_have_rxd_scan_rsp
0000f990 l     F .text	00000080 ble_ll_scan_req_backoff
0000fa10 l     F .text	00000074 ble_ll_scan_start
0000fa8c l     F .text	00000060 ble_ll_scan_sm_start.constprop.3
20001eb0 l     O .bss	00000001 g_ble_ll_scan_num_rsp_advs
20001eb1 l     O .bss	00000001 g_ble_ll_scan_num_dup_advs
00000000 l    df *ABS*	00000000 ble_ll_sched.c
00010378 l     F .text	00000022 ble_ll_sched_is_overlap
0001039c l     F .text	00000038 ble_ll_sched_conn_overlap
00000000 l    df *ABS*	00000000 ble_ll_whitelist.c
00010a08 l     F .text	0000003c ble_ll_whitelist_search
00010a44 l     F .text	00000014 ble_ll_whitelist_chg_allowed
00000000 l    df *ABS*	00000000 ble_hw.c
00010b30 l     F .text	00000038 ble_rng_isr
20001eb2 l     O .bss	00000001 g_ble_hw_whitelist_mask
00000000 l    df *ABS*	00000000 ble_phy.c
00010e1c l     F .text	00000020 nrf_wait_disabled
00010e3c l     F .text	000000ec ble_phy_rx_xcvr_setup
00010f28 l     F .text	0000002c ble_phy_rxpdu_get.part.0
00011258 l     F .text	0000025c ble_phy_isr
20001eb4 l     O .bss	00000104 g_ble_phy_enc_buf
20001fb8 l     O .bss	00000104 g_ble_phy_txrx_buf
00000000 l    df *ABS*	00000000 ble_gap.c
000116d8 l     F .text	0000008a ble_gap_fill_conn_desc
00011762 l     F .text	00000016 ble_gap_conn_cancel_tx
00011778 l     F .text	00000022 ble_gap_disc_enable_tx
0001179a l     F .text	0000001c ble_gap_adv_enable_tx
000117b6 l     F .text	00000050 ble_gap_call_conn_event_cb
00011808 l     F .text	00000028 ble_gap_master_ticks_until_exp
00011830 l     F .text	00000028 ble_gap_slave_ticks_until_exp
00011858 l     F .text	0000001a ble_gap_heartbeat_sched
00011874 l     F .text	00000040 ble_gap_adv_finished
000118b4 l     F .text	00000054 ble_gap_master_failed
00011908 l     F .text	00000070 ble_gap_conn_broken
20000d94 l     O .bssnz	00000014 ble_gap_master
20000da8 l     O .bssnz	00000058 ble_gap_slave
00000000 l    df *ABS*	00000000 ble_gattc.c
00012498 l     F .text	0000001c ble_gattc_error
000124b4 l     F .text	00000040 ble_gattc_mtu_cb
000124f4 l     F .text	00000006 ble_gattc_mtu_err
000124fc l     F .text	00000040 ble_gattc_disc_all_svcs_cb
0001253c l     F .text	00000010 ble_gattc_disc_all_svcs_err
0001254c l     F .text	00000040 ble_gattc_disc_svc_uuid_cb
0001258c l     F .text	0000000e ble_gattc_disc_svc_uuid_err
0001259c l     F .text	00000040 ble_gattc_find_inc_svcs_cb
000125dc l     F .text	00000012 ble_gattc_find_inc_svcs_err
000125f0 l     F .text	00000040 ble_gattc_disc_all_chrs_cb
00012630 l     F .text	0000000e ble_gattc_disc_all_chrs_err
00012640 l     F .text	00000040 ble_gattc_disc_chr_uuid_cb
00012680 l     F .text	0000000e ble_gattc_disc_chr_uuid_err
00012690 l     F .text	0000003c ble_gattc_disc_all_dscs_cb
000126cc l     F .text	0000000e ble_gattc_disc_all_dscs_err
000126dc l     F .text	00000040 ble_gattc_read_cb
0001271c l     F .text	00000006 ble_gattc_read_err
00012722 l     F .text	00000022 ble_gattc_read_rx_read_rsp
00012744 l     F .text	00000040 ble_gattc_read_uuid_cb
00012784 l     F .text	0000000e ble_gattc_read_uuid_err
00012792 l     F .text	00000030 ble_gattc_read_uuid_rx_adata
000127c4 l     F .text	00000040 ble_gattc_read_long_cb
00012804 l     F .text	00000006 ble_gattc_read_long_err
0001280c l     F .text	00000054 ble_gattc_read_mult_cb
00012860 l     F .text	00000010 ble_gattc_read_mult_err
00012870 l     F .text	0000003c ble_gattc_write_long_cb
000128ac l     F .text	0000000c ble_gattc_write_long_rx_exec
000128b8 l     F .text	00000040 ble_gattc_write_reliable_cb
000128f8 l     F .text	0000000c ble_gattc_write_reliable_rx_exec
00012904 l     F .text	00000050 ble_gattc_extract
00012954 l     F .text	0000006c ble_gattc_extract_with_rx_entry
000129c0 l     F .text	00000010 ble_gattc_proc_free
000129d0 l     F .text	0000001c ble_gattc_proc_alloc
000129ec l     F .text	00000050 ble_gattc_write_cb
00012a3c l     F .text	00000004 ble_gattc_write_err
00012a40 l     F .text	00000020 ble_gattc_log_proc_init
00012a60 l     F .text	00000042 ble_gattc_disc_all_chrs_go
00012aa2 l     F .text	00000042 ble_gattc_disc_chr_uuid_go
00012ae4 l     F .text	00000054 ble_gattc_find_inc_svcs_go
00012b38 l     F .text	00000064 ble_gattc_find_inc_svcs_rx_read_rsp
00012b9c l     F .text	00000040 ble_gattc_read_long_go
00012bdc l     F .text	0000006a ble_gattc_write_long_go
00012c46 l     F .text	0000002e ble_gattc_write_long_err
00012c74 l     F .text	0000002e ble_gattc_indicate_err
00012ca2 l     F .text	0000008e ble_gattc_disc_all_chrs_rx_adata
00012d30 l     F .text	000000a8 ble_gattc_disc_chr_uuid_rx_adata
00012dd8 l     F .text	00000056 ble_gattc_write_long_rx_prep
00012e2e l     F .text	00000016 ble_gattc_read_uuid_rx_complete
00012e44 l     F .text	00000034 ble_gattc_process_status
00012e78 l     F .text	0000002e ble_gattc_disc_all_chrs_rx_complete
00012ea6 l     F .text	0000002e ble_gattc_disc_chr_uuid_rx_complete
00012ed4 l     F .text	00000030 ble_gattc_find_inc_svcs_rx_complete
00012f04 l     F .text	0000005e ble_gattc_read_long_rx_read_rsp
00012f62 l     F .text	00000026 ble_gattc_write_reliable_err
00012f88 l     F .text	00000072 ble_gattc_find_inc_svcs_rx_adata
00012ffa l     F .text	0000004e ble_gattc_write_reliable_go.constprop.12
00013048 l     F .text	00000058 ble_gattc_write_reliable_rx_prep
000130a0 l     F .text	000000a0 ble_gattc_fail_procs.constprop.13
200020bc l     O .bss	00000004 ble_gattc_proc_mem
0001f6f0 l     O .text	00000018 ble_gattc_rx_read_rsp_entries
200020c0 l     O .bss	00000004 error.10091
0001f708 l     O .text	00000020 ble_gattc_rx_read_type_elem_entries
0001f728 l     O .text	00000010 ble_gattc_rx_prep_entries
0001f98c l     O .text	00000020 ble_gattc_rx_read_type_complete_entries
0001f9ac l     O .text	00000010 ble_gattc_rx_exec_entries
200020c4 l     O .bss	00000008 ble_gattc_procs
200020cc l     O .bss	0000001c ble_gattc_proc_pool
0001f9bc l     O .text	0000003c ble_gattc_err_dispatch
00000000 l    df *ABS*	00000000 ble_gatts.c
0001381c l     F .text	00000030 ble_gatts_find_svc_entry_idx
0001384c l     F .text	00000028 ble_gatts_clt_cfg_find_idx
00013874 l     F .text	00000034 ble_gatts_svc_access
000138a8 l     F .text	00000044 ble_gatts_inc_access
000138ec l     F .text	00000024 ble_gatts_free_mem
00013910 l     F .text	00000012 ble_gatts_chr_clt_cfg_allowed.isra.0
00013924 l     F .text	00000024 ble_gatts_dsc_inc_stat
00013948 l     F .text	0000002a ble_gatts_schedule_update.isra.4
00013974 l     F .text	000000a4 ble_gatts_chr_def_access
00013a18 l     F .text	00000030 ble_gatts_dsc_access
00013a48 l     F .text	00000160 ble_gatts_clt_cfg_access
000141dc l     F .text	00000058 ble_gatts_chr_val_access
200020e8 l     O .bss	00000004 ble_gatts_num_cfgable_chrs
200020ec l     O .bss	00000002 ble_gatts_num_svc_entries
200020f0 l     O .bss	00000004 ble_gatts_svc_entries
200020f4 l     O .bss	00000002 buf.9781
200020f8 l     O .bss	00000004 ble_gatts_clt_cfgs
200020fc l     O .bss	00000004 ble_gatts_clt_cfg_mem
20002100 l     O .bss	0000001c ble_gatts_clt_cfg_pool
00000000 l    df *ABS*	00000000 ble_hci_cmd.c
2000211c l     O .bss	00000008 ble_hci_cmd_sem
20002124 l     O .bss	0000000c ble_hci_cmd_mutex
00000000 l    df *ABS*	00000000 ble_hci_util.c
00000000 l    df *ABS*	00000000 ble_hs.c
00014720 l     F .text	00000024 ble_hs_free_mem
00014778 l     F .text	00000090 ble_hs_event_handle
0001482c l     F .text	0000002c ble_hs_heartbeat
20002130 l     O .bss	00000004 ble_hs_parent_task
20002134 l     O .bss	00000004 ble_hs_parent_evq
20002138 l     O .bss	00000004 ble_hs_hci_evt_buf
2000213c l     O .bss	0000000c ble_hs_mutex
20002148 l     O .bss	00000020 ble_hs_heartbeat_timer
20002168 l     O .bss	0000001c ble_hs_log_console_handler
2000023c l     O .data	0000000c ble_hs_event_tx_notifications
20002184 l     O .bss	00000004 ble_hs_hci_os_event_buf
20002188 l     O .bss	00000014 ble_hs_rx_q
2000219c l     O .bss	00000014 ble_hs_tx_q
200021b0 l     O .bss	00000020 ble_hs_event_co
200021d0 l     O .bss	0000000c ble_hs_evq
00000000 l    df *ABS*	00000000 ble_hs_adv.c
00014ab4 l     F .text	00000038 ble_hs_adv_parse_uuids16
00014aec l     F .text	00000038 ble_hs_adv_parse_uuids32
00014b24 l     F .text	00000056 ble_hs_adv_set_array16
200021dc l     O .bss	0000001c ble_hs_adv_uuids16
200021f8 l     O .bss	0000001c ble_hs_adv_uuids32
00000000 l    df *ABS*	00000000 ble_hs_atomic.c
00000000 l    df *ABS*	00000000 ble_hs_cfg.c
00000000 l    df *ABS*	00000000 ble_hs_conn.c
20002214 l     O .bss	00000004 ble_hs_conn_elem_mem
20002218 l     O .bss	0000001c ble_hs_conn_pool
20002234 l     O .bss	00000004 ble_hs_conns
20002238 l     O .bss	00000006 ble_hs_conn_null_addr
00000000 l    df *ABS*	00000000 ble_hs_id.c
2000223e l     O .bss	00000006 ble_hs_id_pub
20002244 l     O .bss	00000006 ble_hs_id_rnd
00000000 l    df *ABS*	00000000 ble_hs_log.c
00000000 l    df *ABS*	00000000 ble_hs_misc.c
00000000 l    df *ABS*	00000000 ble_hs_pvcy.c
000155b8 l     F .text	00000020 ble_hs_pvcy_set_resolve_enabled
2000224a l     O .bss	00000001 ble_hs_pvcy_started
00000000 l    df *ABS*	00000000 ble_hs_startup.c
00000000 l    df *ABS*	00000000 ble_l2cap.c
2000224c l     O .bss	00000004 ble_l2cap_chan_mem
00000000 l    df *ABS*	00000000 ble_l2cap_sig.c
00015a74 l     F .text	00000004 ble_l2cap_sig_rx_noop
00015a78 l     F .text	000000c0 ble_l2cap_sig_rx
00015b38 l     F .text	000000c8 ble_l2cap_sig_update_req_rx
00015c00 l     F .text	000000a0 ble_l2cap_sig_update_rsp_rx
20002250 l     O .bss	0000001c ble_l2cap_sig_proc_pool
0001faf0 l     O .text	00000058 ble_l2cap_sig_dispatch
2000226c l     O .bss	00000004 ble_l2cap_sig_proc_mem
20002270 l     O .bss	00000008 ble_l2cap_sig_procs
00000000 l    df *ABS*	00000000 ble_l2cap_sig_cmd.c
00000000 l    df *ABS*	00000000 ble_sm.c
00015e8c l     F .text	00000014 ble_sm_insert
00015ea0 l     F .text	0000000c ble_sm_rx_noop
00015eac l     F .text	0000000e ble_sm_io_action
00015eba l     F .text	000000ca ble_sm_fill_store_value
00015f84 l     F .text	00000058 ble_sm_enc_start_exec
00015fdc l     F .text	00000056 ble_sm_ltk_req_reply_tx
00016032 l     F .text	00000024 ble_sm_ltk_start_exec
00016056 l     F .text	0000003a ble_sm_ltk_req_neg_reply_tx
00016090 l     F .text	00000046 ble_sm_ltk_restore_exec
000160d6 l     F .text	0000000c ble_sm_random_exec
000160e2 l     F .text	0000000c ble_sm_confirm_exec
000160f0 l     F .text	00000010 ble_sm_proc_free
00016100 l     F .text	00000020 ble_sm_proc_alloc
00016120 l     F .text	00000024 ble_sm_proc_remove.isra.1
00016144 l     F .text	00000080 ble_sm_fail_rx
000161c4 l     F .text	000001d8 ble_sm_key_exch_exec
0001639c l     F .text	0000001c ble_sm_enc_restore_exec
000163b8 l     F .text	00000066 ble_sm_pair_cfg
00016420 l     F .text	00000058 ble_sm_key_rxed
0001652c l     F .text	000000d4 ble_sm_sign_info_rx
00016600 l     F .text	000000d0 ble_sm_id_addr_info_rx
000166d0 l     F .text	000000d4 ble_sm_id_info_rx
000167a4 l     F .text	000000c8 ble_sm_master_id_rx
0001686c l     F .text	000000d4 ble_sm_enc_info_rx
00016940 l     F .text	000000f4 ble_sm_pair_req_rx
00016a48 l     F .text	0000001e ble_sm_sec_req_exec
00016aa4 l     F .text	000000ec ble_sm_confirm_rx
00016b90 l     F .text	000000ec ble_sm_pair_rsp_rx
00016dc8 l     F .text	00000124 ble_sm_enc_event_rx
00016eec l     F .text	00000070 ble_sm_rx
00017084 l     F .text	000000c4 ble_sm_pair_exec
00017154 l     F .text	000000c4 ble_sm_random_rx
000173b4 l     F .text	00000128 ble_sm_sec_req_rx
20002278 l     O .bss	00000008 ble_sm_procs
0001fb80 l     O .text	0000003c ble_sm_dispatch
20002280 l     O .bss	0000001c ble_sm_proc_pool
2000229c l     O .bss	00000004 ble_sm_proc_mem
0001fc68 l     O .text	0000002c ble_sm_state_dispatch
00000000 l    df *ABS*	00000000 ble_sm_alg.c
00017580 l     F .text	00000058 ble_sm_alg_encrypt
200022a0 l     O .bss	00000118 ble_sm_alg_ctxt
00000000 l    df *ABS*	00000000 ble_sm_cmd.c
0001784c l     F .text	0000002c ble_sm_tx
00017878 l     F .text	0000002c ble_sm_init_req
00000000 l    df *ABS*	00000000 ble_sm_lgcy.c
0001fed1 l     O .text	00000019 ble_sm_lgcy_resp_ioa
0001feea l     O .text	00000019 ble_sm_lgcy_init_ioa
00000000 l    df *ABS*	00000000 ble_store.c
00018424 l     F .text	0000003c ble_store_persist_sec
00000000 l    df *ABS*	00000000 ble_uuid.c
20000248 l     O .data	00000010 ble_uuid_base
00000000 l    df *ABS*	00000000 host_dbg.c
00000000 l    df *ABS*	00000000 host_hci.c
00018d6c l     F .text	000000c8 host_hci_rx_le_adv_rpt
00018e34 l     F .text	00000038 host_hci_rx_le_meta
00018e6c l     F .text	00000094 host_hci_rx_le_dir_adv_rpt
00018f00 l     F .text	00000036 host_hci_rx_num_completed_pkts
00018f36 l     F .text	00000084 host_hci_rx_le_conn_parm_req
00018fba l     F .text	00000040 host_hci_rx_le_lt_key_req
00018ffa l     F .text	0000007e host_hci_rx_le_conn_upd_complete
00019078 l     F .text	000000da host_hci_rx_le_conn_complete
00019152 l     F .text	00000028 host_hci_rx_enc_key_refresh
0001917a l     F .text	0000002e host_hci_rx_encrypt_change
000191a8 l     F .text	0000002e host_hci_rx_disconn_complete
200023b8 l     O .bss	00000001 host_hci_max_pkts
00020650 l     O .text	00000038 host_hci_le_event_dispatch
200023ba l     O .bss	00000002 host_hci_buffer_sz
00020688 l     O .text	00000028 host_hci_event_dispatch
00000000 l    df *ABS*	00000000 host_hci_cmd.c
00019478 l     F .text	00000048 host_hci_cmd_body_le_conn_update
00000000 l    df *ABS*	00000000 ble_att.c
000199a0 l     F .text	00000240 ble_att_rx
20000e00 l     O .bssnz	00000200 ble_att_flat_buf
200023bc l     O .bss	00000002 ble_att_preferred_mtu
00020704 l     O .text	000000d8 ble_att_rx_dispatch
00000000 l    df *ABS*	00000000 ble_att_clt.c
00019e7c l     F .text	00000054 ble_att_clt_tx_req
00019ed0 l     F .text	0000003a ble_att_clt_copy_attr_to_flatbuf
00019f0a l     F .text	0000002a ble_att_clt_init_req
00019f34 l     F .text	00000014 ble_att_clt_append_blob.isra.2
00000000 l    df *ABS*	00000000 ble_att_cmd.c
00000000 l    df *ABS*	00000000 ble_att_svr.c
0001b06e l     F .text	00000016 ble_att_svr_pullup_req_base
0001b084 l     F .text	00000100 ble_att_svr_tx_rsp
0001b184 l     F .text	0000005c ble_att_svr_read_group_type_entry_write
0001b1e0 l     F .text	0000005e ble_att_svr_fill_type_value_no_match
0001b240 l     F .text	0000001c ble_att_svr_prep_free
0001b25c l     F .text	0000007e ble_att_svr_check_security.isra.1
0001b2da l     F .text	0000005a ble_att_svr_write
0001b334 l     F .text	0000007c ble_att_svr_read
0001b46c l     F .text	00000028 ble_att_svr_write_handle
200023c0 l     O .bss	0000001c ble_att_svr_entry_pool
200023dc l     O .bss	00000002 ble_att_svr_id
200023e0 l     O .bss	0000001c ble_att_svr_prep_entry_pool
200023fc l     O .bss	00000004 ble_att_svr_prep_entry_mem
20002400 l     O .bss	00000008 ble_att_svr_list
20002408 l     O .bss	00000004 ble_att_svr_entry_mem
00000000 l    df *ABS*	00000000 ble_svc_gap.c
0001cb14 l     F .text	000000d4 ble_svc_gap_access
2000240c l     O .bss	00000008 ble_svc_gap_pref_conn_params
20000258 l     O .data	00000010 __compound_literal.0
20000268 l     O .data	00000020 ble_svc_gap_name
20000288 l     O .data	00000010 __compound_literal.2
20000298 l     O .data	00000010 __compound_literal.3
200002a8 l     O .data	00000010 __compound_literal.4
200002b8 l     O .data	00000010 __compound_literal.5
200002c8 l     O .data	00000090 __compound_literal.6
20000358 l     O .data	00000010 __compound_literal.1
00020a3c l     O .text	00000020 ble_svc_gap_defs
20002414 l     O .bss	00000001 ble_svc_gap_privacy_flag
20002416 l     O .bss	00000002 ble_svc_gap_appearance
20002418 l     O .bss	00000006 ble_svc_gap_reconnect_addr
00000000 l    df *ABS*	00000000 ble_svc_gatt.c
0001cc38 l     F .text	0000003c ble_svc_gatt_access
20000368 l     O .data	00000010 __compound_literal.0
20000378 l     O .data	00000010 __compound_literal.1
20000388 l     O .data	00000030 __compound_literal.2
00020a7c l     O .text	00000020 ble_svc_gatt_defs
00000000 l    df *ABS*	00000000 ble_store_ram.c
0001cc90 l     F .text	00000064 ble_store_ram_find_sec
0001ccf4 l     F .text	0000005c ble_store_ram_find_cccd
0001cd50 l     F .text	000000c4 ble_store_ram_print_value_sec
0001ce14 l     F .text	00000060 ble_store_ram_print_key_sec
20002420 l     O .bss	00000100 ble_store_ram_cccds
20002520 l     O .bss	00000140 ble_store_ram_our_secs
20002660 l     O .bss	00000140 ble_store_ram_peer_secs
200027a0 l     O .bss	00000004 ble_store_ram_num_cccds
200027a4 l     O .bss	00000004 ble_store_ram_num_our_secs
200027a8 l     O .bss	00000004 ble_store_ram_num_peer_secs
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 log.c
200027ac l     O .bss	00000001 log_inited
200003b8 l     O .data	00000008 g_log_list
00000000 l    df *ABS*	00000000 log_console.c
0001d264 l     F .text	00000004 log_console_read
0001d268 l     F .text	00000004 log_console_walk
0001d26c l     F .text	00000004 log_console_flush
0001d270 l     F .text	00000038 log_console_append
00000000 l    df *ABS*	00000000 stats.c
200027ad l     O .bss	00000001 stats_module_inited
00000000 l    df *ABS*	00000000 libc_stubs.c
00000000 l    df *ABS*	00000000 os_bsp.c
200003c8 l     O .data	0000003c bsp_flash_areas
00000000 l    df *ABS*	00000000 sbrk.c
20000404 l     O .data	00000004 brk
00000000 l    df *ABS*	00000000 flash_map.c
200027b0 l     O .bss	00000004 flash_map
200027b4 l     O .bss	00000004 flash_map_entries
00000000 l    df *ABS*	00000000 hal_os_tick.c
0001d3f8 l     F .text	00000014 nrf52_os_tick_counter.part.0
0001d40c l     F .text	00000038 sub24
0001d444 l     F .text	00000050 nrf52_os_tick_set_ocmp
0001d494 l     F .text	00000058 nrf52_timer_handler
00000000 l    df *ABS*	00000000 hal_system.c
00000000 l    df *ABS*	00000000 hal_uart.c
0001d63c l     F .text	00000024 hal_uart_tx_fill_buf.constprop.1
0001d660 l     F .text	00000080 uart_irq_handler
200027b8 l     O .bss	0000001c uart
00000000 l    df *ABS*	00000000 malloc.c
0001d95c l     F .text	00000004 malloc_lock_nop
0001d960 l     F .text	00000002 malloc_unlock_nop
0001d964 l     F .text	00000060 __free_block
20000408 l     O .data	00000018 __malloc_head
20000420 l     O .data	00000004 malloc_unlock
20000424 l     O .data	00000004 malloc_lock
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 cons_fmt.c
00020c38 l     O .text	00000004 console_file
00020c44 l     O .text	00000008 console_file_ops
00000000 l    df *ABS*	00000000 aes.c
00020c4c l     O .text	00000100 FSb
00020d4c l     O .text	00000400 RT0
0002114c l     O .text	00000400 RT1
0002154c l     O .text	00000400 RT2
0002194c l     O .text	00000400 RT3
00021d4c l     O .text	00000028 RCON
00021d74 l     O .text	00000400 FT0
00022174 l     O .text	00000400 FT1
00022574 l     O .text	00000400 FT2
00022974 l     O .text	00000400 FT3
00022d74 l     O .text	00000100 RSb
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 hal_bsp.c
00022e74 l     O .text	00000004 uart_cfg
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 bpabi.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/../lib/gcc/arm-none-eabi/4.9.3/armv7e-m/crti.o
00000000 l    df *ABS*	00000000 /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/../lib/gcc/arm-none-eabi/4.9.3/armv7e-m/crtn.o
00000000 l    df *ABS*	00000000 ble_ll_supp_cmd.c
00000000 l    df *ABS*	00000000 hci_common.c
00000000 l    df *ABS*	00000000 impure.c
20000428 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 SVC_Table.S
00000000 l       .svc_table	00000000 SVC_End
00000000 l    df *ABS*	00000000 
00022e94 l       .ARM.exidx	00000000 __exidx_end
00022e7c l       .text	00000000 __exidx_start
20000000 l       .bss	00000000 _ram_start
00000000 l       *UND*	00000000 __deregister_frame_info
20000854 l       .data	00000000 __init_array_end
20000854 l       .data	00000000 __preinit_array_end
20000854 l       .data	00000000 __init_array_start
00000000 l       *UND*	00000000 _Jv_RegisterClasses
20000854 l       .data	00000000 __preinit_array_start
00000000 l       *UND*	00000000 __register_frame_info
00018084 g     F .text	00000006 ble_sm_sec_req_parse
0001d058 g     F .text	00000008 htole16
0001afce g     F .text	0000000a ble_att_exec_write_req_write
0000dc5a g     F .text	00000050 ble_ll_conn_hci_rd_chan_map
0001a6c8 g     F .text	000000a4 ble_att_clt_tx_read_group_type
000152ec g     F .text	0000001c ble_hs_conn_find_by_idx
0001a76c g     F .text	000000d0 ble_att_clt_rx_read_group_type
00009a2c g     F .text	00000030 os_arch_start
20003b1c g     O .bss	00000024 ble_hs_stats
20003e14 g       .bss	00000000 __HeapBase
20002f3c g     O .bss	00000008 g_os_task_list
00009828 g     F .text	0000004c os_idle_task
0001a550 g     F .text	00000090 ble_att_clt_tx_read_blob
00015e5a g     F .text	00000006 ble_l2cap_sig_update_rsp_parse
00019606 g     F .text	0000003e host_hci_cmd_build_le_set_adv_data
00009aa4 g     F .text	0000001e os_callout_func_init
0001e684 g     F .text	0000002e .hidden __gnu_uldivmod_helper
0000d1c8 g     F .text	00000040 ble_ll_conn_set_global_chanmap
0001ae20 g     F .text	00000020 ble_att_read_type_rsp_log
20003d14 g     O .bss	000000e4 ble_att_stats
20002d08 g     O .bss	00000006 __rand48_seed
00000000 g       .svc_table	00000000 SVC_Count
00008b8c  w    F .text	00000002 TIMER2_IRQHandler
000094e0 g     F .text	00000014 fmemopen_w
00019364 g     F .text	00000048 host_hci_split_frag
00016a7c g     F .text	00000026 ble_sm_proc_can_advance
000086e0 g     F .text	00000034 print_addr
0000a070 g     F .text	0000004e os_mbuf_copydata
00019264 g     F .text	00000050 ble_hci_transport_ctlr_event_send
20000224 g     O .data	00000008 g_os_mempool_list
0001d098 g     F .text	00000016 le32toh
00009ac4 g     F .text	0000003c os_callout_stop
00012366 g     F .text	00000044 ble_gap_notify_rx_event
00008b8c  w    F .text	00000002 RTC0_IRQHandler
0000b94c g     F .text	00000038 ble_ll_adv_rx_isr_start
20002d10 g     O .bss	00000004 g_console_is_init
00011568 g     F .text	00000128 ble_phy_tx
0001cc84 g     F .text	0000000c ble_svc_gatt_init
0000c8a4 g     F .text	000000a4 ble_ll_conn_event_end
0000e4a0 g     F .text	00000060 ble_ll_ctrl_proc_start
0001d9c4 g     F .text	00000050 add_malloc_block
200037ac g     O .bss	00000040 g_ble_ll_whitelist
0001ae48 g     F .text	0000000c ble_att_read_req_write
00013328 g     F .text	00000034 ble_gattc_rx_err
0000ff14 g     F .text	0000028c ble_ll_scan_rx_pkt_in
0001e6b8 g     F .text	0000029c .hidden __divdi3
0000dcd0 g     F .text	00000056 ble_ll_conn_hci_set_data_len
0000b134 g     F .text	00000070 ble_ll_reset
00009bf2 g     F .text	00000054 os_eventq_put
000153fc g     F .text	00000020 ble_hs_id_set_pub
0000f660 g     F .text	00000090 ble_ll_resolv_list_add
0001ee9d g     O .text	00000010 gatt_svr_chr_gpio
200000d8 g       .data	00000000 __data_start__
00019950 g     F .text	00000020 host_hci_cmd_build_set_addr_res_en
0001af3c g     F .text	00000008 ble_att_write_cmd_parse
000183e8 g     F .text	00000016 ble_store_key_from_value_cccd
0000a270 g     F .text	0000005c os_mbuf_extend
20000854 g     O .bssnz	00000540 bleprph_stack
000136a2 g     F .text	00000030 ble_gattc_rx_read_mult_rsp
0001aeb8 g     F .text	00000002 ble_att_read_mult_req_parse
00009520 g     F .text	00000014 NVIC_SetVector
00008b8c  w    F .text	00000002 SWI0_EGU0_IRQHandler
00008fa0 g     F .text	00000016 hal_gpio_write
0000ebfc g     F .text	0000054c ble_ll_hci_cmd_proc
000143a2 g     F .text	0000009c ble_gatts_count_resources
0001977a g     F .text	00000012 host_hci_cmd_build_read_adv_pwr
0001046c g     F .text	00000022 ble_ll_sched_overlaps_current
20003bc0 g     O .bss	0000001c ble_l2cap_chan_pool
0000998c g     F .text	0000009c os_arch_os_init
00008b7e  w    F .text	00000002 HardFault_Handler
0001ba04 g     F .text	00000254 ble_att_svr_rx_read_type
0001c058 g     F .text	000002c4 ble_att_svr_rx_read_group_type
00013798 g     F .text	00000084 ble_gattc_init
00014b7a g     F .text	00000040 ble_hs_adv_set_flat
00009a5c g     F .text	00000044 os_arch_os_start
200039c8 g     O .bss	00000088 ble_gap_stats
20003ae8 g     O .bss	00000034 ble_gatts_stats
00017a30 g     F .text	00000080 ble_sm_pair_confirm_tx
00015072 g     F .text	0000002a ble_hs_atomic_conn_delete
0001ca6c g     F .text	000000a8 ble_att_svr_init
000146e6 g     F .text	00000038 ble_hci_util_data_hdr_strip
00014484 g     F .text	0000007c ble_gatts_init
0000b0f0 g     F .text	0000000c ble_ll_state_get
20003c10 g     O .bss	00000104 host_hci_cmd_buf
00016a66 g     F .text	00000016 ble_sm_ioact_state
00008b8c  w    F .text	00000002 SWI2_EGU2_IRQHandler
0000fc9c g     F .text	000001e8 ble_ll_scan_rx_isr_end
000183cc g     F .text	0000000c ble_store_read_cccd
0001335c g     F .text	00000026 ble_gattc_rx_mtu
0000a9a4 g     F .text	0000000c SysTick_Handler
0000f270 g     F .text	00000060 ble_ll_hci_ev_conn_update
00008b8c  w    F .text	00000002 GPIOTE_IRQHandler
0001b634 g     F .text	000001c8 ble_att_svr_rx_find_info
0000f47c g     F .text	00000074 ble_ll_rand_data_get
00018394 g     F .text	00000010 ble_store_write
0001bee0 g     F .text	00000178 ble_att_svr_rx_read_mult
00015ca0 g     F .text	0000001c ble_l2cap_sig_create_chan
00010ce8 g     F .text	00000044 ble_hw_rng_init
0000af38 g     F .text	00000020 ble_ll_rx_pdu_in
0000a420 g     F .text	00000052 os_memblock_put
00008b8c  w    F .text	00000002 PWM1_IRQHandler
00009f32 g     F .text	0000001c os_msys_get_pkthdr
0001dad4 g     F .text	00000032 memmove
00019dec g     F .text	00000008 ble_att_get_flat_buf
0000f778 g     F .text	00000020 ble_ll_resolv_set_rpa_tmo
0001a4dc g     F .text	00000074 ble_att_clt_rx_read
0001791c g     F .text	00000034 ble_sm_pair_cmd_log
00014744 g     F .text	00000010 ble_hs_lock
0000f774 g     F .text	00000002 ble_ll_resolv_local_addr_rd
0000a97a g     F .text	0000002a PendSV_Handler
00009452 g     F .text	0000001a snprintf
20002f4c g     O .bss	00000004 g_os_sanity_num_secs
00008b7c  w    F .text	00000002 NMI_Handler
00013ec4 g     F .text	00000070 ble_gatts_connection_broken
000103d4 g     F .text	00000098 ble_ll_sched_run
00010d80 g     F .text	0000000c ble_hw_resolv_list_clear
00008b40 g     F .text	0000000c gatt_svr_init
00008020 g       .text	00000000 __isr_vector_start
0000c1ec g     F .text	00000032 ble_ll_conn_calc_used_chans
0000db80 g     F .text	00000068 ble_ll_conn_hci_disconnect_cmd
0001d138 g     F .text	00000014 log_init
000094b4 g     F .text	0000002a memfile_write
0000990c g     F .text	00000014 os_arch_ctx_sw
00011cbc g     F .text	0000009c ble_gap_heartbeat
0001d34c g     F .text	00000026 stats_init_and_reg
0000f8c4 g     F .text	00000024 ble_ll_resolv_init
00017fc6 g     F .text	00000018 ble_sm_sign_info_write
00009880 g     F .text	00000038 os_init_idle_task
2000023c g       .data	00000000 __aeabi_unwind_cpp_pr0
0000a4fc g     F .text	0000000c os_sched_set_current_task
0001d62c g     F .text	00000010 system_debugger_connected
00008b8c  w    F .text	00000002 POWER_CLOCK_IRQHandler
0001ebc0 g     F .text	0000000c __errno
00015870 g     F .text	0000002c ble_l2cap_parse_hdr
20003b40 g     O .bss	0000001c g_hci_os_event_pool
00022e94 g       .ARM.exidx	00000000 __etext
00011c90 g     F .text	0000002a ble_gap_rx_l2cap_update_req
0001f29e g     O .text	00000016 g_ble_ll_ctrl_pkt_lengths
0000aed8 g     F .text	00000020 ble_ll_set_random_addr
00013270 g     F .text	000000b8 ble_gattc_indicate
0000a8a4 g     F .text	00000058 os_get_uptime_usec
200027d8 g     O .bss	0000000c io_poll_evq
00014918 g     F .text	0000019c ble_hs_init
00010df8 g     F .text	00000004 ble_hw_resolv_list_size
00012204 g     F .text	000000e0 ble_gap_update_params
0000d6e0 g     F .text	00000038 ble_ll_auth_pyld_tmo_event_send
00008d00 g     F .text	0000008c cputime_timer_start
00008b8c  w    F .text	00000002 RADIO_IRQHandler
00019868 g     F .text	00000022 host_hci_cmd_build_le_conn_param_neg_reply
000151c0 g     F .text	00000040 ble_hs_conn_free
00015e60 g     F .text	0000002c ble_l2cap_sig_update_rsp_tx
0000b4ec g     F .text	000000ec ble_ll_adv_set_adv_params
0000a2cc g     F .text	000000c4 os_mbuf_pullup
00013432 g     F .text	0000006a ble_gattc_rx_find_type_value_hinfo
0000d758 g     F .text	000001e8 ble_ll_conn_create
200030ac g     O .bss	00000084 ble_ll_stats
0000aa5c g     F .text	00000090 os_mutex_release
0001aeba g     F .text	00000006 ble_att_read_mult_rsp_write
0001d2d4 g     F .text	00000040 stats_register
00019768 g     F .text	00000012 host_hci_cmd_build_reset
0001375c g     F .text	00000034 ble_gattc_rx_indicate_rsp
0000aa28 g     F .text	00000020 os_sanity_check_register
20003790 g     O .bss	00000014 g_ble_ll_sched_timer
20000854 g       .bssnz	00000000 __bssnz_start__
0000bb74 g     F .text	0000000e ble_ll_adv_reset
0000a83c g     F .text	00000028 os_time_delay
000123aa g     F .text	0000003e ble_gap_notify_tx_event
00016a34 g     F .text	00000014 ble_sm_build_authreq
20003834 g     O .bss	00000020 g_ble_phy_data
0001d168 g     F .text	000000c0 log_append
0001d060 g     F .text	00000010 htole32
00015308 g     F .text	0000000e ble_hs_conn_exists
0000e458 g     F .text	00000048 ble_ll_ctrl_terminate_start
00008b8c  w    F .text	00000002 PDM_IRQHandler
00012030 g     F .text	0000006c ble_gap_adv_set_fields
0001ce74 g     F .text	000000c0 ble_store_ram_read
00017078 g     F .text	0000000c ble_sm_our_pair_rand
00017a0c g     F .text	00000024 ble_sm_pair_confirm_log
0000bb3c g     F .text	0000000c ble_ll_adv_enabled
0001dd40 g     F .text	000003c8 mbedtls_aes_encrypt
0001989c g     F .text	00000048 host_hci_cmd_build_le_start_encrypt
0000a1ae g     F .text	00000088 os_mbuf_prepend
20003b78 g     O .bss	00000024 ble_hs_cfg
0000af58 g     F .text	00000034 ble_ll_acl_data_in
0001c4d8 g     F .text	00000014 ble_att_svr_prep_clear
00013730 g     F .text	0000002c ble_gattc_rx_exec_write_rsp
00010cb0 g     F .text	00000038 ble_hw_encrypt_block
00016f78 g     F .text	00000100 ble_sm_ltk_req_rx
20003624 g     O .bss	000000a0 g_ble_ll_resolv_list
00008b8c  w    F .text	00000002 TEMP_IRQHandler
00009932 g     F .text	0000000a os_arch_in_critical
00008b8c  w    F .text	00000002 QDEC_IRQHandler
0000c510 g     F .text	00000018 ble_ll_conn_auth_pyld_timer_start
000102b8 g     F .text	0000000c ble_ll_scan_get_pdu
00017ba8 g     F .text	00000088 ble_sm_pair_fail_tx
0001d380 g     F .text	00000020 bsp_init
200036c4 g     O .bss	00000001 g_ble_ll_addr_res_enabled
00008b8c  w    F .text	00000002 TIMER3_IRQHandler
000152c0 g     F .text	0000002c ble_hs_conn_find_by_addr
0001fa8f g     O .text	00000010 default_irk
200036d0 g     O .bss	00000040 g_ble_ll_scan_dup_advs
00010d5c g     F .text	00000024 ble_hw_rng_stop
0000ae6c g     F .text	0000006c ble_ll_is_valid_random_addr
0000cd3c g     F .text	00000174 ble_ll_conn_rx_data_pdu
0000c544 g     F .text	00000130 ble_ll_conn_master_init
00009904 g     F .text	00000006 timer_handler
0001ada4 g     F .text	00000028 ble_att_find_type_value_req_log
20003bae g     O .bss	00000010 ble_hs_pvcy_irk
0000a538 g     F .text	00000074 os_sched_sleep
00008ffc g     F .text	00000016 memcpy
000102d4 g     F .text	00000054 ble_ll_scan_init
0001ae54 g     F .text	00000020 ble_att_read_req_log
0000bb0c g     F .text	00000014 ble_ll_adv_get_local_rpa
0000f60c g     F .text	00000014 ble_ll_resolv_list_read_size
0001acd0 g     F .text	00000008 ble_att_mtu_cmd_parse
0000f740 g     F .text	00000030 ble_ll_resolv_enable_cmd
00013ba8 g     F .text	0000031c ble_gatts_register_svcs
0001ac80 g     F .text	00000010 ble_att_error_rsp_parse
0001029c g     F .text	0000000c ble_ll_scan_get_local_rpa
0001c708 g     F .text	0000019c ble_att_svr_rx_exec_write
00015858 g     F .text	00000018 ble_l2cap_chan_mtu
0001e624 g     F .text	00000000 .hidden __aeabi_uldivmod
0001ab88 g     F .text	000000a4 ble_att_clt_tx_indicate
00020bca g     O .text	00000030 g_ble_hci_le_cmd_len
0000a4c0 g     F .text	00000030 os_sched_ctx_sw_hook
00008488 g     F .text	0000000c get_conn_handle
20002d14 g     O .bss	00000004 console_is_midline
00009f4e g     F .text	00000010 os_mbuf_free
00015514 g     F .text	00000024 ble_hs_misc_pkthdr
20000218 g     O .data	00000004 SystemCoreClock
00015838 g     F .text	00000020 ble_l2cap_chan_free
00013678 g     F .text	0000002a ble_gattc_rx_read_blob_rsp
200027e4 g     O .bss	00000002 conn_handle
20003710 g     O .bss	00000040 g_ble_ll_scan_rsp_advs
00008b8c  w    F .text	00000002 SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
0000993c g     F .text	0000003a os_arch_task_stack_init
0001da14 g     F .text	00000094 malloc
0000d718 g     F .text	00000040 ble_ll_disconn_comp_event_send
0001b4cc g     F .text	0000002c ble_att_svr_read_handle
0001aff8 g     F .text	00000002 ble_att_exec_write_rsp_parse
20002cec g     O .bss	00000014 g_cputime
00008e6c g     F .text	0000003c cputime_set_ocmp
00009cd0 g     F .text	00000048 __assert_func
00019682 g     F .text	00000024 host_hci_cmd_build_set_event_mask
0000f620 g     F .text	00000040 ble_ll_resolv_list_find
00014088 g     F .text	000000b0 ble_gatts_rx_indicate_ack
00019bf4 g     F .text	000001f8 ble_att_inc_tx_stat
0000a65c g     F .text	0000003c os_sched_wakeup_ticks
0000c970 g     F .text	0000008c ble_ll_init_rx_pkt_in
00008b84  w    F .text	00000002 UsageFault_Handler
0000c190 g     F .text	00000024 ble_ll_conn_sm_get
0000942c g     F .text	00000026 vsnprintf
20002f2c g     O .bss	00000008 g_callout_list
000155d8 g     F .text	00000060 ble_hs_pvcy_add_entry
00017c80 g     F .text	00000080 ble_sm_enc_info_tx
0001024c g     F .text	0000001c ble_ll_scan_can_chg_whitelist
00010d2c g     F .text	00000030 ble_hw_rng_start
00014234 g     F .text	00000084 ble_gatts_tx_notifications
0001349c g     F .text	0000005e ble_gattc_rx_find_type_value_complete
0001fa44 g     O .text	00000024 ble_hs_cfg_dflt
0000fc60 g     F .text	0000003c ble_ll_scan_rx_isr_start
0000ae44 g     F .text	00000010 ble_ll_chk_txrx_time
00014634 g     F .text	00000010 ble_hci_cmd_rx_ack
200033b8 g     O .bss	00000012 g_ble_ll_conn_params
00008b8c  w    F .text	00000002 UARTE0_UART0_IRQHandler
0000927e g     F .text	00000190 tfp_format
2000fe50 g       *ABS*	00000000 __HeapLimit
20001000 g       .bss	00000000 __bss_start__
00014754 g     F .text	0000000c ble_hs_unlock
0001affa g     F .text	00000006 ble_att_exec_write_rsp_write
0001afc8 g     F .text	00000006 ble_att_exec_write_req_parse
00014858 g     F .text	00000024 ble_hs_event_enqueue
0001a9e8 g     F .text	00000094 ble_att_clt_tx_exec_write
0001a0e0 g     F .text	000000f4 ble_att_clt_rx_find_info
00008b8c  w    F .text	00000002 TIMER4_IRQHandler
000123e8 g     F .text	00000068 ble_gap_subscribe_event
00017e3c g     F .text	00000080 ble_sm_id_info_tx
0001812c g     F .text	00000068 ble_sm_lgcy_io_action
00017c30 g     F .text	00000012 ble_sm_enc_info_parse
0001af72 g     F .text	00000012 ble_att_prep_write_req_write
0000ebd0 g     F .text	0000002c ble_ll_hci_is_event_enabled
0000c1b4 g     F .text	00000038 ble_ll_conn_calc_window_widening
0000b6f8 g     F .text	00000024 ble_ll_adv_set_adv_data
00011098 g     F .text	00000054 ble_phy_encrypt_enable
00011128 g     F .text	0000000c ble_phy_set_txend_cb
00010d8c g     F .text	0000003c ble_hw_resolv_list_add
0000f4f0 g     F .text	0000002c ble_ll_rand_prand_get
00015318 g     F .text	00000084 ble_hs_conn_addrs
20002f34 g     O .bss	00000004 g_current_task
0000cc98 g     F .text	0000003c ble_ll_conn_timeout
00009920 g     F .text	0000000c os_arch_save_sr
000142b8 g     F .text	000000ea ble_gatts_bonding_restored
0000f5ec g     F .text	00000020 ble_ll_resolv_list_clr
0000a390 g     F .text	00000068 os_mempool_init
000193ac g     F .text	000000cc host_hci_data_tx
0001469a g     F .text	0000004c ble_hci_util_rand
0000a864 g     F .text	00000040 os_gettimeofday
200027e8 g     O .bss	0000001c bleprph_mbuf_mpool
20002f44 g     O .bss	00000001 g_task_id
0000dcaa g     F .text	00000026 ble_ll_conn_hci_set_chan_class
0000faec g     F .text	0000001e ble_ll_scan_is_dup_adv
000178be g     F .text	00000038 ble_sm_pair_cmd_is_valid
200003c0 g     O .data	00000008 g_stats_registry
00011d58 g     F .text	000002d8 ble_gap_adv_start
0001aae4 g     F .text	000000a4 ble_att_clt_tx_notify
200035f8 g     O .bss	0000000c g_ble_ll_rnum_data
0001bc58 g     F .text	00000134 ble_att_svr_rx_read
0001aee0 g     F .text	00000024 ble_att_read_group_type_req_log
00008f3c g     F .text	00000010 cputime_get32
0000c9fc g     F .text	0000029c ble_ll_init_rx_isr_end
0001d74c g     F .text	00000050 hal_uart_blocking_tx
2000021c g     O .data	00000008 g_msys_pool_list
0000e298 g     F .text	0000001a ble_ll_ctrl_is_start_enc_rsp
200033cc g     O .bss	00000004 g_ble_ll_conn_cur_sm
00017c5c g     F .text	00000024 ble_sm_enc_info_log
00008aa0 g     F .text	0000008c io_poll_task_handler
0000bb82 g     F .text	00000006 ble_ll_conn_spvn_timer_cb
00009f70 g     F .text	0000009e os_mbuf_append
0001a44c g     F .text	00000090 ble_att_clt_tx_read
0000a918 g     F .text	00000016 os_set_env
0001ae16 g     F .text	0000000a ble_att_read_type_rsp_write
0001a94c g     F .text	0000009c ble_att_clt_rx_prep_write
000198e4 g     F .text	0000005a host_hci_cmd_build_add_to_resolv_list
0001ae40 g     F .text	00000008 ble_att_read_req_parse
0001ebcc g     F .text	00000050 __libc_init_array
0001cc1c g     F .text	00000010 ble_svc_gap_register
00014500 g     F .text	00000128 ble_hci_cmd_tx
0001570c g     F .text	0000000c ble_hs_pvcy_our_irk
0001f098 g     O .text	00000008 MemFile_methods
20002f50 g     O .bss	0000000c g_os_sanity_check_mu
00013554 g     F .text	00000088 ble_gattc_rx_read_group_type_adata
00014628 g     F .text	0000000a ble_hci_cmd_tx_empty_ack
0001e954 g     F .text	0000026a .hidden __udivdi3
000175d8 g     F .text	000000a4 ble_sm_alg_s1
000080f8 g     F .text	00000000 _mainCRTStartup
20003ba8 g     O .bss	00000006 ble_hs_misc_null_addr
200037a4 g     O .bss	00000008 g_ble_ll_sched_q
20002d00 g     O .bss	00000008 g_cputimer_q
0000e054 g     F .text	00000006 ble_ll_ctrl_proc_rsp_timer_cb
0001d3a0 g     F .text	00000044 _sbrk
0001adec g     F .text	00000024 ble_att_read_type_req_log
000110ec g     F .text	00000010 ble_phy_encrypt_set_pkt_cntr
000183e0 g     F .text	00000008 ble_store_delete_cccd
0001d4ec g     F .text	00000048 os_tick_idle
0000c7e4 g     F .text	000000c0 ble_ll_conn_end
0001e61c g     F .text	00000008 bsp_uart_config
0001db1c g     F .text	0000003c console_printf
000191d8 g     F .text	0000001c host_hci_set_buf_size
0000b120 g     F .text	00000012 ble_ll_mbuf_init
0000c77c g     F .text	00000068 ble_ll_conn_datalen_update
0000972c g     F .text	00000028 console_blocking_mode
00008b8c  w    F .text	00000002 I2S_IRQHandler
00019558 g     F .text	0000001c host_hci_cmd_send_buf
0001ec1c g     F .text	00000000 _init
0001443e g     F .text	00000044 ble_gatts_count_cfg
20002804 g     O .bss	0000000c bleprph_evq
00010b68 g     F .text	00000018 ble_hw_whitelist_clear
0000bac0 g     F .text	00000034 ble_ll_adv_rx_pkt_in
00008ea8 g     F .text	00000094 cputime_hw_init
000097c0 g     F .text	00000068 console_init
00008b8c  w    F .text	00000002 SWI4_EGU4_IRQHandler
0001324c g     F .text	0000001e ble_gattc_notify
0000f178 g     F .text	0000000a ble_hci_transport_host_acl_data_send
000158cc g     F .text	000000f4 ble_l2cap_rx
0001d534 g     F .text	000000c8 os_tick_init
00017ed2 g     F .text	00000016 ble_sm_id_addr_info_write
00010730 g     F .text	000000d0 ble_ll_sched_slave_new
00000000  w      *UND*	00000000 __libc_fini_array
0001ad12 g     F .text	00000012 ble_att_find_info_req_write
0001aa7c g     F .text	00000068 ble_att_clt_rx_exec_write
00016478 g     F .text	00000006 ble_sm_gen_pair_rand
00008b8c  w    F .text	00000002 TIMER0_IRQHandler
000098b8 g     F .text	00000030 os_init
200036c5 g     O .bss	00000001 g_ble_ll_resolv_list_size
00013f34 g     F .text	0000009c ble_gatts_start
00008b4c g     F .text	00000030 Reset_Handler
00010294 g     F .text	00000008 ble_ll_scan_get_peer_rpa
00017adc g     F .text	00000024 ble_sm_pair_random_log
0000ceb0 g     F .text	00000244 ble_ll_conn_rx_isr_end
00017316 g     F .text	0000009c ble_sm_enc_initiate
000136f4 g     F .text	0000003c ble_gattc_rx_prep_write_rsp
0001af64 g     F .text	0000000e ble_att_prep_write_req_parse
00010c90 g     F .text	00000014 ble_hw_whitelist_disable
00010800 g     F .text	000000b8 ble_ll_sched_adv_new
00010ca4 g     F .text	0000000c ble_hw_whitelist_match
0000dbe8 g     F .text	0000003e ble_ll_conn_hci_rd_rem_ver_cmd
200036c8 g     O .bss	00000004 g_ble_ll_resolv_rpa_tmo
00014030 g     F .text	00000056 ble_gatts_send_next_indicate
00009ecc g     F .text	0000000c os_mbuf_pool_init
0001b494 g     F .text	00000038 ble_att_svr_find_by_uuid
000150fc g     F .text	00000050 ble_hs_cfg_init
0000a9b0 g     F .text	0000001e os_default_irq_asm
0000a698 g     F .text	0000000c os_sched_next_task
0000a474 g     F .text	0000004c os_sched_insert
0000fbac g     F .text	000000b4 ble_ll_scan_event_proc
00009b00 g     F .text	00000064 os_callout_reset
0000fb0c g     F .text	00000054 ble_ll_scan_add_dup_adv
00019df4 g     F .text	00000026 ble_att_mtu
0001993e g     F .text	00000012 host_hci_cmd_build_clear_resolv_list
00019f48 g     F .text	00000074 ble_att_clt_rx_error
0001b014 g     F .text	00000020 ble_att_notify_req_log
000105d4 g     F .text	0000015c ble_ll_sched_master_new
00009412 g     F .text	0000001a fprintf
000178a4 g     F .text	0000001a ble_sm_pair_cmd_parse
0001cc74 g     F .text	00000010 ble_svc_gatt_register
0000b5d8 g     F .text	00000028 ble_ll_adv_scheduled
0000aa48 g     F .text	00000014 os_mutex_init
00013ff0 g     F .text	00000040 ble_gatts_conn_init
0001b424 g     F .text	00000026 ble_att_svr_register_uuid16
00008ca4 g     F .text	00000010 cputime_init
20001000 g       .bssnz	00000000 __bssnz_end__
0000aef8 g     F .text	00000028 ble_ll_is_our_devaddr
00010a98 g     F .text	0000000a ble_ll_whitelist_match
00018292 g     F .text	000000f0 ble_sm_lgcy_random_rx
00009874 g     F .text	0000000c os_started
00008b8c  w    F .text	00000002 TIMER1_IRQHandler
00016f6c g     F .text	0000000c ble_sm_enc_key_refresh_rx
0000a620 g     F .text	0000003c os_sched_os_timer_exp
20000000 g       .vector_relocation	00000000 __vector_tbl_reloc__
00014644 g     F .text	0000001c ble_hci_cmd_init
00010a8c g     F .text	0000000c ble_ll_whitelist_read_size
0000f770 g     F .text	00000004 ble_ll_resolv_peer_addr_rd
00015cbc g     F .text	0000006c ble_l2cap_sig_heartbeat
00008f4c g     F .text	00000028 hal_gpio_init_in
20003750 g     O .bss	00000040 g_ble_ll_scan_sm
0000da5c g     F .text	000000fc ble_ll_conn_hci_param_reply
00017b00 g     F .text	00000080 ble_sm_pair_random_tx
0000a02a g     F .text	00000046 os_mbuf_appendfrom
00008b8c  w    F .text	00000002 PWM2_IRQHandler
20002f5c g     O .bss	00000050 g_os_sanity_task
0000e554 g     F .text	00000030 ble_ll_ctrl_proc_stop
0001b7fc g     F .text	00000208 ble_att_svr_rx_find_type_value
0001db64 g     F .text	000001dc mbedtls_aes_setkey_enc
0000f854 g     F .text	00000064 ble_ll_resolv_rpa
20002810 g     O .bss	00000006 g_random_addr
20000854 g       .data	00000000 __data_end__
0001d14c g     F .text	00000018 log_register
00017ac2 g     F .text	00000018 ble_sm_pair_random_write
0001d0ae g     F .text	00000058 le64toh
000131d0 g     F .text	0000007c ble_gattc_notify_custom
000179f2 g     F .text	00000018 ble_sm_pair_confirm_write
00008b8c  w    F .text	00000002 ECB_IRQHandler
000109e4 g     F .text	0000000c ble_ll_sched_stop
0001b000 g     F .text	00000008 ble_att_notify_req_parse
0000d500 g     F .text	00000108 ble_ll_conn_comp_event_send
000174dc g     F .text	0000001c ble_sm_create_chan
00017520 g     F .text	00000060 ble_sm_init
000116ac g     F .text	00000020 ble_phy_resolv_list_enable
0000f184 g     F .text	0000002c ble_ll_hci_init
0001b4f8 g     F .text	0000013c ble_att_svr_rx_mtu
0000af8c g     F .text	0000008c ble_ll_rx_start
0001b44c g     F .text	0000000c ble_att_svr_prev_handle
00011524 g     F .text	00000044 ble_phy_tx_set_start_time
00018384 g     F .text	00000010 ble_store_read
20002f48 g     O .bss	00000004 g_os_time
00019e1a g     F .text	0000000a ble_att_set_peer_mtu
00019e24 g     F .text	00000024 ble_att_create_chan
0001d6e0 g     F .text	00000024 hal_uart_init_cbs
20003e14 g       .bss	00000000 __bss_end__
0000c4e8 g     F .text	00000028 ble_ll_conn_wfr_timer_exp
00009ed8 g     F .text	0000002c os_mbuf_get
00008b8c  w    F .text	00000002 SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
000196a6 g     F .text	00000024 host_hci_cmd_build_set_event_mask2
000197be g     F .text	00000032 host_hci_cmd_build_le_lt_key_req_reply
00010c74 g     F .text	0000001c ble_hw_whitelist_enable
00017218 g     F .text	0000009c ble_sm_heartbeat
00017148 g     F .text	0000000c ble_sm_peer_pair_rand
0000b1a4 g     F .text	000000ac ble_ll_init
0001af34 g     F .text	00000008 ble_att_write_req_parse
0001518e g     F .text	00000030 ble_hs_conn_chan_insert
00010dc8 g     F .text	00000030 ble_hw_resolv_list_rmv
00008b8c g     F .text	00000002 Default_Handler
000080f8 g     F .text	00000000 _start
00010bec g     F .text	00000088 ble_hw_whitelist_rmv
0001ae94 g     F .text	00000024 ble_att_read_blob_req_log
00015178 g     F .text	00000016 ble_hs_conn_chan_find
20003df8 g     O .bss	00000010 g_stats_stats
0000a92e g     F .text	00000006 os_arch_init_task_stack
00017fb4 g     F .text	00000012 ble_sm_sign_info_parse
0000e2dc g     F .text	0000001c ble_ll_ctrl_conn_param_reply
0001d106 g     F .text	0000001a swap_in_place
0000ccd4 g     F .text	00000006 ble_ll_conn_spvn_timeout
0001978c g     F .text	00000012 host_hci_cmd_build_le_create_conn_cancel
000197f0 g     F .text	00000020 host_hci_cmd_build_le_lt_key_req_neg_reply
00018004 g     F .text	00000080 ble_sm_sign_info_tx
000192b4 g     F .text	000000b0 host_hci_data_rx
200000d8 g     O .data	00000006 g_dev_addr
000191f4 g     F .text	00000048 host_hci_event_rx
00019574 g     F .text	00000092 host_hci_cmd_build_le_set_adv_params
0001f036 g     O .text	00000010 gatt_svr_chr_gpio_notif
0001ac90 g     F .text	00000014 ble_att_error_rsp_write
0000b0fc g     F .text	0000000c ble_ll_event_send
00010268 g     F .text	00000020 ble_ll_scan_initiator_start
000172b4 g     F .text	00000062 ble_sm_pair_initiate
20003854 g     O .bss	0000010c g_nrf_encrypt_scratchpad
00017ebc g     F .text	00000016 ble_sm_id_addr_info_parse
000108b8 g     F .text	000000b0 ble_ll_sched_adv_reschedule
20002dd4 g     O .bss	00000050 g_idle_task
00008f74 g     F .text	0000002c hal_gpio_init_out
00008fb6 g     F .text	00000012 hal_gpio_read
0000b0e4 g     F .text	0000000c ble_ll_state_set
0000b71c g     F .text	000000cc ble_ll_adv_conn_req_rxd
20001e90 g     O .bss	00000004 g_os_sanity_check_list
00015294 g     F .text	00000014 ble_hs_conn_find
0001541c g     F .text	0000004c ble_hs_id_addr
000178f6 g     F .text	00000024 ble_sm_pair_cmd_write
0001d704 g     F .text	00000048 hal_uart_start_tx
000183a4 g     F .text	00000010 ble_store_delete
0000a3f8 g     F .text	00000028 os_memblock_get
0000a5ac g     F .text	00000074 os_sched_wakeup
0001d08e g     F .text	0000000a le16toh
0000fef4 g     F .text	00000020 ble_ll_scan_wfr_timer_exp
00009e34 g     F .text	00000024 os_mqueue_get
00013382 g     F .text	00000062 ble_gattc_rx_find_info_idata
0001e4fc g     F .text	00000010 os_sem_init
00010490 g     F .text	00000020 ble_ll_sched_insert_if_empty
0001cbf0 g     F .text	0000002c ble_svc_gap_device_name_set
00000000  w      *UND*	00000000 software_init_hook
0001121c g     F .text	0000003c ble_phy_disable
00009d18 g     F .text	00000090 os_default_irq
00017ab0 g     F .text	00000012 ble_sm_pair_random_parse
200037ec g     O .bss	00000001 g_nrf_num_irks
000155a8 g     F .text	00000010 ble_hs_misc_addr_type_to_id
0000dc26 g     F .text	00000034 ble_ll_conn_hci_rd_rssi
0001ae10 g     F .text	00000006 ble_att_read_type_rsp_parse
0000c178 g     F .text	00000018 ble_ll_conn_find_active_conn
000179e0 g     F .text	00000012 ble_sm_pair_confirm_parse
000174f8 g     F .text	00000026 ble_sm_connection_broken
00013140 g     F .text	00000090 ble_gattc_heartbeat
0001974c g     F .text	0000001c host_hci_cmd_build_le_set_scan_enable
00013640 g     F .text	00000038 ble_gattc_rx_read_rsp
20002f38 g     O .bss	00000004 g_os_last_ctx_sw_time
00017d00 g     F .text	00000018 ble_sm_master_id_parse
0001e50c g     F .text	00000060 os_sem_release
200033d0 g     O .bss	00000008 g_ble_ll_conn_free_list
000109c0 g     F .text	00000024 ble_ll_sched_next_time
0001ad04 g     F .text	0000000e ble_att_find_info_req_parse
0000b108 g     F .text	0000000a ble_ll_read_supp_states
00008fe0 g     F .text	0000001c memcmp
00009978 g     F .text	00000014 os_arch_init
0001487c g     F .text	0000000c ble_hs_notifications_sched
0001ad58 g     F .text	00000020 ble_att_find_info_rsp_log
00015d8c g     F .text	00000046 ble_l2cap_sig_init_cmd
0001ad24 g     F .text	00000024 ble_att_find_info_req_log
000133e4 g     F .text	0000004e ble_gattc_rx_find_info_complete
00008c50 g     F .text	00000054 cputime_chk_expiration
00011134 g     F .text	00000040 ble_phy_txpwr_set
0001e6b4  w    F .text	00000002 .hidden __aeabi_ldiv0
000196ca g     F .text	00000022 host_hci_cmd_build_disconnect
00018568 g     F .text	00000804 host_hci_dbg_event_disp
00019710 g     F .text	00000012 host_hci_cmd_build_le_read_buffer_size
000180ac g     F .text	00000080 ble_sm_sec_req_tx
0000d208 g     F .text	000001b0 ble_ll_conn_slave_start
00012330 g     F .text	00000036 ble_gap_enc_event
0000baf4 g     F .text	00000018 ble_ll_adv_can_chg_whitelist
000148b0 g     F .text	00000034 ble_hs_rx_data
0000c15a g     F .text	0000000a ble_ll_conn_is_lru
0000af20 g     F .text	0000000c ble_ll_wfr_enable
00014138 g     F .text	000000a4 ble_gatts_chr_updated
000097b4 g     F .text	0000000c console_is_init
00009040 g     F .text	00000014 srand48
00010aa4 g     F .text	00000050 ble_ll_whitelist_add
0000c528 g     F .text	0000001a ble_ll_conn_auth_pyld_timer_cb
00008b2c g     F .text	00000014 gatt_svr_register
0001e56c g     F .text	000000b0 os_sem_pend
00015718 g     F .text	000000f8 ble_hs_startup_go
00014888 g     F .text	00000028 ble_hs_start
0000b4e0 g     F .text	0000000c ble_ll_adv_halt
20003130 g     O .bss	00000140 g_ble_ll_stack
0000b460 g     F .text	0000007e ble_ll_adv_chk_rpa_timeout
0001808c g     F .text	00000020 ble_sm_sec_req_log
000110fc g     F .text	0000002c ble_phy_encrypt_disable
0000dd26 g     F .text	0000005e ble_ll_conn_hci_le_start_encrypt
00019722 g     F .text	00000012 host_hci_cmd_build_le_read_loc_supp_feat
00009e58 g     F .text	0000003c os_mqueue_put
0000eb68 g     F .text	00000034 ble_ll_hci_send_noop
00009e94 g     F .text	00000038 os_msys_register
00014660 g     F .text	0000003a ble_hci_util_read_adv_tx_pwr
000102a8 g     F .text	00000010 ble_ll_scan_set_peer_rpa
20002e24 g     O .bss	00000004 g_os_idle_ctr
0000ddf4 g     F .text	00000068 ble_ll_conn_hci_wr_auth_pyld_tmo
00008b8c  w    F .text	00000002 SAADC_IRQHandler
0000b984 g     F .text	0000013c ble_ll_adv_event_done
0000e256 g     F .text	00000012 ble_ll_calc_session_key
00008dc0 g     F .text	00000060 cputime_timer_stop
0001169c g     F .text	0000000c ble_phy_rx_started
00009012 g     F .text	00000010 memset
0000e268 g     F .text	00000030 ble_ll_ctrl_enc_allowed_pdu
00008020 g       .text	000000d8 __isr_vector
0001c31c g     F .text	00000120 ble_att_svr_rx_write
00008494 g     F .text	0000024c main
0001c958 g     F .text	00000114 ble_att_svr_rx_indicate
0000a154 g     F .text	0000005a os_mbuf_memcmp
0000dd84 g     F .text	00000070 ble_ll_conn_hci_le_ltk_reply
000109f0 g     F .text	00000018 ble_ll_sched_init
0000f534 g     F .text	00000024 ble_ll_rand_init
0000f338 g     F .text	00000058 ble_ll_hci_ev_ltk_req
0000fa84 g     F .text	00000006 ble_ll_scan_timer_cb
20002818 g     O .bss	0000000c bleprph_mbuf_pool
0001ad78 g     F .text	00000014 ble_att_find_type_value_req_parse
00008b8c  w    F .text	00000002 CCM_AAR_IRQHandler
0001e108 g     F .text	000003dc mbedtls_aes_decrypt
00008b8c  w    F .text	00000002 WDT_IRQHandler
0000ac20 g     F .text	00000218 ble_ll_task
0001afa4 g     F .text	00000024 ble_att_prep_write_cmd_log
0001979e g     F .text	00000020 host_hci_cmd_build_le_conn_update
0000d4bc g     F .text	00000044 ble_ll_conn_hci_chk_conn_params
20003270 g     O .bss	00000050 g_ble_ll_task
0000f3e0 g     F .text	00000058 ble_ll_hci_ev_rd_rem_ver
0001209c g     F .text	00000060 ble_gap_terminate
0000a934 g     F .text	00000046 SVC_Handler
00012450 g     F .text	00000048 ble_gap_init
00018244 g     F .text	0000004e ble_sm_lgcy_random_exec
0000eb9c g     F .text	00000034 ble_ll_hci_is_le_event_enabled
00017d18 g     F .text	0000003c ble_sm_master_id_log
0000f6f0 g     F .text	00000050 ble_ll_resolv_list_rmv
0000f210 g     F .text	00000060 ble_ll_hci_ev_rem_conn_parm_req
20003960 g     O .bss	00000044 ble_phy_stats
0000d940 g     F .text	00000030 ble_ll_conn_hci_read_rem_features
00008cb4 g     F .text	0000000c cputime_usecs_to_ticks
0001eee0 g     O .text	00000010 gatt_svr_svc_gpio
00000000  w      *UND*	00000000 hardware_init_hook
00009c46 g     F .text	0000004c os_eventq_get
0001db58 g     F .text	0000000a mbedtls_aes_init
0001d2a8 g     F .text	0000002c log_console_handler_init
0000b6d4 g     F .text	00000024 ble_ll_adv_set_scan_rsp_data
0000a8fc g     F .text	0000001a os_time_ms_to_ticks
0001ae82 g     F .text	00000012 ble_att_read_blob_req_write
00010288 g     F .text	0000000c ble_ll_scan_enabled
00009bac g     F .text	00000034 os_callout_wakeup_ticks
00011a58 g     F .text	00000074 ble_gap_rx_adv_report
0001589c g     F .text	00000030 ble_l2cap_prepend_hdr
00008b8c  w    F .text	00000002 SWI5_EGU5_IRQHandler
0001cf34 g     F .text	00000124 ble_store_ram_write
00017b88 g     F .text	00000020 ble_sm_pair_fail_log
200036cc g     O .bss	00000001 g_ble_ll_resolv_list_cnt
0000bb48 g     F .text	0000002c ble_ll_adv_init
0000a0be g     F .text	00000096 os_mbuf_adj
000102c4 g     F .text	00000010 ble_ll_scan_whitelist_enabled
00017fe0 g     F .text	00000024 ble_sm_sign_info_log
0000f148 g     F .text	00000030 ble_hci_transport_host_cmd_send
0000fb60 g     F .text	0000004c ble_ll_scan_sm_stop
20003bdc g     O .bss	00000034 ble_l2cap_stats
00014808 g     F .text	00000024 ble_hs_heartbeat_sched
000148e4 g     F .text	00000034 ble_hs_tx_data
0001db06 g     F .text	00000014 strcmp
0001ae74 g     F .text	0000000e ble_att_read_blob_req_parse
00016f5c g     F .text	00000010 ble_sm_enc_change_rx
0000a4f0 g     F .text	0000000c os_sched_get_current_task
000097a8 g     F .text	0000000c console_write
00017c42 g     F .text	00000018 ble_sm_enc_info_write
0000bb28 g     F .text	00000014 ble_ll_adv_wfr_timer_exp
000122e4 g     F .text	0000004c ble_gap_passkey_event
00008fd0 g     F .text	00000010 lrand48
00010f54 g     F .text	00000144 ble_phy_init
0001a2e8 g     F .text	000000a8 ble_att_clt_tx_read_type
0001ad4e g     F .text	0000000a ble_att_find_info_rsp_write
00008b90 g     F .text	000000c0 SystemInit
00008b8c  w    F .text	00000002 RNG_IRQHandler
00016c7c g     F .text	0000014c ble_sm_process_result
0001b03c g     F .text	0000000c ble_att_indicate_req_write
000154a4 g     F .text	00000040 ble_hs_log_mbuf
0001acd8 g     F .text	0000000c ble_att_mtu_rsp_write
0001adda g     F .text	00000012 ble_att_read_type_req_write
00009c92 g     F .text	0000003e os_eventq_remove
00010af4 g     F .text	00000034 ble_ll_whitelist_rmv
200032c0 g     O .bss	00000050 g_ble_ll_data
0001ec28 g     F .text	00000000 _fini
0001aece g     F .text	00000012 ble_att_read_group_type_req_write
000152a8 g     F .text	00000018 ble_hs_conn_insert
000116a8 g     F .text	00000004 ble_phy_max_data_pdu_pyld
0001cc2c g     F .text	0000000c ble_svc_gap_init
0001a83c g     F .text	00000054 ble_att_clt_rx_write
000104b0 g     F .text	00000124 ble_ll_sched_conn_reschedule
0001ace4 g     F .text	00000020 ble_att_mtu_cmd_log
00009022 g     F .text	0000001e sprintf
200033d8 g     O .bss	00000004 g_ble_ll_conn_create_sm
0001af84 g     F .text	0000000e ble_att_prep_write_rsp_parse
0001af14 g     F .text	00000020 ble_att_read_group_type_rsp_log
0001ac2c g     F .text	00000054 ble_att_clt_rx_indicate
0001a1d4 g     F .text	00000098 ble_att_clt_tx_find_type_value
0001a5e0 g     F .text	00000074 ble_att_clt_rx_read_blob
0000a508 g     F .text	00000030 os_sched
0001a26c g     F .text	0000007c ble_att_clt_rx_find_type_value
00000000  w      *UND*	00000000 atexit
000184c4 g     F .text	00000030 ble_uuid_16_to_128
0001af04 g     F .text	00000006 ble_att_read_group_type_rsp_parse
0001d3e4 g     F .text	00000014 flash_area_init
0001a390 g     F .text	000000bc ble_att_clt_rx_read_type
0000d180 g     F .text	00000048 ble_ll_conn_tx_pkt_in
20003310 g     O .bss	000000a8 g_ble_ll_adv_sm
0000aaec g     F .text	000000e0 os_mutex_pend
000196ec g     F .text	00000024 host_hci_cmd_build_le_set_event_mask
20003b5c g     O .bss	0000001c g_hci_evt_pool
00000000 g       .svc_table	00000000 SVC_Table
20002824 g     O .bss	00000400 io_poll_stack
00008b8c  w    F .text	00000002 RTC2_IRQHandler
000164ec g     F .text	00000040 ble_sm_proc_find
0000f8b8 g     F .text	0000000c ble_ll_resolv_enabled
000134fc g     F .text	0000002c ble_gattc_rx_read_type_adata
0001b034 g     F .text	00000008 ble_att_indicate_req_parse
20010000 g       *ABS*	00000000 __StackTop
00017ee8 g     F .text	0000004c ble_sm_id_addr_info_log
20000850 g     O .data	00000004 _impure_ptr
200037f0 g     O .bss	00000040 g_nrf_irk_list
0000f390 g     F .text	00000050 ble_ll_hci_ev_rd_rem_used_feat
00009e14 g     F .text	00000020 os_mqueue_init
00018460 g     F .text	00000008 ble_store_write_our_sec
0001af92 g     F .text	00000012 ble_att_prep_write_rsp_write
0000eabe g     F .text	00000098 ble_ll_ctrl_tx_done
0001558a g     F .text	0000001e ble_hs_misc_conn_chan_find_reqd
00008b8c  w    F .text	00000002 PWM0_IRQHandler
00008b8c  w    F .text	00000002 SWI3_EGU3_IRQHandler
000194c0 g     F .text	00000098 host_hci_cmd_send
0000e444 g     F .text	00000014 ble_ll_ctrl_is_terminate_ind
0000f1b0 g     F .text	00000060 ble_ll_hci_ev_datalen_chg
0001c8a4 g     F .text	000000b4 ble_att_svr_rx_notify
00009754 g     F .text	00000054 console_file_write
00019e48 g     F .text	00000034 ble_att_init
0001988a g     F .text	00000012 host_hci_cmd_build_le_rand
00015468 g     F .text	0000003c ble_hs_id_use_addr
0001514c g     F .text	0000002c ble_hs_conn_can_alloc
0000abcc g     F .text	00000038 ble_ll_wfr_timer_exp
0001509c g     F .text	00000028 ble_hs_atomic_conn_flags
0001cbe8 g     F .text	00000008 ble_svc_gap_device_name
20002c24 g     O .bss	0000000c io_ev
00010b80 g     F .text	0000006c ble_hw_whitelist_add
00015d28 g     F .text	00000064 ble_l2cap_sig_init
0000ccdc g     F .text	00000060 ble_ll_conn_rx_isr_start
00009b64 g     F .text	00000048 os_callout_tick
000184f4 g     F .text	00000036 ble_uuid_append
0001539c g     F .text	00000060 ble_hs_conn_init
000080f8 g       .text	00000000 __isr_vector_end
000098e8 g     F .text	0000001c os_start
00015e28 g     F .text	00000020 ble_l2cap_sig_reject_invalid_cid_tx
0000ea70 g     F .text	0000004e ble_ll_ctrl_reject_ind_send
0000ae54 g     F .text	00000016 ble_ll_is_rpa
000120fc g     F .text	00000108 ble_gap_rx_param_req
0001d120 g     F .text	00000018 swap_buf
0000e2b2 g     F .text	0000002a ble_ll_ctrl_start_enc_send
0000b114 g     F .text	0000000c ble_ll_read_supp_features
0000c674 g     F .text	00000108 ble_ll_conn_sm_new
0000b7e8 g     F .text	00000164 ble_ll_adv_rx_isr_end
0000db58 g     F .text	00000028 ble_ll_conn_create_cancel
0000d970 g     F .text	000000ec ble_ll_conn_hci_update
0000f438 g     F .text	00000044 ble_ll_rand_sample
000183c0 g     F .text	0000000c ble_store_read_peer_sec
00008b8c  w    F .text	00000002 RTC1_IRQHandler
0001e4e4 g     F .text	00000018 mbedtls_aes_crypt_ecb
0000af2c g     F .text	0000000c ble_ll_wfr_disable
20003a50 g     O .bss	00000098 ble_gattc_stats
0001af0a g     F .text	0000000a ble_att_read_group_type_rsp_write
0001d79c g     F .text	000001c0 hal_uart_config
00015dd2 g     F .text	0000000e ble_l2cap_sig_hdr_parse
0000c21e g     F .text	00000078 ble_ll_conn_calc_dci
0001ad48 g     F .text	00000006 ble_att_find_info_rsp_parse
0001852a g     F .text	0000003c ble_uuid_extract
00017f34 g     F .text	00000080 ble_sm_id_addr_info_tx
00010b2c g     F .text	00000004 ble_ll_whitelist_disable
20010000 g       *ABS*	00000000 __stack
00015664 g     F .text	000000a8 ble_hs_pvcy_set_our_irk
000101a0 g     F .text	00000068 ble_ll_scan_set_scan_params
00008b8c  w    F .text	00000002 SWI1_EGU1_IRQHandler
00019970 g     F .text	00000030 host_hci_cmd_build_set_resolv_priv_addr_timeout
000119f0 g     F .text	00000068 ble_gap_rx_update_complete
00011690 g     F .text	0000000c ble_phy_access_addr_get
20002c30 g     O .bss	00000050 bleprph_task
0000a236 g     F .text	0000003a os_mbuf_concat
00018468 g     F .text	0000002e ble_store_write_peer_sec
0001af44 g     F .text	00000020 ble_att_write_cmd_log
0001ad8c g     F .text	00000018 ble_att_find_type_value_req_write
00019810 g     F .text	00000058 host_hci_cmd_build_le_conn_param_reply
0000fe84 g     F .text	00000070 ble_ll_scan_chk_resume
00018498 g     F .text	0000002c ble_uuid_128_to_16
00018194 g     F .text	000000b0 ble_sm_lgcy_confirm_exec
2000022c g     O .data	00000008 g_os_run_list
20002e28 g     O .bss	00000100 g_idle_task_stack
0001b048 g     F .text	00000020 ble_att_indicate_req_log
000094f4 g     F .text	0000002c NVIC_Relocate
20002d18 g     O .bss	000000bc console_tty
00015810 g     F .text	00000028 ble_l2cap_chan_alloc
0001a064 g     F .text	0000007c ble_att_clt_tx_find_info
20001e58 g     O .bss	00000004 os_flags
0000992c g     F .text	00000006 os_arch_restore_sr
20003e08 g     O .bss	0000000c g_hal_os_tick
000159ec g     F .text	00000088 ble_l2cap_init
00010328 g     F .text	00000050 ble_ll_scan_reset
0000eb58 g     F .text	00000010 ble_ll_hci_event_send
0000bb20 g     F .text	00000008 ble_ll_adv_get_peer_rpa
2000fe50 g       *ABS*	000001b0 __StackLimit
000135dc g     F .text	00000062 ble_gattc_rx_read_group_type_complete
20002f28 g     O .bss	00000004 g_os_started
000114b4 g     F .text	00000070 ble_phy_rx
00008cc0 g     F .text	00000014 cputime_ticks_to_usecs
00011acc g     F .text	000001c4 ble_gap_rx_conn_complete
00008b8c  w    F .text	00000002 SPIM2_SPIS2_SPI2_IRQHandler
000159c0 g     F .text	0000002a ble_l2cap_tx
00008b8c  w    F .text	00000002 NFCT_IRQHandler
0001aca4 g     F .text	0000002c ble_att_error_rsp_log
00013528 g     F .text	0000002c ble_gattc_rx_read_type_complete
20003830 g     O .bss	00000004 g_ble_rng_isr_cb
0001b008 g     F .text	0000000c ble_att_notify_req_write
200033e0 g     O .bss	000001a0 g_ble_ll_conn_sm
00017b80 g     F .text	00000006 ble_sm_pair_fail_parse
00008fc8 g     F .text	00000006 exit
0000ae38 g     F .text	0000000c ble_ll_chk_txrx_octets
000183d8 g     F .text	00000008 ble_store_write_cccd
0001923c g     F .text	00000028 host_hci_os_event_proc
0001b068 g     F .text	00000006 ble_att_indicate_rsp_write
200039a4 g     O .bss	00000021 g_nrf_ccm_data
00009f5e g     F .text	00000012 os_mbuf_free_chain
0001aec0 g     F .text	0000000e ble_att_read_group_type_req_parse
00017d54 g     F .text	00000098 ble_sm_master_id_tx
00015270 g     F .text	00000024 ble_hs_conn_remove
0001b458 g     F .text	00000014 ble_att_svr_find_by_handle
00017dfe g     F .text	00000018 ble_sm_id_info_write
0000a00e g     F .text	0000001c os_mbuf_off
00008d8c g     F .text	00000034 cputime_timer_relative
0000b018 g     F .text	000000cc ble_ll_rx_end
0000a7c0 g     F .text	0000000c os_time_get
0000f7a4 g     F .text	00000084 ble_ll_resolv_gen_priv_addr
000183b4 g     F .text	0000000c ble_store_read_our_sec
0001c4ec g     F .text	0000021c ble_att_svr_rx_prep_write
0000f798 g     F .text	0000000c ble_ll_resolv_get_rpa_tmo
0001a890 g     F .text	000000bc ble_att_clt_tx_prep_write
00009f04 g     F .text	0000002e os_mbuf_get_pkthdr
20002c80 g     O .bss	00000010 g_log_info
0001e6b4  w    F .text	00000002 .hidden __aeabi_idiv0
0001bd8c g     F .text	00000154 ble_att_svr_rx_read_blob
00013fd0 g     F .text	00000020 ble_gatts_conn_can_alloc
20002fac g     O .bss	00000100 g_os_sanity_task_stack
0001d378 g     F .text	00000006 _exit
00010b28 g     F .text	00000004 ble_ll_whitelist_enable
20003b9c g     O .bss	0000000c ble_hs_log
0001d228 g     F .text	0000003c log_printf
00014bba g     F .text	00000286 ble_hs_adv_set_fields
0001f300 g     O .text	00000024 g_ble_ll_supp_cmds
00015538 g     F .text	00000022 ble_hs_misc_pullup_base
0000a6c8 g     F .text	000000b4 os_task_init
00017dec g     F .text	00000012 ble_sm_id_info_parse
000183fe g     F .text	00000026 ble_store_key_from_value_sec
00008b82  w    F .text	00000002 BusFault_Handler
0001647e g     F .text	0000006e ble_sm_ia_ra
0000f2d0 g     F .text	00000068 ble_ll_hci_ev_encrypt_chg
00009054 g     F .text	00000010 strlen
0001adcc g     F .text	0000000e ble_att_read_type_req_parse
000116cc g     F .text	0000000c ble_phy_resolv_list_disable
20003604 g     O .bss	00000020 g_ble_ll_rnum_buf
00009be0 g     F .text	00000012 os_eventq_init
0001a654 g     F .text	00000074 ble_att_clt_rx_read_mult
0000a7cc g     F .text	00000070 os_time_advance
0000c164 g     F .text	00000014 ble_ll_conn_get_ce_end_time
00019734 g     F .text	00000018 host_hci_cmd_build_le_set_adv_enable
0000a6a4 g     F .text	00000024 os_sched_resort
00011978 g     F .text	0000002a ble_gap_conn_find
00017950 g     F .text	00000090 ble_sm_pair_cmd_tx
00019be0 g     F .text	00000012 ble_att_conn_chan_find
0001e654 g     F .text	0000002e .hidden __gnu_ldivmod_helper
00017e18 g     F .text	00000024 ble_sm_id_info_log
00008b8c  w    F .text	00000002 MWU_IRQHandler
0001d314 g     F .text	00000038 stats_module_init
0000d3b8 g     F .text	00000090 ble_ll_conn_module_reset
0001767c g     F .text	000001d0 ble_sm_alg_c1
00008b80  w    F .text	00000002 MemoryManagement_Handler
20002c90 g     O .bss	00000050 io_poll_task
0000b600 g     F .text	0000000c ble_ll_adv_read_txpwr
000136d2 g     F .text	00000020 ble_gattc_rx_write_rsp
00019fbc g     F .text	000000a8 ble_att_clt_rx_mtu
20003580 g     O .bss	00000074 ble_ll_conn_stats
0000d0f4 g     F .text	0000008a ble_ll_conn_enqueue_pkt
000154e4 g     F .text	00000030 ble_hs_log_flat_buf
00019644 g     F .text	0000003e host_hci_cmd_build_le_set_scan_rsp_data
0000b60c g     F .text	000000c8 ble_ll_adv_set_enable
0000e500 g     F .text	00000054 ble_ll_ctrl_chk_proc_start
00008b8c  w    F .text	00000002 COMP_LPCOMP_IRQHandler
00015de0 g     F .text	00000048 ble_l2cap_sig_reject_tx
00010dfc g     F .text	00000020 ble_hw_resolv_list_match
0001c43c g     F .text	0000009c ble_att_svr_rx_write_no_rsp
0001d070 g     F .text	0000001e htole64
0001b3b0 g     F .text	00000074 ble_att_svr_register
00008cd4 g     F .text	0000002c cputime_timer_init
0000d448 g     F .text	00000074 ble_ll_conn_module_init
00010968 g     F .text	00000058 ble_ll_sched_rmv_elem
0001555a g     F .text	00000030 ble_hs_misc_conn_chan_find
0001326a g     F .text	00000006 ble_gatts_indicate_fail_notconn
20000234 g     O .data	00000008 g_os_sleep_list
0000946c g     F .text	00000048 jrand48
00015638 g     F .text	0000002c ble_hs_pvcy_ensure_started
0000e584 g     F .text	000004ea ble_ll_ctrl_rx_pdu
00014e40 g     F .text	00000232 ble_hs_adv_parse_fields
00013790 g     F .text	00000006 ble_gattc_connection_broken
00011174 g     F .text	000000a8 ble_phy_setchan
200035f4 g     O .bss	00000004 g_ble_ll_conn_active_list
0000d608 g     F .text	000000d8 ble_ll_conn_num_comp_pkts_event_send
00010208 g     F .text	00000044 ble_ll_scan_set_enable
0000f51c g     F .text	00000018 ble_ll_rand_start
20002ce0 g     O .bss	0000000c bleprph_log
000119a4 g     F .text	0000004c ble_gap_rx_disconn_complete
00015e48 g     F .text	00000012 ble_l2cap_sig_update_req_parse
0000aa18 g     F .text	0000000e os_sanity_check_init
0000f5d4 g     F .text	00000016 ble_ll_resolv_irk_nonzero
0000f8e8 g     F .text	00000018 ble_ll_resolv_list_reset
00010a58 g     F .text	00000034 ble_ll_whitelist_clear
00015200 g     F .text	00000070 ble_hs_conn_alloc
00014760 g     F .text	00000018 ble_hs_process_tx_data_queue
0000c948 g     F .text	00000028 ble_ll_conn_event_halt
0001afd8 g     F .text	00000020 ble_att_exec_write_req_log
0000940e g     F .text	00000004 vfprintf
0001d372 g     F .text	00000006 _close
0000f828 g     F .text	0000002c ble_ll_resolv_gen_rpa
0001daa8 g     F .text	0000002c free
000150c4 g     F .text	00000038 ble_hs_atomic_conn_set_flags
0001d5fc g     F .text	00000030 system_reset
00008e5c g     F .text	00000010 cputime_disable_ocmp



Disassembly of section .text:

00008020 <__isr_vector>:
    8020:	20010000 	.word	0x20010000
    8024:	00008b4d 	.word	0x00008b4d
    8028:	00008b7d 	.word	0x00008b7d
    802c:	00008b7f 	.word	0x00008b7f
	...
    804c:	0000a935 	.word	0x0000a935
	...
    8058:	0000a97b 	.word	0x0000a97b
    805c:	0000a9a5 	.word	0x0000a9a5
    8060:	00008b8d 	.word	0x00008b8d
    8064:	00008b8d 	.word	0x00008b8d
    8068:	00008b8d 	.word	0x00008b8d
    806c:	00008b8d 	.word	0x00008b8d
    8070:	00008b8d 	.word	0x00008b8d
    8074:	00008b8d 	.word	0x00008b8d
    8078:	00008b8d 	.word	0x00008b8d
    807c:	00008b8d 	.word	0x00008b8d
    8080:	00008b8d 	.word	0x00008b8d
    8084:	00008b8d 	.word	0x00008b8d
    8088:	00008b8d 	.word	0x00008b8d
    808c:	00008b8d 	.word	0x00008b8d
    8090:	00008b8d 	.word	0x00008b8d
    8094:	00008b8d 	.word	0x00008b8d
    8098:	00008b8d 	.word	0x00008b8d
    809c:	00008b8d 	.word	0x00008b8d
    80a0:	00008b8d 	.word	0x00008b8d
    80a4:	00008b8d 	.word	0x00008b8d
    80a8:	00008b8d 	.word	0x00008b8d
    80ac:	00008b8d 	.word	0x00008b8d
    80b0:	00008b8d 	.word	0x00008b8d
    80b4:	00008b8d 	.word	0x00008b8d
    80b8:	00008b8d 	.word	0x00008b8d
    80bc:	00008b8d 	.word	0x00008b8d
    80c0:	00008b8d 	.word	0x00008b8d
    80c4:	00008b8d 	.word	0x00008b8d
    80c8:	00008b8d 	.word	0x00008b8d
    80cc:	00008b8d 	.word	0x00008b8d
    80d0:	00008b8d 	.word	0x00008b8d
    80d4:	00008b8d 	.word	0x00008b8d
	...
    80e0:	00008b8d 	.word	0x00008b8d
    80e4:	00008b8d 	.word	0x00008b8d
    80e8:	00008b8d 	.word	0x00008b8d
    80ec:	00008b8d 	.word	0x00008b8d
    80f0:	00008b8d 	.word	0x00008b8d
    80f4:	00008b8d 	.word	0x00008b8d

000080f8 <_mainCRTStartup>:
    80f8:	4b15      	ldr	r3, [pc, #84]	; (8150 <_mainCRTStartup+0x58>)
    80fa:	2b00      	cmp	r3, #0
    80fc:	bf08      	it	eq
    80fe:	4b13      	ldreq	r3, [pc, #76]	; (814c <_mainCRTStartup+0x54>)
    8100:	469d      	mov	sp, r3
    8102:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
    8106:	2100      	movs	r1, #0
    8108:	468b      	mov	fp, r1
    810a:	460f      	mov	r7, r1
    810c:	4813      	ldr	r0, [pc, #76]	; (815c <_mainCRTStartup+0x64>)
    810e:	4a14      	ldr	r2, [pc, #80]	; (8160 <_mainCRTStartup+0x68>)
    8110:	1a12      	subs	r2, r2, r0
    8112:	f000 ff7e 	bl	9012 <memset>
    8116:	4b0f      	ldr	r3, [pc, #60]	; (8154 <_mainCRTStartup+0x5c>)
    8118:	2b00      	cmp	r3, #0
    811a:	d000      	beq.n	811e <_mainCRTStartup+0x26>
    811c:	4798      	blx	r3
    811e:	4b0e      	ldr	r3, [pc, #56]	; (8158 <_mainCRTStartup+0x60>)
    8120:	2b00      	cmp	r3, #0
    8122:	d000      	beq.n	8126 <_mainCRTStartup+0x2e>
    8124:	4798      	blx	r3
    8126:	2000      	movs	r0, #0
    8128:	2100      	movs	r1, #0
    812a:	0004      	movs	r4, r0
    812c:	000d      	movs	r5, r1
    812e:	480d      	ldr	r0, [pc, #52]	; (8164 <_mainCRTStartup+0x6c>)
    8130:	2800      	cmp	r0, #0
    8132:	d002      	beq.n	813a <_mainCRTStartup+0x42>
    8134:	480c      	ldr	r0, [pc, #48]	; (8168 <_mainCRTStartup+0x70>)
    8136:	f3af 8000 	nop.w
    813a:	f016 fd47 	bl	1ebcc <__libc_init_array>
    813e:	0020      	movs	r0, r4
    8140:	0029      	movs	r1, r5
    8142:	f000 f9a7 	bl	8494 <main>
    8146:	f000 ff3f 	bl	8fc8 <exit>
    814a:	bf00      	nop
    814c:	00080000 	.word	0x00080000
    8150:	20010000 	.word	0x20010000
	...
    815c:	20001000 	.word	0x20001000
    8160:	20003e14 	.word	0x20003e14
	...

0000816c <bleprph_advertise>:
 *     o General discoverable mode.
 *     o Undirected connectable mode.
 */
static void
bleprph_advertise(void)
{
    816c:	b530      	push	{r4, r5, lr}
    816e:	b0a5      	sub	sp, #148	; 0x94
     *     o Advertising tx power.
     *     o Device name.
     *     o 16-bit service UUIDs (alert notifications).
     */

    memset(&fields, 0, sizeof fields);
    8170:	2100      	movs	r1, #0
    8172:	226c      	movs	r2, #108	; 0x6c
    8174:	a809      	add	r0, sp, #36	; 0x24
    8176:	f000 ff4c 	bl	9012 <memset>

    /* Indicate that the flags field should be included; specify a value of 0
     * to instruct the stack to fill the value in for us.
     */
    fields.flags_is_present = 1;
    817a:	2301      	movs	r3, #1
    817c:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25

    /* Indicate that the TX power level field should be included; have the
     * stack fill this one automatically as well.  This is done by assiging the
     * special value BLE_HS_ADV_TX_PWR_LVL_AUTO.
     */
    fields.tx_pwr_lvl_is_present = 1;
    8180:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
    fields.tx_pwr_lvl = BLE_HS_ADV_TX_PWR_LVL_AUTO;
    8184:	2380      	movs	r3, #128	; 0x80
    8186:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46

    name = ble_svc_gap_device_name();
    818a:	f014 fd2d 	bl	1cbe8 <ble_svc_gap_device_name>
    fields.name = (uint8_t *)name;
    818e:	9010      	str	r0, [sp, #64]	; 0x40
    fields.name_len = strlen(name);
    8190:	f000 ff60 	bl	9054 <strlen>
    fields.name_is_complete = 1;
    8194:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    fields.tx_pwr_lvl_is_present = 1;
    fields.tx_pwr_lvl = BLE_HS_ADV_TX_PWR_LVL_AUTO;

    name = ble_svc_gap_device_name();
    fields.name = (uint8_t *)name;
    fields.name_len = strlen(name);
    8198:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
    fields.name_is_complete = 1;
    819c:	f043 0301 	orr.w	r3, r3, #1
    81a0:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45

    fields.uuids16 = (uint16_t[]){ GATT_SVR_SVC_ALERT_UUID };
    81a4:	ab24      	add	r3, sp, #144	; 0x90
    81a6:	f641 0211 	movw	r2, #6161	; 0x1811
    81aa:	f823 2d7c 	strh.w	r2, [r3, #-124]!
    81ae:	930a      	str	r3, [sp, #40]	; 0x28
    fields.num_uuids16 = 1;
    81b0:	2301      	movs	r3, #1
    81b2:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    fields.uuids16_is_complete = 1;
    81b6:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d

    rc = ble_gap_adv_set_fields(&fields);
    81ba:	a809      	add	r0, sp, #36	; 0x24
    fields.name_len = strlen(name);
    fields.name_is_complete = 1;

    fields.uuids16 = (uint16_t[]){ GATT_SVR_SVC_ALERT_UUID };
    fields.num_uuids16 = 1;
    fields.uuids16_is_complete = 1;
    81bc:	f043 0301 	orr.w	r3, r3, #1
    81c0:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d

    rc = ble_gap_adv_set_fields(&fields);
    81c4:	f009 ff34 	bl	12030 <ble_gap_adv_set_fields>
    if (rc != 0) {
    81c8:	4604      	mov	r4, r0
    81ca:	b128      	cbz	r0, 81d8 <bleprph_advertise+0x6c>
        BLEPRPH_LOG(ERROR, "error setting advertisement data; rc=%d\n", rc);
    81cc:	9000      	str	r0, [sp, #0]
    81ce:	2140      	movs	r1, #64	; 0x40
    81d0:	4811      	ldr	r0, [pc, #68]	; (8218 <bleprph_advertise+0xac>)
    81d2:	4b12      	ldr	r3, [pc, #72]	; (821c <bleprph_advertise+0xb0>)
    81d4:	2203      	movs	r2, #3
    81d6:	e01b      	b.n	8210 <bleprph_advertise+0xa4>
        return;
    }

    /* Begin advertising. */
    memset(&adv_params, 0, sizeof adv_params);
    81d8:	ad06      	add	r5, sp, #24
    81da:	4621      	mov	r1, r4
    81dc:	220a      	movs	r2, #10
    81de:	4628      	mov	r0, r5
    81e0:	f000 ff17 	bl	9012 <memset>
    adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
    81e4:	2302      	movs	r3, #2
    81e6:	f88d 3018 	strb.w	r3, [sp, #24]
    adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
    81ea:	f88d 3019 	strb.w	r3, [sp, #25]
    rc = ble_gap_adv_start(BLE_ADDR_TYPE_PUBLIC, 0, NULL, BLE_HS_FOREVER,
    81ee:	4b0c      	ldr	r3, [pc, #48]	; (8220 <bleprph_advertise+0xb4>)
    81f0:	9301      	str	r3, [sp, #4]
    81f2:	9500      	str	r5, [sp, #0]
    81f4:	9402      	str	r4, [sp, #8]
    81f6:	4620      	mov	r0, r4
    81f8:	4621      	mov	r1, r4
    81fa:	4622      	mov	r2, r4
    81fc:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    8200:	f009 fdaa 	bl	11d58 <ble_gap_adv_start>
                           &adv_params, bleprph_gap_event, NULL);
    if (rc != 0) {
    8204:	b130      	cbz	r0, 8214 <bleprph_advertise+0xa8>
        BLEPRPH_LOG(ERROR, "error enabling advertisement; rc=%d\n", rc);
    8206:	9000      	str	r0, [sp, #0]
    8208:	4b06      	ldr	r3, [pc, #24]	; (8224 <bleprph_advertise+0xb8>)
    820a:	4803      	ldr	r0, [pc, #12]	; (8218 <bleprph_advertise+0xac>)
    820c:	2140      	movs	r1, #64	; 0x40
    820e:	2203      	movs	r2, #3
    8210:	f015 f80a 	bl	1d228 <log_printf>
        return;
    }
}
    8214:	b025      	add	sp, #148	; 0x94
    8216:	bd30      	pop	{r4, r5, pc}
    8218:	20002ce0 	.word	0x20002ce0
    821c:	0001ec34 	.word	0x0001ec34
    8220:	0000832d 	.word	0x0000832d
    8224:	0001ec5d 	.word	0x0001ec5d

00008228 <bleprph_task_handler>:
/**
 * Event loop for the main bleprph task.
 */
static void
bleprph_task_handler(void *unused)
{
    8228:	b508      	push	{r3, lr}
    struct os_event *ev;
    struct os_callout_func *cf;
    int rc;

    rc = ble_hs_start();
    822a:	f00c fb2d 	bl	14888 <ble_hs_start>
    assert(rc == 0);
    822e:	b118      	cbz	r0, 8238 <bleprph_task_handler+0x10>
    8230:	480d      	ldr	r0, [pc, #52]	; (8268 <bleprph_task_handler+0x40>)
    8232:	f240 1125 	movw	r1, #293	; 0x125
    8236:	e015      	b.n	8264 <bleprph_task_handler+0x3c>

    /* Begin advertising. */
    bleprph_advertise();
    8238:	f7ff ff98 	bl	816c <bleprph_advertise>

    while (1) {
        ev = os_eventq_get(&bleprph_evq);
    823c:	480b      	ldr	r0, [pc, #44]	; (826c <bleprph_task_handler+0x44>)
    823e:	f001 fd02 	bl	9c46 <os_eventq_get>
        switch (ev->ev_type) {
    8242:	7843      	ldrb	r3, [r0, #1]
    8244:	2b01      	cmp	r3, #1
    8246:	d10a      	bne.n	825e <bleprph_task_handler+0x36>
        case OS_EVENT_T_TIMER:
            cf = (struct os_callout_func *)ev;
            assert(cf->cf_func);
    8248:	69c2      	ldr	r2, [r0, #28]
    824a:	b92a      	cbnz	r2, 8258 <bleprph_task_handler+0x30>
    824c:	4806      	ldr	r0, [pc, #24]	; (8268 <bleprph_task_handler+0x40>)
    824e:	f240 112f 	movw	r1, #303	; 0x12f
    8252:	4613      	mov	r3, r2
    8254:	f001 fd3c 	bl	9cd0 <__assert_func>
            cf->cf_func(CF_ARG(cf));
    8258:	6840      	ldr	r0, [r0, #4]
    825a:	4790      	blx	r2
            break;
        default:
            assert(0);
            break;
        }
    }
    825c:	e7ee      	b.n	823c <bleprph_task_handler+0x14>
            cf = (struct os_callout_func *)ev;
            assert(cf->cf_func);
            cf->cf_func(CF_ARG(cf));
            break;
        default:
            assert(0);
    825e:	4802      	ldr	r0, [pc, #8]	; (8268 <bleprph_task_handler+0x40>)
    8260:	f240 1133 	movw	r1, #307	; 0x133
    8264:	2200      	movs	r2, #0
    8266:	e7f4      	b.n	8252 <bleprph_task_handler+0x2a>
    8268:	0001ec82 	.word	0x0001ec82
    826c:	20002804 	.word	0x20002804

00008270 <bleprph_print_conn_desc>:
/**
 * Logs information about a connection to the console.
 */
static void
bleprph_print_conn_desc(struct ble_gap_conn_desc *desc)
{
    8270:	b530      	push	{r4, r5, lr}
    8272:	b087      	sub	sp, #28
    BLEPRPH_LOG(INFO, "handle=%d our_ota_addr_type=%d our_ota_addr=",
    8274:	8b83      	ldrh	r3, [r0, #28]
    8276:	4d27      	ldr	r5, [pc, #156]	; (8314 <bleprph_print_conn_desc+0xa4>)
    8278:	9300      	str	r3, [sp, #0]
    827a:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
    827e:	9301      	str	r3, [sp, #4]
/**
 * Logs information about a connection to the console.
 */
static void
bleprph_print_conn_desc(struct ble_gap_conn_desc *desc)
{
    8280:	4604      	mov	r4, r0
    BLEPRPH_LOG(INFO, "handle=%d our_ota_addr_type=%d our_ota_addr=",
    8282:	2140      	movs	r1, #64	; 0x40
    8284:	4628      	mov	r0, r5
    8286:	2201      	movs	r2, #1
    8288:	4b23      	ldr	r3, [pc, #140]	; (8318 <bleprph_print_conn_desc+0xa8>)
    828a:	f014 ffcd 	bl	1d228 <log_printf>
                desc->conn_handle, desc->our_ota_addr_type);
    print_addr(desc->our_ota_addr);
    828e:	f104 0016 	add.w	r0, r4, #22
    8292:	f000 fa25 	bl	86e0 <print_addr>
    BLEPRPH_LOG(INFO, " our_id_addr_type=%d our_id_addr=",
    8296:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
    829a:	9300      	str	r3, [sp, #0]
    829c:	4628      	mov	r0, r5
    829e:	2140      	movs	r1, #64	; 0x40
    82a0:	2201      	movs	r2, #1
    82a2:	4b1e      	ldr	r3, [pc, #120]	; (831c <bleprph_print_conn_desc+0xac>)
    82a4:	f014 ffc0 	bl	1d228 <log_printf>
                desc->our_id_addr_type);
    print_addr(desc->our_id_addr);
    82a8:	f104 0010 	add.w	r0, r4, #16
    82ac:	f000 fa18 	bl	86e0 <print_addr>
    BLEPRPH_LOG(INFO, " peer_ota_addr_type=%d peer_ota_addr=",
    82b0:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    82b4:	9300      	str	r3, [sp, #0]
    82b6:	4628      	mov	r0, r5
    82b8:	2140      	movs	r1, #64	; 0x40
    82ba:	2201      	movs	r2, #1
    82bc:	4b18      	ldr	r3, [pc, #96]	; (8320 <bleprph_print_conn_desc+0xb0>)
    82be:	f014 ffb3 	bl	1d228 <log_printf>
                desc->peer_ota_addr_type);
    print_addr(desc->peer_ota_addr);
    82c2:	1d20      	adds	r0, r4, #4
    82c4:	f000 fa0c 	bl	86e0 <print_addr>
    BLEPRPH_LOG(INFO, " peer_id_addr_type=%d peer_id_addr=",
    82c8:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    82cc:	9300      	str	r3, [sp, #0]
    82ce:	4628      	mov	r0, r5
    82d0:	2140      	movs	r1, #64	; 0x40
    82d2:	2201      	movs	r2, #1
    82d4:	4b13      	ldr	r3, [pc, #76]	; (8324 <bleprph_print_conn_desc+0xb4>)
    82d6:	f014 ffa7 	bl	1d228 <log_printf>
                desc->peer_id_addr_type);
    print_addr(desc->peer_id_addr);
    82da:	f104 000a 	add.w	r0, r4, #10
    82de:	f000 f9ff 	bl	86e0 <print_addr>
    BLEPRPH_LOG(INFO, " conn_itvl=%d conn_latency=%d supervision_timeout=%d "
    82e2:	8be3      	ldrh	r3, [r4, #30]
    82e4:	9300      	str	r3, [sp, #0]
    82e6:	8c23      	ldrh	r3, [r4, #32]
    82e8:	9301      	str	r3, [sp, #4]
    82ea:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    82ec:	9302      	str	r3, [sp, #8]
    82ee:	7823      	ldrb	r3, [r4, #0]
    82f0:	f003 0201 	and.w	r2, r3, #1
    82f4:	9203      	str	r2, [sp, #12]
    82f6:	f3c3 0240 	ubfx	r2, r3, #1, #1
    82fa:	f3c3 0380 	ubfx	r3, r3, #2, #1
    82fe:	9204      	str	r2, [sp, #16]
    8300:	9305      	str	r3, [sp, #20]
    8302:	4628      	mov	r0, r5
    8304:	2140      	movs	r1, #64	; 0x40
    8306:	2201      	movs	r2, #1
    8308:	4b07      	ldr	r3, [pc, #28]	; (8328 <bleprph_print_conn_desc+0xb8>)
    830a:	f014 ff8d 	bl	1d228 <log_printf>
                desc->conn_itvl, desc->conn_latency,
                desc->supervision_timeout,
                desc->sec_state.encrypted,
                desc->sec_state.authenticated,
                desc->sec_state.bonded);
}
    830e:	b007      	add	sp, #28
    8310:	bd30      	pop	{r4, r5, pc}
    8312:	bf00      	nop
    8314:	20002ce0 	.word	0x20002ce0
    8318:	0001ec89 	.word	0x0001ec89
    831c:	0001ecb6 	.word	0x0001ecb6
    8320:	0001ecd8 	.word	0x0001ecd8
    8324:	0001ecfe 	.word	0x0001ecfe
    8328:	0001ed22 	.word	0x0001ed22

0000832c <bleprph_gap_event>:
 *                                  of the return code is specific to the
 *                                  particular GAP event being signalled.
 */
static int
bleprph_gap_event(struct ble_gap_event *event, void *arg)
{
    832c:	b530      	push	{r4, r5, lr}
    struct ble_gap_conn_desc desc;
    int rc;

    switch (event->type) {
    832e:	7803      	ldrb	r3, [r0, #0]
 *                                  of the return code is specific to the
 *                                  particular GAP event being signalled.
 */
static int
bleprph_gap_event(struct ble_gap_event *event, void *arg)
{
    8330:	b095      	sub	sp, #84	; 0x54
    8332:	4604      	mov	r4, r0
    struct ble_gap_conn_desc desc;
    int rc;

    switch (event->type) {
    8334:	2b0e      	cmp	r3, #14
    8336:	f200 808b 	bhi.w	8450 <bleprph_gap_event+0x124>
    833a:	e8df f003 	tbb	[pc, r3]
    833e:	2e08      	.short	0x2e08
    8340:	89894389 	.word	0x89894389
    8344:	89898989 	.word	0x89898989
    8348:	89898958 	.word	0x89898958
    834c:	69          	.byte	0x69
    834d:	00          	.byte	0x00
    case BLE_GAP_EVENT_CONNECT:
        /* A new connection was established or a connection attempt failed. */
        BLEPRPH_LOG(INFO, "connection %s; status=%d ",
    834e:	6842      	ldr	r2, [r0, #4]
    8350:	4941      	ldr	r1, [pc, #260]	; (8458 <bleprph_gap_event+0x12c>)
    8352:	4b42      	ldr	r3, [pc, #264]	; (845c <bleprph_gap_event+0x130>)
    8354:	9201      	str	r2, [sp, #4]
    8356:	2a00      	cmp	r2, #0
    8358:	bf18      	it	ne
    835a:	460b      	movne	r3, r1
    835c:	9300      	str	r3, [sp, #0]
    835e:	4840      	ldr	r0, [pc, #256]	; (8460 <bleprph_gap_event+0x134>)
    8360:	4b40      	ldr	r3, [pc, #256]	; (8464 <bleprph_gap_event+0x138>)
    8362:	2140      	movs	r1, #64	; 0x40
    8364:	2201      	movs	r2, #1
    8366:	f014 ff5f 	bl	1d228 <log_printf>
                       event->connect.status == 0 ? "established" : "failed",
                       event->connect.status);
        if (event->connect.status == 0) {
    836a:	6865      	ldr	r5, [r4, #4]
    836c:	b95d      	cbnz	r5, 8386 <bleprph_gap_event+0x5a>
            rc = ble_gap_conn_find(event->connect.conn_handle, &desc);
    836e:	8920      	ldrh	r0, [r4, #8]
    8370:	a909      	add	r1, sp, #36	; 0x24
    8372:	f009 fb01 	bl	11978 <ble_gap_conn_find>
            assert(rc == 0);
    8376:	b118      	cbz	r0, 8380 <bleprph_gap_event+0x54>
    8378:	483b      	ldr	r0, [pc, #236]	; (8468 <bleprph_gap_event+0x13c>)
    837a:	21da      	movs	r1, #218	; 0xda
    837c:	462a      	mov	r2, r5
    837e:	e029      	b.n	83d4 <bleprph_gap_event+0xa8>
            bleprph_print_conn_desc(&desc);
    8380:	a809      	add	r0, sp, #36	; 0x24
    8382:	f7ff ff75 	bl	8270 <bleprph_print_conn_desc>
        }
        BLEPRPH_LOG(INFO, "\n");
    8386:	4b39      	ldr	r3, [pc, #228]	; (846c <bleprph_gap_event+0x140>)
    8388:	4835      	ldr	r0, [pc, #212]	; (8460 <bleprph_gap_event+0x134>)
    838a:	2140      	movs	r1, #64	; 0x40
    838c:	2201      	movs	r2, #1
    838e:	f014 ff4b 	bl	1d228 <log_printf>

        if (event->connect.status != 0) {
    8392:	6863      	ldr	r3, [r4, #4]
    8394:	2b00      	cmp	r3, #0
    8396:	d05b      	beq.n	8450 <bleprph_gap_event+0x124>
    8398:	e011      	b.n	83be <bleprph_gap_event+0x92>
            bleprph_advertise();
        }
        return 0;

    case BLE_GAP_EVENT_DISCONNECT:
        BLEPRPH_LOG(INFO, "disconnect; reason=%d ", event->disconnect.reason);
    839a:	6843      	ldr	r3, [r0, #4]
    839c:	9300      	str	r3, [sp, #0]
    839e:	2140      	movs	r1, #64	; 0x40
    83a0:	2201      	movs	r2, #1
    83a2:	4b33      	ldr	r3, [pc, #204]	; (8470 <bleprph_gap_event+0x144>)
    83a4:	482e      	ldr	r0, [pc, #184]	; (8460 <bleprph_gap_event+0x134>)
    83a6:	f014 ff3f 	bl	1d228 <log_printf>
        bleprph_print_conn_desc(&event->disconnect.conn);
    83aa:	f104 0008 	add.w	r0, r4, #8
    83ae:	f7ff ff5f 	bl	8270 <bleprph_print_conn_desc>
        BLEPRPH_LOG(INFO, "\n");
    83b2:	482b      	ldr	r0, [pc, #172]	; (8460 <bleprph_gap_event+0x134>)
    83b4:	4b2d      	ldr	r3, [pc, #180]	; (846c <bleprph_gap_event+0x140>)
    83b6:	2140      	movs	r1, #64	; 0x40
    83b8:	2201      	movs	r2, #1
    83ba:	f014 ff35 	bl	1d228 <log_printf>

        /* Connection terminated; resume advertising. */
        bleprph_advertise();
    83be:	f7ff fed5 	bl	816c <bleprph_advertise>
        return 0;
    83c2:	e045      	b.n	8450 <bleprph_gap_event+0x124>

    case BLE_GAP_EVENT_CONN_UPDATE:
        /* The central has updated the connection parameters. 
        BLEPRPH_LOG(INFO, "connection updated; status=%d ",
                    event->conn_update.status);*/
        rc = ble_gap_conn_find(event->connect.conn_handle, &desc);
    83c4:	8900      	ldrh	r0, [r0, #8]
    83c6:	a909      	add	r1, sp, #36	; 0x24
    83c8:	f009 fad6 	bl	11978 <ble_gap_conn_find>
        assert(rc == 0);
    83cc:	b128      	cbz	r0, 83da <bleprph_gap_event+0xae>
    83ce:	4826      	ldr	r0, [pc, #152]	; (8468 <bleprph_gap_event+0x13c>)
    83d0:	21f3      	movs	r1, #243	; 0xf3
    83d2:	2200      	movs	r2, #0
    83d4:	4613      	mov	r3, r2
    83d6:	f001 fc7b 	bl	9cd0 <__assert_func>
        bleprph_print_conn_desc(&desc);
    83da:	a809      	add	r0, sp, #36	; 0x24
    83dc:	f7ff ff48 	bl	8270 <bleprph_print_conn_desc>
        BLEPRPH_LOG(INFO, "\n");
    83e0:	481f      	ldr	r0, [pc, #124]	; (8460 <bleprph_gap_event+0x134>)
    83e2:	4b22      	ldr	r3, [pc, #136]	; (846c <bleprph_gap_event+0x140>)
    83e4:	2140      	movs	r1, #64	; 0x40
    83e6:	2201      	movs	r2, #1
    83e8:	f014 ff1e 	bl	1d228 <log_printf>
        /* Update conn_handle */
        return 0;
    83ec:	e030      	b.n	8450 <bleprph_gap_event+0x124>

    case BLE_GAP_EVENT_ENC_CHANGE:
        /* Encryption has been enabled or disabled for this connection. */
        BLEPRPH_LOG(INFO, "encryption change event; status=%d ",
    83ee:	6843      	ldr	r3, [r0, #4]
    83f0:	9300      	str	r3, [sp, #0]
    83f2:	481b      	ldr	r0, [pc, #108]	; (8460 <bleprph_gap_event+0x134>)
    83f4:	4b1f      	ldr	r3, [pc, #124]	; (8474 <bleprph_gap_event+0x148>)
    83f6:	2140      	movs	r1, #64	; 0x40
    83f8:	2201      	movs	r2, #1
    83fa:	f014 ff15 	bl	1d228 <log_printf>
                    event->enc_change.status);
        rc = ble_gap_conn_find(event->connect.conn_handle, &desc);
    83fe:	8920      	ldrh	r0, [r4, #8]
    8400:	a909      	add	r1, sp, #36	; 0x24
    8402:	f009 fab9 	bl	11978 <ble_gap_conn_find>
        assert(rc == 0);
    8406:	2800      	cmp	r0, #0
    8408:	d0e7      	beq.n	83da <bleprph_gap_event+0xae>
    840a:	4817      	ldr	r0, [pc, #92]	; (8468 <bleprph_gap_event+0x13c>)
    840c:	21fe      	movs	r1, #254	; 0xfe
    840e:	e7e0      	b.n	83d2 <bleprph_gap_event+0xa6>
        bleprph_print_conn_desc(&desc);
        BLEPRPH_LOG(INFO, "\n");
        return 0;

    case BLE_GAP_EVENT_SUBSCRIBE:
        BLEPRPH_LOG(INFO, "\n\nsubscribe event; conn_handle=%d attr_handle=%d "
    8410:	8883      	ldrh	r3, [r0, #4]
    8412:	9300      	str	r3, [sp, #0]
    8414:	88c3      	ldrh	r3, [r0, #6]
    8416:	9301      	str	r3, [sp, #4]
    8418:	7a03      	ldrb	r3, [r0, #8]
    841a:	9302      	str	r3, [sp, #8]
    841c:	7a43      	ldrb	r3, [r0, #9]
    841e:	4810      	ldr	r0, [pc, #64]	; (8460 <bleprph_gap_event+0x134>)
    8420:	f003 0201 	and.w	r2, r3, #1
    8424:	9203      	str	r2, [sp, #12]
    8426:	f3c3 0240 	ubfx	r2, r3, #1, #1
    842a:	9204      	str	r2, [sp, #16]
    842c:	f3c3 0280 	ubfx	r2, r3, #2, #1
    8430:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    8434:	9205      	str	r2, [sp, #20]
    8436:	9306      	str	r3, [sp, #24]
    8438:	2140      	movs	r1, #64	; 0x40
    843a:	2201      	movs	r2, #1
    843c:	4b0e      	ldr	r3, [pc, #56]	; (8478 <bleprph_gap_event+0x14c>)
    843e:	f014 fef3 	bl	1d228 <log_printf>
                    event->subscribe.cur_notify,
                    event->subscribe.prev_indicate,
                    event->subscribe.cur_indicate);
        /* When we get a new subscriber, update the connection handle
         * and send a new event to io_poll_task's event queue */
        conn_handle = event->subscribe.conn_handle;
    8442:	4b0e      	ldr	r3, [pc, #56]	; (847c <bleprph_gap_event+0x150>)
    8444:	88a2      	ldrh	r2, [r4, #4]
        os_eventq_put(&io_poll_evq, &io_ev);
    8446:	480e      	ldr	r0, [pc, #56]	; (8480 <bleprph_gap_event+0x154>)
    8448:	490e      	ldr	r1, [pc, #56]	; (8484 <bleprph_gap_event+0x158>)
                    event->subscribe.cur_notify,
                    event->subscribe.prev_indicate,
                    event->subscribe.cur_indicate);
        /* When we get a new subscriber, update the connection handle
         * and send a new event to io_poll_task's event queue */
        conn_handle = event->subscribe.conn_handle;
    844a:	801a      	strh	r2, [r3, #0]
        os_eventq_put(&io_poll_evq, &io_ev);
    844c:	f001 fbd1 	bl	9bf2 <os_eventq_put>

        return 0;
    }

    return 0;
}
    8450:	2000      	movs	r0, #0
    8452:	b015      	add	sp, #84	; 0x54
    8454:	bd30      	pop	{r4, r5, pc}
    8456:	bf00      	nop
    8458:	0001ed8c 	.word	0x0001ed8c
    845c:	0001ed80 	.word	0x0001ed80
    8460:	20002ce0 	.word	0x20002ce0
    8464:	0001ed93 	.word	0x0001ed93
    8468:	0001ec82 	.word	0x0001ec82
    846c:	0001fdec 	.word	0x0001fdec
    8470:	0001edad 	.word	0x0001edad
    8474:	0001edc4 	.word	0x0001edc4
    8478:	0001ede8 	.word	0x0001ede8
    847c:	200027e4 	.word	0x200027e4
    8480:	200027d8 	.word	0x200027d8
    8484:	20002c24 	.word	0x20002c24

00008488 <get_conn_handle>:
/* I/O poll new subscriber event queue */
struct os_eventq io_poll_evq;
struct os_event io_ev;

uint16_t conn_handle;
uint16_t get_conn_handle() { return conn_handle; }
    8488:	4b01      	ldr	r3, [pc, #4]	; (8490 <get_conn_handle+0x8>)
    848a:	8818      	ldrh	r0, [r3, #0]
    848c:	4770      	bx	lr
    848e:	bf00      	nop
    8490:	200027e4 	.word	0x200027e4

00008494 <main>:
 *
 * @return int NOTE: this function should never return!
 */
int
main(void)
{
    8494:	b5f0      	push	{r4, r5, r6, r7, lr}
    8496:	b08f      	sub	sp, #60	; 0x3c
    uint32_t seed;
    int rc;
    int i;

    /* Initialize OS */
    os_init();
    8498:	f001 fa0e 	bl	98b8 <os_init>

    /* Set cputime to count at 1 usec increments */
    rc = cputime_init(1000000);
    849c:	4879      	ldr	r0, [pc, #484]	; (8684 <main+0x1f0>)
    849e:	f000 fc01 	bl	8ca4 <cputime_init>
    assert(rc == 0);
    84a2:	b118      	cbz	r0, 84ac <main+0x18>
    84a4:	4878      	ldr	r0, [pc, #480]	; (8688 <main+0x1f4>)
    84a6:	f240 114f 	movw	r1, #335	; 0x14f
    84aa:	e018      	b.n	84de <main+0x4a>
    84ac:	4603      	mov	r3, r0
    /* Seed random number generator with least significant bytes of device
     * address.
     */
    seed = 0;
    for (i = 0; i < 4; ++i) {
        seed |= g_dev_addr[i];
    84ae:	4a77      	ldr	r2, [pc, #476]	; (868c <main+0x1f8>)
    84b0:	5c9a      	ldrb	r2, [r3, r2]

    /* Seed random number generator with least significant bytes of device
     * address.
     */
    seed = 0;
    for (i = 0; i < 4; ++i) {
    84b2:	3301      	adds	r3, #1
        seed |= g_dev_addr[i];
    84b4:	4310      	orrs	r0, r2

    /* Seed random number generator with least significant bytes of device
     * address.
     */
    seed = 0;
    for (i = 0; i < 4; ++i) {
    84b6:	2b04      	cmp	r3, #4
        seed |= g_dev_addr[i];
        seed <<= 8;
    84b8:	ea4f 2000 	mov.w	r0, r0, lsl #8

    /* Seed random number generator with least significant bytes of device
     * address.
     */
    seed = 0;
    for (i = 0; i < 4; ++i) {
    84bc:	d1f7      	bne.n	84ae <main+0x1a>
{
	return (int)lrand48();
}
__extern_inline void srand(unsigned int __s)
{
	srand48(__s);
    84be:	f000 fdbf 	bl	9040 <srand48>
        seed <<= 8;
    }
    srand(seed);

    /* Initialize msys mbufs. */
    rc = os_mempool_init(&bleprph_mbuf_mpool, MBUF_NUM_MBUFS,
    84c2:	4b73      	ldr	r3, [pc, #460]	; (8690 <main+0x1fc>)
    84c4:	9300      	str	r3, [sp, #0]
    84c6:	4873      	ldr	r0, [pc, #460]	; (8694 <main+0x200>)
    84c8:	4b73      	ldr	r3, [pc, #460]	; (8698 <main+0x204>)
    84ca:	210c      	movs	r1, #12
    84cc:	f44f 7292 	mov.w	r2, #292	; 0x124
    84d0:	f001 ff5e 	bl	a390 <os_mempool_init>
                         MBUF_MEMBLOCK_SIZE, bleprph_mbuf_mpool_data,
                         "bleprph_mbuf_data");
    assert(rc == 0);
    84d4:	4604      	mov	r4, r0
    84d6:	b130      	cbz	r0, 84e6 <main+0x52>
    84d8:	486b      	ldr	r0, [pc, #428]	; (8688 <main+0x1f4>)
    84da:	f240 115f 	movw	r1, #351	; 0x15f
    84de:	2200      	movs	r2, #0
    84e0:	4613      	mov	r3, r2
    84e2:	f001 fbf5 	bl	9cd0 <__assert_func>

    rc = os_mbuf_pool_init(&bleprph_mbuf_pool, &bleprph_mbuf_mpool,
    84e6:	486d      	ldr	r0, [pc, #436]	; (869c <main+0x208>)
    84e8:	496a      	ldr	r1, [pc, #424]	; (8694 <main+0x200>)
    84ea:	f44f 7292 	mov.w	r2, #292	; 0x124
    84ee:	230c      	movs	r3, #12
    84f0:	f001 fcec 	bl	9ecc <os_mbuf_pool_init>
                           MBUF_MEMBLOCK_SIZE, MBUF_NUM_MBUFS);
    assert(rc == 0);
    84f4:	4605      	mov	r5, r0
    84f6:	b118      	cbz	r0, 8500 <main+0x6c>
    84f8:	4863      	ldr	r0, [pc, #396]	; (8688 <main+0x1f4>)
    84fa:	f240 1163 	movw	r1, #355	; 0x163
    84fe:	e0be      	b.n	867e <main+0x1ea>

    rc = os_msys_register(&bleprph_mbuf_pool);
    8500:	4866      	ldr	r0, [pc, #408]	; (869c <main+0x208>)
    8502:	f001 fcc7 	bl	9e94 <os_msys_register>
    assert(rc == 0);
    8506:	4604      	mov	r4, r0
    8508:	b118      	cbz	r0, 8512 <main+0x7e>
    850a:	485f      	ldr	r0, [pc, #380]	; (8688 <main+0x1f4>)
    850c:	f44f 71b3 	mov.w	r1, #358	; 0x166
    8510:	e09b      	b.n	864a <main+0x1b6>

    /* Initialize the logging system. */
    log_init();
    8512:	f014 fe11 	bl	1d138 <log_init>
    log_console_handler_init(&bleprph_log_console_handler);
    8516:	4862      	ldr	r0, [pc, #392]	; (86a0 <main+0x20c>)
    8518:	f014 fec6 	bl	1d2a8 <log_console_handler_init>
    log_register("bleprph", &bleprph_log, &bleprph_log_console_handler);
    851c:	4961      	ldr	r1, [pc, #388]	; (86a4 <main+0x210>)
    851e:	4a60      	ldr	r2, [pc, #384]	; (86a0 <main+0x20c>)
    8520:	4861      	ldr	r0, [pc, #388]	; (86a8 <main+0x214>)
    8522:	f014 fe13 	bl	1d14c <log_register>

    os_task_init(&bleprph_task, "bleprph", bleprph_task_handler,
    8526:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    852a:	9301      	str	r3, [sp, #4]
    852c:	4b5f      	ldr	r3, [pc, #380]	; (86ac <main+0x218>)
    852e:	9302      	str	r3, [sp, #8]
    8530:	2701      	movs	r7, #1
    8532:	f44f 73a8 	mov.w	r3, #336	; 0x150
    8536:	9303      	str	r3, [sp, #12]
    8538:	495b      	ldr	r1, [pc, #364]	; (86a8 <main+0x214>)
    853a:	4a5d      	ldr	r2, [pc, #372]	; (86b0 <main+0x21c>)
    853c:	9700      	str	r7, [sp, #0]
    853e:	4623      	mov	r3, r4
    8540:	485c      	ldr	r0, [pc, #368]	; (86b4 <main+0x220>)
    8542:	f002 f8c1 	bl	a6c8 <os_task_init>
                 NULL, BLEPRPH_TASK_PRIO, OS_WAIT_FOREVER,
                 bleprph_stack, BLEPRPH_STACK_SIZE);

    /* Initialize the BLE LL */
    rc = ble_ll_init(BLE_LL_TASK_PRI, MBUF_NUM_MBUFS, BLE_MBUF_PAYLOAD_SIZE);
    8546:	4620      	mov	r0, r4
    8548:	210c      	movs	r1, #12
    854a:	f44f 7282 	mov.w	r2, #260	; 0x104
    854e:	f002 fe29 	bl	b1a4 <ble_ll_init>
    assert(rc == 0);
    8552:	4606      	mov	r6, r0
    8554:	b118      	cbz	r0, 855e <main+0xca>
    8556:	484c      	ldr	r0, [pc, #304]	; (8688 <main+0x1f4>)
    8558:	f240 1173 	movw	r1, #371	; 0x173
    855c:	e08f      	b.n	867e <main+0x1ea>

    /* Initialize the BLE host. */
    cfg = ble_hs_cfg_dflt;
    855e:	4d56      	ldr	r5, [pc, #344]	; (86b8 <main+0x224>)
    8560:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    8562:	ac05      	add	r4, sp, #20
    8564:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    8566:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    8568:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    856a:	682b      	ldr	r3, [r5, #0]
    856c:	6023      	str	r3, [r4, #0]
    cfg.max_hci_bufs = 3;
    856e:	2303      	movs	r3, #3
    8570:	f88d 3014 	strb.w	r3, [sp, #20]
    cfg.max_connections = 1;
    cfg.max_gattc_procs = 2;
    cfg.max_l2cap_chans = 3;
    8574:	f88d 301f 	strb.w	r3, [sp, #31]
    cfg.max_l2cap_sig_procs = 1;
    cfg.sm_bonding = 1;
    8578:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    assert(rc == 0);

    /* Initialize the BLE host. */
    cfg = ble_hs_cfg_dflt;
    cfg.max_hci_bufs = 3;
    cfg.max_connections = 1;
    857c:	f88d 7015 	strb.w	r7, [sp, #21]
    cfg.max_gattc_procs = 2;
    8580:	2202      	movs	r2, #2
    cfg.max_l2cap_chans = 3;
    cfg.max_l2cap_sig_procs = 1;
    cfg.sm_bonding = 1;
    8582:	4313      	orrs	r3, r2
    8584:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    cfg.sm_our_key_dist = BLE_SM_PAIR_KEY_DIST_ENC;
    cfg.sm_their_key_dist = BLE_SM_PAIR_KEY_DIST_ENC;
    cfg.store_read_cb = ble_store_ram_read;
    8588:	4b4c      	ldr	r3, [pc, #304]	; (86bc <main+0x228>)
    858a:	930a      	str	r3, [sp, #40]	; 0x28
    /* Populate config with the required GATT server settings. */
    cfg.max_attrs = 0;
    cfg.max_services = 0;
    cfg.max_client_configs = 0;

    rc = ble_svc_gap_init(&cfg);
    858c:	a805      	add	r0, sp, #20
    cfg.max_l2cap_sig_procs = 1;
    cfg.sm_bonding = 1;
    cfg.sm_our_key_dist = BLE_SM_PAIR_KEY_DIST_ENC;
    cfg.sm_their_key_dist = BLE_SM_PAIR_KEY_DIST_ENC;
    cfg.store_read_cb = ble_store_ram_read;
    cfg.store_write_cb = ble_store_ram_write;
    858e:	4b4c      	ldr	r3, [pc, #304]	; (86c0 <main+0x22c>)

    /* Initialize the BLE host. */
    cfg = ble_hs_cfg_dflt;
    cfg.max_hci_bufs = 3;
    cfg.max_connections = 1;
    cfg.max_gattc_procs = 2;
    8590:	f88d 201a 	strb.w	r2, [sp, #26]
    cfg.max_l2cap_chans = 3;
    cfg.max_l2cap_sig_procs = 1;
    8594:	f88d 7020 	strb.w	r7, [sp, #32]
    cfg.sm_bonding = 1;
    cfg.sm_our_key_dist = BLE_SM_PAIR_KEY_DIST_ENC;
    8598:	f88d 7024 	strb.w	r7, [sp, #36]	; 0x24
    cfg.sm_their_key_dist = BLE_SM_PAIR_KEY_DIST_ENC;
    859c:	f88d 7025 	strb.w	r7, [sp, #37]	; 0x25
    cfg.store_read_cb = ble_store_ram_read;
    cfg.store_write_cb = ble_store_ram_write;
    85a0:	930b      	str	r3, [sp, #44]	; 0x2c

    /* Populate config with the required GATT server settings. */
    cfg.max_attrs = 0;
    85a2:	f8ad 601c 	strh.w	r6, [sp, #28]
    cfg.max_services = 0;
    85a6:	f8ad 6016 	strh.w	r6, [sp, #22]
    cfg.max_client_configs = 0;
    85aa:	f8ad 6018 	strh.w	r6, [sp, #24]

    rc = ble_svc_gap_init(&cfg);
    85ae:	f014 fb3d 	bl	1cc2c <ble_svc_gap_init>
    assert(rc == 0);
    85b2:	4604      	mov	r4, r0
    85b4:	b120      	cbz	r0, 85c0 <main+0x12c>
    85b6:	4834      	ldr	r0, [pc, #208]	; (8688 <main+0x1f4>)
    85b8:	f44f 71c4 	mov.w	r1, #392	; 0x188
    85bc:	4632      	mov	r2, r6
    85be:	e78f      	b.n	84e0 <main+0x4c>

    rc = ble_svc_gatt_init(&cfg);
    85c0:	a805      	add	r0, sp, #20
    85c2:	f014 fb5f 	bl	1cc84 <ble_svc_gatt_init>
    assert(rc == 0);
    85c6:	4605      	mov	r5, r0
    85c8:	b118      	cbz	r0, 85d2 <main+0x13e>
    85ca:	482f      	ldr	r0, [pc, #188]	; (8688 <main+0x1f4>)
    85cc:	f240 118b 	movw	r1, #395	; 0x18b
    85d0:	e055      	b.n	867e <main+0x1ea>

    rc = gatt_svr_init(&cfg);
    85d2:	a805      	add	r0, sp, #20
    85d4:	f000 fab4 	bl	8b40 <gatt_svr_init>
    assert(rc == 0);
    85d8:	4604      	mov	r4, r0
    85da:	b118      	cbz	r0, 85e4 <main+0x150>
    85dc:	482a      	ldr	r0, [pc, #168]	; (8688 <main+0x1f4>)
    85de:	f44f 71c7 	mov.w	r1, #398	; 0x18e
    85e2:	e032      	b.n	864a <main+0x1b6>

    /* Initialize eventq */
    os_eventq_init(&bleprph_evq);
    85e4:	4837      	ldr	r0, [pc, #220]	; (86c4 <main+0x230>)
    85e6:	f001 fafb 	bl	9be0 <os_eventq_init>

    rc = ble_hs_init(&bleprph_evq, &cfg);
    85ea:	4836      	ldr	r0, [pc, #216]	; (86c4 <main+0x230>)
    85ec:	a905      	add	r1, sp, #20
    85ee:	f00c f993 	bl	14918 <ble_hs_init>
    assert(rc == 0);
    85f2:	b118      	cbz	r0, 85fc <main+0x168>
    85f4:	4824      	ldr	r0, [pc, #144]	; (8688 <main+0x1f4>)
    85f6:	f44f 71ca 	mov.w	r1, #404	; 0x194
    85fa:	e040      	b.n	867e <main+0x1ea>

    /* Initialize the console (for log output). */
    rc = console_init(NULL);
    85fc:	f001 f8e0 	bl	97c0 <console_init>
    assert(rc == 0);
    8600:	b118      	cbz	r0, 860a <main+0x176>
    8602:	4821      	ldr	r0, [pc, #132]	; (8688 <main+0x1f4>)
    8604:	f44f 71cc 	mov.w	r1, #408	; 0x198
    8608:	e769      	b.n	84de <main+0x4a>

    /* Register GATT attributes (services, characteristics, and
     * descriptors).
     */
    rc = ble_svc_gap_register();
    860a:	f014 fb07 	bl	1cc1c <ble_svc_gap_register>
    assert(rc == 0);
    860e:	4605      	mov	r5, r0
    8610:	b118      	cbz	r0, 861a <main+0x186>
    8612:	481d      	ldr	r0, [pc, #116]	; (8688 <main+0x1f4>)
    8614:	f44f 71cf 	mov.w	r1, #414	; 0x19e
    8618:	e761      	b.n	84de <main+0x4a>

    rc = ble_svc_gatt_register();
    861a:	f014 fb2b 	bl	1cc74 <ble_svc_gatt_register>
    assert(rc == 0);
    861e:	4604      	mov	r4, r0
    8620:	b118      	cbz	r0, 862a <main+0x196>
    8622:	4819      	ldr	r0, [pc, #100]	; (8688 <main+0x1f4>)
    8624:	f240 11a1 	movw	r1, #417	; 0x1a1
    8628:	e00f      	b.n	864a <main+0x1b6>

    rc = gatt_svr_register();
    862a:	f000 fa7f 	bl	8b2c <gatt_svr_register>
    assert(rc == 0);
    862e:	4605      	mov	r5, r0
    8630:	b118      	cbz	r0, 863a <main+0x1a6>
    8632:	4815      	ldr	r0, [pc, #84]	; (8688 <main+0x1f4>)
    8634:	f44f 71d2 	mov.w	r1, #420	; 0x1a4
    8638:	e021      	b.n	867e <main+0x1ea>

    /* Set the default device name. */
    rc = ble_svc_gap_device_name_set("ble-gpio");
    863a:	4823      	ldr	r0, [pc, #140]	; (86c8 <main+0x234>)
    863c:	f014 fad8 	bl	1cbf0 <ble_svc_gap_device_name_set>
    assert(rc == 0);
    8640:	4604      	mov	r4, r0
    8642:	b120      	cbz	r0, 864e <main+0x1ba>
    8644:	4810      	ldr	r0, [pc, #64]	; (8688 <main+0x1f4>)
    8646:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
    864a:	462a      	mov	r2, r5
    864c:	e748      	b.n	84e0 <main+0x4c>

    /* Init io_poll_task */
    rc = os_task_init(&io_poll_task, "io_poll_task", io_poll_task_handler,
    864e:	2202      	movs	r2, #2
    8650:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    8654:	e88d 000c 	stmia.w	sp, {r2, r3}
    8658:	4b1c      	ldr	r3, [pc, #112]	; (86cc <main+0x238>)
    865a:	9302      	str	r3, [sp, #8]
    865c:	f44f 7380 	mov.w	r3, #256	; 0x100
    8660:	491b      	ldr	r1, [pc, #108]	; (86d0 <main+0x23c>)
    8662:	4a1c      	ldr	r2, [pc, #112]	; (86d4 <main+0x240>)
    8664:	9303      	str	r3, [sp, #12]
    8666:	481c      	ldr	r0, [pc, #112]	; (86d8 <main+0x244>)
    8668:	4623      	mov	r3, r4
    866a:	f002 f82d 	bl	a6c8 <os_task_init>
            NULL, IO_POLL_TASK_PRIO, OS_WAIT_FOREVER, io_poll_stack,
            IO_POLL_STACK_SIZE);
    /* Init io_poll_evq */
    os_eventq_init(&io_poll_evq);
    866e:	481b      	ldr	r0, [pc, #108]	; (86dc <main+0x248>)
    8670:	f001 fab6 	bl	9be0 <os_eventq_init>

    /* Start the OS */
    os_start();
    8674:	f001 f938 	bl	98e8 <os_start>

    /* os start should never return. If it does, this should be an error */
    assert(0);
    8678:	4803      	ldr	r0, [pc, #12]	; (8688 <main+0x1f4>)
    867a:	f240 11b5 	movw	r1, #437	; 0x1b5
    867e:	4622      	mov	r2, r4
    8680:	e72e      	b.n	84e0 <main+0x4c>
    8682:	bf00      	nop
    8684:	000f4240 	.word	0x000f4240
    8688:	0001ec82 	.word	0x0001ec82
    868c:	200000d8 	.word	0x200000d8
    8690:	0001ee46 	.word	0x0001ee46
    8694:	200027e8 	.word	0x200027e8
    8698:	20001000 	.word	0x20001000
    869c:	20002818 	.word	0x20002818
    86a0:	20001db0 	.word	0x20001db0
    86a4:	20002ce0 	.word	0x20002ce0
    86a8:	0001ee58 	.word	0x0001ee58
    86ac:	20000854 	.word	0x20000854
    86b0:	00008229 	.word	0x00008229
    86b4:	20002c30 	.word	0x20002c30
    86b8:	0001fa44 	.word	0x0001fa44
    86bc:	0001ce75 	.word	0x0001ce75
    86c0:	0001cf35 	.word	0x0001cf35
    86c4:	20002804 	.word	0x20002804
    86c8:	0001ee60 	.word	0x0001ee60
    86cc:	20002824 	.word	0x20002824
    86d0:	0001ee69 	.word	0x0001ee69
    86d4:	00008aa1 	.word	0x00008aa1
    86d8:	20002c90 	.word	0x20002c90
    86dc:	200027d8 	.word	0x200027d8

000086e0 <print_addr>:
    }
}

void
print_addr(const void *addr)
{
    86e0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    const uint8_t *u8p;

    u8p = addr;
    BLEPRPH_LOG(INFO, "%02x:%02x:%02x:%02x:%02x:%02x",
    86e2:	7943      	ldrb	r3, [r0, #5]
    86e4:	9300      	str	r3, [sp, #0]
    86e6:	7903      	ldrb	r3, [r0, #4]
    86e8:	9301      	str	r3, [sp, #4]
    86ea:	78c3      	ldrb	r3, [r0, #3]
    86ec:	9302      	str	r3, [sp, #8]
    86ee:	7883      	ldrb	r3, [r0, #2]
    86f0:	9303      	str	r3, [sp, #12]
    86f2:	7843      	ldrb	r3, [r0, #1]
    86f4:	9304      	str	r3, [sp, #16]
    86f6:	7803      	ldrb	r3, [r0, #0]
    86f8:	9305      	str	r3, [sp, #20]
    86fa:	4804      	ldr	r0, [pc, #16]	; (870c <print_addr+0x2c>)
    86fc:	4b04      	ldr	r3, [pc, #16]	; (8710 <print_addr+0x30>)
    86fe:	2140      	movs	r1, #64	; 0x40
    8700:	2201      	movs	r2, #1
    8702:	f014 fd91 	bl	1d228 <log_printf>
                u8p[5], u8p[4], u8p[3], u8p[2], u8p[1], u8p[0]);
}
    8706:	b007      	add	sp, #28
    8708:	f85d fb04 	ldr.w	pc, [sp], #4
    870c:	20002ce0 	.word	0x20002ce0
    8710:	0001ee7f 	.word	0x0001ee7f

00008714 <gatt_svr_chr_access_gpio_notif>:
 */
static int
gatt_svr_chr_access_gpio_notif(uint16_t conn_handle, uint16_t attr_handle, 
                               struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    assert(0);
    8714:	2200      	movs	r2, #0
 * This should never be called
 */
static int
gatt_svr_chr_access_gpio_notif(uint16_t conn_handle, uint16_t attr_handle, 
                               struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    8716:	b508      	push	{r3, lr}
    assert(0);
    8718:	4802      	ldr	r0, [pc, #8]	; (8724 <gatt_svr_chr_access_gpio_notif+0x10>)
    871a:	f240 1187 	movw	r1, #391	; 0x187
    871e:	4613      	mov	r3, r2
    8720:	f001 fad6 	bl	9cd0 <__assert_func>
    8724:	0001eef1 	.word	0x0001eef1

00008728 <gatt_svr_uuid_to_s>:
    return BLE_ATT_ERR_UNLIKELY; 
}

static char *
gatt_svr_uuid_to_s(const void *uuid128, char *dst)
{
    8728:	b530      	push	{r4, r5, lr}
    872a:	b087      	sub	sp, #28
    872c:	4604      	mov	r4, r0
    872e:	460d      	mov	r5, r1
    const uint8_t *u8p;
    uint16_t uuid16;

    uuid16 = ble_uuid_128_to_16(uuid128);
    8730:	f00f feb2 	bl	18498 <ble_uuid_128_to_16>
    if (uuid16 != 0) {
    8734:	4602      	mov	r2, r0
    8736:	b120      	cbz	r0, 8742 <gatt_svr_uuid_to_s+0x1a>
        sprintf(dst, "0x%04x", uuid16);
    8738:	4628      	mov	r0, r5
    873a:	4917      	ldr	r1, [pc, #92]	; (8798 <gatt_svr_uuid_to_s+0x70>)
    873c:	f000 fc71 	bl	9022 <sprintf>
        return dst;
    8740:	e027      	b.n	8792 <gatt_svr_uuid_to_s+0x6a>
    }

    u8p = uuid128;

    sprintf(dst,      "%02x%02x%02x%02x-", u8p[15], u8p[14], u8p[13], u8p[12]);
    8742:	7b61      	ldrb	r1, [r4, #13]
    8744:	9100      	str	r1, [sp, #0]
    8746:	7b21      	ldrb	r1, [r4, #12]
    8748:	7be2      	ldrb	r2, [r4, #15]
    874a:	7ba3      	ldrb	r3, [r4, #14]
    874c:	9101      	str	r1, [sp, #4]
    874e:	4628      	mov	r0, r5
    8750:	4912      	ldr	r1, [pc, #72]	; (879c <gatt_svr_uuid_to_s+0x74>)
    8752:	f000 fc66 	bl	9022 <sprintf>
    sprintf(dst + 9,  "%02x%02x-%02x%02x-", u8p[11], u8p[10], u8p[9], u8p[8]);
    8756:	7a61      	ldrb	r1, [r4, #9]
    8758:	9100      	str	r1, [sp, #0]
    875a:	7a21      	ldrb	r1, [r4, #8]
    875c:	7ae2      	ldrb	r2, [r4, #11]
    875e:	7aa3      	ldrb	r3, [r4, #10]
    8760:	9101      	str	r1, [sp, #4]
    8762:	f105 0009 	add.w	r0, r5, #9
    8766:	490e      	ldr	r1, [pc, #56]	; (87a0 <gatt_svr_uuid_to_s+0x78>)
    8768:	f000 fc5b 	bl	9022 <sprintf>
    sprintf(dst + 19, "%02x%02x%02x%02x%02x%02x%02x%02x",
    876c:	7961      	ldrb	r1, [r4, #5]
    876e:	9100      	str	r1, [sp, #0]
    8770:	7921      	ldrb	r1, [r4, #4]
    8772:	9101      	str	r1, [sp, #4]
    8774:	78e1      	ldrb	r1, [r4, #3]
    8776:	9102      	str	r1, [sp, #8]
    8778:	78a1      	ldrb	r1, [r4, #2]
    877a:	9103      	str	r1, [sp, #12]
    877c:	7861      	ldrb	r1, [r4, #1]
    877e:	9104      	str	r1, [sp, #16]
    8780:	7821      	ldrb	r1, [r4, #0]
    8782:	9105      	str	r1, [sp, #20]
    8784:	79e2      	ldrb	r2, [r4, #7]
    8786:	79a3      	ldrb	r3, [r4, #6]
    8788:	4906      	ldr	r1, [pc, #24]	; (87a4 <gatt_svr_uuid_to_s+0x7c>)
    878a:	f105 0013 	add.w	r0, r5, #19
    878e:	f000 fc48 	bl	9022 <sprintf>
            u8p[7], u8p[6], u8p[5], u8p[4], u8p[3], u8p[2], u8p[1], u8p[0]);

    return dst;
}
    8792:	4628      	mov	r0, r5
    8794:	b007      	add	sp, #28
    8796:	bd30      	pop	{r4, r5, pc}
    8798:	00020987 	.word	0x00020987
    879c:	0001eefc 	.word	0x0001eefc
    87a0:	0001ef0e 	.word	0x0001ef0e
    87a4:	0001f778 	.word	0x0001f778

000087a8 <gatt_svr_register_cb>:

static void
gatt_svr_register_cb(struct ble_gatt_register_ctxt *ctxt, void *arg)
{
    87a8:	b510      	push	{r4, lr}
    char buf[40];

    switch (ctxt->op) {
    87aa:	7803      	ldrb	r3, [r0, #0]
    87ac:	2b02      	cmp	r3, #2
    return dst;
}

static void
gatt_svr_register_cb(struct ble_gatt_register_ctxt *ctxt, void *arg)
{
    87ae:	b08e      	sub	sp, #56	; 0x38
    87b0:	4604      	mov	r4, r0
    char buf[40];

    switch (ctxt->op) {
    87b2:	d010      	beq.n	87d6 <gatt_svr_register_cb+0x2e>
    87b4:	2b03      	cmp	r3, #3
    87b6:	d01f      	beq.n	87f8 <gatt_svr_register_cb+0x50>
    87b8:	2b01      	cmp	r3, #1
    87ba:	d12c      	bne.n	8816 <gatt_svr_register_cb+0x6e>
    case BLE_GATT_REGISTER_OP_SVC:
        BLEPRPH_LOG(DEBUG, "registered service %s with handle=%d\n",
    87bc:	6883      	ldr	r3, [r0, #8]
    87be:	a904      	add	r1, sp, #16
    87c0:	6858      	ldr	r0, [r3, #4]
    87c2:	f7ff ffb1 	bl	8728 <gatt_svr_uuid_to_s>
    87c6:	88a3      	ldrh	r3, [r4, #4]
    87c8:	9000      	str	r0, [sp, #0]
    87ca:	9301      	str	r3, [sp, #4]
    87cc:	4816      	ldr	r0, [pc, #88]	; (8828 <gatt_svr_register_cb+0x80>)
    87ce:	4b17      	ldr	r3, [pc, #92]	; (882c <gatt_svr_register_cb+0x84>)
    87d0:	2140      	movs	r1, #64	; 0x40
    87d2:	2200      	movs	r2, #0
    87d4:	e01c      	b.n	8810 <gatt_svr_register_cb+0x68>
                    gatt_svr_uuid_to_s(ctxt->svc.svc_def->uuid128, buf),
                    ctxt->svc.handle);
        break;

    case BLE_GATT_REGISTER_OP_CHR:
        BLEPRPH_LOG(DEBUG, "registering characteristic %s with "
    87d6:	6883      	ldr	r3, [r0, #8]
    87d8:	a904      	add	r1, sp, #16
    87da:	6818      	ldr	r0, [r3, #0]
    87dc:	f7ff ffa4 	bl	8728 <gatt_svr_uuid_to_s>
    87e0:	88a3      	ldrh	r3, [r4, #4]
    87e2:	9301      	str	r3, [sp, #4]
    87e4:	88e3      	ldrh	r3, [r4, #6]
    87e6:	9000      	str	r0, [sp, #0]
    87e8:	9302      	str	r3, [sp, #8]
    87ea:	480f      	ldr	r0, [pc, #60]	; (8828 <gatt_svr_register_cb+0x80>)
    87ec:	4b10      	ldr	r3, [pc, #64]	; (8830 <gatt_svr_register_cb+0x88>)
    87ee:	2140      	movs	r1, #64	; 0x40
    87f0:	2200      	movs	r2, #0
    87f2:	f014 fd19 	bl	1d228 <log_printf>
                           "def_handle=%d val_handle=%d\n",
                    gatt_svr_uuid_to_s(ctxt->chr.chr_def->uuid128, buf),
                    ctxt->chr.def_handle,
                    ctxt->chr.val_handle);
        break;
    87f6:	e015      	b.n	8824 <gatt_svr_register_cb+0x7c>

    case BLE_GATT_REGISTER_OP_DSC:
        BLEPRPH_LOG(DEBUG, "registering descriptor %s with handle=%d\n",
    87f8:	6883      	ldr	r3, [r0, #8]
    87fa:	a904      	add	r1, sp, #16
    87fc:	6818      	ldr	r0, [r3, #0]
    87fe:	f7ff ff93 	bl	8728 <gatt_svr_uuid_to_s>
    8802:	88a3      	ldrh	r3, [r4, #4]
    8804:	9000      	str	r0, [sp, #0]
    8806:	9301      	str	r3, [sp, #4]
    8808:	4807      	ldr	r0, [pc, #28]	; (8828 <gatt_svr_register_cb+0x80>)
    880a:	4b0a      	ldr	r3, [pc, #40]	; (8834 <gatt_svr_register_cb+0x8c>)
    880c:	2140      	movs	r1, #64	; 0x40
    880e:	2200      	movs	r2, #0
    8810:	f014 fd0a 	bl	1d228 <log_printf>
                    gatt_svr_uuid_to_s(ctxt->dsc.dsc_def->uuid128, buf),
                    ctxt->dsc.handle);
        break;
    8814:	e006      	b.n	8824 <gatt_svr_register_cb+0x7c>

    default:
        assert(0);
    8816:	2200      	movs	r2, #0
    8818:	4807      	ldr	r0, [pc, #28]	; (8838 <gatt_svr_register_cb+0x90>)
    881a:	f44f 71de 	mov.w	r1, #444	; 0x1bc
    881e:	4613      	mov	r3, r2
    8820:	f001 fa56 	bl	9cd0 <__assert_func>
        break;
    }
}
    8824:	b00e      	add	sp, #56	; 0x38
    8826:	bd10      	pop	{r4, pc}
    8828:	20002ce0 	.word	0x20002ce0
    882c:	0001ef21 	.word	0x0001ef21
    8830:	0001ef47 	.word	0x0001ef47
    8834:	0001ef87 	.word	0x0001ef87
    8838:	0001eef1 	.word	0x0001eef1

0000883c <gatt_svr_chr_write.isra.1>:
        0, /* No more services. */
    },
};

static int
gatt_svr_chr_write(uint8_t op, struct ble_gatt_access_ctxt *ctxt,
    883c:	b570      	push	{r4, r5, r6, lr}
                   uint16_t min_len, uint16_t max_len, void *dst,
                   uint16_t *len)
{
    assert(op == BLE_GATT_ACCESS_OP_WRITE_CHR);
    883e:	2801      	cmp	r0, #1
        0, /* No more services. */
    },
};

static int
gatt_svr_chr_write(uint8_t op, struct ble_gatt_access_ctxt *ctxt,
    8840:	460d      	mov	r5, r1
    8842:	4616      	mov	r6, r2
    8844:	9c05      	ldr	r4, [sp, #20]
                   uint16_t min_len, uint16_t max_len, void *dst,
                   uint16_t *len)
{
    assert(op == BLE_GATT_ACCESS_OP_WRITE_CHR);
    8846:	d005      	beq.n	8854 <gatt_svr_chr_write.isra.1+0x18>
    8848:	2200      	movs	r2, #0
    884a:	480b      	ldr	r0, [pc, #44]	; (8878 <gatt_svr_chr_write.isra.1+0x3c>)
    884c:	2197      	movs	r1, #151	; 0x97
    884e:	4613      	mov	r3, r2
    8850:	f001 fa3e 	bl	9cd0 <__assert_func>
    if (ctxt->att->write.len < min_len ||
    8854:	6809      	ldr	r1, [r1, #0]
    8856:	688a      	ldr	r2, [r1, #8]
    8858:	42b2      	cmp	r2, r6
    885a:	db0b      	blt.n	8874 <gatt_svr_chr_write.isra.1+0x38>
    885c:	429a      	cmp	r2, r3
    885e:	dc09      	bgt.n	8874 <gatt_svr_chr_write.isra.1+0x38>
        ctxt->att->write.len > max_len) {

        return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
    }

    memcpy(dst, ctxt->att->write.data, ctxt->att->write.len);
    8860:	9804      	ldr	r0, [sp, #16]
    8862:	6809      	ldr	r1, [r1, #0]
    8864:	f000 fbca 	bl	8ffc <memcpy>
    if (len != NULL) {
    8868:	b114      	cbz	r4, 8870 <gatt_svr_chr_write.isra.1+0x34>
        *len = ctxt->att->write.len;
    886a:	682b      	ldr	r3, [r5, #0]
    886c:	689b      	ldr	r3, [r3, #8]
    886e:	8023      	strh	r3, [r4, #0]
    }

    return 0;
    8870:	2000      	movs	r0, #0
    8872:	bd70      	pop	{r4, r5, r6, pc}
{
    assert(op == BLE_GATT_ACCESS_OP_WRITE_CHR);
    if (ctxt->att->write.len < min_len ||
        ctxt->att->write.len > max_len) {

        return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
    8874:	200d      	movs	r0, #13
    8876:	bd70      	pop	{r4, r5, r6, pc}
    8878:	0001eef1 	.word	0x0001eef1

0000887c <gatt_svr_chr_access_gpio>:
 * and return.
 */ 
static int
gatt_svr_chr_access_gpio(uint16_t conn_handle, uint16_t attr_handle,
                            struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    887c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    void const *uuid128;
    uint8_t op;
    int rc;

    uuid128 = ctxt->chr->uuid128;
    8880:	6853      	ldr	r3, [r2, #4]
    op = ctxt->op;
    8882:	7817      	ldrb	r7, [r2, #0]
     
    /* Check that the UUID is correct */
    if (memcmp(uuid128, gatt_svr_chr_gpio, 16) == 0) {
    8884:	6818      	ldr	r0, [r3, #0]
    8886:	4946      	ldr	r1, [pc, #280]	; (89a0 <gatt_svr_chr_access_gpio+0x124>)
 * and return.
 */ 
static int
gatt_svr_chr_access_gpio(uint16_t conn_handle, uint16_t attr_handle,
                            struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    8888:	4614      	mov	r4, r2

    uuid128 = ctxt->chr->uuid128;
    op = ctxt->op;
     
    /* Check that the UUID is correct */
    if (memcmp(uuid128, gatt_svr_chr_gpio, 16) == 0) {
    888a:	2210      	movs	r2, #16
    888c:	f000 fba8 	bl	8fe0 <memcmp>
    8890:	4605      	mov	r5, r0
    8892:	2800      	cmp	r0, #0
    8894:	d17b      	bne.n	898e <gatt_svr_chr_access_gpio+0x112>
        /* Use the op to determine whether access is read/write */
        switch (op) {
    8896:	b117      	cbz	r7, 889e <gatt_svr_chr_access_gpio+0x22>
    8898:	2f01      	cmp	r7, #1
    889a:	d007      	beq.n	88ac <gatt_svr_chr_access_gpio+0x30>
    889c:	e072      	b.n	8984 <gatt_svr_chr_access_gpio+0x108>
        case BLE_GATT_ACCESS_OP_READ_CHR:
            /* Read access */
            assert( op == BLE_GATT_ACCESS_OP_READ_CHR);
            /* Set the chr_access data and length fields */
            ctxt->att->read.data = &gatt_svr_gpio_read_val;
    889e:	68a3      	ldr	r3, [r4, #8]
    88a0:	4a40      	ldr	r2, [pc, #256]	; (89a4 <gatt_svr_chr_access_gpio+0x128>)
    88a2:	609a      	str	r2, [r3, #8]
            ctxt->att->read.len = sizeof gatt_svr_gpio_read_val;
    88a4:	68a3      	ldr	r3, [r4, #8]
    88a6:	2202      	movs	r2, #2
    88a8:	819a      	strh	r2, [r3, #12]
            return 0;
    88aa:	e075      	b.n	8998 <gatt_svr_chr_access_gpio+0x11c>

        case BLE_GATT_ACCESS_OP_WRITE_CHR:
            /* Write access */
            assert(op == BLE_GATT_ACCESS_OP_WRITE_CHR);
            /* Write received data to gpio instr field */ 
            rc = gatt_svr_chr_write(op, ctxt,
    88ac:	2202      	movs	r2, #2
    88ae:	4e3e      	ldr	r6, [pc, #248]	; (89a8 <gatt_svr_chr_access_gpio+0x12c>)
    88b0:	9001      	str	r0, [sp, #4]
    88b2:	9600      	str	r6, [sp, #0]
    88b4:	4638      	mov	r0, r7
    88b6:	f104 0108 	add.w	r1, r4, #8
    88ba:	4613      	mov	r3, r2
    88bc:	f7ff ffbe 	bl	883c <gatt_svr_chr_write.isra.1>
                                    sizeof gatt_svr_gpio_instr,
                                    sizeof gatt_svr_gpio_instr,
                                    &gatt_svr_gpio_instr, NULL);
            assert(rc == 0);
    88c0:	4680      	mov	r8, r0
    88c2:	b118      	cbz	r0, 88cc <gatt_svr_chr_access_gpio+0x50>
    88c4:	4839      	ldr	r0, [pc, #228]	; (89ac <gatt_svr_chr_access_gpio+0x130>)
    88c6:	f240 1127 	movw	r1, #295	; 0x127
    88ca:	e05e      	b.n	898a <gatt_svr_chr_access_gpio+0x10e>
            /* Parse instruction into parts */
            uint8_t pin = gatt_svr_gpio_instr >> 8;
    88cc:	8835      	ldrh	r5, [r6, #0]
            uint8_t dir = (gatt_svr_gpio_instr & 0x00f0) >> 4;
            uint32_t val = gatt_svr_gpio_instr & 0x000f;
            BLEPRPH_LOG(INFO, "Instruction received: pin=%u, dir=%u, " \
    88ce:	4838      	ldr	r0, [pc, #224]	; (89b0 <gatt_svr_chr_access_gpio+0x134>)
    88d0:	4b38      	ldr	r3, [pc, #224]	; (89b4 <gatt_svr_chr_access_gpio+0x138>)
                                    sizeof gatt_svr_gpio_instr,
                                    sizeof gatt_svr_gpio_instr,
                                    &gatt_svr_gpio_instr, NULL);
            assert(rc == 0);
            /* Parse instruction into parts */
            uint8_t pin = gatt_svr_gpio_instr >> 8;
    88d2:	0a2c      	lsrs	r4, r5, #8
            uint8_t dir = (gatt_svr_gpio_instr & 0x00f0) >> 4;
    88d4:	f3c5 1603 	ubfx	r6, r5, #4, #4
            uint32_t val = gatt_svr_gpio_instr & 0x000f;
    88d8:	f005 050f 	and.w	r5, r5, #15
            BLEPRPH_LOG(INFO, "Instruction received: pin=%u, dir=%u, " \
    88dc:	e88d 0050 	stmia.w	sp, {r4, r6}
                                    &gatt_svr_gpio_instr, NULL);
            assert(rc == 0);
            /* Parse instruction into parts */
            uint8_t pin = gatt_svr_gpio_instr >> 8;
            uint8_t dir = (gatt_svr_gpio_instr & 0x00f0) >> 4;
            uint32_t val = gatt_svr_gpio_instr & 0x000f;
    88e0:	9502      	str	r5, [sp, #8]
            BLEPRPH_LOG(INFO, "Instruction received: pin=%u, dir=%u, " \
    88e2:	2140      	movs	r1, #64	; 0x40
    88e4:	463a      	mov	r2, r7
    88e6:	f014 fc9f 	bl	1d228 <log_printf>
                                "val=%u\n", pin, dir, val);
            
            assert(pin < 32 && pin >= 0);
    88ea:	2c1f      	cmp	r4, #31
    88ec:	d906      	bls.n	88fc <gatt_svr_chr_access_gpio+0x80>
    88ee:	482f      	ldr	r0, [pc, #188]	; (89ac <gatt_svr_chr_access_gpio+0x130>)
    88f0:	f240 112f 	movw	r1, #303	; 0x12f
    88f4:	4642      	mov	r2, r8
    88f6:	4613      	mov	r3, r2
    88f8:	f001 f9ea 	bl	9cd0 <__assert_func>
            /* Determine input/output from instruction direction */
            if (dir == GPIO_OUTPUT) {
    88fc:	2e01      	cmp	r6, #1
    88fe:	4b2e      	ldr	r3, [pc, #184]	; (89b8 <gatt_svr_chr_access_gpio+0x13c>)
    8900:	d119      	bne.n	8936 <gatt_svr_chr_access_gpio+0xba>
                /* Check if output pin has been initialized yet */
                if(pin_inits[pin] ==  GPIO_UNINITIALIZED) {
    8902:	5d1f      	ldrb	r7, [r3, r4]
    8904:	b997      	cbnz	r7, 892c <gatt_svr_chr_access_gpio+0xb0>
                    pin_inits[pin] = GPIO_OUTPUT;
    8906:	551e      	strb	r6, [r3, r4]
                    BLEPRPH_LOG(INFO, "Setting Pin %d as output...\n", pin);
    8908:	4829      	ldr	r0, [pc, #164]	; (89b0 <gatt_svr_chr_access_gpio+0x134>)
    890a:	9400      	str	r4, [sp, #0]
    890c:	2140      	movs	r1, #64	; 0x40
    890e:	4632      	mov	r2, r6
    8910:	4b2a      	ldr	r3, [pc, #168]	; (89bc <gatt_svr_chr_access_gpio+0x140>)
    8912:	f014 fc89 	bl	1d228 <log_printf>
                    rc = hal_gpio_init_out(pin, val);
    8916:	4620      	mov	r0, r4
    8918:	4629      	mov	r1, r5
    891a:	f000 fb2b 	bl	8f74 <hal_gpio_init_out>
                    assert(rc == 0);
    891e:	2800      	cmp	r0, #0
    8920:	d03a      	beq.n	8998 <gatt_svr_chr_access_gpio+0x11c>
    8922:	4822      	ldr	r0, [pc, #136]	; (89ac <gatt_svr_chr_access_gpio+0x130>)
    8924:	f240 1137 	movw	r1, #311	; 0x137
    8928:	463a      	mov	r2, r7
    892a:	e7e4      	b.n	88f6 <gatt_svr_chr_access_gpio+0x7a>
                } else {
                    /* If pin has been initialized, write val to pin */
                    hal_gpio_write(pin, val);
    892c:	4620      	mov	r0, r4
    892e:	4629      	mov	r1, r5
    8930:	f000 fb36 	bl	8fa0 <hal_gpio_write>
    8934:	e030      	b.n	8998 <gatt_svr_chr_access_gpio+0x11c>
                }
            } else if (dir == GPIO_INPUT) {
    8936:	2e02      	cmp	r6, #2
    8938:	d120      	bne.n	897c <gatt_svr_chr_access_gpio+0x100>
                /* Check if input pin has ben initialized yet */
                if(pin_inits[pin] == GPIO_UNINITIALIZED) {
    893a:	f813 8004 	ldrb.w	r8, [r3, r4]
    893e:	f1b8 0f00 	cmp.w	r8, #0
    8942:	d110      	bne.n	8966 <gatt_svr_chr_access_gpio+0xea>
                    pin_inits[pin] = GPIO_INPUT;
    8944:	551e      	strb	r6, [r3, r4]
                    BLEPRPH_LOG(INFO, "Setting Pin %d as input...\n", pin);
    8946:	481a      	ldr	r0, [pc, #104]	; (89b0 <gatt_svr_chr_access_gpio+0x134>)
    8948:	9400      	str	r4, [sp, #0]
    894a:	2140      	movs	r1, #64	; 0x40
    894c:	463a      	mov	r2, r7
    894e:	4b1c      	ldr	r3, [pc, #112]	; (89c0 <gatt_svr_chr_access_gpio+0x144>)
    8950:	f014 fc6a 	bl	1d228 <log_printf>
                    rc = hal_gpio_init_in(pin, val);
    8954:	4620      	mov	r0, r4
    8956:	4629      	mov	r1, r5
    8958:	f000 faf8 	bl	8f4c <hal_gpio_init_in>
                    assert(rc == 0);
    895c:	b118      	cbz	r0, 8966 <gatt_svr_chr_access_gpio+0xea>
    895e:	4813      	ldr	r0, [pc, #76]	; (89ac <gatt_svr_chr_access_gpio+0x130>)
    8960:	f44f 71a1 	mov.w	r1, #322	; 0x142
    8964:	e7c6      	b.n	88f4 <gatt_svr_chr_access_gpio+0x78>
                }
                /* Every instruction to an input pin should write the
                 * pin value to gatt_svr_read_val */
                uint16_t val = hal_gpio_read(pin) ? 1 : 0;
    8966:	4620      	mov	r0, r4
    8968:	f000 fb25 	bl	8fb6 <hal_gpio_read>
                pin_vals[pin] = val;
    896c:	4b15      	ldr	r3, [pc, #84]	; (89c4 <gatt_svr_chr_access_gpio+0x148>)
                    rc = hal_gpio_init_in(pin, val);
                    assert(rc == 0);
                }
                /* Every instruction to an input pin should write the
                 * pin value to gatt_svr_read_val */
                uint16_t val = hal_gpio_read(pin) ? 1 : 0;
    896e:	3000      	adds	r0, #0
    8970:	bf18      	it	ne
    8972:	2001      	movne	r0, #1
                pin_vals[pin] = val;
    8974:	5518      	strb	r0, [r3, r4]
                memcpy(&gatt_svr_gpio_read_val, &val, sizeof val);
    8976:	4b0b      	ldr	r3, [pc, #44]	; (89a4 <gatt_svr_chr_access_gpio+0x128>)
                    rc = hal_gpio_init_in(pin, val);
                    assert(rc == 0);
                }
                /* Every instruction to an input pin should write the
                 * pin value to gatt_svr_read_val */
                uint16_t val = hal_gpio_read(pin) ? 1 : 0;
    8978:	8018      	strh	r0, [r3, #0]
    897a:	e00d      	b.n	8998 <gatt_svr_chr_access_gpio+0x11c>
                pin_vals[pin] = val;
                memcpy(&gatt_svr_gpio_read_val, &val, sizeof val);
            } else {
                /* Invalid direction */
                assert(0);
    897c:	480b      	ldr	r0, [pc, #44]	; (89ac <gatt_svr_chr_access_gpio+0x130>)
    897e:	f240 114b 	movw	r1, #331	; 0x14b
    8982:	e7b7      	b.n	88f4 <gatt_svr_chr_access_gpio+0x78>
                return BLE_ATT_ERR_UNLIKELY; 
            }
            return rc;
        default:
            assert(0);
    8984:	4809      	ldr	r0, [pc, #36]	; (89ac <gatt_svr_chr_access_gpio+0x130>)
    8986:	f44f 71a8 	mov.w	r1, #336	; 0x150
    898a:	462a      	mov	r2, r5
    898c:	e7b3      	b.n	88f6 <gatt_svr_chr_access_gpio+0x7a>
        }
    }
    /* Unknown characteristic; the nimble stack should not have called this
     * function.
     */
    assert(0);
    898e:	4807      	ldr	r0, [pc, #28]	; (89ac <gatt_svr_chr_access_gpio+0x130>)
    8990:	f240 1157 	movw	r1, #343	; 0x157
    8994:	2200      	movs	r2, #0
    8996:	e7ae      	b.n	88f6 <gatt_svr_chr_access_gpio+0x7a>
    return BLE_ATT_ERR_UNLIKELY;
}
    8998:	2000      	movs	r0, #0
    899a:	b004      	add	sp, #16
    899c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    89a0:	0001ee9d 	.word	0x0001ee9d
    89a4:	20001dee 	.word	0x20001dee
    89a8:	20001df2 	.word	0x20001df2
    89ac:	0001eef1 	.word	0x0001eef1
    89b0:	20002ce0 	.word	0x20002ce0
    89b4:	0001efb1 	.word	0x0001efb1
    89b8:	20001e36 	.word	0x20001e36
    89bc:	0001efdf 	.word	0x0001efdf
    89c0:	0001effc 	.word	0x0001effc
    89c4:	20001dce 	.word	0x20001dce

000089c8 <gatt_svr_chr_access_alert>:

static int
gatt_svr_chr_access_alert(uint16_t conn_handle, uint16_t attr_handle,
                          struct ble_gatt_access_ctxt *ctxt,
                          void *arg)
{
    89c8:	b513      	push	{r0, r1, r4, lr}
    uint16_t uuid16;
    int rc;

    uuid16 = ble_uuid_128_to_16(ctxt->chr->uuid128);
    89ca:	6853      	ldr	r3, [r2, #4]
    89cc:	6818      	ldr	r0, [r3, #0]

static int
gatt_svr_chr_access_alert(uint16_t conn_handle, uint16_t attr_handle,
                          struct ble_gatt_access_ctxt *ctxt,
                          void *arg)
{
    89ce:	4614      	mov	r4, r2
    uint16_t uuid16;
    int rc;

    uuid16 = ble_uuid_128_to_16(ctxt->chr->uuid128);
    89d0:	f00f fd62 	bl	18498 <ble_uuid_128_to_16>
    assert(uuid16 != 0);
    89d4:	4602      	mov	r2, r0
    89d6:	b910      	cbnz	r0, 89de <gatt_svr_chr_access_alert+0x16>
    89d8:	482a      	ldr	r0, [pc, #168]	; (8a84 <gatt_svr_chr_access_alert+0xbc>)
    89da:	21b8      	movs	r1, #184	; 0xb8
    89dc:	e00e      	b.n	89fc <gatt_svr_chr_access_alert+0x34>

    switch (uuid16) {
    89de:	f5a0 5229 	sub.w	r2, r0, #10816	; 0x2a40
    89e2:	3a04      	subs	r2, #4
    89e4:	2a04      	cmp	r2, #4
    89e6:	d847      	bhi.n	8a78 <gatt_svr_chr_access_alert+0xb0>
    89e8:	e8df f002 	tbb	[pc, r2]
    89ec:	030e2d38 	.word	0x030e2d38
    89f0:	21          	.byte	0x21
    89f1:	00          	.byte	0x00
    case GATT_SVR_CHR_SUP_NEW_ALERT_CAT_UUID:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR);
    89f2:	7820      	ldrb	r0, [r4, #0]
    89f4:	b128      	cbz	r0, 8a02 <gatt_svr_chr_access_alert+0x3a>
    89f6:	4823      	ldr	r0, [pc, #140]	; (8a84 <gatt_svr_chr_access_alert+0xbc>)
    89f8:	21bc      	movs	r1, #188	; 0xbc
    89fa:	2200      	movs	r2, #0
    89fc:	4613      	mov	r3, r2
    89fe:	f001 f967 	bl	9cd0 <__assert_func>
        ctxt->att->read.data = &gatt_svr_new_alert_cat;
    8a02:	68a3      	ldr	r3, [r4, #8]
    8a04:	4a20      	ldr	r2, [pc, #128]	; (8a88 <gatt_svr_chr_access_alert+0xc0>)
    8a06:	e019      	b.n	8a3c <gatt_svr_chr_access_alert+0x74>
        ctxt->att->read.len = sizeof gatt_svr_new_alert_cat;
        return 0;

    case GATT_SVR_CHR_NEW_ALERT:
        if (ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR) {
    8a08:	7820      	ldrb	r0, [r4, #0]
    8a0a:	2801      	cmp	r0, #1
    8a0c:	d108      	bne.n	8a20 <gatt_svr_chr_access_alert+0x58>
            rc = gatt_svr_chr_write(ctxt->op, ctxt, 0,
    8a0e:	4b1f      	ldr	r3, [pc, #124]	; (8a8c <gatt_svr_chr_access_alert+0xc4>)
    8a10:	9300      	str	r3, [sp, #0]
    8a12:	4b1f      	ldr	r3, [pc, #124]	; (8a90 <gatt_svr_chr_access_alert+0xc8>)
    8a14:	9301      	str	r3, [sp, #4]
    8a16:	f104 0108 	add.w	r1, r4, #8
    8a1a:	2200      	movs	r2, #0
    8a1c:	2340      	movs	r3, #64	; 0x40
    8a1e:	e028      	b.n	8a72 <gatt_svr_chr_access_alert+0xaa>
                                    sizeof gatt_svr_new_alert_val,
                                    gatt_svr_new_alert_val,
                                    &gatt_svr_new_alert_val_len);
            return rc;
        } else if (ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR) {
    8a20:	b928      	cbnz	r0, 8a2e <gatt_svr_chr_access_alert+0x66>
            ctxt->att->read.data = (void *)&gatt_svr_new_alert_val;
    8a22:	68a3      	ldr	r3, [r4, #8]
    8a24:	4a19      	ldr	r2, [pc, #100]	; (8a8c <gatt_svr_chr_access_alert+0xc4>)
    8a26:	609a      	str	r2, [r3, #8]
            ctxt->att->read.len = sizeof gatt_svr_new_alert_val;
    8a28:	68a3      	ldr	r3, [r4, #8]
    8a2a:	2240      	movs	r2, #64	; 0x40
    8a2c:	e009      	b.n	8a42 <gatt_svr_chr_access_alert+0x7a>
            return 0;
        }

    case GATT_SVR_CHR_SUP_UNR_ALERT_CAT_UUID:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR);
    8a2e:	7820      	ldrb	r0, [r4, #0]
    8a30:	b110      	cbz	r0, 8a38 <gatt_svr_chr_access_alert+0x70>
    8a32:	4814      	ldr	r0, [pc, #80]	; (8a84 <gatt_svr_chr_access_alert+0xbc>)
    8a34:	21cf      	movs	r1, #207	; 0xcf
    8a36:	e7e0      	b.n	89fa <gatt_svr_chr_access_alert+0x32>
        ctxt->att->read.data = &gatt_svr_unr_alert_cat;
    8a38:	68a3      	ldr	r3, [r4, #8]
    8a3a:	4a16      	ldr	r2, [pc, #88]	; (8a94 <gatt_svr_chr_access_alert+0xcc>)
    8a3c:	609a      	str	r2, [r3, #8]
        ctxt->att->read.len = sizeof gatt_svr_unr_alert_cat;
    8a3e:	68a3      	ldr	r3, [r4, #8]
    8a40:	2201      	movs	r2, #1
    8a42:	819a      	strh	r2, [r3, #12]
        return 0;
    8a44:	e01c      	b.n	8a80 <gatt_svr_chr_access_alert+0xb8>

    case GATT_SVR_CHR_UNR_ALERT_STAT_UUID:
        if (ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR) {
    8a46:	7820      	ldrb	r0, [r4, #0]
    8a48:	4b13      	ldr	r3, [pc, #76]	; (8a98 <gatt_svr_chr_access_alert+0xd0>)
    8a4a:	2801      	cmp	r0, #1
    8a4c:	d00a      	beq.n	8a64 <gatt_svr_chr_access_alert+0x9c>
            rc = gatt_svr_chr_write(ctxt->op, ctxt, 2, 2,
                                    &gatt_svr_unr_alert_stat,
                                    NULL);
        } else {
            ctxt->att->read.data = &gatt_svr_unr_alert_stat;
    8a4e:	68a2      	ldr	r2, [r4, #8]
    8a50:	6093      	str	r3, [r2, #8]
            ctxt->att->read.len = sizeof gatt_svr_unr_alert_stat;
    8a52:	68a3      	ldr	r3, [r4, #8]
    8a54:	2202      	movs	r2, #2
    8a56:	819a      	strh	r2, [r3, #12]
            rc = 0;
    8a58:	2000      	movs	r0, #0
    8a5a:	e011      	b.n	8a80 <gatt_svr_chr_access_alert+0xb8>
        }
        return rc;

    case GATT_SVR_CHR_ALERT_NOT_CTRL_PT:
        if (ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR) {
    8a5c:	7820      	ldrb	r0, [r4, #0]
    8a5e:	2801      	cmp	r0, #1
    8a60:	d10d      	bne.n	8a7e <gatt_svr_chr_access_alert+0xb6>
            rc = gatt_svr_chr_write(ctxt->op, ctxt, 2, 2,
    8a62:	4b0e      	ldr	r3, [pc, #56]	; (8a9c <gatt_svr_chr_access_alert+0xd4>)
    8a64:	9300      	str	r3, [sp, #0]
    8a66:	2202      	movs	r2, #2
    8a68:	2300      	movs	r3, #0
    8a6a:	9301      	str	r3, [sp, #4]
    8a6c:	f104 0108 	add.w	r1, r4, #8
    8a70:	4613      	mov	r3, r2
    8a72:	f7ff fee3 	bl	883c <gatt_svr_chr_write.isra.1>
    8a76:	e003      	b.n	8a80 <gatt_svr_chr_access_alert+0xb8>
            rc = BLE_ATT_ERR_UNLIKELY;
        }
        return rc;

    default:
        assert(0);
    8a78:	4802      	ldr	r0, [pc, #8]	; (8a84 <gatt_svr_chr_access_alert+0xbc>)
    8a7a:	21ea      	movs	r1, #234	; 0xea
    8a7c:	e7bd      	b.n	89fa <gatt_svr_chr_access_alert+0x32>
    case GATT_SVR_CHR_ALERT_NOT_CTRL_PT:
        if (ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR) {
            rc = gatt_svr_chr_write(ctxt->op, ctxt, 2, 2,
                                    &gatt_svr_alert_not_ctrl_pt, NULL);
        } else {
            rc = BLE_ATT_ERR_UNLIKELY;
    8a7e:	200e      	movs	r0, #14

    default:
        assert(0);
        return BLE_ATT_ERR_UNLIKELY;
    }
}
    8a80:	b002      	add	sp, #8
    8a82:	bd10      	pop	{r4, pc}
    8a84:	0001eef1 	.word	0x0001eef1
    8a88:	0001f046 	.word	0x0001f046
    8a8c:	20001df6 	.word	0x20001df6
    8a90:	20001e56 	.word	0x20001e56
    8a94:	0001eef0 	.word	0x0001eef0
    8a98:	20001dcc 	.word	0x20001dcc
    8a9c:	20001df4 	.word	0x20001df4

00008aa0 <io_poll_task_handler>:
    return BLE_ATT_ERR_UNLIKELY;
}

void
io_poll_task_handler(void *unused)
{
    8aa0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    int rc; 
    /* Wait for an initial subscriber to start polling I/O */
    os_eventq_get(&io_poll_evq);
    8aa4:	481b      	ldr	r0, [pc, #108]	; (8b14 <io_poll_task_handler+0x74>)
    return BLE_ATT_ERR_UNLIKELY;
}

void
io_poll_task_handler(void *unused)
{
    8aa6:	b085      	sub	sp, #20
    int rc; 
    /* Wait for an initial subscriber to start polling I/O */
    os_eventq_get(&io_poll_evq);
    8aa8:	f001 f8cd 	bl	9c46 <os_eventq_get>
    while (1) {
        /* Get the connection handle */
        uint16_t conn_handle = get_conn_handle();
    8aac:	f7ff fcec 	bl	8488 <get_conn_handle>
    8ab0:	4680      	mov	r8, r0
        /* Wait 1/3 sec */
        os_time_delay(OS_TICKS_PER_SEC/3);
    8ab2:	202a      	movs	r0, #42	; 0x2a
    8ab4:	f001 fec2 	bl	a83c <os_time_delay>
        int i;
        /* Loop through gpio input pins */
        for (i = 0; i < (sizeof(pin_inits)/sizeof(uint8_t)); i++) {
    8ab8:	2400      	movs	r4, #0
            if (pin_inits[i] == GPIO_INPUT) {
    8aba:	4b17      	ldr	r3, [pc, #92]	; (8b18 <io_poll_task_handler+0x78>)
    8abc:	5ce7      	ldrb	r7, [r4, r3]
    8abe:	2f02      	cmp	r7, #2
    8ac0:	d123      	bne.n	8b0a <io_poll_task_handler+0x6a>
                uint16_t val = hal_gpio_read(i) ? 1 : 0;
    8ac2:	4620      	mov	r0, r4
    8ac4:	f000 fa77 	bl	8fb6 <hal_gpio_read>
                /* Check for discrepencies in read value and stored value */
                if (pin_vals[i] != val) {
    8ac8:	4e14      	ldr	r6, [pc, #80]	; (8b1c <io_poll_task_handler+0x7c>)
        os_time_delay(OS_TICKS_PER_SEC/3);
        int i;
        /* Loop through gpio input pins */
        for (i = 0; i < (sizeof(pin_inits)/sizeof(uint8_t)); i++) {
            if (pin_inits[i] == GPIO_INPUT) {
                uint16_t val = hal_gpio_read(i) ? 1 : 0;
    8aca:	f110 0900 	adds.w	r9, r0, #0
    8ace:	bf18      	it	ne
    8ad0:	f04f 0901 	movne.w	r9, #1
                /* Check for discrepencies in read value and stored value */
                if (pin_vals[i] != val) {
    8ad4:	5d33      	ldrb	r3, [r6, r4]
        os_time_delay(OS_TICKS_PER_SEC/3);
        int i;
        /* Loop through gpio input pins */
        for (i = 0; i < (sizeof(pin_inits)/sizeof(uint8_t)); i++) {
            if (pin_inits[i] == GPIO_INPUT) {
                uint16_t val = hal_gpio_read(i) ? 1 : 0;
    8ad6:	fa1f f589 	uxth.w	r5, r9
                /* Check for discrepencies in read value and stored value */
                if (pin_vals[i] != val) {
    8ada:	42ab      	cmp	r3, r5
    8adc:	d015      	beq.n	8b0a <io_poll_task_handler+0x6a>
                    BLEPRPH_LOG(DEBUG, "Found discrepency on pin: %d\n", i);
    8ade:	4810      	ldr	r0, [pc, #64]	; (8b20 <io_poll_task_handler+0x80>)
    8ae0:	4b10      	ldr	r3, [pc, #64]	; (8b24 <io_poll_task_handler+0x84>)
    8ae2:	9400      	str	r4, [sp, #0]
    8ae4:	2140      	movs	r1, #64	; 0x40
    8ae6:	2200      	movs	r2, #0
    8ae8:	f014 fb9e 	bl	1d228 <log_printf>
    8aec:	eb05 2504 	add.w	r5, r5, r4, lsl #8
                    /* Construct info to send to client. Same structure as
                     * instruction defined in gatt_svr_chr_access_gpio */
                    uint16_t pinfo = (i << 8) + 0x20 + val;
                    const void *pinfo_ptr = &pinfo;
                    /* Notify */
                    rc = ble_gattc_notify_custom(conn_handle, 
    8af0:	4b0d      	ldr	r3, [pc, #52]	; (8b28 <io_poll_task_handler+0x88>)
                /* Check for discrepencies in read value and stored value */
                if (pin_vals[i] != val) {
                    BLEPRPH_LOG(DEBUG, "Found discrepency on pin: %d\n", i);
                    /* Construct info to send to client. Same structure as
                     * instruction defined in gatt_svr_chr_access_gpio */
                    uint16_t pinfo = (i << 8) + 0x20 + val;
    8af2:	aa04      	add	r2, sp, #16
    8af4:	3520      	adds	r5, #32
                    const void *pinfo_ptr = &pinfo;
                    /* Notify */
                    rc = ble_gattc_notify_custom(conn_handle, 
    8af6:	8819      	ldrh	r1, [r3, #0]
                /* Check for discrepencies in read value and stored value */
                if (pin_vals[i] != val) {
                    BLEPRPH_LOG(DEBUG, "Found discrepency on pin: %d\n", i);
                    /* Construct info to send to client. Same structure as
                     * instruction defined in gatt_svr_chr_access_gpio */
                    uint16_t pinfo = (i << 8) + 0x20 + val;
    8af8:	f822 5d02 	strh.w	r5, [r2, #-2]!
                    const void *pinfo_ptr = &pinfo;
                    /* Notify */
                    rc = ble_gattc_notify_custom(conn_handle, 
    8afc:	4640      	mov	r0, r8
    8afe:	463b      	mov	r3, r7
    8b00:	f00a fb66 	bl	131d0 <ble_gattc_notify_custom>
                                            gatt_svr_chr_gpio_notif_val_handle,
                                            pinfo_ptr, sizeof(pinfo));
                    /* If the notification was successful, update 
                     * stored pin val */
                    if (rc == 0) {
    8b04:	b908      	cbnz	r0, 8b0a <io_poll_task_handler+0x6a>
                        pin_vals[i] = val;
    8b06:	f804 9006 	strb.w	r9, [r4, r6]
        uint16_t conn_handle = get_conn_handle();
        /* Wait 1/3 sec */
        os_time_delay(OS_TICKS_PER_SEC/3);
        int i;
        /* Loop through gpio input pins */
        for (i = 0; i < (sizeof(pin_inits)/sizeof(uint8_t)); i++) {
    8b0a:	3401      	adds	r4, #1
    8b0c:	2c20      	cmp	r4, #32
    8b0e:	d1d4      	bne.n	8aba <io_poll_task_handler+0x1a>
    8b10:	e7cc      	b.n	8aac <io_poll_task_handler+0xc>
    8b12:	bf00      	nop
    8b14:	200027d8 	.word	0x200027d8
    8b18:	20001e36 	.word	0x20001e36
    8b1c:	20001dce 	.word	0x20001dce
    8b20:	20002ce0 	.word	0x20002ce0
    8b24:	0001f018 	.word	0x0001f018
    8b28:	20001df0 	.word	0x20001df0

00008b2c <gatt_svr_register>:
int
gatt_svr_register(void)
{
    int rc;

    rc = ble_gatts_register_svcs(gatt_svr_svcs, gatt_svr_register_cb, NULL);
    8b2c:	4802      	ldr	r0, [pc, #8]	; (8b38 <gatt_svr_register+0xc>)
    8b2e:	4903      	ldr	r1, [pc, #12]	; (8b3c <gatt_svr_register+0x10>)
    8b30:	2200      	movs	r2, #0
    8b32:	f00b b839 	b.w	13ba8 <ble_gatts_register_svcs>
    8b36:	bf00      	nop
    8b38:	0001eeb0 	.word	0x0001eeb0
    8b3c:	000087a9 	.word	0x000087a9

00008b40 <gatt_svr_init>:
    return rc;
}

int
gatt_svr_init(struct ble_hs_cfg *cfg)
{
    8b40:	4601      	mov	r1, r0
    int rc;

    rc = ble_gatts_count_cfg(gatt_svr_svcs, cfg);
    8b42:	4801      	ldr	r0, [pc, #4]	; (8b48 <gatt_svr_init+0x8>)
    8b44:	f00b bc7b 	b.w	1443e <ble_gatts_count_cfg>
    8b48:	0001eeb0 	.word	0x0001eeb0

00008b4c <Reset_Handler>:
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
    8b4c:	4906      	ldr	r1, [pc, #24]	; (8b68 <Reset_Handler+0x1c>)
    ldr    r2, =__data_start__
    8b4e:	4a07      	ldr	r2, [pc, #28]	; (8b6c <Reset_Handler+0x20>)
    ldr    r3, =__data_end__
    8b50:	4b07      	ldr	r3, [pc, #28]	; (8b70 <Reset_Handler+0x24>)

    subs    r3, r2
    8b52:	1a9b      	subs	r3, r3, r2
    ble     .LC0
    8b54:	dd03      	ble.n	8b5e <Reset_Handler+0x12>

.LC1:
    subs    r3, 4
    8b56:	3b04      	subs	r3, #4
    ldr    r0, [r1,r3]
    8b58:	58c8      	ldr	r0, [r1, r3]
    str    r0, [r2,r3]
    8b5a:	50d0      	str	r0, [r2, r3]
    bgt    .LC1
    8b5c:	dcfb      	bgt.n	8b56 <Reset_Handler+0xa>
.LC0:

    LDR     R0, =SystemInit
    8b5e:	4805      	ldr	r0, [pc, #20]	; (8b74 <Reset_Handler+0x28>)
    BLX     R0
    8b60:	4780      	blx	r0
    LDR     R0, =_start
    8b62:	4805      	ldr	r0, [pc, #20]	; (8b78 <Reset_Handler+0x2c>)
    BX      R0
    8b64:	4700      	bx	r0
    8b66:	0000      	.short	0x0000
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
    8b68:	00022e94 	.word	0x00022e94
    ldr    r2, =__data_start__
    8b6c:	200000d8 	.word	0x200000d8
    ldr    r3, =__data_end__
    8b70:	20000854 	.word	0x20000854
    ldr    r0, [r1,r3]
    str    r0, [r2,r3]
    bgt    .LC1
.LC0:

    LDR     R0, =SystemInit
    8b74:	00008b91 	.word	0x00008b91
    BLX     R0
    LDR     R0, =_start
    8b78:	000080f9 	.word	0x000080f9

00008b7c <NMI_Handler>:
/* Dummy Exception Handlers (infinite loops which can be modified) */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    B       .
    8b7c:	e7fe      	b.n	8b7c <NMI_Handler>

00008b7e <HardFault_Handler>:


    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    B       .
    8b7e:	e7fe      	b.n	8b7e <HardFault_Handler>

00008b80 <MemoryManagement_Handler>:


    .weak   MemoryManagement_Handler
    .type   MemoryManagement_Handler, %function
MemoryManagement_Handler:
    B       .
    8b80:	e7fe      	b.n	8b80 <MemoryManagement_Handler>

00008b82 <BusFault_Handler>:


    .weak   BusFault_Handler
    .type   BusFault_Handler, %function
BusFault_Handler:
    B       .
    8b82:	e7fe      	b.n	8b82 <BusFault_Handler>

00008b84 <UsageFault_Handler>:


    .weak   UsageFault_Handler
    .type   UsageFault_Handler, %function
UsageFault_Handler:
    B       .
    8b84:	e7fe      	b.n	8b84 <UsageFault_Handler>


    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    B       .
    8b86:	e7fe      	b.n	8b86 <UsageFault_Handler+0x2>


    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    B       .
    8b88:	e7fe      	b.n	8b88 <UsageFault_Handler+0x4>


    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    B       .
    8b8a:	e7fe      	b.n	8b8a <UsageFault_Handler+0x6>

00008b8c <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    B       .
    8b8c:	e7fe      	b.n	8b8c <Default_Handler>
    8b8e:	bf00      	nop

00008b90 <SystemInit>:
    NVIC_Relocate();
}

static bool ftpan_32(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
    8b90:	4b27      	ldr	r3, [pc, #156]	; (8c30 <SystemInit+0xa0>)
    8b92:	781b      	ldrb	r3, [r3, #0]
    8b94:	2b06      	cmp	r3, #6
    8b96:	d10e      	bne.n	8bb6 <SystemInit+0x26>
    8b98:	4b26      	ldr	r3, [pc, #152]	; (8c34 <SystemInit+0xa4>)
    8b9a:	681b      	ldr	r3, [r3, #0]
    8b9c:	0719      	lsls	r1, r3, #28
    8b9e:	d10a      	bne.n	8bb6 <SystemInit+0x26>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
    8ba0:	4b25      	ldr	r3, [pc, #148]	; (8c38 <SystemInit+0xa8>)
    8ba2:	681b      	ldr	r3, [r3, #0]
    8ba4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8ba8:	2b30      	cmp	r3, #48	; 0x30
    8baa:	d104      	bne.n	8bb6 <SystemInit+0x26>
    8bac:	4b23      	ldr	r3, [pc, #140]	; (8c3c <SystemInit+0xac>)
    8bae:	681b      	ldr	r3, [r3, #0]
    8bb0:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    8bb4:	d02a      	beq.n	8c0c <SystemInit+0x7c>
    return false;
}

static bool ftpan_37(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
    8bb6:	4b1e      	ldr	r3, [pc, #120]	; (8c30 <SystemInit+0xa0>)
    8bb8:	781b      	ldrb	r3, [r3, #0]
    8bba:	2b06      	cmp	r3, #6
    8bbc:	d10e      	bne.n	8bdc <SystemInit+0x4c>
    8bbe:	4b1d      	ldr	r3, [pc, #116]	; (8c34 <SystemInit+0xa4>)
    8bc0:	681b      	ldr	r3, [r3, #0]
    8bc2:	071a      	lsls	r2, r3, #28
    8bc4:	d10a      	bne.n	8bdc <SystemInit+0x4c>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
    8bc6:	4b1c      	ldr	r3, [pc, #112]	; (8c38 <SystemInit+0xa8>)
    8bc8:	681b      	ldr	r3, [r3, #0]
    8bca:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8bce:	2b30      	cmp	r3, #48	; 0x30
    8bd0:	d104      	bne.n	8bdc <SystemInit+0x4c>
    8bd2:	4b1a      	ldr	r3, [pc, #104]	; (8c3c <SystemInit+0xac>)
    8bd4:	681b      	ldr	r3, [r3, #0]
    8bd6:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    8bda:	d01d      	beq.n	8c18 <SystemInit+0x88>
    return false;
}

static bool ftpan_36(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
    8bdc:	4b14      	ldr	r3, [pc, #80]	; (8c30 <SystemInit+0xa0>)
    8bde:	781b      	ldrb	r3, [r3, #0]
    8be0:	2b06      	cmp	r3, #6
    8be2:	d10e      	bne.n	8c02 <SystemInit+0x72>
    8be4:	4b13      	ldr	r3, [pc, #76]	; (8c34 <SystemInit+0xa4>)
    8be6:	681b      	ldr	r3, [r3, #0]
    8be8:	071b      	lsls	r3, r3, #28
    8bea:	d10a      	bne.n	8c02 <SystemInit+0x72>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
    8bec:	4b12      	ldr	r3, [pc, #72]	; (8c38 <SystemInit+0xa8>)
    8bee:	681b      	ldr	r3, [r3, #0]
    8bf0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8bf4:	2b30      	cmp	r3, #48	; 0x30
    8bf6:	d104      	bne.n	8c02 <SystemInit+0x72>
    8bf8:	4b10      	ldr	r3, [pc, #64]	; (8c3c <SystemInit+0xac>)
    8bfa:	681b      	ldr	r3, [r3, #0]
    8bfc:	f013 03f0 	ands.w	r3, r3, #240	; 0xf0
    8c00:	d00e      	beq.n	8c20 <SystemInit+0x90>
    uint32_t SystemCoreClock __attribute__((used)) = __SYSTEM_CLOCK_64M;
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    8c02:	4b0f      	ldr	r3, [pc, #60]	; (8c40 <SystemInit+0xb0>)
    8c04:	4a0f      	ldr	r2, [pc, #60]	; (8c44 <SystemInit+0xb4>)
    8c06:	601a      	str	r2, [r3, #0]
        NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Parallel << CLOCK_TRACECONFIG_TRACEMUX_Pos;
    #endif

    SystemCoreClockUpdate();

    NVIC_Relocate();
    8c08:	f000 bc74 	b.w	94f4 <NVIC_Relocate>
void SystemInit(void)
{
    /* Workaround for FTPAN-32 "DIF: Debug session automatically enables TracePort pins" found at Product Anomaly document 
       for your device located at https://www.nordicsemi.com/ */
    if (ftpan_32()){        
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
    8c0c:	4a0e      	ldr	r2, [pc, #56]	; (8c48 <SystemInit+0xb8>)
    8c0e:	68d3      	ldr	r3, [r2, #12]
    8c10:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    8c14:	60d3      	str	r3, [r2, #12]
    8c16:	e7ce      	b.n	8bb6 <SystemInit+0x26>
    }
    
    /* Workaround for FTPAN-37 "AMLI: EasyDMA is slow with Radio, ECB, AAR and CCM." found at Product Anomaly document 
       for your device located at https://www.nordicsemi.com/  */
    if (ftpan_37()){        
        *(volatile uint32_t *)0x400005A0 = 0x3;
    8c18:	4b0c      	ldr	r3, [pc, #48]	; (8c4c <SystemInit+0xbc>)
    8c1a:	2203      	movs	r2, #3
    8c1c:	601a      	str	r2, [r3, #0]
    8c1e:	e7dd      	b.n	8bdc <SystemInit+0x4c>
    }
    
    /* Workaround for FTPAN-36 "CLOCK: Some registers are not reset when expected." found at Product Anomaly document 
       for your device located at https://www.nordicsemi.com/  */
    if (ftpan_36()){        
        NRF_CLOCK->EVENTS_DONE = 0;
    8c20:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    8c24:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
    8c28:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
    8c2c:	e7e9      	b.n	8c02 <SystemInit+0x72>
    8c2e:	bf00      	nop
    8c30:	f0000fe0 	.word	0xf0000fe0
    8c34:	f0000fe4 	.word	0xf0000fe4
    8c38:	f0000fe8 	.word	0xf0000fe8
    8c3c:	f0000fec 	.word	0xf0000fec
    8c40:	20000218 	.word	0x20000218
    8c44:	03d09000 	.word	0x03d09000
    8c48:	e000edf0 	.word	0xe000edf0
    8c4c:	400005a0 	.word	0x400005a0

00008c50 <cputime_chk_expiration>:
 * callback function is executed.
 *
 */
void
cputime_chk_expiration(void)
{
    8c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_sr_t sr;
    struct cpu_timer *timer;

    OS_ENTER_CRITICAL(sr);
    8c52:	f000 fe65 	bl	9920 <os_arch_save_sr>
    8c56:	4606      	mov	r6, r0
    while ((timer = TAILQ_FIRST(&g_cputimer_q)) != NULL) {
    8c58:	4d11      	ldr	r5, [pc, #68]	; (8ca0 <cputime_chk_expiration+0x50>)
    8c5a:	682c      	ldr	r4, [r5, #0]
    8c5c:	462f      	mov	r7, r5
    8c5e:	b12c      	cbz	r4, 8c6c <cputime_chk_expiration+0x1c>
        if ((int32_t)(cputime_get32() - timer->cputime) >= 0) {
    8c60:	f000 f96c 	bl	8f3c <cputime_get32>
    8c64:	68a3      	ldr	r3, [r4, #8]
    8c66:	1ac0      	subs	r0, r0, r3
    8c68:	2800      	cmp	r0, #0
    8c6a:	da04      	bge.n	8c76 <cputime_chk_expiration+0x26>
            break;
        }
    }

    /* Any timers left on queue? If so, we need to set OCMP */
    timer = TAILQ_FIRST(&g_cputimer_q);
    8c6c:	6838      	ldr	r0, [r7, #0]
    if (timer) {
    8c6e:	b180      	cbz	r0, 8c92 <cputime_chk_expiration+0x42>
        cputime_set_ocmp(timer);
    8c70:	f000 f8fc 	bl	8e6c <cputime_set_ocmp>
    8c74:	e00f      	b.n	8c96 <cputime_chk_expiration+0x46>
    struct cpu_timer *timer;

    OS_ENTER_CRITICAL(sr);
    while ((timer = TAILQ_FIRST(&g_cputimer_q)) != NULL) {
        if ((int32_t)(cputime_get32() - timer->cputime) >= 0) {
            TAILQ_REMOVE(&g_cputimer_q, timer, link);
    8c76:	68e3      	ldr	r3, [r4, #12]
    8c78:	6922      	ldr	r2, [r4, #16]
    8c7a:	b10b      	cbz	r3, 8c80 <cputime_chk_expiration+0x30>
    8c7c:	611a      	str	r2, [r3, #16]
    8c7e:	e000      	b.n	8c82 <cputime_chk_expiration+0x32>
    8c80:	606a      	str	r2, [r5, #4]
    8c82:	6922      	ldr	r2, [r4, #16]
    8c84:	6013      	str	r3, [r2, #0]
            timer->link.tqe_prev = NULL;
    8c86:	2300      	movs	r3, #0
    8c88:	6123      	str	r3, [r4, #16]
            timer->cb(timer->arg);
    8c8a:	6860      	ldr	r0, [r4, #4]
    8c8c:	6823      	ldr	r3, [r4, #0]
    8c8e:	4798      	blx	r3
    8c90:	e7e2      	b.n	8c58 <cputime_chk_expiration+0x8>
    /* Any timers left on queue? If so, we need to set OCMP */
    timer = TAILQ_FIRST(&g_cputimer_q);
    if (timer) {
        cputime_set_ocmp(timer);
    } else {
        cputime_disable_ocmp();
    8c92:	f000 f8e3 	bl	8e5c <cputime_disable_ocmp>
    }
    OS_EXIT_CRITICAL(sr);
    8c96:	4630      	mov	r0, r6
}
    8c98:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (timer) {
        cputime_set_ocmp(timer);
    } else {
        cputime_disable_ocmp();
    }
    OS_EXIT_CRITICAL(sr);
    8c9c:	f000 be46 	b.w	992c <os_arch_restore_sr>
    8ca0:	20002d00 	.word	0x20002d00

00008ca4 <cputime_init>:
int
cputime_init(uint32_t clock_freq)
{
    int rc;

    TAILQ_INIT(&g_cputimer_q);
    8ca4:	4b02      	ldr	r3, [pc, #8]	; (8cb0 <cputime_init+0xc>)
    8ca6:	2200      	movs	r2, #0
    8ca8:	e883 000c 	stmia.w	r3, {r2, r3}
    rc = cputime_hw_init(clock_freq);
    8cac:	f000 b8fc 	b.w	8ea8 <cputime_hw_init>
    8cb0:	20002d00 	.word	0x20002d00

00008cb4 <cputime_usecs_to_ticks>:
uint32_t
cputime_usecs_to_ticks(uint32_t usecs)
{
    uint32_t ticks;

    ticks = (usecs * g_cputime.ticks_per_usec);
    8cb4:	4b01      	ldr	r3, [pc, #4]	; (8cbc <cputime_usecs_to_ticks+0x8>)
    8cb6:	681b      	ldr	r3, [r3, #0]
    return ticks;
}
    8cb8:	4358      	muls	r0, r3
    8cba:	4770      	bx	lr
    8cbc:	20002cec 	.word	0x20002cec

00008cc0 <cputime_ticks_to_usecs>:
uint32_t
cputime_ticks_to_usecs(uint32_t ticks)
{
    uint32_t us;

    us =  (ticks + (g_cputime.ticks_per_usec - 1)) / g_cputime.ticks_per_usec;
    8cc0:	4b03      	ldr	r3, [pc, #12]	; (8cd0 <cputime_ticks_to_usecs+0x10>)
    8cc2:	681a      	ldr	r2, [r3, #0]
    8cc4:	1e53      	subs	r3, r2, #1
    8cc6:	4418      	add	r0, r3
    return us;
}
    8cc8:	fbb0 f0f2 	udiv	r0, r0, r2
    8ccc:	4770      	bx	lr
    8cce:	bf00      	nop
    8cd0:	20002cec 	.word	0x20002cec

00008cd4 <cputime_timer_init>:
 * @param fp    The timer callback function. Cannot be NULL.
 * @param arg   Pointer to data object to pass to timer.
 */
void
cputime_timer_init(struct cpu_timer *timer, cputimer_func fp, void *arg)
{
    8cd4:	b510      	push	{r4, lr}
    assert(timer != NULL);
    8cd6:	4603      	mov	r3, r0
 * @param fp    The timer callback function. Cannot be NULL.
 * @param arg   Pointer to data object to pass to timer.
 */
void
cputime_timer_init(struct cpu_timer *timer, cputimer_func fp, void *arg)
{
    8cd8:	460c      	mov	r4, r1
    assert(timer != NULL);
    8cda:	b918      	cbnz	r0, 8ce4 <cputime_timer_init+0x10>
    8cdc:	4807      	ldr	r0, [pc, #28]	; (8cfc <cputime_timer_init+0x28>)
    8cde:	21ee      	movs	r1, #238	; 0xee
    8ce0:	461a      	mov	r2, r3
    8ce2:	e004      	b.n	8cee <cputime_timer_init+0x1a>
    assert(fp != NULL);
    8ce4:	b929      	cbnz	r1, 8cf2 <cputime_timer_init+0x1e>
    8ce6:	4805      	ldr	r0, [pc, #20]	; (8cfc <cputime_timer_init+0x28>)
    8ce8:	21ef      	movs	r1, #239	; 0xef
    8cea:	4622      	mov	r2, r4
    8cec:	4623      	mov	r3, r4
    8cee:	f000 ffef 	bl	9cd0 <__assert_func>

    timer->cb = fp;
    8cf2:	6019      	str	r1, [r3, #0]
    timer->arg = arg;
    8cf4:	6042      	str	r2, [r0, #4]
    timer->link.tqe_prev = (void *) NULL;
    8cf6:	2200      	movs	r2, #0
    8cf8:	6102      	str	r2, [r0, #16]
    8cfa:	bd10      	pop	{r4, pc}
    8cfc:	0001f047 	.word	0x0001f047

00008d00 <cputime_timer_start>:
 * @param timer     Pointer to timer to start. Cannot be NULL.
 * @param cputime   The cputime at which the timer should expire.
 */
void
cputime_timer_start(struct cpu_timer *timer, uint32_t cputime)
{
    8d00:	b570      	push	{r4, r5, r6, lr}
    8d02:	460d      	mov	r5, r1
    struct cpu_timer *entry;
    os_sr_t sr;

    assert(timer != NULL);
    8d04:	4604      	mov	r4, r0
    8d06:	b920      	cbnz	r0, 8d12 <cputime_timer_start+0x12>
    8d08:	481e      	ldr	r0, [pc, #120]	; (8d84 <cputime_timer_start+0x84>)
    8d0a:	f44f 7183 	mov.w	r1, #262	; 0x106
    8d0e:	4622      	mov	r2, r4
    8d10:	e005      	b.n	8d1e <cputime_timer_start+0x1e>
    assert(timer->link.tqe_prev == NULL);
    8d12:	6903      	ldr	r3, [r0, #16]
    8d14:	b133      	cbz	r3, 8d24 <cputime_timer_start+0x24>
    8d16:	481b      	ldr	r0, [pc, #108]	; (8d84 <cputime_timer_start+0x84>)
    8d18:	f240 1107 	movw	r1, #263	; 0x107
    8d1c:	2200      	movs	r2, #0
    8d1e:	4613      	mov	r3, r2
    8d20:	f000 ffd6 	bl	9cd0 <__assert_func>

    /* XXX: should this use a mutex? not sure... */
    OS_ENTER_CRITICAL(sr);
    8d24:	f000 fdfc 	bl	9920 <os_arch_save_sr>

    timer->cputime = cputime;
    if (TAILQ_EMPTY(&g_cputimer_q)) {
    8d28:	4a17      	ldr	r2, [pc, #92]	; (8d88 <cputime_timer_start+0x88>)
    assert(timer->link.tqe_prev == NULL);

    /* XXX: should this use a mutex? not sure... */
    OS_ENTER_CRITICAL(sr);

    timer->cputime = cputime;
    8d2a:	60a5      	str	r5, [r4, #8]
    if (TAILQ_EMPTY(&g_cputimer_q)) {
    8d2c:	6813      	ldr	r3, [r2, #0]

    assert(timer != NULL);
    assert(timer->link.tqe_prev == NULL);

    /* XXX: should this use a mutex? not sure... */
    OS_ENTER_CRITICAL(sr);
    8d2e:	4606      	mov	r6, r0

    timer->cputime = cputime;
    if (TAILQ_EMPTY(&g_cputimer_q)) {
    8d30:	b933      	cbnz	r3, 8d40 <cputime_timer_start+0x40>
        TAILQ_INSERT_HEAD(&g_cputimer_q, timer, link);
    8d32:	4621      	mov	r1, r4
    8d34:	6014      	str	r4, [r2, #0]
    8d36:	f841 3f0c 	str.w	r3, [r1, #12]!
    8d3a:	6122      	str	r2, [r4, #16]
    8d3c:	6051      	str	r1, [r2, #4]
    8d3e:	e016      	b.n	8d6e <cputime_timer_start+0x6e>
    } else {
        TAILQ_FOREACH(entry, &g_cputimer_q, link) {
            if ((int32_t)(timer->cputime - entry->cputime) < 0) {
    8d40:	6898      	ldr	r0, [r3, #8]
    8d42:	1a28      	subs	r0, r5, r0
    8d44:	2800      	cmp	r0, #0
    8d46:	da08      	bge.n	8d5a <cputime_timer_start+0x5a>
                TAILQ_INSERT_BEFORE(entry, timer, link);
    8d48:	6919      	ldr	r1, [r3, #16]
    8d4a:	6121      	str	r1, [r4, #16]
    8d4c:	6919      	ldr	r1, [r3, #16]
    8d4e:	60e3      	str	r3, [r4, #12]
    8d50:	600c      	str	r4, [r1, #0]
    8d52:	f104 010c 	add.w	r1, r4, #12
    8d56:	6119      	str	r1, [r3, #16]
    8d58:	e009      	b.n	8d6e <cputime_timer_start+0x6e>

    timer->cputime = cputime;
    if (TAILQ_EMPTY(&g_cputimer_q)) {
        TAILQ_INSERT_HEAD(&g_cputimer_q, timer, link);
    } else {
        TAILQ_FOREACH(entry, &g_cputimer_q, link) {
    8d5a:	68db      	ldr	r3, [r3, #12]
    8d5c:	2b00      	cmp	r3, #0
    8d5e:	d1ef      	bne.n	8d40 <cputime_timer_start+0x40>
                TAILQ_INSERT_BEFORE(entry, timer, link);
                break;
            }
        }
        if (!entry) {
            TAILQ_INSERT_TAIL(&g_cputimer_q, timer, link);
    8d60:	60e3      	str	r3, [r4, #12]
    8d62:	6853      	ldr	r3, [r2, #4]
    8d64:	6123      	str	r3, [r4, #16]
    8d66:	601c      	str	r4, [r3, #0]
    8d68:	f104 030c 	add.w	r3, r4, #12
    8d6c:	6053      	str	r3, [r2, #4]
        }
    }

    /* If this is the head, we need to set new OCMP */
    if (timer == TAILQ_FIRST(&g_cputimer_q)) {
    8d6e:	6813      	ldr	r3, [r2, #0]
    8d70:	429c      	cmp	r4, r3
    8d72:	d102      	bne.n	8d7a <cputime_timer_start+0x7a>
        cputime_set_ocmp(timer);
    8d74:	4620      	mov	r0, r4
    8d76:	f000 f879 	bl	8e6c <cputime_set_ocmp>
    }

    OS_EXIT_CRITICAL(sr);
    8d7a:	4630      	mov	r0, r6
}
    8d7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* If this is the head, we need to set new OCMP */
    if (timer == TAILQ_FIRST(&g_cputimer_q)) {
        cputime_set_ocmp(timer);
    }

    OS_EXIT_CRITICAL(sr);
    8d80:	f000 bdd4 	b.w	992c <os_arch_restore_sr>
    8d84:	0001f047 	.word	0x0001f047
    8d88:	20002d00 	.word	0x20002d00

00008d8c <cputime_timer_relative>:
 * @param timer Pointer to timer. Cannot be NULL.
 * @param usecs The number of usecs from now at which the timer will expire.
 */
void
cputime_timer_relative(struct cpu_timer *timer, uint32_t usecs)
{
    8d8c:	b538      	push	{r3, r4, r5, lr}
    8d8e:	460c      	mov	r4, r1
    uint32_t cputime;

    assert(timer != NULL);
    8d90:	4605      	mov	r5, r0
    8d92:	b930      	cbnz	r0, 8da2 <cputime_timer_relative+0x16>
    8d94:	4808      	ldr	r0, [pc, #32]	; (8db8 <cputime_timer_relative+0x2c>)
    8d96:	f240 1131 	movw	r1, #305	; 0x131
    8d9a:	462a      	mov	r2, r5
    8d9c:	462b      	mov	r3, r5
    8d9e:	f000 ff97 	bl	9cd0 <__assert_func>

    cputime = cputime_get32() + cputime_usecs_to_ticks(usecs);
    8da2:	f000 f8cb 	bl	8f3c <cputime_get32>
uint32_t
cputime_usecs_to_ticks(uint32_t usecs)
{
    uint32_t ticks;

    ticks = (usecs * g_cputime.ticks_per_usec);
    8da6:	4b05      	ldr	r3, [pc, #20]	; (8dbc <cputime_timer_relative+0x30>)
    8da8:	6819      	ldr	r1, [r3, #0]
{
    uint32_t cputime;

    assert(timer != NULL);

    cputime = cputime_get32() + cputime_usecs_to_ticks(usecs);
    8daa:	fb01 0104 	mla	r1, r1, r4, r0
    cputime_timer_start(timer, cputime);
    8dae:	4628      	mov	r0, r5
}
    8db0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    uint32_t cputime;

    assert(timer != NULL);

    cputime = cputime_get32() + cputime_usecs_to_ticks(usecs);
    cputime_timer_start(timer, cputime);
    8db4:	f7ff bfa4 	b.w	8d00 <cputime_timer_start>
    8db8:	0001f047 	.word	0x0001f047
    8dbc:	20002cec 	.word	0x20002cec

00008dc0 <cputime_timer_stop>:
 *
 * @param timer Pointer to cputimer to stop. Cannot be NULL.
 */
void
cputime_timer_stop(struct cpu_timer *timer)
{
    8dc0:	b570      	push	{r4, r5, r6, lr}
    os_sr_t sr;
    int reset_ocmp;
    struct cpu_timer *entry;

    assert(timer != NULL);
    8dc2:	4604      	mov	r4, r0
    8dc4:	b930      	cbnz	r0, 8dd4 <cputime_timer_stop+0x14>
    8dc6:	4814      	ldr	r0, [pc, #80]	; (8e18 <cputime_timer_stop+0x58>)
    8dc8:	f240 1147 	movw	r1, #327	; 0x147
    8dcc:	4622      	mov	r2, r4
    8dce:	4623      	mov	r3, r4
    8dd0:	f000 ff7e 	bl	9cd0 <__assert_func>

    OS_ENTER_CRITICAL(sr);
    8dd4:	f000 fda4 	bl	9920 <os_arch_save_sr>

    if (timer->link.tqe_prev != NULL) {
    8dd8:	6922      	ldr	r2, [r4, #16]
    int reset_ocmp;
    struct cpu_timer *entry;

    assert(timer != NULL);

    OS_ENTER_CRITICAL(sr);
    8dda:	4605      	mov	r5, r0

    if (timer->link.tqe_prev != NULL) {
    8ddc:	b1ba      	cbz	r2, 8e0e <cputime_timer_stop+0x4e>
        reset_ocmp = 0;
        if (timer == TAILQ_FIRST(&g_cputimer_q)) {
    8dde:	490f      	ldr	r1, [pc, #60]	; (8e1c <cputime_timer_stop+0x5c>)
    8de0:	68e3      	ldr	r3, [r4, #12]
    8de2:	6808      	ldr	r0, [r1, #0]
            /* If first on queue, we will need to reset OCMP */
            entry = TAILQ_NEXT(timer, link);
    8de4:	4284      	cmp	r4, r0
    8de6:	bf0d      	iteet	eq
    8de8:	4618      	moveq	r0, r3
    8dea:	2000      	movne	r0, #0
    8dec:	2600      	movne	r6, #0
    8dee:	2601      	moveq	r6, #1
            reset_ocmp = 1;
        }
        TAILQ_REMOVE(&g_cputimer_q, timer, link);
    8df0:	b10b      	cbz	r3, 8df6 <cputime_timer_stop+0x36>
    8df2:	611a      	str	r2, [r3, #16]
    8df4:	e000      	b.n	8df8 <cputime_timer_stop+0x38>
    8df6:	604a      	str	r2, [r1, #4]
    8df8:	6922      	ldr	r2, [r4, #16]
    8dfa:	6013      	str	r3, [r2, #0]
        timer->link.tqe_prev = NULL;
    8dfc:	2300      	movs	r3, #0
    8dfe:	6123      	str	r3, [r4, #16]
        if (reset_ocmp) {
    8e00:	b12e      	cbz	r6, 8e0e <cputime_timer_stop+0x4e>
            if (entry) {
    8e02:	b110      	cbz	r0, 8e0a <cputime_timer_stop+0x4a>
                cputime_set_ocmp(entry);
    8e04:	f000 f832 	bl	8e6c <cputime_set_ocmp>
    8e08:	e001      	b.n	8e0e <cputime_timer_stop+0x4e>
            } else {
                cputime_disable_ocmp();
    8e0a:	f000 f827 	bl	8e5c <cputime_disable_ocmp>
            }
        }
    }

    OS_EXIT_CRITICAL(sr);
    8e0e:	4628      	mov	r0, r5
}
    8e10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                cputime_disable_ocmp();
            }
        }
    }

    OS_EXIT_CRITICAL(sr);
    8e14:	f000 bd8a 	b.w	992c <os_arch_restore_sr>
    8e18:	0001f047 	.word	0x0001f047
    8e1c:	20002d00 	.word	0x20002d00

00008e20 <cputime_isr>:
 * This is the global timer interrupt routine.
 *
 */
static void
cputime_isr(void)
{
    8e20:	b508      	push	{r3, lr}
#ifdef HAL_CPUTIME_USE_OVERFLOW
    uint32_t overflow;
#endif

    /* Check interrupt source. If set, clear them */
    compare = CPUTIMER->EVENTS_COMPARE[CPUTIMER_CC_INT];
    8e22:	4b0c      	ldr	r3, [pc, #48]	; (8e54 <cputime_isr+0x34>)
    8e24:	f8d3 214c 	ldr.w	r2, [r3, #332]	; 0x14c
    if (compare) {
    8e28:	b112      	cbz	r2, 8e30 <cputime_isr+0x10>
        CPUTIMER->EVENTS_COMPARE[CPUTIMER_CC_INT] = 0;
    8e2a:	2200      	movs	r2, #0
    8e2c:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
        ++g_cputime.cputime_high;
    }
#endif

    /* Count # of interrupts */
    ++g_cputime.timer_isrs;
    8e30:	4a09      	ldr	r2, [pc, #36]	; (8e58 <cputime_isr+0x38>)
    8e32:	6891      	ldr	r1, [r2, #8]
    8e34:	3101      	adds	r1, #1
    8e36:	6091      	str	r1, [r2, #8]
     * counter is already passed the output compare value), we use the NVIC
     * to set a pending interrupt. This means that there will be no compare
     * flag set, so all we do is check to see if the compare interrupt is
     * enabled.
     */
    if (CPUTIMER->INTENCLR & CPUTIMER_INT_MASK(CPUTIMER_CC_INT)) {
    8e38:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    8e3c:	031b      	lsls	r3, r3, #12
    8e3e:	d507      	bpl.n	8e50 <cputime_isr+0x30>
        ++g_cputime.ocmp_ints;
    8e40:	68d3      	ldr	r3, [r2, #12]
    8e42:	3301      	adds	r3, #1
    8e44:	60d3      	str	r3, [r2, #12]
        cputime_chk_expiration();
    8e46:	f7ff ff03 	bl	8c50 <cputime_chk_expiration>

        /* XXX: Recommended by nordic to make sure interrupts are cleared */
        compare = CPUTIMER->EVENTS_COMPARE[CPUTIMER_CC_INT];
    8e4a:	4b02      	ldr	r3, [pc, #8]	; (8e54 <cputime_isr+0x34>)
    8e4c:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
    8e50:	bd08      	pop	{r3, pc}
    8e52:	bf00      	nop
    8e54:	40008000 	.word	0x40008000
    8e58:	20002cec 	.word	0x20002cec

00008e5c <cputime_disable_ocmp>:

/* Disable output compare used for cputimer */
void
cputime_disable_ocmp(void)
{
    CPUTIMER->INTENCLR = CPUTIMER_INT_MASK(CPUTIMER_CC_INT);
    8e5c:	4b02      	ldr	r3, [pc, #8]	; (8e68 <cputime_disable_ocmp+0xc>)
    8e5e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    8e62:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    8e66:	4770      	bx	lr
    8e68:	40008000 	.word	0x40008000

00008e6c <cputime_set_ocmp>:
 */
void
cputime_set_ocmp(struct cpu_timer *timer)
{
    /* Disable ocmp interrupt and set new value */
    CPUTIMER->INTENCLR = CPUTIMER_INT_MASK(CPUTIMER_CC_INT);
    8e6c:	4b0c      	ldr	r3, [pc, #48]	; (8ea0 <cputime_set_ocmp+0x34>)
    8e6e:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    8e72:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308

    /* Set output compare register to timer expiration */
    CPUTIMER->CC[CPUTIMER_CC_INT] = timer->cputime;
    8e76:	6882      	ldr	r2, [r0, #8]
    8e78:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c

    /* Clear interrupt flag*/
    CPUTIMER->EVENTS_COMPARE[CPUTIMER_CC_INT] = 0;
    8e7c:	2000      	movs	r0, #0
    8e7e:	f8c3 014c 	str.w	r0, [r3, #332]	; 0x14c

    /* Enable the output compare interrupt */
    CPUTIMER->INTENSET = CPUTIMER_INT_MASK(CPUTIMER_CC_INT);
    8e82:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
cputime_get32(void)
{
    uint32_t cpu_time;

    /* Force a capture of the timer into 'cntr' capture channel; read it */
    CPUTIMER->TASKS_CAPTURE[CPUTIMER_CC_CNTR] = 1;
    8e86:	2101      	movs	r1, #1
    8e88:	6499      	str	r1, [r3, #72]	; 0x48
    cpu_time = CPUTIMER->CC[CPUTIMER_CC_CNTR];
    8e8a:	f8d3 3548 	ldr.w	r3, [r3, #1352]	; 0x548

    /* Enable the output compare interrupt */
    CPUTIMER->INTENSET = CPUTIMER_INT_MASK(CPUTIMER_CC_INT);

    /* Force interrupt to occur as we may have missed it */
    if ((int32_t)(cputime_get32() - timer->cputime) >= 0) {
    8e8e:	1a9b      	subs	r3, r3, r2
    8e90:	4283      	cmp	r3, r0

    \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
    8e92:	bfa2      	ittt	ge
    8e94:	4b03      	ldrge	r3, [pc, #12]	; (8ea4 <cputime_set_ocmp+0x38>)
    8e96:	f44f 7280 	movge.w	r2, #256	; 0x100
    8e9a:	f8c3 2100 	strge.w	r2, [r3, #256]	; 0x100
    8e9e:	4770      	bx	lr
    8ea0:	40008000 	.word	0x40008000
    8ea4:	e000e100 	.word	0xe000e100

00008ea8 <cputime_hw_init>:
 *
 * @return int 0 on success; -1 on error.
 */
int
cputime_hw_init(uint32_t clock_freq)
{
    8ea8:	b538      	push	{r3, r4, r5, lr}
        return -1;
    }
#endif

    /* Clock frequency must be at least 1 MHz */
    if (clock_freq < 1000000U) {
    8eaa:	4a1c      	ldr	r2, [pc, #112]	; (8f1c <cputime_hw_init+0x74>)
    8eac:	f5a0 2374 	sub.w	r3, r0, #999424	; 0xf4000
    8eb0:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
    8eb4:	4293      	cmp	r3, r2
    8eb6:	d82c      	bhi.n	8f12 <cputime_hw_init+0x6a>
    if (clock_freq > max_freq) {
        return -1;
    }

    /* Is this exact frequency obtainable? */
    pre_scaler = max_freq / clock_freq;
    8eb8:	4a19      	ldr	r2, [pc, #100]	; (8f20 <cputime_hw_init+0x78>)
    8eba:	fbb2 f3f0 	udiv	r3, r2, r0
    if ((pre_scaler * clock_freq) != max_freq) {
    8ebe:	fb00 f103 	mul.w	r1, r0, r3
    8ec2:	4291      	cmp	r1, r2
    8ec4:	d125      	bne.n	8f12 <cputime_hw_init+0x6a>
    8ec6:	3b01      	subs	r3, #1
    8ec8:	4a16      	ldr	r2, [pc, #88]	; (8f24 <cputime_hw_init+0x7c>)
    8eca:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    default:
        pre_scaler = 0xFFFFFFFF;
        break;
    }

    if (pre_scaler == 0xFFFFFFFF) {
    8ece:	1c53      	adds	r3, r2, #1
    8ed0:	d01f      	beq.n	8f12 <cputime_hw_init+0x6a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    8ed2:	f3ef 8510 	mrs	r5, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    8ed6:	b672      	cpsid	i

    /* disable interrupts */
    __HAL_DISABLE_INTERRUPTS(ctx);

    /* Set the clock frequency */
    g_cputime.ticks_per_usec = clock_freq / 1000000U;
    8ed8:	4913      	ldr	r1, [pc, #76]	; (8f28 <cputime_hw_init+0x80>)
    8eda:	4b14      	ldr	r3, [pc, #80]	; (8f2c <cputime_hw_init+0x84>)
    8edc:	fbb0 f3f3 	udiv	r3, r0, r3
    8ee0:	600b      	str	r3, [r1, #0]

    /* XXX: no way to halt the timer in debug mode that I can see */

    /* Stop the timer first */
    CPUTIMER->TASKS_STOP = 1;
    8ee2:	4b13      	ldr	r3, [pc, #76]	; (8f30 <cputime_hw_init+0x88>)
    8ee4:	2101      	movs	r1, #1

    /* Put the timer in timer mode using 32 bits. */
    CPUTIMER->MODE = TIMER_MODE_MODE_Timer;
    CPUTIMER->BITMODE = TIMER_BITMODE_BITMODE_32Bit;
    8ee6:	2003      	movs	r0, #3

    /* Stop the timer first */
    CPUTIMER->TASKS_STOP = 1;

    /* Put the timer in timer mode using 32 bits. */
    CPUTIMER->MODE = TIMER_MODE_MODE_Timer;
    8ee8:	2400      	movs	r4, #0
    g_cputime.ticks_per_usec = clock_freq / 1000000U;

    /* XXX: no way to halt the timer in debug mode that I can see */

    /* Stop the timer first */
    CPUTIMER->TASKS_STOP = 1;
    8eea:	6059      	str	r1, [r3, #4]

    /* Put the timer in timer mode using 32 bits. */
    CPUTIMER->MODE = TIMER_MODE_MODE_Timer;
    8eec:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
    CPUTIMER->BITMODE = TIMER_BITMODE_BITMODE_32Bit;
    8ef0:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508

    /* Set the pre-scaler*/
    CPUTIMER->PRESCALER = pre_scaler;
    8ef4:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    CPUTIMER->EVENTS_COMPARE[CPUTIMER_CC_OVERFLOW] = 0;
    CPUTIMER->INTENSET = CPUTIMER_INT_MASK(CPUTIMER_CC_OVERFLOW);
#endif

    /* Set isr in vector table and enable interrupt */
    NVIC_SetVector(CPUTIMER_IRQ, (uint32_t)cputime_isr);
    8ef8:	2008      	movs	r0, #8

    /* Set the pre-scaler*/
    CPUTIMER->PRESCALER = pre_scaler;

    /* Start the timer */
    CPUTIMER->TASKS_START = 1;
    8efa:	6019      	str	r1, [r3, #0]
    CPUTIMER->EVENTS_COMPARE[CPUTIMER_CC_OVERFLOW] = 0;
    CPUTIMER->INTENSET = CPUTIMER_INT_MASK(CPUTIMER_CC_OVERFLOW);
#endif

    /* Set isr in vector table and enable interrupt */
    NVIC_SetVector(CPUTIMER_IRQ, (uint32_t)cputime_isr);
    8efc:	490d      	ldr	r1, [pc, #52]	; (8f34 <cputime_hw_init+0x8c>)
    8efe:	f000 fb0f 	bl	9520 <NVIC_SetVector>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
    8f02:	4b0d      	ldr	r3, [pc, #52]	; (8f38 <cputime_hw_init+0x90>)
    8f04:	f44f 7280 	mov.w	r2, #256	; 0x100
    8f08:	601a      	str	r2, [r3, #0]
    NVIC_EnableIRQ(CPUTIMER_IRQ);

    __HAL_ENABLE_INTERRUPTS(ctx);
    8f0a:	b92d      	cbnz	r5, 8f18 <cputime_hw_init+0x70>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    8f0c:	b662      	cpsie	i

    return 0;
    8f0e:	4628      	mov	r0, r5
    8f10:	bd38      	pop	{r3, r4, r5, pc}
    }
#endif

    /* Clock frequency must be at least 1 MHz */
    if (clock_freq < 1000000U) {
        return -1;
    8f12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8f16:	bd38      	pop	{r3, r4, r5, pc}
    NVIC_SetVector(CPUTIMER_IRQ, (uint32_t)cputime_isr);
    NVIC_EnableIRQ(CPUTIMER_IRQ);

    __HAL_ENABLE_INTERRUPTS(ctx);

    return 0;
    8f18:	4620      	mov	r0, r4
}
    8f1a:	bd38      	pop	{r3, r4, r5, pc}
    8f1c:	00e4e1c0 	.word	0x00e4e1c0
    8f20:	00f42400 	.word	0x00f42400
    8f24:	0001f058 	.word	0x0001f058
    8f28:	20002cec 	.word	0x20002cec
    8f2c:	000f4240 	.word	0x000f4240
    8f30:	40008000 	.word	0x40008000
    8f34:	00008e21 	.word	0x00008e21
    8f38:	e000e100 	.word	0xe000e100

00008f3c <cputime_get32>:
cputime_get32(void)
{
    uint32_t cpu_time;

    /* Force a capture of the timer into 'cntr' capture channel; read it */
    CPUTIMER->TASKS_CAPTURE[CPUTIMER_CC_CNTR] = 1;
    8f3c:	4b02      	ldr	r3, [pc, #8]	; (8f48 <cputime_get32+0xc>)
    8f3e:	2201      	movs	r2, #1
    8f40:	649a      	str	r2, [r3, #72]	; 0x48
    cpu_time = CPUTIMER->CC[CPUTIMER_CC_CNTR];
    8f42:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548

    return cpu_time;
}
    8f46:	4770      	bx	lr
    8f48:	40008000 	.word	0x40008000

00008f4c <hal_gpio_init_in>:
int
hal_gpio_init_in(int pin, gpio_pull_t pull)
{
    uint32_t conf;

    switch (pull) {
    8f4c:	2901      	cmp	r1, #1
    8f4e:	d004      	beq.n	8f5a <hal_gpio_init_in+0xe>
    8f50:	2902      	cmp	r1, #2
    case GPIO_PULL_DOWN:
        conf = GPIO_PIN_CNF_PULL_Pulldown << GPIO_PIN_CNF_PULL_Pos;
        break;
    case GPIO_PULL_NONE:
    default:
        conf = 0;
    8f52:	bf0c      	ite	eq
    8f54:	2304      	moveq	r3, #4
    8f56:	2300      	movne	r3, #0
    8f58:	e000      	b.n	8f5c <hal_gpio_init_in+0x10>
{
    uint32_t conf;

    switch (pull) {
    case GPIO_PULL_UP:
        conf = GPIO_PIN_CNF_PULL_Pullup << GPIO_PIN_CNF_PULL_Pos;
    8f5a:	230c      	movs	r3, #12
    default:
        conf = 0;
        break;
    }

    NRF_P0->PIN_CNF[pin] = conf;
    8f5c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    8f60:	f500 71e0 	add.w	r1, r0, #448	; 0x1c0
    8f64:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    NRF_P0->DIRCLR = HAL_GPIO_MASK(pin);
    8f68:	2301      	movs	r3, #1
    8f6a:	4083      	lsls	r3, r0
    8f6c:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c

    return 0;
}
    8f70:	2000      	movs	r0, #0
    8f72:	4770      	bx	lr

00008f74 <hal_gpio_init_out>:
 * @param val Value to set pin
 *
 * @return int  0: no error; -1 otherwise.
 */
int hal_gpio_init_out(int pin, int val)
{
    8f74:	2301      	movs	r3, #1
    8f76:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    if (val) {
        NRF_P0->OUTSET = HAL_GPIO_MASK(pin);
    8f7a:	4083      	lsls	r3, r0
 *
 * @return int  0: no error; -1 otherwise.
 */
int hal_gpio_init_out(int pin, int val)
{
    if (val) {
    8f7c:	b111      	cbz	r1, 8f84 <hal_gpio_init_out+0x10>
        NRF_P0->OUTSET = HAL_GPIO_MASK(pin);
    8f7e:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    8f82:	e001      	b.n	8f88 <hal_gpio_init_out+0x14>
    } else {
        NRF_P0->OUTCLR = HAL_GPIO_MASK(pin);
    8f84:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
    }
    NRF_P0->PIN_CNF[pin] = GPIO_PIN_CNF_DIR_Output;
    8f88:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    8f8c:	f500 71e0 	add.w	r1, r0, #448	; 0x1c0
    8f90:	2301      	movs	r3, #1
    8f92:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    NRF_P0->DIRSET = HAL_GPIO_MASK(pin);
    8f96:	4083      	lsls	r3, r0
    8f98:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    return 0;
}
    8f9c:	2000      	movs	r0, #0
    8f9e:	4770      	bx	lr

00008fa0 <hal_gpio_write>:
 *
 * @param pin Pin to set
 * @param val Value to set pin (0:low 1:high)
 */
void hal_gpio_write(int pin, int val)
{
    8fa0:	2301      	movs	r3, #1
    8fa2:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 *
 * @param pin
 */
void hal_gpio_set(int pin)
{
    NRF_P0->OUTSET = HAL_GPIO_MASK(pin);
    8fa6:	4083      	lsls	r3, r0
 * @param pin Pin to set
 * @param val Value to set pin (0:low 1:high)
 */
void hal_gpio_write(int pin, int val)
{
    if (val) {
    8fa8:	b111      	cbz	r1, 8fb0 <hal_gpio_write+0x10>
 *
 * @param pin
 */
void hal_gpio_set(int pin)
{
    NRF_P0->OUTSET = HAL_GPIO_MASK(pin);
    8faa:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    8fae:	4770      	bx	lr
 *
 * @param pin
 */
void hal_gpio_clear(int pin)
{
    NRF_P0->OUTCLR = HAL_GPIO_MASK(pin);
    8fb0:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
    8fb4:	4770      	bx	lr

00008fb6 <hal_gpio_read>:
 *
 * @return int 0: low, 1: high
 */
int hal_gpio_read(int pin)
{
    return (NRF_P0->IN & HAL_GPIO_MASK(pin));
    8fb6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    8fba:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    8fbe:	2301      	movs	r3, #1
    8fc0:	fa03 f000 	lsl.w	r0, r3, r0
}
    8fc4:	4010      	ands	r0, r2
    8fc6:	4770      	bx	lr

00008fc8 <exit>:
}

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
__extern_inline void exit(int err)
{
    8fc8:	b508      	push	{r3, lr}
	__extern void _exit(int s);

	_exit(err);
    8fca:	f014 f9d5 	bl	1d378 <_exit>
	...

00008fd0 <lrand48>:
#include <stdint.h>

extern unsigned short __rand48_seed[3];	/* Common with mrand48.c, srand48.c */

long lrand48(void)
{
    8fd0:	b508      	push	{r3, lr}
	return (uint32_t) jrand48(__rand48_seed) >> 1;
    8fd2:	4802      	ldr	r0, [pc, #8]	; (8fdc <lrand48+0xc>)
    8fd4:	f000 fa4a 	bl	946c <jrand48>
}
    8fd8:	0840      	lsrs	r0, r0, #1
    8fda:	bd08      	pop	{r3, pc}
    8fdc:	20002d08 	.word	0x20002d08

00008fe0 <memcmp>:
 */

#include <string.h>

int memcmp(const void *s1, const void *s2, size_t n)
{
    8fe0:	b510      	push	{r4, lr}
    8fe2:	4402      	add	r2, r0
	const unsigned char *c1 = s1, *c2 = s2;
	int d = 0;

	while (n--) {
    8fe4:	4290      	cmp	r0, r2
    8fe6:	d006      	beq.n	8ff6 <memcmp+0x16>
		d = (int)*c1++ - (int)*c2++;
    8fe8:	f810 3b01 	ldrb.w	r3, [r0], #1
    8fec:	f811 4b01 	ldrb.w	r4, [r1], #1
		if (d)
    8ff0:	1b1b      	subs	r3, r3, r4
    8ff2:	d0f7      	beq.n	8fe4 <memcmp+0x4>
    8ff4:	e000      	b.n	8ff8 <memcmp+0x18>
    8ff6:	2300      	movs	r3, #0
			break;
	}

	return d;
}
    8ff8:	4618      	mov	r0, r3
    8ffa:	bd10      	pop	{r4, pc}

00008ffc <memcpy>:

#include <string.h>
#include <stdint.h>

void *memcpy(void *dst, const void *src, size_t n)
{
    8ffc:	b510      	push	{r4, lr}
    8ffe:	1e43      	subs	r3, r0, #1
    9000:	440a      	add	r2, r1
	size_t nq = n >> 3;
	asm volatile ("cld ; rep ; movsq ; movl %3,%%ecx ; rep ; movsb":"+c"
		      (nq), "+S"(p), "+D"(q)
		      :"r"((uint32_t) (n & 7)));
#else
	while (n--) {
    9002:	4291      	cmp	r1, r2
    9004:	d004      	beq.n	9010 <memcpy+0x14>
		*q++ = *p++;
    9006:	f811 4b01 	ldrb.w	r4, [r1], #1
    900a:	f803 4f01 	strb.w	r4, [r3, #1]!
    900e:	e7f8      	b.n	9002 <memcpy+0x6>
	}
#endif

	return dst;
}
    9010:	bd10      	pop	{r4, pc}

00009012 <memset>:

#include <string.h>
#include <stdint.h>

void *memset(void *dst, int c, size_t n)
{
    9012:	4402      	add	r2, r0
	char *q = dst;
    9014:	4603      	mov	r3, r0
	asm volatile ("cld ; rep ; stosq ; movl %3,%%ecx ; rep ; stosb"
		      :"+c" (nq), "+D" (q)
		      : "a" ((unsigned char)c * 0x0101010101010101U),
			"r" ((uint32_t) n & 7));
#else
	while (n--) {
    9016:	4293      	cmp	r3, r2
    9018:	d002      	beq.n	9020 <memset+0xe>
		*q++ = c;
    901a:	f803 1b01 	strb.w	r1, [r3], #1
    901e:	e7fa      	b.n	9016 <memset+0x4>
	}
#endif

	return dst;
}
    9020:	4770      	bx	lr

00009022 <sprintf>:

#include <stdio.h>
#include <unistd.h>

int sprintf(char *buffer, const char *format, ...)
{
    9022:	b40e      	push	{r1, r2, r3}
    9024:	b503      	push	{r0, r1, lr}
    9026:	ab03      	add	r3, sp, #12
	va_list ap;
	int rv;

	va_start(ap, format);
	rv = vsnprintf(buffer, ~(size_t) 0, format, ap);
    9028:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff

#include <stdio.h>
#include <unistd.h>

int sprintf(char *buffer, const char *format, ...)
{
    902c:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list ap;
	int rv;

	va_start(ap, format);
    9030:	9301      	str	r3, [sp, #4]
	rv = vsnprintf(buffer, ~(size_t) 0, format, ap);
    9032:	f000 f9fb 	bl	942c <vsnprintf>
	va_end(ap);

	return rv;
}
    9036:	b002      	add	sp, #8
    9038:	f85d eb04 	ldr.w	lr, [sp], #4
    903c:	b003      	add	sp, #12
    903e:	4770      	bx	lr

00009040 <srand48>:

unsigned short __rand48_seed[3];	/* Common with mrand48.c, lrand48.c */

void srand48(long seedval)
{
	__rand48_seed[0] = 0x330e;
    9040:	4b03      	ldr	r3, [pc, #12]	; (9050 <srand48+0x10>)
    9042:	f243 320e 	movw	r2, #13070	; 0x330e
	__rand48_seed[1] = (unsigned short)seedval;
    9046:	8058      	strh	r0, [r3, #2]
	__rand48_seed[2] = (unsigned short)((uint32_t) seedval >> 16);
    9048:	0c00      	lsrs	r0, r0, #16

unsigned short __rand48_seed[3];	/* Common with mrand48.c, lrand48.c */

void srand48(long seedval)
{
	__rand48_seed[0] = 0x330e;
    904a:	801a      	strh	r2, [r3, #0]
	__rand48_seed[1] = (unsigned short)seedval;
	__rand48_seed[2] = (unsigned short)((uint32_t) seedval >> 16);
    904c:	8098      	strh	r0, [r3, #4]
    904e:	4770      	bx	lr
    9050:	20002d08 	.word	0x20002d08

00009054 <strlen>:
 */

#include <string.h>

size_t strlen(const char *s)
{
    9054:	4603      	mov	r3, r0
    9056:	461a      	mov	r2, r3
    9058:	3301      	adds	r3, #1
	const char *ss = s;
	while (*ss)
    905a:	7811      	ldrb	r1, [r2, #0]
    905c:	2900      	cmp	r1, #0
    905e:	d1fa      	bne.n	9056 <strlen+0x2>
		ss++;
	return ss - s;
}
    9060:	1a10      	subs	r0, r2, r0
    9062:	4770      	bx	lr

00009064 <ui2a>:
    char base;  /**<  number base (e.g.: 8, 10, 16) */
    char *bf;           /**<  Buffer to output */
};

static void ui2a(unsigned long long int num, struct param *p)
{
    9064:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int n = 0;
    unsigned long long int d = 1;
    char *bf = p->bf;
    9068:	f8d2 b004 	ldr.w	fp, [r2, #4]
    while (num / d >= p->base)
    906c:	f892 8003 	ldrb.w	r8, [r2, #3]
    char base;  /**<  number base (e.g.: 8, 10, 16) */
    char *bf;           /**<  Buffer to output */
};

static void ui2a(unsigned long long int num, struct param *p)
{
    9070:	4606      	mov	r6, r0
    9072:	460f      	mov	r7, r1
    9074:	4692      	mov	sl, r2
    int n = 0;
    unsigned long long int d = 1;
    char *bf = p->bf;
    while (num / d >= p->base)
    9076:	f04f 0900 	mov.w	r9, #0
};

static void ui2a(unsigned long long int num, struct param *p)
{
    int n = 0;
    unsigned long long int d = 1;
    907a:	2401      	movs	r4, #1
    907c:	2500      	movs	r5, #0
    char *bf = p->bf;
    while (num / d >= p->base)
    907e:	4630      	mov	r0, r6
    9080:	4639      	mov	r1, r7
    9082:	4622      	mov	r2, r4
    9084:	462b      	mov	r3, r5
    9086:	f015 facd 	bl	1e624 <__aeabi_uldivmod>
    908a:	4549      	cmp	r1, r9
    908c:	bf08      	it	eq
    908e:	4540      	cmpeq	r0, r8
    9090:	d307      	bcc.n	90a2 <ui2a+0x3e>
        d *= p->base;
    9092:	fb04 f309 	mul.w	r3, r4, r9
    9096:	fb08 3305 	mla	r3, r8, r5, r3
    909a:	fba4 4508 	umull	r4, r5, r4, r8
    909e:	441d      	add	r5, r3
    90a0:	e7ed      	b.n	907e <ui2a+0x1a>
static void ui2a(unsigned long long int num, struct param *p)
{
    int n = 0;
    unsigned long long int d = 1;
    char *bf = p->bf;
    while (num / d >= p->base)
    90a2:	f04f 0c00 	mov.w	ip, #0
        d *= p->base;
    while (d != 0) {
    90a6:	ea54 0305 	orrs.w	r3, r4, r5
    90aa:	d03f      	beq.n	912c <ui2a+0xc8>
        unsigned long long  dgt = num / d;
    90ac:	4622      	mov	r2, r4
    90ae:	462b      	mov	r3, r5
    90b0:	4630      	mov	r0, r6
    90b2:	4639      	mov	r1, r7
    90b4:	f8cd c004 	str.w	ip, [sp, #4]
    90b8:	f015 fab4 	bl	1e624 <__aeabi_uldivmod>
        num %= d;
    90bc:	4622      	mov	r2, r4
    90be:	462b      	mov	r3, r5
    unsigned long long int d = 1;
    char *bf = p->bf;
    while (num / d >= p->base)
        d *= p->base;
    while (d != 0) {
        unsigned long long  dgt = num / d;
    90c0:	4680      	mov	r8, r0
    90c2:	4689      	mov	r9, r1
        num %= d;
    90c4:	4630      	mov	r0, r6
    90c6:	4639      	mov	r1, r7
    90c8:	f015 faac 	bl	1e624 <__aeabi_uldivmod>
        d /= p->base;
    90cc:	4620      	mov	r0, r4
    90ce:	4629      	mov	r1, r5
    char *bf = p->bf;
    while (num / d >= p->base)
        d *= p->base;
    while (d != 0) {
        unsigned long long  dgt = num / d;
        num %= d;
    90d0:	4616      	mov	r6, r2
    90d2:	461f      	mov	r7, r3
        d /= p->base;
    90d4:	f89a 2003 	ldrb.w	r2, [sl, #3]
    90d8:	2300      	movs	r3, #0
    90da:	f015 faa3 	bl	1e624 <__aeabi_uldivmod>
        if (n || dgt > 0 || d == 0) {
    90de:	f8dd c004 	ldr.w	ip, [sp, #4]
    while (num / d >= p->base)
        d *= p->base;
    while (d != 0) {
        unsigned long long  dgt = num / d;
        num %= d;
        d /= p->base;
    90e2:	4604      	mov	r4, r0
    90e4:	460d      	mov	r5, r1
        if (n || dgt > 0 || d == 0) {
    90e6:	f1bc 0f00 	cmp.w	ip, #0
    90ea:	d105      	bne.n	90f8 <ui2a+0x94>
    90ec:	ea58 0309 	orrs.w	r3, r8, r9
    90f0:	d102      	bne.n	90f8 <ui2a+0x94>
    90f2:	ea54 0305 	orrs.w	r3, r4, r5
    90f6:	d1d6      	bne.n	90a6 <ui2a+0x42>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    90f8:	f1b9 0f00 	cmp.w	r9, #0
    90fc:	bf08      	it	eq
    90fe:	f1b8 0f0a 	cmpeq.w	r8, #10
    9102:	f10b 0101 	add.w	r1, fp, #1
    9106:	fa5f f388 	uxtb.w	r3, r8
    910a:	d307      	bcc.n	911c <ui2a+0xb8>
    910c:	f89a 2002 	ldrb.w	r2, [sl, #2]
    9110:	f012 0f04 	tst.w	r2, #4
    9114:	bf14      	ite	ne
    9116:	2237      	movne	r2, #55	; 0x37
    9118:	2257      	moveq	r2, #87	; 0x57
    911a:	e000      	b.n	911e <ui2a+0xba>
    911c:	2230      	movs	r2, #48	; 0x30
    911e:	4413      	add	r3, r2
    9120:	f88b 3000 	strb.w	r3, [fp]
            ++n;
    9124:	f10c 0c01 	add.w	ip, ip, #1
    while (d != 0) {
        unsigned long long  dgt = num / d;
        num %= d;
        d /= p->base;
        if (n || dgt > 0 || d == 0) {
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    9128:	468b      	mov	fp, r1
    912a:	e7bc      	b.n	90a6 <ui2a+0x42>
            ++n;
        }
    }
    *bf = 0;
    912c:	2300      	movs	r3, #0
    912e:	f88b 3000 	strb.w	r3, [fp]
}
    9132:	b003      	add	sp, #12
    9134:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00009138 <putf>:
    *nump = num;
    return ch;
}

static int putf(FILE *putp, char c)
{
    9138:	b507      	push	{r0, r1, r2, lr}
    return stream->vmt->read(stream, buf, size*nmemb) / size;
}

__extern_inline size_t fwrite(const void *buf, size_t size, size_t nmemb, FILE *stream)
{
    if (stream->vmt->write == NULL) return 0;
    913a:	6803      	ldr	r3, [r0, #0]
	return fwrite(s, 1, strlen(s), stdout) + fwrite("\n", 1, 1, stdout);
}

__extern_inline int fputc(int c, FILE *f)
{
	unsigned char ch = c;
    913c:	f88d 1007 	strb.w	r1, [sp, #7]
    return stream->vmt->read(stream, buf, size*nmemb) / size;
}

__extern_inline size_t fwrite(const void *buf, size_t size, size_t nmemb, FILE *stream)
{
    if (stream->vmt->write == NULL) return 0;
    9140:	681b      	ldr	r3, [r3, #0]
    9142:	b913      	cbnz	r3, 914a <putf+0x12>
}

__extern_inline int fputc(int c, FILE *f)
{
	unsigned char ch = c;
	return fwrite(&ch, 1, 1, f) == 1 ? ch : EOF;
    9144:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9148:	e007      	b.n	915a <putf+0x22>
}

__extern_inline size_t fwrite(const void *buf, size_t size, size_t nmemb, FILE *stream)
{
    if (stream->vmt->write == NULL) return 0;
    return stream->vmt->write(stream, buf, size*nmemb) / size;
    914a:	f10d 0107 	add.w	r1, sp, #7
    914e:	2201      	movs	r2, #1
    9150:	4798      	blx	r3
}

__extern_inline int fputc(int c, FILE *f)
{
	unsigned char ch = c;
	return fwrite(&ch, 1, 1, f) == 1 ? ch : EOF;
    9152:	2801      	cmp	r0, #1
    9154:	d1f6      	bne.n	9144 <putf+0xc>
    9156:	f89d 0007 	ldrb.w	r0, [sp, #7]
    if (fputc(c, putp) == EOF)
        return 0;
    else
        return 1;
}
    915a:	3001      	adds	r0, #1
    915c:	bf18      	it	ne
    915e:	2001      	movne	r0, #1
    9160:	b003      	add	sp, #12
    9162:	f85d fb04 	ldr.w	pc, [sp], #4

00009166 <putchw>:

static unsigned putchw(FILE *putp, struct param *p)
{
    9166:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unsigned written = 0;
    char ch;
    int n = p->width;
    char *bf = p->bf;
    916a:	684b      	ldr	r3, [r1, #4]

static unsigned putchw(FILE *putp, struct param *p)
{
    unsigned written = 0;
    char ch;
    int n = p->width;
    916c:	780d      	ldrb	r5, [r1, #0]
    else
        return 1;
}

static unsigned putchw(FILE *putp, struct param *p)
{
    916e:	4607      	mov	r7, r0
    9170:	460e      	mov	r6, r1
    char ch;
    int n = p->width;
    char *bf = p->bf;

    /* Number of filling characters */
    while (*bf++ && n > 0)
    9172:	f813 2b01 	ldrb.w	r2, [r3], #1
    9176:	b112      	cbz	r2, 917e <putchw+0x18>
    9178:	b10d      	cbz	r5, 917e <putchw+0x18>
        n--;
    917a:	3d01      	subs	r5, #1
    917c:	e7f9      	b.n	9172 <putchw+0xc>
    if (p->sign)
    917e:	78b3      	ldrb	r3, [r6, #2]
    9180:	07da      	lsls	r2, r3, #31
        n--;
    if (p->alt && p->base == 16)
    9182:	8873      	ldrh	r3, [r6, #2]
    9184:	f023 03fd 	bic.w	r3, r3, #253	; 0xfd
    9188:	b29b      	uxth	r3, r3
    918a:	f241 0202 	movw	r2, #4098	; 0x1002

    /* Number of filling characters */
    while (*bf++ && n > 0)
        n--;
    if (p->sign)
        n--;
    918e:	bf48      	it	mi
    9190:	f105 35ff 	addmi.w	r5, r5, #4294967295	; 0xffffffff
    if (p->alt && p->base == 16)
    9194:	4293      	cmp	r3, r2
    9196:	d101      	bne.n	919c <putchw+0x36>
        n -= 2;
    9198:	3d02      	subs	r5, #2
    919a:	e005      	b.n	91a8 <putchw+0x42>
    else if (p->alt && p->base == 8)
    919c:	f640 0202 	movw	r2, #2050	; 0x802
    91a0:	4293      	cmp	r3, r2
        n--;
    91a2:	bf08      	it	eq
    91a4:	f105 35ff 	addeq.w	r5, r5, #4294967295	; 0xffffffff

    /* Fill with space, before alternate or sign */
    if (!p->lz) {
    91a8:	7874      	ldrb	r4, [r6, #1]
    91aa:	b98c      	cbnz	r4, 91d0 <putchw+0x6a>
    91ac:	46a8      	mov	r8, r5
        while (n-- > 0)
    91ae:	f1b8 0f00 	cmp.w	r8, #0
    91b2:	dd07      	ble.n	91c4 <putchw+0x5e>
            written += putf(putp, ' ');
    91b4:	4638      	mov	r0, r7
    91b6:	2120      	movs	r1, #32
    91b8:	f7ff ffbe 	bl	9138 <putf>
    91bc:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    91c0:	4404      	add	r4, r0
    91c2:	e7f4      	b.n	91ae <putchw+0x48>
    91c4:	1e6b      	subs	r3, r5, #1
    91c6:	2d00      	cmp	r5, #0
    91c8:	bfac      	ite	ge
    91ca:	1b5d      	subge	r5, r3, r5
    91cc:	461d      	movlt	r5, r3
    91ce:	e000      	b.n	91d2 <putchw+0x6c>
        return 1;
}

static unsigned putchw(FILE *putp, struct param *p)
{
    unsigned written = 0;
    91d0:	2400      	movs	r4, #0
        while (n-- > 0)
            written += putf(putp, ' ');
    }

    /* print sign */
    if (p->sign)
    91d2:	78b3      	ldrb	r3, [r6, #2]
    91d4:	07db      	lsls	r3, r3, #31
    91d6:	d504      	bpl.n	91e2 <putchw+0x7c>
        written += putf(putp, '-');
    91d8:	4638      	mov	r0, r7
    91da:	212d      	movs	r1, #45	; 0x2d
    91dc:	f7ff ffac 	bl	9138 <putf>
    91e0:	4404      	add	r4, r0

    /* Alternate */
    if (p->alt && p->base == 16) {
    91e2:	8873      	ldrh	r3, [r6, #2]
    91e4:	f023 03fd 	bic.w	r3, r3, #253	; 0xfd
    91e8:	b29b      	uxth	r3, r3
    91ea:	f241 0202 	movw	r2, #4098	; 0x1002
    91ee:	4293      	cmp	r3, r2
    91f0:	d10d      	bne.n	920e <putchw+0xa8>
        written += putf(putp, '0');
    91f2:	2130      	movs	r1, #48	; 0x30
    91f4:	4638      	mov	r0, r7
    91f6:	f7ff ff9f 	bl	9138 <putf>
        written += putf(putp, (p->uc ? 'X' : 'x'));
    91fa:	78b3      	ldrb	r3, [r6, #2]
    91fc:	f013 0f04 	tst.w	r3, #4
    if (p->sign)
        written += putf(putp, '-');

    /* Alternate */
    if (p->alt && p->base == 16) {
        written += putf(putp, '0');
    9200:	4404      	add	r4, r0
        written += putf(putp, (p->uc ? 'X' : 'x'));
    9202:	bf18      	it	ne
    9204:	2158      	movne	r1, #88	; 0x58
    9206:	4638      	mov	r0, r7
    9208:	bf08      	it	eq
    920a:	2178      	moveq	r1, #120	; 0x78
    920c:	e005      	b.n	921a <putchw+0xb4>
    } else if (p->alt && p->base == 8) {
    920e:	f640 0202 	movw	r2, #2050	; 0x802
    9212:	4293      	cmp	r3, r2
    9214:	d104      	bne.n	9220 <putchw+0xba>
        written += putf(putp, '0');
    9216:	4638      	mov	r0, r7
    9218:	2130      	movs	r1, #48	; 0x30
    921a:	f7ff ff8d 	bl	9138 <putf>
    921e:	4404      	add	r4, r0
    }

    /* Fill with zeros, after alternate or sign */
    if (p->lz) {
    9220:	7873      	ldrb	r3, [r6, #1]
    9222:	b143      	cbz	r3, 9236 <putchw+0xd0>
        while (n-- > 0)
    9224:	2d00      	cmp	r5, #0
    9226:	dd06      	ble.n	9236 <putchw+0xd0>
            written += putf(putp, '0');
    9228:	4638      	mov	r0, r7
    922a:	2130      	movs	r1, #48	; 0x30
    922c:	f7ff ff84 	bl	9138 <putf>
    9230:	3d01      	subs	r5, #1
    9232:	4404      	add	r4, r0
    9234:	e7f6      	b.n	9224 <putchw+0xbe>
    }

    /* Put actual buffer */
    bf = p->bf;
    9236:	6875      	ldr	r5, [r6, #4]
    while ((ch = *bf++))
    9238:	f815 1b01 	ldrb.w	r1, [r5], #1
    923c:	b121      	cbz	r1, 9248 <putchw+0xe2>
        written += putf(putp, ch);
    923e:	4638      	mov	r0, r7
    9240:	f7ff ff7a 	bl	9138 <putf>
    9244:	4404      	add	r4, r0
    9246:	e7f7      	b.n	9238 <putchw+0xd2>
    
    return written;
}
    9248:	4620      	mov	r0, r4
    924a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000924e <intarg>:

static unsigned long long
intarg(int lng, int sign, va_list *va)
{
    924e:	b510      	push	{r4, lr}
    9250:	6813      	ldr	r3, [r2, #0]
    unsigned long long val;

    switch (lng) {
    9252:	b108      	cbz	r0, 9258 <intarg+0xa>
    9254:	2801      	cmp	r0, #1
    9256:	d10a      	bne.n	926e <intarg+0x20>
            val = va_arg(*va, unsigned int);
        }
        break;

    case 1:
        if (sign) {
    9258:	b121      	cbz	r1, 9264 <intarg+0x16>
            val = va_arg(*va, long);
    925a:	1d19      	adds	r1, r3, #4
    925c:	6011      	str	r1, [r2, #0]
    925e:	6818      	ldr	r0, [r3, #0]
    9260:	17c1      	asrs	r1, r0, #31
    9262:	bd10      	pop	{r4, pc}
        } else {
            val = va_arg(*va, unsigned long);
    9264:	1d19      	adds	r1, r3, #4
    9266:	6011      	str	r1, [r2, #0]
    9268:	6818      	ldr	r0, [r3, #0]
    926a:	2100      	movs	r1, #0
    926c:	bd10      	pop	{r4, pc}
         * type was specified.
         */
        /* XXX: Look into this; may just be an incorrect setting when the
         * compiler / newlib was built.
         */
        val = va_arg(*va, unsigned long);
    926e:	4619      	mov	r1, r3
        val |= (unsigned long long)(va_arg(*va, unsigned long)) << 32;
    9270:	2000      	movs	r0, #0
         * type was specified.
         */
        /* XXX: Look into this; may just be an incorrect setting when the
         * compiler / newlib was built.
         */
        val = va_arg(*va, unsigned long);
    9272:	f851 4b08 	ldr.w	r4, [r1], #8
        val |= (unsigned long long)(va_arg(*va, unsigned long)) << 32;
    9276:	6011      	str	r1, [r2, #0]
    9278:	4320      	orrs	r0, r4
    927a:	6859      	ldr	r1, [r3, #4]
        break;
    }

    return val;
}
    927c:	bd10      	pop	{r4, pc}

0000927e <tfp_format>:

size_t tfp_format(FILE *putp, const char *fmt, va_list va)
{
    927e:	b5f0      	push	{r4, r5, r6, r7, lr}
    9280:	b08b      	sub	sp, #44	; 0x2c
    struct param p;
    char bf[23];
    char ch;
    char lng;

    p.bf = bf;
    9282:	ae04      	add	r6, sp, #16

    return val;
}

size_t tfp_format(FILE *putp, const char *fmt, va_list va)
{
    9284:	4607      	mov	r7, r0
    9286:	9201      	str	r2, [sp, #4]
    struct param p;
    char bf[23];
    char ch;
    char lng;

    p.bf = bf;
    9288:	9603      	str	r6, [sp, #12]
    return val;
}

size_t tfp_format(FILE *putp, const char *fmt, va_list va)
{
    size_t written = 0;
    928a:	2400      	movs	r4, #0
    char ch;
    char lng;

    p.bf = bf;

    while ((ch = *(fmt++))) {
    928c:	1c4d      	adds	r5, r1, #1
    928e:	7809      	ldrb	r1, [r1, #0]
    9290:	2900      	cmp	r1, #0
    9292:	f000 80b9 	beq.w	9408 <tfp_format+0x18a>
        if (ch != '%') {
    9296:	2925      	cmp	r1, #37	; 0x25
    9298:	f040 80b0 	bne.w	93fc <tfp_format+0x17e>
            written += putf(putp, ch);
        } else {
            /* Init parameter struct */
            p.lz = 0;
            p.alt = 0;
    929c:	f89d 300a 	ldrb.w	r3, [sp, #10]
    while ((ch = *(fmt++))) {
        if (ch != '%') {
            written += putf(putp, ch);
        } else {
            /* Init parameter struct */
            p.lz = 0;
    92a0:	2200      	movs	r2, #0
            p.alt = 0;
            p.width = 0;
            p.sign = 0;
    92a2:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    92a6:	f362 0300 	bfi	r3, r2, #0, #1
    92aa:	f88d 300a 	strb.w	r3, [sp, #10]
    while ((ch = *(fmt++))) {
        if (ch != '%') {
            written += putf(putp, ch);
        } else {
            /* Init parameter struct */
            p.lz = 0;
    92ae:	f88d 2009 	strb.w	r2, [sp, #9]
            p.alt = 0;
            p.width = 0;
    92b2:	f88d 2008 	strb.w	r2, [sp, #8]
    92b6:	f3c3 0340 	ubfx	r3, r3, #1, #1
            p.sign = 0;
            lng = 0;

            /* Flags */
            while ((ch = *(fmt++))) {
    92ba:	f815 1b01 	ldrb.w	r1, [r5], #1
    92be:	b139      	cbz	r1, 92d0 <tfp_format+0x52>
                switch (ch) {
    92c0:	2923      	cmp	r1, #35	; 0x23
    92c2:	d003      	beq.n	92cc <tfp_format+0x4e>
    92c4:	2930      	cmp	r1, #48	; 0x30
    92c6:	d103      	bne.n	92d0 <tfp_format+0x52>
                case '0':
                    p.lz = 1;
    92c8:	2201      	movs	r2, #1
    92ca:	e7f6      	b.n	92ba <tfp_format+0x3c>
                    continue;
                case '#':
                    p.alt = 1;
    92cc:	2301      	movs	r3, #1
    92ce:	e7f4      	b.n	92ba <tfp_format+0x3c>
    92d0:	f88d 2009 	strb.w	r2, [sp, #9]
    92d4:	f89d 200a 	ldrb.w	r2, [sp, #10]
    92d8:	f363 0241 	bfi	r2, r3, #1, #1
                }
                break;
            }

            /* Width */
            if (ch >= '0' && ch <= '9') {
    92dc:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    92e0:	2b09      	cmp	r3, #9
    92e2:	f88d 200a 	strb.w	r2, [sp, #10]
    92e6:	d81c      	bhi.n	9322 <tfp_format+0xa4>
    92e8:	2200      	movs	r2, #0
    ui2a(num, p);
}

static int a2d(char ch)
{
    if (ch >= '0' && ch <= '9')
    92ea:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    92ee:	b2d8      	uxtb	r0, r3
    92f0:	2809      	cmp	r0, #9
    92f2:	d805      	bhi.n	9300 <tfp_format+0x82>
    int num = 0;
    int digit;
    while ((digit = a2d(ch)) >= 0) {
        if (digit > base)
            break;
        num = num * base + digit;
    92f4:	210a      	movs	r1, #10
    92f6:	fb01 3202 	mla	r2, r1, r2, r3
        ch = *p++;
    92fa:	f815 1b01 	ldrb.w	r1, [r5], #1
    92fe:	e7f4      	b.n	92ea <tfp_format+0x6c>

static int a2d(char ch)
{
    if (ch >= '0' && ch <= '9')
        return ch - '0';
    else if (ch >= 'a' && ch <= 'f')
    9300:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
    9304:	2b05      	cmp	r3, #5
    9306:	d802      	bhi.n	930e <tfp_format+0x90>
        return ch - 'a' + 10;
    9308:	f1a1 0357 	sub.w	r3, r1, #87	; 0x57
    930c:	e005      	b.n	931a <tfp_format+0x9c>
    else if (ch >= 'A' && ch <= 'F')
    930e:	f1a1 0341 	sub.w	r3, r1, #65	; 0x41
    9312:	2b05      	cmp	r3, #5
    9314:	d803      	bhi.n	931e <tfp_format+0xa0>
        return ch - 'A' + 10;
    9316:	f1a1 0337 	sub.w	r3, r1, #55	; 0x37
{
    const char *p = *src;
    int num = 0;
    int digit;
    while ((digit = a2d(ch)) >= 0) {
        if (digit > base)
    931a:	2b0a      	cmp	r3, #10
    931c:	ddea      	ble.n	92f4 <tfp_format+0x76>
            break;
        num = num * base + digit;
        ch = *p++;
    }
    *src = p;
    *nump = num;
    931e:	f88d 2008 	strb.w	r2, [sp, #8]

            /* Width */
            if (ch >= '0' && ch <= '9') {
                ch = a2i(ch, &fmt, 10, &(p.width));
            }
            if (ch == 'l') {
    9322:	296c      	cmp	r1, #108	; 0x6c
    9324:	d109      	bne.n	933a <tfp_format+0xbc>
                ch = *(fmt++);
    9326:	7829      	ldrb	r1, [r5, #0]
                lng = 1;

                if (ch == 'l') {
    9328:	296c      	cmp	r1, #108	; 0x6c
                    ch = *(fmt++);
    932a:	bf0d      	iteet	eq
    932c:	7869      	ldrbeq	r1, [r5, #1]
            /* Width */
            if (ch >= '0' && ch <= '9') {
                ch = a2i(ch, &fmt, 10, &(p.width));
            }
            if (ch == 'l') {
                ch = *(fmt++);
    932e:	3501      	addne	r5, #1
                lng = 1;
    9330:	2001      	movne	r0, #1

                if (ch == 'l') {
                    ch = *(fmt++);
    9332:	3502      	addeq	r5, #2
                    lng = 2;
    9334:	bf08      	it	eq
    9336:	2002      	moveq	r0, #2
    9338:	e000      	b.n	933c <tfp_format+0xbe>
            /* Init parameter struct */
            p.lz = 0;
            p.alt = 0;
            p.width = 0;
            p.sign = 0;
            lng = 0;
    933a:	2000      	movs	r0, #0
                    ch = *(fmt++);
                    lng = 2;
                }
            }

            switch (ch) {
    933c:	2964      	cmp	r1, #100	; 0x64
    933e:	d020      	beq.n	9382 <tfp_format+0x104>
    9340:	d80f      	bhi.n	9362 <tfp_format+0xe4>
    9342:	2925      	cmp	r1, #37	; 0x25
    9344:	d05a      	beq.n	93fc <tfp_format+0x17e>
    9346:	d802      	bhi.n	934e <tfp_format+0xd0>
    9348:	2900      	cmp	r1, #0
    934a:	d05d      	beq.n	9408 <tfp_format+0x18a>
    934c:	e05a      	b.n	9404 <tfp_format+0x186>
    934e:	2958      	cmp	r1, #88	; 0x58
    9350:	d02c      	beq.n	93ac <tfp_format+0x12e>
    9352:	2963      	cmp	r1, #99	; 0x63
    9354:	d156      	bne.n	9404 <tfp_format+0x186>
                p.base = 8;
                ui2a(intarg(lng, 0, &va), &p);
                written += putchw(putp, &p);
                break;
            case 'c':
                written += putf(putp, (char)(va_arg(va, int)));
    9356:	9b01      	ldr	r3, [sp, #4]
    9358:	1d1a      	adds	r2, r3, #4
    935a:	9201      	str	r2, [sp, #4]
    935c:	4638      	mov	r0, r7
    935e:	7819      	ldrb	r1, [r3, #0]
    9360:	e04d      	b.n	93fe <tfp_format+0x180>
                    ch = *(fmt++);
                    lng = 2;
                }
            }

            switch (ch) {
    9362:	2973      	cmp	r1, #115	; 0x73
    9364:	d03e      	beq.n	93e4 <tfp_format+0x166>
    9366:	d805      	bhi.n	9374 <tfp_format+0xf6>
    9368:	2969      	cmp	r1, #105	; 0x69
    936a:	d00a      	beq.n	9382 <tfp_format+0x104>
    936c:	296f      	cmp	r1, #111	; 0x6f
    936e:	d149      	bne.n	9404 <tfp_format+0x186>
                p.uc = (ch == 'X');
                ui2a(intarg(lng, 0, &va), &p);
                written += putchw(putp, &p);
                break;
            case 'o':
                p.base = 8;
    9370:	2308      	movs	r3, #8
    9372:	e029      	b.n	93c8 <tfp_format+0x14a>
                    ch = *(fmt++);
                    lng = 2;
                }
            }

            switch (ch) {
    9374:	2975      	cmp	r1, #117	; 0x75
    9376:	d002      	beq.n	937e <tfp_format+0x100>
    9378:	2978      	cmp	r1, #120	; 0x78
    937a:	d017      	beq.n	93ac <tfp_format+0x12e>
    937c:	e042      	b.n	9404 <tfp_format+0x186>
            case 0:
                goto abort;
            case 'u':
                p.base = 10;
    937e:	230a      	movs	r3, #10
    9380:	e022      	b.n	93c8 <tfp_format+0x14a>
                ui2a(intarg(lng, 0, &va), &p);
                written += putchw(putp, &p);
                break;
            case 'd':
            case 'i':
                p.base = 10;
    9382:	230a      	movs	r3, #10
                i2a(intarg(lng, 1, &va), &p);
    9384:	2101      	movs	r1, #1
    9386:	aa01      	add	r2, sp, #4
                ui2a(intarg(lng, 0, &va), &p);
                written += putchw(putp, &p);
                break;
            case 'd':
            case 'i':
                p.base = 10;
    9388:	f88d 300b 	strb.w	r3, [sp, #11]
                i2a(intarg(lng, 1, &va), &p);
    938c:	f7ff ff5f 	bl	924e <intarg>
    *bf = 0;
}

static void i2a(long long int num, struct param *p)
{
    if (num < 0) {
    9390:	2800      	cmp	r0, #0
    9392:	f171 0300 	sbcs.w	r3, r1, #0
    9396:	da1d      	bge.n	93d4 <tfp_format+0x156>
        num = -num;
        p->sign = 1;
    9398:	f89d 300a 	ldrb.w	r3, [sp, #10]
}

static void i2a(long long int num, struct param *p)
{
    if (num < 0) {
        num = -num;
    939c:	4240      	negs	r0, r0
        p->sign = 1;
    939e:	f043 0301 	orr.w	r3, r3, #1
}

static void i2a(long long int num, struct param *p)
{
    if (num < 0) {
        num = -num;
    93a2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
        p->sign = 1;
    93a6:	f88d 300a 	strb.w	r3, [sp, #10]
    93aa:	e013      	b.n	93d4 <tfp_format+0x156>
                i2a(intarg(lng, 1, &va), &p);
                written += putchw(putp, &p);
                break;
            case 'x':
            case 'X':
                p.base = 16;
    93ac:	2310      	movs	r3, #16
    93ae:	f88d 300b 	strb.w	r3, [sp, #11]
                p.uc = (ch == 'X');
    93b2:	f1a1 0358 	sub.w	r3, r1, #88	; 0x58
    93b6:	4259      	negs	r1, r3
    93b8:	4159      	adcs	r1, r3
    93ba:	f89d 300a 	ldrb.w	r3, [sp, #10]
    93be:	f361 0382 	bfi	r3, r1, #2, #1
    93c2:	f88d 300a 	strb.w	r3, [sp, #10]
    93c6:	e001      	b.n	93cc <tfp_format+0x14e>
                ui2a(intarg(lng, 0, &va), &p);
                written += putchw(putp, &p);
                break;
            case 'o':
                p.base = 8;
    93c8:	f88d 300b 	strb.w	r3, [sp, #11]
                ui2a(intarg(lng, 0, &va), &p);
    93cc:	2100      	movs	r1, #0
    93ce:	aa01      	add	r2, sp, #4
    93d0:	f7ff ff3d 	bl	924e <intarg>
    93d4:	aa02      	add	r2, sp, #8
    93d6:	f7ff fe45 	bl	9064 <ui2a>
                written += putchw(putp, &p);
    93da:	4638      	mov	r0, r7
    93dc:	a902      	add	r1, sp, #8
    93de:	f7ff fec2 	bl	9166 <putchw>
    93e2:	e00e      	b.n	9402 <tfp_format+0x184>
                break;
            case 'c':
                written += putf(putp, (char)(va_arg(va, int)));
                break;
            case 's':
                p.bf = va_arg(va, char *);
    93e4:	9b01      	ldr	r3, [sp, #4]
    93e6:	1d1a      	adds	r2, r3, #4
    93e8:	9201      	str	r2, [sp, #4]
    93ea:	681b      	ldr	r3, [r3, #0]
    93ec:	9303      	str	r3, [sp, #12]
                written += putchw(putp, &p);
    93ee:	4638      	mov	r0, r7
    93f0:	a902      	add	r1, sp, #8
    93f2:	f7ff feb8 	bl	9166 <putchw>
                p.bf = bf;
    93f6:	9603      	str	r6, [sp, #12]
            case 'c':
                written += putf(putp, (char)(va_arg(va, int)));
                break;
            case 's':
                p.bf = va_arg(va, char *);
                written += putchw(putp, &p);
    93f8:	4404      	add	r4, r0
                p.bf = bf;
                break;
    93fa:	e003      	b.n	9404 <tfp_format+0x186>
            case '%':
                written += putf(putp, ch);
    93fc:	4638      	mov	r0, r7
    93fe:	f7ff fe9b 	bl	9138 <putf>
    9402:	4404      	add	r4, r0
                ch = *(fmt++);
                lng = 1;

                if (ch == 'l') {
                    ch = *(fmt++);
                    lng = 2;
    9404:	4629      	mov	r1, r5
    9406:	e741      	b.n	928c <tfp_format+0xe>
        }
    }
 abort:;
 
 return written;
}
    9408:	4620      	mov	r0, r4
    940a:	b00b      	add	sp, #44	; 0x2c
    940c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000940e <vfprintf>:

int vfprintf(FILE *f, const char *fmt, va_list va)
{
    return tfp_format(f, fmt, va);
    940e:	f7ff bf36 	b.w	927e <tfp_format>

00009412 <fprintf>:
}

int fprintf(FILE *f, const char *fmt, ...)
{
    9412:	b40e      	push	{r1, r2, r3}
    9414:	b503      	push	{r0, r1, lr}
    9416:	aa03      	add	r2, sp, #12
    9418:	f852 1b04 	ldr.w	r1, [r2], #4
    va_list va;
    va_start(va, fmt);
    941c:	9201      	str	r2, [sp, #4]
 return written;
}

int vfprintf(FILE *f, const char *fmt, va_list va)
{
    return tfp_format(f, fmt, va);
    941e:	f7ff ff2e 	bl	927e <tfp_format>
    va_list va;
    va_start(va, fmt);
    int rv = vfprintf(f, fmt, va);
    va_end(va);
    return rv;
}
    9422:	b002      	add	sp, #8
    9424:	f85d eb04 	ldr.w	lr, [sp], #4
    9428:	b003      	add	sp, #12
    942a:	4770      	bx	lr

0000942c <vsnprintf>:
    va_end(va);
    return rv;
}

int vsnprintf(char *str, size_t size, const char *fmt, va_list va)
{
    942c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    942e:	4606      	mov	r6, r0
    9430:	461c      	mov	r4, r3
    9432:	4615      	mov	r5, r2
    struct MemFile state;
    FILE *f = fmemopen_w(&state, str, size - 1);
    9434:	4668      	mov	r0, sp
    9436:	1e4a      	subs	r2, r1, #1
    9438:	4631      	mov	r1, r6
    943a:	f000 f851 	bl	94e0 <fmemopen_w>
    tfp_format(f, fmt, va);
    943e:	4622      	mov	r2, r4
    9440:	4629      	mov	r1, r5
    9442:	f7ff ff1c 	bl	927e <tfp_format>
    *(state.buffer) = '\0';
    9446:	9b01      	ldr	r3, [sp, #4]
    9448:	2200      	movs	r2, #0
    944a:	701a      	strb	r2, [r3, #0]
    return state.bytes_written;
}
    944c:	9802      	ldr	r0, [sp, #8]
    944e:	b004      	add	sp, #16
    9450:	bd70      	pop	{r4, r5, r6, pc}

00009452 <snprintf>:

int snprintf(char *str, size_t size, const char *fmt, ...)
{
    9452:	b40c      	push	{r2, r3}
    9454:	b507      	push	{r0, r1, r2, lr}
    9456:	ab04      	add	r3, sp, #16
    9458:	f853 2b04 	ldr.w	r2, [r3], #4
    va_list va;
    va_start(va, fmt);
    945c:	9301      	str	r3, [sp, #4]
    int rv = vsnprintf(str, size, fmt, va);
    945e:	f7ff ffe5 	bl	942c <vsnprintf>
    va_end(va);
    return rv;
}
    9462:	b003      	add	sp, #12
    9464:	f85d eb04 	ldr.w	lr, [sp], #4
    9468:	b002      	add	sp, #8
    946a:	4770      	bx	lr

0000946c <jrand48>:
{
	uint64_t x;

	/* The xsubi[] array is littleendian by spec */
	x = (uint64_t) (uint16_t) xsubi[0] +
	    ((uint64_t) (uint16_t) xsubi[1] << 16) +
    946c:	8842      	ldrh	r2, [r0, #2]
	    ((uint64_t) (uint16_t) xsubi[2] << 32);
    946e:	8883      	ldrh	r3, [r0, #4]

#include <stdlib.h>
#include <stdint.h>

long jrand48(unsigned short xsubi[3])
{
    9470:	b530      	push	{r4, r5, lr}
	uint64_t x;

	/* The xsubi[] array is littleendian by spec */
	x = (uint64_t) (uint16_t) xsubi[0] +
	    ((uint64_t) (uint16_t) xsubi[1] << 16) +
    9472:	0414      	lsls	r4, r2, #16
	    ((uint64_t) (uint16_t) xsubi[2] << 32);
    9474:	2200      	movs	r2, #0
    9476:	1912      	adds	r2, r2, r4
long jrand48(unsigned short xsubi[3])
{
	uint64_t x;

	/* The xsubi[] array is littleendian by spec */
	x = (uint64_t) (uint16_t) xsubi[0] +
    9478:	8804      	ldrh	r4, [r0, #0]
	    ((uint64_t) (uint16_t) xsubi[1] << 16) +
    947a:	f04f 0500 	mov.w	r5, #0

#include <stdlib.h>
#include <stdint.h>

long jrand48(unsigned short xsubi[3])
{
    947e:	4601      	mov	r1, r0
    9480:	416b      	adcs	r3, r5
	/* The xsubi[] array is littleendian by spec */
	x = (uint64_t) (uint16_t) xsubi[0] +
	    ((uint64_t) (uint16_t) xsubi[1] << 16) +
	    ((uint64_t) (uint16_t) xsubi[2] << 32);

	x = (0x5deece66dULL * x) + 0xb;
    9482:	2005      	movs	r0, #5
long jrand48(unsigned short xsubi[3])
{
	uint64_t x;

	/* The xsubi[] array is littleendian by spec */
	x = (uint64_t) (uint16_t) xsubi[0] +
    9484:	1912      	adds	r2, r2, r4
    9486:	f04f 0500 	mov.w	r5, #0
	    ((uint64_t) (uint16_t) xsubi[1] << 16) +
	    ((uint64_t) (uint16_t) xsubi[2] << 32);

	x = (0x5deece66dULL * x) + 0xb;
    948a:	4c09      	ldr	r4, [pc, #36]	; (94b0 <jrand48+0x44>)
long jrand48(unsigned short xsubi[3])
{
	uint64_t x;

	/* The xsubi[] array is littleendian by spec */
	x = (uint64_t) (uint16_t) xsubi[0] +
    948c:	416b      	adcs	r3, r5
	    ((uint64_t) (uint16_t) xsubi[1] << 16) +
	    ((uint64_t) (uint16_t) xsubi[2] << 32);

	x = (0x5deece66dULL * x) + 0xb;
    948e:	4350      	muls	r0, r2
    9490:	fb04 0003 	mla	r0, r4, r3, r0
    9494:	fba2 2304 	umull	r2, r3, r2, r4
    9498:	320b      	adds	r2, #11
    949a:	4403      	add	r3, r0
    949c:	f143 0300 	adc.w	r3, r3, #0

	xsubi[0] = (unsigned short)(uint16_t) x;
	xsubi[1] = (unsigned short)(uint16_t) (x >> 16);
    94a0:	0c10      	lsrs	r0, r2, #16
    94a2:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
	    ((uint64_t) (uint16_t) xsubi[1] << 16) +
	    ((uint64_t) (uint16_t) xsubi[2] << 32);

	x = (0x5deece66dULL * x) + 0xb;

	xsubi[0] = (unsigned short)(uint16_t) x;
    94a6:	800a      	strh	r2, [r1, #0]
	xsubi[1] = (unsigned short)(uint16_t) (x >> 16);
    94a8:	8048      	strh	r0, [r1, #2]
	xsubi[2] = (unsigned short)(uint16_t) (x >> 32);
    94aa:	808b      	strh	r3, [r1, #4]

	return (long)(int32_t) (x >> 16);
}
    94ac:	bd30      	pop	{r4, r5, pc}
    94ae:	bf00      	nop
    94b0:	deece66d 	.word	0xdeece66d

000094b4 <memfile_write>:
#include <stdio.h>

size_t memfile_write(FILE *instance, const char *bp, size_t n)
{
    94b4:	b530      	push	{r4, r5, lr}
    94b6:	4603      	mov	r3, r0
    struct MemFile *f = (struct MemFile*)instance;
    size_t i = 0;
    94b8:	2000      	movs	r0, #0
    
    while (n--)
    94ba:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
    94be:	d30d      	bcc.n	94dc <memfile_write+0x28>
    {
        f->bytes_written++;
    94c0:	689c      	ldr	r4, [r3, #8]
        if (f->bytes_written <= f->size)
    94c2:	68dd      	ldr	r5, [r3, #12]
    struct MemFile *f = (struct MemFile*)instance;
    size_t i = 0;
    
    while (n--)
    {
        f->bytes_written++;
    94c4:	3401      	adds	r4, #1
        if (f->bytes_written <= f->size)
    94c6:	42ac      	cmp	r4, r5
    struct MemFile *f = (struct MemFile*)instance;
    size_t i = 0;
    
    while (n--)
    {
        f->bytes_written++;
    94c8:	609c      	str	r4, [r3, #8]
        if (f->bytes_written <= f->size)
    94ca:	d8f6      	bhi.n	94ba <memfile_write+0x6>
        {
            *f->buffer++ = *bp++;
    94cc:	685c      	ldr	r4, [r3, #4]
    94ce:	1c65      	adds	r5, r4, #1
    94d0:	605d      	str	r5, [r3, #4]
    94d2:	780d      	ldrb	r5, [r1, #0]
    94d4:	7025      	strb	r5, [r4, #0]
            i++;
    94d6:	3001      	adds	r0, #1
    while (n--)
    {
        f->bytes_written++;
        if (f->bytes_written <= f->size)
        {
            *f->buffer++ = *bp++;
    94d8:	3101      	adds	r1, #1
    94da:	e7ee      	b.n	94ba <memfile_write+0x6>
            i++;
        }
    }
    
    return i;
}
    94dc:	bd30      	pop	{r4, r5, pc}
	...

000094e0 <fmemopen_w>:
    &memfile_write,
    NULL
};

FILE *fmemopen_w(struct MemFile* storage, char *buffer, size_t size)
{
    94e0:	b510      	push	{r4, lr}
    storage->file.vmt = &MemFile_methods;
    storage->buffer = buffer;
    94e2:	6041      	str	r1, [r0, #4]
    NULL
};

FILE *fmemopen_w(struct MemFile* storage, char *buffer, size_t size)
{
    storage->file.vmt = &MemFile_methods;
    94e4:	4c02      	ldr	r4, [pc, #8]	; (94f0 <fmemopen_w+0x10>)
    94e6:	6004      	str	r4, [r0, #0]
    storage->buffer = buffer;
    storage->bytes_written = 0;
    94e8:	2100      	movs	r1, #0
    94ea:	6081      	str	r1, [r0, #8]
    storage->size = size;
    94ec:	60c2      	str	r2, [r0, #12]
    return (FILE*)storage;
}
    94ee:	bd10      	pop	{r4, pc}
    94f0:	0001f098 	.word	0x0001f098

000094f4 <NVIC_Relocate>:
     * designated in the linker script.
     */
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
    94f4:	4a07      	ldr	r2, [pc, #28]	; (9514 <NVIC_Relocate+0x20>)
    94f6:	4b08      	ldr	r3, [pc, #32]	; (9518 <NVIC_Relocate+0x24>)
    94f8:	4293      	cmp	r3, r2
    94fa:	4611      	mov	r1, r2
    94fc:	d102      	bne.n	9504 <NVIC_Relocate+0x10>
    }

    /* Set VTOR except for M0 */
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
#else
    SCB->VTOR = (uint32_t)&__vector_tbl_reloc__;
    94fe:	4a07      	ldr	r2, [pc, #28]	; (951c <NVIC_Relocate+0x28>)
    9500:	6093      	str	r3, [r2, #8]
    9502:	4770      	bx	lr
    9504:	2200      	movs	r2, #0
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
            new_location[i] = current_location[i];
    9506:	5888      	ldr	r0, [r1, r2]
    9508:	5098      	str	r0, [r3, r2]
    950a:	3204      	adds	r2, #4
     */
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
    950c:	2ad8      	cmp	r2, #216	; 0xd8
    950e:	d1fa      	bne.n	9506 <NVIC_Relocate+0x12>
    9510:	e7f5      	b.n	94fe <NVIC_Relocate+0xa>
    9512:	bf00      	nop
    9514:	00008020 	.word	0x00008020
    9518:	20000000 	.word	0x20000000
    951c:	e000ed00 	.word	0xe000ed00

00009520 <NVIC_SetVector>:
{
    uint32_t *vectors;
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
    vectors = (uint32_t *)&__vector_tbl_reloc__;
#else
    vectors = (uint32_t *)SCB->VTOR;
    9520:	4b03      	ldr	r3, [pc, #12]	; (9530 <NVIC_SetVector+0x10>)
#endif
    vectors[IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    9522:	3010      	adds	r0, #16
{
    uint32_t *vectors;
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
    vectors = (uint32_t *)&__vector_tbl_reloc__;
#else
    vectors = (uint32_t *)SCB->VTOR;
    9524:	689b      	ldr	r3, [r3, #8]
#endif
    vectors[IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    9526:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    952a:	f3bf 8f5f 	dmb	sy
    952e:	4770      	bx	lr
    9530:	e000ed00 	.word	0xe000ed00

00009534 <console_add_char>:
} console_tty;

static void
console_add_char(struct console_ring *cr, char ch)
{
    cr->cr_buf[cr->cr_head] = ch;
    9534:	7803      	ldrb	r3, [r0, #0]
    9536:	6842      	ldr	r2, [r0, #4]
    9538:	54d1      	strb	r1, [r2, r3]
    cr->cr_head = CONSOLE_HEAD_INC(cr);
    953a:	7883      	ldrb	r3, [r0, #2]
    953c:	1e5a      	subs	r2, r3, #1
    953e:	7803      	ldrb	r3, [r0, #0]
    9540:	3301      	adds	r3, #1
    9542:	4013      	ands	r3, r2
    9544:	7003      	strb	r3, [r0, #0]
    9546:	4770      	bx	lr

00009548 <console_blocking_tx>:
    OS_EXIT_CRITICAL(sr);
}

static void
console_blocking_tx(char ch)
{
    9548:	4601      	mov	r1, r0
    hal_uart_blocking_tx(CONSOLE_UART, ch);
    954a:	2000      	movs	r0, #0
    954c:	f014 b8fe 	b.w	1d74c <hal_uart_blocking_tx>

00009550 <console_tx_flush>:
/*
 * Flush cnt characters from console output queue.
 */
static void
console_tx_flush(struct console_tty *ct, int cnt)
{
    9550:	b570      	push	{r4, r5, r6, lr}
    9552:	4604      	mov	r4, r0
    9554:	460e      	mov	r6, r1
    int i;
    uint8_t byte;

    for (i = 0; i < cnt; i++) {
    9556:	2500      	movs	r5, #0
    9558:	42b5      	cmp	r5, r6
    955a:	da0e      	bge.n	957a <console_tx_flush+0x2a>
        if (ct->ct_tx.cr_head == ct->ct_tx.cr_tail) {
    955c:	7863      	ldrb	r3, [r4, #1]
    955e:	7822      	ldrb	r2, [r4, #0]
    9560:	429a      	cmp	r2, r3
    9562:	d00a      	beq.n	957a <console_tx_flush+0x2a>
static uint8_t
console_pull_char(struct console_ring *cr)
{
    uint8_t ch;

    ch = cr->cr_buf[cr->cr_tail];
    9564:	6862      	ldr	r2, [r4, #4]
    9566:	5cd0      	ldrb	r0, [r2, r3]
    cr->cr_tail = CONSOLE_TAIL_INC(cr);
    9568:	78a2      	ldrb	r2, [r4, #2]
    956a:	3301      	adds	r3, #1
    956c:	3a01      	subs	r2, #1
    956e:	4013      	ands	r3, r2
    9570:	7063      	strb	r3, [r4, #1]
             * Queue is empty.
             */
            break;
        }
        byte = console_pull_char(&ct->ct_tx);
        console_blocking_tx(byte);
    9572:	f7ff ffe9 	bl	9548 <console_blocking_tx>
console_tx_flush(struct console_tty *ct, int cnt)
{
    int i;
    uint8_t byte;

    for (i = 0; i < cnt; i++) {
    9576:	3501      	adds	r5, #1
    9578:	e7ee      	b.n	9558 <console_tx_flush+0x8>
    957a:	bd70      	pop	{r4, r5, r6, pc}

0000957c <console_rx_char>:
    return space - 1;
}

static int
console_rx_char(void *arg, uint8_t data)
{
    957c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    struct console_ring *rx = &ct->ct_rx;
    int tx_space;
    int i;
    int tx_buf[3];

    if (CONSOLE_HEAD_INC(&ct->ct_rx) == ct->ct_rx.cr_tail) {
    957e:	f890 202a 	ldrb.w	r2, [r0, #42]	; 0x2a
    9582:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
    9586:	f890 6029 	ldrb.w	r6, [r0, #41]	; 0x29
    return space - 1;
}

static int
console_rx_char(void *arg, uint8_t data)
{
    958a:	4604      	mov	r4, r0
    struct console_ring *rx = &ct->ct_rx;
    int tx_space;
    int i;
    int tx_buf[3];

    if (CONSOLE_HEAD_INC(&ct->ct_rx) == ct->ct_rx.cr_tail) {
    958c:	3a01      	subs	r2, #1
    958e:	1c58      	adds	r0, r3, #1
    9590:	4010      	ands	r0, r2
    9592:	42b0      	cmp	r0, r6
    9594:	d106      	bne.n	95a4 <console_rx_char+0x28>
        /*
         * RX queue full. Reader must drain this.
         */
        if (ct->ct_rx_cb) {
    9596:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
    959a:	2b00      	cmp	r3, #0
    959c:	f000 8089 	beq.w	96b2 <console_rx_char+0x136>
            ct->ct_rx_cb();
    95a0:	4798      	blx	r3
    95a2:	e086      	b.n	96b2 <console_rx_char+0x136>
        }
        return -1;
    }

    /* echo */
    switch (data) {
    95a4:	2942      	cmp	r1, #66	; 0x42
static int
console_rx_char(void *arg, uint8_t data)
{
    struct console_tty *ct = (struct console_tty *)arg;
    struct console_ring *tx = &ct->ct_tx;
    struct console_ring *rx = &ct->ct_rx;
    95a6:	f104 0028 	add.w	r0, r4, #40	; 0x28
        }
        return -1;
    }

    /* echo */
    switch (data) {
    95aa:	d80e      	bhi.n	95ca <console_rx_char+0x4e>
    95ac:	2941      	cmp	r1, #65	; 0x41
    95ae:	d22f      	bcs.n	9610 <console_rx_char+0x94>
    95b0:	290a      	cmp	r1, #10
    95b2:	d011      	beq.n	95d8 <console_rx_char+0x5c>
    95b4:	d801      	bhi.n	95ba <console_rx_char+0x3e>
    95b6:	2908      	cmp	r1, #8
    95b8:	e028      	b.n	960c <console_rx_char+0x90>
    95ba:	290d      	cmp	r1, #13
    95bc:	d00c      	beq.n	95d8 <console_rx_char+0x5c>
    95be:	291b      	cmp	r1, #27
    95c0:	d14c      	bne.n	965c <console_rx_char+0xe0>
        if (ct->ct_rx_cb) {
            ct->ct_rx_cb();
        }
        break;
    case CONSOLE_ESC:
        ct->ct_esc_seq = 1;
    95c2:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    95c6:	2201      	movs	r2, #1
    95c8:	e018      	b.n	95fc <console_rx_char+0x80>
        }
        return -1;
    }

    /* echo */
    switch (data) {
    95ca:	2944      	cmp	r1, #68	; 0x44
    95cc:	d019      	beq.n	9602 <console_rx_char+0x86>
    95ce:	d32a      	bcc.n	9626 <console_rx_char+0xaa>
    95d0:	295b      	cmp	r1, #91	; 0x5b
    95d2:	d00d      	beq.n	95f0 <console_rx_char+0x74>
    95d4:	297f      	cmp	r1, #127	; 0x7f
    95d6:	e019      	b.n	960c <console_rx_char+0x90>
    case '\n':
        /*
         * linefeed
         */
        tx_buf[0] = '\n';
        tx_buf[1] = '\r';
    95d8:	230d      	movs	r3, #13
    case '\r':
    case '\n':
        /*
         * linefeed
         */
        tx_buf[0] = '\n';
    95da:	210a      	movs	r1, #10
        tx_buf[1] = '\r';
    95dc:	9302      	str	r3, [sp, #8]
    case '\r':
    case '\n':
        /*
         * linefeed
         */
        tx_buf[0] = '\n';
    95de:	9101      	str	r1, [sp, #4]
        tx_buf[1] = '\r';
        tx_space = 2;
        console_add_char(rx, '\n');
    95e0:	f7ff ffa8 	bl	9534 <console_add_char>
        if (ct->ct_rx_cb) {
    95e4:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
    95e8:	2b00      	cmp	r3, #0
    95ea:	d042      	beq.n	9672 <console_rx_char+0xf6>
            ct->ct_rx_cb();
    95ec:	4798      	blx	r3
    95ee:	e040      	b.n	9672 <console_rx_char+0xf6>
        break;
    case CONSOLE_ESC:
        ct->ct_esc_seq = 1;
        goto out;
    case '[':
        if (ct->ct_esc_seq == 1) {
    95f0:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    95f4:	f003 0206 	and.w	r2, r3, #6
    95f8:	2a02      	cmp	r2, #2
    95fa:	d12f      	bne.n	965c <console_rx_char+0xe0>
            ct->ct_esc_seq = 2;
    95fc:	f362 0342 	bfi	r3, r2, #1, #2
    9600:	e00e      	b.n	9620 <console_rx_char+0xa4>
        } else {
            goto queue_char;
        }
        break;
    case CONSOLE_LEFT:
        if (ct->ct_esc_seq == 2) {
    9602:	f894 50b8 	ldrb.w	r5, [r4, #184]	; 0xb8
    9606:	f005 0506 	and.w	r5, r5, #6
    960a:	2d04      	cmp	r5, #4
    960c:	d126      	bne.n	965c <console_rx_char+0xe0>
    960e:	e012      	b.n	9636 <console_rx_char+0xba>
            goto queue_char;
        }
        break;
    case CONSOLE_UP:
    case CONSOLE_DOWN:
        if (ct->ct_esc_seq == 2) {
    9610:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    9614:	f003 0206 	and.w	r2, r3, #6
    9618:	2a04      	cmp	r2, #4
    961a:	d11f      	bne.n	965c <console_rx_char+0xe0>
            /*
             * Do nothing.
             */
            ct->ct_esc_seq = 0;
    961c:	f36f 0342 	bfc	r3, #1, #2
    9620:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
    9624:	e043      	b.n	96ae <console_rx_char+0x132>
            goto out;
        }
        goto queue_char;
    case CONSOLE_RIGHT:
        if (ct->ct_esc_seq == 2) {
    9626:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    962a:	f003 0306 	and.w	r3, r3, #6
            data = ' '; /* add space */
    962e:	2b04      	cmp	r3, #4
    9630:	bf08      	it	eq
    9632:	2120      	moveq	r1, #32
    9634:	e012      	b.n	965c <console_rx_char+0xe0>
    case CONSOLE_DEL:
backspace:
        /*
         * backspace
         */
        ct->ct_esc_seq = 0;
    9636:	f894 10b8 	ldrb.w	r1, [r4, #184]	; 0xb8
}

static int
console_pull_char_head(struct console_ring *cr)
{
    if (cr->cr_head != cr->cr_tail) {
    963a:	42b3      	cmp	r3, r6
    case CONSOLE_DEL:
backspace:
        /*
         * backspace
         */
        ct->ct_esc_seq = 0;
    963c:	f36f 0142 	bfc	r1, #1, #2
    9640:	f884 10b8 	strb.w	r1, [r4, #184]	; 0xb8
}

static int
console_pull_char_head(struct console_ring *cr)
{
    if (cr->cr_head != cr->cr_tail) {
    9644:	d033      	beq.n	96ae <console_rx_char+0x132>
        cr->cr_head = (cr->cr_head - 1) & (cr->cr_size - 1);
    9646:	3b01      	subs	r3, #1
    9648:	4013      	ands	r3, r2
    964a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        if (console_pull_char_head(rx) == 0) {
            /*
             * Only wipe out char if we can pull stuff off from head.
             */
            tx_buf[0] = '\b';
            tx_buf[1] = ' ';
    964e:	2220      	movs	r2, #32
        ct->ct_esc_seq = 0;
        if (console_pull_char_head(rx) == 0) {
            /*
             * Only wipe out char if we can pull stuff off from head.
             */
            tx_buf[0] = '\b';
    9650:	2308      	movs	r3, #8
    9652:	9301      	str	r3, [sp, #4]
            tx_buf[1] = ' ';
    9654:	9202      	str	r2, [sp, #8]
            tx_buf[2] = '\b';
    9656:	9303      	str	r3, [sp, #12]
            tx_space = 3;
    9658:	2503      	movs	r5, #3
        } else {
            goto out;
        }
        break;
    965a:	e00b      	b.n	9674 <console_rx_char+0xf8>
    default:
queue_char:
        tx_buf[0] = data;
        tx_space = 1;
        ct->ct_esc_seq = 0;
    965c:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
            goto out;
        }
        break;
    default:
queue_char:
        tx_buf[0] = data;
    9660:	9101      	str	r1, [sp, #4]
        tx_space = 1;
        ct->ct_esc_seq = 0;
    9662:	f36f 0342 	bfc	r3, #1, #2
    9666:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
        console_add_char(rx, data);
    966a:	f7ff ff63 	bl	9534 <console_add_char>
        }
        break;
    default:
queue_char:
        tx_buf[0] = data;
        tx_space = 1;
    966e:	2501      	movs	r5, #1
        ct->ct_esc_seq = 0;
        console_add_char(rx, data);
        break;
    9670:	e000      	b.n	9674 <console_rx_char+0xf8>
        /*
         * linefeed
         */
        tx_buf[0] = '\n';
        tx_buf[1] = '\r';
        tx_space = 2;
    9672:	2502      	movs	r5, #2
        tx_space = 1;
        ct->ct_esc_seq = 0;
        console_add_char(rx, data);
        break;
    }
    if (!ct->ct_echo_off) {
    9674:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    9678:	07db      	lsls	r3, r3, #31
    967a:	d418      	bmi.n	96ae <console_rx_char+0x132>
static int
console_buf_space(struct console_ring *cr)
{
    int space;

    space = (cr->cr_tail - cr->cr_head) & (cr->cr_size - 1);
    967c:	78a3      	ldrb	r3, [r4, #2]
    967e:	7862      	ldrb	r2, [r4, #1]
    9680:	1e59      	subs	r1, r3, #1
    9682:	7823      	ldrb	r3, [r4, #0]
    9684:	1ad3      	subs	r3, r2, r3
    9686:	400b      	ands	r3, r1
        ct->ct_esc_seq = 0;
        console_add_char(rx, data);
        break;
    }
    if (!ct->ct_echo_off) {
        if (console_buf_space(tx) < tx_space) {
    9688:	42ab      	cmp	r3, r5
    968a:	dc03      	bgt.n	9694 <console_rx_char+0x118>
            console_tx_flush(ct, tx_space);
    968c:	4620      	mov	r0, r4
    968e:	4629      	mov	r1, r5
    9690:	f7ff ff5e 	bl	9550 <console_tx_flush>
        /*
         * linefeed
         */
        tx_buf[0] = '\n';
        tx_buf[1] = '\r';
        tx_space = 2;
    9694:	2600      	movs	r6, #0
    if (!ct->ct_echo_off) {
        if (console_buf_space(tx) < tx_space) {
            console_tx_flush(ct, tx_space);
        }
        for (i = 0; i < tx_space; i++) {
            console_add_char(tx, tx_buf[i]);
    9696:	ab01      	add	r3, sp, #4
    9698:	4620      	mov	r0, r4
    969a:	f813 1026 	ldrb.w	r1, [r3, r6, lsl #2]
    }
    if (!ct->ct_echo_off) {
        if (console_buf_space(tx) < tx_space) {
            console_tx_flush(ct, tx_space);
        }
        for (i = 0; i < tx_space; i++) {
    969e:	3601      	adds	r6, #1
            console_add_char(tx, tx_buf[i]);
    96a0:	f7ff ff48 	bl	9534 <console_add_char>
    }
    if (!ct->ct_echo_off) {
        if (console_buf_space(tx) < tx_space) {
            console_tx_flush(ct, tx_space);
        }
        for (i = 0; i < tx_space; i++) {
    96a4:	42ae      	cmp	r6, r5
    96a6:	d1f6      	bne.n	9696 <console_rx_char+0x11a>
            console_add_char(tx, tx_buf[i]);
        }
        hal_uart_start_tx(CONSOLE_UART);
    96a8:	2000      	movs	r0, #0
    96aa:	f014 f82b 	bl	1d704 <hal_uart_start_tx>
    }
out:
    return 0;
    96ae:	2000      	movs	r0, #0
    96b0:	e001      	b.n	96b6 <console_rx_char+0x13a>
         * RX queue full. Reader must drain this.
         */
        if (ct->ct_rx_cb) {
            ct->ct_rx_cb();
        }
        return -1;
    96b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }
        hal_uart_start_tx(CONSOLE_UART);
    }
out:
    return 0;
}
    96b6:	b004      	add	sp, #16
    96b8:	bd70      	pop	{r4, r5, r6, pc}
	...

000096bc <console_queue_char>:
    }
}

static void
console_queue_char(char ch)
{
    96bc:	b538      	push	{r3, r4, r5, lr}
    96be:	4605      	mov	r5, r0
        hal_uart_start_tx(CONSOLE_UART);
        OS_EXIT_CRITICAL(sr);
	if (os_started()) {
            os_time_delay(1);
	}
        OS_ENTER_CRITICAL(sr);
    96c0:	f000 f92e 	bl	9920 <os_arch_save_sr>
    96c4:	4604      	mov	r4, r0
{
    struct console_tty *ct = &console_tty;
    int sr;

    OS_ENTER_CRITICAL(sr);
    while (CONSOLE_HEAD_INC(&ct->ct_tx) == ct->ct_tx.cr_tail) {
    96c6:	480f      	ldr	r0, [pc, #60]	; (9704 <console_queue_char+0x48>)
    96c8:	7883      	ldrb	r3, [r0, #2]
    96ca:	1e5a      	subs	r2, r3, #1
    96cc:	7803      	ldrb	r3, [r0, #0]
    96ce:	3301      	adds	r3, #1
    96d0:	4013      	ands	r3, r2
    96d2:	7842      	ldrb	r2, [r0, #1]
    96d4:	4293      	cmp	r3, r2
    96d6:	d10d      	bne.n	96f4 <console_queue_char+0x38>
        /* TX needs to drain */
        hal_uart_start_tx(CONSOLE_UART);
    96d8:	2000      	movs	r0, #0
    96da:	f014 f813 	bl	1d704 <hal_uart_start_tx>
        OS_EXIT_CRITICAL(sr);
    96de:	4620      	mov	r0, r4
    96e0:	f000 f924 	bl	992c <os_arch_restore_sr>
	if (os_started()) {
    96e4:	f000 f8c6 	bl	9874 <os_started>
    96e8:	2800      	cmp	r0, #0
    96ea:	d0e9      	beq.n	96c0 <console_queue_char+0x4>
            os_time_delay(1);
    96ec:	2001      	movs	r0, #1
    96ee:	f001 f8a5 	bl	a83c <os_time_delay>
    96f2:	e7e5      	b.n	96c0 <console_queue_char+0x4>
	}
        OS_ENTER_CRITICAL(sr);
    }
    console_add_char(&ct->ct_tx, ch);
    96f4:	4629      	mov	r1, r5
    96f6:	f7ff ff1d 	bl	9534 <console_add_char>
    OS_EXIT_CRITICAL(sr);
    96fa:	4620      	mov	r0, r4
}
    96fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            os_time_delay(1);
	}
        OS_ENTER_CRITICAL(sr);
    }
    console_add_char(&ct->ct_tx, ch);
    OS_EXIT_CRITICAL(sr);
    9700:	f000 b914 	b.w	992c <os_arch_restore_sr>
    9704:	20002d18 	.word	0x20002d18

00009708 <console_tx_char>:
console_tx_char(void *arg)
{
    struct console_tty *ct = (struct console_tty *)arg;
    struct console_ring *cr = &ct->ct_tx;

    if (cr->cr_head == cr->cr_tail) {
    9708:	7843      	ldrb	r3, [r0, #1]
    970a:	7802      	ldrb	r2, [r0, #0]
    970c:	429a      	cmp	r2, r3
console_pull_char(struct console_ring *cr)
{
    uint8_t ch;

    ch = cr->cr_buf[cr->cr_tail];
    cr->cr_tail = CONSOLE_TAIL_INC(cr);
    970e:	bf1f      	itttt	ne
    9710:	7881      	ldrbne	r1, [r0, #2]
static uint8_t
console_pull_char(struct console_ring *cr)
{
    uint8_t ch;

    ch = cr->cr_buf[cr->cr_tail];
    9712:	6842      	ldrne	r2, [r0, #4]
    cr->cr_tail = CONSOLE_TAIL_INC(cr);
    9714:	f101 31ff 	addne.w	r1, r1, #4294967295	; 0xffffffff
static uint8_t
console_pull_char(struct console_ring *cr)
{
    uint8_t ch;

    ch = cr->cr_buf[cr->cr_tail];
    9718:	5cd2      	ldrbne	r2, [r2, r3]
    cr->cr_tail = CONSOLE_TAIL_INC(cr);
    971a:	bf1f      	itttt	ne
    971c:	3301      	addne	r3, #1
    971e:	400b      	andne	r3, r1
    9720:	7043      	strbne	r3, [r0, #1]
        /*
         * No more data.
         */
        return -1;
    }
    return console_pull_char(cr);
    9722:	4610      	movne	r0, r2

    if (cr->cr_head == cr->cr_tail) {
        /*
         * No more data.
         */
        return -1;
    9724:	bf08      	it	eq
    9726:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
    }
    return console_pull_char(cr);
}
    972a:	4770      	bx	lr

0000972c <console_blocking_mode>:
    }
}

void
console_blocking_mode(void)
{
    972c:	b510      	push	{r4, lr}
    struct console_tty *ct = &console_tty;
    int sr;

    OS_ENTER_CRITICAL(sr);
    972e:	f000 f8f7 	bl	9920 <os_arch_save_sr>
    9732:	4604      	mov	r4, r0
    ct->ct_write_char = console_blocking_tx;
    9734:	4805      	ldr	r0, [pc, #20]	; (974c <console_blocking_mode+0x20>)
    9736:	4b06      	ldr	r3, [pc, #24]	; (9750 <console_blocking_mode+0x24>)
    9738:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4

    console_tx_flush(ct, CONSOLE_TX_BUF_SZ);
    973c:	2120      	movs	r1, #32
    973e:	f7ff ff07 	bl	9550 <console_tx_flush>
    OS_EXIT_CRITICAL(sr);
    9742:	4620      	mov	r0, r4
}
    9744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

    OS_ENTER_CRITICAL(sr);
    ct->ct_write_char = console_blocking_tx;

    console_tx_flush(ct, CONSOLE_TX_BUF_SZ);
    OS_EXIT_CRITICAL(sr);
    9748:	f000 b8f0 	b.w	992c <os_arch_restore_sr>
    974c:	20002d18 	.word	0x20002d18
    9750:	00009549 	.word	0x00009549

00009754 <console_file_write>:
    ct->ct_echo_off = !on;
}

size_t
console_file_write(void *arg, const char *str, size_t cnt)
{
    9754:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9758:	4615      	mov	r5, r2
    975a:	460c      	mov	r4, r1
    975c:	188f      	adds	r7, r1, r2
    struct console_tty *ct = &console_tty;
    int i;

    for (i = 0; i < cnt; i++) {
    975e:	42bc      	cmp	r4, r7
    9760:	d00f      	beq.n	9782 <console_file_write+0x2e>
        if (str[i] == '\n') {
    9762:	7823      	ldrb	r3, [r4, #0]
    9764:	4e0e      	ldr	r6, [pc, #56]	; (97a0 <console_file_write+0x4c>)
    9766:	2b0a      	cmp	r3, #10
    9768:	46a0      	mov	r8, r4
    976a:	d103      	bne.n	9774 <console_file_write+0x20>
            ct->ct_write_char('\r');
    976c:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
    9770:	200d      	movs	r0, #13
    9772:	4798      	blx	r3
        }
        ct->ct_write_char(str[i]);
    9774:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
    9778:	f898 0000 	ldrb.w	r0, [r8]
    977c:	3401      	adds	r4, #1
    977e:	4798      	blx	r3
    9780:	e7ed      	b.n	975e <console_file_write+0xa>
    }
    if (cnt > 0) {
    9782:	b135      	cbz	r5, 9792 <console_file_write+0x3e>
        console_is_midline = str[cnt - 1] != '\n';
    9784:	f814 3c01 	ldrb.w	r3, [r4, #-1]
    9788:	4a06      	ldr	r2, [pc, #24]	; (97a4 <console_file_write+0x50>)
    978a:	3b0a      	subs	r3, #10
    978c:	bf18      	it	ne
    978e:	2301      	movne	r3, #1
    9790:	6013      	str	r3, [r2, #0]
    }
    hal_uart_start_tx(CONSOLE_UART);
    9792:	2000      	movs	r0, #0
    9794:	f013 ffb6 	bl	1d704 <hal_uart_start_tx>
    return cnt;
}
    9798:	4628      	mov	r0, r5
    979a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    979e:	bf00      	nop
    97a0:	20002d18 	.word	0x20002d18
    97a4:	20002d14 	.word	0x20002d14

000097a8 <console_write>:

void
console_write(const char *str, int cnt)
{
    97a8:	4603      	mov	r3, r0
    97aa:	460a      	mov	r2, r1
    console_file_write(NULL, str, cnt);
    97ac:	2000      	movs	r0, #0
    97ae:	4619      	mov	r1, r3
    97b0:	f7ff bfd0 	b.w	9754 <console_file_write>

000097b4 <console_is_init>:

int
console_is_init(void)
{
    return (g_console_is_init);
}
    97b4:	4b01      	ldr	r3, [pc, #4]	; (97bc <console_is_init+0x8>)
    97b6:	6818      	ldr	r0, [r3, #0]
    97b8:	4770      	bx	lr
    97ba:	bf00      	nop
    97bc:	20002d10 	.word	0x20002d10

000097c0 <console_init>:

int
console_init(console_rx_cb rx_cb)
{
    97c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    97c2:	4605      	mov	r5, r0
    struct console_tty *ct = &console_tty;
    int rc;

    rc = hal_uart_init_cbs(CONSOLE_UART, console_tx_char, NULL,
    97c4:	4c13      	ldr	r4, [pc, #76]	; (9814 <console_init+0x54>)
    97c6:	9400      	str	r4, [sp, #0]
    97c8:	2000      	movs	r0, #0
    97ca:	4913      	ldr	r1, [pc, #76]	; (9818 <console_init+0x58>)
    97cc:	4b13      	ldr	r3, [pc, #76]	; (981c <console_init+0x5c>)
    97ce:	4602      	mov	r2, r0
    97d0:	f013 ff86 	bl	1d6e0 <hal_uart_init_cbs>
            console_rx_char, ct);
    if (rc) {
    97d4:	b9d8      	cbnz	r0, 980e <console_init+0x4e>
        return rc;
    }
    ct->ct_tx.cr_size = CONSOLE_TX_BUF_SZ;
    97d6:	2220      	movs	r2, #32
    97d8:	70a2      	strb	r2, [r4, #2]
    ct->ct_tx.cr_buf = ct->ct_tx_buf;
    97da:	f104 0208 	add.w	r2, r4, #8
    97de:	6062      	str	r2, [r4, #4]
    ct->ct_rx.cr_size = CONSOLE_RX_BUF_SZ;
    97e0:	2280      	movs	r2, #128	; 0x80
    97e2:	f884 202a 	strb.w	r2, [r4, #42]	; 0x2a
    ct->ct_rx.cr_buf = ct->ct_rx_buf;
    97e6:	f104 0230 	add.w	r2, r4, #48	; 0x30
    97ea:	62e2      	str	r2, [r4, #44]	; 0x2c
    ct->ct_rx_cb = rx_cb;
    ct->ct_write_char = console_queue_char;
    97ec:	4a0c      	ldr	r2, [pc, #48]	; (9820 <console_init+0x60>)
    97ee:	f8c4 20b4 	str.w	r2, [r4, #180]	; 0xb4

    rc = hal_uart_config(CONSOLE_UART, 115200, 8, 1, HAL_UART_PARITY_NONE,
    97f2:	9000      	str	r0, [sp, #0]
    97f4:	9001      	str	r0, [sp, #4]
    97f6:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
    97fa:	2208      	movs	r2, #8
    97fc:	2301      	movs	r3, #1
    }
    ct->ct_tx.cr_size = CONSOLE_TX_BUF_SZ;
    ct->ct_tx.cr_buf = ct->ct_tx_buf;
    ct->ct_rx.cr_size = CONSOLE_RX_BUF_SZ;
    ct->ct_rx.cr_buf = ct->ct_rx_buf;
    ct->ct_rx_cb = rx_cb;
    97fe:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
    ct->ct_write_char = console_queue_char;

    rc = hal_uart_config(CONSOLE_UART, 115200, 8, 1, HAL_UART_PARITY_NONE,
    9802:	f013 ffcb 	bl	1d79c <hal_uart_config>
      HAL_UART_FLOW_CTL_NONE);
    if (rc) {
    9806:	b910      	cbnz	r0, 980e <console_init+0x4e>
        return rc;
    }

    g_console_is_init = 1;
    9808:	4b06      	ldr	r3, [pc, #24]	; (9824 <console_init+0x64>)
    980a:	2201      	movs	r2, #1
    980c:	601a      	str	r2, [r3, #0]

    return 0;
}
    980e:	b003      	add	sp, #12
    9810:	bd30      	pop	{r4, r5, pc}
    9812:	bf00      	nop
    9814:	20002d18 	.word	0x20002d18
    9818:	00009709 	.word	0x00009709
    981c:	0000957d 	.word	0x0000957d
    9820:	000096bd 	.word	0x000096bd
    9824:	20002d10 	.word	0x20002d10

00009828 <os_idle_task>:
 *
 * @param arg unused
 */
void
os_idle_task(void *arg)
{
    9828:	b570      	push	{r4, r5, r6, lr}
    os_sr_t sr;
    os_time_t now;
    os_time_t iticks, sticks, cticks;

    while (1) {
        ++g_os_idle_ctr;
    982a:	4a11      	ldr	r2, [pc, #68]	; (9870 <os_idle_task+0x48>)
    982c:	6813      	ldr	r3, [r2, #0]
    982e:	3301      	adds	r3, #1
    9830:	6013      	str	r3, [r2, #0]
        OS_ENTER_CRITICAL(sr);
    9832:	f000 f875 	bl	9920 <os_arch_save_sr>
    9836:	4605      	mov	r5, r0
        now = os_time_get();
    9838:	f000 ffc2 	bl	a7c0 <os_time_get>
    983c:	4606      	mov	r6, r0
        sticks = os_sched_wakeup_ticks(now);
    983e:	f000 ff0d 	bl	a65c <os_sched_wakeup_ticks>
    9842:	4604      	mov	r4, r0
        cticks = os_callout_wakeup_ticks(now);
    9844:	4630      	mov	r0, r6
    9846:	f000 f9b1 	bl	9bac <os_callout_wakeup_ticks>
        iticks = min(sticks, cticks);
    984a:	42a0      	cmp	r0, r4
    984c:	bf28      	it	cs
    984e:	4620      	movcs	r0, r4
        if (iticks < MIN_IDLE_TICKS) {
    9850:	280b      	cmp	r0, #11
    9852:	d905      	bls.n	9860 <os_idle_task+0x38>
    9854:	f5b0 3f96 	cmp.w	r0, #76800	; 0x12c00
    9858:	bf28      	it	cs
    985a:	f44f 3096 	movcs.w	r0, #76800	; 0x12c00
    985e:	e000      	b.n	9862 <os_idle_task+0x3a>
            iticks = 0;
    9860:	2000      	movs	r0, #0
            /* NOTHING */
        }
        /* Tell the architecture specific support to put the processor to sleep
         * for 'n' ticks.
         */
        os_tick_idle(iticks);
    9862:	f013 fe43 	bl	1d4ec <os_tick_idle>
        OS_EXIT_CRITICAL(sr);
    9866:	4628      	mov	r0, r5
    9868:	f000 f860 	bl	992c <os_arch_restore_sr>
    }
    986c:	e7dd      	b.n	982a <os_idle_task+0x2>
    986e:	bf00      	nop
    9870:	20002e24 	.word	0x20002e24

00009874 <os_started>:
 */
int
os_started(void)
{
    return (g_os_started);
}
    9874:	4b01      	ldr	r3, [pc, #4]	; (987c <os_started+0x8>)
    9876:	6818      	ldr	r0, [r3, #0]
    9878:	4770      	bx	lr
    987a:	bf00      	nop
    987c:	20002f28 	.word	0x20002f28

00009880 <os_init_idle_task>:


void
os_init_idle_task(void)
{
    9880:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    os_task_init(&g_idle_task, "idle", os_idle_task, NULL,
    9882:	22ff      	movs	r2, #255	; 0xff
    9884:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9888:	e88d 000c 	stmia.w	sp, {r2, r3}
    988c:	4b06      	ldr	r3, [pc, #24]	; (98a8 <os_init_idle_task+0x28>)
    988e:	9302      	str	r3, [sp, #8]
    9890:	2340      	movs	r3, #64	; 0x40
    9892:	9303      	str	r3, [sp, #12]
    9894:	4905      	ldr	r1, [pc, #20]	; (98ac <os_init_idle_task+0x2c>)
    9896:	4a06      	ldr	r2, [pc, #24]	; (98b0 <os_init_idle_task+0x30>)
    9898:	4806      	ldr	r0, [pc, #24]	; (98b4 <os_init_idle_task+0x34>)
    989a:	2300      	movs	r3, #0
    989c:	f000 ff14 	bl	a6c8 <os_task_init>
            OS_IDLE_PRIO, OS_WAIT_FOREVER, g_idle_task_stack,
            OS_STACK_ALIGN(OS_IDLE_STACK_SIZE));
}
    98a0:	b005      	add	sp, #20
    98a2:	f85d fb04 	ldr.w	pc, [sp], #4
    98a6:	bf00      	nop
    98a8:	20002e28 	.word	0x20002e28
    98ac:	0001f0a0 	.word	0x0001f0a0
    98b0:	00009829 	.word	0x00009829
    98b4:	20002dd4 	.word	0x20002dd4

000098b8 <os_init>:
void
os_init(void)
{
    os_error_t err;

    TAILQ_INIT(&g_callout_list);
    98b8:	4b08      	ldr	r3, [pc, #32]	; (98dc <os_init+0x24>)
 * Initialize the operating system, calls into the architecture specific
 * support to initialize the operating system.
 */
void
os_init(void)
{
    98ba:	b510      	push	{r4, lr}
    os_error_t err;

    TAILQ_INIT(&g_callout_list);
    98bc:	2400      	movs	r4, #0
    98be:	601c      	str	r4, [r3, #0]
    98c0:	605b      	str	r3, [r3, #4]
    STAILQ_INIT(&g_os_task_list);
    98c2:	4b07      	ldr	r3, [pc, #28]	; (98e0 <os_init+0x28>)
    98c4:	601c      	str	r4, [r3, #0]
    98c6:	605b      	str	r3, [r3, #4]

    err = os_arch_os_init();
    98c8:	f000 f860 	bl	998c <os_arch_os_init>
    assert(err == OS_OK);
    98cc:	b128      	cbz	r0, 98da <os_init+0x22>
    98ce:	4805      	ldr	r0, [pc, #20]	; (98e4 <os_init+0x2c>)
    98d0:	2171      	movs	r1, #113	; 0x71
    98d2:	4622      	mov	r2, r4
    98d4:	4623      	mov	r3, r4
    98d6:	f000 f9fb 	bl	9cd0 <__assert_func>
    98da:	bd10      	pop	{r4, pc}
    98dc:	20002f2c 	.word	0x20002f2c
    98e0:	20002f3c 	.word	0x20002f3c
    98e4:	0001f0a5 	.word	0x0001f0a5

000098e8 <os_start>:
 * Start the operating system, calls into the architecture specific support
 * to start the operating system.
 */
void
os_start(void)
{
    98e8:	b508      	push	{r3, lr}
    os_error_t err;

    err = os_arch_os_start();
    98ea:	f000 f8b7 	bl	9a5c <os_arch_os_start>
    assert(err == OS_OK);
    98ee:	b128      	cbz	r0, 98fc <os_start+0x14>
    98f0:	2200      	movs	r2, #0
    98f2:	4803      	ldr	r0, [pc, #12]	; (9900 <os_start+0x18>)
    98f4:	217e      	movs	r1, #126	; 0x7e
    98f6:	4613      	mov	r3, r2
    98f8:	f000 f9ea 	bl	9cd0 <__assert_func>
    98fc:	bd08      	pop	{r3, pc}
    98fe:	bf00      	nop
    9900:	0001f0a5 	.word	0x0001f0a5

00009904 <timer_handler>:
uint32_t os_flags = OS_RUN_PRIV;

void
timer_handler(void)
{
    os_time_advance(1);
    9904:	2001      	movs	r0, #1
    9906:	f000 bf61 	b.w	a7cc <os_time_advance>
	...

0000990c <os_arch_ctx_sw>:
}

void
os_arch_ctx_sw(struct os_task *t)
{
    990c:	b508      	push	{r3, lr}
    os_sched_ctx_sw_hook(t);
    990e:	f000 fdd7 	bl	a4c0 <os_sched_ctx_sw_hook>

    /* Set PendSV interrupt pending bit to force context switch */
    SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
    9912:	4b02      	ldr	r3, [pc, #8]	; (991c <os_arch_ctx_sw+0x10>)
    9914:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    9918:	605a      	str	r2, [r3, #4]
    991a:	bd08      	pop	{r3, pc}
    991c:	e000ed00 	.word	0xe000ed00

00009920 <os_arch_save_sr>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    9920:	f3ef 8010 	mrs	r0, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    9924:	b672      	cpsid	i
    uint32_t isr_ctx;

    isr_ctx = __get_PRIMASK();
    __disable_irq();
    return (isr_ctx & 1);
}
    9926:	f000 0001 	and.w	r0, r0, #1
    992a:	4770      	bx	lr

0000992c <os_arch_restore_sr>:

void
os_arch_restore_sr(os_sr_t isr_ctx)
{
    if (!isr_ctx) {
    992c:	b900      	cbnz	r0, 9930 <os_arch_restore_sr+0x4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    992e:	b662      	cpsie	i
    9930:	4770      	bx	lr

00009932 <os_arch_in_critical>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    9932:	f3ef 8010 	mrs	r0, PRIMASK
{
    uint32_t isr_ctx;

    isr_ctx = __get_PRIMASK();
    return (isr_ctx & 1);
}
    9936:	f000 0001 	and.w	r0, r0, #1
    993a:	4770      	bx	lr

0000993c <os_arch_task_stack_init>:

os_stack_t *
os_arch_task_stack_init(struct os_task *t, os_stack_t *stack_top, int size)
{
    993c:	b570      	push	{r4, r5, r6, lr}
    993e:	f1a1 0320 	sub.w	r3, r1, #32
    9942:	4606      	mov	r6, r0
    9944:	460c      	mov	r4, r1
    int i;
    os_stack_t *s;
    struct stack_frame *sf;

    /* Get stack frame pointer */
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));
    9946:	f1a1 0540 	sub.w	r5, r1, #64	; 0x40
    994a:	f1a1 020c 	sub.w	r2, r1, #12

    /* Zero out R1-R3, R12, LR */
    for (i = 9; i < 14; ++i) {
        s[i] = 0;
    994e:	2100      	movs	r1, #0
    9950:	f843 1f04 	str.w	r1, [r3, #4]!

    /* Get stack frame pointer */
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));

    /* Zero out R1-R3, R12, LR */
    for (i = 9; i < 14; ++i) {
    9954:	4293      	cmp	r3, r2
    9956:	d1fa      	bne.n	994e <os_arch_task_stack_init+0x12>
        s[i] = 0;
    }

    /* Set registers R4 - R11 on stack. */
    os_arch_init_task_stack(s);
    9958:	4628      	mov	r0, r5
    995a:	f000 ffe8 	bl	a92e <os_arch_init_task_stack>

    /* Set remaining portions of stack frame */
    sf = (struct stack_frame *) s;
    sf->xpsr = INITIAL_xPSR;
    995e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    9962:	f844 3c04 	str.w	r3, [r4, #-4]
    sf->pc = (uint32_t)t->t_func;
    9966:	6973      	ldr	r3, [r6, #20]
    9968:	f844 3c08 	str.w	r3, [r4, #-8]
    sf->r0 = (uint32_t)t->t_arg;
    996c:	69b3      	ldr	r3, [r6, #24]
    996e:	f844 3c20 	str.w	r3, [r4, #-32]

    return (s);
}
    9972:	4628      	mov	r0, r5
    9974:	bd70      	pop	{r4, r5, r6, pc}
	...

00009978 <os_arch_init>:
os_arch_init(void)
{
    /*
     * Trap on divide-by-zero.
     */
    SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    9978:	4a03      	ldr	r2, [pc, #12]	; (9988 <os_arch_init+0x10>)
    997a:	6953      	ldr	r3, [r2, #20]
    997c:	f043 0310 	orr.w	r3, r3, #16
    9980:	6153      	str	r3, [r2, #20]
    os_init_idle_task();
    9982:	f7ff bf7d 	b.w	9880 <os_init_idle_task>
    9986:	bf00      	nop
    9988:	e000ed00 	.word	0xe000ed00

0000998c <os_arch_os_init>:
    SVC_Call(os_arch_init);
}

os_error_t
os_arch_os_init(void)
{
    998c:	b538      	push	{r3, r4, r5, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    998e:	f3ef 8305 	mrs	r3, IPSR
    os_error_t err;
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
    9992:	2b00      	cmp	r3, #0
    9994:	d141      	bne.n	9a1a <os_arch_os_init+0x8e>
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
            NVIC->IP[i] = 0xff;
    9996:	f103 4260 	add.w	r2, r3, #3758096384	; 0xe0000000
    999a:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    999e:	3301      	adds	r3, #1
            NVIC->IP[i] = 0xff;
    99a0:	21ff      	movs	r1, #255	; 0xff
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    99a2:	2bf0      	cmp	r3, #240	; 0xf0
            NVIC->IP[i] = 0xff;
    99a4:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    99a8:	d1f5      	bne.n	9996 <os_arch_os_init+0xa>
        /*
         * Install default interrupt handler, which'll print out system
         * state at the time of the interrupt, and few other regs which
         * should help in trying to figure out what went wrong.
         */
        NVIC_SetVector(NonMaskableInt_IRQn, (uint32_t)os_default_irq_asm);
    99aa:	f06f 000d 	mvn.w	r0, #13
    99ae:	491c      	ldr	r1, [pc, #112]	; (9a20 <os_arch_os_init+0x94>)
    99b0:	f7ff fdb6 	bl	9520 <NVIC_SetVector>
        NVIC_SetVector(-13, (uint32_t)os_default_irq_asm);
    99b4:	f06f 000c 	mvn.w	r0, #12
    99b8:	4919      	ldr	r1, [pc, #100]	; (9a20 <os_arch_os_init+0x94>)
    99ba:	f7ff fdb1 	bl	9520 <NVIC_SetVector>
        NVIC_SetVector(MemoryManagement_IRQn, (uint32_t)os_default_irq_asm);
    99be:	f06f 000b 	mvn.w	r0, #11
    99c2:	4917      	ldr	r1, [pc, #92]	; (9a20 <os_arch_os_init+0x94>)
    99c4:	f7ff fdac 	bl	9520 <NVIC_SetVector>
        NVIC_SetVector(BusFault_IRQn, (uint32_t)os_default_irq_asm);
    99c8:	f06f 000a 	mvn.w	r0, #10
    99cc:	4914      	ldr	r1, [pc, #80]	; (9a20 <os_arch_os_init+0x94>)
    99ce:	f7ff fda7 	bl	9520 <NVIC_SetVector>
        NVIC_SetVector(UsageFault_IRQn, (uint32_t)os_default_irq_asm);
    99d2:	f06f 0009 	mvn.w	r0, #9
    99d6:	4912      	ldr	r1, [pc, #72]	; (9a20 <os_arch_os_init+0x94>)
    99d8:	f7ff fda2 	bl	9520 <NVIC_SetVector>
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    99dc:	2400      	movs	r4, #0
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
    99de:	b260      	sxtb	r0, r4
    99e0:	490f      	ldr	r1, [pc, #60]	; (9a20 <os_arch_os_init+0x94>)
        NVIC_SetVector(NonMaskableInt_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(-13, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(MemoryManagement_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(BusFault_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(UsageFault_IRQn, (uint32_t)os_default_irq_asm);
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    99e2:	3401      	adds	r4, #1
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
    99e4:	f7ff fd9c 	bl	9520 <NVIC_SetVector>
        NVIC_SetVector(NonMaskableInt_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(-13, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(MemoryManagement_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(BusFault_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(UsageFault_IRQn, (uint32_t)os_default_irq_asm);
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    99e8:	2c26      	cmp	r4, #38	; 0x26
    99ea:	d1f8      	bne.n	99de <os_arch_os_init+0x52>
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
    99ec:	4c0d      	ldr	r4, [pc, #52]	; (9a24 <os_arch_os_init+0x98>)
    99ee:	25e0      	movs	r5, #224	; 0xe0
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
        }

        /* Call bsp related OS initializations */
        bsp_init();
    99f0:	f013 fcc6 	bl	1d380 <bsp_init>
    99f4:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
    99f8:	2520      	movs	r5, #32
    99fa:	77e5      	strb	r5, [r4, #31]
        /*
         * Set the os environment. This will set stack pointers and, based
         * on the contents of os_flags, will determine if the tasks run in
         * priviliged or un-privileged mode.
         */
        os_set_env();
    99fc:	f000 ff8c 	bl	a918 <os_set_env>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    9a00:	f3ef 8414 	mrs	r4, CONTROL

        /* Check if privileged or not */
        if ((__get_CONTROL() & 1) == 0) {
    9a04:	f014 0401 	ands.w	r4, r4, #1
    9a08:	d102      	bne.n	9a10 <os_arch_os_init+0x84>
            os_arch_init();
    9a0a:	f7ff ffb5 	bl	9978 <os_arch_init>
    9a0e:	e002      	b.n	9a16 <os_arch_os_init+0x8a>
__attribute__((always_inline))
static inline void
svc_os_arch_init(void)
{
    SVC_Arg0();
    SVC_Call(os_arch_init);
    9a10:	f8df c014 	ldr.w	ip, [pc, #20]	; 9a28 <os_arch_os_init+0x9c>
    9a14:	df00      	svc	0
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;
    9a16:	2000      	movs	r0, #0
    9a18:	bd38      	pop	{r3, r4, r5, pc}
{
    os_error_t err;
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    9a1a:	2007      	movs	r0, #7
            svc_os_arch_init();
        }
    }

    return err;
}
    9a1c:	bd38      	pop	{r3, r4, r5, pc}
    9a1e:	bf00      	nop
    9a20:	0000a9b1 	.word	0x0000a9b1
    9a24:	e000ed00 	.word	0xe000ed00
    9a28:	00009979 	.word	0x00009979

00009a2c <os_arch_start>:

uint32_t
os_arch_start(void)
{
    9a2c:	b510      	push	{r4, lr}
    struct os_task *t;

    /* Get the highest priority ready to run to set the current task */
    t = os_sched_next_task();
    9a2e:	f000 fe33 	bl	a698 <os_sched_next_task>
    9a32:	4604      	mov	r4, r0
    os_sched_set_current_task(t);
    9a34:	f000 fd62 	bl	a4fc <os_sched_set_current_task>

    /* Adjust PSP so it looks like this task just took an exception */
    __set_PSP((uint32_t)t->t_stackptr + offsetof(struct stack_frame, r0));
    9a38:	6823      	ldr	r3, [r4, #0]
    9a3a:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    9a3c:	f383 8809 	msr	PSP, r3

    /* Intitialize and start system clock timer */
    os_tick_init(OS_TICKS_PER_SEC, OS_TICK_PRIO);
    9a40:	2106      	movs	r1, #6
    9a42:	2080      	movs	r0, #128	; 0x80
    9a44:	f013 fd76 	bl	1d534 <os_tick_init>

    /* Mark the OS as started, right before we run our first task */
    g_os_started = 1;
    9a48:	4b03      	ldr	r3, [pc, #12]	; (9a58 <os_arch_start+0x2c>)
    9a4a:	2201      	movs	r2, #1

    /* Perform context switch */
    os_arch_ctx_sw(t);
    9a4c:	4620      	mov	r0, r4

    /* Intitialize and start system clock timer */
    os_tick_init(OS_TICKS_PER_SEC, OS_TICK_PRIO);

    /* Mark the OS as started, right before we run our first task */
    g_os_started = 1;
    9a4e:	601a      	str	r2, [r3, #0]

    /* Perform context switch */
    os_arch_ctx_sw(t);
    9a50:	f7ff ff5c 	bl	990c <os_arch_ctx_sw>

    return (uint32_t)(t->t_arg);
}
    9a54:	69a0      	ldr	r0, [r4, #24]
    9a56:	bd10      	pop	{r4, pc}
    9a58:	20002f28 	.word	0x20002f28

00009a5c <os_arch_os_start>:
 * 
 * @return os_error_t 
 */
os_error_t
os_arch_os_start(void)
{
    9a5c:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    9a5e:	f3ef 8405 	mrs	r4, IPSR
    os_error_t err;

    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
    9a62:	b994      	cbnz	r4, 9a8a <os_arch_os_start+0x2e>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    9a64:	f3ef 8414 	mrs	r4, CONTROL
         * The following switch statement is really just a sanity check to
         * insure that the os initialization routine was called prior to the
         * os start routine.
         */
        err = OS_OK;
        switch (__get_CONTROL() & 0x03) {
    9a68:	f004 0403 	and.w	r4, r4, #3
    9a6c:	2c02      	cmp	r4, #2
    9a6e:	d002      	beq.n	9a76 <os_arch_os_start+0x1a>
    9a70:	2c03      	cmp	r4, #3
    9a72:	d005      	beq.n	9a80 <os_arch_os_start+0x24>
    9a74:	e00b      	b.n	9a8e <os_arch_os_start+0x32>
        case 0x02:
            /* 
             * We are running in Privileged Thread mode w/SP = PSP but we
             * are supposed to be un-privileged.
             */
            if ((os_flags & 1) == OS_RUN_UNPRIV) {
    9a76:	4c09      	ldr	r4, [pc, #36]	; (9a9c <os_arch_os_start+0x40>)
    9a78:	6824      	ldr	r4, [r4, #0]
    9a7a:	07e4      	lsls	r4, r4, #31
    9a7c:	d407      	bmi.n	9a8e <os_arch_os_start+0x32>
    9a7e:	e008      	b.n	9a92 <os_arch_os_start+0x36>
        case 0x03:
            /* 
             * We are running in Unprivileged Thread mode w/SP = PSP but we
             * are supposed to be privileged.
             */
            if  ((os_flags & 1) == OS_RUN_PRIV) {
    9a80:	4c06      	ldr	r4, [pc, #24]	; (9a9c <os_arch_os_start+0x40>)
    9a82:	6824      	ldr	r4, [r4, #0]
    9a84:	07e4      	lsls	r4, r4, #31
    9a86:	d404      	bmi.n	9a92 <os_arch_os_start+0x36>
    9a88:	e001      	b.n	9a8e <os_arch_os_start+0x32>
os_error_t
os_arch_os_start(void)
{
    os_error_t err;

    err = OS_ERR_IN_ISR;
    9a8a:	2007      	movs	r0, #7
    9a8c:	bd10      	pop	{r4, pc}
    9a8e:	2008      	movs	r0, #8
    9a90:	bd10      	pop	{r4, pc}

__attribute__((always_inline))
static inline void svc_os_arch_start(void)
{
    SVC_Arg0();
    SVC_Call(os_arch_start);
    9a92:	f8df c00c 	ldr.w	ip, [pc, #12]	; 9aa0 <os_arch_os_start+0x44>
    9a96:	df00      	svc	0
    9a98:	2000      	movs	r0, #0
            svc_os_arch_start();
        }
    }

    return err;
}
    9a9a:	bd10      	pop	{r4, pc}
    9a9c:	20001e58 	.word	0x20001e58
    9aa0:	00009a2d 	.word	0x00009a2d

00009aa4 <os_callout_func_init>:
 *               timer.
 */
void
os_callout_func_init(struct os_callout_func *cf, struct os_eventq *evq,
  os_callout_func_t timo_func, void *ev_arg)
{
    9aa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9aa6:	4604      	mov	r4, r0
    9aa8:	460e      	mov	r6, r1
    9aaa:	4615      	mov	r5, r2
struct os_callout_list g_callout_list;

static void
_os_callout_init(struct os_callout *c, struct os_eventq *evq, void *ev_arg)
{
    memset(c, 0, sizeof(*c));
    9aac:	2100      	movs	r1, #0
    9aae:	221c      	movs	r2, #28
 *               timer.
 */
void
os_callout_func_init(struct os_callout_func *cf, struct os_eventq *evq,
  os_callout_func_t timo_func, void *ev_arg)
{
    9ab0:	461f      	mov	r7, r3
struct os_callout_list g_callout_list;

static void
_os_callout_init(struct os_callout *c, struct os_eventq *evq, void *ev_arg)
{
    memset(c, 0, sizeof(*c));
    9ab2:	f7ff faae 	bl	9012 <memset>
    c->c_ev.ev_type = OS_EVENT_T_TIMER;
    9ab6:	2301      	movs	r3, #1
    9ab8:	7063      	strb	r3, [r4, #1]
    c->c_ev.ev_arg = ev_arg;
    9aba:	6067      	str	r7, [r4, #4]
    c->c_evq = evq;
    9abc:	60e6      	str	r6, [r4, #12]
void
os_callout_func_init(struct os_callout_func *cf, struct os_eventq *evq,
  os_callout_func_t timo_func, void *ev_arg)
{
    _os_callout_init(&cf->cf_c, evq, ev_arg);
    cf->cf_func = timo_func;
    9abe:	61e5      	str	r5, [r4, #28]
    9ac0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00009ac4 <os_callout_stop>:
 *
 * @param c The callout to stop
 */
void
os_callout_stop(struct os_callout *c)
{
    9ac4:	b538      	push	{r3, r4, r5, lr}
    9ac6:	4604      	mov	r4, r0
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    9ac8:	f7ff ff2a 	bl	9920 <os_arch_save_sr>
    9acc:	69a2      	ldr	r2, [r4, #24]
    9ace:	4605      	mov	r5, r0

    if (os_callout_queued(c)) {
    9ad0:	b14a      	cbz	r2, 9ae6 <os_callout_stop+0x22>
        TAILQ_REMOVE(&g_callout_list, c, c_next);
    9ad2:	6963      	ldr	r3, [r4, #20]
    9ad4:	b10b      	cbz	r3, 9ada <os_callout_stop+0x16>
    9ad6:	619a      	str	r2, [r3, #24]
    9ad8:	e001      	b.n	9ade <os_callout_stop+0x1a>
    9ada:	4908      	ldr	r1, [pc, #32]	; (9afc <os_callout_stop+0x38>)
    9adc:	604a      	str	r2, [r1, #4]
    9ade:	69a2      	ldr	r2, [r4, #24]
    9ae0:	6013      	str	r3, [r2, #0]
        c->c_next.tqe_prev = NULL;
    9ae2:	2300      	movs	r3, #0
    9ae4:	61a3      	str	r3, [r4, #24]
    }

    if (c->c_evq) {
    9ae6:	68e0      	ldr	r0, [r4, #12]
    9ae8:	b110      	cbz	r0, 9af0 <os_callout_stop+0x2c>
        os_eventq_remove(c->c_evq, &c->c_ev);
    9aea:	4621      	mov	r1, r4
    9aec:	f000 f8d1 	bl	9c92 <os_eventq_remove>
    }

    OS_EXIT_CRITICAL(sr);
    9af0:	4628      	mov	r0, r5
}
    9af2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    if (c->c_evq) {
        os_eventq_remove(c->c_evq, &c->c_ev);
    }

    OS_EXIT_CRITICAL(sr);
    9af6:	f7ff bf19 	b.w	992c <os_arch_restore_sr>
    9afa:	bf00      	nop
    9afc:	20002f2c 	.word	0x20002f2c

00009b00 <os_callout_reset>:
 *
 * @return 0 on success, non-zero on failure
 */
int
os_callout_reset(struct os_callout *c, int32_t ticks)
{
    9b00:	b570      	push	{r4, r5, r6, lr}
    struct os_callout *entry;
    os_sr_t sr;
    int rc;

    if (ticks < 0) {
    9b02:	1e0d      	subs	r5, r1, #0
 *
 * @return 0 on success, non-zero on failure
 */
int
os_callout_reset(struct os_callout *c, int32_t ticks)
{
    9b04:	4604      	mov	r4, r0
    struct os_callout *entry;
    os_sr_t sr;
    int rc;

    if (ticks < 0) {
    9b06:	db15      	blt.n	9b34 <os_callout_reset+0x34>
        rc = OS_EINVAL;
        goto err;
    }

    OS_ENTER_CRITICAL(sr);
    9b08:	f7ff ff0a 	bl	9920 <os_arch_save_sr>
    9b0c:	4606      	mov	r6, r0

    os_callout_stop(c);
    9b0e:	4620      	mov	r0, r4
    9b10:	f7ff ffd8 	bl	9ac4 <os_callout_stop>

    if (ticks == 0) {
        ticks = 1;
    9b14:	2d00      	cmp	r5, #0
    9b16:	bf08      	it	eq
    9b18:	2501      	moveq	r5, #1
    }

    c->c_ticks = os_time_get() + ticks;
    9b1a:	f000 fe51 	bl	a7c0 <os_time_get>

    entry = NULL;
    TAILQ_FOREACH(entry, &g_callout_list, c_next) {
    9b1e:	4a10      	ldr	r2, [pc, #64]	; (9b60 <os_callout_reset+0x60>)

    if (ticks == 0) {
        ticks = 1;
    }

    c->c_ticks = os_time_get() + ticks;
    9b20:	4428      	add	r0, r5

    entry = NULL;
    TAILQ_FOREACH(entry, &g_callout_list, c_next) {
    9b22:	6813      	ldr	r3, [r2, #0]

    if (ticks == 0) {
        ticks = 1;
    }

    c->c_ticks = os_time_get() + ticks;
    9b24:	6120      	str	r0, [r4, #16]

    entry = NULL;
    TAILQ_FOREACH(entry, &g_callout_list, c_next) {
    9b26:	b19b      	cbz	r3, 9b50 <os_callout_reset+0x50>
        if (OS_TIME_TICK_LT(c->c_ticks, entry->c_ticks)) {
    9b28:	6919      	ldr	r1, [r3, #16]
    9b2a:	1a41      	subs	r1, r0, r1
    9b2c:	2900      	cmp	r1, #0
    9b2e:	db03      	blt.n	9b38 <os_callout_reset+0x38>
    }

    c->c_ticks = os_time_get() + ticks;

    entry = NULL;
    TAILQ_FOREACH(entry, &g_callout_list, c_next) {
    9b30:	695b      	ldr	r3, [r3, #20]
    9b32:	e7f8      	b.n	9b26 <os_callout_reset+0x26>

    OS_EXIT_CRITICAL(sr);

    return (0);
err:
    return (rc);
    9b34:	2002      	movs	r0, #2
    9b36:	bd70      	pop	{r4, r5, r6, pc}
            break;
        }
    }

    if (entry) {
        TAILQ_INSERT_BEFORE(entry, c, c_next);
    9b38:	699a      	ldr	r2, [r3, #24]
    9b3a:	61a2      	str	r2, [r4, #24]
    9b3c:	699a      	ldr	r2, [r3, #24]
    9b3e:	6163      	str	r3, [r4, #20]
    9b40:	6014      	str	r4, [r2, #0]
    9b42:	3414      	adds	r4, #20
    9b44:	619c      	str	r4, [r3, #24]
    } else {
        TAILQ_INSERT_TAIL(&g_callout_list, c, c_next);
    }

    OS_EXIT_CRITICAL(sr);
    9b46:	4630      	mov	r0, r6
    9b48:	f7ff fef0 	bl	992c <os_arch_restore_sr>

    return (0);
    9b4c:	2000      	movs	r0, #0
    9b4e:	bd70      	pop	{r4, r5, r6, pc}
    }

    if (entry) {
        TAILQ_INSERT_BEFORE(entry, c, c_next);
    } else {
        TAILQ_INSERT_TAIL(&g_callout_list, c, c_next);
    9b50:	6163      	str	r3, [r4, #20]
    9b52:	6853      	ldr	r3, [r2, #4]
    9b54:	61a3      	str	r3, [r4, #24]
    9b56:	601c      	str	r4, [r3, #0]
    9b58:	3414      	adds	r4, #20
    9b5a:	6054      	str	r4, [r2, #4]
    9b5c:	e7f3      	b.n	9b46 <os_callout_reset+0x46>
    9b5e:	bf00      	nop
    9b60:	20002f2c 	.word	0x20002f2c

00009b64 <os_callout_tick>:
 * to run, it posts an event for each callout that's ready to run,
 * to the event queue provided to os_callout_func_init().
 */
void
os_callout_tick(void)
{
    9b64:	b538      	push	{r3, r4, r5, lr}
    os_sr_t sr;
    struct os_callout *c;
    uint32_t now;

    now = os_time_get();
    9b66:	f000 fe2b 	bl	a7c0 <os_time_get>
    9b6a:	4605      	mov	r5, r0

    while (1) {
        OS_ENTER_CRITICAL(sr);
    9b6c:	f7ff fed8 	bl	9920 <os_arch_save_sr>
        c = TAILQ_FIRST(&g_callout_list);
    9b70:	4a0d      	ldr	r2, [pc, #52]	; (9ba8 <os_callout_tick+0x44>)
    9b72:	6814      	ldr	r4, [r2, #0]
        if (c) {
    9b74:	b17c      	cbz	r4, 9b96 <os_callout_tick+0x32>
            if (OS_TIME_TICK_GEQ(now, c->c_ticks)) {
    9b76:	6923      	ldr	r3, [r4, #16]
    9b78:	1aeb      	subs	r3, r5, r3
    9b7a:	2b00      	cmp	r3, #0
    9b7c:	db0a      	blt.n	9b94 <os_callout_tick+0x30>
                TAILQ_REMOVE(&g_callout_list, c, c_next);
    9b7e:	6963      	ldr	r3, [r4, #20]
    9b80:	69a1      	ldr	r1, [r4, #24]
    9b82:	b10b      	cbz	r3, 9b88 <os_callout_tick+0x24>
    9b84:	6199      	str	r1, [r3, #24]
    9b86:	e000      	b.n	9b8a <os_callout_tick+0x26>
    9b88:	6051      	str	r1, [r2, #4]
    9b8a:	69a2      	ldr	r2, [r4, #24]
    9b8c:	6013      	str	r3, [r2, #0]
                c->c_next.tqe_prev = NULL;
    9b8e:	2300      	movs	r3, #0
    9b90:	61a3      	str	r3, [r4, #24]
    9b92:	e000      	b.n	9b96 <os_callout_tick+0x32>
    9b94:	2400      	movs	r4, #0
            } else {
                c = NULL;
            }
        }
        OS_EXIT_CRITICAL(sr);
    9b96:	f7ff fec9 	bl	992c <os_arch_restore_sr>

        if (c) {
    9b9a:	b124      	cbz	r4, 9ba6 <os_callout_tick+0x42>
            os_eventq_put(c->c_evq, &c->c_ev);
    9b9c:	68e0      	ldr	r0, [r4, #12]
    9b9e:	4621      	mov	r1, r4
    9ba0:	f000 f827 	bl	9bf2 <os_eventq_put>
        } else {
            break;
        }
    }
    9ba4:	e7e2      	b.n	9b6c <os_callout_tick+0x8>
    9ba6:	bd38      	pop	{r3, r4, r5, pc}
    9ba8:	20002f2c 	.word	0x20002f2c

00009bac <os_callout_wakeup_ticks>:
 *
 * @return Number of ticks to first pending callout
 */
os_time_t
os_callout_wakeup_ticks(os_time_t now)
{
    9bac:	b510      	push	{r4, lr}
    9bae:	4604      	mov	r4, r0
    os_time_t rt;
    struct os_callout *c;

    OS_ASSERT_CRITICAL();
    9bb0:	f7ff febf 	bl	9932 <os_arch_in_critical>
    9bb4:	4602      	mov	r2, r0
    9bb6:	b920      	cbnz	r0, 9bc2 <os_callout_wakeup_ticks+0x16>
    9bb8:	4807      	ldr	r0, [pc, #28]	; (9bd8 <os_callout_wakeup_ticks+0x2c>)
    9bba:	21ba      	movs	r1, #186	; 0xba
    9bbc:	4613      	mov	r3, r2
    9bbe:	f000 f887 	bl	9cd0 <__assert_func>

    c = TAILQ_FIRST(&g_callout_list);
    9bc2:	4b06      	ldr	r3, [pc, #24]	; (9bdc <os_callout_wakeup_ticks+0x30>)
    9bc4:	681b      	ldr	r3, [r3, #0]
    if (c != NULL) {
    9bc6:	b123      	cbz	r3, 9bd2 <os_callout_wakeup_ticks+0x26>
        if (OS_TIME_TICK_GEQ(c->c_ticks, now)) {
    9bc8:	6918      	ldr	r0, [r3, #16]
    9bca:	1b00      	subs	r0, r0, r4
            rt = c->c_ticks - now;
        } else {
            rt = 0;     /* callout time is in the past */
    9bcc:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    9bd0:	bd10      	pop	{r4, pc}
        }
    } else {
        rt = OS_TIMEOUT_NEVER;
    9bd2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }

    return (rt);
}
    9bd6:	bd10      	pop	{r4, pc}
    9bd8:	0001f0aa 	.word	0x0001f0aa
    9bdc:	20002f2c 	.word	0x20002f2c

00009be0 <os_eventq_init>:
 *
 * @param evq The event queue to initialize
 */
void
os_eventq_init(struct os_eventq *evq)
{
    9be0:	b510      	push	{r4, lr}
    memset(evq, 0, sizeof(*evq));
    9be2:	2100      	movs	r1, #0
 *
 * @param evq The event queue to initialize
 */
void
os_eventq_init(struct os_eventq *evq)
{
    9be4:	4604      	mov	r4, r0
    memset(evq, 0, sizeof(*evq));
    9be6:	220c      	movs	r2, #12
    9be8:	f7ff fa13 	bl	9012 <memset>
    STAILQ_INIT(&evq->evq_list);
    9bec:	1d23      	adds	r3, r4, #4
    9bee:	60a3      	str	r3, [r4, #8]
    9bf0:	bd10      	pop	{r4, pc}

00009bf2 <os_eventq_put>:
 * @param evq The event queue to put an event on 
 * @param ev The event to put on the queue
 */
void
os_eventq_put(struct os_eventq *evq, struct os_event *ev)
{
    9bf2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9bf4:	460d      	mov	r5, r1
    9bf6:	4606      	mov	r6, r0
    int resched;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    9bf8:	f7ff fe92 	bl	9920 <os_arch_save_sr>

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
    9bfc:	782b      	ldrb	r3, [r5, #0]
os_eventq_put(struct os_eventq *evq, struct os_event *ev)
{
    int resched;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    9bfe:	4607      	mov	r7, r0

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
    9c00:	b11b      	cbz	r3, 9c0a <os_eventq_put+0x18>
    OS_EXIT_CRITICAL(sr);

    if (resched) {
        os_sched(NULL);
    }
}
    9c02:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

    OS_ENTER_CRITICAL(sr);

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
        OS_EXIT_CRITICAL(sr);
    9c06:	f7ff be91 	b.w	992c <os_arch_restore_sr>
        return;
    }

    /* Queue the event */
    ev->ev_queued = 1;
    9c0a:	2401      	movs	r4, #1
    9c0c:	702c      	strb	r4, [r5, #0]
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);
    9c0e:	68b2      	ldr	r2, [r6, #8]
    9c10:	60ab      	str	r3, [r5, #8]
    9c12:	6015      	str	r5, [r2, #0]

    resched = 0;
    if (evq->evq_task) {
    9c14:	6830      	ldr	r0, [r6, #0]
        return;
    }

    /* Queue the event */
    ev->ev_queued = 1;
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);
    9c16:	3508      	adds	r5, #8
    9c18:	60b5      	str	r5, [r6, #8]

    resched = 0;
    if (evq->evq_task) {
    9c1a:	b148      	cbz	r0, 9c30 <os_eventq_put+0x3e>
        /* If task waiting on event, wake it up.
         * Check if task is sleeping, because another event 
         * queue may have woken this task up beforehand.
         */
        if (evq->evq_task->t_state == OS_TASK_SLEEP) {
    9c1c:	7b82      	ldrb	r2, [r0, #14]
    9c1e:	2a02      	cmp	r2, #2
    9c20:	d102      	bne.n	9c28 <os_eventq_put+0x36>
            os_sched_wakeup(evq->evq_task);
    9c22:	f000 fcc3 	bl	a5ac <os_sched_wakeup>
    9c26:	e000      	b.n	9c2a <os_eventq_put+0x38>

    /* Queue the event */
    ev->ev_queued = 1;
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);

    resched = 0;
    9c28:	461c      	mov	r4, r3
            resched = 1;
        }
        /* Either way, NULL out the task, because the task will
         * be awake upon exit of this function.
         */
        evq->evq_task = NULL;
    9c2a:	2300      	movs	r3, #0
    9c2c:	6033      	str	r3, [r6, #0]
    9c2e:	e000      	b.n	9c32 <os_eventq_put+0x40>

    /* Queue the event */
    ev->ev_queued = 1;
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);

    resched = 0;
    9c30:	4604      	mov	r4, r0
         * be awake upon exit of this function.
         */
        evq->evq_task = NULL;
    }

    OS_EXIT_CRITICAL(sr);
    9c32:	4638      	mov	r0, r7
    9c34:	f7ff fe7a 	bl	992c <os_arch_restore_sr>

    if (resched) {
    9c38:	b124      	cbz	r4, 9c44 <os_eventq_put+0x52>
        os_sched(NULL);
    9c3a:	2000      	movs	r0, #0
    }
}
    9c3c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }

    OS_EXIT_CRITICAL(sr);

    if (resched) {
        os_sched(NULL);
    9c40:	f000 bc62 	b.w	a508 <os_sched>
    9c44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00009c46 <os_eventq_get>:
 *
 * @return The event from the queue
 */
struct os_event *
os_eventq_get(struct os_eventq *evq)
{
    9c46:	b570      	push	{r4, r5, r6, lr}
    9c48:	4605      	mov	r5, r0
    struct os_event *ev;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    9c4a:	f7ff fe69 	bl	9920 <os_arch_save_sr>
    9c4e:	4606      	mov	r6, r0
pull_one:
    ev = STAILQ_FIRST(&evq->evq_list);
    9c50:	686c      	ldr	r4, [r5, #4]
    if (ev) {
    9c52:	b12c      	cbz	r4, 9c60 <os_eventq_get+0x1a>
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
    9c54:	68a3      	ldr	r3, [r4, #8]
    9c56:	606b      	str	r3, [r5, #4]
    9c58:	b9a3      	cbnz	r3, 9c84 <os_eventq_get+0x3e>
    9c5a:	1d2b      	adds	r3, r5, #4
    9c5c:	60ab      	str	r3, [r5, #8]
    9c5e:	e011      	b.n	9c84 <os_eventq_get+0x3e>
        ev->ev_queued = 0;
    } else {
        evq->evq_task = os_sched_get_current_task();
    9c60:	f000 fc46 	bl	a4f0 <os_sched_get_current_task>
        os_sched_sleep(evq->evq_task, OS_TIMEOUT_NEVER);
    9c64:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ev = STAILQ_FIRST(&evq->evq_list);
    if (ev) {
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
        ev->ev_queued = 0;
    } else {
        evq->evq_task = os_sched_get_current_task();
    9c68:	6028      	str	r0, [r5, #0]
        os_sched_sleep(evq->evq_task, OS_TIMEOUT_NEVER);
    9c6a:	f000 fc65 	bl	a538 <os_sched_sleep>
        OS_EXIT_CRITICAL(sr);
    9c6e:	4630      	mov	r0, r6
    9c70:	f7ff fe5c 	bl	992c <os_arch_restore_sr>

        os_sched(NULL);
    9c74:	4620      	mov	r0, r4
    9c76:	f000 fc47 	bl	a508 <os_sched>

        OS_ENTER_CRITICAL(sr);
    9c7a:	f7ff fe51 	bl	9920 <os_arch_save_sr>
        evq->evq_task = NULL;
    9c7e:	602c      	str	r4, [r5, #0]
        os_sched_sleep(evq->evq_task, OS_TIMEOUT_NEVER);
        OS_EXIT_CRITICAL(sr);

        os_sched(NULL);

        OS_ENTER_CRITICAL(sr);
    9c80:	4606      	mov	r6, r0
        evq->evq_task = NULL;
        goto pull_one;
    9c82:	e7e5      	b.n	9c50 <os_eventq_get+0xa>
    OS_ENTER_CRITICAL(sr);
pull_one:
    ev = STAILQ_FIRST(&evq->evq_list);
    if (ev) {
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
        ev->ev_queued = 0;
    9c84:	2300      	movs	r3, #0

        OS_ENTER_CRITICAL(sr);
        evq->evq_task = NULL;
        goto pull_one;
    }
    OS_EXIT_CRITICAL(sr);
    9c86:	4630      	mov	r0, r6
    OS_ENTER_CRITICAL(sr);
pull_one:
    ev = STAILQ_FIRST(&evq->evq_list);
    if (ev) {
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
        ev->ev_queued = 0;
    9c88:	7023      	strb	r3, [r4, #0]

        OS_ENTER_CRITICAL(sr);
        evq->evq_task = NULL;
        goto pull_one;
    }
    OS_EXIT_CRITICAL(sr);
    9c8a:	f7ff fe4f 	bl	992c <os_arch_restore_sr>

    return (ev);
}
    9c8e:	4620      	mov	r0, r4
    9c90:	bd70      	pop	{r4, r5, r6, pc}

00009c92 <os_eventq_remove>:
 * @param evq The event queue to remove the event from
 * @param ev  The event to remove from the queue
 */
void
os_eventq_remove(struct os_eventq *evq, struct os_event *ev)
{
    9c92:	b538      	push	{r3, r4, r5, lr}
    9c94:	460c      	mov	r4, r1
    9c96:	4605      	mov	r5, r0
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    9c98:	f7ff fe42 	bl	9920 <os_arch_save_sr>
    if (OS_EVENT_QUEUED(ev)) {
    9c9c:	7823      	ldrb	r3, [r4, #0]
    9c9e:	b18b      	cbz	r3, 9cc4 <os_eventq_remove+0x32>
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
    9ca0:	686b      	ldr	r3, [r5, #4]
    9ca2:	42a3      	cmp	r3, r4
    9ca4:	d104      	bne.n	9cb0 <os_eventq_remove+0x1e>
    9ca6:	68a3      	ldr	r3, [r4, #8]
    9ca8:	606b      	str	r3, [r5, #4]
    9caa:	b95b      	cbnz	r3, 9cc4 <os_eventq_remove+0x32>
    9cac:	1d2b      	adds	r3, r5, #4
    9cae:	e008      	b.n	9cc2 <os_eventq_remove+0x30>
    9cb0:	689a      	ldr	r2, [r3, #8]
    9cb2:	42a2      	cmp	r2, r4
    9cb4:	d001      	beq.n	9cba <os_eventq_remove+0x28>
    9cb6:	4613      	mov	r3, r2
    9cb8:	e7fa      	b.n	9cb0 <os_eventq_remove+0x1e>
    9cba:	68a2      	ldr	r2, [r4, #8]
    9cbc:	609a      	str	r2, [r3, #8]
    9cbe:	b90a      	cbnz	r2, 9cc4 <os_eventq_remove+0x32>
    9cc0:	3308      	adds	r3, #8
    9cc2:	60ab      	str	r3, [r5, #8]
    }
    ev->ev_queued = 0;
    9cc4:	2300      	movs	r3, #0
    9cc6:	7023      	strb	r3, [r4, #0]
    OS_EXIT_CRITICAL(sr);
}
    9cc8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    OS_ENTER_CRITICAL(sr);
    if (OS_EVENT_QUEUED(ev)) {
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
    }
    ev->ev_queued = 0;
    OS_EXIT_CRITICAL(sr);
    9ccc:	f7ff be2e 	b.w	992c <os_arch_restore_sr>

00009cd0 <__assert_func>:
}
#endif

void
__assert_func(const char *file, int line, const char *func, const char *e)
{
    9cd0:	b570      	push	{r4, r5, r6, lr}
    9cd2:	460d      	mov	r5, r1
    9cd4:	461c      	mov	r4, r3
    9cd6:	4606      	mov	r6, r0
    int sr;

    OS_ENTER_CRITICAL(sr);
    9cd8:	f7ff fe22 	bl	9920 <os_arch_save_sr>
    (void)sr;
    console_blocking_mode();
    9cdc:	f7ff fd26 	bl	972c <console_blocking_mode>
    console_printf("Assert %s; failed in %s:%d\n", e ? e : "", file, line);
    9ce0:	490a      	ldr	r1, [pc, #40]	; (9d0c <__assert_func+0x3c>)
    9ce2:	480b      	ldr	r0, [pc, #44]	; (9d10 <__assert_func+0x40>)
    9ce4:	2c00      	cmp	r4, #0
    9ce6:	bf18      	it	ne
    9ce8:	4621      	movne	r1, r4
    9cea:	4632      	mov	r2, r6
    9cec:	462b      	mov	r3, r5
    9cee:	f013 ff15 	bl	1db1c <console_printf>
    if (system_debugger_connected()) {
    9cf2:	f013 fc9b 	bl	1d62c <system_debugger_connected>
    9cf6:	b100      	cbz	r0, 9cfa <__assert_func+0x2a>
       /*
        * If debugger is attached, breakpoint before the trap.
        */
       asm("bkpt");
    9cf8:	be00      	bkpt	0x0000
    }
    SCB->ICSR = SCB_ICSR_NMIPENDSET_Msk;
    9cfa:	4b06      	ldr	r3, [pc, #24]	; (9d14 <__assert_func+0x44>)
    9cfc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    9d00:	605a      	str	r2, [r3, #4]
    asm("isb");
    9d02:	f3bf 8f6f 	isb	sy
    system_reset();
    9d06:	f013 fc79 	bl	1d5fc <system_reset>
    9d0a:	bf00      	nop
    9d0c:	0001fded 	.word	0x0001fded
    9d10:	0001f0b7 	.word	0x0001f0b7
    9d14:	e000ed00 	.word	0xe000ed00

00009d18 <os_default_irq>:
    struct coredump_regs regs;
#endif

    console_blocking_mode();
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    9d18:	4d1b      	ldr	r5, [pc, #108]	; (9d88 <os_default_irq+0x70>)
    system_reset();
}

void
os_default_irq(struct trap_frame *tf)
{
    9d1a:	b507      	push	{r0, r1, r2, lr}
    9d1c:	4604      	mov	r4, r0
#ifdef COREDUMP_PRESENT
    struct coredump_regs regs;
#endif

    console_blocking_mode();
    9d1e:	f7ff fd05 	bl	972c <console_blocking_mode>
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    9d22:	6869      	ldr	r1, [r5, #4]
#ifdef COREDUMP_PRESENT
    struct coredump_regs regs;
#endif

    console_blocking_mode();
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
    9d24:	4819      	ldr	r0, [pc, #100]	; (9d8c <os_default_irq+0x74>)
    9d26:	6822      	ldr	r2, [r4, #0]
    9d28:	f3c1 0108 	ubfx	r1, r1, #0, #9
    9d2c:	f013 fef6 	bl	1db1c <console_printf>
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    console_printf(" r0:0x%08lx  r1:0x%08lx  r2:0x%08lx  r3:0x%08lx\n",
      tf->ef->r0, tf->ef->r1, tf->ef->r2, tf->ef->r3);
    9d30:	6823      	ldr	r3, [r4, #0]
#endif

    console_blocking_mode();
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    console_printf(" r0:0x%08lx  r1:0x%08lx  r2:0x%08lx  r3:0x%08lx\n",
    9d32:	4817      	ldr	r0, [pc, #92]	; (9d90 <os_default_irq+0x78>)
    9d34:	68da      	ldr	r2, [r3, #12]
    9d36:	9200      	str	r2, [sp, #0]
    9d38:	cb0e      	ldmia	r3, {r1, r2, r3}
    9d3a:	f013 feef 	bl	1db1c <console_printf>
      tf->ef->r0, tf->ef->r1, tf->ef->r2, tf->ef->r3);
    console_printf(" r4:0x%08lx  r5:0x%08lx  r6:0x%08lx  r7:0x%08lx\n",
    9d3e:	6923      	ldr	r3, [r4, #16]
    9d40:	9300      	str	r3, [sp, #0]
    9d42:	1d21      	adds	r1, r4, #4
    9d44:	c90e      	ldmia	r1, {r1, r2, r3}
    9d46:	4813      	ldr	r0, [pc, #76]	; (9d94 <os_default_irq+0x7c>)
    9d48:	f013 fee8 	bl	1db1c <console_printf>
      tf->r4, tf->r5, tf->r6, tf->r7);
    console_printf(" r8:0x%08lx  r9:0x%08lx r10:0x%08lx r11:0x%08lx\n",
    9d4c:	6a23      	ldr	r3, [r4, #32]
    9d4e:	9300      	str	r3, [sp, #0]
    9d50:	f104 0114 	add.w	r1, r4, #20
    9d54:	c90e      	ldmia	r1, {r1, r2, r3}
    9d56:	4810      	ldr	r0, [pc, #64]	; (9d98 <os_default_irq+0x80>)
    9d58:	f013 fee0 	bl	1db1c <console_printf>
      tf->r8, tf->r9, tf->r10, tf->r11);
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
      tf->ef->r12, tf->ef->lr, tf->ef->pc, tf->ef->psr);
    9d5c:	6823      	ldr	r3, [r4, #0]
      tf->ef->r0, tf->ef->r1, tf->ef->r2, tf->ef->r3);
    console_printf(" r4:0x%08lx  r5:0x%08lx  r6:0x%08lx  r7:0x%08lx\n",
      tf->r4, tf->r5, tf->r6, tf->r7);
    console_printf(" r8:0x%08lx  r9:0x%08lx r10:0x%08lx r11:0x%08lx\n",
      tf->r8, tf->r9, tf->r10, tf->r11);
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
    9d5e:	480f      	ldr	r0, [pc, #60]	; (9d9c <os_default_irq+0x84>)
    9d60:	69da      	ldr	r2, [r3, #28]
    9d62:	9200      	str	r2, [sp, #0]
    9d64:	f103 0110 	add.w	r1, r3, #16
    9d68:	c90e      	ldmia	r1, {r1, r2, r3}
    9d6a:	f013 fed7 	bl	1db1c <console_printf>
      tf->ef->r12, tf->ef->lr, tf->ef->pc, tf->ef->psr);
    console_printf("ICSR:0x%08lx HFSR:0x%08lx CFSR:0x%08lx\n",
    9d6e:	6869      	ldr	r1, [r5, #4]
    9d70:	480b      	ldr	r0, [pc, #44]	; (9da0 <os_default_irq+0x88>)
    9d72:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    9d74:	6aab      	ldr	r3, [r5, #40]	; 0x28
    9d76:	f013 fed1 	bl	1db1c <console_printf>
      SCB->ICSR, SCB->HFSR, SCB->CFSR);
    console_printf("BFAR:0x%08lx MMFAR:0x%08lx\n", SCB->BFAR, SCB->MMFAR);
    9d7a:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    9d7c:	4809      	ldr	r0, [pc, #36]	; (9da4 <os_default_irq+0x8c>)
    9d7e:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    9d80:	f013 fecc 	bl	1db1c <console_printf>

#ifdef COREDUMP_PRESENT
    trap_to_coredump(tf, &regs);
    coredump_dump(&regs, sizeof(regs));
#endif
    system_reset();
    9d84:	f013 fc3a 	bl	1d5fc <system_reset>
    9d88:	e000ed00 	.word	0xe000ed00
    9d8c:	0001f0d3 	.word	0x0001f0d3
    9d90:	0001f104 	.word	0x0001f104
    9d94:	0001f135 	.word	0x0001f135
    9d98:	0001f166 	.word	0x0001f166
    9d9c:	0001f197 	.word	0x0001f197
    9da0:	0001f1c8 	.word	0x0001f1c8
    9da4:	0001f1f0 	.word	0x0001f1f0

00009da8 <_os_mbuf_trailingspace>:
{
    struct os_mbuf_pool *omp;

    omp = om->om_omp;

    return (&om->om_databuf[0] + omp->omp_databuf_len) -
    9da8:	6883      	ldr	r3, [r0, #8]
      (om->om_data + om->om_len);
    9daa:	88c2      	ldrh	r2, [r0, #6]
{
    struct os_mbuf_pool *omp;

    omp = om->om_omp;

    return (&om->om_databuf[0] + omp->omp_databuf_len) -
    9dac:	881b      	ldrh	r3, [r3, #0]
    9dae:	3310      	adds	r3, #16
    9db0:	4403      	add	r3, r0
      (om->om_data + om->om_len);
    9db2:	6800      	ldr	r0, [r0, #0]
    9db4:	4410      	add	r0, r2
{
    struct os_mbuf_pool *omp;

    omp = om->om_omp;

    return (&om->om_databuf[0] + omp->omp_databuf_len) -
    9db6:	1a18      	subs	r0, r3, r0
      (om->om_data + om->om_len);
}
    9db8:	b280      	uxth	r0, r0
    9dba:	4770      	bx	lr

00009dbc <_os_msys_find_pool>:
_os_msys_find_pool(uint16_t dsize)
{
    struct os_mbuf_pool *pool;

    pool = NULL;
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    9dbc:	4a07      	ldr	r2, [pc, #28]	; (9ddc <_os_msys_find_pool+0x20>)
    STAILQ_INIT(&g_msys_pool_list);
}

static struct os_mbuf_pool *
_os_msys_find_pool(uint16_t dsize)
{
    9dbe:	b510      	push	{r4, lr}
    struct os_mbuf_pool *pool;

    pool = NULL;
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    9dc0:	6811      	ldr	r1, [r2, #0]
    9dc2:	460b      	mov	r3, r1
    9dc4:	b123      	cbz	r3, 9dd0 <_os_msys_find_pool+0x14>
        if (dsize <= pool->omp_databuf_len) {
    9dc6:	881c      	ldrh	r4, [r3, #0]
    9dc8:	4284      	cmp	r4, r0
    9dca:	d204      	bcs.n	9dd6 <_os_msys_find_pool+0x1a>
_os_msys_find_pool(uint16_t dsize)
{
    struct os_mbuf_pool *pool;

    pool = NULL;
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    9dcc:	689b      	ldr	r3, [r3, #8]
    9dce:	e7f9      	b.n	9dc4 <_os_msys_find_pool+0x8>
            break;
        }
    }

    if (!pool) {
        pool = STAILQ_LAST(&g_msys_pool_list, os_mbuf_pool, omp_next);
    9dd0:	b109      	cbz	r1, 9dd6 <_os_msys_find_pool+0x1a>
    9dd2:	6853      	ldr	r3, [r2, #4]
    9dd4:	3b08      	subs	r3, #8
    }

    return (pool);
}
    9dd6:	4618      	mov	r0, r3
    9dd8:	bd10      	pop	{r4, pc}
    9dda:	bf00      	nop
    9ddc:	2000021c 	.word	0x2000021c

00009de0 <_os_mbuf_copypkthdr>:
 * @param new_buf The new buffer to copy the packet header into
 * @param old_buf The old buffer to copy the packet header from
 */
static inline void
_os_mbuf_copypkthdr(struct os_mbuf *new_buf, struct os_mbuf *old_buf)
{
    9de0:	b538      	push	{r3, r4, r5, lr}
    assert(new_buf->om_len == 0);
    9de2:	88c3      	ldrh	r3, [r0, #6]
 * @param new_buf The new buffer to copy the packet header into
 * @param old_buf The old buffer to copy the packet header from
 */
static inline void
_os_mbuf_copypkthdr(struct os_mbuf *new_buf, struct os_mbuf *old_buf)
{
    9de4:	4604      	mov	r4, r0
    9de6:	460d      	mov	r5, r1
    assert(new_buf->om_len == 0);
    9de8:	b133      	cbz	r3, 9df8 <_os_mbuf_copypkthdr+0x18>
    9dea:	2200      	movs	r2, #0
    9dec:	4808      	ldr	r0, [pc, #32]	; (9e10 <_os_mbuf_copypkthdr+0x30>)
    9dee:	f240 11a5 	movw	r1, #421	; 0x1a5
    9df2:	4613      	mov	r3, r2
    9df4:	f7ff ff6c 	bl	9cd0 <__assert_func>

    memcpy(&new_buf->om_databuf[0], &old_buf->om_databuf[0],
    9df8:	3010      	adds	r0, #16
    9dfa:	3110      	adds	r1, #16
    9dfc:	796a      	ldrb	r2, [r5, #5]
    9dfe:	f7ff f8fd 	bl	8ffc <memcpy>
           old_buf->om_pkthdr_len);
    new_buf->om_pkthdr_len = old_buf->om_pkthdr_len;
    9e02:	796b      	ldrb	r3, [r5, #5]
    9e04:	7163      	strb	r3, [r4, #5]
    new_buf->om_data = new_buf->om_databuf + old_buf->om_pkthdr_len;
    9e06:	796b      	ldrb	r3, [r5, #5]
    9e08:	3310      	adds	r3, #16
    9e0a:	4423      	add	r3, r4
    9e0c:	6023      	str	r3, [r4, #0]
    9e0e:	bd38      	pop	{r3, r4, r5, pc}
    9e10:	0001f20c 	.word	0x0001f20c

00009e14 <os_mqueue_init>:
 * @return 0 on success, non-zero on failure.
 *
 */
int
os_mqueue_init(struct os_mqueue *mq, void *arg)
{
    9e14:	b570      	push	{r4, r5, r6, lr}
    9e16:	4604      	mov	r4, r0
    struct os_event *ev;

    STAILQ_INIT(&mq->mq_head);
    9e18:	2500      	movs	r5, #0
    9e1a:	6005      	str	r5, [r0, #0]
 * @return 0 on success, non-zero on failure.
 *
 */
int
os_mqueue_init(struct os_mqueue *mq, void *arg)
{
    9e1c:	460e      	mov	r6, r1
    struct os_event *ev;

    STAILQ_INIT(&mq->mq_head);
    9e1e:	6060      	str	r0, [r4, #4]

    ev = &mq->mq_ev;
    memset(ev, 0, sizeof(*ev));
    9e20:	4629      	mov	r1, r5
    9e22:	220c      	movs	r2, #12
    9e24:	3008      	adds	r0, #8
    9e26:	f7ff f8f4 	bl	9012 <memset>
    ev->ev_arg = arg;
    ev->ev_type = OS_EVENT_T_MQUEUE_DATA;
    9e2a:	2302      	movs	r3, #2
    9e2c:	7263      	strb	r3, [r4, #9]

    STAILQ_INIT(&mq->mq_head);

    ev = &mq->mq_ev;
    memset(ev, 0, sizeof(*ev));
    ev->ev_arg = arg;
    9e2e:	60e6      	str	r6, [r4, #12]
    ev->ev_type = OS_EVENT_T_MQUEUE_DATA;

    return (0);
}
    9e30:	4628      	mov	r0, r5
    9e32:	bd70      	pop	{r4, r5, r6, pc}

00009e34 <os_mqueue_get>:
 *
 * @return The next mbuf in the queue, or NULL if queue has no mbufs.
 */
struct os_mbuf *
os_mqueue_get(struct os_mqueue *mq)
{
    9e34:	b538      	push	{r3, r4, r5, lr}
    9e36:	4605      	mov	r5, r0
    struct os_mbuf_pkthdr *mp;
    struct os_mbuf *m;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    9e38:	f7ff fd72 	bl	9920 <os_arch_save_sr>
    mp = STAILQ_FIRST(&mq->mq_head);
    9e3c:	682c      	ldr	r4, [r5, #0]
    if (mp) {
    9e3e:	b11c      	cbz	r4, 9e48 <os_mqueue_get+0x14>
        STAILQ_REMOVE_HEAD(&mq->mq_head, omp_next);
    9e40:	6863      	ldr	r3, [r4, #4]
    9e42:	602b      	str	r3, [r5, #0]
    9e44:	b903      	cbnz	r3, 9e48 <os_mqueue_get+0x14>
    9e46:	606d      	str	r5, [r5, #4]
    }
    OS_EXIT_CRITICAL(sr);
    9e48:	f7ff fd70 	bl	992c <os_arch_restore_sr>

    if (mp) {
    9e4c:	b114      	cbz	r4, 9e54 <os_mqueue_get+0x20>
        m = OS_MBUF_PKTHDR_TO_MBUF(mp);
    9e4e:	f1a4 0010 	sub.w	r0, r4, #16
    9e52:	bd38      	pop	{r3, r4, r5, pc}
    } else {
        m = NULL;
    9e54:	4620      	mov	r0, r4
    }

    return (m);
}
    9e56:	bd38      	pop	{r3, r4, r5, pc}

00009e58 <os_mqueue_put>:
 *
 * @return 0 on success, non-zero on failure.
 */
int
os_mqueue_put(struct os_mqueue *mq, struct os_eventq *evq, struct os_mbuf *m)
{
    9e58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    struct os_mbuf_pkthdr *mp;
    os_sr_t sr;
    int rc;

    /* Can only place the head of a chained mbuf on the queue. */
    if (!OS_MBUF_IS_PKTHDR(m)) {
    9e5a:	7953      	ldrb	r3, [r2, #5]
    9e5c:	2b07      	cmp	r3, #7
 *
 * @return 0 on success, non-zero on failure.
 */
int
os_mqueue_put(struct os_mqueue *mq, struct os_eventq *evq, struct os_mbuf *m)
{
    9e5e:	4606      	mov	r6, r0
    9e60:	460c      	mov	r4, r1
    9e62:	4615      	mov	r5, r2
    struct os_mbuf_pkthdr *mp;
    os_sr_t sr;
    int rc;

    /* Can only place the head of a chained mbuf on the queue. */
    if (!OS_MBUF_IS_PKTHDR(m)) {
    9e64:	d913      	bls.n	9e8e <os_mqueue_put+0x36>
        goto err;
    }

    mp = OS_MBUF_PKTHDR(m);

    OS_ENTER_CRITICAL(sr);
    9e66:	f7ff fd5b 	bl	9920 <os_arch_save_sr>
    STAILQ_INSERT_TAIL(&mq->mq_head, mp, omp_next);
    9e6a:	2700      	movs	r7, #0
    9e6c:	6873      	ldr	r3, [r6, #4]
    9e6e:	616f      	str	r7, [r5, #20]
    if (!OS_MBUF_IS_PKTHDR(m)) {
        rc = OS_EINVAL;
        goto err;
    }

    mp = OS_MBUF_PKTHDR(m);
    9e70:	f105 0210 	add.w	r2, r5, #16

    OS_ENTER_CRITICAL(sr);
    STAILQ_INSERT_TAIL(&mq->mq_head, mp, omp_next);
    9e74:	3514      	adds	r5, #20
    9e76:	601a      	str	r2, [r3, #0]
    9e78:	6075      	str	r5, [r6, #4]
    OS_EXIT_CRITICAL(sr);
    9e7a:	f7ff fd57 	bl	992c <os_arch_restore_sr>

    /* Only post an event to the queue if its specified */
    if (evq) {
        os_eventq_put(evq, &mq->mq_ev);
    9e7e:	4620      	mov	r0, r4
    OS_ENTER_CRITICAL(sr);
    STAILQ_INSERT_TAIL(&mq->mq_head, mp, omp_next);
    OS_EXIT_CRITICAL(sr);

    /* Only post an event to the queue if its specified */
    if (evq) {
    9e80:	b13c      	cbz	r4, 9e92 <os_mqueue_put+0x3a>
        os_eventq_put(evq, &mq->mq_ev);
    9e82:	f106 0108 	add.w	r1, r6, #8
    9e86:	f7ff feb4 	bl	9bf2 <os_eventq_put>
    }

    return (0);
    9e8a:	4638      	mov	r0, r7
    9e8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
err:
    return (rc);
    9e8e:	2002      	movs	r0, #2
    9e90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
}
    9e92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00009e94 <os_msys_register>:
 *
 * @return 0 on success, non-zero on failure
 */
int
os_msys_register(struct os_mbuf_pool *new_pool)
{
    9e94:	b510      	push	{r4, lr}
    struct os_mbuf_pool *pool;

    pool = NULL;
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    9e96:	4a0c      	ldr	r2, [pc, #48]	; (9ec8 <os_msys_register+0x34>)
    9e98:	6813      	ldr	r3, [r2, #0]
    9e9a:	b16b      	cbz	r3, 9eb8 <os_msys_register+0x24>
        if (new_pool->omp_databuf_len > pool->omp_databuf_len) {
    9e9c:	8804      	ldrh	r4, [r0, #0]
    9e9e:	8819      	ldrh	r1, [r3, #0]
    9ea0:	428c      	cmp	r4, r1
    9ea2:	d801      	bhi.n	9ea8 <os_msys_register+0x14>
os_msys_register(struct os_mbuf_pool *new_pool)
{
    struct os_mbuf_pool *pool;

    pool = NULL;
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    9ea4:	689b      	ldr	r3, [r3, #8]
    9ea6:	e7f8      	b.n	9e9a <os_msys_register+0x6>
            break;
        }
    }

    if (pool) {
        STAILQ_INSERT_AFTER(&g_msys_pool_list, pool, new_pool, omp_next);
    9ea8:	6899      	ldr	r1, [r3, #8]
    9eaa:	6081      	str	r1, [r0, #8]
    9eac:	b911      	cbnz	r1, 9eb4 <os_msys_register+0x20>
    9eae:	f100 0108 	add.w	r1, r0, #8
    9eb2:	6051      	str	r1, [r2, #4]
    9eb4:	6098      	str	r0, [r3, #8]
    9eb6:	e004      	b.n	9ec2 <os_msys_register+0x2e>
    } else {
        STAILQ_INSERT_TAIL(&g_msys_pool_list, new_pool, omp_next);
    9eb8:	6083      	str	r3, [r0, #8]
    9eba:	6853      	ldr	r3, [r2, #4]
    9ebc:	6018      	str	r0, [r3, #0]
    9ebe:	3008      	adds	r0, #8
    9ec0:	6050      	str	r0, [r2, #4]
    }

    return (0);
}
    9ec2:	2000      	movs	r0, #0
    9ec4:	bd10      	pop	{r4, pc}
    9ec6:	bf00      	nop
    9ec8:	2000021c 	.word	0x2000021c

00009ecc <os_mbuf_pool_init>:
 */
int
os_mbuf_pool_init(struct os_mbuf_pool *omp, struct os_mempool *mp,
                  uint16_t buf_len, uint16_t nbufs)
{
    omp->omp_databuf_len = buf_len - sizeof(struct os_mbuf);
    9ecc:	3a10      	subs	r2, #16
    9ece:	8002      	strh	r2, [r0, #0]
    omp->omp_mbuf_count = nbufs;
    9ed0:	8043      	strh	r3, [r0, #2]
    omp->omp_pool = mp;
    9ed2:	6041      	str	r1, [r0, #4]

    return (0);
}
    9ed4:	2000      	movs	r0, #0
    9ed6:	4770      	bx	lr

00009ed8 <os_mbuf_get>:
 *
 * @return An initialized mbuf on success, and NULL on failure.
 */
struct os_mbuf *
os_mbuf_get(struct os_mbuf_pool *omp, uint16_t leadingspace)
{
    9ed8:	b538      	push	{r3, r4, r5, lr}
    struct os_mbuf *om;

    if (leadingspace > omp->omp_databuf_len) {
    9eda:	8803      	ldrh	r3, [r0, #0]
    9edc:	428b      	cmp	r3, r1
 *
 * @return An initialized mbuf on success, and NULL on failure.
 */
struct os_mbuf *
os_mbuf_get(struct os_mbuf_pool *omp, uint16_t leadingspace)
{
    9ede:	4605      	mov	r5, r0
    9ee0:	460c      	mov	r4, r1
    struct os_mbuf *om;

    if (leadingspace > omp->omp_databuf_len) {
    9ee2:	d30d      	bcc.n	9f00 <os_mbuf_get+0x28>
        goto err;
    }

    om = os_memblock_get(omp->omp_pool);
    9ee4:	6840      	ldr	r0, [r0, #4]
    9ee6:	f000 fa87 	bl	a3f8 <os_memblock_get>
    9eea:	2300      	movs	r3, #0
    if (!om) {
    9eec:	b148      	cbz	r0, 9f02 <os_mbuf_get+0x2a>

    SLIST_NEXT(om, om_next) = NULL;
    om->om_flags = 0;
    om->om_pkthdr_len = 0;
    om->om_len = 0;
    om->om_data = (&om->om_databuf[0] + leadingspace);
    9eee:	3410      	adds	r4, #16
    9ef0:	4404      	add	r4, r0
    if (!om) {
        goto err;
    }

    SLIST_NEXT(om, om_next) = NULL;
    om->om_flags = 0;
    9ef2:	7103      	strb	r3, [r0, #4]
    om->om_pkthdr_len = 0;
    9ef4:	7143      	strb	r3, [r0, #5]
    om = os_memblock_get(omp->omp_pool);
    if (!om) {
        goto err;
    }

    SLIST_NEXT(om, om_next) = NULL;
    9ef6:	60c3      	str	r3, [r0, #12]
    om->om_flags = 0;
    om->om_pkthdr_len = 0;
    om->om_len = 0;
    9ef8:	80c3      	strh	r3, [r0, #6]
    om->om_data = (&om->om_databuf[0] + leadingspace);
    9efa:	6004      	str	r4, [r0, #0]
    om->om_omp = omp;
    9efc:	6085      	str	r5, [r0, #8]

    return (om);
    9efe:	bd38      	pop	{r3, r4, r5, pc}
err:
    return (NULL);
    9f00:	2000      	movs	r0, #0
}
    9f02:	bd38      	pop	{r3, r4, r5, pc}

00009f04 <os_mbuf_get_pkthdr>:
    struct os_mbuf_pkthdr *pkthdr;
    struct os_mbuf *om;

    /* User packet header must fit inside mbuf */
    pkthdr_len = user_pkthdr_len + sizeof(struct os_mbuf_pkthdr);
    if ((pkthdr_len > omp->omp_databuf_len) || (pkthdr_len > 255)) {
    9f04:	8803      	ldrh	r3, [r0, #0]
 *
 * @return A freshly allocated mbuf on success, NULL on failure.
 */
struct os_mbuf *
os_mbuf_get_pkthdr(struct os_mbuf_pool *omp, uint8_t user_pkthdr_len)
{
    9f06:	b510      	push	{r4, lr}
    uint16_t pkthdr_len;
    struct os_mbuf_pkthdr *pkthdr;
    struct os_mbuf *om;

    /* User packet header must fit inside mbuf */
    pkthdr_len = user_pkthdr_len + sizeof(struct os_mbuf_pkthdr);
    9f08:	f101 0408 	add.w	r4, r1, #8
    if ((pkthdr_len > omp->omp_databuf_len) || (pkthdr_len > 255)) {
    9f0c:	42a3      	cmp	r3, r4
    9f0e:	d30e      	bcc.n	9f2e <os_mbuf_get_pkthdr+0x2a>
    9f10:	2cff      	cmp	r4, #255	; 0xff
    9f12:	d80c      	bhi.n	9f2e <os_mbuf_get_pkthdr+0x2a>
        return NULL;
    }

    om = os_mbuf_get(omp, 0);
    9f14:	2100      	movs	r1, #0
    9f16:	f7ff ffdf 	bl	9ed8 <os_mbuf_get>
    if (om) {
    9f1a:	b148      	cbz	r0, 9f30 <os_mbuf_get_pkthdr+0x2c>
        om->om_pkthdr_len = pkthdr_len;
        om->om_data += pkthdr_len;
    9f1c:	6803      	ldr	r3, [r0, #0]
        return NULL;
    }

    om = os_mbuf_get(omp, 0);
    if (om) {
        om->om_pkthdr_len = pkthdr_len;
    9f1e:	7144      	strb	r4, [r0, #5]
        om->om_data += pkthdr_len;
    9f20:	441c      	add	r4, r3

        pkthdr = OS_MBUF_PKTHDR(om);
        pkthdr->omp_len = 0;
    9f22:	2300      	movs	r3, #0
    }

    om = os_mbuf_get(omp, 0);
    if (om) {
        om->om_pkthdr_len = pkthdr_len;
        om->om_data += pkthdr_len;
    9f24:	6004      	str	r4, [r0, #0]

        pkthdr = OS_MBUF_PKTHDR(om);
        pkthdr->omp_len = 0;
    9f26:	8203      	strh	r3, [r0, #16]
        pkthdr->omp_flags = 0;
    9f28:	8243      	strh	r3, [r0, #18]
        STAILQ_NEXT(pkthdr, omp_next) = NULL;
    9f2a:	6143      	str	r3, [r0, #20]
    9f2c:	bd10      	pop	{r4, pc}
    struct os_mbuf *om;

    /* User packet header must fit inside mbuf */
    pkthdr_len = user_pkthdr_len + sizeof(struct os_mbuf_pkthdr);
    if ((pkthdr_len > omp->omp_databuf_len) || (pkthdr_len > 255)) {
        return NULL;
    9f2e:	2000      	movs	r0, #0
        pkthdr->omp_flags = 0;
        STAILQ_NEXT(pkthdr, omp_next) = NULL;
    }

    return om;
}
    9f30:	bd10      	pop	{r4, pc}

00009f32 <os_msys_get_pkthdr>:
 *
 * @return A freshly allocated mbuf on success, NULL on failure.
 */
struct os_mbuf *
os_msys_get_pkthdr(uint16_t dsize, uint16_t user_hdr_len)
{
    9f32:	3008      	adds	r0, #8
    uint16_t total_pkthdr_len;
    struct os_mbuf *m;
    struct os_mbuf_pool *pool;

    total_pkthdr_len =  user_hdr_len + sizeof(struct os_mbuf_pkthdr);
    pool = _os_msys_find_pool(dsize + total_pkthdr_len);
    9f34:	4408      	add	r0, r1
 *
 * @return A freshly allocated mbuf on success, NULL on failure.
 */
struct os_mbuf *
os_msys_get_pkthdr(uint16_t dsize, uint16_t user_hdr_len)
{
    9f36:	b510      	push	{r4, lr}
    uint16_t total_pkthdr_len;
    struct os_mbuf *m;
    struct os_mbuf_pool *pool;

    total_pkthdr_len =  user_hdr_len + sizeof(struct os_mbuf_pkthdr);
    pool = _os_msys_find_pool(dsize + total_pkthdr_len);
    9f38:	b280      	uxth	r0, r0
 *
 * @return A freshly allocated mbuf on success, NULL on failure.
 */
struct os_mbuf *
os_msys_get_pkthdr(uint16_t dsize, uint16_t user_hdr_len)
{
    9f3a:	460c      	mov	r4, r1
    uint16_t total_pkthdr_len;
    struct os_mbuf *m;
    struct os_mbuf_pool *pool;

    total_pkthdr_len =  user_hdr_len + sizeof(struct os_mbuf_pkthdr);
    pool = _os_msys_find_pool(dsize + total_pkthdr_len);
    9f3c:	f7ff ff3e 	bl	9dbc <_os_msys_find_pool>
    if (!pool) {
    9f40:	b120      	cbz	r0, 9f4c <os_msys_get_pkthdr+0x1a>
        goto err;
    }

    m = os_mbuf_get_pkthdr(pool, user_hdr_len);
    9f42:	b2e1      	uxtb	r1, r4
    return (m);
err:
    return (NULL);
}
    9f44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    pool = _os_msys_find_pool(dsize + total_pkthdr_len);
    if (!pool) {
        goto err;
    }

    m = os_mbuf_get_pkthdr(pool, user_hdr_len);
    9f48:	f7ff bfdc 	b.w	9f04 <os_mbuf_get_pkthdr>
    return (m);
err:
    return (NULL);
}
    9f4c:	bd10      	pop	{r4, pc}

00009f4e <os_mbuf_free>:
 *
 * @return 0 on success, -1 on failure
 */
int
os_mbuf_free(struct os_mbuf *om)
{
    9f4e:	4601      	mov	r1, r0
    int rc;

    if (om->om_omp != NULL) {
    9f50:	6880      	ldr	r0, [r0, #8]
 *
 * @return 0 on success, -1 on failure
 */
int
os_mbuf_free(struct os_mbuf *om)
{
    9f52:	b508      	push	{r3, lr}
    int rc;

    if (om->om_omp != NULL) {
    9f54:	b110      	cbz	r0, 9f5c <os_mbuf_free+0xe>
        rc = os_memblock_put(om->om_omp->omp_pool, om);
    9f56:	6840      	ldr	r0, [r0, #4]
    9f58:	f000 fa62 	bl	a420 <os_memblock_put>
    }

    return (0);
err:
    return (rc);
}
    9f5c:	bd08      	pop	{r3, pc}

00009f5e <os_mbuf_free_chain>:
 *
 * @return 0 on success, -1 on failure
 */
int
os_mbuf_free_chain(struct os_mbuf *om)
{
    9f5e:	b510      	push	{r4, lr}
    struct os_mbuf *next;
    int rc;

    while (om != NULL) {
    9f60:	b128      	cbz	r0, 9f6e <os_mbuf_free_chain+0x10>
        next = SLIST_NEXT(om, om_next);
    9f62:	68c4      	ldr	r4, [r0, #12]

        rc = os_mbuf_free(om);
    9f64:	f7ff fff3 	bl	9f4e <os_mbuf_free>
        if (rc != 0) {
    9f68:	b908      	cbnz	r0, 9f6e <os_mbuf_free_chain+0x10>
            goto err;
        }

        om = next;
    9f6a:	4620      	mov	r0, r4
    9f6c:	e7f8      	b.n	9f60 <os_mbuf_free_chain+0x2>
    }

    return (0);
err:
    return (rc);
}
    9f6e:	bd10      	pop	{r4, pc}

00009f70 <os_mbuf_append>:
 *
 * @return 0 on success, and an error code on failure
 */
int
os_mbuf_append(struct os_mbuf *om, const void *data,  uint16_t len)
{
    9f70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9f74:	460f      	mov	r7, r1
    9f76:	4690      	mov	r8, r2
    struct os_mbuf *new;
    int remainder;
    int space;
    int rc;

    if (om == NULL) {
    9f78:	4606      	mov	r6, r0
    9f7a:	2800      	cmp	r0, #0
    9f7c:	d044      	beq.n	a008 <os_mbuf_append+0x98>
        rc = OS_EINVAL;
        goto err;
    }

    omp = om->om_omp;
    9f7e:	f8d0 9008 	ldr.w	r9, [r0, #8]

    /* Scroll to last mbuf in the chain */
    last = om;
    while (SLIST_NEXT(last, om_next) != NULL) {
    9f82:	4605      	mov	r5, r0
    9f84:	68eb      	ldr	r3, [r5, #12]
    9f86:	b10b      	cbz	r3, 9f8c <os_mbuf_append+0x1c>
    9f88:	461d      	mov	r5, r3
    9f8a:	e7fb      	b.n	9f84 <os_mbuf_append+0x14>
        last = SLIST_NEXT(last, om_next);
    }

    remainder = len;
    space = OS_MBUF_TRAILINGSPACE(last);
    9f8c:	4628      	mov	r0, r5
    last = om;
    while (SLIST_NEXT(last, om_next) != NULL) {
        last = SLIST_NEXT(last, om_next);
    }

    remainder = len;
    9f8e:	4644      	mov	r4, r8
    space = OS_MBUF_TRAILINGSPACE(last);
    9f90:	f7ff ff0a 	bl	9da8 <_os_mbuf_trailingspace>

    /* If room in current mbuf, copy the first part of the data into the
     * remaining space in that mbuf.
     */
    if (space > 0) {
    9f94:	b340      	cbz	r0, 9fe8 <os_mbuf_append+0x78>
    9f96:	4540      	cmp	r0, r8
    9f98:	bfa8      	it	ge
    9f9a:	4640      	movge	r0, r8
    9f9c:	4604      	mov	r4, r0
        if (space > remainder) {
            space = remainder;
        }

        memcpy(OS_MBUF_DATA(last, uint8_t *) + last->om_len , data, space);
    9f9e:	88eb      	ldrh	r3, [r5, #6]
    9fa0:	6828      	ldr	r0, [r5, #0]
    9fa2:	4639      	mov	r1, r7
    9fa4:	4418      	add	r0, r3
    9fa6:	4622      	mov	r2, r4
    9fa8:	f7ff f828 	bl	8ffc <memcpy>

        last->om_len += space;
    9fac:	88eb      	ldrh	r3, [r5, #6]
    9fae:	4423      	add	r3, r4
        data += space;
    9fb0:	4427      	add	r7, r4
            space = remainder;
        }

        memcpy(OS_MBUF_DATA(last, uint8_t *) + last->om_len , data, space);

        last->om_len += space;
    9fb2:	80eb      	strh	r3, [r5, #6]
        data += space;
        remainder -= space;
    9fb4:	ebc4 0408 	rsb	r4, r4, r8
    9fb8:	e016      	b.n	9fe8 <os_mbuf_append+0x78>

    /* Take the remaining data, and keep allocating new mbufs and copying
     * data into it, until data is exhausted.
     */
    while (remainder > 0) {
        new = os_mbuf_get(omp, 0);
    9fba:	4648      	mov	r0, r9
    9fbc:	2100      	movs	r1, #0
    9fbe:	f7ff ff8b 	bl	9ed8 <os_mbuf_get>
        if (!new) {
    9fc2:	4682      	mov	sl, r0
    9fc4:	b190      	cbz	r0, 9fec <os_mbuf_append+0x7c>
            break;
        }

        new->om_len = min(omp->omp_databuf_len, remainder);
    9fc6:	f8b9 2000 	ldrh.w	r2, [r9]
    9fca:	42a2      	cmp	r2, r4
    9fcc:	bfa8      	it	ge
    9fce:	4622      	movge	r2, r4
    9fd0:	80c2      	strh	r2, [r0, #6]
        memcpy(OS_MBUF_DATA(new, void *), data, new->om_len);
    9fd2:	4639      	mov	r1, r7
    9fd4:	6800      	ldr	r0, [r0, #0]
    9fd6:	f7ff f811 	bl	8ffc <memcpy>
        data += new->om_len;
    9fda:	f8ba 3006 	ldrh.w	r3, [sl, #6]
        remainder -= new->om_len;
        SLIST_NEXT(last, om_next) = new;
    9fde:	f8c5 a00c 	str.w	sl, [r5, #12]
            break;
        }

        new->om_len = min(omp->omp_databuf_len, remainder);
        memcpy(OS_MBUF_DATA(new, void *), data, new->om_len);
        data += new->om_len;
    9fe2:	441f      	add	r7, r3
        remainder -= new->om_len;
    9fe4:	1ae4      	subs	r4, r4, r3
        SLIST_NEXT(last, om_next) = new;
    9fe6:	4655      	mov	r5, sl
    }

    /* Take the remaining data, and keep allocating new mbufs and copying
     * data into it, until data is exhausted.
     */
    while (remainder > 0) {
    9fe8:	2c00      	cmp	r4, #0
    9fea:	dce6      	bgt.n	9fba <os_mbuf_append+0x4a>
        SLIST_NEXT(last, om_next) = new;
        last = new;
    }

    /* Adjust the packet header length in the buffer */
    if (OS_MBUF_IS_PKTHDR(om)) {
    9fec:	7973      	ldrb	r3, [r6, #5]
    9fee:	2b07      	cmp	r3, #7
    9ff0:	d905      	bls.n	9ffe <os_mbuf_append+0x8e>
    9ff2:	8a33      	ldrh	r3, [r6, #16]
    9ff4:	4498      	add	r8, r3
        OS_MBUF_PKTHDR(om)->omp_len += len - remainder;
    9ff6:	ebc4 0808 	rsb	r8, r4, r8
    9ffa:	f8a6 8010 	strh.w	r8, [r6, #16]
    }

    if (remainder != 0) {
    9ffe:	1c20      	adds	r0, r4, #0
    a000:	bf18      	it	ne
    a002:	2001      	movne	r0, #1
    a004:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    int remainder;
    int space;
    int rc;

    if (om == NULL) {
        rc = OS_EINVAL;
    a008:	2002      	movs	r0, #2


    return (0);
err:
    return (rc);
}
    a00a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000a00e <os_mbuf_off>:
 *                                  success.
 *                              NULL if the specified offset is out of bounds.
 */
struct os_mbuf *
os_mbuf_off(const struct os_mbuf *om, int off, int *out_off)
{
    a00e:	b510      	push	{r4, lr}

    /* Cast away const. */
    cur = (struct os_mbuf *)om;

    while (1) {
        if (cur == NULL) {
    a010:	b150      	cbz	r0, a028 <os_mbuf_off+0x1a>
            return NULL;
        }

        next = SLIST_NEXT(cur, om_next);

        if (cur->om_len > off ||
    a012:	88c4      	ldrh	r4, [r0, #6]
    while (1) {
        if (cur == NULL) {
            return NULL;
        }

        next = SLIST_NEXT(cur, om_next);
    a014:	68c3      	ldr	r3, [r0, #12]

        if (cur->om_len > off ||
    a016:	428c      	cmp	r4, r1
    a018:	dc01      	bgt.n	a01e <os_mbuf_off+0x10>
    a01a:	d102      	bne.n	a022 <os_mbuf_off+0x14>
            (cur->om_len == off && next == NULL)) {
    a01c:	b90b      	cbnz	r3, a022 <os_mbuf_off+0x14>

            *out_off = off;
    a01e:	6011      	str	r1, [r2, #0]
            return cur;
    a020:	bd10      	pop	{r4, pc}
        }

        off -= cur->om_len;
    a022:	1b09      	subs	r1, r1, r4
    while (1) {
        if (cur == NULL) {
            return NULL;
        }

        next = SLIST_NEXT(cur, om_next);
    a024:	4618      	mov	r0, r3
            return cur;
        }

        off -= cur->om_len;
        cur = next;
    }
    a026:	e7f3      	b.n	a010 <os_mbuf_off+0x2>
}
    a028:	bd10      	pop	{r4, pc}

0000a02a <os_mbuf_appendfrom>:
 * @param len                   The number of bytes to append.
 */
int
os_mbuf_appendfrom(struct os_mbuf *dst, const struct os_mbuf *src,
                   uint16_t src_off, uint16_t len)
{
    a02a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a02c:	4606      	mov	r6, r0
    const struct os_mbuf *src_cur_om;
    uint16_t chunk_sz;
    int src_cur_off;
    int rc;

    src_cur_om = os_mbuf_off(src, src_off, &src_cur_off);
    a02e:	4608      	mov	r0, r1
    a030:	4611      	mov	r1, r2
    a032:	aa01      	add	r2, sp, #4
 * @param len                   The number of bytes to append.
 */
int
os_mbuf_appendfrom(struct os_mbuf *dst, const struct os_mbuf *src,
                   uint16_t src_off, uint16_t len)
{
    a034:	461d      	mov	r5, r3
    const struct os_mbuf *src_cur_om;
    uint16_t chunk_sz;
    int src_cur_off;
    int rc;

    src_cur_om = os_mbuf_off(src, src_off, &src_cur_off);
    a036:	f7ff ffea 	bl	a00e <os_mbuf_off>
    if (src_cur_om == NULL) {
    a03a:	4607      	mov	r7, r0
    a03c:	b1a8      	cbz	r0, a06a <os_mbuf_appendfrom+0x40>
        return OS_EINVAL;
    }

    while (len > 0) {
    a03e:	b195      	cbz	r5, a066 <os_mbuf_appendfrom+0x3c>
        chunk_sz = min(len, src_cur_om->om_len - src_cur_off);
    a040:	9b01      	ldr	r3, [sp, #4]
    a042:	88fc      	ldrh	r4, [r7, #6]
        rc = os_mbuf_append(dst, src_cur_om->om_data + src_cur_off, chunk_sz);
    a044:	6839      	ldr	r1, [r7, #0]
    if (src_cur_om == NULL) {
        return OS_EINVAL;
    }

    while (len > 0) {
        chunk_sz = min(len, src_cur_om->om_len - src_cur_off);
    a046:	1ae4      	subs	r4, r4, r3
    a048:	42ac      	cmp	r4, r5
    a04a:	bfa8      	it	ge
    a04c:	462c      	movge	r4, r5
    a04e:	b2a4      	uxth	r4, r4
        rc = os_mbuf_append(dst, src_cur_om->om_data + src_cur_off, chunk_sz);
    a050:	4630      	mov	r0, r6
    a052:	4419      	add	r1, r3
    a054:	4622      	mov	r2, r4
    a056:	f7ff ff8b 	bl	9f70 <os_mbuf_append>
        if (rc != 0) {
    a05a:	b938      	cbnz	r0, a06c <os_mbuf_appendfrom+0x42>
            return rc;
        }

        len -= chunk_sz;
    a05c:	1b2d      	subs	r5, r5, r4
    a05e:	b2ad      	uxth	r5, r5
        src_cur_om = SLIST_NEXT(src_cur_om, om_next);
    a060:	68ff      	ldr	r7, [r7, #12]
        src_cur_off = 0;
    a062:	9001      	str	r0, [sp, #4]
    a064:	e7eb      	b.n	a03e <os_mbuf_appendfrom+0x14>
    }

    return 0;
    a066:	4628      	mov	r0, r5
    a068:	e000      	b.n	a06c <os_mbuf_appendfrom+0x42>
    int src_cur_off;
    int rc;

    src_cur_om = os_mbuf_off(src, src_off, &src_cur_off);
    if (src_cur_om == NULL) {
        return OS_EINVAL;
    a06a:	2002      	movs	r0, #2
        src_cur_om = SLIST_NEXT(src_cur_om, om_next);
        src_cur_off = 0;
    }

    return 0;
}
    a06c:	b003      	add	sp, #12
    a06e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000a070 <os_mbuf_copydata>:
 * @return                      0 on success;
 *                              -1 if the mbuf does not contain enough data.
 */
int
os_mbuf_copydata(const struct os_mbuf *m, int off, int len, void *dst)
{
    a070:	b570      	push	{r4, r5, r6, lr}
    a072:	4604      	mov	r4, r0
    unsigned int count;
    uint8_t *udst;

    if (!len) {
    a074:	4616      	mov	r6, r2
    a076:	b93a      	cbnz	r2, a088 <os_mbuf_copydata+0x18>
        return 0;
    a078:	2000      	movs	r0, #0
    a07a:	bd70      	pop	{r4, r5, r6, pc}
    }

    udst = dst;

    while (off > 0) {
        if (!m) {
    a07c:	b13c      	cbz	r4, a08e <os_mbuf_copydata+0x1e>
            return (-1);
        }

        if (off < m->om_len)
    a07e:	88e2      	ldrh	r2, [r4, #6]
    a080:	4291      	cmp	r1, r2
    a082:	db19      	blt.n	a0b8 <os_mbuf_copydata+0x48>
            break;
        off -= m->om_len;
        m = SLIST_NEXT(m, om_next);
    a084:	68e4      	ldr	r4, [r4, #12]
            return (-1);
        }

        if (off < m->om_len)
            break;
        off -= m->om_len;
    a086:	1a89      	subs	r1, r1, r2
        return 0;
    }

    udst = dst;

    while (off > 0) {
    a088:	2900      	cmp	r1, #0
    a08a:	dcf7      	bgt.n	a07c <os_mbuf_copydata+0xc>
    a08c:	e014      	b.n	a0b8 <os_mbuf_copydata+0x48>
        if (!m) {
            return (-1);
    a08e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a092:	bd70      	pop	{r4, r5, r6, pc}
        if (off < m->om_len)
            break;
        off -= m->om_len;
        m = SLIST_NEXT(m, om_next);
    }
    while (len > 0 && m != NULL) {
    a094:	2c00      	cmp	r4, #0
    a096:	d0fa      	beq.n	a08e <os_mbuf_copydata+0x1e>
        count = min(m->om_len - off, len);
    a098:	88e5      	ldrh	r5, [r4, #6]
        memcpy(udst, m->om_data + off, count);
    a09a:	6822      	ldr	r2, [r4, #0]
            break;
        off -= m->om_len;
        m = SLIST_NEXT(m, om_next);
    }
    while (len > 0 && m != NULL) {
        count = min(m->om_len - off, len);
    a09c:	1a6d      	subs	r5, r5, r1
    a09e:	42b5      	cmp	r5, r6
    a0a0:	bfa8      	it	ge
    a0a2:	4635      	movge	r5, r6
        memcpy(udst, m->om_data + off, count);
    a0a4:	4411      	add	r1, r2
    a0a6:	4618      	mov	r0, r3
    a0a8:	462a      	mov	r2, r5
    a0aa:	f7fe ffa7 	bl	8ffc <memcpy>
        len -= count;
        udst += count;
        off = 0;
        m = SLIST_NEXT(m, om_next);
    a0ae:	68e4      	ldr	r4, [r4, #12]
        off -= m->om_len;
        m = SLIST_NEXT(m, om_next);
    }
    while (len > 0 && m != NULL) {
        count = min(m->om_len - off, len);
        memcpy(udst, m->om_data + off, count);
    a0b0:	4603      	mov	r3, r0
        len -= count;
    a0b2:	1b76      	subs	r6, r6, r5
        udst += count;
    a0b4:	442b      	add	r3, r5
        off = 0;
    a0b6:	2100      	movs	r1, #0
        if (off < m->om_len)
            break;
        off -= m->om_len;
        m = SLIST_NEXT(m, om_next);
    }
    while (len > 0 && m != NULL) {
    a0b8:	2e00      	cmp	r6, #0
    a0ba:	dceb      	bgt.n	a094 <os_mbuf_copydata+0x24>
    a0bc:	e7dc      	b.n	a078 <os_mbuf_copydata+0x8>

0000a0be <os_mbuf_adj>:
 *                from the head of the mbuf, if negative, trims from the
 *                tail of the mbuf.
 */
void
os_mbuf_adj(struct os_mbuf *mp, int req_len)
{
    a0be:	b570      	push	{r4, r5, r6, lr}
    int len = req_len;
    struct os_mbuf *m;
    int count;

    if ((m = mp) == NULL)
    a0c0:	4604      	mov	r4, r0
    a0c2:	2800      	cmp	r0, #0
    a0c4:	d045      	beq.n	a152 <os_mbuf_adj+0x94>
        return;
    if (len >= 0) {
    a0c6:	2900      	cmp	r1, #0
    a0c8:	db1a      	blt.n	a100 <os_mbuf_adj+0x42>
    a0ca:	4602      	mov	r2, r0
    a0cc:	460b      	mov	r3, r1
        /*
         * Trim from head.
         */
        while (m != NULL && len > 0) {
    a0ce:	2b00      	cmp	r3, #0
    a0d0:	dd0f      	ble.n	a0f2 <os_mbuf_adj+0x34>
            if (m->om_len <= len) {
    a0d2:	88d0      	ldrh	r0, [r2, #6]
    a0d4:	4298      	cmp	r0, r3
    a0d6:	dc06      	bgt.n	a0e6 <os_mbuf_adj+0x28>
                len -= m->om_len;
    a0d8:	1a1b      	subs	r3, r3, r0
                m->om_len = 0;
    a0da:	2000      	movs	r0, #0
    a0dc:	80d0      	strh	r0, [r2, #6]
                m = SLIST_NEXT(m, om_next);
    a0de:	68d2      	ldr	r2, [r2, #12]
        return;
    if (len >= 0) {
        /*
         * Trim from head.
         */
        while (m != NULL && len > 0) {
    a0e0:	2a00      	cmp	r2, #0
    a0e2:	d1f4      	bne.n	a0ce <os_mbuf_adj+0x10>
    a0e4:	e005      	b.n	a0f2 <os_mbuf_adj+0x34>
            if (m->om_len <= len) {
                len -= m->om_len;
                m->om_len = 0;
                m = SLIST_NEXT(m, om_next);
            } else {
                m->om_len -= len;
    a0e6:	1ac0      	subs	r0, r0, r3
    a0e8:	80d0      	strh	r0, [r2, #6]
                m->om_data += len;
    a0ea:	6810      	ldr	r0, [r2, #0]
    a0ec:	4403      	add	r3, r0
    a0ee:	6013      	str	r3, [r2, #0]
                len = 0;
    a0f0:	2300      	movs	r3, #0
            }
        }
        if (OS_MBUF_IS_PKTHDR(mp))
    a0f2:	7962      	ldrb	r2, [r4, #5]
    a0f4:	2a07      	cmp	r2, #7
    a0f6:	d92c      	bls.n	a152 <os_mbuf_adj+0x94>
    a0f8:	8a22      	ldrh	r2, [r4, #16]
    a0fa:	1a51      	subs	r1, r2, r1
            OS_MBUF_PKTHDR(mp)->omp_len -= (req_len - len);
    a0fc:	440b      	add	r3, r1
    a0fe:	e011      	b.n	a124 <os_mbuf_adj+0x66>
         * calculating its length and finding the last mbuf.
         * If the adjustment only affects this mbuf, then just
         * adjust and return.  Otherwise, rescan and truncate
         * after the remaining size.
         */
        len = -len;
    a100:	424b      	negs	r3, r1
        count = 0;
    a102:	2500      	movs	r5, #0
        for (;;) {
            count += m->om_len;
    a104:	88c2      	ldrh	r2, [r0, #6]
            if (SLIST_NEXT(m, om_next) == (struct os_mbuf *)0)
    a106:	68c6      	ldr	r6, [r0, #12]
         * after the remaining size.
         */
        len = -len;
        count = 0;
        for (;;) {
            count += m->om_len;
    a108:	4415      	add	r5, r2
            if (SLIST_NEXT(m, om_next) == (struct os_mbuf *)0)
    a10a:	b10e      	cbz	r6, a110 <os_mbuf_adj+0x52>
    a10c:	4630      	mov	r0, r6
    a10e:	e7f9      	b.n	a104 <os_mbuf_adj+0x46>
                break;
            m = SLIST_NEXT(m, om_next);
        }
        if (m->om_len >= len) {
    a110:	429a      	cmp	r2, r3
    a112:	7966      	ldrb	r6, [r4, #5]
    a114:	db08      	blt.n	a128 <os_mbuf_adj+0x6a>
            m->om_len -= len;
    a116:	b29b      	uxth	r3, r3
    a118:	1ad2      	subs	r2, r2, r3
            if (OS_MBUF_IS_PKTHDR(mp))
    a11a:	2e07      	cmp	r6, #7
            if (SLIST_NEXT(m, om_next) == (struct os_mbuf *)0)
                break;
            m = SLIST_NEXT(m, om_next);
        }
        if (m->om_len >= len) {
            m->om_len -= len;
    a11c:	80c2      	strh	r2, [r0, #6]
            if (OS_MBUF_IS_PKTHDR(mp))
    a11e:	d918      	bls.n	a152 <os_mbuf_adj+0x94>
                OS_MBUF_PKTHDR(mp)->omp_len -= len;
    a120:	8a22      	ldrh	r2, [r4, #16]
    a122:	1ad3      	subs	r3, r2, r3
    a124:	8223      	strh	r3, [r4, #16]
    a126:	bd70      	pop	{r4, r5, r6, pc}
            return;
        }
        count -= len;
    a128:	4429      	add	r1, r5
    a12a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
         * Correct length for chain is "count".
         * Find the mbuf with last data, adjust its length,
         * and toss data from remaining mbufs on chain.
         */
        m = mp;
        if (OS_MBUF_IS_PKTHDR(m))
    a12e:	2e07      	cmp	r6, #7
            OS_MBUF_PKTHDR(m)->omp_len = count;
    a130:	bf88      	it	hi
    a132:	8221      	strhhi	r1, [r4, #16]
        for (; m; m = SLIST_NEXT(m, om_next)) {
            if (m->om_len >= count) {
    a134:	88e3      	ldrh	r3, [r4, #6]
    a136:	428b      	cmp	r3, r1
    a138:	db07      	blt.n	a14a <os_mbuf_adj+0x8c>
                m->om_len = count;
                if (SLIST_NEXT(m, om_next) != NULL) {
    a13a:	68e0      	ldr	r0, [r4, #12]
        m = mp;
        if (OS_MBUF_IS_PKTHDR(m))
            OS_MBUF_PKTHDR(m)->omp_len = count;
        for (; m; m = SLIST_NEXT(m, om_next)) {
            if (m->om_len >= count) {
                m->om_len = count;
    a13c:	80e1      	strh	r1, [r4, #6]
                if (SLIST_NEXT(m, om_next) != NULL) {
    a13e:	b140      	cbz	r0, a152 <os_mbuf_adj+0x94>
                    os_mbuf_free_chain(SLIST_NEXT(m, om_next));
    a140:	f7ff ff0d 	bl	9f5e <os_mbuf_free_chain>
                    SLIST_NEXT(m, om_next) = NULL;
    a144:	2300      	movs	r3, #0
    a146:	60e3      	str	r3, [r4, #12]
    a148:	bd70      	pop	{r4, r5, r6, pc}
         * and toss data from remaining mbufs on chain.
         */
        m = mp;
        if (OS_MBUF_IS_PKTHDR(m))
            OS_MBUF_PKTHDR(m)->omp_len = count;
        for (; m; m = SLIST_NEXT(m, om_next)) {
    a14a:	68e4      	ldr	r4, [r4, #12]
                    os_mbuf_free_chain(SLIST_NEXT(m, om_next));
                    SLIST_NEXT(m, om_next) = NULL;
                }
                break;
            }
            count -= m->om_len;
    a14c:	1ac9      	subs	r1, r1, r3
         * and toss data from remaining mbufs on chain.
         */
        m = mp;
        if (OS_MBUF_IS_PKTHDR(m))
            OS_MBUF_PKTHDR(m)->omp_len = count;
        for (; m; m = SLIST_NEXT(m, om_next)) {
    a14e:	2c00      	cmp	r4, #0
    a150:	d1f0      	bne.n	a134 <os_mbuf_adj+0x76>
    a152:	bd70      	pop	{r4, r5, r6, pc}

0000a154 <os_mbuf_memcmp>:
 *                              A memcmp return code if there is a mismatch;
 *                              -1 if the mbuf is too short.
 */
int
os_mbuf_memcmp(const struct os_mbuf *om, int off, const void *data, int len)
{
    a154:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    int chunk_sz;
    int data_off;
    int om_off;
    int rc;

    if (len <= 0) {
    a158:	1e1f      	subs	r7, r3, #0
 *                              A memcmp return code if there is a mismatch;
 *                              -1 if the mbuf is too short.
 */
int
os_mbuf_memcmp(const struct os_mbuf *om, int off, const void *data, int len)
{
    a15a:	4690      	mov	r8, r2
    int chunk_sz;
    int data_off;
    int om_off;
    int rc;

    if (len <= 0) {
    a15c:	dc01      	bgt.n	a162 <os_mbuf_memcmp+0xe>
        return 0;
    a15e:	2000      	movs	r0, #0
    a160:	e022      	b.n	a1a8 <os_mbuf_memcmp+0x54>
    }

    data_off = 0;
    om = os_mbuf_off((struct os_mbuf *)om, off, &om_off);
    a162:	aa01      	add	r2, sp, #4
    a164:	f7ff ff53 	bl	a00e <os_mbuf_off>

    if (len <= 0) {
        return 0;
    }

    data_off = 0;
    a168:	2600      	movs	r6, #0
    om = os_mbuf_off((struct os_mbuf *)om, off, &om_off);
    a16a:	4605      	mov	r5, r0
    while (1) {
        if (om == NULL) {
    a16c:	b915      	cbnz	r5, a174 <os_mbuf_memcmp+0x20>
            return -1;
    a16e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a172:	e019      	b.n	a1a8 <os_mbuf_memcmp+0x54>
        }

        chunk_sz = min(om->om_len - om_off, len - data_off);
    a174:	9a01      	ldr	r2, [sp, #4]
    a176:	88eb      	ldrh	r3, [r5, #6]
    a178:	1bbc      	subs	r4, r7, r6
    a17a:	1a9b      	subs	r3, r3, r2
    a17c:	429c      	cmp	r4, r3
    a17e:	bfa8      	it	ge
    a180:	461c      	movge	r4, r3
        if (chunk_sz > 0) {
    a182:	2c00      	cmp	r4, #0
    a184:	dd07      	ble.n	a196 <os_mbuf_memcmp+0x42>
            rc = memcmp(om->om_data + om_off, data + data_off, chunk_sz);
    a186:	6828      	ldr	r0, [r5, #0]
    a188:	eb08 0106 	add.w	r1, r8, r6
    a18c:	4410      	add	r0, r2
    a18e:	4622      	mov	r2, r4
    a190:	f7fe ff26 	bl	8fe0 <memcmp>
            if (rc != 0) {
    a194:	b940      	cbnz	r0, a1a8 <os_mbuf_memcmp+0x54>
                return rc;
            }
        }

        data_off += chunk_sz;
    a196:	4426      	add	r6, r4
        if (data_off == len) {
    a198:	42be      	cmp	r6, r7
    a19a:	d0e0      	beq.n	a15e <os_mbuf_memcmp+0xa>
            return 0;
        }

        om = SLIST_NEXT(om, om_next);
    a19c:	68ed      	ldr	r5, [r5, #12]
        om_off = 0;
    a19e:	2300      	movs	r3, #0
    a1a0:	9301      	str	r3, [sp, #4]

        if (om == NULL) {
    a1a2:	2d00      	cmp	r5, #0
    a1a4:	d1e2      	bne.n	a16c <os_mbuf_memcmp+0x18>
    a1a6:	e7e2      	b.n	a16e <os_mbuf_memcmp+0x1a>
            return -1;
        }
    }
}
    a1a8:	b002      	add	sp, #8
    a1aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000a1ae <os_mbuf_prepend>:
 * @return                      The new head of the chain on success;
 *                              NULL on failure.
 */
struct os_mbuf *
os_mbuf_prepend(struct os_mbuf *om, int len)
{
    a1ae:	b570      	push	{r4, r5, r6, lr}
    a1b0:	4604      	mov	r4, r0
    a1b2:	460d      	mov	r5, r1
{
    uint16_t startoff;
    uint16_t leadingspace;

    startoff = 0;
    if (OS_MBUF_IS_PKTHDR(om)) {
    a1b4:	7961      	ldrb	r1, [r4, #5]
        startoff = om->om_pkthdr_len;
    }

    leadingspace = (uint16_t) (OS_MBUF_DATA(om, uint8_t *) - 
    a1b6:	6822      	ldr	r2, [r4, #0]
         * needed.
         */
        leading = min(len, OS_MBUF_LEADINGSPACE(om));

        om->om_data -= leading;
        om->om_len += leading;
    a1b8:	88e0      	ldrh	r0, [r4, #6]
{
    uint16_t startoff;
    uint16_t leadingspace;

    startoff = 0;
    if (OS_MBUF_IS_PKTHDR(om)) {
    a1ba:	2907      	cmp	r1, #7
        startoff = om->om_pkthdr_len;
    a1bc:	bf8c      	ite	hi
    a1be:	b28b      	uxthhi	r3, r1
_os_mbuf_leadingspace(struct os_mbuf *om)
{
    uint16_t startoff;
    uint16_t leadingspace;

    startoff = 0;
    a1c0:	2300      	movls	r3, #0
    if (OS_MBUF_IS_PKTHDR(om)) {
        startoff = om->om_pkthdr_len;
    }

    leadingspace = (uint16_t) (OS_MBUF_DATA(om, uint8_t *) - 
        ((uint8_t *) &om->om_databuf[0] + startoff));
    a1c2:	3310      	adds	r3, #16
    a1c4:	4423      	add	r3, r4
    startoff = 0;
    if (OS_MBUF_IS_PKTHDR(om)) {
        startoff = om->om_pkthdr_len;
    }

    leadingspace = (uint16_t) (OS_MBUF_DATA(om, uint8_t *) - 
    a1c6:	1ad3      	subs	r3, r2, r3

    while (1) {
        /* Fill the available space at the front of the head of the chain, as
         * needed.
         */
        leading = min(len, OS_MBUF_LEADINGSPACE(om));
    a1c8:	b29b      	uxth	r3, r3
    a1ca:	42ab      	cmp	r3, r5
    a1cc:	bfa8      	it	ge
    a1ce:	462b      	movge	r3, r5

        om->om_data -= leading;
    a1d0:	1ad2      	subs	r2, r2, r3
        om->om_len += leading;
        if (OS_MBUF_IS_PKTHDR(om)) {
    a1d2:	2907      	cmp	r1, #7
        /* Fill the available space at the front of the head of the chain, as
         * needed.
         */
        leading = min(len, OS_MBUF_LEADINGSPACE(om));

        om->om_data -= leading;
    a1d4:	6022      	str	r2, [r4, #0]
        om->om_len += leading;
        if (OS_MBUF_IS_PKTHDR(om)) {
            OS_MBUF_PKTHDR(om)->omp_len += leading;
    a1d6:	bf88      	it	hi
    a1d8:	8a22      	ldrhhi	r2, [r4, #16]
         * needed.
         */
        leading = min(len, OS_MBUF_LEADINGSPACE(om));

        om->om_data -= leading;
        om->om_len += leading;
    a1da:	b29e      	uxth	r6, r3
        if (OS_MBUF_IS_PKTHDR(om)) {
            OS_MBUF_PKTHDR(om)->omp_len += leading;
    a1dc:	bf88      	it	hi
    a1de:	1992      	addhi	r2, r2, r6
         * needed.
         */
        leading = min(len, OS_MBUF_LEADINGSPACE(om));

        om->om_data -= leading;
        om->om_len += leading;
    a1e0:	4430      	add	r0, r6
        if (OS_MBUF_IS_PKTHDR(om)) {
            OS_MBUF_PKTHDR(om)->omp_len += leading;
    a1e2:	bf88      	it	hi
    a1e4:	8222      	strhhi	r2, [r4, #16]
        }

        len -= leading;
        if (len == 0) {
    a1e6:	1aed      	subs	r5, r5, r3
         * needed.
         */
        leading = min(len, OS_MBUF_LEADINGSPACE(om));

        om->om_data -= leading;
        om->om_len += leading;
    a1e8:	80e0      	strh	r0, [r4, #6]
        if (OS_MBUF_IS_PKTHDR(om)) {
            OS_MBUF_PKTHDR(om)->omp_len += leading;
        }

        len -= leading;
        if (len == 0) {
    a1ea:	d022      	beq.n	a232 <os_mbuf_prepend+0x84>
            break;
        }

        /* The current head didn't have enough space; allocate a new head. */
        if (OS_MBUF_IS_PKTHDR(om)) {
    a1ec:	2907      	cmp	r1, #7
    a1ee:	68a0      	ldr	r0, [r4, #8]
    a1f0:	d904      	bls.n	a1fc <os_mbuf_prepend+0x4e>
            p = os_mbuf_get_pkthdr(om->om_omp,
    a1f2:	3908      	subs	r1, #8
    a1f4:	b2c9      	uxtb	r1, r1
    a1f6:	f7ff fe85 	bl	9f04 <os_mbuf_get_pkthdr>
    a1fa:	e002      	b.n	a202 <os_mbuf_prepend+0x54>
                om->om_pkthdr_len - sizeof (struct os_mbuf_pkthdr));
        } else {
            p = os_mbuf_get(om->om_omp, 0);
    a1fc:	2100      	movs	r1, #0
    a1fe:	f7ff fe6b 	bl	9ed8 <os_mbuf_get>
    a202:	4606      	mov	r6, r0
        }
        if (p == NULL) {
    a204:	b920      	cbnz	r0, a210 <os_mbuf_prepend+0x62>
            os_mbuf_free_chain(om);
    a206:	4620      	mov	r0, r4
    a208:	f7ff fea9 	bl	9f5e <os_mbuf_free_chain>
            om = NULL;
    a20c:	4634      	mov	r4, r6
            break;
    a20e:	e010      	b.n	a232 <os_mbuf_prepend+0x84>
        }

        if (OS_MBUF_IS_PKTHDR(om)) {
    a210:	7963      	ldrb	r3, [r4, #5]
    a212:	2b07      	cmp	r3, #7
    a214:	d904      	bls.n	a220 <os_mbuf_prepend+0x72>
            _os_mbuf_copypkthdr(p, om);
    a216:	4621      	mov	r1, r4
    a218:	f7ff fde2 	bl	9de0 <_os_mbuf_copypkthdr>
            om->om_pkthdr_len = 0;
    a21c:	2300      	movs	r3, #0
    a21e:	7163      	strb	r3, [r4, #5]
        }

        /* Move the new head's data pointer to the end so that data can be
         * prepended.
         */
        p->om_data += OS_MBUF_TRAILINGSPACE(p);
    a220:	4630      	mov	r0, r6
    a222:	f7ff fdc1 	bl	9da8 <_os_mbuf_trailingspace>
    a226:	6833      	ldr	r3, [r6, #0]

        SLIST_NEXT(p, om_next) = om;
    a228:	60f4      	str	r4, [r6, #12]
        }

        /* Move the new head's data pointer to the end so that data can be
         * prepended.
         */
        p->om_data += OS_MBUF_TRAILINGSPACE(p);
    a22a:	4418      	add	r0, r3
    a22c:	6030      	str	r0, [r6, #0]

        SLIST_NEXT(p, om_next) = om;
        om = p;
    }
    a22e:	4634      	mov	r4, r6
    a230:	e7c0      	b.n	a1b4 <os_mbuf_prepend+0x6>

    return om;
}
    a232:	4620      	mov	r0, r4
    a234:	bd70      	pop	{r4, r5, r6, pc}

0000a236 <os_mbuf_concat>:
 * @param first                 The mbuf chain being attached to.
 * @param second                The mbuf chain that gets attached.
 */
void
os_mbuf_concat(struct os_mbuf *first, struct os_mbuf *second)
{
    a236:	b510      	push	{r4, lr}
    a238:	4603      	mov	r3, r0
    struct os_mbuf *cur;

    /* Point 'cur' to the last buffer in the first chain. */
    cur = first;
    while (1) {
        next = SLIST_NEXT(cur, om_next);
    a23a:	68da      	ldr	r2, [r3, #12]
        if (next == NULL) {
    a23c:	b10a      	cbz	r2, a242 <os_mbuf_concat+0xc>
    a23e:	4613      	mov	r3, r2
    a240:	e7fb      	b.n	a23a <os_mbuf_concat+0x4>

        cur = next;
    }

    /* Attach the second chain to the end of the first. */
    SLIST_NEXT(cur, om_next) = second;
    a242:	60d9      	str	r1, [r3, #12]

    /* If the first chain has a packet header, calculate the length of the
     * second chain and add it to the header length.
     */
    if (OS_MBUF_IS_PKTHDR(first)) {
    a244:	7943      	ldrb	r3, [r0, #5]
    a246:	2b07      	cmp	r3, #7
    a248:	d90f      	bls.n	a26a <os_mbuf_concat+0x34>
        if (OS_MBUF_IS_PKTHDR(second)) {
    a24a:	794b      	ldrb	r3, [r1, #5]
    a24c:	2b07      	cmp	r3, #7
    a24e:	d903      	bls.n	a258 <os_mbuf_concat+0x22>
            OS_MBUF_PKTHDR(first)->omp_len += OS_MBUF_PKTHDR(second)->omp_len;
    a250:	8a0a      	ldrh	r2, [r1, #16]
    a252:	8a03      	ldrh	r3, [r0, #16]
    a254:	4413      	add	r3, r2
    a256:	e007      	b.n	a268 <os_mbuf_concat+0x32>
    a258:	8a03      	ldrh	r3, [r0, #16]

    /* If the first chain has a packet header, calculate the length of the
     * second chain and add it to the header length.
     */
    if (OS_MBUF_IS_PKTHDR(first)) {
        if (OS_MBUF_IS_PKTHDR(second)) {
    a25a:	460a      	mov	r2, r1
            OS_MBUF_PKTHDR(first)->omp_len += OS_MBUF_PKTHDR(second)->omp_len;
        } else {
            for (cur = second; cur != NULL; cur = SLIST_NEXT(cur, om_next)) {
                OS_MBUF_PKTHDR(first)->omp_len += cur->om_len;
    a25c:	88d4      	ldrh	r4, [r2, #6]
     */
    if (OS_MBUF_IS_PKTHDR(first)) {
        if (OS_MBUF_IS_PKTHDR(second)) {
            OS_MBUF_PKTHDR(first)->omp_len += OS_MBUF_PKTHDR(second)->omp_len;
        } else {
            for (cur = second; cur != NULL; cur = SLIST_NEXT(cur, om_next)) {
    a25e:	68d2      	ldr	r2, [r2, #12]
                OS_MBUF_PKTHDR(first)->omp_len += cur->om_len;
    a260:	4423      	add	r3, r4
    a262:	b29b      	uxth	r3, r3
     */
    if (OS_MBUF_IS_PKTHDR(first)) {
        if (OS_MBUF_IS_PKTHDR(second)) {
            OS_MBUF_PKTHDR(first)->omp_len += OS_MBUF_PKTHDR(second)->omp_len;
        } else {
            for (cur = second; cur != NULL; cur = SLIST_NEXT(cur, om_next)) {
    a264:	2a00      	cmp	r2, #0
    a266:	d1f9      	bne.n	a25c <os_mbuf_concat+0x26>
    a268:	8203      	strh	r3, [r0, #16]
                OS_MBUF_PKTHDR(first)->omp_len += cur->om_len;
            }
        }
    }

    second->om_pkthdr_len = 0;
    a26a:	2300      	movs	r3, #0
    a26c:	714b      	strb	r3, [r1, #5]
    a26e:	bd10      	pop	{r4, pc}

0000a270 <os_mbuf_extend>:
 * @return                      A pointer to the new data on success;
 *                              NULL on failure.
 */
void *
os_mbuf_extend(struct os_mbuf *om, uint16_t len)
{
    a270:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    struct os_mbuf *newm;
    struct os_mbuf *last;
    void *data;

    if (len > om->om_omp->omp_databuf_len) {
    a274:	f8d0 8008 	ldr.w	r8, [r0, #8]
    a278:	f8b8 3000 	ldrh.w	r3, [r8]
    a27c:	428b      	cmp	r3, r1
 * @return                      A pointer to the new data on success;
 *                              NULL on failure.
 */
void *
os_mbuf_extend(struct os_mbuf *om, uint16_t len)
{
    a27e:	4605      	mov	r5, r0
    a280:	460e      	mov	r6, r1
    struct os_mbuf *newm;
    struct os_mbuf *last;
    void *data;

    if (len > om->om_omp->omp_databuf_len) {
    a282:	d202      	bcs.n	a28a <os_mbuf_extend+0x1a>
        return NULL;
    a284:	2000      	movs	r0, #0
    a286:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a28a:	4604      	mov	r4, r0
    }

    /* Scroll to last mbuf in the chain */
    last = om;
    while (SLIST_NEXT(last, om_next) != NULL) {
    a28c:	68e7      	ldr	r7, [r4, #12]
    a28e:	b10f      	cbz	r7, a294 <os_mbuf_extend+0x24>
    a290:	463c      	mov	r4, r7
    a292:	e7fb      	b.n	a28c <os_mbuf_extend+0x1c>
        last = SLIST_NEXT(last, om_next);
    }

    if (OS_MBUF_TRAILINGSPACE(last) < len) {
    a294:	4620      	mov	r0, r4
    a296:	f7ff fd87 	bl	9da8 <_os_mbuf_trailingspace>
    a29a:	42b0      	cmp	r0, r6
    a29c:	46a1      	mov	r9, r4
    a29e:	d208      	bcs.n	a2b2 <os_mbuf_extend+0x42>
        newm = os_mbuf_get(om->om_omp, 0);
    a2a0:	4640      	mov	r0, r8
    a2a2:	4639      	mov	r1, r7
    a2a4:	f7ff fe18 	bl	9ed8 <os_mbuf_get>
        if (newm == NULL) {
    a2a8:	4604      	mov	r4, r0
    a2aa:	2800      	cmp	r0, #0
    a2ac:	d0ea      	beq.n	a284 <os_mbuf_extend+0x14>
            return NULL;
        }

        SLIST_NEXT(last, om_next) = newm;
    a2ae:	f8c9 000c 	str.w	r0, [r9, #12]
        last = newm;
    }

    data = last->om_data + last->om_len;
    a2b2:	88e3      	ldrh	r3, [r4, #6]
    a2b4:	6820      	ldr	r0, [r4, #0]
    a2b6:	4418      	add	r0, r3
    last->om_len += len;
    a2b8:	4433      	add	r3, r6
    a2ba:	80e3      	strh	r3, [r4, #6]

    if (OS_MBUF_IS_PKTHDR(om)) {
    a2bc:	796b      	ldrb	r3, [r5, #5]
    a2be:	2b07      	cmp	r3, #7
        OS_MBUF_PKTHDR(om)->omp_len += len;
    a2c0:	bf82      	ittt	hi
    a2c2:	8a2b      	ldrhhi	r3, [r5, #16]
    a2c4:	18f6      	addhi	r6, r6, r3
    a2c6:	822e      	strhhi	r6, [r5, #16]
    }

    return data;
}
    a2c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000a2cc <os_mbuf_pullup>:
 *
 * @return The contiguous mbuf chain on success, NULL on failure.
 */
struct os_mbuf *
os_mbuf_pullup(struct os_mbuf *om, uint16_t len)
{
    a2cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    /*
     * If first mbuf has no cluster, and has room for len bytes
     * without shifting current data, pullup into it,
     * otherwise allocate a new mbuf to prepend to the chain.
     */
    if (om->om_len >= len) {
    a2d0:	88c5      	ldrh	r5, [r0, #6]
    struct os_mbuf *next;
    struct os_mbuf *om2;
    int count;
    int space;

    omp = om->om_omp;
    a2d2:	6887      	ldr	r7, [r0, #8]
    /*
     * If first mbuf has no cluster, and has room for len bytes
     * without shifting current data, pullup into it,
     * otherwise allocate a new mbuf to prepend to the chain.
     */
    if (om->om_len >= len) {
    a2d4:	428d      	cmp	r5, r1
 *
 * @return The contiguous mbuf chain on success, NULL on failure.
 */
struct os_mbuf *
os_mbuf_pullup(struct os_mbuf *om, uint16_t len)
{
    a2d6:	4604      	mov	r4, r0
    a2d8:	460e      	mov	r6, r1
    /*
     * If first mbuf has no cluster, and has room for len bytes
     * without shifting current data, pullup into it,
     * otherwise allocate a new mbuf to prepend to the chain.
     */
    if (om->om_len >= len) {
    a2da:	d253      	bcs.n	a384 <os_mbuf_pullup+0xb8>
        return (om);
    }
    if (om->om_len + OS_MBUF_TRAILINGSPACE(om) >= len &&
    a2dc:	f7ff fd64 	bl	9da8 <_os_mbuf_trailingspace>
    a2e0:	4428      	add	r0, r5
    a2e2:	42b0      	cmp	r0, r6
    a2e4:	db06      	blt.n	a2f4 <os_mbuf_pullup+0x28>
        SLIST_NEXT(om, om_next)) {
    a2e6:	68e3      	ldr	r3, [r4, #12]
     * otherwise allocate a new mbuf to prepend to the chain.
     */
    if (om->om_len >= len) {
        return (om);
    }
    if (om->om_len + OS_MBUF_TRAILINGSPACE(om) >= len &&
    a2e8:	b123      	cbz	r3, a2f4 <os_mbuf_pullup+0x28>
        SLIST_NEXT(om, om_next)) {
        om2 = om;
        om = SLIST_NEXT(om, om_next);
        len -= om2->om_len;
    a2ea:	1b76      	subs	r6, r6, r5
    a2ec:	b2b6      	uxth	r6, r6
    a2ee:	4625      	mov	r5, r4
    a2f0:	461c      	mov	r4, r3
    a2f2:	e011      	b.n	a318 <os_mbuf_pullup+0x4c>
    } else {
        if (len > omp->omp_databuf_len - om->om_pkthdr_len) {
    a2f4:	883b      	ldrh	r3, [r7, #0]
    a2f6:	7962      	ldrb	r2, [r4, #5]
    a2f8:	1a9b      	subs	r3, r3, r2
    a2fa:	429e      	cmp	r6, r3
    a2fc:	dc3c      	bgt.n	a378 <os_mbuf_pullup+0xac>
            goto bad;
        }

        om2 = os_mbuf_get(omp, 0);
    a2fe:	4638      	mov	r0, r7
    a300:	2100      	movs	r1, #0
    a302:	f7ff fde9 	bl	9ed8 <os_mbuf_get>
        if (om2 == NULL) {
    a306:	4605      	mov	r5, r0
    a308:	2800      	cmp	r0, #0
    a30a:	d035      	beq.n	a378 <os_mbuf_pullup+0xac>
            goto bad;
        }

        if (OS_MBUF_IS_PKTHDR(om)) {
    a30c:	7963      	ldrb	r3, [r4, #5]
    a30e:	2b07      	cmp	r3, #7
    a310:	d902      	bls.n	a318 <os_mbuf_pullup+0x4c>
            _os_mbuf_copypkthdr(om2, om);
    a312:	4621      	mov	r1, r4
    a314:	f7ff fd64 	bl	9de0 <_os_mbuf_copypkthdr>
        }
    }
    space = OS_MBUF_TRAILINGSPACE(om2);
    a318:	4628      	mov	r0, r5
    a31a:	f7ff fd45 	bl	9da8 <_os_mbuf_trailingspace>
    a31e:	4680      	mov	r8, r0
    a320:	46a1      	mov	r9, r4
    do {
        count = min(min(len, space), om->om_len);
    a322:	88e7      	ldrh	r7, [r4, #6]
        memcpy(om2->om_data + om2->om_len, om->om_data, count);
    a324:	88eb      	ldrh	r3, [r5, #6]
    a326:	6828      	ldr	r0, [r5, #0]
    a328:	6821      	ldr	r1, [r4, #0]
    a32a:	4547      	cmp	r7, r8
    a32c:	bfa8      	it	ge
    a32e:	4647      	movge	r7, r8
            _os_mbuf_copypkthdr(om2, om);
        }
    }
    space = OS_MBUF_TRAILINGSPACE(om2);
    do {
        count = min(min(len, space), om->om_len);
    a330:	42b7      	cmp	r7, r6
    a332:	bfa8      	it	ge
    a334:	4637      	movge	r7, r6
        memcpy(om2->om_data + om2->om_len, om->om_data, count);
    a336:	4418      	add	r0, r3
    a338:	463a      	mov	r2, r7
    a33a:	f7fe fe5f 	bl	8ffc <memcpy>
        len -= count;
        om2->om_len += count;
    a33e:	88eb      	ldrh	r3, [r5, #6]
    }
    space = OS_MBUF_TRAILINGSPACE(om2);
    do {
        count = min(min(len, space), om->om_len);
        memcpy(om2->om_data + om2->om_len, om->om_data, count);
        len -= count;
    a340:	b2ba      	uxth	r2, r7
        om2->om_len += count;
    a342:	4413      	add	r3, r2
    a344:	80eb      	strh	r3, [r5, #6]
        om->om_len -= count;
    a346:	88e3      	ldrh	r3, [r4, #6]
    a348:	1a9b      	subs	r3, r3, r2
    }
    space = OS_MBUF_TRAILINGSPACE(om2);
    do {
        count = min(min(len, space), om->om_len);
        memcpy(om2->om_data + om2->om_len, om->om_data, count);
        len -= count;
    a34a:	1ab6      	subs	r6, r6, r2
        om2->om_len += count;
        om->om_len -= count;
    a34c:	b29b      	uxth	r3, r3
    }
    space = OS_MBUF_TRAILINGSPACE(om2);
    do {
        count = min(min(len, space), om->om_len);
        memcpy(om2->om_data + om2->om_len, om->om_data, count);
        len -= count;
    a34e:	b2b6      	uxth	r6, r6
        om2->om_len += count;
        om->om_len -= count;
    a350:	80e3      	strh	r3, [r4, #6]
        space -= count;
    a352:	ebc7 0808 	rsb	r8, r7, r8
        if (om->om_len) {
    a356:	b12b      	cbz	r3, a364 <os_mbuf_pullup+0x98>
            om->om_data += count;
    a358:	6823      	ldr	r3, [r4, #0]
    a35a:	441f      	add	r7, r3
    a35c:	6027      	str	r7, [r4, #0]
        } else {
            next = SLIST_NEXT(om, om_next);
            os_mbuf_free(om);
            om = next;
        }
    } while (len > 0 && om);
    a35e:	2e00      	cmp	r6, #0
    a360:	d1df      	bne.n	a322 <os_mbuf_pullup+0x56>
    a362:	e011      	b.n	a388 <os_mbuf_pullup+0xbc>
        space -= count;
        if (om->om_len) {
            om->om_data += count;
        } else {
            next = SLIST_NEXT(om, om_next);
            os_mbuf_free(om);
    a364:	4648      	mov	r0, r9
        om->om_len -= count;
        space -= count;
        if (om->om_len) {
            om->om_data += count;
        } else {
            next = SLIST_NEXT(om, om_next);
    a366:	68e4      	ldr	r4, [r4, #12]
            os_mbuf_free(om);
    a368:	f7ff fdf1 	bl	9f4e <os_mbuf_free>
            om = next;
        }
    } while (len > 0 && om);
    a36c:	b166      	cbz	r6, a388 <os_mbuf_pullup+0xbc>
    a36e:	2c00      	cmp	r4, #0
    a370:	d1d6      	bne.n	a320 <os_mbuf_pullup+0x54>
    if (len > 0) {
        os_mbuf_free(om2);
    a372:	4628      	mov	r0, r5
    a374:	f7ff fdeb 	bl	9f4e <os_mbuf_free>
        goto bad;
    }
    SLIST_NEXT(om2, om_next) = om;
    return (om2);
bad:
    os_mbuf_free_chain(om);
    a378:	4620      	mov	r0, r4
    a37a:	f7ff fdf0 	bl	9f5e <os_mbuf_free_chain>
    return (NULL);
    a37e:	2000      	movs	r0, #0
    a380:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a384:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    } while (len > 0 && om);
    if (len > 0) {
        os_mbuf_free(om2);
        goto bad;
    }
    SLIST_NEXT(om2, om_next) = om;
    a388:	60ec      	str	r4, [r5, #12]
    return (om2);
    a38a:	4628      	mov	r0, r5
bad:
    os_mbuf_free_chain(om);
    return (NULL);
}
    a38c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000a390 <os_mempool_init>:
 * @return os_error_t 
 */
os_error_t
os_mempool_init(struct os_mempool *mp, int blocks, int block_size, void *membuf,
                char *name)
{
    a390:	b570      	push	{r4, r5, r6, lr}
    int true_block_size;
    uint8_t *block_addr;
    struct os_memblock *block_ptr;

    /* Check for valid parameters */
    if ((!mp) || (!membuf) || (blocks <= 0) || (block_size <= 0)) {
    a392:	b350      	cbz	r0, a3ea <os_mempool_init+0x5a>
    a394:	b34b      	cbz	r3, a3ea <os_mempool_init+0x5a>
    a396:	2900      	cmp	r1, #0
    a398:	dd27      	ble.n	a3ea <os_mempool_init+0x5a>
    a39a:	2a00      	cmp	r2, #0
    a39c:	dd25      	ble.n	a3ea <os_mempool_init+0x5a>
        return OS_INVALID_PARM;
    }

    /* Blocks need to be sized properly and memory buffer should be aligned */
    if (((uint32_t)membuf & (OS_ALIGNMENT - 1)) != 0) {
    a39e:	079c      	lsls	r4, r3, #30
    a3a0:	d125      	bne.n	a3ee <os_mempool_init+0x5e>
        return OS_MEM_NOT_ALIGNED;
    }
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(block_size);
    a3a2:	f012 0403 	ands.w	r4, r2, #3
    a3a6:	bf1a      	itte	ne
    a3a8:	f1c4 0404 	rsbne	r4, r4, #4
    a3ac:	18a4      	addne	r4, r4, r2
    a3ae:	4614      	moveq	r4, r2

    /* Initialize the memory pool structure */
    mp->mp_block_size = block_size;
    a3b0:	6002      	str	r2, [r0, #0]
    mp->mp_num_free = blocks;
    mp->mp_num_blocks = blocks;
    mp->mp_membuf_addr = (uint32_t)membuf;
    mp->name = name;
    a3b2:	9a04      	ldr	r2, [sp, #16]
    a3b4:	6182      	str	r2, [r0, #24]
    }
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(block_size);

    /* Initialize the memory pool structure */
    mp->mp_block_size = block_size;
    mp->mp_num_free = blocks;
    a3b6:	6081      	str	r1, [r0, #8]
    mp->mp_num_blocks = blocks;
    a3b8:	6041      	str	r1, [r0, #4]
    mp->mp_membuf_addr = (uint32_t)membuf;
    a3ba:	60c3      	str	r3, [r0, #12]
    mp->name = name;
    SLIST_FIRST(mp) = membuf;
    a3bc:	6143      	str	r3, [r0, #20]

    /* Chain the memory blocks to the free list */
    block_addr = (uint8_t *)membuf;
    block_ptr = (struct os_memblock *)block_addr;
    while (blocks > 1) {
    a3be:	461d      	mov	r5, r3
    a3c0:	460a      	mov	r2, r1
    a3c2:	2a01      	cmp	r2, #1
    a3c4:	d004      	beq.n	a3d0 <os_mempool_init+0x40>
    a3c6:	192e      	adds	r6, r5, r4
        block_addr += true_block_size;
        SLIST_NEXT(block_ptr, mb_next) = (struct os_memblock *)block_addr;
    a3c8:	602e      	str	r6, [r5, #0]
        block_ptr = (struct os_memblock *)block_addr;
        --blocks;
    a3ca:	3a01      	subs	r2, #1

    /* Chain the memory blocks to the free list */
    block_addr = (uint8_t *)membuf;
    block_ptr = (struct os_memblock *)block_addr;
    while (blocks > 1) {
        block_addr += true_block_size;
    a3cc:	4635      	mov	r5, r6
    a3ce:	e7f8      	b.n	a3c2 <os_mempool_init+0x32>
    a3d0:	3901      	subs	r1, #1
    a3d2:	4361      	muls	r1, r4
        block_ptr = (struct os_memblock *)block_addr;
        --blocks;
    }

    /* Last one in the list should be NULL */
    SLIST_NEXT(block_ptr, mb_next) = NULL;
    a3d4:	2200      	movs	r2, #0
    a3d6:	505a      	str	r2, [r3, r1]

    STAILQ_INSERT_TAIL(&g_os_mempool_list, mp, mp_list);
    a3d8:	4906      	ldr	r1, [pc, #24]	; (a3f4 <os_mempool_init+0x64>)
    a3da:	6102      	str	r2, [r0, #16]
    a3dc:	684b      	ldr	r3, [r1, #4]
    a3de:	6018      	str	r0, [r3, #0]
    a3e0:	f100 0310 	add.w	r3, r0, #16
    a3e4:	604b      	str	r3, [r1, #4]

    return OS_OK;
    a3e6:	4610      	mov	r0, r2
    a3e8:	bd70      	pop	{r4, r5, r6, pc}
    uint8_t *block_addr;
    struct os_memblock *block_ptr;

    /* Check for valid parameters */
    if ((!mp) || (!membuf) || (blocks <= 0) || (block_size <= 0)) {
        return OS_INVALID_PARM;
    a3ea:	2003      	movs	r0, #3
    a3ec:	bd70      	pop	{r4, r5, r6, pc}
    }

    /* Blocks need to be sized properly and memory buffer should be aligned */
    if (((uint32_t)membuf & (OS_ALIGNMENT - 1)) != 0) {
        return OS_MEM_NOT_ALIGNED;
    a3ee:	2004      	movs	r0, #4
    SLIST_NEXT(block_ptr, mb_next) = NULL;

    STAILQ_INSERT_TAIL(&g_os_mempool_list, mp, mp_list);

    return OS_OK;
}
    a3f0:	bd70      	pop	{r4, r5, r6, pc}
    a3f2:	bf00      	nop
    a3f4:	20000224 	.word	0x20000224

0000a3f8 <os_memblock_get>:
 * 
 * @return void* Pointer to block if available; NULL otherwise
 */
void *
os_memblock_get(struct os_mempool *mp)
{
    a3f8:	b538      	push	{r3, r4, r5, lr}
    os_sr_t sr;
    struct os_memblock *block;

    /* Check to make sure they passed in a memory pool (or something) */
    block = NULL;
    if (mp) {
    a3fa:	4604      	mov	r4, r0
    a3fc:	b168      	cbz	r0, a41a <os_memblock_get+0x22>
        OS_ENTER_CRITICAL(sr);
    a3fe:	f7ff fa8f 	bl	9920 <os_arch_save_sr>
        /* Check for any free */
        if (mp->mp_num_free) {
    a402:	68a3      	ldr	r3, [r4, #8]
    a404:	b12b      	cbz	r3, a412 <os_memblock_get+0x1a>
            /* Get a free block */
            block = SLIST_FIRST(mp);
    a406:	6965      	ldr	r5, [r4, #20]

            /* Set new free list head */
            SLIST_FIRST(mp) = SLIST_NEXT(block, mb_next);

            /* Decrement number free by 1 */
            mp->mp_num_free--;
    a408:	3b01      	subs	r3, #1
        if (mp->mp_num_free) {
            /* Get a free block */
            block = SLIST_FIRST(mp);

            /* Set new free list head */
            SLIST_FIRST(mp) = SLIST_NEXT(block, mb_next);
    a40a:	682a      	ldr	r2, [r5, #0]
    a40c:	6162      	str	r2, [r4, #20]

            /* Decrement number free by 1 */
            mp->mp_num_free--;
    a40e:	60a3      	str	r3, [r4, #8]
    a410:	e000      	b.n	a414 <os_memblock_get+0x1c>
{
    os_sr_t sr;
    struct os_memblock *block;

    /* Check to make sure they passed in a memory pool (or something) */
    block = NULL;
    a412:	461d      	mov	r5, r3
            SLIST_FIRST(mp) = SLIST_NEXT(block, mb_next);

            /* Decrement number free by 1 */
            mp->mp_num_free--;
        }
        OS_EXIT_CRITICAL(sr);
    a414:	f7ff fa8a 	bl	992c <os_arch_restore_sr>
    a418:	e000      	b.n	a41c <os_memblock_get+0x24>
{
    os_sr_t sr;
    struct os_memblock *block;

    /* Check to make sure they passed in a memory pool (or something) */
    block = NULL;
    a41a:	4605      	mov	r5, r0
        }
        OS_EXIT_CRITICAL(sr);
    }

    return (void *)block;
}
    a41c:	4628      	mov	r0, r5
    a41e:	bd38      	pop	{r3, r4, r5, pc}

0000a420 <os_memblock_put>:
 * 
 * @return os_error_t 
 */
os_error_t
os_memblock_put(struct os_mempool *mp, void *block_addr)
{
    a420:	b570      	push	{r4, r5, r6, lr}
    a422:	460e      	mov	r6, r1
    uint32_t true_block_size;
    uint32_t baddr32;
    struct os_memblock *block;

    /* Make sure parameters are valid */
    if ((mp == NULL) || (block_addr == NULL)) {
    a424:	4605      	mov	r5, r0
    a426:	b310      	cbz	r0, a46e <os_memblock_put+0x4e>
    a428:	b309      	cbz	r1, a46e <os_memblock_put+0x4e>
        return OS_INVALID_PARM;
    }

    /* Check that the block we are freeing is a valid block! */
    baddr32 = (uint32_t)block_addr;
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(mp->mp_block_size);
    a42a:	6804      	ldr	r4, [r0, #0]
    end = mp->mp_membuf_addr + (mp->mp_num_blocks * true_block_size);
    a42c:	68c0      	ldr	r0, [r0, #12]
    a42e:	686b      	ldr	r3, [r5, #4]
        return OS_INVALID_PARM;
    }

    /* Check that the block we are freeing is a valid block! */
    baddr32 = (uint32_t)block_addr;
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(mp->mp_block_size);
    a430:	f014 0203 	ands.w	r2, r4, #3
    a434:	bf16      	itet	ne
    a436:	f1c2 0204 	rsbne	r2, r2, #4
    a43a:	4622      	moveq	r2, r4
    a43c:	1912      	addne	r2, r2, r4
    end = mp->mp_membuf_addr + (mp->mp_num_blocks * true_block_size);
    if ((baddr32 < mp->mp_membuf_addr) || (baddr32 >= end)) {
    a43e:	4281      	cmp	r1, r0
    a440:	d315      	bcc.n	a46e <os_memblock_put+0x4e>
    }

    /* Check that the block we are freeing is a valid block! */
    baddr32 = (uint32_t)block_addr;
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(mp->mp_block_size);
    end = mp->mp_membuf_addr + (mp->mp_num_blocks * true_block_size);
    a442:	fb03 0302 	mla	r3, r3, r2, r0
    if ((baddr32 < mp->mp_membuf_addr) || (baddr32 >= end)) {
    a446:	4299      	cmp	r1, r3
    a448:	d211      	bcs.n	a46e <os_memblock_put+0x4e>
        return OS_INVALID_PARM;
    }

    /* All freed blocks should be on true block size boundaries! */
    if (((baddr32 - mp->mp_membuf_addr) % true_block_size) != 0) {
    a44a:	1a08      	subs	r0, r1, r0
    a44c:	fbb0 f3f2 	udiv	r3, r0, r2
    a450:	fb02 0413 	mls	r4, r2, r3, r0
    a454:	b95c      	cbnz	r4, a46e <os_memblock_put+0x4e>
     * XXX: we should do boundary checks here! The block had better be within 
     * the pool. If it fails, do we return an error or assert()? Add this when 
     * we add the memory debug. 
     */ 
    block = (struct os_memblock *)block_addr;
    OS_ENTER_CRITICAL(sr);
    a456:	f7ff fa63 	bl	9920 <os_arch_save_sr>
    
    /* Chain current free list pointer to this block; make this block head */
    SLIST_NEXT(block, mb_next) = SLIST_FIRST(mp);
    a45a:	696b      	ldr	r3, [r5, #20]
    a45c:	6033      	str	r3, [r6, #0]
    SLIST_FIRST(mp) = block;

    /* XXX: Should we check that the number free <= number blocks? */
    /* Increment number free */
    mp->mp_num_free++;
    a45e:	68ab      	ldr	r3, [r5, #8]
    block = (struct os_memblock *)block_addr;
    OS_ENTER_CRITICAL(sr);
    
    /* Chain current free list pointer to this block; make this block head */
    SLIST_NEXT(block, mb_next) = SLIST_FIRST(mp);
    SLIST_FIRST(mp) = block;
    a460:	616e      	str	r6, [r5, #20]

    /* XXX: Should we check that the number free <= number blocks? */
    /* Increment number free */
    mp->mp_num_free++;
    a462:	3301      	adds	r3, #1
    a464:	60ab      	str	r3, [r5, #8]

    OS_EXIT_CRITICAL(sr);
    a466:	f7ff fa61 	bl	992c <os_arch_restore_sr>

    return OS_OK;
    a46a:	4620      	mov	r0, r4
    a46c:	bd70      	pop	{r4, r5, r6, pc}
    uint32_t baddr32;
    struct os_memblock *block;

    /* Make sure parameters are valid */
    if ((mp == NULL) || (block_addr == NULL)) {
        return OS_INVALID_PARM;
    a46e:	2003      	movs	r0, #3
    mp->mp_num_free++;

    OS_EXIT_CRITICAL(sr);

    return OS_OK;
}
    a470:	bd70      	pop	{r4, r5, r6, pc}
	...

0000a474 <os_sched_insert>:
 * @return int  OS_OK: task was inserted into run list 
 *              OS_EINVAL: Task was not in ready state. 
 */
os_error_t
os_sched_insert(struct os_task *t) 
{
    a474:	b538      	push	{r3, r4, r5, lr}
    struct os_task *entry; 
    os_sr_t sr; 
    os_error_t rc;

    if (t->t_state != OS_TASK_READY) {
    a476:	7b83      	ldrb	r3, [r0, #14]
    a478:	2b01      	cmp	r3, #1
 * @return int  OS_OK: task was inserted into run list 
 *              OS_EINVAL: Task was not in ready state. 
 */
os_error_t
os_sched_insert(struct os_task *t) 
{
    a47a:	4604      	mov	r4, r0
    struct os_task *entry; 
    os_sr_t sr; 
    os_error_t rc;

    if (t->t_state != OS_TASK_READY) {
    a47c:	d10a      	bne.n	a494 <os_sched_insert+0x20>
        rc = OS_EINVAL;
        goto err;
    }

    entry = NULL;
    OS_ENTER_CRITICAL(sr); 
    a47e:	f7ff fa4f 	bl	9920 <os_arch_save_sr>
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    a482:	4a0e      	ldr	r2, [pc, #56]	; (a4bc <os_sched_insert+0x48>)
    a484:	6813      	ldr	r3, [r2, #0]
    a486:	b193      	cbz	r3, a4ae <os_sched_insert+0x3a>
        if (t->t_prio < entry->t_prio) { 
    a488:	7b65      	ldrb	r5, [r4, #13]
    a48a:	7b59      	ldrb	r1, [r3, #13]
    a48c:	428d      	cmp	r5, r1
    a48e:	d303      	bcc.n	a498 <os_sched_insert+0x24>
        goto err;
    }

    entry = NULL;
    OS_ENTER_CRITICAL(sr); 
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    a490:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    a492:	e7f8      	b.n	a486 <os_sched_insert+0x12>
    }
    OS_EXIT_CRITICAL(sr);

    return (0);
err:
    return (rc);
    a494:	2002      	movs	r0, #2
    a496:	bd38      	pop	{r3, r4, r5, pc}
        if (t->t_prio < entry->t_prio) { 
            break;
        }
    }
    if (entry) {
        TAILQ_INSERT_BEFORE(entry, (struct os_task *) t, t_os_list);
    a498:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    a49a:	64a2      	str	r2, [r4, #72]	; 0x48
    a49c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    a49e:	6463      	str	r3, [r4, #68]	; 0x44
    a4a0:	6014      	str	r4, [r2, #0]
    a4a2:	3444      	adds	r4, #68	; 0x44
    a4a4:	649c      	str	r4, [r3, #72]	; 0x48
    } else {
        TAILQ_INSERT_TAIL(&g_os_run_list, (struct os_task *) t, t_os_list);
    }
    OS_EXIT_CRITICAL(sr);
    a4a6:	f7ff fa41 	bl	992c <os_arch_restore_sr>
    a4aa:	2000      	movs	r0, #0
    a4ac:	bd38      	pop	{r3, r4, r5, pc}
        }
    }
    if (entry) {
        TAILQ_INSERT_BEFORE(entry, (struct os_task *) t, t_os_list);
    } else {
        TAILQ_INSERT_TAIL(&g_os_run_list, (struct os_task *) t, t_os_list);
    a4ae:	6463      	str	r3, [r4, #68]	; 0x44
    a4b0:	6853      	ldr	r3, [r2, #4]
    a4b2:	64a3      	str	r3, [r4, #72]	; 0x48
    a4b4:	601c      	str	r4, [r3, #0]
    a4b6:	3444      	adds	r4, #68	; 0x44
    a4b8:	6054      	str	r4, [r2, #4]
    a4ba:	e7f4      	b.n	a4a6 <os_sched_insert+0x32>
    a4bc:	2000022c 	.word	0x2000022c

0000a4c0 <os_sched_ctx_sw_hook>:
}

void
os_sched_ctx_sw_hook(struct os_task *next_t)
{
    if (g_current_task == next_t) {
    a4c0:	4b08      	ldr	r3, [pc, #32]	; (a4e4 <os_sched_ctx_sw_hook+0x24>)
    a4c2:	681a      	ldr	r2, [r3, #0]
    a4c4:	4282      	cmp	r2, r0
    return (rc);
}

void
os_sched_ctx_sw_hook(struct os_task *next_t)
{
    a4c6:	b510      	push	{r4, lr}
    if (g_current_task == next_t) {
    a4c8:	d00b      	beq.n	a4e2 <os_sched_ctx_sw_hook+0x22>
        return;
    }

    next_t->t_ctx_sw_cnt++;
    a4ca:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    a4cc:	4906      	ldr	r1, [pc, #24]	; (a4e8 <os_sched_ctx_sw_hook+0x28>)
{
    if (g_current_task == next_t) {
        return;
    }

    next_t->t_ctx_sw_cnt++;
    a4ce:	3301      	adds	r3, #1
    a4d0:	63c3      	str	r3, [r0, #60]	; 0x3c
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    a4d2:	4b06      	ldr	r3, [pc, #24]	; (a4ec <os_sched_ctx_sw_hook+0x2c>)
    a4d4:	680c      	ldr	r4, [r1, #0]
    a4d6:	6818      	ldr	r0, [r3, #0]
    a4d8:	6b93      	ldr	r3, [r2, #56]	; 0x38
    g_os_last_ctx_sw_time = g_os_time;
    a4da:	6008      	str	r0, [r1, #0]
    a4dc:	4403      	add	r3, r0
    if (g_current_task == next_t) {
        return;
    }

    next_t->t_ctx_sw_cnt++;
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    a4de:	1b1b      	subs	r3, r3, r4
    a4e0:	6393      	str	r3, [r2, #56]	; 0x38
    a4e2:	bd10      	pop	{r4, pc}
    a4e4:	20002f34 	.word	0x20002f34
    a4e8:	20002f38 	.word	0x20002f38
    a4ec:	20002f48 	.word	0x20002f48

0000a4f0 <os_sched_get_current_task>:
 */
struct os_task * 
os_sched_get_current_task(void)
{
    return (g_current_task);
}
    a4f0:	4b01      	ldr	r3, [pc, #4]	; (a4f8 <os_sched_get_current_task+0x8>)
    a4f2:	6818      	ldr	r0, [r3, #0]
    a4f4:	4770      	bx	lr
    a4f6:	bf00      	nop
    a4f8:	20002f34 	.word	0x20002f34

0000a4fc <os_sched_set_current_task>:
 * @param t Pointer to currently running task.
 */
void 
os_sched_set_current_task(struct os_task *t) 
{
    g_current_task = t;
    a4fc:	4b01      	ldr	r3, [pc, #4]	; (a504 <os_sched_set_current_task+0x8>)
    a4fe:	6018      	str	r0, [r3, #0]
    a500:	4770      	bx	lr
    a502:	bf00      	nop
    a504:	20002f34 	.word	0x20002f34

0000a508 <os_sched>:
 * 
 * @param next_t Task to run
 */
void
os_sched(struct os_task *next_t)
{
    a508:	b538      	push	{r3, r4, r5, lr}
    a50a:	4604      	mov	r4, r0
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    a50c:	f7ff fa08 	bl	9920 <os_arch_save_sr>
    a510:	4605      	mov	r5, r0

    if (!next_t) {
    a512:	b90c      	cbnz	r4, a518 <os_sched+0x10>
 * @return struct os_task* 
 */
struct os_task *  
os_sched_next_task(void) 
{
    return (TAILQ_FIRST(&g_os_run_list));
    a514:	4b06      	ldr	r3, [pc, #24]	; (a530 <os_sched+0x28>)
    a516:	681c      	ldr	r4, [r3, #0]

    if (!next_t) {
        next_t = os_sched_next_task();
    }

    if (next_t != g_current_task) {
    a518:	4b06      	ldr	r3, [pc, #24]	; (a534 <os_sched+0x2c>)
    a51a:	681b      	ldr	r3, [r3, #0]
    a51c:	429c      	cmp	r4, r3
    a51e:	d002      	beq.n	a526 <os_sched+0x1e>
        os_arch_ctx_sw(next_t);
    a520:	4620      	mov	r0, r4
    a522:	f7ff f9f3 	bl	990c <os_arch_ctx_sw>
    }

    OS_EXIT_CRITICAL(sr);
    a526:	4628      	mov	r0, r5
}
    a528:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    if (next_t != g_current_task) {
        os_arch_ctx_sw(next_t);
    }

    OS_EXIT_CRITICAL(sr);
    a52c:	f7ff b9fe 	b.w	992c <os_arch_restore_sr>
    a530:	2000022c 	.word	0x2000022c
    a534:	20002f34 	.word	0x20002f34

0000a538 <os_sched_sleep>:
 * NOTE: must be called with interrupts disabled! This function does not call 
 * the scheduler 
 */
int 
os_sched_sleep(struct os_task *t, os_time_t nticks) 
{
    a538:	b538      	push	{r3, r4, r5, lr}
    struct os_task *entry;

    entry = NULL; 

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    a53a:	6c43      	ldr	r3, [r0, #68]	; 0x44
    a53c:	6c82      	ldr	r2, [r0, #72]	; 0x48
 * NOTE: must be called with interrupts disabled! This function does not call 
 * the scheduler 
 */
int 
os_sched_sleep(struct os_task *t, os_time_t nticks) 
{
    a53e:	4604      	mov	r4, r0
    a540:	460d      	mov	r5, r1
    struct os_task *entry;

    entry = NULL; 

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    a542:	b10b      	cbz	r3, a548 <os_sched_sleep+0x10>
    a544:	649a      	str	r2, [r3, #72]	; 0x48
    a546:	e001      	b.n	a54c <os_sched_sleep+0x14>
    a548:	4916      	ldr	r1, [pc, #88]	; (a5a4 <os_sched_sleep+0x6c>)
    a54a:	604a      	str	r2, [r1, #4]
    a54c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    a54e:	6013      	str	r3, [r2, #0]
    t->t_state = OS_TASK_SLEEP;
    a550:	2302      	movs	r3, #2
    a552:	73a3      	strb	r3, [r4, #14]
    t->t_next_wakeup = os_time_get() + nticks;
    a554:	f000 f934 	bl	a7c0 <os_time_get>
    a558:	4428      	add	r0, r5
    if (nticks == OS_TIMEOUT_NEVER) {
    a55a:	3501      	adds	r5, #1

    entry = NULL; 

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    t->t_state = OS_TASK_SLEEP;
    t->t_next_wakeup = os_time_get() + nticks;
    a55c:	6360      	str	r0, [r4, #52]	; 0x34
    a55e:	4a12      	ldr	r2, [pc, #72]	; (a5a8 <os_sched_sleep+0x70>)
    if (nticks == OS_TIMEOUT_NEVER) {
    a560:	d105      	bne.n	a56e <os_sched_sleep+0x36>
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
    a562:	7be3      	ldrb	r3, [r4, #15]
    a564:	f043 0301 	orr.w	r3, r3, #1
    a568:	73e3      	strb	r3, [r4, #15]
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    a56a:	2300      	movs	r3, #0
    a56c:	e00a      	b.n	a584 <os_sched_sleep+0x4c>
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    a56e:	6813      	ldr	r3, [r2, #0]
    a570:	b143      	cbz	r3, a584 <os_sched_sleep+0x4c>
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    a572:	7bd9      	ldrb	r1, [r3, #15]
    a574:	07c9      	lsls	r1, r1, #31
    a576:	d40c      	bmi.n	a592 <os_sched_sleep+0x5a>
                    OS_TIME_TICK_GT(entry->t_next_wakeup, t->t_next_wakeup)) {
    a578:	6b59      	ldr	r1, [r3, #52]	; 0x34
    a57a:	1a09      	subs	r1, r1, r0
    if (nticks == OS_TIMEOUT_NEVER) {
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    a57c:	2900      	cmp	r1, #0
    a57e:	dc08      	bgt.n	a592 <os_sched_sleep+0x5a>
    t->t_next_wakeup = os_time_get() + nticks;
    if (nticks == OS_TIMEOUT_NEVER) {
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    a580:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    a582:	e7f5      	b.n	a570 <os_sched_sleep+0x38>
            }
        }
        if (entry) {
            TAILQ_INSERT_BEFORE(entry, t, t_os_list); 
        } else {
            TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    a584:	6463      	str	r3, [r4, #68]	; 0x44
    a586:	6853      	ldr	r3, [r2, #4]
    a588:	64a3      	str	r3, [r4, #72]	; 0x48
    a58a:	601c      	str	r4, [r3, #0]
    a58c:	3444      	adds	r4, #68	; 0x44
    a58e:	6054      	str	r4, [r2, #4]
    a590:	e006      	b.n	a5a0 <os_sched_sleep+0x68>
                    OS_TIME_TICK_GT(entry->t_next_wakeup, t->t_next_wakeup)) {
                break;
            }
        }
        if (entry) {
            TAILQ_INSERT_BEFORE(entry, t, t_os_list); 
    a592:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    a594:	64a2      	str	r2, [r4, #72]	; 0x48
    a596:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    a598:	6463      	str	r3, [r4, #68]	; 0x44
    a59a:	6014      	str	r4, [r2, #0]
    a59c:	3444      	adds	r4, #68	; 0x44
    a59e:	649c      	str	r4, [r3, #72]	; 0x48
            TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
        }
    }

    return (0);
}
    a5a0:	2000      	movs	r0, #0
    a5a2:	bd38      	pop	{r3, r4, r5, pc}
    a5a4:	2000022c 	.word	0x2000022c
    a5a8:	20000234 	.word	0x20000234

0000a5ac <os_sched_wakeup>:
 *  
 * NOTE: This function must be called with interrupts disabled. 
 */
int 
os_sched_wakeup(struct os_task *t) 
{
    a5ac:	b508      	push	{r3, lr}
    struct os_task_obj *os_obj;

    assert(t->t_state == OS_TASK_SLEEP);
    a5ae:	7b83      	ldrb	r3, [r0, #14]
    a5b0:	2b02      	cmp	r3, #2
    a5b2:	d003      	beq.n	a5bc <os_sched_wakeup+0x10>
    a5b4:	4818      	ldr	r0, [pc, #96]	; (a618 <os_sched_wakeup+0x6c>)
    a5b6:	21ce      	movs	r1, #206	; 0xce
    a5b8:	2200      	movs	r2, #0
    a5ba:	e005      	b.n	a5c8 <os_sched_wakeup+0x1c>

    /* Remove self from object list if waiting on one */
    if (t->t_obj) {
    a5bc:	69c3      	ldr	r3, [r0, #28]
    a5be:	b1ab      	cbz	r3, a5ec <os_sched_wakeup+0x40>
        os_obj = (struct os_task_obj *)t->t_obj;
        assert(!SLIST_EMPTY(&os_obj->obj_head));
    a5c0:	681a      	ldr	r2, [r3, #0]
    a5c2:	b922      	cbnz	r2, a5ce <os_sched_wakeup+0x22>
    a5c4:	4814      	ldr	r0, [pc, #80]	; (a618 <os_sched_wakeup+0x6c>)
    a5c6:	21d3      	movs	r1, #211	; 0xd3
    a5c8:	4613      	mov	r3, r2
    a5ca:	f7ff fb81 	bl	9cd0 <__assert_func>
        SLIST_REMOVE(&os_obj->obj_head, t, os_task, t_obj_list);
    a5ce:	4282      	cmp	r2, r0
    a5d0:	d102      	bne.n	a5d8 <os_sched_wakeup+0x2c>
    a5d2:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
    a5d4:	601a      	str	r2, [r3, #0]
    a5d6:	e006      	b.n	a5e6 <os_sched_wakeup+0x3a>
    a5d8:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    a5da:	4283      	cmp	r3, r0
    a5dc:	d001      	beq.n	a5e2 <os_sched_wakeup+0x36>
    a5de:	461a      	mov	r2, r3
    a5e0:	e7fa      	b.n	a5d8 <os_sched_wakeup+0x2c>
    a5e2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    a5e4:	64d3      	str	r3, [r2, #76]	; 0x4c
        SLIST_NEXT(t, t_obj_list) = NULL;
    a5e6:	2300      	movs	r3, #0
    a5e8:	64c3      	str	r3, [r0, #76]	; 0x4c
        t->t_obj = NULL; 
    a5ea:	61c3      	str	r3, [r0, #28]
    }

    /* Remove task from sleep list */
    t->t_state = OS_TASK_READY;
    a5ec:	2301      	movs	r3, #1
    a5ee:	7383      	strb	r3, [r0, #14]
    t->t_next_wakeup = 0;
    a5f0:	2300      	movs	r3, #0
    a5f2:	6343      	str	r3, [r0, #52]	; 0x34
    t->t_flags &= ~OS_TASK_FLAG_NO_TIMEOUT;
    a5f4:	7bc3      	ldrb	r3, [r0, #15]
    a5f6:	6c82      	ldr	r2, [r0, #72]	; 0x48
    a5f8:	f023 0301 	bic.w	r3, r3, #1
    a5fc:	73c3      	strb	r3, [r0, #15]
    TAILQ_REMOVE(&g_os_sleep_list, t, t_os_list);
    a5fe:	6c43      	ldr	r3, [r0, #68]	; 0x44
    a600:	b10b      	cbz	r3, a606 <os_sched_wakeup+0x5a>
    a602:	649a      	str	r2, [r3, #72]	; 0x48
    a604:	e001      	b.n	a60a <os_sched_wakeup+0x5e>
    a606:	4905      	ldr	r1, [pc, #20]	; (a61c <os_sched_wakeup+0x70>)
    a608:	604a      	str	r2, [r1, #4]
    a60a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    a60c:	6013      	str	r3, [r2, #0]
    os_sched_insert(t);
    a60e:	f7ff ff31 	bl	a474 <os_sched_insert>

    return (0);
}
    a612:	2000      	movs	r0, #0
    a614:	bd08      	pop	{r3, pc}
    a616:	bf00      	nop
    a618:	0001f216 	.word	0x0001f216
    a61c:	20000234 	.word	0x20000234

0000a620 <os_sched_os_timer_exp>:
 * removed from the sleep list and added to the run list. 
 * 
 */
void
os_sched_os_timer_exp(void)
{
    a620:	b570      	push	{r4, r5, r6, lr}
    struct os_task *t;
    struct os_task *next;
    os_time_t now; 
    os_sr_t sr;

    now = os_time_get();
    a622:	f000 f8cd 	bl	a7c0 <os_time_get>
    a626:	4605      	mov	r5, r0

    OS_ENTER_CRITICAL(sr);
    a628:	f7ff f97a 	bl	9920 <os_arch_save_sr>

    /*
     * Wakeup any tasks that have their sleep timer expired
     */
    t = TAILQ_FIRST(&g_os_sleep_list);
    a62c:	4b0a      	ldr	r3, [pc, #40]	; (a658 <os_sched_os_timer_exp+0x38>)
    os_time_t now; 
    os_sr_t sr;

    now = os_time_get();

    OS_ENTER_CRITICAL(sr);
    a62e:	4604      	mov	r4, r0

    /*
     * Wakeup any tasks that have their sleep timer expired
     */
    t = TAILQ_FIRST(&g_os_sleep_list);
    a630:	6818      	ldr	r0, [r3, #0]
    while (t) {
    a632:	b158      	cbz	r0, a64c <os_sched_os_timer_exp+0x2c>
        /* If task waiting forever, do not check next wakeup time */
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
    a634:	7bc3      	ldrb	r3, [r0, #15]
    a636:	07db      	lsls	r3, r3, #31
    a638:	d408      	bmi.n	a64c <os_sched_os_timer_exp+0x2c>
            break;
        }
        next = TAILQ_NEXT(t, t_os_list);
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
    a63a:	6b43      	ldr	r3, [r0, #52]	; 0x34
    while (t) {
        /* If task waiting forever, do not check next wakeup time */
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
            break;
        }
        next = TAILQ_NEXT(t, t_os_list);
    a63c:	6c46      	ldr	r6, [r0, #68]	; 0x44
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
    a63e:	1aeb      	subs	r3, r5, r3
    a640:	2b00      	cmp	r3, #0
    a642:	db03      	blt.n	a64c <os_sched_os_timer_exp+0x2c>
            os_sched_wakeup(t);
    a644:	f7ff ffb2 	bl	a5ac <os_sched_wakeup>
        } else {
            break;
        }
        t = next;
    a648:	4630      	mov	r0, r6
    a64a:	e7f2      	b.n	a632 <os_sched_os_timer_exp+0x12>
    }

    OS_EXIT_CRITICAL(sr); 
    a64c:	4620      	mov	r0, r4
}
    a64e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            break;
        }
        t = next;
    }

    OS_EXIT_CRITICAL(sr); 
    a652:	f7ff b96b 	b.w	992c <os_arch_restore_sr>
    a656:	bf00      	nop
    a658:	20000234 	.word	0x20000234

0000a65c <os_sched_wakeup_ticks>:
 * Return the number of ticks until the first sleep timer expires.If there are
 * no such tasks then return OS_TIMEOUT_NEVER instead.
 */
os_time_t
os_sched_wakeup_ticks(os_time_t now)
{
    a65c:	b510      	push	{r4, lr}
    a65e:	4604      	mov	r4, r0
    os_time_t rt;
    struct os_task *t;

    OS_ASSERT_CRITICAL();
    a660:	f7ff f967 	bl	9932 <os_arch_in_critical>
    a664:	4602      	mov	r2, r0
    a666:	b928      	cbnz	r0, a674 <os_sched_wakeup_ticks+0x18>
    a668:	4809      	ldr	r0, [pc, #36]	; (a690 <os_sched_wakeup_ticks+0x34>)
    a66a:	f240 1117 	movw	r1, #279	; 0x117
    a66e:	4613      	mov	r3, r2
    a670:	f7ff fb2e 	bl	9cd0 <__assert_func>

    t = TAILQ_FIRST(&g_os_sleep_list);
    a674:	4b07      	ldr	r3, [pc, #28]	; (a694 <os_sched_wakeup_ticks+0x38>)
    a676:	681b      	ldr	r3, [r3, #0]
    if (t == NULL || (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT)) {
    a678:	b13b      	cbz	r3, a68a <os_sched_wakeup_ticks+0x2e>
    a67a:	7bda      	ldrb	r2, [r3, #15]
    a67c:	07d2      	lsls	r2, r2, #31
    a67e:	d404      	bmi.n	a68a <os_sched_wakeup_ticks+0x2e>
        rt = OS_TIMEOUT_NEVER;
    } else if (OS_TIME_TICK_GEQ(t->t_next_wakeup, now)) {
    a680:	6b58      	ldr	r0, [r3, #52]	; 0x34
    a682:	1b00      	subs	r0, r0, r4
        rt = t->t_next_wakeup - now;   
    } else {
        rt = 0;     /* wakeup time was in the past */
    a684:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    a688:	bd10      	pop	{r4, pc}

    OS_ASSERT_CRITICAL();

    t = TAILQ_FIRST(&g_os_sleep_list);
    if (t == NULL || (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT)) {
        rt = OS_TIMEOUT_NEVER;
    a68a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        rt = t->t_next_wakeup - now;   
    } else {
        rt = 0;     /* wakeup time was in the past */
    }
    return (rt);
}
    a68e:	bd10      	pop	{r4, pc}
    a690:	0001f216 	.word	0x0001f216
    a694:	20000234 	.word	0x20000234

0000a698 <os_sched_next_task>:
 */
struct os_task *  
os_sched_next_task(void) 
{
    return (TAILQ_FIRST(&g_os_run_list));
}
    a698:	4b01      	ldr	r3, [pc, #4]	; (a6a0 <os_sched_next_task+0x8>)
    a69a:	6818      	ldr	r0, [r3, #0]
    a69c:	4770      	bx	lr
    a69e:	bf00      	nop
    a6a0:	2000022c 	.word	0x2000022c

0000a6a4 <os_sched_resort>:
 * are not disabled here. 
 */
void 
os_sched_resort(struct os_task *t) 
{
    if (t->t_state == OS_TASK_READY) {
    a6a4:	7b83      	ldrb	r3, [r0, #14]
    a6a6:	2b01      	cmp	r3, #1
    a6a8:	d10a      	bne.n	a6c0 <os_sched_resort+0x1c>
        TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    a6aa:	6c43      	ldr	r3, [r0, #68]	; 0x44
    a6ac:	6c82      	ldr	r2, [r0, #72]	; 0x48
    a6ae:	b10b      	cbz	r3, a6b4 <os_sched_resort+0x10>
    a6b0:	649a      	str	r2, [r3, #72]	; 0x48
    a6b2:	e001      	b.n	a6b8 <os_sched_resort+0x14>
    a6b4:	4903      	ldr	r1, [pc, #12]	; (a6c4 <os_sched_resort+0x20>)
    a6b6:	604a      	str	r2, [r1, #4]
    a6b8:	6c82      	ldr	r2, [r0, #72]	; 0x48
    a6ba:	6013      	str	r3, [r2, #0]
        os_sched_insert(t);
    a6bc:	f7ff beda 	b.w	a474 <os_sched_insert>
    a6c0:	4770      	bx	lr
    a6c2:	bf00      	nop
    a6c4:	2000022c 	.word	0x2000022c

0000a6c8 <os_task_init>:
 */
int
os_task_init(struct os_task *t, char *name, os_task_func_t func, void *arg,
        uint8_t prio, os_time_t sanity_itvl, os_stack_t *stack_bottom,
        uint16_t stack_size)
{
    a6c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a6cc:	4604      	mov	r4, r0
    a6ce:	461f      	mov	r7, r3
    a6d0:	4689      	mov	r9, r1
    a6d2:	4692      	mov	sl, r2
    struct os_sanity_check *sc;
    int rc;

    memset(t, 0, sizeof(*t));
    a6d4:	2100      	movs	r1, #0
    a6d6:	2250      	movs	r2, #80	; 0x50
 */
int
os_task_init(struct os_task *t, char *name, os_task_func_t func, void *arg,
        uint8_t prio, os_time_t sanity_itvl, os_stack_t *stack_bottom,
        uint16_t stack_size)
{
    a6d8:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    a6dc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    a6de:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
    struct os_sanity_check *sc;
    int rc;

    memset(t, 0, sizeof(*t));
    a6e2:	f7fe fc96 	bl	9012 <memset>

    t->t_func = func;
    t->t_arg = arg;
    a6e6:	61a7      	str	r7, [r4, #24]
    struct os_sanity_check *sc;
    int rc;

    memset(t, 0, sizeof(*t));

    t->t_func = func;
    a6e8:	f8c4 a014 	str.w	sl, [r4, #20]
os_task_next_id(void)
{
    uint8_t rc;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    a6ec:	f7ff f918 	bl	9920 <os_arch_save_sr>
    rc = g_task_id;
    a6f0:	4b1f      	ldr	r3, [pc, #124]	; (a770 <os_task_init+0xa8>)
    a6f2:	781f      	ldrb	r7, [r3, #0]
    g_task_id++;
    a6f4:	1c7a      	adds	r2, r7, #1
    a6f6:	701a      	strb	r2, [r3, #0]
    OS_EXIT_CRITICAL(sr);
    a6f8:	f7ff f918 	bl	992c <os_arch_restore_sr>

    t->t_func = func;
    t->t_arg = arg;

    t->t_taskid = os_task_next_id();
    t->t_prio = prio;
    a6fc:	f89d 3020 	ldrb.w	r3, [sp, #32]
    a700:	7363      	strb	r3, [r4, #13]

    t->t_state = OS_TASK_READY;
    a702:	2301      	movs	r3, #1
    memset(t, 0, sizeof(*t));

    t->t_func = func;
    t->t_arg = arg;

    t->t_taskid = os_task_next_id();
    a704:	7327      	strb	r7, [r4, #12]
    t->t_prio = prio;

    t->t_state = OS_TASK_READY;
    a706:	73a3      	strb	r3, [r4, #14]
    t->t_name = name;
    t->t_next_wakeup = 0;

    rc = os_sanity_check_init(&t->t_sanity_check);
    a708:	f104 0720 	add.w	r7, r4, #32
    t->t_taskid = os_task_next_id();
    t->t_prio = prio;

    t->t_state = OS_TASK_READY;
    t->t_name = name;
    t->t_next_wakeup = 0;
    a70c:	2300      	movs	r3, #0

    t->t_taskid = os_task_next_id();
    t->t_prio = prio;

    t->t_state = OS_TASK_READY;
    t->t_name = name;
    a70e:	f8c4 9010 	str.w	r9, [r4, #16]
    t->t_next_wakeup = 0;
    a712:	6363      	str	r3, [r4, #52]	; 0x34

    rc = os_sanity_check_init(&t->t_sanity_check);
    a714:	4638      	mov	r0, r7
    a716:	f000 f97f 	bl	aa18 <os_sanity_check_init>
    if (rc != OS_OK) {
    a71a:	bb38      	cbnz	r0, a76c <os_task_init+0xa4>
        goto err;
    }

    if (sanity_itvl != OS_WAIT_FOREVER) {
    a71c:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    a720:	d101      	bne.n	a726 <os_task_init+0x5e>
static void
_clear_stack(os_stack_t *stack_bottom, int size)
{
    int i;

    for (i = 0; i < size; i++) {
    a722:	2300      	movs	r3, #0
    a724:	e006      	b.n	a734 <os_task_init+0x6c>
        goto err;
    }

    if (sanity_itvl != OS_WAIT_FOREVER) {
        sc = (struct os_sanity_check *) &t->t_sanity_check;
        sc->sc_checkin_itvl = sanity_itvl;
    a726:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24

        rc = os_sanity_check_register(sc);
    a72a:	4638      	mov	r0, r7
    a72c:	f000 f97c 	bl	aa28 <os_sanity_check_register>
        if (rc != OS_OK) {
    a730:	b9e0      	cbnz	r0, a76c <os_task_init+0xa4>
    a732:	e7f6      	b.n	a722 <os_task_init+0x5a>
static void
_clear_stack(os_stack_t *stack_bottom, int size)
{
    int i;

    for (i = 0; i < size; i++) {
    a734:	42b3      	cmp	r3, r6
    a736:	da04      	bge.n	a742 <os_task_init+0x7a>
        stack_bottom[i] = OS_STACK_PATTERN;
    a738:	4a0e      	ldr	r2, [pc, #56]	; (a774 <os_task_init+0xac>)
    a73a:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
static void
_clear_stack(os_stack_t *stack_bottom, int size)
{
    int i;

    for (i = 0; i < size; i++) {
    a73e:	3301      	adds	r3, #1
    a740:	e7f8      	b.n	a734 <os_task_init+0x6c>
            goto err;
        }
    }

    _clear_stack(stack_bottom, stack_size);
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
    a742:	eb05 0586 	add.w	r5, r5, r6, lsl #2
    a746:	4632      	mov	r2, r6
    a748:	4620      	mov	r0, r4
    a74a:	4629      	mov	r1, r5
    a74c:	f7ff f8f6 	bl	993c <os_arch_task_stack_init>
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    t->t_stacksize = stack_size;

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    a750:	2300      	movs	r3, #0
    a752:	6423      	str	r3, [r4, #64]	; 0x40
    a754:	4b08      	ldr	r3, [pc, #32]	; (a778 <os_task_init+0xb0>)

    _clear_stack(stack_bottom, stack_size);
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    t->t_stacksize = stack_size;
    a756:	8126      	strh	r6, [r4, #8]

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    a758:	685a      	ldr	r2, [r3, #4]
    }

    _clear_stack(stack_bottom, stack_size);
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    a75a:	e884 0021 	stmia.w	r4, {r0, r5}
    t->t_stacksize = stack_size;

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    a75e:	6014      	str	r4, [r2, #0]

    /* insert this task into the scheduler list */
    rc = os_sched_insert(t);
    a760:	4620      	mov	r0, r4
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    t->t_stacksize = stack_size;

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    a762:	f104 0240 	add.w	r2, r4, #64	; 0x40
    a766:	605a      	str	r2, [r3, #4]

    /* insert this task into the scheduler list */
    rc = os_sched_insert(t);
    a768:	f7ff fe84 	bl	a474 <os_sched_insert>


    return (0);
err:
    return (rc);
}
    a76c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a770:	20002f44 	.word	0x20002f44
    a774:	deadbeef 	.word	0xdeadbeef
    a778:	20002f3c 	.word	0x20002f3c

0000a77c <os_deltatime>:
} basetod;

static void
os_deltatime(os_time_t delta, const struct os_timeval *base,
    struct os_timeval *result)
{
    a77c:	b530      	push	{r4, r5, lr}
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    os_timeradd(base, &tvdelta, result);
    a77e:	e9d1 4500 	ldrd	r4, r5, [r1]
os_deltatime(os_time_t delta, const struct os_timeval *base,
    struct os_timeval *result)
{
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    a782:	09c3      	lsrs	r3, r0, #7
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    os_timeradd(base, &tvdelta, result);
    a784:	6889      	ldr	r1, [r1, #8]
    a786:	18e4      	adds	r4, r4, r3
    struct os_timeval *result)
{
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    a788:	f000 037f 	and.w	r3, r0, #127	; 0x7f
    os_timeradd(base, &tvdelta, result);
    a78c:	f641 6084 	movw	r0, #7812	; 0x1e84
    a790:	fb00 1003 	mla	r0, r0, r3, r1
    a794:	4b09      	ldr	r3, [pc, #36]	; (a7bc <os_deltatime+0x40>)
    a796:	6090      	str	r0, [r2, #8]
    a798:	f145 0500 	adc.w	r5, r5, #0
    a79c:	4298      	cmp	r0, r3
    a79e:	e9c2 4500 	strd	r4, r5, [r2]
    a7a2:	dd09      	ble.n	a7b8 <os_deltatime+0x3c>
    a7a4:	3401      	adds	r4, #1
    a7a6:	f145 0500 	adc.w	r5, r5, #0
    a7aa:	f5a0 2074 	sub.w	r0, r0, #999424	; 0xf4000
    a7ae:	e9c2 4500 	strd	r4, r5, [r2]
    a7b2:	f5a0 7010 	sub.w	r0, r0, #576	; 0x240
    a7b6:	6090      	str	r0, [r2, #8]
    a7b8:	bd30      	pop	{r4, r5, pc}
    a7ba:	bf00      	nop
    a7bc:	000f423f 	.word	0x000f423f

0000a7c0 <os_time_get>:
 */
os_time_t
os_time_get(void)
{
    return (g_os_time);
}
    a7c0:	4b01      	ldr	r3, [pc, #4]	; (a7c8 <os_time_get+0x8>)
    a7c2:	6818      	ldr	r0, [r3, #0]
    a7c4:	4770      	bx	lr
    a7c6:	bf00      	nop
    a7c8:	20002f48 	.word	0x20002f48

0000a7cc <os_time_advance>:
 *
 * @param ticks The number of ticks to move time forward.
 */
void
os_time_advance(int ticks)
{
    a7cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    assert(ticks >= 0);
    a7ce:	1e04      	subs	r4, r0, #0
    a7d0:	da05      	bge.n	a7de <os_time_advance+0x12>
    a7d2:	2200      	movs	r2, #0
    a7d4:	4816      	ldr	r0, [pc, #88]	; (a830 <os_time_advance+0x64>)
    a7d6:	2161      	movs	r1, #97	; 0x61
    a7d8:	4613      	mov	r3, r2
    a7da:	f7ff fa79 	bl	9cd0 <__assert_func>

    if (ticks > 0) {
    a7de:	d026      	beq.n	a82e <os_time_advance+0x62>
    os_time_t delta, prev_os_time;

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    prev_os_time = g_os_time;
    a7e0:	4e14      	ldr	r6, [pc, #80]	; (a834 <os_time_advance+0x68>)
    os_sr_t sr;
    os_time_t delta, prev_os_time;

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    a7e2:	f7ff f89d 	bl	9920 <os_arch_save_sr>
    prev_os_time = g_os_time;
    a7e6:	6833      	ldr	r3, [r6, #0]
    os_sr_t sr;
    os_time_t delta, prev_os_time;

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    a7e8:	4607      	mov	r7, r0
    prev_os_time = g_os_time;
    g_os_time += ticks;
    a7ea:	18e0      	adds	r0, r4, r3

    /*
     * Update 'basetod' when 'g_os_time' crosses the 0x00000000 and
     * 0x80000000 thresholds.
     */
    if ((prev_os_time ^ g_os_time) >> 31) {
    a7ec:	ea90 0f03 	teq	r0, r3

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    prev_os_time = g_os_time;
    g_os_time += ticks;
    a7f0:	6030      	str	r0, [r6, #0]

    /*
     * Update 'basetod' when 'g_os_time' crosses the 0x00000000 and
     * 0x80000000 thresholds.
     */
    if ((prev_os_time ^ g_os_time) >> 31) {
    a7f2:	d510      	bpl.n	a816 <os_time_advance+0x4a>
        delta = g_os_time - basetod.ostime;
    a7f4:	4d10      	ldr	r5, [pc, #64]	; (a838 <os_time_advance+0x6c>)
    a7f6:	4629      	mov	r1, r5
    a7f8:	f851 4b08 	ldr.w	r4, [r1], #8
    a7fc:	1b04      	subs	r4, r0, r4
        os_deltatime(delta, &basetod.uptime, &basetod.uptime);
    a7fe:	460a      	mov	r2, r1
    a800:	4620      	mov	r0, r4
    a802:	f7ff ffbb 	bl	a77c <os_deltatime>
        os_deltatime(delta, &basetod.utctime, &basetod.utctime);
    a806:	f105 0118 	add.w	r1, r5, #24
    a80a:	4620      	mov	r0, r4
    a80c:	460a      	mov	r2, r1
    a80e:	f7ff ffb5 	bl	a77c <os_deltatime>
        basetod.ostime = g_os_time;
    a812:	6833      	ldr	r3, [r6, #0]
    a814:	602b      	str	r3, [r5, #0]
    }
    OS_EXIT_CRITICAL(sr);
    a816:	4638      	mov	r0, r7
    a818:	f7ff f888 	bl	992c <os_arch_restore_sr>
{
    assert(ticks >= 0);

    if (ticks > 0) {
        os_time_tick(ticks);
        os_callout_tick();
    a81c:	f7ff f9a2 	bl	9b64 <os_callout_tick>
        os_sched_os_timer_exp();
    a820:	f7ff fefe 	bl	a620 <os_sched_os_timer_exp>
        os_sched(NULL);
    a824:	2000      	movs	r0, #0
    }
}
    a826:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

    if (ticks > 0) {
        os_time_tick(ticks);
        os_callout_tick();
        os_sched_os_timer_exp();
        os_sched(NULL);
    a82a:	f7ff be6d 	b.w	a508 <os_sched>
    a82e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a830:	0001f221 	.word	0x0001f221
    a834:	20002f48 	.word	0x20002f48
    a838:	20001e60 	.word	0x20001e60

0000a83c <os_time_delay>:
 *
 * @param osticks Number of ticks to delay (<= 0 means no delay).
 */
void
os_time_delay(int32_t osticks)
{
    a83c:	b538      	push	{r3, r4, r5, lr}
    os_sr_t sr;

    if (osticks > 0) {
    a83e:	1e05      	subs	r5, r0, #0
    a840:	dd0f      	ble.n	a862 <os_time_delay+0x26>
        OS_ENTER_CRITICAL(sr);
    a842:	f7ff f86d 	bl	9920 <os_arch_save_sr>
    a846:	4604      	mov	r4, r0
        os_sched_sleep(os_sched_get_current_task(), (os_time_t)osticks);
    a848:	f7ff fe52 	bl	a4f0 <os_sched_get_current_task>
    a84c:	4629      	mov	r1, r5
    a84e:	f7ff fe73 	bl	a538 <os_sched_sleep>
        OS_EXIT_CRITICAL(sr);
    a852:	4620      	mov	r0, r4
    a854:	f7ff f86a 	bl	992c <os_arch_restore_sr>
        os_sched(NULL);
    a858:	2000      	movs	r0, #0
    }
}
    a85a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    if (osticks > 0) {
        OS_ENTER_CRITICAL(sr);
        os_sched_sleep(os_sched_get_current_task(), (os_time_t)osticks);
        OS_EXIT_CRITICAL(sr);
        os_sched(NULL);
    a85e:	f7ff be53 	b.w	a508 <os_sched>
    a862:	bd38      	pop	{r3, r4, r5, pc}

0000a864 <os_gettimeofday>:
 *
 * @return 0 on success, non-zero on failure
 */
int
os_gettimeofday(struct os_timeval *tv, struct os_timezone *tz)
{
    a864:	b570      	push	{r4, r5, r6, lr}
    a866:	4605      	mov	r5, r0
    a868:	460c      	mov	r4, r1
    os_sr_t sr;
    os_time_t delta;

    OS_ENTER_CRITICAL(sr);
    a86a:	f7ff f859 	bl	9920 <os_arch_save_sr>
    a86e:	4606      	mov	r6, r0
    if (tv != NULL) {
    a870:	b145      	cbz	r5, a884 <os_gettimeofday+0x20>
        delta = os_time_get() - basetod.ostime;
    a872:	4b09      	ldr	r3, [pc, #36]	; (a898 <os_gettimeofday+0x34>)
    a874:	4909      	ldr	r1, [pc, #36]	; (a89c <os_gettimeofday+0x38>)
    a876:	6818      	ldr	r0, [r3, #0]
    a878:	f851 3b18 	ldr.w	r3, [r1], #24
        os_deltatime(delta, &basetod.utctime, tv);
    a87c:	462a      	mov	r2, r5
    a87e:	1ac0      	subs	r0, r0, r3
    a880:	f7ff ff7c 	bl	a77c <os_deltatime>
    }

    if (tz != NULL) {
    a884:	b114      	cbz	r4, a88c <os_gettimeofday+0x28>
        *tz = basetod.timezone;
    a886:	4b06      	ldr	r3, [pc, #24]	; (a8a0 <os_gettimeofday+0x3c>)
    a888:	6818      	ldr	r0, [r3, #0]
    a88a:	6020      	str	r0, [r4, #0]
    }
    OS_EXIT_CRITICAL(sr);
    a88c:	4630      	mov	r0, r6
    a88e:	f7ff f84d 	bl	992c <os_arch_restore_sr>

    return (0);
}
    a892:	2000      	movs	r0, #0
    a894:	bd70      	pop	{r4, r5, r6, pc}
    a896:	bf00      	nop
    a898:	20002f48 	.word	0x20002f48
    a89c:	20001e60 	.word	0x20001e60
    a8a0:	20001e88 	.word	0x20001e88

0000a8a4 <os_get_uptime_usec>:
 *
 * @return time since boot in microseconds
 */
int64_t
os_get_uptime_usec(void)
{
    a8a4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  os_time_t delta;
  os_sr_t sr;
  os_time_t ostime;


  OS_ENTER_CRITICAL(sr);
    a8a6:	f7ff f83b 	bl	9920 <os_arch_save_sr>
  tv = basetod.uptime;
    a8aa:	4d11      	ldr	r5, [pc, #68]	; (a8f0 <os_get_uptime_usec+0x4c>)
    a8ac:	f105 0308 	add.w	r3, r5, #8
  os_time_t delta;
  os_sr_t sr;
  os_time_t ostime;


  OS_ENTER_CRITICAL(sr);
    a8b0:	4606      	mov	r6, r0
  tv = basetod.uptime;
    a8b2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    a8b4:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 * @return OS time in ticks
 */
os_time_t
os_time_get(void)
{
    return (g_os_time);
    a8b8:	4b0e      	ldr	r3, [pc, #56]	; (a8f4 <os_get_uptime_usec+0x50>)


  OS_ENTER_CRITICAL(sr);
  tv = basetod.uptime;
  ostime = basetod.ostime;
  delta = os_time_get() - ostime;
    a8ba:	682d      	ldr	r5, [r5, #0]
    a8bc:	681b      	ldr	r3, [r3, #0]
  os_sr_t sr;
  os_time_t ostime;


  OS_ENTER_CRITICAL(sr);
  tv = basetod.uptime;
    a8be:	466c      	mov	r4, sp
  ostime = basetod.ostime;
  delta = os_time_get() - ostime;
    a8c0:	1b5d      	subs	r5, r3, r5
  OS_EXIT_CRITICAL(sr);
    a8c2:	4630      	mov	r0, r6
    a8c4:	f7ff f832 	bl	992c <os_arch_restore_sr>

  os_deltatime(delta, &tv, &tv);
    a8c8:	4628      	mov	r0, r5
    a8ca:	4669      	mov	r1, sp
    a8cc:	4622      	mov	r2, r4
    a8ce:	f7ff ff55 	bl	a77c <os_deltatime>

  return(tv.tv_sec * 1000000 + tv.tv_usec);
    a8d2:	4909      	ldr	r1, [pc, #36]	; (a8f8 <os_get_uptime_usec+0x54>)
    a8d4:	9a00      	ldr	r2, [sp, #0]
    a8d6:	9801      	ldr	r0, [sp, #4]
    a8d8:	fba2 2301 	umull	r2, r3, r2, r1
    a8dc:	fb01 3300 	mla	r3, r1, r0, r3
}
    a8e0:	9802      	ldr	r0, [sp, #8]
    a8e2:	1814      	adds	r4, r2, r0
    a8e4:	eb43 75e0 	adc.w	r5, r3, r0, asr #31
    a8e8:	4629      	mov	r1, r5
    a8ea:	4620      	mov	r0, r4
    a8ec:	b004      	add	sp, #16
    a8ee:	bd70      	pop	{r4, r5, r6, pc}
    a8f0:	20001e60 	.word	0x20001e60
    a8f4:	20002f48 	.word	0x20002f48
    a8f8:	000f4240 	.word	0x000f4240

0000a8fc <os_time_ms_to_ticks>:
 * @return                      0 on success; OS_EINVAL if the result is too
 *                                  large to fit in a uint32_t.
 */
int
os_time_ms_to_ticks(uint32_t ms, uint32_t *out_ticks)
{
    a8fc:	b510      	push	{r4, lr}
    a8fe:	4603      	mov	r3, r0
    a900:	460c      	mov	r4, r1
#endif

    _Static_assert(OS_TICKS_PER_SEC <= UINT32_MAX,
                   "OS_TICKS_PER_SEC must be <= UINT32_MAX");

    ticks = (uint64_t)ms * OS_TICKS_PER_SEC / 1000;
    a902:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    a906:	0e59      	lsrs	r1, r3, #25
    a908:	01c0      	lsls	r0, r0, #7
    a90a:	2300      	movs	r3, #0
    a90c:	f013 fe8a 	bl	1e624 <__aeabi_uldivmod>
    if (ticks > UINT32_MAX) {
        return OS_EINVAL;
    }

    *out_ticks = ticks;
    a910:	6020      	str	r0, [r4, #0]
    return 0;
}
    a912:	2000      	movs	r0, #0
    a914:	bd10      	pop	{r4, pc}
	...

0000a918 <os_set_env>:
        .global os_set_env
os_set_env:
        .fnstart
        .cantunwind

        MOV     R0,SP           /* Copy MSP to PSP */
    a918:	4668      	mov	r0, sp
        MSR     PSP,R0
    a91a:	f380 8809 	msr	PSP, r0
        LDR     R0,=os_flags
    a91e:	482c      	ldr	r0, [pc, #176]	; (a9d0 <os_default_irq_asm+0x20>)
        LDRB    R0,[R0]
    a920:	7800      	ldrb	r0, [r0, #0]
        ADDS    R0, R0, #2
    a922:	3002      	adds	r0, #2
        MSR     CONTROL,R0
    a924:	f380 8814 	msr	CONTROL, r0
        ISB
    a928:	f3bf 8f6f 	isb	sy
        BX      LR
    a92c:	4770      	bx	lr

0000a92e <os_arch_init_task_stack>:
        .type   os_arch_init_task_stack, %function
        .global os_arch_init_task_stack
os_arch_init_task_stack:
        .fnstart

        STMIA   R0,{R4-R11}
    a92e:	e880 0ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
        BX      LR
    a932:	4770      	bx	lr

0000a934 <SVC_Handler>:
        .global SVC_Handler
SVC_Handler:
        .fnstart
        .cantunwind

        MRS     R0,PSP                  /* Read PSP */
    a934:	f3ef 8009 	mrs	r0, PSP
        LDR     R1,[R0,#24]             /* Read Saved PC from Stack */
    a938:	6981      	ldr	r1, [r0, #24]
        LDRB    R1,[R1,#-2]             /* Load SVC Number */
    a93a:	f811 1c02 	ldrb.w	r1, [r1, #-2]
        CBNZ    R1,SVC_User
    a93e:	b951      	cbnz	r1, a956 <SVC_User>

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
    a940:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    a944:	b510      	push	{r4, lr}
        BLX     R12                     /* Call SVC Function */
    a946:	47e0      	blx	ip
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    a948:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

        MRS     R12,PSP                 /* Read PSP */
    a94c:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R2}             /* Store return values */
    a950:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
        BX      LR                      /* Return from interrupt */
    a954:	4770      	bx	lr

0000a956 <SVC_User>:

        /*------------------- User SVC ------------------------------*/
SVC_User:
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    a956:	b510      	push	{r4, lr}
        LDR     R2,=SVC_Count
    a958:	4a1e      	ldr	r2, [pc, #120]	; (a9d4 <os_default_irq_asm+0x24>)
        LDR     R2,[R2]
    a95a:	6812      	ldr	r2, [r2, #0]
        CMP     R1,R2
    a95c:	4291      	cmp	r1, r2
        BHI     SVC_Done                /* Overflow */
    a95e:	d809      	bhi.n	a974 <SVC_Done>

        LDR     R4,=SVC_Table-4
    a960:	4c1d      	ldr	r4, [pc, #116]	; (a9d8 <os_default_irq_asm+0x28>)
        LDR     R4,[R4,R1,LSL #2]       /* Load SVC Function Address */
    a962:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
    a966:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        BLX     R4                      /* Call SVC Function */
    a96a:	47a0      	blx	r4

        MRS     R12,PSP
    a96c:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R3}             /* Function return values */
    a970:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

0000a974 <SVC_Done>:
SVC_Done:
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    a974:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR                      /* Return from interrupt */
    a978:	4770      	bx	lr

0000a97a <PendSV_Handler>:
        .global PendSV_Handler
PendSV_Handler:
        .fnstart
        .cantunwind

        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
    a97a:	4b18      	ldr	r3, [pc, #96]	; (a9dc <os_default_irq_asm+0x2c>)
        LDR     R2,[R3]                 /* Store in R2 */
    a97c:	681a      	ldr	r2, [r3, #0]
        LDR     R3,=g_current_task      /* Get current task */
    a97e:	4b18      	ldr	r3, [pc, #96]	; (a9e0 <os_default_irq_asm+0x30>)
        LDR     R1,[R3]                 /* Current task in R1 */
    a980:	6819      	ldr	r1, [r3, #0]
        CMP     R1,R2
    a982:	4291      	cmp	r1, r2
        IT      EQ
    a984:	bf08      	it	eq
        BXEQ    LR                      /* RETI, no task switch */
    a986:	4770      	bxeq	lr

        MRS     R12,PSP                 /* Read PSP */
    a988:	f3ef 8c09 	mrs	ip, PSP
        STMDB   R12!,{R4-R11}           /* Save Old context */
    a98c:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
        STR     R12,[R1,#0]             /* Update stack pointer in current task */
    a990:	f8c1 c000 	str.w	ip, [r1]
        STR     R2,[R3]                 /* g_current_task = highest ready */
    a994:	601a      	str	r2, [r3, #0]

        LDR     R12,[R2,#0]             /* get stack pointer of task we will start */
    a996:	f8d2 c000 	ldr.w	ip, [r2]
        LDMIA   R12!,{R4-R11}           /* Restore New Context */
    a99a:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
        MSR     PSP,R12                 /* Write PSP */
    a99e:	f38c 8809 	msr	PSP, ip
        BX      LR                      /* Return to Thread Mode */
    a9a2:	4770      	bx	lr

0000a9a4 <SysTick_Handler>:
        .global SysTick_Handler
SysTick_Handler:
        .fnstart
        .cantunwind

        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    a9a4:	b510      	push	{r4, lr}
        BL      timer_handler
    a9a6:	f7fe ffad 	bl	9904 <timer_handler>
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    a9aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR
    a9ae:	4770      	bx	lr

0000a9b0 <os_default_irq_asm>:

        /*
         * LR = 0xfffffff9 if we were using MSP as SP
         * LR = 0xfffffffd if we were using PSP as SP
         */
        TST     LR,#4
    a9b0:	f01e 0f04 	tst.w	lr, #4
        ITE     EQ
    a9b4:	bf0c      	ite	eq
        MRSEQ   R3,MSP
    a9b6:	f3ef 8308 	mrseq	r3, MSP
        MRSNE   R3,PSP
    a9ba:	f3ef 8309 	mrsne	r3, PSP
        PUSH    {R3-R11,LR}
    a9be:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        MOV     R0, SP
    a9c2:	4668      	mov	r0, sp
        BL      os_default_irq
    a9c4:	f7ff f9a8 	bl	9d18 <os_default_irq>
        POP     {R3-R11,LR}                 /* Restore EXC_RETURN */
    a9c8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        BX      LR
    a9cc:	4770      	bx	lr
    a9ce:	0000      	.short	0x0000
        .fnstart
        .cantunwind

        MOV     R0,SP           /* Copy MSP to PSP */
        MSR     PSP,R0
        LDR     R0,=os_flags
    a9d0:	20001e58 	.word	0x20001e58
        BX      LR                      /* Return from interrupt */

        /*------------------- User SVC ------------------------------*/
SVC_User:
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
        LDR     R2,=SVC_Count
    a9d4:	00000000 	.word	0x00000000
        LDR     R2,[R2]
        CMP     R1,R2
        BHI     SVC_Done                /* Overflow */

        LDR     R4,=SVC_Table-4
    a9d8:	fffffffc 	.word	0xfffffffc
        .global PendSV_Handler
PendSV_Handler:
        .fnstart
        .cantunwind

        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
    a9dc:	2000022c 	.word	0x2000022c
        LDR     R2,[R3]                 /* Store in R2 */
        LDR     R3,=g_current_task      /* Get current task */
    a9e0:	20002f34 	.word	0x20002f34

0000a9e4 <os_sanity_check_list_lock>:
 *
 * @return 0 on success, error code on failure. 
 */
static int
os_sanity_check_list_lock(void)
{
    a9e4:	b508      	push	{r3, lr}
    int rc; 

    if (!g_os_started) {
    a9e6:	4b04      	ldr	r3, [pc, #16]	; (a9f8 <os_sanity_check_list_lock+0x14>)
    a9e8:	6818      	ldr	r0, [r3, #0]
    a9ea:	b120      	cbz	r0, a9f6 <os_sanity_check_list_lock+0x12>
        return (0);
    }

    rc = os_mutex_pend(&g_os_sanity_check_mu, OS_WAIT_FOREVER);
    a9ec:	4803      	ldr	r0, [pc, #12]	; (a9fc <os_sanity_check_list_lock+0x18>)
    a9ee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    a9f2:	f000 f87b 	bl	aaec <os_mutex_pend>
    }

    return (0);
err:
    return (rc);
}
    a9f6:	bd08      	pop	{r3, pc}
    a9f8:	20002f28 	.word	0x20002f28
    a9fc:	20002f50 	.word	0x20002f50

0000aa00 <os_sanity_check_list_unlock>:
 *
 * @return 0 on success, error code on failure
 */
static int 
os_sanity_check_list_unlock(void)
{
    aa00:	b508      	push	{r3, lr}
    int rc; 

    if (!g_os_started) {
    aa02:	4b03      	ldr	r3, [pc, #12]	; (aa10 <os_sanity_check_list_unlock+0x10>)
    aa04:	6818      	ldr	r0, [r3, #0]
    aa06:	b110      	cbz	r0, aa0e <os_sanity_check_list_unlock+0xe>
        return (0);
    }

    rc = os_mutex_release(&g_os_sanity_check_mu);
    aa08:	4802      	ldr	r0, [pc, #8]	; (aa14 <os_sanity_check_list_unlock+0x14>)
    aa0a:	f000 f827 	bl	aa5c <os_mutex_release>
    }

    return (0);
err:
    return (rc);
}
    aa0e:	bd08      	pop	{r3, pc}
    aa10:	20002f28 	.word	0x20002f28
    aa14:	20002f50 	.word	0x20002f50

0000aa18 <os_sanity_check_init>:
 *
 * @return 0 on success, error code on failure.
 */
int 
os_sanity_check_init(struct os_sanity_check *sc)
{
    aa18:	b508      	push	{r3, lr}
    memset(sc, 0, sizeof(*sc)); 
    aa1a:	2100      	movs	r1, #0
    aa1c:	2214      	movs	r2, #20
    aa1e:	f7fe faf8 	bl	9012 <memset>

    return (0);
}
    aa22:	2000      	movs	r0, #0
    aa24:	bd08      	pop	{r3, pc}
	...

0000aa28 <os_sanity_check_register>:
 *
 * @return 0 on success, error code on failure
 */
int 
os_sanity_check_register(struct os_sanity_check *sc)
{
    aa28:	b510      	push	{r4, lr}
    aa2a:	4604      	mov	r4, r0
    int rc;

    rc = os_sanity_check_list_lock();
    aa2c:	f7ff ffda 	bl	a9e4 <os_sanity_check_list_lock>
    if (rc != OS_OK) {
    aa30:	b938      	cbnz	r0, aa42 <os_sanity_check_register+0x1a>
        goto err;
    }

    SLIST_INSERT_HEAD(&g_os_sanity_check_list, sc, sc_next);
    aa32:	4b04      	ldr	r3, [pc, #16]	; (aa44 <os_sanity_check_register+0x1c>)
    aa34:	681a      	ldr	r2, [r3, #0]
    aa36:	6122      	str	r2, [r4, #16]
    aa38:	601c      	str	r4, [r3, #0]
    }

    return (0);
err:
    return (rc);
}
    aa3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        goto err;
    }

    SLIST_INSERT_HEAD(&g_os_sanity_check_list, sc, sc_next);

    rc = os_sanity_check_list_unlock();
    aa3e:	f7ff bfdf 	b.w	aa00 <os_sanity_check_list_unlock>
    }

    return (0);
err:
    return (rc);
}
    aa42:	bd10      	pop	{r4, pc}
    aa44:	20001e90 	.word	0x20001e90

0000aa48 <os_mutex_init>:
 *      OS_OK               no error.
 */
os_error_t
os_mutex_init(struct os_mutex *mu)
{
    if (!mu) {
    aa48:	b130      	cbz	r0, aa58 <os_mutex_init+0x10>
        return OS_INVALID_PARM;
    }

    /* Initialize to 0 */
    mu->mu_prio = 0;
    aa4a:	2300      	movs	r3, #0
    aa4c:	7143      	strb	r3, [r0, #5]
    mu->mu_level = 0;
    aa4e:	80c3      	strh	r3, [r0, #6]
    mu->mu_owner = NULL;
    aa50:	6083      	str	r3, [r0, #8]
    SLIST_FIRST(&mu->mu_head) = NULL;
    aa52:	6003      	str	r3, [r0, #0]

    return OS_OK;
    aa54:	4618      	mov	r0, r3
    aa56:	4770      	bx	lr
 */
os_error_t
os_mutex_init(struct os_mutex *mu)
{
    if (!mu) {
        return OS_INVALID_PARM;
    aa58:	2003      	movs	r0, #3
    mu->mu_level = 0;
    mu->mu_owner = NULL;
    SLIST_FIRST(&mu->mu_head) = NULL;

    return OS_OK;
}
    aa5a:	4770      	bx	lr

0000aa5c <os_mutex_release>:
 *      OS_BAD_MUTEX    Mutex was not granted to current task (not owner).
 *      OS_OK           No error
 */
os_error_t
os_mutex_release(struct os_mutex *mu)
{
    aa5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_sr_t sr;
    struct os_task *current;
    struct os_task *rdy;

    /* Check if OS is started */
    if (!g_os_started) {
    aa5e:	4b21      	ldr	r3, [pc, #132]	; (aae4 <os_mutex_release+0x88>)
    aa60:	681b      	ldr	r3, [r3, #0]
 *      OS_BAD_MUTEX    Mutex was not granted to current task (not owner).
 *      OS_OK           No error
 */
os_error_t
os_mutex_release(struct os_mutex *mu)
{
    aa62:	4604      	mov	r4, r0
    os_sr_t sr;
    struct os_task *current;
    struct os_task *rdy;

    /* Check if OS is started */
    if (!g_os_started) {
    aa64:	2b00      	cmp	r3, #0
    aa66:	d036      	beq.n	aad6 <os_mutex_release+0x7a>
        return (OS_NOT_STARTED);
    }

    /* Check for valid mutex */
    if (!mu) {
    aa68:	2800      	cmp	r0, #0
    aa6a:	d036      	beq.n	aada <os_mutex_release+0x7e>
        return OS_INVALID_PARM;
    }

    /* We better own this mutex! */
    current = os_sched_get_current_task();
    aa6c:	f7ff fd40 	bl	a4f0 <os_sched_get_current_task>
    if ((mu->mu_level == 0) || (mu->mu_owner != current)) {
    aa70:	88e3      	ldrh	r3, [r4, #6]
    aa72:	2b00      	cmp	r3, #0
    aa74:	d033      	beq.n	aade <os_mutex_release+0x82>
    aa76:	68a5      	ldr	r5, [r4, #8]
    aa78:	4285      	cmp	r5, r0
    aa7a:	d130      	bne.n	aade <os_mutex_release+0x82>
        return (OS_BAD_MUTEX);
    }

    /* Decrement nesting level by 1. If not zero, nested (so dont release!) */
    --mu->mu_level;
    aa7c:	3b01      	subs	r3, #1
    aa7e:	b29b      	uxth	r3, r3
    aa80:	80e3      	strh	r3, [r4, #6]
    if (mu->mu_level != 0) {
    aa82:	bb33      	cbnz	r3, aad2 <os_mutex_release+0x76>
        return (OS_OK);
    }

    OS_ENTER_CRITICAL(sr);
    aa84:	f7fe ff4c 	bl	9920 <os_arch_save_sr>

    /* Restore owner task's priority; resort list if different  */
    if (current->t_prio != mu->mu_prio) {
    aa88:	7963      	ldrb	r3, [r4, #5]
    aa8a:	7b6a      	ldrb	r2, [r5, #13]
    aa8c:	429a      	cmp	r2, r3
    --mu->mu_level;
    if (mu->mu_level != 0) {
        return (OS_OK);
    }

    OS_ENTER_CRITICAL(sr);
    aa8e:	4607      	mov	r7, r0

    /* Restore owner task's priority; resort list if different  */
    if (current->t_prio != mu->mu_prio) {
    aa90:	d003      	beq.n	aa9a <os_mutex_release+0x3e>
        current->t_prio = mu->mu_prio;
    aa92:	736b      	strb	r3, [r5, #13]
        os_sched_resort(current);
    aa94:	4628      	mov	r0, r5
    aa96:	f7ff fe05 	bl	a6a4 <os_sched_resort>
    }

    /* Check if tasks are waiting for the mutex */
    rdy = SLIST_FIRST(&mu->mu_head);
    aa9a:	6826      	ldr	r6, [r4, #0]
    if (rdy) {
    aa9c:	b16e      	cbz	r6, aaba <os_mutex_release+0x5e>
        /* There is one waiting. Wake it up */
        assert(rdy->t_obj);
    aa9e:	69f2      	ldr	r2, [r6, #28]
    aaa0:	b922      	cbnz	r2, aaac <os_mutex_release+0x50>
    aaa2:	4811      	ldr	r0, [pc, #68]	; (aae8 <os_mutex_release+0x8c>)
    aaa4:	2168      	movs	r1, #104	; 0x68
    aaa6:	4613      	mov	r3, r2
    aaa8:	f7ff f912 	bl	9cd0 <__assert_func>
        os_sched_wakeup(rdy);
    aaac:	4630      	mov	r0, r6
    aaae:	f7ff fd7d 	bl	a5ac <os_sched_wakeup>

        /* Set mutex internals */
        mu->mu_level = 1;
    aab2:	2301      	movs	r3, #1
    aab4:	80e3      	strh	r3, [r4, #6]
        mu->mu_prio = rdy->t_prio;
    aab6:	7b73      	ldrb	r3, [r6, #13]
    aab8:	7163      	strb	r3, [r4, #5]
    }

    /* Set new owner of mutex (or NULL if not owned) */
    mu->mu_owner = rdy;
    aaba:	60a6      	str	r6, [r4, #8]

    /* Do we need to re-schedule? */
    resched = 0;
    rdy = os_sched_next_task();
    aabc:	f7ff fdec 	bl	a698 <os_sched_next_task>
    aac0:	4604      	mov	r4, r0
    if (rdy != current) {
        resched = 1;
    }
    OS_EXIT_CRITICAL(sr);
    aac2:	4638      	mov	r0, r7
    aac4:	f7fe ff32 	bl	992c <os_arch_restore_sr>

    /* Re-schedule if needed */
    if (resched) {
    aac8:	42ac      	cmp	r4, r5
    aaca:	d002      	beq.n	aad2 <os_mutex_release+0x76>
        os_sched(rdy);
    aacc:	4620      	mov	r0, r4
    aace:	f7ff fd1b 	bl	a508 <os_sched>
    }

    return OS_OK;
    aad2:	2000      	movs	r0, #0
    aad4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    struct os_task *current;
    struct os_task *rdy;

    /* Check if OS is started */
    if (!g_os_started) {
        return (OS_NOT_STARTED);
    aad6:	2009      	movs	r0, #9
    aad8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Check for valid mutex */
    if (!mu) {
        return OS_INVALID_PARM;
    aada:	2003      	movs	r0, #3
    aadc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* We better own this mutex! */
    current = os_sched_get_current_task();
    if ((mu->mu_level == 0) || (mu->mu_owner != current)) {
        return (OS_BAD_MUTEX);
    aade:	2005      	movs	r0, #5
    if (resched) {
        os_sched(rdy);
    }

    return OS_OK;
}
    aae0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aae2:	bf00      	nop
    aae4:	20002f28 	.word	0x20002f28
    aae8:	0001f22b 	.word	0x0001f22b

0000aaec <os_mutex_pend>:
    struct os_task *current;
    struct os_task *entry;
    struct os_task *last;

    /* OS must be started when calling this function */
    if (!g_os_started) {
    aaec:	4b36      	ldr	r3, [pc, #216]	; (abc8 <os_mutex_pend+0xdc>)
    aaee:	681b      	ldr	r3, [r3, #0]
 *      OS_TIMEOUT          Mutex was owned by another task and timeout=0
 *      OS_OK               no error.
 */ 
os_error_t
os_mutex_pend(struct os_mutex *mu, uint32_t timeout)
{
    aaf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    aaf4:	4606      	mov	r6, r0
    aaf6:	4688      	mov	r8, r1
    struct os_task *current;
    struct os_task *entry;
    struct os_task *last;

    /* OS must be started when calling this function */
    if (!g_os_started) {
    aaf8:	2b00      	cmp	r3, #0
    aafa:	d05e      	beq.n	abba <os_mutex_pend+0xce>
        return (OS_NOT_STARTED);
    }

    /* Check for valid mutex */
    if (!mu) {
    aafc:	2800      	cmp	r0, #0
    aafe:	d05f      	beq.n	abc0 <os_mutex_pend+0xd4>
        return OS_INVALID_PARM;
    }

    OS_ENTER_CRITICAL(sr);
    ab00:	f7fe ff0e 	bl	9920 <os_arch_save_sr>
    ab04:	4607      	mov	r7, r0

    /* Is this owned? */
    current = os_sched_get_current_task();
    ab06:	f7ff fcf3 	bl	a4f0 <os_sched_get_current_task>
    if (mu->mu_level == 0) {
    ab0a:	88f5      	ldrh	r5, [r6, #6]
    }

    OS_ENTER_CRITICAL(sr);

    /* Is this owned? */
    current = os_sched_get_current_task();
    ab0c:	4604      	mov	r4, r0
    if (mu->mu_level == 0) {
    ab0e:	b92d      	cbnz	r5, ab1c <os_mutex_pend+0x30>
        mu->mu_owner = current;
    ab10:	60b0      	str	r0, [r6, #8]
        mu->mu_prio  = current->t_prio;
    ab12:	7b43      	ldrb	r3, [r0, #13]
    ab14:	7173      	strb	r3, [r6, #5]
        mu->mu_level = 1;
    ab16:	2301      	movs	r3, #1
    ab18:	80f3      	strh	r3, [r6, #6]
    ab1a:	e004      	b.n	ab26 <os_mutex_pend+0x3a>
        OS_EXIT_CRITICAL(sr);
        return OS_OK;
    }

    /* Are we owner? */
    if (mu->mu_owner == current) {
    ab1c:	68b3      	ldr	r3, [r6, #8]
    ab1e:	4283      	cmp	r3, r0
    ab20:	d107      	bne.n	ab32 <os_mutex_pend+0x46>
        ++mu->mu_level;
    ab22:	1c68      	adds	r0, r5, #1
    ab24:	80f0      	strh	r0, [r6, #6]
        OS_EXIT_CRITICAL(sr);
    ab26:	4638      	mov	r0, r7
    ab28:	f7fe ff00 	bl	992c <os_arch_restore_sr>
        return OS_OK;
    ab2c:	2000      	movs	r0, #0
    ab2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /* Mutex is not owned by us. If timeout is 0, return immediately */
    if (timeout == 0) {
    ab32:	f1b8 0f00 	cmp.w	r8, #0
    ab36:	d105      	bne.n	ab44 <os_mutex_pend+0x58>
        OS_EXIT_CRITICAL(sr);
    ab38:	4638      	mov	r0, r7
    ab3a:	f7fe fef7 	bl	992c <os_arch_restore_sr>
        return OS_TIMEOUT;
    ab3e:	2006      	movs	r0, #6
    ab40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /* Change priority of owner if needed */
    if (mu->mu_owner->t_prio > current->t_prio) {
    ab44:	7b42      	ldrb	r2, [r0, #13]
    ab46:	7b59      	ldrb	r1, [r3, #13]
    ab48:	4291      	cmp	r1, r2
    ab4a:	d903      	bls.n	ab54 <os_mutex_pend+0x68>
        mu->mu_owner->t_prio = current->t_prio;
    ab4c:	735a      	strb	r2, [r3, #13]
        os_sched_resort(mu->mu_owner);
    ab4e:	68b0      	ldr	r0, [r6, #8]
    ab50:	f7ff fda8 	bl	a6a4 <os_sched_resort>
    }

    /* Link current task to tasks waiting for mutex */
    last = NULL;
    if (!SLIST_EMPTY(&mu->mu_head)) {
    ab54:	6832      	ldr	r2, [r6, #0]
    ab56:	b182      	cbz	r2, ab7a <os_mutex_pend+0x8e>
        /* Insert in priority order */
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
            if (current->t_prio < entry->t_prio) { 
    ab58:	7b65      	ldrb	r5, [r4, #13]
    ab5a:	4613      	mov	r3, r2
    ab5c:	2100      	movs	r1, #0
    ab5e:	7b58      	ldrb	r0, [r3, #13]
    ab60:	42a8      	cmp	r0, r5
    ab62:	d804      	bhi.n	ab6e <os_mutex_pend+0x82>

    /* Link current task to tasks waiting for mutex */
    last = NULL;
    if (!SLIST_EMPTY(&mu->mu_head)) {
        /* Insert in priority order */
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
    ab64:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
    ab66:	4619      	mov	r1, r3
    ab68:	b118      	cbz	r0, ab72 <os_mutex_pend+0x86>
    ab6a:	4603      	mov	r3, r0
    ab6c:	e7f7      	b.n	ab5e <os_mutex_pend+0x72>
            }
            last = entry;
        }
    }

    if (last) {
    ab6e:	460b      	mov	r3, r1
    ab70:	b119      	cbz	r1, ab7a <os_mutex_pend+0x8e>
        SLIST_INSERT_AFTER(last, current, t_obj_list);
    ab72:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    ab74:	64e2      	str	r2, [r4, #76]	; 0x4c
    ab76:	64dc      	str	r4, [r3, #76]	; 0x4c
    ab78:	e001      	b.n	ab7e <os_mutex_pend+0x92>
    } else {
        SLIST_INSERT_HEAD(&mu->mu_head, current, t_obj_list);
    ab7a:	64e2      	str	r2, [r4, #76]	; 0x4c
    ab7c:	6034      	str	r4, [r6, #0]
    }

    /* Set mutex pointer in task */
    current->t_obj = mu;
    current->t_flags |= OS_TASK_FLAG_MUTEX_WAIT;
    ab7e:	7be3      	ldrb	r3, [r4, #15]
    } else {
        SLIST_INSERT_HEAD(&mu->mu_head, current, t_obj_list);
    }

    /* Set mutex pointer in task */
    current->t_obj = mu;
    ab80:	61e6      	str	r6, [r4, #28]
    current->t_flags |= OS_TASK_FLAG_MUTEX_WAIT;
    ab82:	f043 0304 	orr.w	r3, r3, #4
    ab86:	73e3      	strb	r3, [r4, #15]
    os_sched_sleep(current, timeout);
    ab88:	4641      	mov	r1, r8
    ab8a:	4620      	mov	r0, r4
    ab8c:	f7ff fcd4 	bl	a538 <os_sched_sleep>
    OS_EXIT_CRITICAL(sr);
    ab90:	4638      	mov	r0, r7
    ab92:	f7fe fecb 	bl	992c <os_arch_restore_sr>

    os_sched(NULL);
    ab96:	2000      	movs	r0, #0
    ab98:	f7ff fcb6 	bl	a508 <os_sched>

    OS_ENTER_CRITICAL(sr);
    ab9c:	f7fe fec0 	bl	9920 <os_arch_save_sr>
    current->t_flags &= ~OS_TASK_FLAG_MUTEX_WAIT;
    aba0:	7be3      	ldrb	r3, [r4, #15]
    aba2:	f023 0304 	bic.w	r3, r3, #4
    aba6:	73e3      	strb	r3, [r4, #15]
    OS_EXIT_CRITICAL(sr);
    aba8:	f7fe fec0 	bl	992c <os_arch_restore_sr>

    /* If we are owner we did not time out. */
    if (mu->mu_owner == current) {
    abac:	68b0      	ldr	r0, [r6, #8]
        rc = OS_OK; 
    } else {
        rc = OS_TIMEOUT;
    abae:	42a0      	cmp	r0, r4
    abb0:	bf14      	ite	ne
    abb2:	2006      	movne	r0, #6
    abb4:	2000      	moveq	r0, #0
    abb6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    struct os_task *entry;
    struct os_task *last;

    /* OS must be started when calling this function */
    if (!g_os_started) {
        return (OS_NOT_STARTED);
    abba:	2009      	movs	r0, #9
    abbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /* Check for valid mutex */
    if (!mu) {
        return OS_INVALID_PARM;
    abc0:	2003      	movs	r0, #3
    } else {
        rc = OS_TIMEOUT;
    }

    return rc;
}
    abc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    abc6:	bf00      	nop
    abc8:	20002f28 	.word	0x20002f28

0000abcc <ble_ll_wfr_timer_exp>:
 *
 * @param arg
 */
void
ble_ll_wfr_timer_exp(void *arg)
{
    abcc:	b508      	push	{r3, lr}
    int rx_start;
    uint8_t lls;

    rx_start = ble_phy_rx_started();
    abce:	f006 fd65 	bl	1169c <ble_phy_rx_started>
    lls = g_ble_ll_data.ll_state;
    abd2:	4b0b      	ldr	r3, [pc, #44]	; (ac00 <ble_ll_wfr_timer_exp+0x34>)
    abd4:	781b      	ldrb	r3, [r3, #0]

    ble_ll_log(BLE_LL_LOG_ID_WFR_EXP, lls, ble_phy_xcvr_state_get(),
               (uint32_t)rx_start);

    /* If we have started a reception, there is nothing to do here */
    if (!rx_start) {
    abd6:	b988      	cbnz	r0, abfc <ble_ll_wfr_timer_exp+0x30>
        switch (lls) {
    abd8:	2b02      	cmp	r3, #2
    abda:	d00b      	beq.n	abf4 <ble_ll_wfr_timer_exp+0x28>
    abdc:	2b04      	cmp	r3, #4
    abde:	d005      	beq.n	abec <ble_ll_wfr_timer_exp+0x20>
    abe0:	2b01      	cmp	r3, #1
    abe2:	d10b      	bne.n	abfc <ble_ll_wfr_timer_exp+0x30>
        case BLE_LL_STATE_INITIATING:
        default:
            break;
        }
    }
}
    abe4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

    /* If we have started a reception, there is nothing to do here */
    if (!rx_start) {
        switch (lls) {
        case BLE_LL_STATE_ADV:
            ble_ll_adv_wfr_timer_exp();
    abe8:	f000 bf9e 	b.w	bb28 <ble_ll_adv_wfr_timer_exp>
        case BLE_LL_STATE_INITIATING:
        default:
            break;
        }
    }
}
    abec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        switch (lls) {
        case BLE_LL_STATE_ADV:
            ble_ll_adv_wfr_timer_exp();
            break;
        case BLE_LL_STATE_CONNECTION:
            ble_ll_conn_wfr_timer_exp();
    abf0:	f001 bc7a 	b.w	c4e8 <ble_ll_conn_wfr_timer_exp>
        case BLE_LL_STATE_INITIATING:
        default:
            break;
        }
    }
}
    abf4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            break;
        case BLE_LL_STATE_CONNECTION:
            ble_ll_conn_wfr_timer_exp();
            break;
        case BLE_LL_STATE_SCANNING:
            ble_ll_scan_wfr_timer_exp();
    abf8:	f005 b97c 	b.w	fef4 <ble_ll_scan_wfr_timer_exp>
    abfc:	bd08      	pop	{r3, pc}
    abfe:	bf00      	nop
    ac00:	200032c0 	.word	0x200032c0

0000ac04 <ble_ll_flush_pkt_queue>:
 *
 * @param pktq
 */
static void
ble_ll_flush_pkt_queue(struct ble_ll_pkt_q *pktq)
{
    ac04:	b510      	push	{r4, lr}
    ac06:	4604      	mov	r4, r0
    struct os_mbuf_pkthdr *pkthdr;
    struct os_mbuf *om;

    /* FLush all packets from Link layer queues */
    while (STAILQ_FIRST(pktq)) {
    ac08:	6823      	ldr	r3, [r4, #0]
    ac0a:	b143      	cbz	r3, ac1e <ble_ll_flush_pkt_queue+0x1a>
        /* Get mbuf pointer from packet header pointer */
        pkthdr = STAILQ_FIRST(pktq);
        om = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
    ac0c:	f1a3 0010 	sub.w	r0, r3, #16

        /* Remove from queue and free the mbuf */
        STAILQ_REMOVE_HEAD(pktq, omp_next);
    ac10:	685b      	ldr	r3, [r3, #4]
    ac12:	6023      	str	r3, [r4, #0]
    ac14:	b903      	cbnz	r3, ac18 <ble_ll_flush_pkt_queue+0x14>
    ac16:	6064      	str	r4, [r4, #4]
        os_mbuf_free_chain(om);
    ac18:	f7ff f9a1 	bl	9f5e <os_mbuf_free_chain>
    ac1c:	e7f4      	b.n	ac08 <ble_ll_flush_pkt_queue+0x4>
    }
}
    ac1e:	bd10      	pop	{r4, pc}

0000ac20 <ble_ll_task>:
 *
 * @param arg
 */
void
ble_ll_task(void *arg)
{
    ac20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    struct os_event *ev;
    struct os_callout_func *cf;

    /* Init ble phy */
    ble_phy_init();
    ac22:	f006 f997 	bl	10f54 <ble_phy_init>

    /* Set output power to 1mW (0 dBm) */
    ble_phy_txpwr_set(NIMBLE_OPT_LL_TX_PWR_DBM);
    ac26:	2000      	movs	r0, #0
    ac28:	f006 fa84 	bl	11134 <ble_phy_txpwr_set>

    /* Tell the host that we are ready to receive packets */
    ble_ll_hci_send_noop();
    ac2c:	f003 ff9c 	bl	eb68 <ble_ll_hci_send_noop>

    ble_ll_rand_start();
    ac30:	f004 fc74 	bl	f51c <ble_ll_rand_start>

    /* Wait for an event */
    while (1) {
        ev = os_eventq_get(&g_ble_ll_data.ll_evq);
    ac34:	487c      	ldr	r0, [pc, #496]	; (ae28 <ble_ll_task+0x208>)
    ac36:	f7ff f806 	bl	9c46 <os_eventq_get>
        switch (ev->ev_type) {
    ac3a:	7843      	ldrb	r3, [r0, #1]
    ac3c:	3b01      	subs	r3, #1
    ac3e:	2b15      	cmp	r3, #21
    ac40:	f200 80eb 	bhi.w	ae1a <ble_ll_task+0x1fa>
    ac44:	e8df f013 	tbh	[pc, r3, lsl #1]
    ac48:	00e90016 	.word	0x00e90016
    ac4c:	00e900e9 	.word	0x00e900e9
    ac50:	00e900e9 	.word	0x00e900e9
    ac54:	00e900e9 	.word	0x00e900e9
    ac58:	00e900e9 	.word	0x00e900e9
    ac5c:	00e900e9 	.word	0x00e900e9
    ac60:	00e900e9 	.word	0x00e900e9
    ac64:	001f00e9 	.word	0x001f00e9
    ac68:	00540022 	.word	0x00540022
    ac6c:	00e10026 	.word	0x00e10026
    ac70:	00d000e5 	.word	0x00d000e5
        case OS_EVENT_T_TIMER:
            cf = (struct os_callout_func *)ev;
            assert(cf->cf_func);
    ac74:	69c2      	ldr	r2, [r0, #28]
    ac76:	b91a      	cbnz	r2, ac80 <ble_ll_task+0x60>
    ac78:	486c      	ldr	r0, [pc, #432]	; (ae2c <ble_ll_task+0x20c>)
    ac7a:	f44f 715d 	mov.w	r1, #884	; 0x374
    ac7e:	e0d0      	b.n	ae22 <ble_ll_task+0x202>
            cf->cf_func(ev->ev_arg);
    ac80:	6840      	ldr	r0, [r0, #4]
    ac82:	4790      	blx	r2
            break;
    ac84:	e7d6      	b.n	ac34 <ble_ll_task+0x14>
        case BLE_LL_EVENT_HCI_CMD:
            /* Process HCI command */
            ble_ll_hci_cmd_proc(ev);
    ac86:	f003 ffb9 	bl	ebfc <ble_ll_hci_cmd_proc>
            break;
    ac8a:	e7d3      	b.n	ac34 <ble_ll_task+0x14>
        case BLE_LL_EVENT_ADV_EV_DONE:
            ble_ll_adv_event_done(ev->ev_arg);
    ac8c:	6840      	ldr	r0, [r0, #4]
    ac8e:	f000 fe79 	bl	b984 <ble_ll_adv_event_done>
            break;
    ac92:	e7cf      	b.n	ac34 <ble_ll_task+0x14>
        case BLE_LL_EVENT_SCAN:
            ble_ll_scan_event_proc(ev->ev_arg);
    ac94:	6840      	ldr	r0, [r0, #4]
    ac96:	f004 ff89 	bl	fbac <ble_ll_scan_event_proc>
            break;
    ac9a:	e7cb      	b.n	ac34 <ble_ll_task+0x14>
        /* Get mbuf pointer from packet header pointer */
        pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q);
        m = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));

        /* Remove from queue */
        OS_ENTER_CRITICAL(sr);
    ac9c:	f7fe fe40 	bl	9920 <os_arch_save_sr>
        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_rx_pkt_q, omp_next);
    aca0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    aca2:	685b      	ldr	r3, [r3, #4]
    aca4:	636b      	str	r3, [r5, #52]	; 0x34

    /* Drain all packets off the queue */
    while (STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q)) {
        /* Get mbuf pointer from packet header pointer */
        pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q);
        m = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));
    aca6:	f1a4 0610 	sub.w	r6, r4, #16

        /* Remove from queue */
        OS_ENTER_CRITICAL(sr);
        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_rx_pkt_q, omp_next);
    acaa:	b913      	cbnz	r3, acb2 <ble_ll_task+0x92>
    acac:	f105 0334 	add.w	r3, r5, #52	; 0x34
    acb0:	63ab      	str	r3, [r5, #56]	; 0x38
        OS_EXIT_CRITICAL(sr);
    acb2:	f7fe fe3b 	bl	992c <os_arch_restore_sr>

        /* Note: pdu type wont get used unless this is an advertising pdu */
        ble_hdr = BLE_MBUF_HDR_PTR(m);
        rxbuf = m->om_data;
    acb6:	f854 1c10 	ldr.w	r1, [r4, #-16]
ble_ll_count_rx_stats(struct ble_mbuf_hdr *hdr, uint16_t len, uint8_t pdu_type)
{
    uint8_t crcok;
    uint8_t chan;

    crcok = BLE_MBUF_HDR_CRC_OK(hdr);
    acba:	7a23      	ldrb	r3, [r4, #8]
        OS_EXIT_CRITICAL(sr);

        /* Note: pdu type wont get used unless this is an advertising pdu */
        ble_hdr = BLE_MBUF_HDR_PTR(m);
        rxbuf = m->om_data;
        pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    acbc:	7808      	ldrb	r0, [r1, #0]
        ble_ll_count_rx_stats(ble_hdr, pkthdr->omp_len, pdu_type);
    acbe:	8825      	ldrh	r5, [r4, #0]
    acc0:	7a67      	ldrb	r7, [r4, #9]
    uint8_t crcok;
    uint8_t chan;

    crcok = BLE_MBUF_HDR_CRC_OK(hdr);
    chan = hdr->rxinfo.channel;
    if (crcok) {
    acc2:	f013 0f80 	tst.w	r3, #128	; 0x80
        OS_ENTER_CRITICAL(sr);
        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_rx_pkt_q, omp_next);
        OS_EXIT_CRITICAL(sr);

        /* Note: pdu type wont get used unless this is an advertising pdu */
        ble_hdr = BLE_MBUF_HDR_PTR(m);
    acc6:	f104 0208 	add.w	r2, r4, #8
        rxbuf = m->om_data;
        pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    acca:	f000 000f 	and.w	r0, r0, #15
    acce:	4b58      	ldr	r3, [pc, #352]	; (ae30 <ble_ll_task+0x210>)
    uint8_t crcok;
    uint8_t chan;

    crcok = BLE_MBUF_HDR_CRC_OK(hdr);
    chan = hdr->rxinfo.channel;
    if (crcok) {
    acd0:	d03d      	beq.n	ad4e <ble_ll_task+0x12e>
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
    acd2:	2f24      	cmp	r7, #36	; 0x24
    acd4:	d811      	bhi.n	acfa <ble_ll_task+0xda>
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_ok);
    acd6:	6b1f      	ldr	r7, [r3, #48]	; 0x30
    acd8:	3701      	adds	r7, #1
    acda:	631f      	str	r7, [r3, #48]	; 0x30
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_ok, len);
    acdc:	6b9f      	ldr	r7, [r3, #56]	; 0x38
    acde:	443d      	add	r5, r7
    ace0:	639d      	str	r5, [r3, #56]	; 0x38
        rxbuf = m->om_data;
        pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
        ble_ll_count_rx_stats(ble_hdr, pkthdr->omp_len, pdu_type);

        /* Process the data or advertising pdu */
        if (ble_hdr->rxinfo.channel < BLE_PHY_NUM_DATA_CHANS) {
    ace2:	7a65      	ldrb	r5, [r4, #9]
    ace4:	2d24      	cmp	r5, #36	; 0x24
    ace6:	d843      	bhi.n	ad70 <ble_ll_task+0x150>
            ble_ll_conn_rx_data_pdu(m, ble_hdr);
    ace8:	4630      	mov	r0, r6
    acea:	4611      	mov	r1, r2
    acec:	f002 f826 	bl	cd3c <ble_ll_conn_rx_data_pdu>
    struct os_mbuf_pkthdr *pkthdr;
    struct ble_mbuf_hdr *ble_hdr;
    struct os_mbuf *m;

    /* Drain all packets off the queue */
    while (STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q)) {
    acf0:	4d50      	ldr	r5, [pc, #320]	; (ae34 <ble_ll_task+0x214>)
    acf2:	6b6c      	ldr	r4, [r5, #52]	; 0x34
    acf4:	2c00      	cmp	r4, #0
    acf6:	d1d1      	bne.n	ac9c <ble_ll_task+0x7c>
    acf8:	e79c      	b.n	ac34 <ble_ll_task+0x14>
    if (crcok) {
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_ok);
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_ok, len);
        } else {
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_ok);
    acfa:	6a1f      	ldr	r7, [r3, #32]
    acfc:	3701      	adds	r7, #1
    acfe:	621f      	str	r7, [r3, #32]
            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_ok, len);
    ad00:	6a9f      	ldr	r7, [r3, #40]	; 0x28
    ad02:	443d      	add	r5, r7
    ad04:	629d      	str	r5, [r3, #40]	; 0x28
 */
static void
ble_ll_count_rx_adv_pdus(uint8_t pdu_type)
{
    /* Count received packet types  */
    switch (pdu_type) {
    ad06:	2806      	cmp	r0, #6
    ad08:	d8eb      	bhi.n	ace2 <ble_ll_task+0xc2>
    ad0a:	e8df f000 	tbb	[pc, r0]
    ad0e:	0804      	.short	0x0804
    ad10:	1814100c 	.word	0x1814100c
    ad14:	1c          	.byte	0x1c
    ad15:	00          	.byte	0x00
    case BLE_ADV_PDU_TYPE_ADV_IND:
        STATS_INC(ble_ll_stats, rx_adv_ind);
    ad16:	6c5d      	ldr	r5, [r3, #68]	; 0x44
    ad18:	3501      	adds	r5, #1
    ad1a:	645d      	str	r5, [r3, #68]	; 0x44
    ad1c:	e7e1      	b.n	ace2 <ble_ll_task+0xc2>
        break;
    case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
        STATS_INC(ble_ll_stats, rx_adv_direct_ind);
    ad1e:	6c9d      	ldr	r5, [r3, #72]	; 0x48
    ad20:	3501      	adds	r5, #1
    ad22:	649d      	str	r5, [r3, #72]	; 0x48
    ad24:	e7dd      	b.n	ace2 <ble_ll_task+0xc2>
        break;
    case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
        STATS_INC(ble_ll_stats, rx_adv_nonconn_ind);
    ad26:	6cdd      	ldr	r5, [r3, #76]	; 0x4c
    ad28:	3501      	adds	r5, #1
    ad2a:	64dd      	str	r5, [r3, #76]	; 0x4c
    ad2c:	e7d9      	b.n	ace2 <ble_ll_task+0xc2>
        break;
    case BLE_ADV_PDU_TYPE_SCAN_REQ:
        STATS_INC(ble_ll_stats, rx_scan_reqs);
    ad2e:	6d1d      	ldr	r5, [r3, #80]	; 0x50
    ad30:	3501      	adds	r5, #1
    ad32:	651d      	str	r5, [r3, #80]	; 0x50
    ad34:	e7d5      	b.n	ace2 <ble_ll_task+0xc2>
        break;
    case BLE_ADV_PDU_TYPE_SCAN_RSP:
        STATS_INC(ble_ll_stats, rx_scan_rsps);
    ad36:	6d5d      	ldr	r5, [r3, #84]	; 0x54
    ad38:	3501      	adds	r5, #1
    ad3a:	655d      	str	r5, [r3, #84]	; 0x54
    ad3c:	e7d1      	b.n	ace2 <ble_ll_task+0xc2>
        break;
    case BLE_ADV_PDU_TYPE_CONNECT_REQ:
        STATS_INC(ble_ll_stats, rx_connect_reqs);
    ad3e:	6d9d      	ldr	r5, [r3, #88]	; 0x58
    ad40:	3501      	adds	r5, #1
    ad42:	659d      	str	r5, [r3, #88]	; 0x58
    ad44:	e7cd      	b.n	ace2 <ble_ll_task+0xc2>
        break;
    case BLE_ADV_PDU_TYPE_ADV_SCAN_IND:
        STATS_INC(ble_ll_stats, rx_scan_ind);
    ad46:	6ddd      	ldr	r5, [r3, #92]	; 0x5c
    ad48:	3501      	adds	r5, #1
    ad4a:	65dd      	str	r5, [r3, #92]	; 0x5c
    ad4c:	e7c9      	b.n	ace2 <ble_ll_task+0xc2>
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_ok);
            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_ok, len);
            ble_ll_count_rx_adv_pdus(pdu_type);
        }
    } else {
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
    ad4e:	2f24      	cmp	r7, #36	; 0x24
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
    ad50:	bf95      	itete	ls
    ad52:	6b5f      	ldrls	r7, [r3, #52]	; 0x34
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
        } else {
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
    ad54:	6a5f      	ldrhi	r7, [r3, #36]	; 0x24
            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_ok, len);
            ble_ll_count_rx_adv_pdus(pdu_type);
        }
    } else {
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
    ad56:	3701      	addls	r7, #1
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
        } else {
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
    ad58:	3701      	addhi	r7, #1
            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_ok, len);
            ble_ll_count_rx_adv_pdus(pdu_type);
        }
    } else {
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
    ad5a:	bf95      	itete	ls
    ad5c:	635f      	strls	r7, [r3, #52]	; 0x34
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
        } else {
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
    ad5e:	625f      	strhi	r7, [r3, #36]	; 0x24
            ble_ll_count_rx_adv_pdus(pdu_type);
        }
    } else {
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
    ad60:	6bdf      	ldrls	r7, [r3, #60]	; 0x3c
        } else {
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_err, len);
    ad62:	6adf      	ldrhi	r7, [r3, #44]	; 0x2c
            ble_ll_count_rx_adv_pdus(pdu_type);
        }
    } else {
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
    ad64:	bf95      	itete	ls
    ad66:	19ed      	addls	r5, r5, r7
        } else {
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_err, len);
    ad68:	19ed      	addhi	r5, r5, r7
            ble_ll_count_rx_adv_pdus(pdu_type);
        }
    } else {
        if (chan < BLE_PHY_NUM_DATA_CHANS) {
            STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
    ad6a:	63dd      	strls	r5, [r3, #60]	; 0x3c
        } else {
            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_err, len);
    ad6c:	62dd      	strhi	r5, [r3, #44]	; 0x2c
    ad6e:	e7b8      	b.n	ace2 <ble_ll_task+0xc2>
        /* Process the data or advertising pdu */
        if (ble_hdr->rxinfo.channel < BLE_PHY_NUM_DATA_CHANS) {
            ble_ll_conn_rx_data_pdu(m, ble_hdr);
        } else {
            /* Process the PDU */
            switch (BLE_MBUF_HDR_RX_STATE(ble_hdr)) {
    ad70:	7a24      	ldrb	r4, [r4, #8]
    ad72:	f004 0403 	and.w	r4, r4, #3
    ad76:	2c02      	cmp	r4, #2
    ad78:	d006      	beq.n	ad88 <ble_ll_task+0x168>
    ad7a:	2c03      	cmp	r4, #3
    ad7c:	d007      	beq.n	ad8e <ble_ll_task+0x16e>
    ad7e:	2c01      	cmp	r4, #1
    ad80:	d10a      	bne.n	ad98 <ble_ll_task+0x178>
            case BLE_LL_STATE_ADV:
                ble_ll_adv_rx_pkt_in(pdu_type, rxbuf, ble_hdr);
    ad82:	f000 fe9d 	bl	bac0 <ble_ll_adv_rx_pkt_in>
    ad86:	e00a      	b.n	ad9e <ble_ll_task+0x17e>
                break;
            case BLE_LL_STATE_SCANNING:
                ble_ll_scan_rx_pkt_in(pdu_type, rxbuf, ble_hdr);
    ad88:	f005 f8c4 	bl	ff14 <ble_ll_scan_rx_pkt_in>
    ad8c:	e007      	b.n	ad9e <ble_ll_task+0x17e>
                break;
            case BLE_LL_STATE_INITIATING:
                ble_ll_init_rx_pkt_in(rxbuf, ble_hdr);
    ad8e:	4608      	mov	r0, r1
    ad90:	4611      	mov	r1, r2
    ad92:	f001 fded 	bl	c970 <ble_ll_init_rx_pkt_in>
    ad96:	e002      	b.n	ad9e <ble_ll_task+0x17e>
                break;
            default:
                /* Any other state should never occur */
                STATS_INC(ble_ll_stats, bad_ll_state);
    ad98:	699a      	ldr	r2, [r3, #24]
    ad9a:	3201      	adds	r2, #1
    ad9c:	619a      	str	r2, [r3, #24]
                break;
            }

            /* Free the packet buffer */
            os_mbuf_free_chain(m);
    ad9e:	4630      	mov	r0, r6
    ada0:	f7ff f8dd 	bl	9f5e <os_mbuf_free_chain>
    ada4:	e7a4      	b.n	acf0 <ble_ll_task+0xd0>
        /* Get mbuf pointer from packet header pointer */
        pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q);
        om = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));

        /* Remove from queue */
        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_tx_pkt_q, omp_next);
    ada6:	6862      	ldr	r2, [r4, #4]
    ada8:	649a      	str	r2, [r3, #72]	; 0x48

    /* Drain all packets off the queue */
    while (STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q)) {
        /* Get mbuf pointer from packet header pointer */
        pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q);
        om = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));
    adaa:	f1a4 0510 	sub.w	r5, r4, #16

        /* Remove from queue */
        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_tx_pkt_q, omp_next);
    adae:	b912      	cbnz	r2, adb6 <ble_ll_task+0x196>
    adb0:	f103 0248 	add.w	r2, r3, #72	; 0x48
    adb4:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Strip HCI ACL header to get handle and length */
        handle = le16toh(om->om_data);
    adb6:	f854 0c10 	ldr.w	r0, [r4, #-16]
    adba:	f012 f968 	bl	1d08e <le16toh>
    adbe:	4606      	mov	r6, r0
        length = le16toh(om->om_data + 2);
    adc0:	f854 0c10 	ldr.w	r0, [r4, #-16]
    adc4:	3002      	adds	r0, #2
    adc6:	f012 f962 	bl	1d08e <le16toh>
        os_mbuf_adj(om, sizeof(struct hci_data_hdr));
    adca:	2104      	movs	r1, #4
        /* Remove from queue */
        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_tx_pkt_q, omp_next);

        /* Strip HCI ACL header to get handle and length */
        handle = le16toh(om->om_data);
        length = le16toh(om->om_data + 2);
    adcc:	4607      	mov	r7, r0
        os_mbuf_adj(om, sizeof(struct hci_data_hdr));
    adce:	4628      	mov	r0, r5
    add0:	f7ff f975 	bl	a0be <os_mbuf_adj>

        /* Do some basic error checking */
        pb = handle & 0x3000;
        if ((pkthdr->omp_len != length) || (pb > 0x1000) || (length == 0)) {
    add4:	8822      	ldrh	r2, [r4, #0]
    add6:	42ba      	cmp	r2, r7
    add8:	d00b      	beq.n	adf2 <ble_ll_task+0x1d2>
            /* This is a bad ACL packet. Count a stat and free it */
            STATS_INC(ble_ll_stats, bad_acl_hdr);
    adda:	4a15      	ldr	r2, [pc, #84]	; (ae30 <ble_ll_task+0x210>)
    addc:	69d3      	ldr	r3, [r2, #28]
            os_mbuf_free_chain(om);
    adde:	4628      	mov	r0, r5

        /* Do some basic error checking */
        pb = handle & 0x3000;
        if ((pkthdr->omp_len != length) || (pb > 0x1000) || (length == 0)) {
            /* This is a bad ACL packet. Count a stat and free it */
            STATS_INC(ble_ll_stats, bad_acl_hdr);
    ade0:	3301      	adds	r3, #1
    ade2:	61d3      	str	r3, [r2, #28]
            os_mbuf_free_chain(om);
    ade4:	f7ff f8bb 	bl	9f5e <os_mbuf_free_chain>
    uint16_t pb;
    struct os_mbuf_pkthdr *pkthdr;
    struct os_mbuf *om;

    /* Drain all packets off the queue */
    while (STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q)) {
    ade8:	4b12      	ldr	r3, [pc, #72]	; (ae34 <ble_ll_task+0x214>)
    adea:	6c9c      	ldr	r4, [r3, #72]	; 0x48
    adec:	2c00      	cmp	r4, #0
    adee:	d1da      	bne.n	ada6 <ble_ll_task+0x186>
    adf0:	e720      	b.n	ac34 <ble_ll_task+0x14>
        length = le16toh(om->om_data + 2);
        os_mbuf_adj(om, sizeof(struct hci_data_hdr));

        /* Do some basic error checking */
        pb = handle & 0x3000;
        if ((pkthdr->omp_len != length) || (pb > 0x1000) || (length == 0)) {
    adf2:	f406 5340 	and.w	r3, r6, #12288	; 0x3000
    adf6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    adfa:	d8ee      	bhi.n	adda <ble_ll_task+0x1ba>
    adfc:	2a00      	cmp	r2, #0
    adfe:	d0ec      	beq.n	adda <ble_ll_task+0x1ba>
            os_mbuf_free_chain(om);
            continue;
        }

        /* Hand to connection state machine */
        ble_ll_conn_tx_pkt_in(om, handle, length);
    ae00:	4628      	mov	r0, r5
    ae02:	4631      	mov	r1, r6
    ae04:	f002 f9bc 	bl	d180 <ble_ll_conn_tx_pkt_in>
    ae08:	e7ee      	b.n	ade8 <ble_ll_task+0x1c8>
            break;
        case BLE_LL_EVENT_TX_PKT_IN:
            ble_ll_tx_pkt_in();
            break;
        case BLE_LL_EVENT_CONN_SPVN_TMO:
            ble_ll_conn_spvn_timeout(ev->ev_arg);
    ae0a:	6840      	ldr	r0, [r0, #4]
    ae0c:	f001 ff62 	bl	ccd4 <ble_ll_conn_spvn_timeout>
            break;
    ae10:	e710      	b.n	ac34 <ble_ll_task+0x14>
        case BLE_LL_EVENT_CONN_EV_END:
            ble_ll_conn_event_end(ev->ev_arg);
    ae12:	6840      	ldr	r0, [r0, #4]
    ae14:	f001 fd46 	bl	c8a4 <ble_ll_conn_event_end>
            break;
    ae18:	e70c      	b.n	ac34 <ble_ll_task+0x14>
        default:
            assert(0);
    ae1a:	4804      	ldr	r0, [pc, #16]	; (ae2c <ble_ll_task+0x20c>)
    ae1c:	f240 318e 	movw	r1, #910	; 0x38e
    ae20:	2200      	movs	r2, #0
    ae22:	4613      	mov	r3, r2
    ae24:	f7fe ff54 	bl	9cd0 <__assert_func>
    ae28:	200032c8 	.word	0x200032c8
    ae2c:	0001f236 	.word	0x0001f236
    ae30:	200030ac 	.word	0x200030ac
    ae34:	200032c0 	.word	0x200032c0

0000ae38 <ble_ll_chk_txrx_octets>:
int
ble_ll_chk_txrx_octets(uint16_t octets)
{
    int rc;

    if ((octets < BLE_LL_CONN_SUPP_BYTES_MIN) ||
    ae38:	381b      	subs	r0, #27
    } else {
        rc = 1;
    }

    return rc;
}
    ae3a:	28e0      	cmp	r0, #224	; 0xe0
    ae3c:	bf8c      	ite	hi
    ae3e:	2000      	movhi	r0, #0
    ae40:	2001      	movls	r0, #1
    ae42:	4770      	bx	lr

0000ae44 <ble_ll_chk_txrx_time>:
int
ble_ll_chk_txrx_time(uint16_t time)
{
    int rc;

    if ((time < BLE_LL_CONN_SUPP_TIME_MIN) ||
    ae44:	f5a0 70a4 	sub.w	r0, r0, #328	; 0x148
    } else {
        rc = 1;
    }

    return rc;
}
    ae48:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    ae4c:	bf8c      	ite	hi
    ae4e:	2000      	movhi	r0, #0
    ae50:	2001      	movls	r0, #1
    ae52:	4770      	bx	lr

0000ae54 <ble_ll_is_rpa>:
int
ble_ll_is_rpa(uint8_t *addr, uint8_t addr_type)
{
    int rc;

    if (addr_type && ((addr[5] & 0xc0) == 0x40)) {
    ae54:	b139      	cbz	r1, ae66 <ble_ll_is_rpa+0x12>
    ae56:	7940      	ldrb	r0, [r0, #5]
    ae58:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
    ae5c:	f1a0 0340 	sub.w	r3, r0, #64	; 0x40
    ae60:	4258      	negs	r0, r3
    ae62:	4158      	adcs	r0, r3
    ae64:	4770      	bx	lr
        rc = 1;
    } else {
        rc = 0;
    ae66:	4608      	mov	r0, r1
    }
    return rc;
}
    ae68:	4770      	bx	lr
	...

0000ae6c <ble_ll_is_valid_random_addr>:

/* Checks to see that the device is a valid random address */
int
ble_ll_is_valid_random_addr(uint8_t *addr)
{
    ae6c:	b510      	push	{r4, lr}
    ae6e:	4601      	mov	r1, r0
    ae70:	1e43      	subs	r3, r0, #1
    ae72:	1d02      	adds	r2, r0, #4
    int rc;
    uint16_t sum;
    uint8_t addr_type;

    /* Make sure all bits are neither one nor zero */
    sum = 0;
    ae74:	2000      	movs	r0, #0
    for (i = 0; i < (BLE_DEV_ADDR_LEN -1); ++i) {
        sum += addr[i];
    ae76:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    ae7a:	4420      	add	r0, r4
    uint16_t sum;
    uint8_t addr_type;

    /* Make sure all bits are neither one nor zero */
    sum = 0;
    for (i = 0; i < (BLE_DEV_ADDR_LEN -1); ++i) {
    ae7c:	4293      	cmp	r3, r2
        sum += addr[i];
    ae7e:	b280      	uxth	r0, r0
    uint16_t sum;
    uint8_t addr_type;

    /* Make sure all bits are neither one nor zero */
    sum = 0;
    for (i = 0; i < (BLE_DEV_ADDR_LEN -1); ++i) {
    ae80:	d1f9      	bne.n	ae76 <ble_ll_is_valid_random_addr+0xa>
        sum += addr[i];
    }
    sum += addr[5] & 0x3f;
    ae82:	794b      	ldrb	r3, [r1, #5]
    ae84:	f003 043f 	and.w	r4, r3, #63	; 0x3f
    ae88:	4420      	add	r0, r4
    ae8a:	b280      	uxth	r0, r0

    if ((sum == 0) || (sum == ((5*255) + 0x3f))) {
    ae8c:	b300      	cbz	r0, aed0 <ble_ll_is_valid_random_addr+0x64>
    ae8e:	f240 523a 	movw	r2, #1338	; 0x53a
    ae92:	4290      	cmp	r0, r2
    ae94:	d01b      	beq.n	aece <ble_ll_is_valid_random_addr+0x62>
        return 0;
    }

    /* Get the upper two bits of the address */
    rc = 1;
    addr_type = addr[5] & 0xc0;
    ae96:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    if (addr_type == 0xc0) {
    ae9a:	2bc0      	cmp	r3, #192	; 0xc0
    ae9c:	d015      	beq.n	aeca <ble_ll_is_valid_random_addr+0x5e>
        /* Static random address. No other checks needed */
    } else if (addr_type == 0x40) {
    ae9e:	2b40      	cmp	r3, #64	; 0x40
    aea0:	d10a      	bne.n	aeb8 <ble_ll_is_valid_random_addr+0x4c>
        /* Resolvable */
        sum = addr[3] + addr[4] + (addr[5] & 0x3f);
    aea2:	790b      	ldrb	r3, [r1, #4]
    aea4:	78ca      	ldrb	r2, [r1, #3]
    aea6:	18e0      	adds	r0, r4, r3
        if ((sum == 0) || (sum == (255 + 255 + 0x3f))) {
    aea8:	1880      	adds	r0, r0, r2
    aeaa:	d011      	beq.n	aed0 <ble_ll_is_valid_random_addr+0x64>
    aeac:	f240 233d 	movw	r3, #573	; 0x23d
    aeb0:	1ac0      	subs	r0, r0, r3
    aeb2:	bf18      	it	ne
    aeb4:	2001      	movne	r0, #1
    aeb6:	bd10      	pop	{r4, pc}
            rc = 0;
        }
    } else if (addr_type == 0) {
    aeb8:	b94b      	cbnz	r3, aece <ble_ll_is_valid_random_addr+0x62>
        /* non-resolvable. Cant be equal to public */
        if (!memcmp(g_dev_addr, addr, BLE_DEV_ADDR_LEN)) {
    aeba:	2206      	movs	r2, #6
    aebc:	4805      	ldr	r0, [pc, #20]	; (aed4 <ble_ll_is_valid_random_addr+0x68>)
    aebe:	f7fe f88f 	bl	8fe0 <memcmp>
    aec2:	3000      	adds	r0, #0
    aec4:	bf18      	it	ne
    aec6:	2001      	movne	r0, #1
    aec8:	bd10      	pop	{r4, pc}
    if ((sum == 0) || (sum == ((5*255) + 0x3f))) {
        return 0;
    }

    /* Get the upper two bits of the address */
    rc = 1;
    aeca:	2001      	movs	r0, #1
    aecc:	bd10      	pop	{r4, pc}
        sum += addr[i];
    }
    sum += addr[5] & 0x3f;

    if ((sum == 0) || (sum == ((5*255) + 0x3f))) {
        return 0;
    aece:	2000      	movs	r0, #0
        /* Invalid upper two bits */
        rc = 0;
    }

    return rc;
}
    aed0:	bd10      	pop	{r4, pc}
    aed2:	bf00      	nop
    aed4:	200000d8 	.word	0x200000d8

0000aed8 <ble_ll_set_random_addr>:
 *
 * @return int 0: success
 */
int
ble_ll_set_random_addr(uint8_t *addr)
{
    aed8:	b510      	push	{r4, lr}
    aeda:	4604      	mov	r4, r0
    int rc;

    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    if (ble_ll_is_valid_random_addr(addr)) {
    aedc:	f7ff ffc6 	bl	ae6c <ble_ll_is_valid_random_addr>
    aee0:	b130      	cbz	r0, aef0 <ble_ll_set_random_addr+0x18>
        memcpy(g_random_addr, addr, BLE_DEV_ADDR_LEN);
    aee2:	4b04      	ldr	r3, [pc, #16]	; (aef4 <ble_ll_set_random_addr+0x1c>)
    aee4:	6822      	ldr	r2, [r4, #0]
    aee6:	601a      	str	r2, [r3, #0]
    aee8:	88a2      	ldrh	r2, [r4, #4]
    aeea:	809a      	strh	r2, [r3, #4]
        rc = BLE_ERR_SUCCESS;
    aeec:	2000      	movs	r0, #0
    aeee:	bd10      	pop	{r4, pc}
int
ble_ll_set_random_addr(uint8_t *addr)
{
    int rc;

    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    aef0:	2012      	movs	r0, #18
        memcpy(g_random_addr, addr, BLE_DEV_ADDR_LEN);
        rc = BLE_ERR_SUCCESS;
    }

    return rc;
}
    aef2:	bd10      	pop	{r4, pc}
    aef4:	20002810 	.word	0x20002810

0000aef8 <ble_ll_is_our_devaddr>:
 *
 * @return int 0: not our device address. 1: is our device address
 */
int
ble_ll_is_our_devaddr(uint8_t *addr, int addr_type)
{
    aef8:	b508      	push	{r3, lr}
    } else {
        our_addr = g_dev_addr;
    }

    rc = 0;
    if (!memcmp(our_addr, addr, BLE_DEV_ADDR_LEN)) {
    aefa:	4a07      	ldr	r2, [pc, #28]	; (af18 <ble_ll_is_our_devaddr+0x20>)
 *
 * @return int 0: not our device address. 1: is our device address
 */
int
ble_ll_is_our_devaddr(uint8_t *addr, int addr_type)
{
    aefc:	4603      	mov	r3, r0
    } else {
        our_addr = g_dev_addr;
    }

    rc = 0;
    if (!memcmp(our_addr, addr, BLE_DEV_ADDR_LEN)) {
    aefe:	4807      	ldr	r0, [pc, #28]	; (af1c <ble_ll_is_our_devaddr+0x24>)
    af00:	2900      	cmp	r1, #0
    af02:	bf08      	it	eq
    af04:	4610      	moveq	r0, r2
    af06:	4619      	mov	r1, r3
    af08:	2206      	movs	r2, #6
    af0a:	f7fe f869 	bl	8fe0 <memcmp>
        rc = 1;
    }

    return rc;
}
    af0e:	fab0 f080 	clz	r0, r0
    af12:	0940      	lsrs	r0, r0, #5
    af14:	bd08      	pop	{r3, pc}
    af16:	bf00      	nop
    af18:	200000d8 	.word	0x200000d8
    af1c:	20002810 	.word	0x20002810

0000af20 <ble_ll_wfr_enable>:
 * @param wfr_cb
 * @param arg
 */
void
ble_ll_wfr_enable(uint32_t cputime)
{
    af20:	4601      	mov	r1, r0
    cputime_timer_start(&g_ble_ll_data.ll_wfr_timer, cputime);
    af22:	4801      	ldr	r0, [pc, #4]	; (af28 <ble_ll_wfr_enable+0x8>)
    af24:	f7fd beec 	b.w	8d00 <cputime_timer_start>
    af28:	200032d4 	.word	0x200032d4

0000af2c <ble_ll_wfr_disable>:
 * Disable the wait for response timer
 */
void
ble_ll_wfr_disable(void)
{
    cputime_timer_stop(&g_ble_ll_data.ll_wfr_timer);
    af2c:	4801      	ldr	r0, [pc, #4]	; (af34 <ble_ll_wfr_disable+0x8>)
    af2e:	f7fd bf47 	b.w	8dc0 <cputime_timer_stop>
    af32:	bf00      	nop
    af34:	200032d4 	.word	0x200032d4

0000af38 <ble_ll_rx_pdu_in>:
ble_ll_rx_pdu_in(struct os_mbuf *rxpdu)
{
    struct os_mbuf_pkthdr *pkthdr;

    pkthdr = OS_MBUF_PKTHDR(rxpdu);
    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_rx_pkt_q, pkthdr, omp_next);
    af38:	4906      	ldr	r1, [pc, #24]	; (af54 <ble_ll_rx_pdu_in+0x1c>)
    af3a:	2300      	movs	r3, #0
    af3c:	6143      	str	r3, [r0, #20]
    af3e:	6b8b      	ldr	r3, [r1, #56]	; 0x38
void
ble_ll_rx_pdu_in(struct os_mbuf *rxpdu)
{
    struct os_mbuf_pkthdr *pkthdr;

    pkthdr = OS_MBUF_PKTHDR(rxpdu);
    af40:	f100 0210 	add.w	r2, r0, #16
    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_rx_pkt_q, pkthdr, omp_next);
    af44:	3014      	adds	r0, #20
    af46:	601a      	str	r2, [r3, #0]
    af48:	6388      	str	r0, [r1, #56]	; 0x38
    os_eventq_put(&g_ble_ll_data.ll_evq, &g_ble_ll_data.ll_rx_pkt_ev);
    af4a:	f101 0008 	add.w	r0, r1, #8
    af4e:	3128      	adds	r1, #40	; 0x28
    af50:	f7fe be4f 	b.w	9bf2 <os_eventq_put>
    af54:	200032c0 	.word	0x200032c0

0000af58 <ble_ll_acl_data_in>:
 *
 * @param txpdu Pointer to transmit packet
 */
void
ble_ll_acl_data_in(struct os_mbuf *txpkt)
{
    af58:	b538      	push	{r3, r4, r5, lr}
    os_sr_t sr;
    struct os_mbuf_pkthdr *pkthdr;

    pkthdr = OS_MBUF_PKTHDR(txpkt);
    OS_ENTER_CRITICAL(sr);
    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_tx_pkt_q, pkthdr, omp_next);
    af5a:	4d0b      	ldr	r5, [pc, #44]	; (af88 <ble_ll_acl_data_in+0x30>)
 *
 * @param txpdu Pointer to transmit packet
 */
void
ble_ll_acl_data_in(struct os_mbuf *txpkt)
{
    af5c:	4604      	mov	r4, r0
    os_sr_t sr;
    struct os_mbuf_pkthdr *pkthdr;

    pkthdr = OS_MBUF_PKTHDR(txpkt);
    OS_ENTER_CRITICAL(sr);
    af5e:	f7fe fcdf 	bl	9920 <os_arch_save_sr>
    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_tx_pkt_q, pkthdr, omp_next);
    af62:	2300      	movs	r3, #0
    af64:	6163      	str	r3, [r4, #20]
    af66:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
ble_ll_acl_data_in(struct os_mbuf *txpkt)
{
    os_sr_t sr;
    struct os_mbuf_pkthdr *pkthdr;

    pkthdr = OS_MBUF_PKTHDR(txpkt);
    af68:	f104 0210 	add.w	r2, r4, #16
    OS_ENTER_CRITICAL(sr);
    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_tx_pkt_q, pkthdr, omp_next);
    af6c:	601a      	str	r2, [r3, #0]
    af6e:	3414      	adds	r4, #20
    af70:	64ec      	str	r4, [r5, #76]	; 0x4c
    OS_EXIT_CRITICAL(sr);
    af72:	f7fe fcdb 	bl	992c <os_arch_restore_sr>
    os_eventq_put(&g_ble_ll_data.ll_evq, &g_ble_ll_data.ll_tx_pkt_ev);
    af76:	f105 0008 	add.w	r0, r5, #8
    af7a:	f105 013c 	add.w	r1, r5, #60	; 0x3c
}
    af7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    pkthdr = OS_MBUF_PKTHDR(txpkt);
    OS_ENTER_CRITICAL(sr);
    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_tx_pkt_q, pkthdr, omp_next);
    OS_EXIT_CRITICAL(sr);
    os_eventq_put(&g_ble_ll_data.ll_evq, &g_ble_ll_data.ll_tx_pkt_ev);
    af82:	f7fe be36 	b.w	9bf2 <os_eventq_put>
    af86:	bf00      	nop
    af88:	200032c0 	.word	0x200032c0

0000af8c <ble_ll_rx_start>:

    ble_ll_log(BLE_LL_LOG_ID_RX_START, chan, 0, (uint32_t)rxpdu);

    /* Check channel type */
    rxbuf = rxpdu->om_data;
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
    af8c:	2924      	cmp	r1, #36	; 0x24
 *   = 0: Continue to receive frame. Dont go from rx to tx
 *   > 0: Continue to receive frame and go from rx to tx when done
 */
int
ble_ll_rx_start(struct os_mbuf *rxpdu, uint8_t chan)
{
    af8e:	b510      	push	{r4, lr}
    struct ble_mbuf_hdr *ble_hdr;

    ble_ll_log(BLE_LL_LOG_ID_RX_START, chan, 0, (uint32_t)rxpdu);

    /* Check channel type */
    rxbuf = rxpdu->om_data;
    af90:	6802      	ldr	r2, [r0, #0]
    af92:	4b1e      	ldr	r3, [pc, #120]	; (b00c <ble_ll_rx_start+0x80>)
 *   = 0: Continue to receive frame. Dont go from rx to tx
 *   > 0: Continue to receive frame and go from rx to tx when done
 */
int
ble_ll_rx_start(struct os_mbuf *rxpdu, uint8_t chan)
{
    af94:	4604      	mov	r4, r0

    ble_ll_log(BLE_LL_LOG_ID_RX_START, chan, 0, (uint32_t)rxpdu);

    /* Check channel type */
    rxbuf = rxpdu->om_data;
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
    af96:	d811      	bhi.n	afbc <ble_ll_rx_start+0x30>
        /*
         * Data channel pdu. We should be in CONNECTION state with an
         * ongoing connection
         */
        if (g_ble_ll_data.ll_state == BLE_LL_STATE_CONNECTION) {
    af98:	781b      	ldrb	r3, [r3, #0]
    af9a:	2b04      	cmp	r3, #4
    af9c:	d108      	bne.n	afb0 <ble_ll_rx_start+0x24>
            ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
            rc = ble_ll_conn_rx_isr_start(ble_hdr, ble_phy_access_addr_get());
    af9e:	f006 fb77 	bl	11690 <ble_phy_access_addr_get>
    afa2:	4601      	mov	r1, r0
    afa4:	f104 0018 	add.w	r0, r4, #24
        STATS_INC(ble_ll_stats, bad_ll_state);
        break;
    }

    return rc;
}
    afa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
         * Data channel pdu. We should be in CONNECTION state with an
         * ongoing connection
         */
        if (g_ble_ll_data.ll_state == BLE_LL_STATE_CONNECTION) {
            ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
            rc = ble_ll_conn_rx_isr_start(ble_hdr, ble_phy_access_addr_get());
    afac:	f001 be96 	b.w	ccdc <ble_ll_conn_rx_isr_start>
        } else {
            STATS_INC(ble_ll_stats, bad_ll_state);
    afb0:	4a17      	ldr	r2, [pc, #92]	; (b010 <ble_ll_rx_start+0x84>)
    afb2:	6993      	ldr	r3, [r2, #24]
    afb4:	3301      	adds	r3, #1
    afb6:	6193      	str	r3, [r2, #24]
            rc = 0;
    afb8:	2000      	movs	r0, #0
    afba:	bd10      	pop	{r4, pc}
    }

    /* Advertising channel PDU */
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;

    switch (g_ble_ll_data.ll_state) {
    afbc:	781b      	ldrb	r3, [r3, #0]
        }
        return rc;
    }

    /* Advertising channel PDU */
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    afbe:	7810      	ldrb	r0, [r2, #0]

    switch (g_ble_ll_data.ll_state) {
    afc0:	3b01      	subs	r3, #1
        }
        return rc;
    }

    /* Advertising channel PDU */
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    afc2:	f000 000f 	and.w	r0, r0, #15

    switch (g_ble_ll_data.ll_state) {
    afc6:	2b03      	cmp	r3, #3
    afc8:	d818      	bhi.n	affc <ble_ll_rx_start+0x70>
    afca:	e8df f003 	tbb	[pc, r3]
    afce:	0b02      	.short	0x0b02
    afd0:	1006      	.short	0x1006
        STATS_INC(ble_ll_stats, bad_ll_state);
        break;
    }

    return rc;
}
    afd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    /* Advertising channel PDU */
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;

    switch (g_ble_ll_data.ll_state) {
    case BLE_LL_STATE_ADV:
        rc = ble_ll_adv_rx_isr_start(pdu_type);
    afd6:	f000 bcb9 	b.w	b94c <ble_ll_adv_rx_isr_start>
        break;
    case BLE_LL_STATE_INITIATING:
        if ((pdu_type == BLE_ADV_PDU_TYPE_ADV_IND) ||
    afda:	2801      	cmp	r0, #1
    afdc:	bf8c      	ite	hi
    afde:	2000      	movhi	r0, #0
    afe0:	2001      	movls	r0, #1
    afe2:	bd10      	pop	{r4, pc}
        } else {
            rc = 0;
        }
        break;
    case BLE_LL_STATE_SCANNING:
        rc = ble_ll_scan_rx_isr_start(pdu_type, rxpdu);
    afe4:	4621      	mov	r1, r4
        STATS_INC(ble_ll_stats, bad_ll_state);
        break;
    }

    return rc;
}
    afe6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        } else {
            rc = 0;
        }
        break;
    case BLE_LL_STATE_SCANNING:
        rc = ble_ll_scan_rx_isr_start(pdu_type, rxpdu);
    afea:	f004 be39 	b.w	fc60 <ble_ll_scan_rx_isr_start>
        break;
    case BLE_LL_STATE_CONNECTION:
        /* Should not occur */
        assert(0);
    afee:	2200      	movs	r2, #0
    aff0:	4808      	ldr	r0, [pc, #32]	; (b014 <ble_ll_rx_start+0x88>)
    aff2:	f240 21c7 	movw	r1, #711	; 0x2c7
    aff6:	4613      	mov	r3, r2
    aff8:	f7fe fe6a 	bl	9cd0 <__assert_func>
        rc = 0;
        break;
    default:
        /* Should not be in this state! */
        rc = -1;
        STATS_INC(ble_ll_stats, bad_ll_state);
    affc:	4a04      	ldr	r2, [pc, #16]	; (b010 <ble_ll_rx_start+0x84>)
    affe:	6993      	ldr	r3, [r2, #24]
    b000:	3301      	adds	r3, #1
    b002:	6193      	str	r3, [r2, #24]
        assert(0);
        rc = 0;
        break;
    default:
        /* Should not be in this state! */
        rc = -1;
    b004:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        STATS_INC(ble_ll_stats, bad_ll_state);
        break;
    }

    return rc;
}
    b008:	bd10      	pop	{r4, pc}
    b00a:	bf00      	nop
    b00c:	200032c0 	.word	0x200032c0
    b010:	200030ac 	.word	0x200030ac
    b014:	0001f236 	.word	0x0001f236

0000b018 <ble_ll_rx_end>:
 *      == 0: Success. Do not disable the PHY.
 *       > 0: Do not disable PHY as that has already been done.
 */
int
ble_ll_rx_end(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *ble_hdr)
{
    b018:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ble_ll_log(BLE_LL_LOG_ID_RX_END, rxbuf[0],
               ((uint16_t)ble_hdr->rxinfo.flags << 8) | rxbuf[1],
               (BLE_MBUF_HDR_PTR(rxpdu))->beg_cputime);

    /* Check channel type */
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
    b01a:	784b      	ldrb	r3, [r1, #1]
    /* Set the rx buffer pointer to the start of the received data */
    rxbuf = rxpdu->om_data;

    /* Get channel and CRC status from BLE header */
    chan = ble_hdr->rxinfo.channel;
    crcok = BLE_MBUF_HDR_CRC_OK(ble_hdr);
    b01c:	780d      	ldrb	r5, [r1, #0]
    uint8_t crcok;
    uint16_t mblen;
    uint8_t *rxbuf;

    /* Set the rx buffer pointer to the start of the received data */
    rxbuf = rxpdu->om_data;
    b01e:	6802      	ldr	r2, [r0, #0]

    /* Get channel and CRC status from BLE header */
    chan = ble_hdr->rxinfo.channel;
    crcok = BLE_MBUF_HDR_CRC_OK(ble_hdr);
    b020:	f025 057f 	bic.w	r5, r5, #127	; 0x7f
    ble_ll_log(BLE_LL_LOG_ID_RX_END, rxbuf[0],
               ((uint16_t)ble_hdr->rxinfo.flags << 8) | rxbuf[1],
               (BLE_MBUF_HDR_PTR(rxpdu))->beg_cputime);

    /* Check channel type */
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
    b024:	2b24      	cmp	r3, #36	; 0x24
 *      == 0: Success. Do not disable the PHY.
 *       > 0: Do not disable PHY as that has already been done.
 */
int
ble_ll_rx_end(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *ble_hdr)
{
    b026:	4604      	mov	r4, r0
    b028:	460f      	mov	r7, r1
    /* Set the rx buffer pointer to the start of the received data */
    rxbuf = rxpdu->om_data;

    /* Get channel and CRC status from BLE header */
    chan = ble_hdr->rxinfo.channel;
    crcok = BLE_MBUF_HDR_CRC_OK(ble_hdr);
    b02a:	b2ed      	uxtb	r5, r5
    b02c:	7853      	ldrb	r3, [r2, #1]
    ble_ll_log(BLE_LL_LOG_ID_RX_END, rxbuf[0],
               ((uint16_t)ble_hdr->rxinfo.flags << 8) | rxbuf[1],
               (BLE_MBUF_HDR_PTR(rxpdu))->beg_cputime);

    /* Check channel type */
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
    b02e:	d809      	bhi.n	b044 <ble_ll_rx_end+0x2c>
        /* Set length in the received PDU */
        mblen = rxbuf[1] + BLE_LL_PDU_HDR_LEN;
    b030:	3302      	adds	r3, #2
        OS_MBUF_PKTHDR(rxpdu)->omp_len = mblen;
    b032:	8203      	strh	r3, [r0, #16]
        rxpdu->om_len = mblen;
    b034:	80c3      	strh	r3, [r0, #6]
         * NOTE: this looks a bit odd, and it is, but for now we place the
         * received PDU on the Link Layer task before calling the rx end
         * function. We do this to guarantee connection event end ordering
         * and receive PDU processing.
         */
        ble_ll_rx_pdu_in(rxpdu);
    b036:	f7ff ff7f 	bl	af38 <ble_ll_rx_pdu_in>

        /*
         * Data channel pdu. We should be in CONNECTION state with an
         * ongoing connection.
         */
        rc = ble_ll_conn_rx_isr_end(rxpdu);
    b03a:	4620      	mov	r0, r4
    if (rxpdu) {
        ble_ll_rx_pdu_in(rxpdu);
    }

    return rc;
}
    b03c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

        /*
         * Data channel pdu. We should be in CONNECTION state with an
         * ongoing connection.
         */
        rc = ble_ll_conn_rx_isr_end(rxpdu);
    b040:	f001 bf36 	b.w	ceb0 <ble_ll_conn_rx_isr_end>
        return rc;
    }

    /* Get advertising PDU type and length */
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    b044:	7816      	ldrb	r6, [r2, #0]
    len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
    b046:	f003 033f 	and.w	r3, r3, #63	; 0x3f

    /* Setup the mbuf lengths */
    mblen = len + BLE_LL_PDU_HDR_LEN;
    b04a:	1c9a      	adds	r2, r3, #2
        rc = ble_ll_conn_rx_isr_end(rxpdu);
        return rc;
    }

    /* Get advertising PDU type and length */
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    b04c:	f006 060f 	and.w	r6, r6, #15
    len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;

    /* Setup the mbuf lengths */
    mblen = len + BLE_LL_PDU_HDR_LEN;
    OS_MBUF_PKTHDR(rxpdu)->omp_len = mblen;
    b050:	8202      	strh	r2, [r0, #16]
    rxpdu->om_len = mblen;
    b052:	80c2      	strh	r2, [r0, #6]

    /* If the CRC checks, make sure lengths check! */
    if (crcok) {
    b054:	b1a5      	cbz	r5, b080 <ble_ll_rx_end+0x68>
    b056:	2e06      	cmp	r6, #6
    b058:	d837      	bhi.n	b0ca <ble_ll_rx_end+0xb2>
    b05a:	2201      	movs	r2, #1
    b05c:	40b2      	lsls	r2, r6
    b05e:	f012 0f55 	tst.w	r2, #85	; 0x55
    b062:	d108      	bne.n	b076 <ble_ll_rx_end+0x5e>
    b064:	f012 0f0a 	tst.w	r2, #10
    b068:	d103      	bne.n	b072 <ble_ll_rx_end+0x5a>
    b06a:	0692      	lsls	r2, r2, #26
    b06c:	d52d      	bpl.n	b0ca <ble_ll_rx_end+0xb2>
            if ((len < BLE_DEV_ADDR_LEN) || (len > BLE_ADV_SCAN_IND_MAX_LEN)) {
                badpkt = 1;
            }
            break;
        case BLE_ADV_PDU_TYPE_CONNECT_REQ:
            if (len != BLE_CONNECT_REQ_LEN) {
    b06e:	2b22      	cmp	r3, #34	; 0x22
    b070:	e005      	b.n	b07e <ble_ll_rx_end+0x66>
    if (crcok) {
        badpkt = 0;
        switch (pdu_type) {
        case BLE_ADV_PDU_TYPE_SCAN_REQ:
        case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
            if (len != BLE_SCAN_REQ_LEN) {
    b072:	2b0c      	cmp	r3, #12
    b074:	e003      	b.n	b07e <ble_ll_rx_end+0x66>
            break;
        case BLE_ADV_PDU_TYPE_SCAN_RSP:
        case BLE_ADV_PDU_TYPE_ADV_IND:
        case BLE_ADV_PDU_TYPE_ADV_SCAN_IND:
        case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
            if ((len < BLE_DEV_ADDR_LEN) || (len > BLE_ADV_SCAN_IND_MAX_LEN)) {
    b076:	3b06      	subs	r3, #6
    b078:	2b1f      	cmp	r3, #31
    b07a:	d826      	bhi.n	b0ca <ble_ll_rx_end+0xb2>
    b07c:	e000      	b.n	b080 <ble_ll_rx_end+0x68>
                badpkt = 1;
            }
            break;
        case BLE_ADV_PDU_TYPE_CONNECT_REQ:
            if (len != BLE_CONNECT_REQ_LEN) {
    b07e:	d124      	bne.n	b0ca <ble_ll_rx_end+0xb2>
        }
    }


    /* Hand packet to the appropriate state machine (if crc ok) */
    switch (BLE_MBUF_HDR_RX_STATE(ble_hdr)) {
    b080:	783b      	ldrb	r3, [r7, #0]
    b082:	f003 0303 	and.w	r3, r3, #3
    b086:	2b02      	cmp	r3, #2
    b088:	d009      	beq.n	b09e <ble_ll_rx_end+0x86>
    b08a:	2b03      	cmp	r3, #3
    b08c:	d00d      	beq.n	b0aa <ble_ll_rx_end+0x92>
    b08e:	2b01      	cmp	r3, #1
    b090:	d110      	bne.n	b0b4 <ble_ll_rx_end+0x9c>
    case BLE_LL_STATE_ADV:
        rc = ble_ll_adv_rx_isr_end(pdu_type, rxpdu, crcok);
    b092:	4630      	mov	r0, r6
    b094:	4621      	mov	r1, r4
    b096:	462a      	mov	r2, r5
    b098:	f000 fba6 	bl	b7e8 <ble_ll_adv_rx_isr_end>
    b09c:	e003      	b.n	b0a6 <ble_ll_rx_end+0x8e>
        break;
    case BLE_LL_STATE_SCANNING:
        rc = ble_ll_scan_rx_isr_end(rxpdu, crcok);
    b09e:	4620      	mov	r0, r4
    b0a0:	4629      	mov	r1, r5
    b0a2:	f004 fdfb 	bl	fc9c <ble_ll_scan_rx_isr_end>
    b0a6:	4605      	mov	r5, r0
        break;
    b0a8:	e00a      	b.n	b0c0 <ble_ll_rx_end+0xa8>
    case BLE_LL_STATE_INITIATING:
        rc = ble_ll_init_rx_isr_end(rxpdu, crcok);
    b0aa:	4620      	mov	r0, r4
    b0ac:	4629      	mov	r1, r5
    b0ae:	f001 fca5 	bl	c9fc <ble_ll_init_rx_isr_end>
    b0b2:	e7f8      	b.n	b0a6 <ble_ll_rx_end+0x8e>
        break;
    default:
        rc = -1;
        STATS_INC(ble_ll_stats, bad_ll_state);
    b0b4:	4a0a      	ldr	r2, [pc, #40]	; (b0e0 <ble_ll_rx_end+0xc8>)
    b0b6:	6993      	ldr	r3, [r2, #24]
    b0b8:	3301      	adds	r3, #1
    b0ba:	6193      	str	r3, [r2, #24]
        break;
    case BLE_LL_STATE_INITIATING:
        rc = ble_ll_init_rx_isr_end(rxpdu, crcok);
        break;
    default:
        rc = -1;
    b0bc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
        STATS_INC(ble_ll_stats, bad_ll_state);
        break;
    }

    /* Hand packet up to higher layer (regardless of CRC failure) */
    if (rxpdu) {
    b0c0:	b164      	cbz	r4, b0dc <ble_ll_rx_end+0xc4>
        ble_ll_rx_pdu_in(rxpdu);
    b0c2:	4620      	mov	r0, r4
    b0c4:	f7ff ff38 	bl	af38 <ble_ll_rx_pdu_in>
    b0c8:	e008      	b.n	b0dc <ble_ll_rx_end+0xc4>
            break;
        }

        /* If this is a malformed packet, just kill it here */
        if (badpkt) {
            STATS_INC(ble_ll_stats, rx_adv_malformed_pkts);
    b0ca:	4a05      	ldr	r2, [pc, #20]	; (b0e0 <ble_ll_rx_end+0xc8>)
    b0cc:	6c13      	ldr	r3, [r2, #64]	; 0x40
            os_mbuf_free_chain(rxpdu);
    b0ce:	4620      	mov	r0, r4
            break;
        }

        /* If this is a malformed packet, just kill it here */
        if (badpkt) {
            STATS_INC(ble_ll_stats, rx_adv_malformed_pkts);
    b0d0:	3301      	adds	r3, #1
    b0d2:	6413      	str	r3, [r2, #64]	; 0x40
            os_mbuf_free_chain(rxpdu);
            rxpdu = NULL;
    b0d4:	2400      	movs	r4, #0
        }

        /* If this is a malformed packet, just kill it here */
        if (badpkt) {
            STATS_INC(ble_ll_stats, rx_adv_malformed_pkts);
            os_mbuf_free_chain(rxpdu);
    b0d6:	f7fe ff42 	bl	9f5e <os_mbuf_free_chain>
    b0da:	e7d1      	b.n	b080 <ble_ll_rx_end+0x68>
    if (rxpdu) {
        ble_ll_rx_pdu_in(rxpdu);
    }

    return rc;
}
    b0dc:	4628      	mov	r0, r5
    b0de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b0e0:	200030ac 	.word	0x200030ac

0000b0e4 <ble_ll_state_set>:
 * @param ll_state
 */
void
ble_ll_state_set(uint8_t ll_state)
{
    g_ble_ll_data.ll_state = ll_state;
    b0e4:	4b01      	ldr	r3, [pc, #4]	; (b0ec <ble_ll_state_set+0x8>)
    b0e6:	7018      	strb	r0, [r3, #0]
    b0e8:	4770      	bx	lr
    b0ea:	bf00      	nop
    b0ec:	200032c0 	.word	0x200032c0

0000b0f0 <ble_ll_state_get>:
 */
uint8_t
ble_ll_state_get(void)
{
    return g_ble_ll_data.ll_state;
}
    b0f0:	4b01      	ldr	r3, [pc, #4]	; (b0f8 <ble_ll_state_get+0x8>)
    b0f2:	7818      	ldrb	r0, [r3, #0]
    b0f4:	4770      	bx	lr
    b0f6:	bf00      	nop
    b0f8:	200032c0 	.word	0x200032c0

0000b0fc <ble_ll_event_send>:
 *
 * @param ev Event to add to the Link Layer event queue.
 */
void
ble_ll_event_send(struct os_event *ev)
{
    b0fc:	4601      	mov	r1, r0
    os_eventq_put(&g_ble_ll_data.ll_evq, ev);
    b0fe:	4801      	ldr	r0, [pc, #4]	; (b104 <ble_ll_event_send+0x8>)
    b100:	f7fe bd77 	b.w	9bf2 <os_eventq_put>
    b104:	200032c8 	.word	0x200032c8

0000b108 <ble_ll_read_supp_states>:
 */
uint64_t
ble_ll_read_supp_states(void)
{
    return BLE_LL_SUPPORTED_STATES;
}
    b108:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b10c:	f240 31ff 	movw	r1, #1023	; 0x3ff
    b110:	4770      	bx	lr
	...

0000b114 <ble_ll_read_supp_features>:
 */
uint8_t
ble_ll_read_supp_features(void)
{
    return g_ble_ll_data.ll_supp_features;
}
    b114:	4b01      	ldr	r3, [pc, #4]	; (b11c <ble_ll_read_supp_features+0x8>)
    b116:	7858      	ldrb	r0, [r3, #1]
    b118:	4770      	bx	lr
    b11a:	bf00      	nop
    b11c:	200032c0 	.word	0x200032c0

0000b120 <ble_ll_mbuf_init>:
ble_ll_mbuf_init(struct os_mbuf *m, uint8_t pdulen, uint8_t hdr)
{
    struct ble_mbuf_hdr *ble_hdr;

    /* Set mbuf length and packet length */
    m->om_len = pdulen;
    b120:	b28b      	uxth	r3, r1
    b122:	80c3      	strh	r3, [r0, #6]
    OS_MBUF_PKTHDR(m)->omp_len = pdulen;
    b124:	8203      	strh	r3, [r0, #16]

    /* Set BLE transmit header */
    ble_hdr = BLE_MBUF_HDR_PTR(m);
    ble_hdr->txinfo.flags = 0;
    b126:	2300      	movs	r3, #0
    b128:	7603      	strb	r3, [r0, #24]
    ble_hdr->txinfo.offset = 0;
    b12a:	7643      	strb	r3, [r0, #25]
    ble_hdr->txinfo.pyld_len = pdulen;
    b12c:	7681      	strb	r1, [r0, #26]
    ble_hdr->txinfo.hdr_byte = hdr;
    b12e:	76c2      	strb	r2, [r0, #27]
    b130:	4770      	bx	lr
	...

0000b134 <ble_ll_reset>:
 * @return int The ble error code to place in the command complete event that
 * is returned when this command is issued.
 */
int
ble_ll_reset(void)
{
    b134:	b510      	push	{r4, lr}
    int rc;
    os_sr_t sr;

    /* Stop the phy */
    ble_phy_disable();
    b136:	f006 f871 	bl	1121c <ble_phy_disable>

    /* Stop any wait for response timer */
    OS_ENTER_CRITICAL(sr);
    b13a:	f7fe fbf1 	bl	9920 <os_arch_save_sr>
    b13e:	4604      	mov	r4, r0
    ble_ll_wfr_disable();
    b140:	f7ff fef4 	bl	af2c <ble_ll_wfr_disable>
    ble_ll_sched_stop();
    b144:	f005 fc4e 	bl	109e4 <ble_ll_sched_stop>
    OS_EXIT_CRITICAL(sr);
    b148:	4620      	mov	r0, r4

    /* Stop any advertising */
    ble_ll_adv_reset();

    /* FLush all packets from Link layer queues */
    ble_ll_flush_pkt_queue(&g_ble_ll_data.ll_tx_pkt_q);
    b14a:	4c13      	ldr	r4, [pc, #76]	; (b198 <ble_ll_reset+0x64>)

    /* Stop any wait for response timer */
    OS_ENTER_CRITICAL(sr);
    ble_ll_wfr_disable();
    ble_ll_sched_stop();
    OS_EXIT_CRITICAL(sr);
    b14c:	f7fe fbee 	bl	992c <os_arch_restore_sr>

    /* Stop any scanning */
    ble_ll_scan_reset();
    b150:	f005 f8ea 	bl	10328 <ble_ll_scan_reset>

    /* Stop any advertising */
    ble_ll_adv_reset();
    b154:	f000 fd0e 	bl	bb74 <ble_ll_adv_reset>

    /* FLush all packets from Link layer queues */
    ble_ll_flush_pkt_queue(&g_ble_ll_data.ll_tx_pkt_q);
    b158:	4620      	mov	r0, r4
    b15a:	f7ff fd53 	bl	ac04 <ble_ll_flush_pkt_queue>
    ble_ll_flush_pkt_queue(&g_ble_ll_data.ll_rx_pkt_q);
    b15e:	f1a4 0014 	sub.w	r0, r4, #20
    b162:	f7ff fd4f 	bl	ac04 <ble_ll_flush_pkt_queue>

    /* Reset LL stats */
    memset((uint8_t *)&ble_ll_stats + sizeof(struct stats_hdr), 0,
    b166:	2100      	movs	r1, #0
    b168:	2278      	movs	r2, #120	; 0x78
    b16a:	480c      	ldr	r0, [pc, #48]	; (b19c <ble_ll_reset+0x68>)
    b16c:	f7fd ff51 	bl	9012 <memset>
    g_ble_ll_log_index = 0;
    memset(&g_ble_ll_log, 0, sizeof(g_ble_ll_log));
#endif

    /* Reset connection module */
    ble_ll_conn_module_reset();
    b170:	f002 f922 	bl	d3b8 <ble_ll_conn_module_reset>

    /* All this does is re-initialize the event masks so call the hci init */
    ble_ll_hci_init();
    b174:	f004 f806 	bl	f184 <ble_ll_hci_init>
 * @param ll_state
 */
void
ble_ll_state_set(uint8_t ll_state)
{
    g_ble_ll_data.ll_state = ll_state;
    b178:	2100      	movs	r1, #0

    /* Set state to standby */
    ble_ll_state_set(BLE_LL_STATE_STANDBY);

    /* Reset our random address */
    memset(g_random_addr, 0, BLE_DEV_ADDR_LEN);
    b17a:	2206      	movs	r2, #6
    b17c:	4808      	ldr	r0, [pc, #32]	; (b1a0 <ble_ll_reset+0x6c>)
 * @param ll_state
 */
void
ble_ll_state_set(uint8_t ll_state)
{
    g_ble_ll_data.ll_state = ll_state;
    b17e:	f804 1c48 	strb.w	r1, [r4, #-72]

    /* Set state to standby */
    ble_ll_state_set(BLE_LL_STATE_STANDBY);

    /* Reset our random address */
    memset(g_random_addr, 0, BLE_DEV_ADDR_LEN);
    b182:	f7fd ff46 	bl	9012 <memset>

    /* Clear the whitelist */
    ble_ll_whitelist_clear();
    b186:	f005 fc67 	bl	10a58 <ble_ll_whitelist_clear>

    /* Reset resolving list */
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    ble_ll_resolv_list_reset();
    b18a:	f004 fbad 	bl	f8e8 <ble_ll_resolv_list_reset>

    /* Re-initialize the PHY */
    rc = ble_phy_init();

    return rc;
}
    b18e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    ble_ll_resolv_list_reset();
#endif

    /* Re-initialize the PHY */
    rc = ble_phy_init();
    b192:	f005 bedf 	b.w	10f54 <ble_phy_init>
    b196:	bf00      	nop
    b198:	20003308 	.word	0x20003308
    b19c:	200030b8 	.word	0x200030b8
    b1a0:	20002810 	.word	0x20002810

0000b1a4 <ble_ll_init>:
 *
 * @return int
 */
int
ble_ll_init(uint8_t ll_task_prio, uint8_t num_acl_pkts, uint16_t acl_pkt_size)
{
    b1a4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

    /* Get pointer to global data object */
    lldata = &g_ble_ll_data;

    /* Set acl pkt size and number */
    lldata->ll_num_acl_pkts = num_acl_pkts;
    b1a6:	4c23      	ldr	r4, [pc, #140]	; (b234 <ble_ll_init+0x90>)
 *
 * @return int
 */
int
ble_ll_init(uint8_t ll_task_prio, uint8_t num_acl_pkts, uint16_t acl_pkt_size)
{
    b1a8:	4606      	mov	r6, r0
    /* Set acl pkt size and number */
    lldata->ll_num_acl_pkts = num_acl_pkts;
    lldata->ll_acl_pkt_size = acl_pkt_size;

    /* Initialize eventq */
    os_eventq_init(&lldata->ll_evq);
    b1aa:	f104 0008 	add.w	r0, r4, #8

    /* Get pointer to global data object */
    lldata = &g_ble_ll_data;

    /* Set acl pkt size and number */
    lldata->ll_num_acl_pkts = num_acl_pkts;
    b1ae:	70a1      	strb	r1, [r4, #2]
    lldata->ll_acl_pkt_size = acl_pkt_size;
    b1b0:	80a2      	strh	r2, [r4, #4]

    /* Initialize eventq */
    os_eventq_init(&lldata->ll_evq);
    b1b2:	f7fe fd15 	bl	9be0 <os_eventq_init>

    /* Initialize the transmit (from host) and receive (from phy) queues */
    STAILQ_INIT(&lldata->ll_tx_pkt_q);
    b1b6:	4623      	mov	r3, r4
    b1b8:	2500      	movs	r5, #0
    b1ba:	f843 5f48 	str.w	r5, [r3, #72]!
    b1be:	64e3      	str	r3, [r4, #76]	; 0x4c
    STAILQ_INIT(&lldata->ll_rx_pkt_q);
    b1c0:	4623      	mov	r3, r4
    /* Initialize transmit (from host) and receive packet (from phy) event */
    lldata->ll_rx_pkt_ev.ev_type = BLE_LL_EVENT_RX_PKT_IN;
    lldata->ll_tx_pkt_ev.ev_type = BLE_LL_EVENT_TX_PKT_IN;

    /* Initialize wait for response timer */
    cputime_timer_init(&g_ble_ll_data.ll_wfr_timer, ble_ll_wfr_timer_exp,
    b1c2:	462a      	mov	r2, r5
    /* Initialize eventq */
    os_eventq_init(&lldata->ll_evq);

    /* Initialize the transmit (from host) and receive (from phy) queues */
    STAILQ_INIT(&lldata->ll_tx_pkt_q);
    STAILQ_INIT(&lldata->ll_rx_pkt_q);
    b1c4:	f843 5f34 	str.w	r5, [r3, #52]!
    b1c8:	63a3      	str	r3, [r4, #56]	; 0x38

    /* Initialize transmit (from host) and receive packet (from phy) event */
    lldata->ll_rx_pkt_ev.ev_type = BLE_LL_EVENT_RX_PKT_IN;
    b1ca:	2312      	movs	r3, #18
    lldata->ll_tx_pkt_ev.ev_type = BLE_LL_EVENT_TX_PKT_IN;

    /* Initialize wait for response timer */
    cputime_timer_init(&g_ble_ll_data.ll_wfr_timer, ble_ll_wfr_timer_exp,
    b1cc:	491a      	ldr	r1, [pc, #104]	; (b238 <ble_ll_init+0x94>)
    /* Initialize the transmit (from host) and receive (from phy) queues */
    STAILQ_INIT(&lldata->ll_tx_pkt_q);
    STAILQ_INIT(&lldata->ll_rx_pkt_q);

    /* Initialize transmit (from host) and receive packet (from phy) event */
    lldata->ll_rx_pkt_ev.ev_type = BLE_LL_EVENT_RX_PKT_IN;
    b1ce:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
    lldata->ll_tx_pkt_ev.ev_type = BLE_LL_EVENT_TX_PKT_IN;

    /* Initialize wait for response timer */
    cputime_timer_init(&g_ble_ll_data.ll_wfr_timer, ble_ll_wfr_timer_exp,
    b1d2:	f104 0014 	add.w	r0, r4, #20
    STAILQ_INIT(&lldata->ll_tx_pkt_q);
    STAILQ_INIT(&lldata->ll_rx_pkt_q);

    /* Initialize transmit (from host) and receive packet (from phy) event */
    lldata->ll_rx_pkt_ev.ev_type = BLE_LL_EVENT_RX_PKT_IN;
    lldata->ll_tx_pkt_ev.ev_type = BLE_LL_EVENT_TX_PKT_IN;
    b1d6:	2316      	movs	r3, #22
    b1d8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

    /* Initialize wait for response timer */
    cputime_timer_init(&g_ble_ll_data.ll_wfr_timer, ble_ll_wfr_timer_exp,
    b1dc:	f7fd fd7a 	bl	8cd4 <cputime_timer_init>
                       NULL);

    /* Initialize LL HCI */
    ble_ll_hci_init();
    b1e0:	f003 ffd0 	bl	f184 <ble_ll_hci_init>

    /* Init the scheduler */
    ble_ll_sched_init();
    b1e4:	f005 fc04 	bl	109f0 <ble_ll_sched_init>

    /* Initialize advertiser */
    ble_ll_adv_init();
    b1e8:	f000 fcae 	bl	bb48 <ble_ll_adv_init>

    /* Initialize a scanner */
    ble_ll_scan_init();
    b1ec:	f005 f872 	bl	102d4 <ble_ll_scan_init>

    /* Initialize the connection module */
    ble_ll_conn_module_init();
    b1f0:	f002 f92a 	bl	d448 <ble_ll_conn_module_init>
    features |= BLE_LL_FEAT_LE_ENCRYPTION;
#endif

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    features |= (BLE_LL_FEAT_LL_PRIVACY | BLE_LL_FEAT_EXT_SCAN_FILT);
    ble_ll_resolv_init();
    b1f4:	f004 fb66 	bl	f8c4 <ble_ll_resolv_init>
#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    features |= BLE_LL_FEAT_LE_PING;
#endif

    /* Initialize random number generation */
    ble_ll_rand_init();
    b1f8:	f004 f99c 	bl	f534 <ble_ll_rand_init>

    lldata->ll_supp_features = features;
    b1fc:	23fd      	movs	r3, #253	; 0xfd
    b1fe:	7063      	strb	r3, [r4, #1]

    /* Initialize the LL task */
    os_task_init(&g_ble_ll_task, "ble_ll", ble_ll_task, NULL, ll_task_prio,
    b200:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    b204:	4c0d      	ldr	r4, [pc, #52]	; (b23c <ble_ll_init+0x98>)
    b206:	9301      	str	r3, [sp, #4]
    b208:	4b0d      	ldr	r3, [pc, #52]	; (b240 <ble_ll_init+0x9c>)
    b20a:	9302      	str	r3, [sp, #8]
    b20c:	2350      	movs	r3, #80	; 0x50
    b20e:	9303      	str	r3, [sp, #12]
    b210:	4621      	mov	r1, r4
    b212:	462b      	mov	r3, r5
    b214:	9600      	str	r6, [sp, #0]
    b216:	4a0b      	ldr	r2, [pc, #44]	; (b244 <ble_ll_init+0xa0>)
    b218:	480b      	ldr	r0, [pc, #44]	; (b248 <ble_ll_init+0xa4>)
    b21a:	f7ff fa55 	bl	a6c8 <os_task_init>
                 OS_WAIT_FOREVER, g_ble_ll_stack, BLE_LL_STACK_SIZE);

    rc = stats_init_and_reg(STATS_HDR(ble_ll_stats),
    b21e:	9500      	str	r5, [sp, #0]
    b220:	9401      	str	r4, [sp, #4]
    b222:	2104      	movs	r1, #4
    b224:	221e      	movs	r2, #30
    b226:	462b      	mov	r3, r5
    b228:	4808      	ldr	r0, [pc, #32]	; (b24c <ble_ll_init+0xa8>)
    b22a:	f012 f88f 	bl	1d34c <stats_init_and_reg>
                            STATS_SIZE_INIT_PARMS(ble_ll_stats, STATS_SIZE_32),
                            STATS_NAME_INIT_PARMS(ble_ll_stats),
                            "ble_ll");
    return rc;
}
    b22e:	b004      	add	sp, #16
    b230:	bd70      	pop	{r4, r5, r6, pc}
    b232:	bf00      	nop
    b234:	200032c0 	.word	0x200032c0
    b238:	0000abcd 	.word	0x0000abcd
    b23c:	0001f23f 	.word	0x0001f23f
    b240:	20003130 	.word	0x20003130
    b244:	0000ac21 	.word	0x0000ac21
    b248:	20003270 	.word	0x20003270
    b24c:	200030ac 	.word	0x200030ac

0000b250 <ble_ll_adv_tx_done>:
 * @param advsm
 *
 */
static void
ble_ll_adv_tx_done(void *arg)
{
    b250:	b508      	push	{r3, lr}
    struct ble_ll_adv_sm *advsm;

    advsm = (struct ble_ll_adv_sm *)arg;
    os_eventq_put(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);
    b252:	f100 0180 	add.w	r1, r0, #128	; 0x80
    b256:	4804      	ldr	r0, [pc, #16]	; (b268 <ble_ll_adv_tx_done+0x18>)
    b258:	f7fe fccb 	bl	9bf2 <os_eventq_put>

    ble_ll_log(BLE_LL_LOG_ID_ADV_TXDONE, ble_ll_state_get(), 0, 0);

    ble_ll_state_set(BLE_LL_STATE_STANDBY);
    b25c:	2000      	movs	r0, #0
}
    b25e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    advsm = (struct ble_ll_adv_sm *)arg;
    os_eventq_put(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);

    ble_ll_log(BLE_LL_LOG_ID_ADV_TXDONE, ble_ll_state_get(), 0, 0);

    ble_ll_state_set(BLE_LL_STATE_STANDBY);
    b262:	f7ff bf3f 	b.w	b0e4 <ble_ll_state_set>
    b266:	bf00      	nop
    b268:	200032c8 	.word	0x200032c8

0000b26c <ble_ll_adv_set_sched>:
    return BLE_LL_SCHED_STATE_DONE;
}

static void
ble_ll_adv_set_sched(struct ble_ll_adv_sm *advsm, int sched_new)
{
    b26c:	b570      	push	{r4, r5, r6, lr}
    b26e:	4604      	mov	r4, r0
    uint32_t max_usecs;
    struct ble_ll_sched_item *sch;

    sch = &advsm->adv_sch;
    sch->cb_arg = advsm;
    sch->sched_cb = ble_ll_adv_tx_start_cb;
    b270:	4b18      	ldr	r3, [pc, #96]	; (b2d4 <ble_ll_adv_set_sched+0x68>)
{
    uint32_t max_usecs;
    struct ble_ll_sched_item *sch;

    sch = &advsm->adv_sch;
    sch->cb_arg = advsm;
    b272:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
    sch->sched_cb = ble_ll_adv_tx_start_cb;
    sch->sched_type = BLE_LL_SCHED_TYPE_ADV;

    /* Set end time to maximum time this schedule item may take */
    max_usecs = BLE_TX_DUR_USECS_M(advsm->adv_pdu_len);
    b276:	7a45      	ldrb	r5, [r0, #9]
    uint32_t max_usecs;
    struct ble_ll_sched_item *sch;

    sch = &advsm->adv_sch;
    sch->cb_arg = advsm;
    sch->sched_cb = ble_ll_adv_tx_start_cb;
    b278:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    sch->sched_type = BLE_LL_SCHED_TYPE_ADV;
    b27c:	2301      	movs	r3, #1
    b27e:	f880 308c 	strb.w	r3, [r0, #140]	; 0x8c

    /* Set end time to maximum time this schedule item may take */
    max_usecs = BLE_TX_DUR_USECS_M(advsm->adv_pdu_len);
    switch (advsm->adv_type) {
    b282:	7843      	ldrb	r3, [r0, #1]
    sch->cb_arg = advsm;
    sch->sched_cb = ble_ll_adv_tx_start_cb;
    sch->sched_type = BLE_LL_SCHED_TYPE_ADV;

    /* Set end time to maximum time this schedule item may take */
    max_usecs = BLE_TX_DUR_USECS_M(advsm->adv_pdu_len);
    b284:	350a      	adds	r5, #10
    b286:	00ed      	lsls	r5, r5, #3
    switch (advsm->adv_type) {
    b288:	2b04      	cmp	r3, #4
    b28a:	d809      	bhi.n	b2a0 <ble_ll_adv_set_sched+0x34>
    b28c:	e8df f003 	tbb	[pc, r3]
    b290:	08060306 	.word	0x08060306
    b294:	03          	.byte	0x03
    b295:	00          	.byte	0x00
    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD:
    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD:
        max_usecs += BLE_LL_ADV_DIRECT_SCHED_MAX_USECS;
    b296:	f505 75fb 	add.w	r5, r5, #502	; 0x1f6
        break;
    b29a:	e001      	b.n	b2a0 <ble_ll_adv_set_sched+0x34>
    case BLE_HCI_ADV_TYPE_ADV_IND:
    case BLE_HCI_ADV_TYPE_ADV_SCAN_IND:
        max_usecs += BLE_LL_ADV_SCHED_MAX_USECS;
    b29c:	f505 7555 	add.w	r5, r5, #852	; 0x354
     * XXX: For now, just schedule some additional time so we insure we have
     * enough time to do everything we want.
     */
    max_usecs += XCVR_PROC_DELAY_USECS;

    if (sched_new) {
    b2a0:	b139      	cbz	r1, b2b2 <ble_ll_adv_set_sched+0x46>
        /*
         * We have to add the scheduling delay and tx start delay to the max
         * time of the event since the pdu does not start at the scheduled start.
         */
        max_usecs += XCVR_TX_SCHED_DELAY_USECS;
        sch->start_time = cputime_get32();
    b2a2:	f7fd fe4b 	bl	8f3c <cputime_get32>
    b2a6:	4606      	mov	r6, r0
    b2a8:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
        sch->end_time = sch->start_time + cputime_usecs_to_ticks(max_usecs);
    b2ac:	f105 00f0 	add.w	r0, r5, #240	; 0xf0
    b2b0:	e009      	b.n	b2c6 <ble_ll_adv_set_sched+0x5a>
    } else {
        sch->start_time = advsm->adv_pdu_start_time -
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
    b2b2:	20be      	movs	r0, #190	; 0xbe
         */
        max_usecs += XCVR_TX_SCHED_DELAY_USECS;
        sch->start_time = cputime_get32();
        sch->end_time = sch->start_time + cputime_usecs_to_ticks(max_usecs);
    } else {
        sch->start_time = advsm->adv_pdu_start_time -
    b2b4:	69e6      	ldr	r6, [r4, #28]
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
    b2b6:	f7fd fcfd 	bl	8cb4 <cputime_usecs_to_ticks>
         */
        max_usecs += XCVR_TX_SCHED_DELAY_USECS;
        sch->start_time = cputime_get32();
        sch->end_time = sch->start_time + cputime_usecs_to_ticks(max_usecs);
    } else {
        sch->start_time = advsm->adv_pdu_start_time -
    b2ba:	1a30      	subs	r0, r6, r0
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
        sch->end_time = advsm->adv_pdu_start_time +
    b2bc:	69e6      	ldr	r6, [r4, #28]
         */
        max_usecs += XCVR_TX_SCHED_DELAY_USECS;
        sch->start_time = cputime_get32();
        sch->end_time = sch->start_time + cputime_usecs_to_ticks(max_usecs);
    } else {
        sch->start_time = advsm->adv_pdu_start_time -
    b2be:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
        sch->end_time = advsm->adv_pdu_start_time +
            cputime_usecs_to_ticks(max_usecs);
    b2c2:	f105 0032 	add.w	r0, r5, #50	; 0x32
    b2c6:	f7fd fcf5 	bl	8cb4 <cputime_usecs_to_ticks>
        sch->start_time = cputime_get32();
        sch->end_time = sch->start_time + cputime_usecs_to_ticks(max_usecs);
    } else {
        sch->start_time = advsm->adv_pdu_start_time -
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
        sch->end_time = advsm->adv_pdu_start_time +
    b2ca:	4430      	add	r0, r6
    b2cc:	f8c4 0094 	str.w	r0, [r4, #148]	; 0x94
    b2d0:	bd70      	pop	{r4, r5, r6, pc}
    b2d2:	bf00      	nop
    b2d4:	0000b2d9 	.word	0x0000b2d9

0000b2d8 <ble_ll_adv_tx_start_cb>:
 *
 * @return int
 */
static int
ble_ll_adv_tx_start_cb(struct ble_ll_sched_item *sch)
{
    b2d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t txstart;
    struct ble_ll_adv_sm *advsm;
    struct os_mbuf *adv_pdu;

    /* Get the state machine for the event */
    advsm = (struct ble_ll_adv_sm *)sch->cb_arg;
    b2da:	68c4      	ldr	r4, [r0, #12]

    /* Set channel */
    rc = ble_phy_setchan(advsm->adv_chan, 0, 0);
    b2dc:	2100      	movs	r1, #0
 *
 * @return int
 */
static int
ble_ll_adv_tx_start_cb(struct ble_ll_sched_item *sch)
{
    b2de:	4605      	mov	r5, r0

    /* Get the state machine for the event */
    advsm = (struct ble_ll_adv_sm *)sch->cb_arg;

    /* Set channel */
    rc = ble_phy_setchan(advsm->adv_chan, 0, 0);
    b2e0:	460a      	mov	r2, r1
    b2e2:	79e0      	ldrb	r0, [r4, #7]
    b2e4:	f005 ff46 	bl	11174 <ble_phy_setchan>
    assert(rc == 0);
    b2e8:	b118      	cbz	r0, b2f2 <ble_ll_adv_tx_start_cb+0x1a>
    b2ea:	4848      	ldr	r0, [pc, #288]	; (b40c <ble_ll_adv_tx_start_cb+0x134>)
    b2ec:	f44f 71b7 	mov.w	r1, #366	; 0x16e
    b2f0:	e047      	b.n	b382 <ble_ll_adv_tx_start_cb+0xaa>

    /* Set transmit start time. */
    txstart = sch->start_time + XCVR_PROC_DELAY_USECS;
    b2f2:	6868      	ldr	r0, [r5, #4]
    rc = ble_phy_tx_set_start_time(txstart);
    b2f4:	3032      	adds	r0, #50	; 0x32
    b2f6:	f006 f915 	bl	11524 <ble_phy_tx_set_start_time>
    if (rc) {
    b2fa:	b120      	cbz	r0, b306 <ble_ll_adv_tx_start_cb+0x2e>
        STATS_INC(ble_ll_stats, adv_late_starts);
    b2fc:	4a44      	ldr	r2, [pc, #272]	; (b410 <ble_ll_adv_tx_start_cb+0x138>)
    b2fe:	6e53      	ldr	r3, [r2, #100]	; 0x64
    b300:	3301      	adds	r3, #1
    b302:	6653      	str	r3, [r2, #100]	; 0x64
        goto adv_tx_done;
    b304:	e07c      	b.n	b400 <ble_ll_adv_tx_start_cb+0x128>
    }

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    /* XXX: automatically do this in the phy based on channel? */
    ble_phy_encrypt_disable();
    b306:	f005 fef9 	bl	110fc <ble_phy_encrypt_disable>
#endif

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    advsm->adv_rpa_index = -1;
    b30a:	23ff      	movs	r3, #255	; 0xff
    b30c:	72a3      	strb	r3, [r4, #10]
    if (ble_ll_resolv_enabled()) {
    b30e:	f004 fad3 	bl	f8b8 <ble_ll_resolv_enabled>
    b312:	b110      	cbz	r0, b31a <ble_ll_adv_tx_start_cb+0x42>
        ble_phy_resolv_list_enable();
    b314:	f006 f9ca 	bl	116ac <ble_phy_resolv_list_enable>
    b318:	e001      	b.n	b31e <ble_ll_adv_tx_start_cb+0x46>
    } else {
        ble_phy_resolv_list_disable();
    b31a:	f006 f9d7 	bl	116cc <ble_phy_resolv_list_disable>
    }
#endif

    /* Set phy mode based on type of advertisement */
    if (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_NONCONN_IND) {
    b31e:	7863      	ldrb	r3, [r4, #1]
    b320:	2b03      	cmp	r3, #3
    b322:	d105      	bne.n	b330 <ble_ll_adv_tx_start_cb+0x58>
        end_trans = BLE_PHY_TRANSITION_NONE;
        ble_phy_set_txend_cb(ble_ll_adv_tx_done, advsm);
    b324:	483b      	ldr	r0, [pc, #236]	; (b414 <ble_ll_adv_tx_start_cb+0x13c>)
    b326:	4621      	mov	r1, r4
    b328:	f005 fefe 	bl	11128 <ble_phy_set_txend_cb>
    }
#endif

    /* Set phy mode based on type of advertisement */
    if (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_NONCONN_IND) {
        end_trans = BLE_PHY_TRANSITION_NONE;
    b32c:	2700      	movs	r7, #0
    b32e:	e004      	b.n	b33a <ble_ll_adv_tx_start_cb+0x62>
        ble_phy_set_txend_cb(ble_ll_adv_tx_done, advsm);
    } else {
        end_trans = BLE_PHY_TRANSITION_TX_RX;
        ble_phy_set_txend_cb(NULL, NULL);
    b330:	2000      	movs	r0, #0
    b332:	4601      	mov	r1, r0
    b334:	f005 fef8 	bl	11128 <ble_phy_set_txend_cb>
    /* Set phy mode based on type of advertisement */
    if (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_NONCONN_IND) {
        end_trans = BLE_PHY_TRANSITION_NONE;
        ble_phy_set_txend_cb(ble_ll_adv_tx_done, advsm);
    } else {
        end_trans = BLE_PHY_TRANSITION_TX_RX;
    b338:	2702      	movs	r7, #2
        ble_phy_set_txend_cb(NULL, NULL);
    }

    /* Get an advertising mbuf (packet header)  */
    adv_pdu = os_msys_get_pkthdr(BLE_MBUF_PAYLOAD_SIZE,
    b33a:	f44f 7082 	mov.w	r0, #260	; 0x104
    b33e:	2108      	movs	r1, #8
    b340:	f7fe fdf7 	bl	9f32 <os_msys_get_pkthdr>
                                 sizeof(struct ble_mbuf_hdr));
    if (!adv_pdu) {
    b344:	4605      	mov	r5, r0
    b346:	b910      	cbnz	r0, b34e <ble_ll_adv_tx_start_cb+0x76>
        ble_phy_disable();
    b348:	f005 ff68 	bl	1121c <ble_phy_disable>
        goto adv_tx_done;
    b34c:	e058      	b.n	b400 <ble_ll_adv_tx_start_cb+0x128>
    /* assume this is not a direct ind */
    adv_data_len = advsm->adv_len;
    pdulen = BLE_DEV_ADDR_LEN + adv_data_len;

    /* Must be an advertising type! */
    switch (advsm->adv_type) {
    b34e:	7863      	ldrb	r3, [r4, #1]
    uint8_t     *dptr;
    uint8_t     pdulen;
    uint8_t     pdu_type;

    /* assume this is not a direct ind */
    adv_data_len = advsm->adv_len;
    b350:	78a6      	ldrb	r6, [r4, #2]
    pdulen = BLE_DEV_ADDR_LEN + adv_data_len;

    /* Must be an advertising type! */
    switch (advsm->adv_type) {
    b352:	2b04      	cmp	r3, #4
    b354:	d813      	bhi.n	b37e <ble_ll_adv_tx_start_cb+0xa6>
    b356:	e8df f003 	tbb	[pc, r3]
    b35a:	050d      	.short	0x050d
    b35c:	030f      	.short	0x030f
    b35e:	05          	.byte	0x05
    b35f:	00          	.byte	0x00
    case BLE_HCI_ADV_TYPE_ADV_IND:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_IND;
        break;

    case BLE_HCI_ADV_TYPE_ADV_NONCONN_IND:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_NONCONN_IND;
    b360:	2202      	movs	r2, #2
    b362:	e00a      	b.n	b37a <ble_ll_adv_tx_start_cb+0xa2>
    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD:
    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_DIRECT_IND;
        adv_data_len = 0;
        pdulen = BLE_ADV_DIRECT_IND_LEN;
        if (advsm->adv_rxadd) {
    b364:	7b63      	ldrb	r3, [r4, #13]
            pdu_type |= BLE_ADV_PDU_HDR_RXADD_RAND;
    b366:	2b00      	cmp	r3, #0
    b368:	bf0c      	ite	eq
    b36a:	2201      	moveq	r2, #1
    b36c:	2281      	movne	r2, #129	; 0x81
    case BLE_HCI_ADV_TYPE_ADV_NONCONN_IND:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_NONCONN_IND;
        break;

    case BLE_HCI_ADV_TYPE_ADV_SCAN_IND:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_SCAN_IND;
    b36e:	210c      	movs	r1, #12
    b370:	2600      	movs	r6, #0
    b372:	e00c      	b.n	b38e <ble_ll_adv_tx_start_cb+0xb6>
    pdulen = BLE_DEV_ADDR_LEN + adv_data_len;

    /* Must be an advertising type! */
    switch (advsm->adv_type) {
    case BLE_HCI_ADV_TYPE_ADV_IND:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_IND;
    b374:	2200      	movs	r2, #0
    b376:	e000      	b.n	b37a <ble_ll_adv_tx_start_cb+0xa2>
    case BLE_HCI_ADV_TYPE_ADV_NONCONN_IND:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_NONCONN_IND;
        break;

    case BLE_HCI_ADV_TYPE_ADV_SCAN_IND:
        pdu_type = BLE_ADV_PDU_TYPE_ADV_SCAN_IND;
    b378:	2206      	movs	r2, #6
        adv_data_len = 0xFF;
        break;
    }

    /* An invalid advertising data length indicates a memory overwrite */
    assert(adv_data_len <= BLE_ADV_DATA_MAX_LEN);
    b37a:	2e1f      	cmp	r6, #31
    b37c:	d905      	bls.n	b38a <ble_ll_adv_tx_start_cb+0xb2>
    b37e:	4823      	ldr	r0, [pc, #140]	; (b40c <ble_ll_adv_tx_start_cb+0x134>)
    b380:	21f0      	movs	r1, #240	; 0xf0
    b382:	2200      	movs	r2, #0
    b384:	4613      	mov	r3, r2
    b386:	f7fe fca3 	bl	9cd0 <__assert_func>
    uint8_t     pdulen;
    uint8_t     pdu_type;

    /* assume this is not a direct ind */
    adv_data_len = advsm->adv_len;
    pdulen = BLE_DEV_ADDR_LEN + adv_data_len;
    b38a:	1db1      	adds	r1, r6, #6
    b38c:	b2c9      	uxtb	r1, r1

    /* An invalid advertising data length indicates a memory overwrite */
    assert(adv_data_len <= BLE_ADV_DATA_MAX_LEN);

    /* Set the PDU length in the state machine (includes header) */
    advsm->adv_pdu_len = pdulen + BLE_LL_PDU_HDR_LEN;
    b38e:	1c8b      	adds	r3, r1, #2
    b390:	7263      	strb	r3, [r4, #9]

    /* Set TxAdd to random if needed. */
    if (advsm->adv_txadd) {
    b392:	7b23      	ldrb	r3, [r4, #12]
    b394:	b10b      	cbz	r3, b39a <ble_ll_adv_tx_start_cb+0xc2>
        pdu_type |= BLE_ADV_PDU_HDR_TXADD_RAND;
    b396:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    }

    /* Get the advertising PDU and initialize it*/
    ble_ll_mbuf_init(m, pdulen, pdu_type);
    b39a:	4628      	mov	r0, r5
    b39c:	f7ff fec0 	bl	b120 <ble_ll_mbuf_init>

    /* Construct advertisement */
    dptr = m->om_data;
    memcpy(dptr, advsm->adva, BLE_DEV_ADDR_LEN);
    b3a0:	4622      	mov	r2, r4

    /* Get the advertising PDU and initialize it*/
    ble_ll_mbuf_init(m, pdulen, pdu_type);

    /* Construct advertisement */
    dptr = m->om_data;
    b3a2:	682b      	ldr	r3, [r5, #0]
    memcpy(dptr, advsm->adva, BLE_DEV_ADDR_LEN);
    b3a4:	f852 1f28 	ldr.w	r1, [r2, #40]!
    b3a8:	6019      	str	r1, [r3, #0]
    b3aa:	8892      	ldrh	r2, [r2, #4]
    b3ac:	809a      	strh	r2, [r3, #4]
    dptr += BLE_DEV_ADDR_LEN;

    /* For ADV_DIRECT_IND add inita */
    if (advsm->adv_directed) {
    b3ae:	7ae2      	ldrb	r2, [r4, #11]
    ble_ll_mbuf_init(m, pdulen, pdu_type);

    /* Construct advertisement */
    dptr = m->om_data;
    memcpy(dptr, advsm->adva, BLE_DEV_ADDR_LEN);
    dptr += BLE_DEV_ADDR_LEN;
    b3b0:	1d98      	adds	r0, r3, #6

    /* For ADV_DIRECT_IND add inita */
    if (advsm->adv_directed) {
    b3b2:	b132      	cbz	r2, b3c2 <ble_ll_adv_tx_start_cb+0xea>
        memcpy(dptr, advsm->initiator_addr, BLE_DEV_ADDR_LEN);
    b3b4:	4622      	mov	r2, r4
    b3b6:	f852 1f3a 	ldr.w	r1, [r2, #58]!
    b3ba:	f8c3 1006 	str.w	r1, [r3, #6]
    b3be:	8893      	ldrh	r3, [r2, #4]
    b3c0:	8083      	strh	r3, [r0, #4]
    }

    /* Copy in advertising data, if any */
    if (adv_data_len != 0) {
    b3c2:	b126      	cbz	r6, b3ce <ble_ll_adv_tx_start_cb+0xf6>
        memcpy(dptr, advsm->adv_data, adv_data_len);
    b3c4:	f104 0140 	add.w	r1, r4, #64	; 0x40
    b3c8:	4632      	mov	r2, r6
    b3ca:	f7fd fe17 	bl	8ffc <memcpy>
    }

    ble_ll_adv_pdu_make(advsm, adv_pdu);

    /* Transmit advertisement */
    rc = ble_phy_tx(adv_pdu, end_trans);
    b3ce:	4628      	mov	r0, r5
    b3d0:	4639      	mov	r1, r7
    b3d2:	f006 f8c9 	bl	11568 <ble_phy_tx>
    b3d6:	4606      	mov	r6, r0
    os_mbuf_free_chain(adv_pdu);
    b3d8:	4628      	mov	r0, r5
    b3da:	f7fe fdc0 	bl	9f5e <os_mbuf_free_chain>
    if (rc) {
    b3de:	b97e      	cbnz	r6, b400 <ble_ll_adv_tx_start_cb+0x128>
        goto adv_tx_done;
    }

    /* Enable/disable whitelisting based on filter policy */
    if (advsm->adv_filter_policy != BLE_HCI_ADV_FILT_NONE) {
    b3e0:	7923      	ldrb	r3, [r4, #4]
    b3e2:	b113      	cbz	r3, b3ea <ble_ll_adv_tx_start_cb+0x112>
        ble_ll_whitelist_enable();
    b3e4:	f005 fba0 	bl	10b28 <ble_ll_whitelist_enable>
    b3e8:	e001      	b.n	b3ee <ble_ll_adv_tx_start_cb+0x116>
    } else {
        ble_ll_whitelist_disable();
    b3ea:	f005 fb9f 	bl	10b2c <ble_ll_whitelist_disable>
    }

    /* Set link layer state to advertising */
    ble_ll_state_set(BLE_LL_STATE_ADV);
    b3ee:	2001      	movs	r0, #1
    b3f0:	f7ff fe78 	bl	b0e4 <ble_ll_state_set>

    /* Count # of adv. sent */
    STATS_INC(ble_ll_stats, adv_txg);
    b3f4:	4a06      	ldr	r2, [pc, #24]	; (b410 <ble_ll_adv_tx_start_cb+0x138>)
    b3f6:	6e13      	ldr	r3, [r2, #96]	; 0x60
    b3f8:	3301      	adds	r3, #1
    b3fa:	6613      	str	r3, [r2, #96]	; 0x60

    return BLE_LL_SCHED_STATE_RUNNING;
    b3fc:	2000      	movs	r0, #0
    b3fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

adv_tx_done:
    ble_ll_adv_tx_done(advsm);
    b400:	4620      	mov	r0, r4
    b402:	f7ff ff25 	bl	b250 <ble_ll_adv_tx_done>
    return BLE_LL_SCHED_STATE_DONE;
    b406:	2001      	movs	r0, #1
}
    b408:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b40a:	bf00      	nop
    b40c:	0001f246 	.word	0x0001f246
    b410:	200030ac 	.word	0x200030ac
    b414:	0000b251 	.word	0x0000b251

0000b418 <ble_ll_adv_sm_stop.constprop.4>:
 * Context: Link Layer task.
 *
 * @param advsm
 */
static void
ble_ll_adv_sm_stop(struct ble_ll_adv_sm *advsm)
    b418:	b538      	push	{r3, r4, r5, lr}
{
    os_sr_t sr;

    if (advsm->enabled) {
    b41a:	4c0f      	ldr	r4, [pc, #60]	; (b458 <ble_ll_adv_sm_stop.constprop.4+0x40>)
    b41c:	7823      	ldrb	r3, [r4, #0]
    b41e:	b1cb      	cbz	r3, b454 <ble_ll_adv_sm_stop.constprop.4+0x3c>
        /* Remove any scheduled advertising items */
        ble_ll_sched_rmv_elem(&advsm->adv_sch);
    b420:	f104 008c 	add.w	r0, r4, #140	; 0x8c
    b424:	f005 faa0 	bl	10968 <ble_ll_sched_rmv_elem>
        os_eventq_remove(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);
    b428:	f104 0180 	add.w	r1, r4, #128	; 0x80
    b42c:	480b      	ldr	r0, [pc, #44]	; (b45c <ble_ll_adv_sm_stop.constprop.4+0x44>)
    b42e:	f7fe fc30 	bl	9c92 <os_eventq_remove>

        /* Set to standby if we are no longer advertising */
        OS_ENTER_CRITICAL(sr);
    b432:	f7fe fa75 	bl	9920 <os_arch_save_sr>
    b436:	4605      	mov	r5, r0
        if (ble_ll_state_get() == BLE_LL_STATE_ADV) {
    b438:	f7ff fe5a 	bl	b0f0 <ble_ll_state_get>
    b43c:	2801      	cmp	r0, #1
    b43e:	d104      	bne.n	b44a <ble_ll_adv_sm_stop.constprop.4+0x32>
            ble_ll_wfr_disable();
    b440:	f7ff fd74 	bl	af2c <ble_ll_wfr_disable>
            ble_ll_state_set(BLE_LL_STATE_STANDBY);
    b444:	2000      	movs	r0, #0
    b446:	f7ff fe4d 	bl	b0e4 <ble_ll_state_set>
        }
        OS_EXIT_CRITICAL(sr);
    b44a:	4628      	mov	r0, r5
    b44c:	f7fe fa6e 	bl	992c <os_arch_restore_sr>

        /* Disable advertising */
        advsm->enabled = 0;
    b450:	2300      	movs	r3, #0
    b452:	7023      	strb	r3, [r4, #0]
    b454:	bd38      	pop	{r3, r4, r5, pc}
    b456:	bf00      	nop
    b458:	20003310 	.word	0x20003310
    b45c:	200032c8 	.word	0x200032c8

0000b460 <ble_ll_adv_chk_rpa_timeout>:


#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
void
ble_ll_adv_chk_rpa_timeout(struct ble_ll_adv_sm *advsm)
{
    b460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t now;

    if (advsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    b464:	7943      	ldrb	r3, [r0, #5]
    b466:	2b01      	cmp	r3, #1


#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
void
ble_ll_adv_chk_rpa_timeout(struct ble_ll_adv_sm *advsm)
{
    b468:	4604      	mov	r4, r0
    uint32_t now;

    if (advsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    b46a:	d936      	bls.n	b4da <ble_ll_adv_chk_rpa_timeout+0x7a>
        now = os_time_get();
    b46c:	f7ff f9a8 	bl	a7c0 <os_time_get>
        if ((int32_t)(now - advsm->adv_rpa_timer) >= 0) {
    b470:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b472:	1ac3      	subs	r3, r0, r3
    b474:	2b00      	cmp	r3, #0
ble_ll_adv_chk_rpa_timeout(struct ble_ll_adv_sm *advsm)
{
    uint32_t now;

    if (advsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
        now = os_time_get();
    b476:	4605      	mov	r5, r0
        if ((int32_t)(now - advsm->adv_rpa_timer) >= 0) {
    b478:	db2f      	blt.n	b4da <ble_ll_adv_chk_rpa_timeout+0x7a>
            ble_ll_resolv_gen_rpa(advsm->peer_addr, advsm->peer_addr_type,
    b47a:	f104 0834 	add.w	r8, r4, #52	; 0x34
                                  advsm->adva, 1);
    b47e:	f104 0728 	add.w	r7, r4, #40	; 0x28
    uint32_t now;

    if (advsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
        now = os_time_get();
        if ((int32_t)(now - advsm->adv_rpa_timer) >= 0) {
            ble_ll_resolv_gen_rpa(advsm->peer_addr, advsm->peer_addr_type,
    b482:	2301      	movs	r3, #1
    b484:	4640      	mov	r0, r8
    b486:	79a1      	ldrb	r1, [r4, #6]
    b488:	463a      	mov	r2, r7
    b48a:	f004 f9cd 	bl	f828 <ble_ll_resolv_gen_rpa>
                                  advsm->adva, 1);

            if (advsm->adv_directed) {
    b48e:	7ae3      	ldrb	r3, [r4, #11]
    b490:	b19b      	cbz	r3, b4ba <ble_ll_adv_chk_rpa_timeout+0x5a>
                ble_ll_resolv_gen_rpa(advsm->peer_addr, advsm->peer_addr_type,
                                      advsm->initiator_addr, 0);
    b492:	f104 063a 	add.w	r6, r4, #58	; 0x3a
        if ((int32_t)(now - advsm->adv_rpa_timer) >= 0) {
            ble_ll_resolv_gen_rpa(advsm->peer_addr, advsm->peer_addr_type,
                                  advsm->adva, 1);

            if (advsm->adv_directed) {
                ble_ll_resolv_gen_rpa(advsm->peer_addr, advsm->peer_addr_type,
    b496:	79a1      	ldrb	r1, [r4, #6]
    b498:	4640      	mov	r0, r8
    b49a:	4632      	mov	r2, r6
    b49c:	2300      	movs	r3, #0
    b49e:	f004 f9c3 	bl	f828 <ble_ll_resolv_gen_rpa>
                                      advsm->initiator_addr, 0);
                if (ble_ll_is_rpa(advsm->initiator_addr, 1)) {
    b4a2:	4630      	mov	r0, r6
    b4a4:	2101      	movs	r1, #1
    b4a6:	f7ff fcd5 	bl	ae54 <ble_ll_is_rpa>
    b4aa:	b108      	cbz	r0, b4b0 <ble_ll_adv_chk_rpa_timeout+0x50>
                    advsm->adv_rxadd = 1;
    b4ac:	2301      	movs	r3, #1
    b4ae:	e003      	b.n	b4b8 <ble_ll_adv_chk_rpa_timeout+0x58>
                } else {
                    if (advsm->own_addr_type & 1) {
    b4b0:	7963      	ldrb	r3, [r4, #5]
    b4b2:	f013 0301 	ands.w	r3, r3, #1
    b4b6:	d1f9      	bne.n	b4ac <ble_ll_adv_chk_rpa_timeout+0x4c>
                        advsm->adv_rxadd = 1;
                    } else {
                        advsm->adv_rxadd = 0;
    b4b8:	7363      	strb	r3, [r4, #13]
                    }
                }
            }
            advsm->adv_rpa_timer = now + ble_ll_resolv_get_rpa_tmo();
    b4ba:	f004 f96d 	bl	f798 <ble_ll_resolv_get_rpa_tmo>
    b4be:	4428      	add	r0, r5
    b4c0:	6260      	str	r0, [r4, #36]	; 0x24

            /* May have to reset txadd bit */
            if (ble_ll_is_rpa(advsm->adva, 1)) {
    b4c2:	2101      	movs	r1, #1
    b4c4:	4638      	mov	r0, r7
    b4c6:	f7ff fcc5 	bl	ae54 <ble_ll_is_rpa>
    b4ca:	b108      	cbz	r0, b4d0 <ble_ll_adv_chk_rpa_timeout+0x70>
                advsm->adv_txadd = 1;
    b4cc:	2301      	movs	r3, #1
    b4ce:	e003      	b.n	b4d8 <ble_ll_adv_chk_rpa_timeout+0x78>
            } else {
                if (advsm->own_addr_type & 1) {
    b4d0:	7963      	ldrb	r3, [r4, #5]
    b4d2:	f013 0301 	ands.w	r3, r3, #1
    b4d6:	d1f9      	bne.n	b4cc <ble_ll_adv_chk_rpa_timeout+0x6c>
                    advsm->adv_txadd = 1;
                } else {
                    advsm->adv_txadd = 0;
    b4d8:	7323      	strb	r3, [r4, #12]
    b4da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

0000b4e0 <ble_ll_adv_halt>:
 *
 */
void
ble_ll_adv_halt(void)
{
    ble_ll_adv_tx_done(&g_ble_ll_adv_sm);
    b4e0:	4801      	ldr	r0, [pc, #4]	; (b4e8 <ble_ll_adv_halt+0x8>)
    b4e2:	f7ff beb5 	b.w	b250 <ble_ll_adv_tx_done>
    b4e6:	bf00      	nop
    b4e8:	20003310 	.word	0x20003310

0000b4ec <ble_ll_adv_set_adv_params>:
 *
 * @return int
 */
int
ble_ll_adv_set_adv_params(uint8_t *cmd)
{
    b4ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint16_t min_itvl;
    struct ble_ll_adv_sm *advsm;

    /* If already enabled, we return an error */
    advsm = &g_ble_ll_adv_sm;
    if (advsm->enabled) {
    b4f0:	4c37      	ldr	r4, [pc, #220]	; (b5d0 <ble_ll_adv_set_adv_params+0xe4>)
    b4f2:	f894 a000 	ldrb.w	sl, [r4]
 *
 * @return int
 */
int
ble_ll_adv_set_adv_params(uint8_t *cmd)
{
    b4f6:	4605      	mov	r5, r0
    uint16_t min_itvl;
    struct ble_ll_adv_sm *advsm;

    /* If already enabled, we return an error */
    advsm = &g_ble_ll_adv_sm;
    if (advsm->enabled) {
    b4f8:	f1ba 0f00 	cmp.w	sl, #0
    b4fc:	d165      	bne.n	b5ca <ble_ll_adv_set_adv_params+0xde>
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* Make sure intervals are OK (along with advertising type */
    adv_itvl_min = le16toh(cmd);
    b4fe:	f011 fdc6 	bl	1d08e <le16toh>
    b502:	4606      	mov	r6, r0
    adv_itvl_max = le16toh(cmd + 2);
    b504:	1ca8      	adds	r0, r5, #2
    b506:	f011 fdc2 	bl	1d08e <le16toh>
    adv_type = cmd[4];
    b50a:	f895 8004 	ldrb.w	r8, [r5, #4]

    /*
     * Get the filter policy now since we will ignore it if we are doing
     * directed advertising
     */
    adv_filter_policy = cmd[14];
    b50e:	f895 900e 	ldrb.w	r9, [r5, #14]

    /* Assume min interval based on low duty cycle/indirect advertising */
    min_itvl = BLE_LL_ADV_ITVL_MIN;

    advsm->adv_directed = 0;
    b512:	f884 a00b 	strb.w	sl, [r4, #11]
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* Make sure intervals are OK (along with advertising type */
    adv_itvl_min = le16toh(cmd);
    adv_itvl_max = le16toh(cmd + 2);
    b516:	4607      	mov	r7, r0

    /* Assume min interval based on low duty cycle/indirect advertising */
    min_itvl = BLE_LL_ADV_ITVL_MIN;

    advsm->adv_directed = 0;
    switch (adv_type) {
    b518:	f1b8 0f04 	cmp.w	r8, #4
    b51c:	d817      	bhi.n	b54e <ble_ll_adv_set_adv_params+0x62>
    b51e:	e8df f008 	tbb	[pc, r8]
    b522:	0519      	.short	0x0519
    b524:	0303      	.short	0x0303
    b526:	09          	.byte	0x09
    b527:	00          	.byte	0x00
    case BLE_HCI_ADV_TYPE_ADV_IND:
        /* Nothing to do */
        break;
    case BLE_HCI_ADV_TYPE_ADV_NONCONN_IND:
    case BLE_HCI_ADV_TYPE_ADV_SCAN_IND:
        min_itvl = BLE_LL_ADV_ITVL_NONCONN_MIN;
    b528:	23a0      	movs	r3, #160	; 0xa0
    b52a:	e014      	b.n	b556 <ble_ll_adv_set_adv_params+0x6a>
    advsm->adv_directed = 0;
    switch (adv_type) {
    /* Fall through intentional */
    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD:
        /* Ignore min/max interval */
        min_itvl = 0;
    b52c:	2300      	movs	r3, #0
        adv_itvl_min = 0;
        adv_itvl_max = 0;
    b52e:	461f      	mov	r7, r3
    switch (adv_type) {
    /* Fall through intentional */
    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD:
        /* Ignore min/max interval */
        min_itvl = 0;
        adv_itvl_min = 0;
    b530:	461e      	mov	r6, r3
    b532:	e000      	b.n	b536 <ble_ll_adv_set_adv_params+0x4a>
     * directed advertising
     */
    adv_filter_policy = cmd[14];

    /* Assume min interval based on low duty cycle/indirect advertising */
    min_itvl = BLE_LL_ADV_ITVL_MIN;
    b534:	2320      	movs	r3, #32
        adv_itvl_min = 0;
        adv_itvl_max = 0;

    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD:
        adv_filter_policy = BLE_HCI_ADV_FILT_NONE;
        advsm->adv_directed = 1;
    b536:	2201      	movs	r2, #1
    b538:	72e2      	strb	r2, [r4, #11]
        memcpy(advsm->peer_addr, cmd + 7, BLE_DEV_ADDR_LEN);
    b53a:	462a      	mov	r2, r5
        min_itvl = 0;
        adv_itvl_min = 0;
        adv_itvl_max = 0;

    case BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD:
        adv_filter_policy = BLE_HCI_ADV_FILT_NONE;
    b53c:	f04f 0900 	mov.w	r9, #0
        advsm->adv_directed = 1;
        memcpy(advsm->peer_addr, cmd + 7, BLE_DEV_ADDR_LEN);
    b540:	f852 0f07 	ldr.w	r0, [r2, #7]!
    b544:	6360      	str	r0, [r4, #52]	; 0x34
    b546:	8891      	ldrh	r1, [r2, #4]
    b548:	4a22      	ldr	r2, [pc, #136]	; (b5d4 <ble_ll_adv_set_adv_params+0xe8>)
    b54a:	8091      	strh	r1, [r2, #4]
        break;
    b54c:	e003      	b.n	b556 <ble_ll_adv_set_adv_params+0x6a>
    case BLE_HCI_ADV_TYPE_ADV_NONCONN_IND:
    case BLE_HCI_ADV_TYPE_ADV_SCAN_IND:
        min_itvl = BLE_LL_ADV_ITVL_NONCONN_MIN;
        break;
    default:
        min_itvl = 0xFFFF;
    b54e:	f64f 73ff 	movw	r3, #65535	; 0xffff
        break;
    b552:	e000      	b.n	b556 <ble_ll_adv_set_adv_params+0x6a>
     * directed advertising
     */
    adv_filter_policy = cmd[14];

    /* Assume min interval based on low duty cycle/indirect advertising */
    min_itvl = BLE_LL_ADV_ITVL_MIN;
    b554:	2320      	movs	r3, #32
        min_itvl = 0xFFFF;
        break;
    }

    /* Make sure interval minimum is valid for the advertising type */
    if ((adv_itvl_min > adv_itvl_max) || (adv_itvl_min < min_itvl) ||
    b556:	42be      	cmp	r6, r7
    b558:	d902      	bls.n	b560 <ble_ll_adv_set_adv_params+0x74>
        (adv_itvl_min > BLE_HCI_ADV_ITVL_MAX) ||
        (adv_itvl_max > BLE_HCI_ADV_ITVL_MAX)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    b55a:	2012      	movs	r0, #18
    b55c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        min_itvl = 0xFFFF;
        break;
    }

    /* Make sure interval minimum is valid for the advertising type */
    if ((adv_itvl_min > adv_itvl_max) || (adv_itvl_min < min_itvl) ||
    b560:	429e      	cmp	r6, r3
    b562:	d3fa      	bcc.n	b55a <ble_ll_adv_set_adv_params+0x6e>
    b564:	f5b6 4f80 	cmp.w	r6, #16384	; 0x4000
    b568:	d8f7      	bhi.n	b55a <ble_ll_adv_set_adv_params+0x6e>
        (adv_itvl_min > BLE_HCI_ADV_ITVL_MAX) ||
    b56a:	f5b7 4f80 	cmp.w	r7, #16384	; 0x4000
    b56e:	d8f4      	bhi.n	b55a <ble_ll_adv_set_adv_params+0x6e>
        (adv_itvl_max > BLE_HCI_ADV_ITVL_MAX)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check own and peer address type */
    own_addr_type =  cmd[5];
    b570:	f895 a005 	ldrb.w	sl, [r5, #5]
    peer_addr_type = cmd[6];
    b574:	f895 b006 	ldrb.w	fp, [r5, #6]

    if ((own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) ||
    b578:	f1ba 0f03 	cmp.w	sl, #3
    b57c:	d8ed      	bhi.n	b55a <ble_ll_adv_set_adv_params+0x6e>
    b57e:	f1bb 0f01 	cmp.w	fp, #1
    b582:	d8ea      	bhi.n	b55a <ble_ll_adv_set_adv_params+0x6e>
        (peer_addr_type > BLE_HCI_ADV_PEER_ADDR_MAX)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    b584:	f1ba 0f01 	cmp.w	sl, #1
    b588:	d909      	bls.n	b59e <ble_ll_adv_set_adv_params+0xb2>
        /* Copy peer address */
        memcpy(advsm->peer_addr, cmd + 7, BLE_DEV_ADDR_LEN);
    b58a:	462b      	mov	r3, r5
    b58c:	4a11      	ldr	r2, [pc, #68]	; (b5d4 <ble_ll_adv_set_adv_params+0xe8>)
    b58e:	f853 0f07 	ldr.w	r0, [r3, #7]!
    b592:	6010      	str	r0, [r2, #0]
    b594:	889b      	ldrh	r3, [r3, #4]
    b596:	8093      	strh	r3, [r2, #4]

        /* Reset RPA timer so we generate a new RPA */
        advsm->adv_rpa_timer = os_time_get();
    b598:	f7ff f912 	bl	a7c0 <os_time_get>
    b59c:	6260      	str	r0, [r4, #36]	; 0x24
        return BLE_ERR_UNSUPPORTED;
    }
#endif

    /* There are only three adv channels, so check for any outside the range */
    adv_chanmask = cmd[13];
    b59e:	7b6b      	ldrb	r3, [r5, #13]
    if (((adv_chanmask & 0xF8) != 0) || (adv_chanmask == 0)) {
    b5a0:	f013 00f8 	ands.w	r0, r3, #248	; 0xf8
    b5a4:	d1d9      	bne.n	b55a <ble_ll_adv_set_adv_params+0x6e>
    b5a6:	2b00      	cmp	r3, #0
    b5a8:	d0d7      	beq.n	b55a <ble_ll_adv_set_adv_params+0x6e>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check for valid filter policy */
    if (adv_filter_policy > BLE_HCI_ADV_FILT_MAX) {
    b5aa:	f1b9 0f03 	cmp.w	r9, #3
    b5ae:	d8d4      	bhi.n	b55a <ble_ll_adv_set_adv_params+0x6e>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Fill out rest of advertising state machine */
    advsm->own_addr_type = own_addr_type;
    b5b0:	f884 a005 	strb.w	sl, [r4, #5]
    advsm->peer_addr_type = peer_addr_type;
    b5b4:	f884 b006 	strb.w	fp, [r4, #6]
    advsm->adv_filter_policy = adv_filter_policy;
    b5b8:	f884 9004 	strb.w	r9, [r4, #4]
    advsm->adv_chanmask = adv_chanmask;
    b5bc:	70e3      	strb	r3, [r4, #3]
    advsm->adv_itvl_min = adv_itvl_min;
    advsm->adv_itvl_max = adv_itvl_max;
    advsm->adv_type = adv_type;
    b5be:	f884 8001 	strb.w	r8, [r4, #1]
    /* Fill out rest of advertising state machine */
    advsm->own_addr_type = own_addr_type;
    advsm->peer_addr_type = peer_addr_type;
    advsm->adv_filter_policy = adv_filter_policy;
    advsm->adv_chanmask = adv_chanmask;
    advsm->adv_itvl_min = adv_itvl_min;
    b5c2:	81e6      	strh	r6, [r4, #14]
    advsm->adv_itvl_max = adv_itvl_max;
    b5c4:	8227      	strh	r7, [r4, #16]
    advsm->adv_type = adv_type;

    return 0;
    b5c6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    struct ble_ll_adv_sm *advsm;

    /* If already enabled, we return an error */
    advsm = &g_ble_ll_adv_sm;
    if (advsm->enabled) {
        return BLE_ERR_CMD_DISALLOWED;
    b5ca:	200c      	movs	r0, #12
    advsm->adv_itvl_min = adv_itvl_min;
    advsm->adv_itvl_max = adv_itvl_max;
    advsm->adv_type = adv_type;

    return 0;
}
    b5cc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b5d0:	20003310 	.word	0x20003310
    b5d4:	20003344 	.word	0x20003344

0000b5d8 <ble_ll_adv_scheduled>:
    return BLE_ERR_SUCCESS;
}

void
ble_ll_adv_scheduled(uint32_t sch_start)
{
    b5d8:	b538      	push	{r3, r4, r5, lr}
    b5da:	4604      	mov	r4, r0

    advsm = &g_ble_ll_adv_sm;

    /* The event start time is when we start transmission of the adv PDU */
    advsm->adv_event_start_time = sch_start +
        cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
    b5dc:	20be      	movs	r0, #190	; 0xbe
    b5de:	f7fd fb69 	bl	8cb4 <cputime_usecs_to_ticks>
    struct ble_ll_adv_sm *advsm;

    advsm = &g_ble_ll_adv_sm;

    /* The event start time is when we start transmission of the adv PDU */
    advsm->adv_event_start_time = sch_start +
    b5e2:	4d05      	ldr	r5, [pc, #20]	; (b5f8 <ble_ll_adv_scheduled+0x20>)
    b5e4:	4404      	add	r4, r0
     * Set the time at which we must end directed, high-duty cycle advertising.
     * Does not matter that we calculate this value if we are not doing high
     * duty cycle advertising.
     */
    advsm->adv_dir_hd_end_time = advsm->adv_event_start_time +
        cputime_usecs_to_ticks(BLE_LL_ADV_STATE_HD_MAX * 1000);
    b5e6:	4805      	ldr	r0, [pc, #20]	; (b5fc <ble_ll_adv_scheduled+0x24>)
    struct ble_ll_adv_sm *advsm;

    advsm = &g_ble_ll_adv_sm;

    /* The event start time is when we start transmission of the adv PDU */
    advsm->adv_event_start_time = sch_start +
    b5e8:	61ac      	str	r4, [r5, #24]
        cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);

    advsm->adv_pdu_start_time = advsm->adv_event_start_time;
    b5ea:	61ec      	str	r4, [r5, #28]
     * Set the time at which we must end directed, high-duty cycle advertising.
     * Does not matter that we calculate this value if we are not doing high
     * duty cycle advertising.
     */
    advsm->adv_dir_hd_end_time = advsm->adv_event_start_time +
        cputime_usecs_to_ticks(BLE_LL_ADV_STATE_HD_MAX * 1000);
    b5ec:	f7fd fb62 	bl	8cb4 <cputime_usecs_to_ticks>
    /*
     * Set the time at which we must end directed, high-duty cycle advertising.
     * Does not matter that we calculate this value if we are not doing high
     * duty cycle advertising.
     */
    advsm->adv_dir_hd_end_time = advsm->adv_event_start_time +
    b5f0:	4420      	add	r0, r4
    b5f2:	6228      	str	r0, [r5, #32]
    b5f4:	bd38      	pop	{r3, r4, r5, pc}
    b5f6:	bf00      	nop
    b5f8:	20003310 	.word	0x20003310
    b5fc:	00138800 	.word	0x00138800

0000b600 <ble_ll_adv_read_txpwr>:
 * @return int
 */
int
ble_ll_adv_read_txpwr(uint8_t *rspbuf, uint8_t *rsplen)
{
    rspbuf[0] = NIMBLE_OPT_LL_TX_PWR_DBM;
    b600:	2300      	movs	r3, #0
    *rsplen = 1;
    b602:	2201      	movs	r2, #1
 * @return int
 */
int
ble_ll_adv_read_txpwr(uint8_t *rspbuf, uint8_t *rsplen)
{
    rspbuf[0] = NIMBLE_OPT_LL_TX_PWR_DBM;
    b604:	7003      	strb	r3, [r0, #0]
    *rsplen = 1;
    b606:	700a      	strb	r2, [r1, #0]
    return BLE_ERR_SUCCESS;
}
    b608:	4618      	mov	r0, r3
    b60a:	4770      	bx	lr

0000b60c <ble_ll_adv_set_enable>:
 *
 * @return int
 */
int
ble_ll_adv_set_enable(uint8_t *cmd)
{
    b60c:	b538      	push	{r3, r4, r5, lr}
    struct ble_ll_adv_sm *advsm;

    advsm = &g_ble_ll_adv_sm;

    rc = 0;
    enable = cmd[0];
    b60e:	7804      	ldrb	r4, [r0, #0]
    if (enable == 1) {
    b610:	2c01      	cmp	r4, #1
    b612:	d150      	bne.n	b6b6 <ble_ll_adv_set_enable+0xaa>
        /* If already enabled, do nothing */
        if (!advsm->enabled) {
    b614:	4b2b      	ldr	r3, [pc, #172]	; (b6c4 <ble_ll_adv_set_enable+0xb8>)
    b616:	781a      	ldrb	r2, [r3, #0]
    b618:	461c      	mov	r4, r3
    b61a:	2a00      	cmp	r2, #0
    b61c:	d14e      	bne.n	b6bc <ble_ll_adv_set_enable+0xb0>
     * command disallowed error if no random address has been sent by the
     * host. All the parameter errors refer to the command
     * parameter (which in this case is just enable or disable) so that
     * is why I chose command disallowed.
     */
    if (advsm->own_addr_type == BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    b61e:	795b      	ldrb	r3, [r3, #5]
    b620:	2b01      	cmp	r3, #1
    b622:	d007      	beq.n	b634 <ble_ll_adv_set_enable+0x28>
            return BLE_ERR_CMD_DISALLOWED;
        }
    }

    /* Set advertising address */
    if ((advsm->own_addr_type & 1) == 0) {
    b624:	7963      	ldrb	r3, [r4, #5]
    b626:	4a27      	ldr	r2, [pc, #156]	; (b6c4 <ble_ll_adv_set_enable+0xb8>)
    b628:	f013 0301 	ands.w	r3, r3, #1
    b62c:	d109      	bne.n	b642 <ble_ll_adv_set_enable+0x36>
        addr = g_dev_addr;
        advsm->adv_txadd = 0;
    b62e:	7313      	strb	r3, [r2, #12]
        }
    }

    /* Set advertising address */
    if ((advsm->own_addr_type & 1) == 0) {
        addr = g_dev_addr;
    b630:	4a25      	ldr	r2, [pc, #148]	; (b6c8 <ble_ll_adv_set_enable+0xbc>)
    b632:	e009      	b.n	b648 <ble_ll_adv_set_enable+0x3c>
     * host. All the parameter errors refer to the command
     * parameter (which in this case is just enable or disable) so that
     * is why I chose command disallowed.
     */
    if (advsm->own_addr_type == BLE_HCI_ADV_OWN_ADDR_RANDOM) {
        if (!ble_ll_is_valid_random_addr(g_random_addr)) {
    b634:	4825      	ldr	r0, [pc, #148]	; (b6cc <ble_ll_adv_set_enable+0xc0>)
    b636:	f7ff fc19 	bl	ae6c <ble_ll_is_valid_random_addr>
    b63a:	2800      	cmp	r0, #0
    b63c:	d1f2      	bne.n	b624 <ble_ll_adv_set_enable+0x18>
            return BLE_ERR_CMD_DISALLOWED;
    b63e:	200c      	movs	r0, #12
    b640:	bd38      	pop	{r3, r4, r5, pc}
    if ((advsm->own_addr_type & 1) == 0) {
        addr = g_dev_addr;
        advsm->adv_txadd = 0;
    } else {
        addr = g_random_addr;
        advsm->adv_txadd = 1;
    b642:	2301      	movs	r3, #1
    b644:	7313      	strb	r3, [r2, #12]
    /* Set advertising address */
    if ((advsm->own_addr_type & 1) == 0) {
        addr = g_dev_addr;
        advsm->adv_txadd = 0;
    } else {
        addr = g_random_addr;
    b646:	4a21      	ldr	r2, [pc, #132]	; (b6cc <ble_ll_adv_set_enable+0xc0>)
        advsm->adv_txadd = 1;
    }
    memcpy(advsm->adva, addr, BLE_DEV_ADDR_LEN);
    b648:	4b1e      	ldr	r3, [pc, #120]	; (b6c4 <ble_ll_adv_set_enable+0xb8>)
    b64a:	6810      	ldr	r0, [r2, #0]
    b64c:	8892      	ldrh	r2, [r2, #4]
    b64e:	62a0      	str	r0, [r4, #40]	; 0x28
    b650:	859a      	strh	r2, [r3, #44]	; 0x2c

    if (advsm->adv_directed) {
    b652:	7ae2      	ldrb	r2, [r4, #11]
    b654:	b162      	cbz	r2, b670 <ble_ll_adv_set_enable+0x64>
        memcpy(advsm->initiator_addr, advsm->peer_addr, BLE_DEV_ADDR_LEN);
    b656:	461a      	mov	r2, r3
    b658:	f852 0f34 	ldr.w	r0, [r2, #52]!
    b65c:	f8c3 003a 	str.w	r0, [r3, #58]	; 0x3a
    b660:	8892      	ldrh	r2, [r2, #4]
    b662:	87da      	strh	r2, [r3, #62]	; 0x3e
        if (advsm->peer_addr_type & 1) {
    b664:	799a      	ldrb	r2, [r3, #6]
    b666:	f012 0201 	ands.w	r2, r2, #1
            advsm->adv_rxadd = 1;
    b66a:	bf18      	it	ne
    b66c:	2201      	movne	r2, #1
        } else {
            advsm->adv_rxadd = 0;
    b66e:	735a      	strb	r2, [r3, #13]
        }
    }

    /* This will generate an RPA for both initiator addr and adva */
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    ble_ll_adv_chk_rpa_timeout(advsm);
    b670:	4d14      	ldr	r5, [pc, #80]	; (b6c4 <ble_ll_adv_set_enable+0xb8>)
    b672:	4628      	mov	r0, r5
    b674:	f7ff fef4 	bl	b460 <ble_ll_adv_chk_rpa_timeout>
#endif

    /* Set flag telling us that advertising is enabled */
    advsm->enabled = 1;
    b678:	2301      	movs	r3, #1
    b67a:	7023      	strb	r3, [r4, #0]

    /* Determine the advertising interval we will use */
    if (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
    b67c:	7863      	ldrb	r3, [r4, #1]
    b67e:	2b01      	cmp	r3, #1
        /* Set it to max. allowed for high duty cycle advertising */
        advsm->adv_itvl_usecs = BLE_LL_ADV_PDU_ITVL_HD_MS_MAX;
    } else {
        advsm->adv_itvl_usecs = (uint32_t)advsm->adv_itvl_max;
    b680:	bf1b      	ittet	ne
    b682:	8a2a      	ldrhne	r2, [r5, #16]
        advsm->adv_itvl_usecs *= BLE_LL_ADV_ITVL;
    b684:	f240 2371 	movwne	r3, #625	; 0x271
    advsm->enabled = 1;

    /* Determine the advertising interval we will use */
    if (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
        /* Set it to max. allowed for high duty cycle advertising */
        advsm->adv_itvl_usecs = BLE_LL_ADV_PDU_ITVL_HD_MS_MAX;
    b688:	f640 63a6 	movweq	r3, #3750	; 0xea6
    } else {
        advsm->adv_itvl_usecs = (uint32_t)advsm->adv_itvl_max;
        advsm->adv_itvl_usecs *= BLE_LL_ADV_ITVL;
    b68c:	4353      	mulne	r3, r2
    b68e:	616b      	str	r3, [r5, #20]
    b690:	78e3      	ldrb	r3, [r4, #3]
ble_ll_adv_first_chan(struct ble_ll_adv_sm *advsm)
{
    uint8_t adv_chan;

    /* Set first advertising channel */
    if (advsm->adv_chanmask & 0x01) {
    b692:	07da      	lsls	r2, r3, #31
    b694:	d405      	bmi.n	b6a2 <ble_ll_adv_set_enable+0x96>
        adv_chan = BLE_PHY_ADV_CHAN_START;
    } else if (advsm->adv_chanmask & 0x02) {
        adv_chan = BLE_PHY_ADV_CHAN_START + 1;
    } else {
        adv_chan = BLE_PHY_ADV_CHAN_START + 2;
    b696:	f013 0f02 	tst.w	r3, #2
    b69a:	bf14      	ite	ne
    b69c:	2326      	movne	r3, #38	; 0x26
    b69e:	2327      	moveq	r3, #39	; 0x27
    b6a0:	e000      	b.n	b6a4 <ble_ll_adv_set_enable+0x98>
{
    uint8_t adv_chan;

    /* Set first advertising channel */
    if (advsm->adv_chanmask & 0x01) {
        adv_chan = BLE_PHY_ADV_CHAN_START;
    b6a2:	2325      	movs	r3, #37	; 0x25

    /*
     * Schedule advertising. We set the initial schedule start and end
     * times to the earliest possible start/end.
     */
    ble_ll_adv_set_sched(advsm, 1);
    b6a4:	4807      	ldr	r0, [pc, #28]	; (b6c4 <ble_ll_adv_set_enable+0xb8>)
        advsm->adv_itvl_usecs *= BLE_LL_ADV_ITVL;
    }

    /* Set first advertising channel */
    adv_chan = ble_ll_adv_first_chan(advsm);
    advsm->adv_chan = adv_chan;
    b6a6:	71e3      	strb	r3, [r4, #7]

    /*
     * Schedule advertising. We set the initial schedule start and end
     * times to the earliest possible start/end.
     */
    ble_ll_adv_set_sched(advsm, 1);
    b6a8:	2101      	movs	r1, #1
    b6aa:	f7ff fddf 	bl	b26c <ble_ll_adv_set_sched>
    ble_ll_sched_adv_new(&advsm->adv_sch);
    b6ae:	4808      	ldr	r0, [pc, #32]	; (b6d0 <ble_ll_adv_set_enable+0xc4>)
    b6b0:	f005 f8a6 	bl	10800 <ble_ll_sched_adv_new>
    b6b4:	e002      	b.n	b6bc <ble_ll_adv_set_enable+0xb0>
        /* If already enabled, do nothing */
        if (!advsm->enabled) {
            /* Start the advertising state machine */
            rc = ble_ll_adv_sm_start(advsm);
        }
    } else if (enable == 0) {
    b6b6:	b91c      	cbnz	r4, b6c0 <ble_ll_adv_set_enable+0xb4>
        ble_ll_adv_sm_stop(advsm);
    b6b8:	f7ff feae 	bl	b418 <ble_ll_adv_sm_stop.constprop.4>
    uint8_t enable;
    struct ble_ll_adv_sm *advsm;

    advsm = &g_ble_ll_adv_sm;

    rc = 0;
    b6bc:	2000      	movs	r0, #0
    b6be:	bd38      	pop	{r3, r4, r5, pc}
            rc = ble_ll_adv_sm_start(advsm);
        }
    } else if (enable == 0) {
        ble_ll_adv_sm_stop(advsm);
    } else {
        rc = BLE_ERR_INV_HCI_CMD_PARMS;
    b6c0:	2012      	movs	r0, #18
    }

    return rc;
}
    b6c2:	bd38      	pop	{r3, r4, r5, pc}
    b6c4:	20003310 	.word	0x20003310
    b6c8:	200000d8 	.word	0x200000d8
    b6cc:	20002810 	.word	0x20002810
    b6d0:	2000339c 	.word	0x2000339c

0000b6d4 <ble_ll_adv_set_scan_rsp_data>:
 *
 * @return int
 */
int
ble_ll_adv_set_scan_rsp_data(uint8_t *cmd, uint8_t len)
{
    b6d4:	b508      	push	{r3, lr}
    uint8_t datalen;
    struct ble_ll_adv_sm *advsm;

    /* Check for valid scan response data length */
    datalen = cmd[0];
    b6d6:	7802      	ldrb	r2, [r0, #0]
    if (datalen > BLE_SCAN_RSP_DATA_MAX_LEN) {
    b6d8:	2a1f      	cmp	r2, #31
 *
 * @return int
 */
int
ble_ll_adv_set_scan_rsp_data(uint8_t *cmd, uint8_t len)
{
    b6da:	4601      	mov	r1, r0
    uint8_t datalen;
    struct ble_ll_adv_sm *advsm;

    /* Check for valid scan response data length */
    datalen = cmd[0];
    if (datalen > BLE_SCAN_RSP_DATA_MAX_LEN) {
    b6dc:	d807      	bhi.n	b6ee <ble_ll_adv_set_scan_rsp_data+0x1a>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Copy the new data into the advertising structure. */
    advsm = &g_ble_ll_adv_sm;
    advsm->scan_rsp_len = datalen;
    b6de:	4805      	ldr	r0, [pc, #20]	; (b6f4 <ble_ll_adv_set_scan_rsp_data+0x20>)
    memcpy(advsm->scan_rsp_data, cmd + 1, datalen);
    b6e0:	3101      	adds	r1, #1
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Copy the new data into the advertising structure. */
    advsm = &g_ble_ll_adv_sm;
    advsm->scan_rsp_len = datalen;
    b6e2:	7202      	strb	r2, [r0, #8]
    memcpy(advsm->scan_rsp_data, cmd + 1, datalen);
    b6e4:	305f      	adds	r0, #95	; 0x5f
    b6e6:	f7fd fc89 	bl	8ffc <memcpy>

    return 0;
    b6ea:	2000      	movs	r0, #0
    b6ec:	bd08      	pop	{r3, pc}
    struct ble_ll_adv_sm *advsm;

    /* Check for valid scan response data length */
    datalen = cmd[0];
    if (datalen > BLE_SCAN_RSP_DATA_MAX_LEN) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    b6ee:	2012      	movs	r0, #18
    advsm = &g_ble_ll_adv_sm;
    advsm->scan_rsp_len = datalen;
    memcpy(advsm->scan_rsp_data, cmd + 1, datalen);

    return 0;
}
    b6f0:	bd08      	pop	{r3, pc}
    b6f2:	bf00      	nop
    b6f4:	20003310 	.word	0x20003310

0000b6f8 <ble_ll_adv_set_adv_data>:
 *
 * @return int 0: success; BLE_ERR_INV_HCI_CMD_PARMS otherwise.
 */
int
ble_ll_adv_set_adv_data(uint8_t *cmd, uint8_t len)
{
    b6f8:	b508      	push	{r3, lr}
    uint8_t datalen;
    struct ble_ll_adv_sm *advsm;

    /* Check for valid advertising data length */
    datalen = cmd[0];
    b6fa:	7802      	ldrb	r2, [r0, #0]
    if (datalen > BLE_ADV_DATA_MAX_LEN) {
    b6fc:	2a1f      	cmp	r2, #31
 *
 * @return int 0: success; BLE_ERR_INV_HCI_CMD_PARMS otherwise.
 */
int
ble_ll_adv_set_adv_data(uint8_t *cmd, uint8_t len)
{
    b6fe:	4601      	mov	r1, r0
    uint8_t datalen;
    struct ble_ll_adv_sm *advsm;

    /* Check for valid advertising data length */
    datalen = cmd[0];
    if (datalen > BLE_ADV_DATA_MAX_LEN) {
    b700:	d807      	bhi.n	b712 <ble_ll_adv_set_adv_data+0x1a>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Copy the new data into the advertising structure. */
    advsm = &g_ble_ll_adv_sm;
    advsm->adv_len = datalen;
    b702:	4805      	ldr	r0, [pc, #20]	; (b718 <ble_ll_adv_set_adv_data+0x20>)
    memcpy(advsm->adv_data, cmd + 1, datalen);
    b704:	3101      	adds	r1, #1
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Copy the new data into the advertising structure. */
    advsm = &g_ble_ll_adv_sm;
    advsm->adv_len = datalen;
    b706:	7082      	strb	r2, [r0, #2]
    memcpy(advsm->adv_data, cmd + 1, datalen);
    b708:	3040      	adds	r0, #64	; 0x40
    b70a:	f7fd fc77 	bl	8ffc <memcpy>

    return 0;
    b70e:	2000      	movs	r0, #0
    b710:	bd08      	pop	{r3, pc}
    struct ble_ll_adv_sm *advsm;

    /* Check for valid advertising data length */
    datalen = cmd[0];
    if (datalen > BLE_ADV_DATA_MAX_LEN) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    b712:	2012      	movs	r0, #18
    advsm = &g_ble_ll_adv_sm;
    advsm->adv_len = datalen;
    memcpy(advsm->adv_data, cmd + 1, datalen);

    return 0;
}
    b714:	bd08      	pop	{r3, pc}
    b716:	bf00      	nop
    b718:	20003310 	.word	0x20003310

0000b71c <ble_ll_adv_conn_req_rxd>:
 *
 * @return 0: no connection started. 1: connection started
 */
int
ble_ll_adv_conn_req_rxd(uint8_t *rxbuf, struct ble_mbuf_hdr *hdr)
{
    b71c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint32_t endtime;
    struct ble_ll_adv_sm *advsm;

    /* Check filter policy. */
    valid = 0;
    resolved = BLE_MBUF_HDR_RESOLVED(hdr);
    b720:	780d      	ldrb	r5, [r1, #0]
    advsm = &g_ble_ll_adv_sm;
    inita = rxbuf + BLE_LL_PDU_HDR_LEN;
    if (hdr->rxinfo.flags & BLE_MBUF_HDR_F_DEVMATCH) {
    b722:	f005 0340 	and.w	r3, r5, #64	; 0x40
 *
 * @return 0: no connection started. 1: connection started
 */
int
ble_ll_adv_conn_req_rxd(uint8_t *rxbuf, struct ble_mbuf_hdr *hdr)
{
    b726:	4606      	mov	r6, r0
    b728:	460f      	mov	r7, r1
    /* Check filter policy. */
    valid = 0;
    resolved = BLE_MBUF_HDR_RESOLVED(hdr);
    advsm = &g_ble_ll_adv_sm;
    inita = rxbuf + BLE_LL_PDU_HDR_LEN;
    if (hdr->rxinfo.flags & BLE_MBUF_HDR_F_DEVMATCH) {
    b72a:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    b72e:	2b00      	cmp	r3, #0
    b730:	d04f      	beq.n	b7d2 <ble_ll_adv_conn_req_rxd+0xb6>

        /*
         * Only accept connect requests from the desired address if we
         * are doing directed advertising
         */
        if ((advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) ||
    b732:	4a29      	ldr	r2, [pc, #164]	; (b7d8 <ble_ll_adv_conn_req_rxd+0xbc>)
    advsm = &g_ble_ll_adv_sm;
    inita = rxbuf + BLE_LL_PDU_HDR_LEN;
    if (hdr->rxinfo.flags & BLE_MBUF_HDR_F_DEVMATCH) {

        valid = 1;
        if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
    b734:	7804      	ldrb	r4, [r0, #0]

        /*
         * Only accept connect requests from the desired address if we
         * are doing directed advertising
         */
        if ((advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) ||
    b736:	7853      	ldrb	r3, [r2, #1]
    uint32_t endtime;
    struct ble_ll_adv_sm *advsm;

    /* Check filter policy. */
    valid = 0;
    resolved = BLE_MBUF_HDR_RESOLVED(hdr);
    b738:	f005 0504 	and.w	r5, r5, #4

        /*
         * Only accept connect requests from the desired address if we
         * are doing directed advertising
         */
        if ((advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) ||
    b73c:	2b01      	cmp	r3, #1
    uint32_t endtime;
    struct ble_ll_adv_sm *advsm;

    /* Check filter policy. */
    valid = 0;
    resolved = BLE_MBUF_HDR_RESOLVED(hdr);
    b73e:	b2ed      	uxtb	r5, r5
    advsm = &g_ble_ll_adv_sm;
    inita = rxbuf + BLE_LL_PDU_HDR_LEN;
    b740:	f100 0902 	add.w	r9, r0, #2
    if (hdr->rxinfo.flags & BLE_MBUF_HDR_F_DEVMATCH) {

        valid = 1;
        if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
            addr_type = BLE_ADDR_TYPE_RANDOM;
    b744:	f3c4 1480 	ubfx	r4, r4, #6, #1
    b748:	4690      	mov	r8, r2

        /*
         * Only accept connect requests from the desired address if we
         * are doing directed advertising
         */
        if ((advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) ||
    b74a:	d001      	beq.n	b750 <ble_ll_adv_conn_req_rxd+0x34>
    b74c:	2b04      	cmp	r3, #4
    b74e:	d115      	bne.n	b77c <ble_ll_adv_conn_req_rxd+0x60>
            (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD)) {
            ident_addr = inita;

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
            if (resolved) {
    b750:	b145      	cbz	r5, b764 <ble_ll_adv_conn_req_rxd+0x48>
                ident_addr = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_identity_addr;
    b752:	f998 200a 	ldrsb.w	r2, [r8, #10]
    b756:	4b21      	ldr	r3, [pc, #132]	; (b7dc <ble_ll_adv_conn_req_rxd+0xc0>)
    b758:	2128      	movs	r1, #40	; 0x28
    b75a:	fb01 3302 	mla	r3, r1, r2, r3
    b75e:	1c99      	adds	r1, r3, #2
                addr_type = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_addr_type;
    b760:	785c      	ldrb	r4, [r3, #1]
    b762:	e000      	b.n	b766 <ble_ll_adv_conn_req_rxd+0x4a>
         * Only accept connect requests from the desired address if we
         * are doing directed advertising
         */
        if ((advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) ||
            (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD)) {
            ident_addr = inita;
    b764:	4649      	mov	r1, r9
            if (resolved) {
                ident_addr = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_identity_addr;
                addr_type = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_addr_type;
            }
#endif
            if ((addr_type != advsm->peer_addr_type) ||
    b766:	f898 3006 	ldrb.w	r3, [r8, #6]
    b76a:	42a3      	cmp	r3, r4
    b76c:	d104      	bne.n	b778 <ble_ll_adv_conn_req_rxd+0x5c>
                memcmp(advsm->peer_addr, ident_addr, BLE_DEV_ADDR_LEN)) {
    b76e:	481c      	ldr	r0, [pc, #112]	; (b7e0 <ble_ll_adv_conn_req_rxd+0xc4>)
    b770:	2206      	movs	r2, #6
    b772:	f7fd fc35 	bl	8fe0 <memcmp>
            if (resolved) {
                ident_addr = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_identity_addr;
                addr_type = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_addr_type;
            }
#endif
            if ((addr_type != advsm->peer_addr_type) ||
    b776:	b108      	cbz	r0, b77c <ble_ll_adv_conn_req_rxd+0x60>
    b778:	2400      	movs	r4, #0
    b77a:	e02a      	b.n	b7d2 <ble_ll_adv_conn_req_rxd+0xb6>
        }
    }

    if (valid) {
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
        if (resolved) {
    b77c:	b1d5      	cbz	r5, b7b4 <ble_ll_adv_conn_req_rxd+0x98>
            /* Retain the resolvable private address that we received. */
            memcpy(advsm->adv_rpa, inita, BLE_DEV_ADDR_LEN);
    b77e:	4b19      	ldr	r3, [pc, #100]	; (b7e4 <ble_ll_adv_conn_req_rxd+0xc8>)
    b780:	f8d9 2000 	ldr.w	r2, [r9]
    b784:	601a      	str	r2, [r3, #0]
    b786:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    b78a:	809a      	strh	r2, [r3, #4]

            /*
             * Overwrite received inita with identity address since that
             * is used from now on.
             */
            memcpy(inita,
    b78c:	4913      	ldr	r1, [pc, #76]	; (b7dc <ble_ll_adv_conn_req_rxd+0xc0>)
                   g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_identity_addr,
    b78e:	f998 300a 	ldrsb.w	r3, [r8, #10]

            /*
             * Overwrite received inita with identity address since that
             * is used from now on.
             */
            memcpy(inita,
    b792:	2028      	movs	r0, #40	; 0x28
    b794:	fb00 1303 	mla	r3, r0, r3, r1
    b798:	f853 2f02 	ldr.w	r2, [r3, #2]!
    b79c:	f8c6 2002 	str.w	r2, [r6, #2]
    b7a0:	889b      	ldrh	r3, [r3, #4]
    b7a2:	f8a9 3004 	strh.w	r3, [r9, #4]
                   g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_identity_addr,
                   BLE_DEV_ADDR_LEN);

            /* Peer address type is an identity address */
            addr_type = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_addr_type;
    b7a6:	f998 200a 	ldrsb.w	r2, [r8, #10]
    b7aa:	fb00 1302 	mla	r3, r0, r2, r1
    b7ae:	785c      	ldrb	r4, [r3, #1]
            addr_type += 2;
    b7b0:	3402      	adds	r4, #2
    b7b2:	b2e4      	uxtb	r4, r4
        }
#endif

        /* Try to start slave connection. If successful, stop advertising */
        pyld_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
    b7b4:	7873      	ldrb	r3, [r6, #1]
        endtime = hdr->beg_cputime + BLE_TX_DUR_USECS_M(pyld_len);
    b7b6:	6879      	ldr	r1, [r7, #4]
    b7b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    b7bc:	330a      	adds	r3, #10
        valid = ble_ll_conn_slave_start(rxbuf, endtime, addr_type);
    b7be:	4622      	mov	r2, r4
    b7c0:	4630      	mov	r0, r6
    b7c2:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    b7c6:	f001 fd1f 	bl	d208 <ble_ll_conn_slave_start>
        if (valid) {
    b7ca:	4604      	mov	r4, r0
    b7cc:	b108      	cbz	r0, b7d2 <ble_ll_adv_conn_req_rxd+0xb6>
            ble_ll_adv_sm_stop(advsm);
    b7ce:	f7ff fe23 	bl	b418 <ble_ll_adv_sm_stop.constprop.4>
        }
    }

    return valid;
}
    b7d2:	4620      	mov	r0, r4
    b7d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    b7d8:	20003310 	.word	0x20003310
    b7dc:	20003624 	.word	0x20003624
    b7e0:	20003344 	.word	0x20003344
    b7e4:	2000333e 	.word	0x2000333e

0000b7e8 <ble_ll_adv_rx_isr_end>:
 *      == 0: Do not disable the PHY
 *       > 0: Do not disable PHY as that has already been done.
 */
int
ble_ll_adv_rx_isr_end(uint8_t pdu_type, struct os_mbuf *rxpdu, int crcok)
{
    b7e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b7ec:	4680      	mov	r8, r0
    int rc;

    rc = -1;
    if (rxpdu == NULL) {
    b7ee:	460d      	mov	r5, r1
    b7f0:	b919      	cbnz	r1, b7fa <ble_ll_adv_rx_isr_end+0x12>
        ble_ll_adv_tx_done(&g_ble_ll_adv_sm);
    b7f2:	4850      	ldr	r0, [pc, #320]	; (b934 <ble_ll_adv_rx_isr_end+0x14c>)
    b7f4:	f7ff fd2c 	bl	b250 <ble_ll_adv_tx_done>
    b7f8:	e079      	b.n	b8ee <ble_ll_adv_rx_isr_end+0x106>
    } else {
        if (crcok) {
    b7fa:	2a00      	cmp	r2, #0
    b7fc:	d077      	beq.n	b8ee <ble_ll_adv_rx_isr_end+0x106>
            if ((pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) ||
    b7fe:	2803      	cmp	r0, #3
    b800:	d001      	beq.n	b806 <ble_ll_adv_rx_isr_end+0x1e>
    b802:	2805      	cmp	r0, #5
    b804:	d173      	bne.n	b8ee <ble_ll_adv_rx_isr_end+0x106>
    struct ble_ll_adv_sm *advsm;
    struct os_mbuf *scan_rsp;

    /* See if adva in the request (scan or connect) matches what we sent */
    advsm = &g_ble_ll_adv_sm;
    rxbuf = rxpdu->om_data;
    b806:	682e      	ldr	r6, [r5, #0]
    adva = rxbuf + BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN;
    if (memcmp(advsm->adva, adva, BLE_DEV_ADDR_LEN)) {
    b808:	484b      	ldr	r0, [pc, #300]	; (b938 <ble_ll_adv_rx_isr_end+0x150>)
    b80a:	f8df 912c 	ldr.w	r9, [pc, #300]	; b938 <ble_ll_adv_rx_isr_end+0x150>
    b80e:	f106 0108 	add.w	r1, r6, #8
    b812:	2206      	movs	r2, #6
    b814:	f7fd fbe4 	bl	8fe0 <memcmp>
    b818:	2800      	cmp	r0, #0
    b81a:	d168      	bne.n	b8ee <ble_ll_adv_rx_isr_end+0x106>
    b81c:	f1a9 0728 	sub.w	r7, r9, #40	; 0x28
    } else {
        chk_wl = advsm->adv_filter_policy & 2;
    }

    /* Get the peer address type */
    if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
    b820:	f816 ab02 	ldrb.w	sl, [r6], #2
        return -1;
    }

    /* Set device match bit if we are whitelisting */
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
        chk_wl = advsm->adv_filter_policy & 1;
    b824:	793c      	ldrb	r4, [r7, #4]
    if (memcmp(advsm->adva, adva, BLE_DEV_ADDR_LEN)) {
        return -1;
    }

    /* Set device match bit if we are whitelisting */
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
    b826:	f1b8 0f03 	cmp.w	r8, #3
        chk_wl = advsm->adv_filter_policy & 2;
    }

    /* Get the peer address type */
    if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
        txadd = BLE_ADDR_TYPE_RANDOM;
    b82a:	f3ca 1a80 	ubfx	sl, sl, #6, #1

    /* Set device match bit if we are whitelisting */
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
        chk_wl = advsm->adv_filter_policy & 1;
    } else {
        chk_wl = advsm->adv_filter_policy & 2;
    b82e:	bf18      	it	ne
    b830:	f004 0402 	andne.w	r4, r4, #2
    peer = rxbuf + BLE_LL_PDU_HDR_LEN;
    peer_addr_type = txadd;
    resolved = 0;

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_is_rpa(peer, txadd) && ble_ll_resolv_enabled()) {
    b834:	4630      	mov	r0, r6
    b836:	4651      	mov	r1, sl
        return -1;
    }

    /* Set device match bit if we are whitelisting */
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
        chk_wl = advsm->adv_filter_policy & 1;
    b838:	bf0c      	ite	eq
    b83a:	f004 0401 	andeq.w	r4, r4, #1
    } else {
        chk_wl = advsm->adv_filter_policy & 2;
    b83e:	b2e4      	uxtbne	r4, r4
    peer = rxbuf + BLE_LL_PDU_HDR_LEN;
    peer_addr_type = txadd;
    resolved = 0;

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_is_rpa(peer, txadd) && ble_ll_resolv_enabled()) {
    b840:	f7ff fb08 	bl	ae54 <ble_ll_is_rpa>
    b844:	b1c8      	cbz	r0, b87a <ble_ll_adv_rx_isr_end+0x92>
    b846:	f004 f837 	bl	f8b8 <ble_ll_resolv_enabled>
    b84a:	b1b0      	cbz	r0, b87a <ble_ll_adv_rx_isr_end+0x92>
        advsm->adv_rpa_index = ble_hw_resolv_list_match();
    b84c:	f005 fad6 	bl	10dfc <ble_hw_resolv_list_match>
    b850:	b2c0      	uxtb	r0, r0
        if (advsm->adv_rpa_index >= 0) {
    b852:	b243      	sxtb	r3, r0
    b854:	2b00      	cmp	r3, #0
    peer_addr_type = txadd;
    resolved = 0;

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_is_rpa(peer, txadd) && ble_ll_resolv_enabled()) {
        advsm->adv_rpa_index = ble_hw_resolv_list_match();
    b856:	72b8      	strb	r0, [r7, #10]
        if (advsm->adv_rpa_index >= 0) {
    b858:	db0d      	blt.n	b876 <ble_ll_adv_rx_isr_end+0x8e>
            ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_RESOLVED;
    b85a:	7e2a      	ldrb	r2, [r5, #24]
    b85c:	f042 0204 	orr.w	r2, r2, #4
    b860:	762a      	strb	r2, [r5, #24]
            if (chk_wl) {
    b862:	b18c      	cbz	r4, b888 <ble_ll_adv_rx_isr_end+0xa0>
                peer = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_identity_addr;
    b864:	4a35      	ldr	r2, [pc, #212]	; (b93c <ble_ll_adv_rx_isr_end+0x154>)
    b866:	2028      	movs	r0, #40	; 0x28
    b868:	fb00 2003 	mla	r0, r0, r3, r2
    b86c:	1c86      	adds	r6, r0, #2
                peer_addr_type = g_ble_ll_resolv_list[advsm->adv_rpa_index].rl_addr_type;
    b86e:	f890 a001 	ldrb.w	sl, [r0, #1]
                resolved = 1;
    b872:	2201      	movs	r2, #1
    b874:	e003      	b.n	b87e <ble_ll_adv_rx_isr_end+0x96>
            }
        } else {
            if (chk_wl) {
    b876:	b13c      	cbz	r4, b888 <ble_ll_adv_rx_isr_end+0xa0>
    b878:	e039      	b.n	b8ee <ble_ll_adv_rx_isr_end+0x106>
        }
    }
#endif

    /* Set device match bit if we are whitelisting */
    if (chk_wl && !ble_ll_whitelist_match(peer, peer_addr_type, resolved)) {
    b87a:	b12c      	cbz	r4, b888 <ble_ll_adv_rx_isr_end+0xa0>
    b87c:	2200      	movs	r2, #0
    b87e:	4630      	mov	r0, r6
    b880:	4651      	mov	r1, sl
    b882:	f005 f909 	bl	10a98 <ble_ll_whitelist_match>
    b886:	b390      	cbz	r0, b8ee <ble_ll_adv_rx_isr_end+0x106>

    /*
     * We set the device match bit to tell the upper layer that we will
     * accept the request
     */
    ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_DEVMATCH;
    b888:	7e2b      	ldrb	r3, [r5, #24]

    /* Setup to transmit the scan response if appropriate */
    rc = -1;
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
    b88a:	f1b8 0f03 	cmp.w	r8, #3

    /*
     * We set the device match bit to tell the upper layer that we will
     * accept the request
     */
    ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_DEVMATCH;
    b88e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b892:	762b      	strb	r3, [r5, #24]

    /* Setup to transmit the scan response if appropriate */
    rc = -1;
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
    b894:	d12b      	bne.n	b8ee <ble_ll_adv_rx_isr_end+0x106>
    uint8_t     pdulen;
    uint8_t     hdr;
    struct os_mbuf *m;

    /* Obtain scan response buffer */
    m = os_msys_get_pkthdr(BLE_MBUF_PAYLOAD_SIZE, sizeof(struct ble_mbuf_hdr));
    b896:	f44f 7082 	mov.w	r0, #260	; 0x104
    b89a:	2108      	movs	r1, #8
    b89c:	f7fe fb49 	bl	9f32 <os_msys_get_pkthdr>
    if (!m) {
    b8a0:	4606      	mov	r6, r0
    b8a2:	b320      	cbz	r0, b8ee <ble_ll_adv_rx_isr_end+0x106>
        return NULL;
    }

    /* Make sure that the length is valid */
    scan_rsp_len = advsm->scan_rsp_len;
    b8a4:	7a3c      	ldrb	r4, [r7, #8]
    b8a6:	f8df 808c 	ldr.w	r8, [pc, #140]	; b934 <ble_ll_adv_rx_isr_end+0x14c>
    assert(scan_rsp_len <= BLE_SCAN_RSP_DATA_MAX_LEN);
    b8aa:	2c1f      	cmp	r4, #31
    b8ac:	d906      	bls.n	b8bc <ble_ll_adv_rx_isr_end+0xd4>
    b8ae:	2200      	movs	r2, #0
    b8b0:	4823      	ldr	r0, [pc, #140]	; (b940 <ble_ll_adv_rx_isr_end+0x158>)
    b8b2:	f240 1123 	movw	r1, #291	; 0x123
    b8b6:	4613      	mov	r3, r2
    b8b8:	f7fe fa0a 	bl	9cd0 <__assert_func>

    /* Set BLE transmit header */
    pdulen = BLE_DEV_ADDR_LEN + scan_rsp_len;
    hdr = BLE_ADV_PDU_TYPE_SCAN_RSP;
    if (advsm->adv_txadd) {
    b8bc:	f898 300c 	ldrb.w	r3, [r8, #12]
    /* Make sure that the length is valid */
    scan_rsp_len = advsm->scan_rsp_len;
    assert(scan_rsp_len <= BLE_SCAN_RSP_DATA_MAX_LEN);

    /* Set BLE transmit header */
    pdulen = BLE_DEV_ADDR_LEN + scan_rsp_len;
    b8c0:	1da1      	adds	r1, r4, #6
    hdr = BLE_ADV_PDU_TYPE_SCAN_RSP;
    if (advsm->adv_txadd) {
        hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
    b8c2:	2b00      	cmp	r3, #0
    }

    ble_ll_mbuf_init(m, pdulen, hdr);
    b8c4:	bf0c      	ite	eq
    b8c6:	2204      	moveq	r2, #4
    b8c8:	2244      	movne	r2, #68	; 0x44
    b8ca:	b2c9      	uxtb	r1, r1
    b8cc:	f7ff fc28 	bl	b120 <ble_ll_mbuf_init>
     * was not generated based on the local irk of the peer sending the scan
     * request.
     */

    /* Construct scan response */
    dptr = m->om_data;
    b8d0:	6833      	ldr	r3, [r6, #0]
    memcpy(dptr, advsm->adva, BLE_DEV_ADDR_LEN);
    b8d2:	f8d9 0000 	ldr.w	r0, [r9]
    b8d6:	6018      	str	r0, [r3, #0]
    b8d8:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    b8dc:	809a      	strh	r2, [r3, #4]
    if (scan_rsp_len != 0) {
    b8de:	b164      	cbz	r4, b8fa <ble_ll_adv_rx_isr_end+0x112>
        memcpy(dptr + BLE_DEV_ADDR_LEN, advsm->scan_rsp_data, scan_rsp_len);
    b8e0:	1d98      	adds	r0, r3, #6
    b8e2:	f108 015f 	add.w	r1, r8, #95	; 0x5f
    b8e6:	4622      	mov	r2, r4
    b8e8:	f7fd fb88 	bl	8ffc <memcpy>
    b8ec:	e005      	b.n	b8fa <ble_ll_adv_rx_isr_end+0x112>
     * accept the request
     */
    ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_DEVMATCH;

    /* Setup to transmit the scan response if appropriate */
    rc = -1;
    b8ee:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
            }
        }
    }

    if (rc) {
        ble_ll_state_set(BLE_LL_STATE_STANDBY);
    b8f2:	2000      	movs	r0, #0
    b8f4:	f7ff fbf6 	bl	b0e4 <ble_ll_state_set>
    b8f8:	e018      	b.n	b92c <ble_ll_adv_rx_isr_end+0x144>
    /* Setup to transmit the scan response if appropriate */
    rc = -1;
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
        scan_rsp = ble_ll_adv_scan_rsp_pdu_make(advsm);
        if (scan_rsp) {
            ble_phy_set_txend_cb(ble_ll_adv_tx_done, &g_ble_ll_adv_sm);
    b8fa:	4812      	ldr	r0, [pc, #72]	; (b944 <ble_ll_adv_rx_isr_end+0x15c>)
    b8fc:	490d      	ldr	r1, [pc, #52]	; (b934 <ble_ll_adv_rx_isr_end+0x14c>)
    b8fe:	f005 fc13 	bl	11128 <ble_phy_set_txend_cb>
            rc = ble_phy_tx(scan_rsp, BLE_PHY_TRANSITION_NONE);
    b902:	4630      	mov	r0, r6
    b904:	2100      	movs	r1, #0
    b906:	f005 fe2f 	bl	11568 <ble_phy_tx>
            if (!rc) {
    b90a:	4604      	mov	r4, r0
    b90c:	b948      	cbnz	r0, b922 <ble_ll_adv_rx_isr_end+0x13a>
                ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_SCAN_RSP_TXD;
    b90e:	7e2b      	ldrb	r3, [r5, #24]
                STATS_INC(ble_ll_stats, scan_rsp_txg);
    b910:	4a0d      	ldr	r2, [pc, #52]	; (b948 <ble_ll_adv_rx_isr_end+0x160>)
        scan_rsp = ble_ll_adv_scan_rsp_pdu_make(advsm);
        if (scan_rsp) {
            ble_phy_set_txend_cb(ble_ll_adv_tx_done, &g_ble_ll_adv_sm);
            rc = ble_phy_tx(scan_rsp, BLE_PHY_TRANSITION_NONE);
            if (!rc) {
                ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_SCAN_RSP_TXD;
    b912:	f043 0310 	orr.w	r3, r3, #16
    b916:	762b      	strb	r3, [r5, #24]
                STATS_INC(ble_ll_stats, scan_rsp_txg);
    b918:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    b91c:	3301      	adds	r3, #1
    b91e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
            }
            os_mbuf_free_chain(scan_rsp);
    b922:	4630      	mov	r0, r6
    b924:	f7fe fb1b 	bl	9f5e <os_mbuf_free_chain>
                rc = ble_ll_adv_rx_req(pdu_type, rxpdu);
            }
        }
    }

    if (rc) {
    b928:	2c00      	cmp	r4, #0
    b92a:	d1e2      	bne.n	b8f2 <ble_ll_adv_rx_isr_end+0x10a>
        ble_ll_state_set(BLE_LL_STATE_STANDBY);
    }

    return rc;
}
    b92c:	4620      	mov	r0, r4
    b92e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b932:	bf00      	nop
    b934:	20003310 	.word	0x20003310
    b938:	20003338 	.word	0x20003338
    b93c:	20003624 	.word	0x20003624
    b940:	0001f246 	.word	0x0001f246
    b944:	0000b251 	.word	0x0000b251
    b948:	200030ac 	.word	0x200030ac

0000b94c <ble_ll_adv_rx_isr_start>:
    /* Assume we will abort the frame */
    rc = -1;

    /* If we get a scan request we must tell the phy to go from rx to tx */
    advsm = &g_ble_ll_adv_sm;
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
    b94c:	2803      	cmp	r0, #3
 *   = 0: Continue to receive frame. Dont go from rx to tx
 *   > 0: Continue to receive frame and go from rx to tx when done
 */
int
ble_ll_adv_rx_isr_start(uint8_t pdu_type)
{
    b94e:	b508      	push	{r3, lr}
    /* Assume we will abort the frame */
    rc = -1;

    /* If we get a scan request we must tell the phy to go from rx to tx */
    advsm = &g_ble_ll_adv_sm;
    if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_REQ) {
    b950:	d106      	bne.n	b960 <ble_ll_adv_rx_isr_start+0x14>
        /* Only accept scan requests if we are indirect adv or scan adv */
        if ((advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_SCAN_IND) ||
    b952:	4b0b      	ldr	r3, [pc, #44]	; (b980 <ble_ll_adv_rx_isr_start+0x34>)
    b954:	785b      	ldrb	r3, [r3, #1]
    b956:	f013 0ffd 	tst.w	r3, #253	; 0xfd
    b95a:	d10b      	bne.n	b974 <ble_ll_adv_rx_isr_start+0x28>
            (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_IND)) {
            rc = 1;
    b95c:	2001      	movs	r0, #1
    b95e:	bd08      	pop	{r3, pc}
        }
    } else {
        /* Only accept connect requests if connectable advertising event */
        if (pdu_type == BLE_ADV_PDU_TYPE_CONNECT_REQ) {
    b960:	2805      	cmp	r0, #5
    b962:	d107      	bne.n	b974 <ble_ll_adv_rx_isr_start+0x28>
            if ((advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) ||
    b964:	4b06      	ldr	r3, [pc, #24]	; (b980 <ble_ll_adv_rx_isr_start+0x34>)
    b966:	785b      	ldrb	r3, [r3, #1]
    b968:	2b04      	cmp	r3, #4
    b96a:	d001      	beq.n	b970 <ble_ll_adv_rx_isr_start+0x24>
                (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD) ||
    b96c:	2b01      	cmp	r3, #1
    b96e:	d801      	bhi.n	b974 <ble_ll_adv_rx_isr_start+0x28>
                (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_IND)) {
                rc = 0;
    b970:	2000      	movs	r0, #0
    b972:	bd08      	pop	{r3, pc}
    /*
     * If we abort the frame, we need to post the LL task to check if the
     * advertising event is over.
     */
    if (rc < 0) {
        ble_ll_adv_tx_done(advsm);
    b974:	4802      	ldr	r0, [pc, #8]	; (b980 <ble_ll_adv_rx_isr_start+0x34>)
    b976:	f7ff fc6b 	bl	b250 <ble_ll_adv_tx_done>
    b97a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }

    return rc;
}
    b97e:	bd08      	pop	{r3, pc}
    b980:	20003310 	.word	0x20003310

0000b984 <ble_ll_adv_event_done>:
 *
 * @param arg Pointer to advertising state machine.
 */
void
ble_ll_adv_event_done(void *arg)
{
    b984:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t start_time;
    struct ble_ll_adv_sm *advsm;

    /* Stop advertising event */
    advsm = (struct ble_ll_adv_sm *)arg;
    assert(advsm->enabled);
    b988:	7802      	ldrb	r2, [r0, #0]
 *
 * @param arg Pointer to advertising state machine.
 */
void
ble_ll_adv_event_done(void *arg)
{
    b98a:	4604      	mov	r4, r0
    uint32_t start_time;
    struct ble_ll_adv_sm *advsm;

    /* Stop advertising event */
    advsm = (struct ble_ll_adv_sm *)arg;
    assert(advsm->enabled);
    b98c:	b92a      	cbnz	r2, b99a <ble_ll_adv_event_done+0x16>
    b98e:	484a      	ldr	r0, [pc, #296]	; (bab8 <ble_ll_adv_event_done+0x134>)
    b990:	f240 41b9 	movw	r1, #1209	; 0x4b9
    b994:	4613      	mov	r3, r2
    b996:	f7fe f99b 	bl	9cd0 <__assert_func>

    /* Remove the element from the schedule if it is still there. */
    ble_ll_sched_rmv_elem(&advsm->adv_sch);
    b99a:	f100 078c 	add.w	r7, r0, #140	; 0x8c
    b99e:	4638      	mov	r0, r7
    os_eventq_remove(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);
    b9a0:	f104 0680 	add.w	r6, r4, #128	; 0x80
    /* Stop advertising event */
    advsm = (struct ble_ll_adv_sm *)arg;
    assert(advsm->enabled);

    /* Remove the element from the schedule if it is still there. */
    ble_ll_sched_rmv_elem(&advsm->adv_sch);
    b9a4:	f004 ffe0 	bl	10968 <ble_ll_sched_rmv_elem>
    os_eventq_remove(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);
    b9a8:	4844      	ldr	r0, [pc, #272]	; (babc <ble_ll_adv_event_done+0x138>)
    b9aa:	4631      	mov	r1, r6
    b9ac:	f7fe f971 	bl	9c92 <os_eventq_remove>
    /*
     * Check if we have ended our advertising event. If our last advertising
     * packet was sent on the last channel, it means we are done with this
     * event.
     */
    if (advsm->adv_chanmask & 0x04) {
    b9b0:	78e0      	ldrb	r0, [r4, #3]
    b9b2:	0741      	lsls	r1, r0, #29
    b9b4:	d405      	bmi.n	b9c2 <ble_ll_adv_event_done+0x3e>
        final_adv_chan = BLE_PHY_ADV_CHAN_START + 2;
    } else if (advsm->adv_chanmask & 0x02) {
        final_adv_chan = BLE_PHY_ADV_CHAN_START + 1;
    } else {
        final_adv_chan = BLE_PHY_ADV_CHAN_START;
    b9b6:	f010 0f02 	tst.w	r0, #2
    b9ba:	bf14      	ite	ne
    b9bc:	2226      	movne	r2, #38	; 0x26
    b9be:	2225      	moveq	r2, #37	; 0x25
    b9c0:	e000      	b.n	b9c4 <ble_ll_adv_event_done+0x40>
     * Check if we have ended our advertising event. If our last advertising
     * packet was sent on the last channel, it means we are done with this
     * event.
     */
    if (advsm->adv_chanmask & 0x04) {
        final_adv_chan = BLE_PHY_ADV_CHAN_START + 2;
    b9c2:	2227      	movs	r2, #39	; 0x27
        final_adv_chan = BLE_PHY_ADV_CHAN_START + 1;
    } else {
        final_adv_chan = BLE_PHY_ADV_CHAN_START;
    }

    if (advsm->adv_chan == final_adv_chan) {
    b9c4:	79e3      	ldrb	r3, [r4, #7]
    b9c6:	4293      	cmp	r3, r2
    b9c8:	d13f      	bne.n	ba4a <ble_ll_adv_event_done+0xc6>
        /* Check if we need to resume scanning */
        ble_ll_scan_chk_resume();
    b9ca:	f004 fa5b 	bl	fe84 <ble_ll_scan_chk_resume>
    b9ce:	78e3      	ldrb	r3, [r4, #3]
ble_ll_adv_first_chan(struct ble_ll_adv_sm *advsm)
{
    uint8_t adv_chan;

    /* Set first advertising channel */
    if (advsm->adv_chanmask & 0x01) {
    b9d0:	07da      	lsls	r2, r3, #31
    b9d2:	d405      	bmi.n	b9e0 <ble_ll_adv_event_done+0x5c>
        adv_chan = BLE_PHY_ADV_CHAN_START;
    } else if (advsm->adv_chanmask & 0x02) {
        adv_chan = BLE_PHY_ADV_CHAN_START + 1;
    } else {
        adv_chan = BLE_PHY_ADV_CHAN_START + 2;
    b9d4:	f013 0f02 	tst.w	r3, #2
    b9d8:	bf14      	ite	ne
    b9da:	2326      	movne	r3, #38	; 0x26
    b9dc:	2327      	moveq	r3, #39	; 0x27
    b9de:	e000      	b.n	b9e2 <ble_ll_adv_event_done+0x5e>
{
    uint8_t adv_chan;

    /* Set first advertising channel */
    if (advsm->adv_chanmask & 0x01) {
        adv_chan = BLE_PHY_ADV_CHAN_START;
    b9e0:	2325      	movs	r3, #37	; 0x25
    if (advsm->adv_chan == final_adv_chan) {
        /* Check if we need to resume scanning */
        ble_ll_scan_chk_resume();

        /* This event is over. Set adv channel to first one */
        advsm->adv_chan = ble_ll_adv_first_chan(advsm);
    b9e2:	71e3      	strb	r3, [r4, #7]

        /* Calculate start time of next advertising event */
        itvl = advsm->adv_itvl_usecs;
        if (advsm->adv_type != BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
    b9e4:	7863      	ldrb	r3, [r4, #1]

        /* This event is over. Set adv channel to first one */
        advsm->adv_chan = ble_ll_adv_first_chan(advsm);

        /* Calculate start time of next advertising event */
        itvl = advsm->adv_itvl_usecs;
    b9e6:	6965      	ldr	r5, [r4, #20]
        if (advsm->adv_type != BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
    b9e8:	2b01      	cmp	r3, #1
    b9ea:	d008      	beq.n	b9fe <ble_ll_adv_event_done+0x7a>
}

#define RAND_MAX 0x7fffffff
__extern_inline int rand(void)
{
	return (int)lrand48();
    b9ec:	f7fd faf0 	bl	8fd0 <lrand48>
            itvl += rand() % (BLE_LL_ADV_DELAY_MS_MAX * 1000);
    b9f0:	f242 7310 	movw	r3, #10000	; 0x2710
    b9f4:	fb90 f2f3 	sdiv	r2, r0, r3
    b9f8:	fb02 0013 	mls	r0, r2, r3, r0
    b9fc:	4405      	add	r5, r0
        }
        advsm->adv_event_start_time += cputime_usecs_to_ticks(itvl);
    b9fe:	4628      	mov	r0, r5
    ba00:	f7fd f958 	bl	8cb4 <cputime_usecs_to_ticks>
    ba04:	69a5      	ldr	r5, [r4, #24]
    ba06:	4405      	add	r5, r0
    ba08:	61a5      	str	r5, [r4, #24]
        advsm->adv_pdu_start_time = advsm->adv_event_start_time;
    ba0a:	61e5      	str	r5, [r4, #28]
        /*
         * The scheduled time better be in the future! If it is not, we will
         * just keep advancing until we the time is in the future
         */
        start_time = advsm->adv_pdu_start_time -
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
    ba0c:	20be      	movs	r0, #190	; 0xbe
    ba0e:	f7fd f951 	bl	8cb4 <cputime_usecs_to_ticks>

        /*
         * The scheduled time better be in the future! If it is not, we will
         * just keep advancing until we the time is in the future
         */
        start_time = advsm->adv_pdu_start_time -
    ba12:	1a2d      	subs	r5, r5, r0
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);

        delta_t = (int32_t)(start_time - cputime_get32());
    ba14:	f7fd fa92 	bl	8f3c <cputime_get32>
        if (delta_t < 0) {
    ba18:	1a2d      	subs	r5, r5, r0
    ba1a:	d529      	bpl.n	ba70 <ble_ll_adv_event_done+0xec>
            /* Calculate start time of next advertising event */
            while (delta_t < 0) {
                itvl = advsm->adv_itvl_usecs;
                if (advsm->adv_type != BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
    ba1c:	7863      	ldrb	r3, [r4, #1]

        delta_t = (int32_t)(start_time - cputime_get32());
        if (delta_t < 0) {
            /* Calculate start time of next advertising event */
            while (delta_t < 0) {
                itvl = advsm->adv_itvl_usecs;
    ba1e:	f8d4 8014 	ldr.w	r8, [r4, #20]
                if (advsm->adv_type != BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
    ba22:	2b01      	cmp	r3, #1
    ba24:	d008      	beq.n	ba38 <ble_ll_adv_event_done+0xb4>
    ba26:	f7fd fad3 	bl	8fd0 <lrand48>
                    itvl += rand() % (BLE_LL_ADV_DELAY_MS_MAX * 1000);
    ba2a:	f242 7310 	movw	r3, #10000	; 0x2710
    ba2e:	fb90 f2f3 	sdiv	r2, r0, r3
    ba32:	fb02 0013 	mls	r0, r2, r3, r0
    ba36:	4480      	add	r8, r0
                }
                itvl = cputime_usecs_to_ticks(itvl);
    ba38:	4640      	mov	r0, r8
    ba3a:	f7fd f93b 	bl	8cb4 <cputime_usecs_to_ticks>
                advsm->adv_event_start_time += itvl;
    ba3e:	69a3      	ldr	r3, [r4, #24]
    ba40:	4403      	add	r3, r0
    ba42:	61a3      	str	r3, [r4, #24]
                advsm->adv_pdu_start_time = advsm->adv_event_start_time;
    ba44:	61e3      	str	r3, [r4, #28]
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);

        delta_t = (int32_t)(start_time - cputime_get32());
        if (delta_t < 0) {
            /* Calculate start time of next advertising event */
            while (delta_t < 0) {
    ba46:	182d      	adds	r5, r5, r0
    ba48:	e7e7      	b.n	ba1a <ble_ll_adv_event_done+0x96>
        /*
         * Move to next advertising channel. If not in the mask, just
         * increment by 1. We can do this because we already checked if we
         * just transmitted on the last advertising channel
         */
        ++advsm->adv_chan;
    ba4a:	1c5a      	adds	r2, r3, #1
    ba4c:	b2d2      	uxtb	r2, r2
        mask = 1 << (advsm->adv_chan - BLE_PHY_ADV_CHAN_START);
    ba4e:	f1a2 0525 	sub.w	r5, r2, #37	; 0x25
    ba52:	2101      	movs	r1, #1
    ba54:	40a9      	lsls	r1, r5
        if ((mask & advsm->adv_chanmask) == 0) {
    ba56:	4208      	tst	r0, r1
            ++advsm->adv_chan;
    ba58:	bf0a      	itet	eq
    ba5a:	3302      	addeq	r3, #2
        /*
         * Move to next advertising channel. If not in the mask, just
         * increment by 1. We can do this because we already checked if we
         * just transmitted on the last advertising channel
         */
        ++advsm->adv_chan;
    ba5c:	71e2      	strbne	r2, [r4, #7]
        mask = 1 << (advsm->adv_chan - BLE_PHY_ADV_CHAN_START);
        if ((mask & advsm->adv_chanmask) == 0) {
            ++advsm->adv_chan;
    ba5e:	71e3      	strbeq	r3, [r4, #7]

        /*
         * We will transmit right away. Set next pdu start time to now
         * plus a xcvr start delay just so we dont count late adv starts
         */
        advsm->adv_pdu_start_time = cputime_get32() +
    ba60:	f7fd fa6c 	bl	8f3c <cputime_get32>
    ba64:	4605      	mov	r5, r0
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
    ba66:	20be      	movs	r0, #190	; 0xbe
    ba68:	f7fd f924 	bl	8cb4 <cputime_usecs_to_ticks>

        /*
         * We will transmit right away. Set next pdu start time to now
         * plus a xcvr start delay just so we dont count late adv starts
         */
        advsm->adv_pdu_start_time = cputime_get32() +
    ba6c:	4428      	add	r0, r5
    ba6e:	61e0      	str	r0, [r4, #28]

    /*
     * Stop high duty cycle directed advertising if we have been doing
     * it for more than 1.28 seconds
     */
    if (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
    ba70:	7863      	ldrb	r3, [r4, #1]
    ba72:	2b01      	cmp	r3, #1
    ba74:	d10c      	bne.n	ba90 <ble_ll_adv_event_done+0x10c>
        if (advsm->adv_pdu_start_time >= advsm->adv_dir_hd_end_time) {
    ba76:	69e2      	ldr	r2, [r4, #28]
    ba78:	6a23      	ldr	r3, [r4, #32]
    ba7a:	429a      	cmp	r2, r3
    ba7c:	d308      	bcc.n	ba90 <ble_ll_adv_event_done+0x10c>
            /* Disable advertising */
            advsm->enabled = 0;
    ba7e:	2000      	movs	r0, #0
    ba80:	7020      	strb	r0, [r4, #0]
            ble_ll_conn_comp_event_send(NULL, BLE_ERR_DIR_ADV_TMO);
    ba82:	213c      	movs	r1, #60	; 0x3c
    ba84:	f001 fd3c 	bl	d500 <ble_ll_conn_comp_event_send>
     * event and we will reschedule the next advertising event
     */
    if (ble_ll_sched_adv_reschedule(&advsm->adv_sch)) {
        os_eventq_put(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);
    }
}
    ba88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (advsm->adv_type == BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
        if (advsm->adv_pdu_start_time >= advsm->adv_dir_hd_end_time) {
            /* Disable advertising */
            advsm->enabled = 0;
            ble_ll_conn_comp_event_send(NULL, BLE_ERR_DIR_ADV_TMO);
            ble_ll_scan_chk_resume();
    ba8c:	f004 b9fa 	b.w	fe84 <ble_ll_scan_chk_resume>
        }
    }

    /* We need to regenerate our RPA's if we have passed timeout */
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    ble_ll_adv_chk_rpa_timeout(advsm);
    ba90:	4620      	mov	r0, r4
    ba92:	f7ff fce5 	bl	b460 <ble_ll_adv_chk_rpa_timeout>
#endif

    /* Schedule advertising transmit */
    ble_ll_adv_set_sched(advsm, 0);
    ba96:	4620      	mov	r0, r4
    ba98:	2100      	movs	r1, #0
    ba9a:	f7ff fbe7 	bl	b26c <ble_ll_adv_set_sched>

    /*
     * In the unlikely event we cant reschedule this, just post a done
     * event and we will reschedule the next advertising event
     */
    if (ble_ll_sched_adv_reschedule(&advsm->adv_sch)) {
    ba9e:	4638      	mov	r0, r7
    baa0:	f004 ff0a 	bl	108b8 <ble_ll_sched_adv_reschedule>
    baa4:	b128      	cbz	r0, bab2 <ble_ll_adv_event_done+0x12e>
        os_eventq_put(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);
    baa6:	4631      	mov	r1, r6
    baa8:	4804      	ldr	r0, [pc, #16]	; (babc <ble_ll_adv_event_done+0x138>)
    }
}
    baaa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    /*
     * In the unlikely event we cant reschedule this, just post a done
     * event and we will reschedule the next advertising event
     */
    if (ble_ll_sched_adv_reschedule(&advsm->adv_sch)) {
        os_eventq_put(&g_ble_ll_data.ll_evq, &advsm->adv_txdone_ev);
    baae:	f7fe b8a0 	b.w	9bf2 <os_eventq_put>
    bab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bab6:	bf00      	nop
    bab8:	0001f246 	.word	0x0001f246
    babc:	200032c8 	.word	0x200032c8

0000bac0 <ble_ll_adv_rx_pkt_in>:
 *
 * @return int
 */
void
ble_ll_adv_rx_pkt_in(uint8_t ptype, uint8_t *rxbuf, struct ble_mbuf_hdr *hdr)
{
    bac0:	b508      	push	{r3, lr}
     * event. In the case of a connect request we will stop advertising. In
     * the case of the scan response transmission we will get a transmit
     * end callback.
     */
    adv_event_over = 1;
    if (BLE_MBUF_HDR_CRC_OK(hdr)) {
    bac2:	7813      	ldrb	r3, [r2, #0]
    bac4:	f013 0f80 	tst.w	r3, #128	; 0x80
    bac8:	d00b      	beq.n	bae2 <ble_ll_adv_rx_pkt_in+0x22>
        if (ptype == BLE_ADV_PDU_TYPE_CONNECT_REQ) {
    baca:	2805      	cmp	r0, #5
    bacc:	d105      	bne.n	bada <ble_ll_adv_rx_pkt_in+0x1a>
            if (ble_ll_adv_conn_req_rxd(rxbuf, hdr)) {
    bace:	4608      	mov	r0, r1
    bad0:	4611      	mov	r1, r2
    bad2:	f7ff fe23 	bl	b71c <ble_ll_adv_conn_req_rxd>
    bad6:	b948      	cbnz	r0, baec <ble_ll_adv_rx_pkt_in+0x2c>
    bad8:	e003      	b.n	bae2 <ble_ll_adv_rx_pkt_in+0x22>
                adv_event_over = 0;
            }
        } else {
            if ((ptype == BLE_ADV_PDU_TYPE_SCAN_REQ) &&
    bada:	2803      	cmp	r0, #3
    badc:	d101      	bne.n	bae2 <ble_ll_adv_rx_pkt_in+0x22>
    bade:	06db      	lsls	r3, r3, #27
    bae0:	d404      	bmi.n	baec <ble_ll_adv_rx_pkt_in+0x2c>
            }
        }
    }

    if (adv_event_over) {
        ble_ll_adv_event_done(&g_ble_ll_adv_sm);
    bae2:	4803      	ldr	r0, [pc, #12]	; (baf0 <ble_ll_adv_rx_pkt_in+0x30>)
    }
}
    bae4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            }
        }
    }

    if (adv_event_over) {
        ble_ll_adv_event_done(&g_ble_ll_adv_sm);
    bae8:	f7ff bf4c 	b.w	b984 <ble_ll_adv_event_done>
    baec:	bd08      	pop	{r3, pc}
    baee:	bf00      	nop
    baf0:	20003310 	.word	0x20003310

0000baf4 <ble_ll_adv_can_chg_whitelist>:
{
    int rc;
    struct ble_ll_adv_sm *advsm;

    advsm = &g_ble_ll_adv_sm;
    if (advsm->enabled && (advsm->adv_filter_policy != BLE_HCI_ADV_FILT_NONE)) {
    baf4:	4b04      	ldr	r3, [pc, #16]	; (bb08 <ble_ll_adv_can_chg_whitelist+0x14>)
    baf6:	781a      	ldrb	r2, [r3, #0]
    baf8:	b122      	cbz	r2, bb04 <ble_ll_adv_can_chg_whitelist+0x10>
    bafa:	7918      	ldrb	r0, [r3, #4]
    bafc:	fab0 f080 	clz	r0, r0
    bb00:	0940      	lsrs	r0, r0, #5
    bb02:	4770      	bx	lr
        rc = 0;
    } else {
        rc = 1;
    bb04:	2001      	movs	r0, #1
    }

    return rc;
}
    bb06:	4770      	bx	lr
    bb08:	20003310 	.word	0x20003310

0000bb0c <ble_ll_adv_get_local_rpa>:
    struct ble_ll_adv_sm *advsm;

    advsm = &g_ble_ll_adv_sm;

    rpa = NULL;
    if (advsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    bb0c:	4803      	ldr	r0, [pc, #12]	; (bb1c <ble_ll_adv_get_local_rpa+0x10>)
    bb0e:	7943      	ldrb	r3, [r0, #5]
        rpa = advsm->adva;
    bb10:	2b02      	cmp	r3, #2
    bb12:	f100 0028 	add.w	r0, r0, #40	; 0x28
    }

    return rpa;
}
    bb16:	bf38      	it	cc
    bb18:	2000      	movcc	r0, #0
    bb1a:	4770      	bx	lr
    bb1c:	20003310 	.word	0x20003310

0000bb20 <ble_ll_adv_get_peer_rpa>:

    advsm = &g_ble_ll_adv_sm;

    /* XXX: should this go into IRK list or connection? */
    return advsm->adv_rpa;
}
    bb20:	4800      	ldr	r0, [pc, #0]	; (bb24 <ble_ll_adv_get_peer_rpa+0x4>)
    bb22:	4770      	bx	lr
    bb24:	2000333e 	.word	0x2000333e

0000bb28 <ble_ll_adv_wfr_timer_exp>:
 * state. Disables the phy and
 *
 */
void
ble_ll_adv_wfr_timer_exp(void)
{
    bb28:	b508      	push	{r3, lr}
    ble_phy_disable();
    bb2a:	f005 fb77 	bl	1121c <ble_phy_disable>
    ble_ll_adv_tx_done(&g_ble_ll_adv_sm);
    bb2e:	4802      	ldr	r0, [pc, #8]	; (bb38 <ble_ll_adv_wfr_timer_exp+0x10>)
}
    bb30:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */
void
ble_ll_adv_wfr_timer_exp(void)
{
    ble_phy_disable();
    ble_ll_adv_tx_done(&g_ble_ll_adv_sm);
    bb34:	f7ff bb8c 	b.w	b250 <ble_ll_adv_tx_done>
    bb38:	20003310 	.word	0x20003310

0000bb3c <ble_ll_adv_enabled>:
/* Called to determine if advertising is enabled */
uint8_t
ble_ll_adv_enabled(void)
{
    return g_ble_ll_adv_sm.enabled;
}
    bb3c:	4b01      	ldr	r3, [pc, #4]	; (bb44 <ble_ll_adv_enabled+0x8>)
    bb3e:	7818      	ldrb	r0, [r3, #0]
    bb40:	4770      	bx	lr
    bb42:	bf00      	nop
    bb44:	20003310 	.word	0x20003310

0000bb48 <ble_ll_adv_init>:
 * Initialize the advertising functionality of a BLE device. This should
 * be called once on initialization
 */
void
ble_ll_adv_init(void)
{
    bb48:	b510      	push	{r4, lr}
    struct ble_ll_adv_sm *advsm;

    /* Set default advertising parameters */
    advsm = &g_ble_ll_adv_sm;
    memset(advsm, 0, sizeof(struct ble_ll_adv_sm));
    bb4a:	4c09      	ldr	r4, [pc, #36]	; (bb70 <ble_ll_adv_init+0x28>)
    bb4c:	2100      	movs	r1, #0
    bb4e:	4620      	mov	r0, r4
    bb50:	22a8      	movs	r2, #168	; 0xa8
    bb52:	f7fd fa5e 	bl	9012 <memset>

    advsm->adv_itvl_min = BLE_HCI_ADV_ITVL_DEF;
    bb56:	f44f 6300 	mov.w	r3, #2048	; 0x800
    bb5a:	81e3      	strh	r3, [r4, #14]
    advsm->adv_itvl_max = BLE_HCI_ADV_ITVL_DEF;
    bb5c:	8223      	strh	r3, [r4, #16]
    advsm->adv_chanmask = BLE_HCI_ADV_CHANMASK_DEF;
    bb5e:	2307      	movs	r3, #7
    bb60:	70e3      	strb	r3, [r4, #3]

    /* Initialize advertising tx done event */
    advsm->adv_txdone_ev.ev_type = BLE_LL_EVENT_ADV_EV_DONE;
    bb62:	2311      	movs	r3, #17
    bb64:	f884 3081 	strb.w	r3, [r4, #129]	; 0x81
    advsm->adv_txdone_ev.ev_arg = advsm;
    bb68:	f8c4 4084 	str.w	r4, [r4, #132]	; 0x84
    bb6c:	bd10      	pop	{r4, pc}
    bb6e:	bf00      	nop
    bb70:	20003310 	.word	0x20003310

0000bb74 <ble_ll_adv_reset>:
 * Context: Link Layer task
 *
 */
void
ble_ll_adv_reset(void)
{
    bb74:	b508      	push	{r3, lr}
    struct ble_ll_adv_sm *advsm;
    advsm = &g_ble_ll_adv_sm;

    /* Stop advertising state machine */
    ble_ll_adv_sm_stop(advsm);
    bb76:	f7ff fc4f 	bl	b418 <ble_ll_adv_sm_stop.constprop.4>

    /* re-initialize the advertiser state machine */
    ble_ll_adv_init();
}
    bb7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

    /* Stop advertising state machine */
    ble_ll_adv_sm_stop(advsm);

    /* re-initialize the advertiser state machine */
    ble_ll_adv_init();
    bb7e:	f7ff bfe3 	b.w	bb48 <ble_ll_adv_init>

0000bb82 <ble_ll_conn_spvn_timer_cb>:
ble_ll_conn_spvn_timer_cb(void *arg)
{
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    ble_ll_event_send(&connsm->conn_spvn_ev);
    bb82:	3098      	adds	r0, #152	; 0x98
    bb84:	f7ff baba 	b.w	b0fc <ble_ll_event_send>

0000bb88 <ble_ll_conn_current_sm_over>:
 *  the PHY and remove the schedule item before we can set the state to
 *  standby and set the current state machine pointer to NULL.
 */
static void
ble_ll_conn_current_sm_over(void)
{
    bb88:	b508      	push	{r3, lr}
    /* Disable the PHY */
    ble_phy_disable();
    bb8a:	f005 fb47 	bl	1121c <ble_phy_disable>

    /* Disable the wfr timer */
    ble_ll_wfr_disable();
    bb8e:	f7ff f9cd 	bl	af2c <ble_ll_wfr_disable>

    /* Link-layer is in standby state now */
    ble_ll_state_set(BLE_LL_STATE_STANDBY);
    bb92:	2000      	movs	r0, #0
    bb94:	f7ff faa6 	bl	b0e4 <ble_ll_state_set>

    /* Set current LL connection to NULL */
    g_ble_ll_conn_cur_sm = NULL;
    bb98:	4b01      	ldr	r3, [pc, #4]	; (bba0 <ble_ll_conn_current_sm_over+0x18>)
    bb9a:	2200      	movs	r2, #0
    bb9c:	601a      	str	r2, [r3, #0]
    bb9e:	bd08      	pop	{r3, pc}
    bba0:	200033cc 	.word	0x200033cc

0000bba4 <ble_ll_conn_rxend_unencrypt>:
    ble_ll_event_send(&connsm->conn_ev_end);
}

static void
ble_ll_conn_rxend_unencrypt(void *arg)
{
    bba4:	b510      	push	{r4, lr}
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 0;
    bba6:	7883      	ldrb	r3, [r0, #2]
    bba8:	f36f 0300 	bfc	r3, #0, #1
    ble_ll_event_send(&connsm->conn_ev_end);
}

static void
ble_ll_conn_rxend_unencrypt(void *arg)
{
    bbac:	4604      	mov	r4, r0
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 0;
    bbae:	7083      	strb	r3, [r0, #2]
    ble_ll_conn_current_sm_over();
    bbb0:	f7ff ffea 	bl	bb88 <ble_ll_conn_current_sm_over>
    ble_ll_event_send(&connsm->conn_ev_end);
    bbb4:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
}
    bbb8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 0;
    ble_ll_conn_current_sm_over();
    ble_ll_event_send(&connsm->conn_ev_end);
    bbbc:	f7ff ba9e 	b.w	b0fc <ble_ll_event_send>

0000bbc0 <ble_ll_conn_txend_encrypt>:
    ble_phy_encrypt_disable();
}

static void
ble_ll_conn_txend_encrypt(void *arg)
{
    bbc0:	b510      	push	{r4, lr}
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 1;
    bbc2:	7883      	ldrb	r3, [r0, #2]
    bbc4:	f043 0301 	orr.w	r3, r3, #1
    ble_phy_encrypt_disable();
}

static void
ble_ll_conn_txend_encrypt(void *arg)
{
    bbc8:	4604      	mov	r4, r0
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 1;
    bbca:	7083      	strb	r3, [r0, #2]
    ble_ll_conn_current_sm_over();
    bbcc:	f7ff ffdc 	bl	bb88 <ble_ll_conn_current_sm_over>
    ble_ll_event_send(&connsm->conn_ev_end);
    bbd0:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
}
    bbd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 1;
    ble_ll_conn_current_sm_over();
    ble_ll_event_send(&connsm->conn_ev_end);
    bbd8:	f7ff ba90 	b.w	b0fc <ble_ll_event_send>

0000bbdc <ble_ll_conn_wait_txend>:
 * @param sch
 *
 */
static void
ble_ll_conn_wait_txend(void *arg)
{
    bbdc:	b510      	push	{r4, lr}
    bbde:	4604      	mov	r4, r0
    struct ble_ll_conn_sm *connsm;

    ble_ll_conn_current_sm_over();
    bbe0:	f7ff ffd2 	bl	bb88 <ble_ll_conn_current_sm_over>

    connsm = (struct ble_ll_conn_sm *)arg;
    ble_ll_event_send(&connsm->conn_ev_end);
    bbe4:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
}
    bbe8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    struct ble_ll_conn_sm *connsm;

    ble_ll_conn_current_sm_over();

    connsm = (struct ble_ll_conn_sm *)arg;
    ble_ll_event_send(&connsm->conn_ev_end);
    bbec:	f7ff ba86 	b.w	b0fc <ble_ll_event_send>

0000bbf0 <ble_ll_conn_req_txend>:
 * @param arg
 */
static void
ble_ll_conn_req_txend(void *arg)
{
    ble_ll_state_set(BLE_LL_STATE_STANDBY);
    bbf0:	2000      	movs	r0, #0
    bbf2:	f7ff ba77 	b.w	b0e4 <ble_ll_state_set>

0000bbf6 <ble_ll_conn_start_rx_encrypt>:
}

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
static void
ble_ll_conn_start_rx_encrypt(void *arg)
{
    bbf6:	b507      	push	{r0, r1, r2, lr}
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 1;
    bbf8:	7882      	ldrb	r2, [r0, #2]
}

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
static void
ble_ll_conn_start_rx_encrypt(void *arg)
{
    bbfa:	4603      	mov	r3, r0
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 1;
    bbfc:	f042 0201 	orr.w	r2, r2, #1
    bc00:	7082      	strb	r2, [r0, #2]
    ble_phy_encrypt_enable(connsm->enc_data.rx_pkt_cntr,
    bc02:	79da      	ldrb	r2, [r3, #7]
    bc04:	f8b3 0126 	ldrh.w	r0, [r3, #294]	; 0x126
    bc08:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
    bc0c:	bf18      	it	ne
    bc0e:	2201      	movne	r2, #1
    bc10:	9200      	str	r2, [sp, #0]
    bc12:	2100      	movs	r1, #0
    bc14:	f503 7298 	add.w	r2, r3, #304	; 0x130
    bc18:	f503 73ac 	add.w	r3, r3, #344	; 0x158
    bc1c:	f005 fa3c 	bl	11098 <ble_phy_encrypt_enable>
                           connsm->enc_data.iv,
                           connsm->enc_data.enc_block.cipher_text,
                           !CONN_IS_MASTER(connsm));
}
    bc20:	b003      	add	sp, #12
    bc22:	f85d fb04 	ldr.w	pc, [sp], #4

0000bc26 <ble_ll_conn_start_rx_unencrypt>:
ble_ll_conn_start_rx_unencrypt(void *arg)
{
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    CONN_F_ENCRYPTED(connsm) = 0;
    bc26:	7883      	ldrb	r3, [r0, #2]
    bc28:	f36f 0300 	bfc	r3, #0, #1
    bc2c:	7083      	strb	r3, [r0, #2]
    ble_phy_encrypt_disable();
    bc2e:	f005 ba65 	b.w	110fc <ble_phy_encrypt_disable>

0000bc32 <ble_ll_conn_continue_rx_encrypt>:
ble_ll_conn_continue_rx_encrypt(void *arg)
{
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    ble_phy_encrypt_set_pkt_cntr(connsm->enc_data.rx_pkt_cntr,
    bc32:	79c2      	ldrb	r2, [r0, #7]
    bc34:	f8b0 0126 	ldrh.w	r0, [r0, #294]	; 0x126
    bc38:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
    bc3c:	f04f 0100 	mov.w	r1, #0
    bc40:	bf18      	it	ne
    bc42:	2201      	movne	r2, #1
    bc44:	f005 ba52 	b.w	110ec <ble_phy_encrypt_set_pkt_cntr>

0000bc48 <ble_ll_conn_get_next_sched_time>:
    uint32_t itvl;
    uint32_t ce_end;
    uint32_t next_sched_time;

    /* Calculate time at which next connection event will start */
    itvl = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    bc48:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
 *
 * @return uint32_t
 */
static uint32_t
ble_ll_conn_get_next_sched_time(struct ble_ll_conn_sm *connsm)
{
    bc4c:	b513      	push	{r0, r1, r4, lr}
    uint32_t ce_end;
    uint32_t next_sched_time;

    /* Calculate time at which next connection event will start */
    itvl = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    ce_end = connsm->anchor_point + cputime_usecs_to_ticks(itvl);
    bc4e:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    bc50:	f240 40e2 	movw	r0, #1250	; 0x4e2
    bc54:	4358      	muls	r0, r3
    bc56:	f7fd f82d 	bl	8cb4 <cputime_usecs_to_ticks>
    bc5a:	4404      	add	r4, r0

    if (ble_ll_sched_next_time(&next_sched_time)) {
    bc5c:	a801      	add	r0, sp, #4
    bc5e:	f004 feaf 	bl	109c0 <ble_ll_sched_next_time>
    bc62:	b128      	cbz	r0, bc70 <ble_ll_conn_get_next_sched_time+0x28>
        if (CPUTIME_LT(next_sched_time, ce_end)) {
    bc64:	9b01      	ldr	r3, [sp, #4]
    bc66:	1b1a      	subs	r2, r3, r4
            ce_end = next_sched_time;
    bc68:	ea34 0422 	bics.w	r4, r4, r2, asr #32
    bc6c:	bf28      	it	cs
    bc6e:	461c      	movcs	r4, r3
        }
    }

    return ce_end;
}
    bc70:	4620      	mov	r0, r4
    bc72:	b002      	add	sp, #8
    bc74:	bd10      	pop	{r4, pc}
	...

0000bc78 <ble_ll_conn_tx_data_pdu>:
 *
 * @return int 0: success; otherwise failure to transmit
 */
static int
ble_ll_conn_tx_data_pdu(struct ble_ll_conn_sm *connsm)
{
    bc78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    /*
     * We need to check if we are retrying a pdu or if there is a pdu on
     * the transmit queue.
     */
    pkthdr = STAILQ_FIRST(&connsm->conn_txq);
    if (!connsm->cur_tx_pdu && !CONN_F_EMPTY_PDU_TXD(connsm) && !pkthdr) {
    bc7c:	f8d0 60b0 	ldr.w	r6, [r0, #176]	; 0xb0

    /*
     * We need to check if we are retrying a pdu or if there is a pdu on
     * the transmit queue.
     */
    pkthdr = STAILQ_FIRST(&connsm->conn_txq);
    bc80:	f8d0 a0b4 	ldr.w	sl, [r0, #180]	; 0xb4
 *
 * @return int 0: success; otherwise failure to transmit
 */
static int
ble_ll_conn_tx_data_pdu(struct ble_ll_conn_sm *connsm)
{
    bc84:	b08d      	sub	sp, #52	; 0x34
    bc86:	4604      	mov	r4, r0
    /*
     * We need to check if we are retrying a pdu or if there is a pdu on
     * the transmit queue.
     */
    pkthdr = STAILQ_FIRST(&connsm->conn_txq);
    if (!connsm->cur_tx_pdu && !CONN_F_EMPTY_PDU_TXD(connsm) && !pkthdr) {
    bc88:	2e00      	cmp	r6, #0
    bc8a:	d14f      	bne.n	bd2c <ble_ll_conn_tx_data_pdu+0xb4>
    bc8c:	7843      	ldrb	r3, [r0, #1]
    bc8e:	06dd      	lsls	r5, r3, #27
    bc90:	d46f      	bmi.n	bd72 <ble_ll_conn_tx_data_pdu+0xfa>
    bc92:	f1ba 0f00 	cmp.w	sl, #0
    bc96:	d103      	bne.n	bca0 <ble_ll_conn_tx_data_pdu+0x28>
        CONN_F_EMPTY_PDU_TXD(connsm) = 1;
    bc98:	f043 0310 	orr.w	r3, r3, #16
    bc9c:	7043      	strb	r3, [r0, #1]
    bc9e:	e19b      	b.n	bfd8 <ble_ll_conn_tx_data_pdu+0x360>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        /*
         * If we are encrypting, we are only allowed to send certain
         * kinds of LL control PDU's. If none is enqueued, send empty pdu!
         */
        if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
    bca0:	f890 3120 	ldrb.w	r3, [r0, #288]	; 0x120
     */
    cur_offset = 0;
    if (!connsm->cur_tx_pdu && !CONN_F_EMPTY_PDU_TXD(connsm)) {
        /* Convert packet header to mbuf */
        m = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
        nextpkthdr = STAILQ_NEXT(pkthdr, omp_next);
    bca4:	f8da 9004 	ldr.w	r9, [sl, #4]
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        /*
         * If we are encrypting, we are only allowed to send certain
         * kinds of LL control PDU's. If none is enqueued, send empty pdu!
         */
        if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
    bca8:	2b02      	cmp	r3, #2
     * the connection transmit queue
     */
    cur_offset = 0;
    if (!connsm->cur_tx_pdu && !CONN_F_EMPTY_PDU_TXD(connsm)) {
        /* Convert packet header to mbuf */
        m = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
    bcaa:	f1aa 0610 	sub.w	r6, sl, #16
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        /*
         * If we are encrypting, we are only allowed to send certain
         * kinds of LL control PDU's. If none is enqueued, send empty pdu!
         */
        if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
    bcae:	d91f      	bls.n	bcf0 <ble_ll_conn_tx_data_pdu+0x78>
            if (!ble_ll_ctrl_enc_allowed_pdu(pkthdr)) {
    bcb0:	4650      	mov	r0, sl
    bcb2:	f002 fad9 	bl	e268 <ble_ll_ctrl_enc_allowed_pdu>
    bcb6:	b938      	cbnz	r0, bcc8 <ble_ll_conn_tx_data_pdu+0x50>
                CONN_F_EMPTY_PDU_TXD(connsm) = 1;
    bcb8:	7863      	ldrb	r3, [r4, #1]
    bcba:	f043 0310 	orr.w	r3, r3, #16
    bcbe:	7063      	strb	r3, [r4, #1]
    struct os_mbuf_pkthdr *nextpkthdr;
    struct ble_ll_empty_pdu empty_pdu;
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    bcc0:	4680      	mov	r8, r0
    m = NULL;
    md = 0;
    hdr_byte = BLE_LL_LLID_DATA_FRAG;
    bcc2:	2701      	movs	r7, #1
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    m = NULL;
    md = 0;
    bcc4:	4605      	mov	r5, r0
         * kinds of LL control PDU's. If none is enqueued, send empty pdu!
         */
        if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
            if (!ble_ll_ctrl_enc_allowed_pdu(pkthdr)) {
                CONN_F_EMPTY_PDU_TXD(connsm) = 1;
                goto conn_tx_pdu;
    bcc6:	e0ad      	b.n	be24 <ble_ll_conn_tx_data_pdu+0x1ac>
             * We will allow a next packet if it itself is allowed or we are
             * a slave and we are sending the START_ENC_RSP. The master has
             * to wait to receive the START_ENC_RSP from the slave before
             * packets can be let go.
             */
            if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu(nextpkthdr)
    bcc8:	f1b9 0f00 	cmp.w	r9, #0
    bccc:	d102      	bne.n	bcd4 <ble_ll_conn_tx_data_pdu+0x5c>
 *
 * @return int 0: success; otherwise failure to transmit
 */
static int
ble_ll_conn_tx_data_pdu(struct ble_ll_conn_sm *connsm)
{
    bcce:	f04f 0900 	mov.w	r9, #0
    bcd2:	e00d      	b.n	bcf0 <ble_ll_conn_tx_data_pdu+0x78>
             * We will allow a next packet if it itself is allowed or we are
             * a slave and we are sending the START_ENC_RSP. The master has
             * to wait to receive the START_ENC_RSP from the slave before
             * packets can be let go.
             */
            if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu(nextpkthdr)
    bcd4:	4648      	mov	r0, r9
    bcd6:	f002 fac7 	bl	e268 <ble_ll_ctrl_enc_allowed_pdu>
    bcda:	b948      	cbnz	r0, bcf0 <ble_ll_conn_tx_data_pdu+0x78>
                && ((connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) ||
    bcdc:	79e3      	ldrb	r3, [r4, #7]
    bcde:	2b01      	cmp	r3, #1
    bce0:	d0f5      	beq.n	bcce <ble_ll_conn_tx_data_pdu+0x56>
                    !ble_ll_ctrl_is_start_enc_rsp(m))) {
    bce2:	4630      	mov	r0, r6
    bce4:	f002 fad8 	bl	e298 <ble_ll_ctrl_is_start_enc_rsp>
                nextpkthdr = NULL;
    bce8:	2800      	cmp	r0, #0
    bcea:	bf08      	it	eq
    bcec:	f04f 0900 	moveq.w	r9, #0
            }
        }
#endif
        /* Take packet off queue*/
        STAILQ_REMOVE_HEAD(&connsm->conn_txq, omp_next);
    bcf0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    bcf4:	685b      	ldr	r3, [r3, #4]
    bcf6:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
    bcfa:	b91b      	cbnz	r3, bd04 <ble_ll_conn_tx_data_pdu+0x8c>
    bcfc:	f104 03b4 	add.w	r3, r4, #180	; 0xb4
    bd00:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
        ble_hdr = BLE_MBUF_HDR_PTR(m);

        /* Determine packet length we will transmit */
        cur_txlen = connsm->eff_max_tx_octets;
        pktlen = pkthdr->omp_len;
    bd04:	f8ba 5000 	ldrh.w	r5, [sl]
        /* Take packet off queue*/
        STAILQ_REMOVE_HEAD(&connsm->conn_txq, omp_next);
        ble_hdr = BLE_MBUF_HDR_PTR(m);

        /* Determine packet length we will transmit */
        cur_txlen = connsm->eff_max_tx_octets;
    bd08:	f894 b00c 	ldrb.w	fp, [r4, #12]
            cur_txlen = pktlen;
        }
        ble_hdr->txinfo.pyld_len = cur_txlen;

        /* NOTE: header was set when first enqueued */
        hdr_byte = ble_hdr->txinfo.hdr_byte;
    bd0c:	f89a 700b 	ldrb.w	r7, [sl, #11]
        ble_hdr = BLE_MBUF_HDR_PTR(m);

        /* Determine packet length we will transmit */
        cur_txlen = connsm->eff_max_tx_octets;
        pktlen = pkthdr->omp_len;
        if (cur_txlen > pktlen) {
    bd10:	45ab      	cmp	fp, r5
            cur_txlen = pktlen;
    bd12:	bf88      	it	hi
    bd14:	fa5f fb85 	uxtbhi.w	fp, r5
        }
        ble_hdr->txinfo.pyld_len = cur_txlen;
    bd18:	f88a b00a 	strb.w	fp, [sl, #10]
            }
        }
#endif
        /* Take packet off queue*/
        STAILQ_REMOVE_HEAD(&connsm->conn_txq, omp_next);
        ble_hdr = BLE_MBUF_HDR_PTR(m);
    bd1c:	f10a 0808 	add.w	r8, sl, #8
        }
        ble_hdr->txinfo.pyld_len = cur_txlen;

        /* NOTE: header was set when first enqueued */
        hdr_byte = ble_hdr->txinfo.hdr_byte;
        connsm->cur_tx_pdu = m;
    bd20:	f8c4 60b0 	str.w	r6, [r4, #176]	; 0xb0
    bd24:	46ca      	mov	sl, r9

    /*
     * If we dont have a pdu we have previously transmitted, take it off
     * the connection transmit queue
     */
    cur_offset = 0;
    bd26:	f04f 0900 	mov.w	r9, #0
        }
        ble_hdr->txinfo.pyld_len = cur_txlen;

        /* NOTE: header was set when first enqueued */
        hdr_byte = ble_hdr->txinfo.hdr_byte;
        connsm->cur_tx_pdu = m;
    bd2a:	e036      	b.n	bd9a <ble_ll_conn_tx_data_pdu+0x122>
        if (connsm->cur_tx_pdu) {
            m = connsm->cur_tx_pdu;
            ble_hdr = BLE_MBUF_HDR_PTR(m);
            pktlen = OS_MBUF_PKTLEN(m);
            cur_txlen = ble_hdr->txinfo.pyld_len;
            cur_offset = ble_hdr->txinfo.offset;
    bd2c:	f896 9019 	ldrb.w	r9, [r6, #25]
    } else {
        nextpkthdr = pkthdr;
        if (connsm->cur_tx_pdu) {
            m = connsm->cur_tx_pdu;
            ble_hdr = BLE_MBUF_HDR_PTR(m);
            pktlen = OS_MBUF_PKTLEN(m);
    bd30:	8a35      	ldrh	r5, [r6, #16]
            cur_txlen = ble_hdr->txinfo.pyld_len;
    bd32:	f896 b01a 	ldrb.w	fp, [r6, #26]
        connsm->cur_tx_pdu = m;
    } else {
        nextpkthdr = pkthdr;
        if (connsm->cur_tx_pdu) {
            m = connsm->cur_tx_pdu;
            ble_hdr = BLE_MBUF_HDR_PTR(m);
    bd36:	f106 0818 	add.w	r8, r6, #24
            pktlen = OS_MBUF_PKTLEN(m);
            cur_txlen = ble_hdr->txinfo.pyld_len;
            cur_offset = ble_hdr->txinfo.offset;
            if (cur_offset == 0) {
    bd3a:	f1b9 0f00 	cmp.w	r9, #0
    bd3e:	d103      	bne.n	bd48 <ble_ll_conn_tx_data_pdu+0xd0>
                hdr_byte = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
    bd40:	7ef7      	ldrb	r7, [r6, #27]
    bd42:	f007 0703 	and.w	r7, r7, #3
    bd46:	e000      	b.n	bd4a <ble_ll_conn_tx_data_pdu+0xd2>

    /* For compiler warnings... */
    ble_hdr = NULL;
    m = NULL;
    md = 0;
    hdr_byte = BLE_LL_LLID_DATA_FRAG;
    bd48:	2701      	movs	r7, #1
            cur_offset = ble_hdr->txinfo.offset;
            if (cur_offset == 0) {
                hdr_byte = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
            }
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
    bd4a:	f894 2120 	ldrb.w	r2, [r4, #288]	; 0x120
    bd4e:	2a02      	cmp	r2, #2
    bd50:	d923      	bls.n	bd9a <ble_ll_conn_tx_data_pdu+0x122>
                /* We will allow a next packet if it itself is allowed */
                pkthdr = OS_MBUF_PKTHDR(connsm->cur_tx_pdu);
                if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu(nextpkthdr)
    bd52:	f1ba 0f00 	cmp.w	sl, #0
    bd56:	d023      	beq.n	bda0 <ble_ll_conn_tx_data_pdu+0x128>
    bd58:	4650      	mov	r0, sl
    bd5a:	f002 fa85 	bl	e268 <ble_ll_ctrl_enc_allowed_pdu>
    bd5e:	bb78      	cbnz	r0, bdc0 <ble_ll_conn_tx_data_pdu+0x148>
                    && ((connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) ||
    bd60:	79e2      	ldrb	r2, [r4, #7]
    bd62:	2a01      	cmp	r2, #1
    bd64:	d01c      	beq.n	bda0 <ble_ll_conn_tx_data_pdu+0x128>
                        !ble_ll_ctrl_is_start_enc_rsp(connsm->cur_tx_pdu))) {
    bd66:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
    bd6a:	f002 fa95 	bl	e298 <ble_ll_ctrl_is_start_enc_rsp>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
                /* We will allow a next packet if it itself is allowed */
                pkthdr = OS_MBUF_PKTHDR(connsm->cur_tx_pdu);
                if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu(nextpkthdr)
                    && ((connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) ||
    bd6e:	b1b8      	cbz	r0, bda0 <ble_ll_conn_tx_data_pdu+0x128>
    bd70:	e026      	b.n	bdc0 <ble_ll_conn_tx_data_pdu+0x148>
        } else {
            /* Empty PDU here. NOTE: header byte gets set later */
            pktlen = 0;
            cur_txlen = 0;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
    bd72:	f890 3120 	ldrb.w	r3, [r0, #288]	; 0x120
    bd76:	2b02      	cmp	r3, #2
    bd78:	d919      	bls.n	bdae <ble_ll_conn_tx_data_pdu+0x136>
                /* We will allow a next packet if it itself is allowed */
                if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu(nextpkthdr)) {
    bd7a:	f1ba 0f00 	cmp.w	sl, #0
    bd7e:	d106      	bne.n	bd8e <ble_ll_conn_tx_data_pdu+0x116>
    struct os_mbuf_pkthdr *nextpkthdr;
    struct ble_ll_empty_pdu empty_pdu;
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    bd80:	f04f 0800 	mov.w	r8, #0
                }
            }
#endif
        } else {
            /* Empty PDU here. NOTE: header byte gets set later */
            pktlen = 0;
    bd84:	4645      	mov	r5, r8

    /*
     * If we dont have a pdu we have previously transmitted, take it off
     * the connection transmit queue
     */
    cur_offset = 0;
    bd86:	46c1      	mov	r9, r8
            }
#endif
        } else {
            /* Empty PDU here. NOTE: header byte gets set later */
            pktlen = 0;
            cur_txlen = 0;
    bd88:	46c3      	mov	fp, r8

    /* For compiler warnings... */
    ble_hdr = NULL;
    m = NULL;
    md = 0;
    hdr_byte = BLE_LL_LLID_DATA_FRAG;
    bd8a:	2701      	movs	r7, #1
    bd8c:	e008      	b.n	bda0 <ble_ll_conn_tx_data_pdu+0x128>
            pktlen = 0;
            cur_txlen = 0;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
                /* We will allow a next packet if it itself is allowed */
                if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu(nextpkthdr)) {
    bd8e:	4650      	mov	r0, sl
    bd90:	f002 fa6a 	bl	e268 <ble_ll_ctrl_enc_allowed_pdu>
    bd94:	2800      	cmp	r0, #0
    bd96:	d0f3      	beq.n	bd80 <ble_ll_conn_tx_data_pdu+0x108>
    bd98:	e00d      	b.n	bdb6 <ble_ll_conn_tx_data_pdu+0x13e>

    /*
     * Set the more data data flag if we have more data to send and we
     * have not been asked to terminate
     */
    if ((nextpkthdr || ((cur_offset + cur_txlen) < pktlen)) &&
    bd9a:	f1ba 0f00 	cmp.w	sl, #0
    bd9e:	d10f      	bne.n	bdc0 <ble_ll_conn_tx_data_pdu+0x148>
    bda0:	eb09 020b 	add.w	r2, r9, fp
    bda4:	42aa      	cmp	r2, r5
    bda6:	da3c      	bge.n	be22 <ble_ll_conn_tx_data_pdu+0x1aa>
    bda8:	f04f 0a00 	mov.w	sl, #0
    bdac:	e008      	b.n	bdc0 <ble_ll_conn_tx_data_pdu+0x148>
    bdae:	f1ba 0f00 	cmp.w	sl, #0
    bdb2:	f000 8111 	beq.w	bfd8 <ble_ll_conn_tx_data_pdu+0x360>
    struct os_mbuf_pkthdr *nextpkthdr;
    struct ble_ll_empty_pdu empty_pdu;
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    bdb6:	46b0      	mov	r8, r6
                }
            }
#endif
        } else {
            /* Empty PDU here. NOTE: header byte gets set later */
            pktlen = 0;
    bdb8:	4635      	mov	r5, r6

    /*
     * If we dont have a pdu we have previously transmitted, take it off
     * the connection transmit queue
     */
    cur_offset = 0;
    bdba:	46b1      	mov	r9, r6
            }
#endif
        } else {
            /* Empty PDU here. NOTE: header byte gets set later */
            pktlen = 0;
            cur_txlen = 0;
    bdbc:	46b3      	mov	fp, r6

    /* For compiler warnings... */
    ble_hdr = NULL;
    m = NULL;
    md = 0;
    hdr_byte = BLE_LL_LLID_DATA_FRAG;
    bdbe:	2701      	movs	r7, #1
    /*
     * Set the more data data flag if we have more data to send and we
     * have not been asked to terminate
     */
    if ((nextpkthdr || ((cur_offset + cur_txlen) < pktlen)) &&
         !connsm->csmflags.cfbit.terminate_ind_rxd) {
    bdc0:	7822      	ldrb	r2, [r4, #0]

    /*
     * Set the more data data flag if we have more data to send and we
     * have not been asked to terminate
     */
    if ((nextpkthdr || ((cur_offset + cur_txlen) < pktlen)) &&
    bdc2:	0750      	lsls	r0, r2, #29
    bdc4:	d42d      	bmi.n	be22 <ble_ll_conn_tx_data_pdu+0x1aa>
         !connsm->csmflags.cfbit.terminate_ind_rxd) {
        /* Get next event time */
        next_event_time = ble_ll_conn_get_next_sched_time(connsm);
    bdc6:	4620      	mov	r0, r4
    bdc8:	f7ff ff3e 	bl	bc48 <ble_ll_conn_get_next_sched_time>
         *  For slave:
         *  -> wait IFS, send current frame.
         *  -> wait IFS, receive maximum size frame.
         *  -> wait IFS, send next frame.
         */
        if ((cur_offset + cur_txlen) < pktlen) {
    bdcc:	eb09 020b 	add.w	r2, r9, fp
    bdd0:	42aa      	cmp	r2, r5
     * have not been asked to terminate
     */
    if ((nextpkthdr || ((cur_offset + cur_txlen) < pktlen)) &&
         !connsm->csmflags.cfbit.terminate_ind_rxd) {
        /* Get next event time */
        next_event_time = ble_ll_conn_get_next_sched_time(connsm);
    bdd2:	4601      	mov	r1, r0
         *  For slave:
         *  -> wait IFS, send current frame.
         *  -> wait IFS, receive maximum size frame.
         *  -> wait IFS, send next frame.
         */
        if ((cur_offset + cur_txlen) < pktlen) {
    bdd4:	da05      	bge.n	bde2 <ble_ll_conn_tx_data_pdu+0x16a>
    bdd6:	ebc9 0505 	rsb	r5, r9, r5
            next_txlen = pktlen - (cur_offset + cur_txlen);
    bdda:	ebcb 0005 	rsb	r0, fp, r5
    bdde:	b2c5      	uxtb	r5, r0
    bde0:	e005      	b.n	bdee <ble_ll_conn_tx_data_pdu+0x176>
        } else {
            if (nextpkthdr->omp_len > connsm->eff_max_tx_octets) {
    bde2:	f8ba 3000 	ldrh.w	r3, [sl]
    bde6:	7b25      	ldrb	r5, [r4, #12]
    bde8:	42ab      	cmp	r3, r5
                next_txlen = connsm->eff_max_tx_octets;
            } else {
                next_txlen = nextpkthdr->omp_len;
    bdea:	bf98      	it	ls
    bdec:	b2dd      	uxtbls	r5, r3
         * XXX: this calculation is based on using the current time
         * and assuming the transmission will occur an IFS time from
         * now. This is not the most accurate especially if we have
         * received a frame and we are replying to it.
         */
        ticks = (BLE_LL_IFS * 3) + connsm->eff_max_rx_time +
    bdee:	8b23      	ldrh	r3, [r4, #24]
                BLE_TX_DUR_USECS_M(next_txlen) +
                BLE_TX_DUR_USECS_M(cur_txlen);

        if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    bdf0:	79e2      	ldrb	r2, [r4, #7]
    bdf2:	9103      	str	r1, [sp, #12]
         * and assuming the transmission will occur an IFS time from
         * now. This is not the most accurate especially if we have
         * received a frame and we are replying to it.
         */
        ticks = (BLE_LL_IFS * 3) + connsm->eff_max_rx_time +
                BLE_TX_DUR_USECS_M(next_txlen) +
    bdf4:	eb03 00c5 	add.w	r0, r3, r5, lsl #3
                BLE_TX_DUR_USECS_M(cur_txlen);

        if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    bdf8:	2a01      	cmp	r2, #1
         * now. This is not the most accurate especially if we have
         * received a frame and we are replying to it.
         */
        ticks = (BLE_LL_IFS * 3) + connsm->eff_max_rx_time +
                BLE_TX_DUR_USECS_M(next_txlen) +
                BLE_TX_DUR_USECS_M(cur_txlen);
    bdfa:	eb00 05cb 	add.w	r5, r0, fp, lsl #3
    bdfe:	bf08      	it	eq
    be00:	3396      	addeq	r3, #150	; 0x96
         * and assuming the transmission will occur an IFS time from
         * now. This is not the most accurate especially if we have
         * received a frame and we are replying to it.
         */
        ticks = (BLE_LL_IFS * 3) + connsm->eff_max_rx_time +
                BLE_TX_DUR_USECS_M(next_txlen) +
    be02:	f205 2062 	addw	r0, r5, #610	; 0x262
                BLE_TX_DUR_USECS_M(cur_txlen);

        if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
            ticks += (BLE_LL_IFS + connsm->eff_max_rx_time);
    be06:	bf08      	it	eq
    be08:	18c0      	addeq	r0, r0, r3
        }

        ticks = cputime_usecs_to_ticks(ticks);
    be0a:	f7fc ff53 	bl	8cb4 <cputime_usecs_to_ticks>
    be0e:	4605      	mov	r5, r0
        if ((cputime_get32() + ticks) < next_event_time) {
    be10:	f7fd f894 	bl	8f3c <cputime_get32>
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    m = NULL;
    md = 0;
    be14:	9903      	ldr	r1, [sp, #12]
        if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
            ticks += (BLE_LL_IFS + connsm->eff_max_rx_time);
        }

        ticks = cputime_usecs_to_ticks(ticks);
        if ((cputime_get32() + ticks) < next_event_time) {
    be16:	4428      	add	r0, r5
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    m = NULL;
    md = 0;
    be18:	4288      	cmp	r0, r1
    be1a:	bf2c      	ite	cs
    be1c:	2500      	movcs	r5, #0
    be1e:	2501      	movcc	r5, #1
    be20:	e000      	b.n	be24 <ble_ll_conn_tx_data_pdu+0x1ac>
    be22:	2500      	movs	r5, #0
        }
     }

    /* If we send an empty PDU we need to initialize the header */
conn_tx_pdu:
    if (CONN_F_EMPTY_PDU_TXD(connsm)) {
    be24:	7863      	ldrb	r3, [r4, #1]
    be26:	06d9      	lsls	r1, r3, #27
    be28:	d50b      	bpl.n	be42 <ble_ll_conn_tx_data_pdu+0x1ca>
         * This looks strange, but we dont use the data pointer in the mbuf
         * when we have an empty pdu.
         */
        m = (struct os_mbuf *)&empty_pdu;
        m->om_data = (uint8_t *)&empty_pdu;
        m->om_data += BLE_MBUF_MEMBLOCK_OVERHEAD;
    be2a:	ab0c      	add	r3, sp, #48	; 0x30
    be2c:	9304      	str	r3, [sp, #16]
        ble_hdr = &empty_pdu.ble_hdr;
        ble_hdr->txinfo.flags = 0;
    be2e:	2300      	movs	r3, #0
    be30:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
        ble_hdr->txinfo.offset = 0;
    be34:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
        ble_hdr->txinfo.pyld_len = 0;
    be38:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
         * when we have an empty pdu.
         */
        m = (struct os_mbuf *)&empty_pdu;
        m->om_data = (uint8_t *)&empty_pdu;
        m->om_data += BLE_MBUF_MEMBLOCK_OVERHEAD;
        ble_hdr = &empty_pdu.ble_hdr;
    be3c:	f10d 0828 	add.w	r8, sp, #40	; 0x28
    if (CONN_F_EMPTY_PDU_TXD(connsm)) {
        /*
         * This looks strange, but we dont use the data pointer in the mbuf
         * when we have an empty pdu.
         */
        m = (struct os_mbuf *)&empty_pdu;
    be40:	ae04      	add	r6, sp, #16
        ble_hdr->txinfo.offset = 0;
        ble_hdr->txinfo.pyld_len = 0;
    }

    /* Set tx seqnum */
    if (connsm->tx_seqnum) {
    be42:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    be46:	b10b      	cbz	r3, be4c <ble_ll_conn_tx_data_pdu+0x1d4>
        hdr_byte |= BLE_LL_DATA_HDR_SN_MASK;
    be48:	f047 0708 	orr.w	r7, r7, #8
    }

    /* If we have more data, set the bit */
    if (md) {
    be4c:	b10d      	cbz	r5, be52 <ble_ll_conn_tx_data_pdu+0x1da>
        hdr_byte |= BLE_LL_DATA_HDR_MD_MASK;
    be4e:	f047 0710 	orr.w	r7, r7, #16
    }

    /* Set NESN (next expected sequence number) bit */
    if (connsm->next_exp_seqnum) {
    be52:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    be56:	b10b      	cbz	r3, be5c <ble_ll_conn_tx_data_pdu+0x1e4>
        hdr_byte |= BLE_LL_DATA_HDR_NESN_MASK;
    be58:	f047 0704 	orr.w	r7, r7, #4
    }

    /* Set the header byte in the outgoing frame */
    ble_hdr->txinfo.hdr_byte = hdr_byte;
    be5c:	f888 7003 	strb.w	r7, [r8, #3]
     *  -> wait IFS, send empty pdu or next pdu.
     *
     *  We could do this. Now, we just keep going and hope that we dont
     *  overrun next scheduled item.
     */
    if ((connsm->csmflags.cfbit.terminate_ind_rxd) ||
    be60:	7823      	ldrb	r3, [r4, #0]
    be62:	075a      	lsls	r2, r3, #29
    be64:	d418      	bmi.n	be98 <ble_ll_conn_tx_data_pdu+0x220>
    be66:	79e3      	ldrb	r3, [r4, #7]
    be68:	2b02      	cmp	r3, #2
    be6a:	d004      	beq.n	be76 <ble_ll_conn_tx_data_pdu+0x1fe>
        end_transition = BLE_PHY_TRANSITION_NONE;
        txend_func = ble_ll_conn_wait_txend;
    } else {
        /* Wait for a response here */
        end_transition = BLE_PHY_TRANSITION_TX_RX;
        txend_func = NULL;
    be6c:	f04f 0900 	mov.w	r9, #0
        /* We will end the connection event */
        end_transition = BLE_PHY_TRANSITION_NONE;
        txend_func = ble_ll_conn_wait_txend;
    } else {
        /* Wait for a response here */
        end_transition = BLE_PHY_TRANSITION_TX_RX;
    be70:	f04f 0a02 	mov.w	sl, #2
    be74:	e014      	b.n	bea0 <ble_ll_conn_tx_data_pdu+0x228>
     *
     *  We could do this. Now, we just keep going and hope that we dont
     *  overrun next scheduled item.
     */
    if ((connsm->csmflags.cfbit.terminate_ind_rxd) ||
        ((connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) && (md == 0) &&
    be76:	2d00      	cmp	r5, #0
    be78:	d1f8      	bne.n	be6c <ble_ll_conn_tx_data_pdu+0x1f4>
    be7a:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    be7e:	2b00      	cmp	r3, #0
    be80:	d1f4      	bne.n	be6c <ble_ll_conn_tx_data_pdu+0x1f4>
         (connsm->cons_rxd_bad_crc == 0) &&
         ((connsm->last_rxd_hdr_byte & BLE_LL_DATA_HDR_MD_MASK) == 0) &&
    be82:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
     *  We could do this. Now, we just keep going and hope that we dont
     *  overrun next scheduled item.
     */
    if ((connsm->csmflags.cfbit.terminate_ind_rxd) ||
        ((connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) && (md == 0) &&
         (connsm->cons_rxd_bad_crc == 0) &&
    be86:	06db      	lsls	r3, r3, #27
    be88:	d4f0      	bmi.n	be6c <ble_ll_conn_tx_data_pdu+0x1f4>
         ((connsm->last_rxd_hdr_byte & BLE_LL_DATA_HDR_MD_MASK) == 0) &&
         !ble_ll_ctrl_is_terminate_ind(hdr_byte, m->om_data[0]))) {
    be8a:	6833      	ldr	r3, [r6, #0]
    be8c:	4638      	mov	r0, r7
    be8e:	7819      	ldrb	r1, [r3, #0]
    be90:	f002 fad8 	bl	e444 <ble_ll_ctrl_is_terminate_ind>
     *  overrun next scheduled item.
     */
    if ((connsm->csmflags.cfbit.terminate_ind_rxd) ||
        ((connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) && (md == 0) &&
         (connsm->cons_rxd_bad_crc == 0) &&
         ((connsm->last_rxd_hdr_byte & BLE_LL_DATA_HDR_MD_MASK) == 0) &&
    be94:	2800      	cmp	r0, #0
    be96:	d1e9      	bne.n	be6c <ble_ll_conn_tx_data_pdu+0x1f4>
         !ble_ll_ctrl_is_terminate_ind(hdr_byte, m->om_data[0]))) {
        /* We will end the connection event */
        end_transition = BLE_PHY_TRANSITION_NONE;
        txend_func = ble_ll_conn_wait_txend;
    be98:	f8df 9164 	ldr.w	r9, [pc, #356]	; c000 <ble_ll_conn_tx_data_pdu+0x388>
        ((connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) && (md == 0) &&
         (connsm->cons_rxd_bad_crc == 0) &&
         ((connsm->last_rxd_hdr_byte & BLE_LL_DATA_HDR_MD_MASK) == 0) &&
         !ble_ll_ctrl_is_terminate_ind(hdr_byte, m->om_data[0]))) {
        /* We will end the connection event */
        end_transition = BLE_PHY_TRANSITION_NONE;
    be9c:	f04f 0a00 	mov.w	sl, #0
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    int is_ctrl;
    uint8_t llid;
    uint8_t opcode;

    llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
    bea0:	f898 3003 	ldrb.w	r3, [r8, #3]
    if (llid == BLE_LL_LLID_CTRL) {
    bea4:	f003 0303 	and.w	r3, r3, #3
    bea8:	2b03      	cmp	r3, #3
    beaa:	d157      	bne.n	bf5c <ble_ll_conn_tx_data_pdu+0x2e4>
        is_ctrl = 1;
        opcode = m->om_data[0];
    beac:	6833      	ldr	r3, [r6, #0]
    beae:	781b      	ldrb	r3, [r3, #0]
    } else {
        is_ctrl = 0;
        opcode = 0;
    }

    if (is_ctrl && (opcode == BLE_LL_CTRL_START_ENC_RSP)) {
    beb0:	2b06      	cmp	r3, #6
    beb2:	d118      	bne.n	bee6 <ble_ll_conn_tx_data_pdu+0x26e>
        /*
         * Both master and slave send the START_ENC_RSP encrypted and receive
         * encrypted
         */
        CONN_F_ENCRYPTED(connsm) = 1;
    beb4:	78a3      	ldrb	r3, [r4, #2]
        connsm->enc_data.tx_encrypted = 1;
        ble_phy_encrypt_enable(connsm->enc_data.tx_pkt_cntr,
    beb6:	f8b4 0124 	ldrh.w	r0, [r4, #292]	; 0x124
    if (is_ctrl && (opcode == BLE_LL_CTRL_START_ENC_RSP)) {
        /*
         * Both master and slave send the START_ENC_RSP encrypted and receive
         * encrypted
         */
        CONN_F_ENCRYPTED(connsm) = 1;
    beba:	f043 0301 	orr.w	r3, r3, #1
    bebe:	70a3      	strb	r3, [r4, #2]
        connsm->enc_data.tx_encrypted = 1;
    bec0:	2301      	movs	r3, #1
    bec2:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
        ble_phy_encrypt_enable(connsm->enc_data.tx_pkt_cntr,
    bec6:	79e3      	ldrb	r3, [r4, #7]
    bec8:	f103 3eff 	add.w	lr, r3, #4294967295	; 0xffffffff
    becc:	f1de 0300 	rsbs	r3, lr, #0
    bed0:	eb43 030e 	adc.w	r3, r3, lr
    bed4:	9300      	str	r3, [sp, #0]
    bed6:	2100      	movs	r1, #0
    bed8:	f504 7298 	add.w	r2, r4, #304	; 0x130
    bedc:	f504 73ac 	add.w	r3, r4, #344	; 0x158
    bee0:	f005 f8da 	bl	11098 <ble_phy_encrypt_enable>
    bee4:	e04e      	b.n	bf84 <ble_ll_conn_tx_data_pdu+0x30c>
                               connsm->enc_data.iv,
                               connsm->enc_data.enc_block.cipher_text,
                               CONN_IS_MASTER(connsm));
    } else if (is_ctrl && (opcode == BLE_LL_CTRL_START_ENC_REQ)) {
    bee6:	2b05      	cmp	r3, #5
    bee8:	d10d      	bne.n	bf06 <ble_ll_conn_tx_data_pdu+0x28e>
        /*
         * Only the slave sends this and it gets sent unencrypted but
         * we receive encrypted
         */
        CONN_F_ENCRYPTED(connsm) = 0;
    beea:	78a2      	ldrb	r2, [r4, #2]
        connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
    beec:	f884 3120 	strb.w	r3, [r4, #288]	; 0x120
    } else if (is_ctrl && (opcode == BLE_LL_CTRL_START_ENC_REQ)) {
        /*
         * Only the slave sends this and it gets sent unencrypted but
         * we receive encrypted
         */
        CONN_F_ENCRYPTED(connsm) = 0;
    bef0:	f36f 0200 	bfc	r2, #0, #1
        connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
        connsm->enc_data.tx_encrypted = 0;
    bef4:	2300      	movs	r3, #0
    } else if (is_ctrl && (opcode == BLE_LL_CTRL_START_ENC_REQ)) {
        /*
         * Only the slave sends this and it gets sent unencrypted but
         * we receive encrypted
         */
        CONN_F_ENCRYPTED(connsm) = 0;
    bef6:	70a2      	strb	r2, [r4, #2]
        connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
        connsm->enc_data.tx_encrypted = 0;
    bef8:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
        ble_phy_encrypt_disable();
    befc:	f005 f8fe 	bl	110fc <ble_phy_encrypt_disable>
        if (txend_func == NULL) {
            txend_func = ble_ll_conn_start_rx_encrypt;
        } else {
            txend_func = ble_ll_conn_txend_encrypt;
    bf00:	4b39      	ldr	r3, [pc, #228]	; (bfe8 <ble_ll_conn_tx_data_pdu+0x370>)
    bf02:	4a3a      	ldr	r2, [pc, #232]	; (bfec <ble_ll_conn_tx_data_pdu+0x374>)
    bf04:	e018      	b.n	bf38 <ble_ll_conn_tx_data_pdu+0x2c0>
        }
    } else if (is_ctrl && (opcode == BLE_LL_CTRL_PAUSE_ENC_RSP)) {
    bf06:	2b0b      	cmp	r3, #11
    bf08:	d128      	bne.n	bf5c <ble_ll_conn_tx_data_pdu+0x2e4>
        /*
         * The slave sends the PAUSE_ENC_RSP encrypted. The master sends
         * it unencrypted (note that link was already set unencrypted).
         */
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    bf0a:	79e3      	ldrb	r3, [r4, #7]
    bf0c:	2b02      	cmp	r3, #2
    bf0e:	78a3      	ldrb	r3, [r4, #2]
    bf10:	d118      	bne.n	bf44 <ble_ll_conn_tx_data_pdu+0x2cc>
            CONN_F_ENCRYPTED(connsm) = 1;
    bf12:	f043 0301 	orr.w	r3, r3, #1
    bf16:	70a3      	strb	r3, [r4, #2]
            connsm->enc_data.tx_encrypted = 1;
    bf18:	2301      	movs	r3, #1
    bf1a:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
            ble_phy_encrypt_enable(connsm->enc_data.tx_pkt_cntr,
    bf1e:	2300      	movs	r3, #0
    bf20:	f8b4 0124 	ldrh.w	r0, [r4, #292]	; 0x124
    bf24:	9300      	str	r3, [sp, #0]
    bf26:	f504 7298 	add.w	r2, r4, #304	; 0x130
    bf2a:	f504 73ac 	add.w	r3, r4, #344	; 0x158
    bf2e:	2100      	movs	r1, #0
    bf30:	f005 f8b2 	bl	11098 <ble_phy_encrypt_enable>
                                   connsm->enc_data.enc_block.cipher_text,
                                   CONN_IS_MASTER(connsm));
            if (txend_func == NULL) {
                txend_func = ble_ll_conn_start_rx_unencrypt;
            } else {
                txend_func = ble_ll_conn_rxend_unencrypt;
    bf34:	4b2e      	ldr	r3, [pc, #184]	; (bff0 <ble_ll_conn_tx_data_pdu+0x378>)
    bf36:	4a2f      	ldr	r2, [pc, #188]	; (bff4 <ble_ll_conn_tx_data_pdu+0x37c>)
    bf38:	f1b9 0f00 	cmp.w	r9, #0
    bf3c:	bf0c      	ite	eq
    bf3e:	4691      	moveq	r9, r2
    bf40:	4699      	movne	r9, r3
    bf42:	e01f      	b.n	bf84 <ble_ll_conn_tx_data_pdu+0x30c>
            }
        } else {
            CONN_F_ENCRYPTED(connsm) = 0;
    bf44:	f36f 0300 	bfc	r3, #0, #1
    bf48:	70a3      	strb	r3, [r4, #2]
            connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
    bf4a:	2301      	movs	r3, #1
    bf4c:	f884 3120 	strb.w	r3, [r4, #288]	; 0x120
            connsm->enc_data.tx_encrypted = 0;
    bf50:	2300      	movs	r3, #0
    bf52:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
            ble_phy_encrypt_disable();
    bf56:	f005 f8d1 	bl	110fc <ble_phy_encrypt_disable>
    bf5a:	e013      	b.n	bf84 <ble_ll_conn_tx_data_pdu+0x30c>
        }
    } else {
        /* If encrypted set packet counter */
        if (CONN_F_ENCRYPTED(connsm)) {
    bf5c:	78a3      	ldrb	r3, [r4, #2]
    bf5e:	07da      	lsls	r2, r3, #31
    bf60:	d510      	bpl.n	bf84 <ble_ll_conn_tx_data_pdu+0x30c>
            connsm->enc_data.tx_encrypted = 1;
            ble_phy_encrypt_set_pkt_cntr(connsm->enc_data.tx_pkt_cntr,
    bf62:	79e2      	ldrb	r2, [r4, #7]
    bf64:	f8b4 0124 	ldrh.w	r0, [r4, #292]	; 0x124
            ble_phy_encrypt_disable();
        }
    } else {
        /* If encrypted set packet counter */
        if (CONN_F_ENCRYPTED(connsm)) {
            connsm->enc_data.tx_encrypted = 1;
    bf68:	2301      	movs	r3, #1
    bf6a:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
            ble_phy_encrypt_set_pkt_cntr(connsm->enc_data.tx_pkt_cntr,
    bf6e:	1ad3      	subs	r3, r2, r3
    bf70:	425a      	negs	r2, r3
    bf72:	415a      	adcs	r2, r3
    bf74:	2100      	movs	r1, #0
    bf76:	f005 f8b9 	bl	110ec <ble_phy_encrypt_set_pkt_cntr>
                                         CONN_IS_MASTER(connsm));
            if (txend_func == NULL) {
                txend_func = ble_ll_conn_continue_rx_encrypt;
    bf7a:	4b1f      	ldr	r3, [pc, #124]	; (bff8 <ble_ll_conn_tx_data_pdu+0x380>)
    bf7c:	f1b9 0f00 	cmp.w	r9, #0
    bf80:	bf08      	it	eq
    bf82:	4699      	moveq	r9, r3
        }
    }
#endif

    /* Set transmit end callback */
    ble_phy_set_txend_cb(txend_func, connsm);
    bf84:	4648      	mov	r0, r9
    bf86:	4621      	mov	r1, r4
    bf88:	f005 f8ce 	bl	11128 <ble_phy_set_txend_cb>
    rc = ble_phy_tx(m, end_transition);
    bf8c:	4630      	mov	r0, r6
    bf8e:	4651      	mov	r1, sl
    bf90:	f005 faea 	bl	11568 <ble_phy_tx>
    if (!rc) {
    bf94:	bb20      	cbnz	r0, bfe0 <ble_ll_conn_tx_data_pdu+0x368>
                   hdr_byte,
                   ((uint16_t)ble_hdr->txinfo.offset << 8) | cur_txlen,
                   (uint32_t)m);

        /* Set last transmitted MD bit */
        CONN_F_LAST_TXD_MD(connsm) = md;
    bf96:	7863      	ldrb	r3, [r4, #1]
    /* Set transmit end callback */
    ble_phy_set_txend_cb(txend_func, connsm);
    rc = ble_phy_tx(m, end_transition);
    if (!rc) {
        /* Log transmit on connection state */
        cur_txlen = ble_hdr->txinfo.pyld_len;
    bf98:	f898 6002 	ldrb.w	r6, [r8, #2]
                   hdr_byte,
                   ((uint16_t)ble_hdr->txinfo.offset << 8) | cur_txlen,
                   (uint32_t)m);

        /* Set last transmitted MD bit */
        CONN_F_LAST_TXD_MD(connsm) = md;
    bf9c:	f365 1345 	bfi	r3, r5, #5, #1

        /* Increment packets transmitted */
        if (CONN_F_EMPTY_PDU_TXD(connsm)) {
    bfa0:	f013 0f10 	tst.w	r3, #16
                   hdr_byte,
                   ((uint16_t)ble_hdr->txinfo.offset << 8) | cur_txlen,
                   (uint32_t)m);

        /* Set last transmitted MD bit */
        CONN_F_LAST_TXD_MD(connsm) = md;
    bfa4:	7063      	strb	r3, [r4, #1]
    bfa6:	4b15      	ldr	r3, [pc, #84]	; (bffc <ble_ll_conn_tx_data_pdu+0x384>)

        /* Increment packets transmitted */
        if (CONN_F_EMPTY_PDU_TXD(connsm)) {
    bfa8:	d003      	beq.n	bfb2 <ble_ll_conn_tx_data_pdu+0x33a>
            STATS_INC(ble_ll_conn_stats, tx_empty_pdus);
    bfaa:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    bfac:	3201      	adds	r2, #1
    bfae:	66da      	str	r2, [r3, #108]	; 0x6c
    bfb0:	e016      	b.n	bfe0 <ble_ll_conn_tx_data_pdu+0x368>
        } else if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
    bfb2:	f007 0703 	and.w	r7, r7, #3
    bfb6:	2f03      	cmp	r7, #3
            STATS_INC(ble_ll_conn_stats, tx_ctrl_pdus);
    bfb8:	bf07      	ittee	eq
    bfba:	6ddc      	ldreq	r4, [r3, #92]	; 0x5c
            STATS_INCN(ble_ll_conn_stats, tx_ctrl_bytes, cur_txlen);
    bfbc:	6e19      	ldreq	r1, [r3, #96]	; 0x60
        } else {
            STATS_INC(ble_ll_conn_stats, tx_l2cap_pdus);
    bfbe:	6e59      	ldrne	r1, [r3, #100]	; 0x64
            STATS_INCN(ble_ll_conn_stats, tx_l2cap_bytes, cur_txlen);
    bfc0:	6e9a      	ldrne	r2, [r3, #104]	; 0x68

        /* Increment packets transmitted */
        if (CONN_F_EMPTY_PDU_TXD(connsm)) {
            STATS_INC(ble_ll_conn_stats, tx_empty_pdus);
        } else if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
            STATS_INC(ble_ll_conn_stats, tx_ctrl_pdus);
    bfc2:	bf07      	ittee	eq
    bfc4:	3401      	addeq	r4, #1
            STATS_INCN(ble_ll_conn_stats, tx_ctrl_bytes, cur_txlen);
    bfc6:	1989      	addeq	r1, r1, r6
        } else {
            STATS_INC(ble_ll_conn_stats, tx_l2cap_pdus);
    bfc8:	3101      	addne	r1, #1
            STATS_INCN(ble_ll_conn_stats, tx_l2cap_bytes, cur_txlen);
    bfca:	1992      	addne	r2, r2, r6

        /* Increment packets transmitted */
        if (CONN_F_EMPTY_PDU_TXD(connsm)) {
            STATS_INC(ble_ll_conn_stats, tx_empty_pdus);
        } else if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
            STATS_INC(ble_ll_conn_stats, tx_ctrl_pdus);
    bfcc:	bf07      	ittee	eq
    bfce:	65dc      	streq	r4, [r3, #92]	; 0x5c
            STATS_INCN(ble_ll_conn_stats, tx_ctrl_bytes, cur_txlen);
    bfd0:	6619      	streq	r1, [r3, #96]	; 0x60
        } else {
            STATS_INC(ble_ll_conn_stats, tx_l2cap_pdus);
    bfd2:	6659      	strne	r1, [r3, #100]	; 0x64
            STATS_INCN(ble_ll_conn_stats, tx_l2cap_bytes, cur_txlen);
    bfd4:	669a      	strne	r2, [r3, #104]	; 0x68
    bfd6:	e003      	b.n	bfe0 <ble_ll_conn_tx_data_pdu+0x368>
    struct os_mbuf_pkthdr *nextpkthdr;
    struct ble_ll_empty_pdu empty_pdu;
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    bfd8:	46b0      	mov	r8, r6
    m = NULL;
    md = 0;
    hdr_byte = BLE_LL_LLID_DATA_FRAG;
    bfda:	2701      	movs	r7, #1
    ble_phy_tx_end_func txend_func;

    /* For compiler warnings... */
    ble_hdr = NULL;
    m = NULL;
    md = 0;
    bfdc:	4635      	mov	r5, r6
    bfde:	e721      	b.n	be24 <ble_ll_conn_tx_data_pdu+0x1ac>
            STATS_INC(ble_ll_conn_stats, tx_l2cap_pdus);
            STATS_INCN(ble_ll_conn_stats, tx_l2cap_bytes, cur_txlen);
        }
    }
    return rc;
}
    bfe0:	b00d      	add	sp, #52	; 0x34
    bfe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bfe6:	bf00      	nop
    bfe8:	0000bbc1 	.word	0x0000bbc1
    bfec:	0000bbf7 	.word	0x0000bbf7
    bff0:	0000bba5 	.word	0x0000bba5
    bff4:	0000bc27 	.word	0x0000bc27
    bff8:	0000bc33 	.word	0x0000bc33
    bffc:	20003580 	.word	0x20003580
    c000:	0000bbdd 	.word	0x0000bbdd

0000c004 <ble_ll_conn_event_start_cb>:
 *
 * @return int 0: scheduled item is still running. 1: schedule item is done.
 */
static int
ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
{
    c004:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    struct ble_ll_conn_sm *connsm;

    /* XXX: note that we can extend end time here if we want. Look at this */

    /* Set current connection state machine */
    connsm = (struct ble_ll_conn_sm *)sch->cb_arg;
    c006:	68c4      	ldr	r4, [r0, #12]
    g_ble_ll_conn_cur_sm = connsm;
    c008:	4d39      	ldr	r5, [pc, #228]	; (c0f0 <ble_ll_conn_event_start_cb+0xec>)
 *
 * @return int 0: scheduled item is still running. 1: schedule item is done.
 */
static int
ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
{
    c00a:	4607      	mov	r7, r0

    /* XXX: note that we can extend end time here if we want. Look at this */

    /* Set current connection state machine */
    connsm = (struct ble_ll_conn_sm *)sch->cb_arg;
    g_ble_ll_conn_cur_sm = connsm;
    c00c:	602c      	str	r4, [r5, #0]
    assert(connsm);
    c00e:	b934      	cbnz	r4, c01e <ble_ll_conn_event_start_cb+0x1a>
    c010:	4838      	ldr	r0, [pc, #224]	; (c0f4 <ble_ll_conn_event_start_cb+0xf0>)
    c012:	f240 4153 	movw	r1, #1107	; 0x453
    c016:	4622      	mov	r2, r4
    c018:	4623      	mov	r3, r4
    c01a:	f7fd fe59 	bl	9cd0 <__assert_func>

    /* Disable whitelisting as connections do not use it */
    ble_ll_whitelist_disable();
    c01e:	f004 fd85 	bl	10b2c <ble_ll_whitelist_disable>

    /* Set LL state */
    ble_ll_state_set(BLE_LL_STATE_CONNECTION);
    c022:	2004      	movs	r0, #4
    c024:	f7ff f85e 	bl	b0e4 <ble_ll_state_set>
    /* Log connection event start */
    ble_ll_log(BLE_LL_LOG_ID_CONN_EV_START, (uint8_t)connsm->conn_handle,
               (uint16_t)connsm->ce_end_time, connsm->csmflags.conn_flags);

    /* Set channel */
    ble_phy_setchan(connsm->data_chan_index, connsm->access_addr,
    c028:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    c02a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    c02c:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
    c030:	f005 f8a0 	bl	11174 <ble_phy_setchan>
                    connsm->crcinit);

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    ble_phy_resolv_list_disable();
    c034:	f005 fb4a 	bl	116cc <ble_phy_resolv_list_disable>
#endif

    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    c038:	79e6      	ldrb	r6, [r4, #7]
    c03a:	2e01      	cmp	r6, #1
    c03c:	d11e      	bne.n	c07c <ble_ll_conn_event_start_cb+0x78>
        /* Set start time of transmission */
        rc = ble_phy_tx_set_start_time(sch->start_time + XCVR_PROC_DELAY_USECS);
    c03e:	6878      	ldr	r0, [r7, #4]
    c040:	3032      	adds	r0, #50	; 0x32
    c042:	f005 fa6f 	bl	11524 <ble_phy_tx_set_start_time>
        if (!rc) {
    c046:	b9a0      	cbnz	r0, c072 <ble_ll_conn_event_start_cb+0x6e>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (CONN_F_ENCRYPTED(connsm)) {
    c048:	78a3      	ldrb	r3, [r4, #2]
    c04a:	07da      	lsls	r2, r3, #31
    c04c:	d50a      	bpl.n	c064 <ble_ll_conn_event_start_cb+0x60>
                ble_phy_encrypt_enable(connsm->enc_data.tx_pkt_cntr,
    c04e:	f8b4 0124 	ldrh.w	r0, [r4, #292]	; 0x124
    c052:	9600      	str	r6, [sp, #0]
    c054:	2100      	movs	r1, #0
    c056:	f504 7298 	add.w	r2, r4, #304	; 0x130
    c05a:	f504 73ac 	add.w	r3, r4, #344	; 0x158
    c05e:	f005 f81b 	bl	11098 <ble_phy_encrypt_enable>
    c062:	e001      	b.n	c068 <ble_ll_conn_event_start_cb+0x64>
                                       connsm->enc_data.iv,
                                       connsm->enc_data.enc_block.cipher_text,
                                       1);
            } else {
                ble_phy_encrypt_disable();
    c064:	f005 f84a 	bl	110fc <ble_phy_encrypt_disable>
            }
#endif
            rc = ble_ll_conn_tx_data_pdu(connsm);
    c068:	4620      	mov	r0, r4
    c06a:	f7ff fe05 	bl	bc78 <ble_ll_conn_tx_data_pdu>
            if (!rc) {
    c06e:	b360      	cbz	r0, c0ca <ble_ll_conn_event_start_cb+0xc6>
    c070:	e02d      	b.n	c0ce <ble_ll_conn_event_start_cb+0xca>
            } else {
                /* Inform LL task of connection event end */
                rc = BLE_LL_SCHED_STATE_DONE;
            }
        } else {
            STATS_INC(ble_ll_conn_stats, conn_ev_late);
    c072:	4a21      	ldr	r2, [pc, #132]	; (c0f8 <ble_ll_conn_event_start_cb+0xf4>)
    c074:	6913      	ldr	r3, [r2, #16]
    c076:	3301      	adds	r3, #1
    c078:	6113      	str	r3, [r2, #16]
    c07a:	e028      	b.n	c0ce <ble_ll_conn_event_start_cb+0xca>
            rc = BLE_LL_SCHED_STATE_DONE;
        }
    } else {
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (CONN_F_ENCRYPTED(connsm)) {
    c07c:	78a3      	ldrb	r3, [r4, #2]
    c07e:	07db      	lsls	r3, r3, #31
    c080:	d50b      	bpl.n	c09a <ble_ll_conn_event_start_cb+0x96>
                ble_phy_encrypt_enable(connsm->enc_data.rx_pkt_cntr,
    c082:	2301      	movs	r3, #1
    c084:	f8b4 0126 	ldrh.w	r0, [r4, #294]	; 0x126
    c088:	9300      	str	r3, [sp, #0]
    c08a:	2100      	movs	r1, #0
    c08c:	f504 7298 	add.w	r2, r4, #304	; 0x130
    c090:	f504 73ac 	add.w	r3, r4, #344	; 0x158
    c094:	f005 f800 	bl	11098 <ble_phy_encrypt_enable>
    c098:	e001      	b.n	c09e <ble_ll_conn_event_start_cb+0x9a>
                                       connsm->enc_data.iv,
                                       connsm->enc_data.enc_block.cipher_text,
                                       1);
            } else {
                ble_phy_encrypt_disable();
    c09a:	f005 f82f 	bl	110fc <ble_phy_encrypt_disable>
#endif
        /*
         * XXX: make sure I dont care that I get here early to start receiving.
         * I could use events compare and all that shit to start rx.
         */
        rc = ble_phy_rx();
    c09e:	f005 fa09 	bl	114b4 <ble_phy_rx>
        if (rc) {
    c0a2:	b120      	cbz	r0, c0ae <ble_ll_conn_event_start_cb+0xaa>
            /* End the connection event as we have no more buffers */
            STATS_INC(ble_ll_conn_stats, slave_ce_failures);
    c0a4:	4a14      	ldr	r2, [pc, #80]	; (c0f8 <ble_ll_conn_event_start_cb+0xf4>)
    c0a6:	6b13      	ldr	r3, [r2, #48]	; 0x30
    c0a8:	3301      	adds	r3, #1
    c0aa:	6313      	str	r3, [r2, #48]	; 0x30
    c0ac:	e00f      	b.n	c0ce <ble_ll_conn_event_start_cb+0xca>
        } else {
            /*
             * Set flag that tells slave to set last anchor point if a packet
             * has been received.
             */
            connsm->csmflags.cfbit.slave_set_last_anchor = 1;
    c0ae:	7823      	ldrb	r3, [r4, #0]
             * to hear a reply within the anchor point plus:
             *  -> the current tx window size
             *  -> The current window widening amount
             *  -> Amount of time it takes to detect packet start.
             */
            usecs = connsm->slave_cur_tx_win_usecs + BLE_LL_WFR_USECS +
    c0b0:	6f60      	ldr	r0, [r4, #116]	; 0x74
                connsm->slave_cur_window_widening;
            wfr_time = connsm->anchor_point + cputime_usecs_to_ticks(usecs);
    c0b2:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
        } else {
            /*
             * Set flag that tells slave to set last anchor point if a packet
             * has been received.
             */
            connsm->csmflags.cfbit.slave_set_last_anchor = 1;
    c0b4:	f043 0310 	orr.w	r3, r3, #16
    c0b8:	7023      	strb	r3, [r4, #0]
             * to hear a reply within the anchor point plus:
             *  -> the current tx window size
             *  -> The current window widening amount
             *  -> Amount of time it takes to detect packet start.
             */
            usecs = connsm->slave_cur_tx_win_usecs + BLE_LL_WFR_USECS +
    c0ba:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    c0bc:	4418      	add	r0, r3
                connsm->slave_cur_window_widening;
            wfr_time = connsm->anchor_point + cputime_usecs_to_ticks(usecs);
    c0be:	30de      	adds	r0, #222	; 0xde
    c0c0:	f7fc fdf8 	bl	8cb4 <cputime_usecs_to_ticks>
            ble_ll_wfr_enable(wfr_time);
    c0c4:	4428      	add	r0, r5
    c0c6:	f7fe ff2b 	bl	af20 <ble_ll_wfr_enable>
 *
 * @return int 0: scheduled item is still running. 1: schedule item is done.
 */
static int
ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
{
    c0ca:	2500      	movs	r5, #0
    c0cc:	e009      	b.n	c0e2 <ble_ll_conn_event_start_cb+0xde>
            rc = BLE_LL_SCHED_STATE_RUNNING;
        }
    }

    if (rc == BLE_LL_SCHED_STATE_DONE) {
        ble_ll_event_send(&connsm->conn_ev_end);
    c0ce:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
    c0d2:	f7ff f813 	bl	b0fc <ble_ll_event_send>
        ble_ll_state_set(BLE_LL_STATE_STANDBY);
    c0d6:	2000      	movs	r0, #0
    c0d8:	f7ff f804 	bl	b0e4 <ble_ll_state_set>
        g_ble_ll_conn_cur_sm = NULL;
    c0dc:	2300      	movs	r3, #0
    c0de:	602b      	str	r3, [r5, #0]
    c0e0:	2501      	movs	r5, #1
    }

    /* Set time that we last serviced the schedule */
    connsm->last_scheduled = cputime_get32();
    c0e2:	f7fc ff2b 	bl	8f3c <cputime_get32>
    c0e6:	65a0      	str	r0, [r4, #88]	; 0x58
    return rc;
}
    c0e8:	4628      	mov	r0, r5
    c0ea:	b003      	add	sp, #12
    c0ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c0ee:	bf00      	nop
    c0f0:	200033cc 	.word	0x200033cc
    c0f4:	0001f253 	.word	0x0001f253
    c0f8:	20003580 	.word	0x20003580

0000c0fc <ble_ll_conn_chk_csm_flags>:
 *
 * @param connsm
 */
static void
ble_ll_conn_chk_csm_flags(struct ble_ll_conn_sm *connsm)
{
    c0fc:	b510      	push	{r4, lr}
    uint8_t update_status;

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (connsm->csmflags.cfbit.send_ltk_req) {
    c0fe:	7843      	ldrb	r3, [r0, #1]
    c100:	0619      	lsls	r1, r3, #24
 *
 * @param connsm
 */
static void
ble_ll_conn_chk_csm_flags(struct ble_ll_conn_sm *connsm)
{
    c102:	4604      	mov	r4, r0
    uint8_t update_status;

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (connsm->csmflags.cfbit.send_ltk_req) {
    c104:	d50b      	bpl.n	c11e <ble_ll_conn_chk_csm_flags+0x22>
        /*
         * Send Long term key request event to host. If masked, we need to
         * send a REJECT_IND.
         */
        if (ble_ll_hci_ev_ltk_req(connsm)) {
    c106:	f003 f917 	bl	f338 <ble_ll_hci_ev_ltk_req>
    c10a:	b120      	cbz	r0, c116 <ble_ll_conn_chk_csm_flags+0x1a>
            ble_ll_ctrl_reject_ind_send(connsm, BLE_LL_CTRL_ENC_REQ,
    c10c:	4620      	mov	r0, r4
    c10e:	2103      	movs	r1, #3
    c110:	2206      	movs	r2, #6
    c112:	f002 fcad 	bl	ea70 <ble_ll_ctrl_reject_ind_send>
                                        BLE_ERR_PINKEY_MISSING);
        }
        connsm->csmflags.cfbit.send_ltk_req = 0;
    c116:	7863      	ldrb	r3, [r4, #1]
    c118:	f36f 13c7 	bfc	r3, #7, #1
    c11c:	7063      	strb	r3, [r4, #1]
     * There are two cases where this flag gets set:
     * 1) A connection update procedure was started and the event counter
     * has passed the instant.
     * 2) We successfully sent the reject reason.
     */
    if (connsm->csmflags.cfbit.host_expects_upd_event) {
    c11e:	7863      	ldrb	r3, [r4, #1]
    c120:	07da      	lsls	r2, r3, #31
    c122:	d519      	bpl.n	c158 <ble_ll_conn_chk_csm_flags+0x5c>
        update_status = BLE_ERR_SUCCESS;
        if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE)) {
    c124:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
    c126:	07cb      	lsls	r3, r1, #31
    c128:	d505      	bpl.n	c136 <ble_ll_conn_chk_csm_flags+0x3a>
            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE);
    c12a:	2100      	movs	r1, #0
    c12c:	4620      	mov	r0, r4
    c12e:	f002 fa11 	bl	e554 <ble_ll_ctrl_proc_stop>
     * 1) A connection update procedure was started and the event counter
     * has passed the instant.
     * 2) We successfully sent the reject reason.
     */
    if (connsm->csmflags.cfbit.host_expects_upd_event) {
        update_status = BLE_ERR_SUCCESS;
    c132:	2100      	movs	r1, #0
    c134:	e009      	b.n	c14a <ble_ll_conn_chk_csm_flags+0x4e>
        if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE)) {
            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE);
        } else {
            if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
    c136:	f001 0140 	and.w	r1, r1, #64	; 0x40
    c13a:	b289      	uxth	r1, r1
    c13c:	b129      	cbz	r1, c14a <ble_ll_conn_chk_csm_flags+0x4e>
                ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
    c13e:	2106      	movs	r1, #6
    c140:	4620      	mov	r0, r4
    c142:	f002 fa07 	bl	e554 <ble_ll_ctrl_proc_stop>
                update_status = connsm->reject_reason;
    c146:	f894 1032 	ldrb.w	r1, [r4, #50]	; 0x32
            }
        }
        ble_ll_hci_ev_conn_update(connsm, update_status);
    c14a:	4620      	mov	r0, r4
    c14c:	f003 f890 	bl	f270 <ble_ll_hci_ev_conn_update>
        connsm->csmflags.cfbit.host_expects_upd_event = 0;
    c150:	7863      	ldrb	r3, [r4, #1]
    c152:	f36f 0300 	bfc	r3, #0, #1
    c156:	7063      	strb	r3, [r4, #1]
    c158:	bd10      	pop	{r4, pc}

0000c15a <ble_ll_conn_is_lru>:
ble_ll_conn_is_lru(struct ble_ll_conn_sm *s1, struct ble_ll_conn_sm *s2)
{
    int rc;

    /* Set time that we last serviced the schedule */
    if ((int32_t)(s1->last_scheduled - s2->last_scheduled) < 0) {
    c15a:	6d83      	ldr	r3, [r0, #88]	; 0x58
    c15c:	6d88      	ldr	r0, [r1, #88]	; 0x58
    c15e:	1a18      	subs	r0, r3, r0
    } else {
        rc = 0;
    }

    return rc;
}
    c160:	0fc0      	lsrs	r0, r0, #31
    c162:	4770      	bx	lr

0000c164 <ble_ll_conn_get_ce_end_time>:
uint32_t
ble_ll_conn_get_ce_end_time(void)
{
    uint32_t ce_end_time;

    if (g_ble_ll_conn_cur_sm) {
    c164:	4b03      	ldr	r3, [pc, #12]	; (c174 <ble_ll_conn_get_ce_end_time+0x10>)
    c166:	681b      	ldr	r3, [r3, #0]
    c168:	b90b      	cbnz	r3, c16e <ble_ll_conn_get_ce_end_time+0xa>
        ce_end_time = g_ble_ll_conn_cur_sm->ce_end_time;
    } else {
        ce_end_time = cputime_get32();
    c16a:	f7fc bee7 	b.w	8f3c <cputime_get32>
ble_ll_conn_get_ce_end_time(void)
{
    uint32_t ce_end_time;

    if (g_ble_ll_conn_cur_sm) {
        ce_end_time = g_ble_ll_conn_cur_sm->ce_end_time;
    c16e:	6d18      	ldr	r0, [r3, #80]	; 0x50
    } else {
        ce_end_time = cputime_get32();
    }
    return ce_end_time;
}
    c170:	4770      	bx	lr
    c172:	bf00      	nop
    c174:	200033cc 	.word	0x200033cc

0000c178 <ble_ll_conn_find_active_conn>:
ble_ll_conn_find_active_conn(uint16_t handle)
{
    struct ble_ll_conn_sm *connsm;

    connsm = NULL;
    if ((handle != 0) && (handle <= NIMBLE_OPT_MAX_CONNECTIONS)) {
    c178:	2801      	cmp	r0, #1
    c17a:	d105      	bne.n	c188 <ble_ll_conn_find_active_conn+0x10>
        connsm = &g_ble_ll_conn_sm[handle - 1];
        if (connsm->conn_state == BLE_LL_CONN_STATE_IDLE) {
    c17c:	4803      	ldr	r0, [pc, #12]	; (c18c <ble_ll_conn_find_active_conn+0x14>)
    c17e:	7983      	ldrb	r3, [r0, #6]
            connsm = NULL;
    c180:	2b00      	cmp	r3, #0
    c182:	bf08      	it	eq
    c184:	2000      	moveq	r0, #0
    c186:	4770      	bx	lr
struct ble_ll_conn_sm *
ble_ll_conn_find_active_conn(uint16_t handle)
{
    struct ble_ll_conn_sm *connsm;

    connsm = NULL;
    c188:	2000      	movs	r0, #0
        if (connsm->conn_state == BLE_LL_CONN_STATE_IDLE) {
            connsm = NULL;
        }
    }
    return connsm;
}
    c18a:	4770      	bx	lr
    c18c:	200033e0 	.word	0x200033e0

0000c190 <ble_ll_conn_sm_get>:
struct ble_ll_conn_sm *
ble_ll_conn_sm_get(void)
{
    struct ble_ll_conn_sm *connsm;

    connsm = STAILQ_FIRST(&g_ble_ll_conn_free_list);
    c190:	4b06      	ldr	r3, [pc, #24]	; (c1ac <ble_ll_conn_sm_get+0x1c>)
    c192:	6818      	ldr	r0, [r3, #0]
    if (connsm) {
    c194:	b128      	cbz	r0, c1a2 <ble_ll_conn_sm_get+0x12>
        STAILQ_REMOVE_HEAD(&g_ble_ll_conn_free_list, free_stqe);
    c196:	f8d0 20bc 	ldr.w	r2, [r0, #188]	; 0xbc
    c19a:	601a      	str	r2, [r3, #0]
    c19c:	b92a      	cbnz	r2, c1aa <ble_ll_conn_sm_get+0x1a>
    c19e:	605b      	str	r3, [r3, #4]
    c1a0:	4770      	bx	lr
    } else {
        STATS_INC(ble_ll_conn_stats, no_free_conn_sm);
    c1a2:	4a03      	ldr	r2, [pc, #12]	; (c1b0 <ble_ll_conn_sm_get+0x20>)
    c1a4:	6a13      	ldr	r3, [r2, #32]
    c1a6:	3301      	adds	r3, #1
    c1a8:	6213      	str	r3, [r2, #32]
    }

    return connsm;
}
    c1aa:	4770      	bx	lr
    c1ac:	200033d0 	.word	0x200033d0
    c1b0:	20003580 	.word	0x20003580

0000c1b4 <ble_ll_conn_calc_window_widening>:
    int32_t time_since_last_anchor;
    uint32_t delta_msec;

    window_widening = 0;

    time_since_last_anchor = (int32_t)(connsm->anchor_point -
    c1b4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 *
 * @return uint32_t The current window widening amount (in microseconds)
 */
uint32_t
ble_ll_conn_calc_window_widening(struct ble_ll_conn_sm *connsm)
{
    c1b6:	b510      	push	{r4, lr}
    c1b8:	4604      	mov	r4, r0
    int32_t time_since_last_anchor;
    uint32_t delta_msec;

    window_widening = 0;

    time_since_last_anchor = (int32_t)(connsm->anchor_point -
    c1ba:	6f00      	ldr	r0, [r0, #112]	; 0x70
    c1bc:	1a18      	subs	r0, r3, r0
                                       connsm->last_anchor_point);
    if (time_since_last_anchor > 0) {
    c1be:	2800      	cmp	r0, #0
    c1c0:	dd0f      	ble.n	c1e2 <ble_ll_conn_calc_window_widening+0x2e>
        delta_msec = cputime_ticks_to_usecs(time_since_last_anchor) / 1000;
    c1c2:	f7fc fd7d 	bl	8cc0 <cputime_ticks_to_usecs>
        total_sca_ppm = g_ble_sca_ppm_tbl[connsm->master_sca] +
    c1c6:	f894 1034 	ldrb.w	r1, [r4, #52]	; 0x34
    c1ca:	4b07      	ldr	r3, [pc, #28]	; (c1e8 <ble_ll_conn_calc_window_widening+0x34>)
    c1cc:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    c1d0:	333c      	adds	r3, #60	; 0x3c
    window_widening = 0;

    time_since_last_anchor = (int32_t)(connsm->anchor_point -
                                       connsm->last_anchor_point);
    if (time_since_last_anchor > 0) {
        delta_msec = cputime_ticks_to_usecs(time_since_last_anchor) / 1000;
    c1d2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c1d6:	fbb0 f0f2 	udiv	r0, r0, r2
        total_sca_ppm = g_ble_sca_ppm_tbl[connsm->master_sca] +
            NIMBLE_OPT_LL_OUR_SCA;
        window_widening = (total_sca_ppm * delta_msec) / 1000;
    c1da:	4358      	muls	r0, r3
    c1dc:	fbb0 f0f2 	udiv	r0, r0, r2
    c1e0:	bd10      	pop	{r4, pc}
    uint32_t total_sca_ppm;
    uint32_t window_widening;
    int32_t time_since_last_anchor;
    uint32_t delta_msec;

    window_widening = 0;
    c1e2:	2000      	movs	r0, #0
        window_widening = (total_sca_ppm * delta_msec) / 1000;
    }

    /* XXX: spec gives 16 usecs error btw. Probably should add that in */
    return window_widening;
}
    c1e4:	bd10      	pop	{r4, pc}
    c1e6:	bf00      	nop
    c1e8:	0001f26e 	.word	0x0001f26e

0000c1ec <ble_ll_conn_calc_used_chans>:
 *
 * @return uint8_t Number of used channels
 */
uint8_t
ble_ll_conn_calc_used_chans(uint8_t *chmap)
{
    c1ec:	b530      	push	{r4, r5, lr}
    c1ee:	1e41      	subs	r1, r0, #1
    c1f0:	1d02      	adds	r2, r0, #4
    int j;
    uint8_t mask;
    uint8_t chanbyte;
    uint8_t used_channels;

    used_channels = 0;
    c1f2:	2000      	movs	r0, #0
    for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; ++i) {
        chanbyte = chmap[i];
    c1f4:	f811 5f01 	ldrb.w	r5, [r1, #1]!
        if (chanbyte) {
    c1f8:	b175      	cbz	r5, c218 <ble_ll_conn_calc_used_chans+0x2c>
            if (chanbyte == 0xff) {
    c1fa:	2dff      	cmp	r5, #255	; 0xff
    c1fc:	d102      	bne.n	c204 <ble_ll_conn_calc_used_chans+0x18>
                used_channels += 8;
    c1fe:	3008      	adds	r0, #8
    c200:	b2c0      	uxtb	r0, r0
    c202:	e009      	b.n	c218 <ble_ll_conn_calc_used_chans+0x2c>

    used_channels = 0;
    for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; ++i) {
        chanbyte = chmap[i];
        if (chanbyte) {
            if (chanbyte == 0xff) {
    c204:	2408      	movs	r4, #8
    c206:	2301      	movs	r3, #1
                used_channels += 8;
            } else {
                mask = 0x01;
                for (j = 0; j < 8; ++j) {
                    if (chanbyte & mask) {
    c208:	422b      	tst	r3, r5
                        ++used_channels;
    c20a:	bf1c      	itt	ne
    c20c:	3001      	addne	r0, #1
    c20e:	b2c0      	uxtbne	r0, r0
                    }
                    mask <<= 1;
    c210:	005b      	lsls	r3, r3, #1
        if (chanbyte) {
            if (chanbyte == 0xff) {
                used_channels += 8;
            } else {
                mask = 0x01;
                for (j = 0; j < 8; ++j) {
    c212:	3c01      	subs	r4, #1
                    if (chanbyte & mask) {
                        ++used_channels;
                    }
                    mask <<= 1;
    c214:	b2db      	uxtb	r3, r3
        if (chanbyte) {
            if (chanbyte == 0xff) {
                used_channels += 8;
            } else {
                mask = 0x01;
                for (j = 0; j < 8; ++j) {
    c216:	d1f7      	bne.n	c208 <ble_ll_conn_calc_used_chans+0x1c>
    uint8_t mask;
    uint8_t chanbyte;
    uint8_t used_channels;

    used_channels = 0;
    for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; ++i) {
    c218:	4291      	cmp	r1, r2
    c21a:	d1eb      	bne.n	c1f4 <ble_ll_conn_calc_used_chans+0x8>
                }
            }
        }
    }
    return used_channels;
}
    c21c:	bd30      	pop	{r4, r5, pc}

0000c21e <ble_ll_conn_calc_dci>:
 *
 * @return uint8_t
 */
uint8_t
ble_ll_conn_calc_dci(struct ble_ll_conn_sm *conn)
{
    c21e:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t cntr;
    uint8_t mask;
    uint8_t usable_chans;

    /* Get next unmapped channel */
    curchan = conn->last_unmapped_chan + conn->hop_inc;
    c220:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
    c224:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
    c228:	4413      	add	r3, r2
    c22a:	b2db      	uxtb	r3, r3
    if (curchan > BLE_PHY_NUM_DATA_CHANS) {
    c22c:	2b25      	cmp	r3, #37	; 0x25
        curchan -= BLE_PHY_NUM_DATA_CHANS;
    c22e:	bf84      	itt	hi
    c230:	3b25      	subhi	r3, #37	; 0x25
    c232:	b2db      	uxtbhi	r3, r3

    /* Set the current unmapped channel */
    conn->unmapped_chan = curchan;

    /* Is this a valid channel? */
    bitpos = 1 << (curchan & 0x07);
    c234:	f003 0107 	and.w	r1, r3, #7
    c238:	2201      	movs	r2, #1
    c23a:	408a      	lsls	r2, r1
    if ((conn->chanmap[curchan >> 3] & bitpos) == 0) {
    c23c:	eb00 01d3 	add.w	r1, r0, r3, lsr #3
    if (curchan > BLE_PHY_NUM_DATA_CHANS) {
        curchan -= BLE_PHY_NUM_DATA_CHANS;
    }

    /* Set the current unmapped channel */
    conn->unmapped_chan = curchan;
    c240:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28

    /* Is this a valid channel? */
    bitpos = 1 << (curchan & 0x07);
    if ((conn->chanmap[curchan >> 3] & bitpos) == 0) {
    c244:	7e89      	ldrb	r1, [r1, #26]
    c246:	400a      	ands	r2, r1
    c248:	d123      	bne.n	c292 <ble_ll_conn_calc_dci+0x74>

        /* Calculate remap index */
        remap_index = curchan % conn->num_used_chans;
    c24a:	f890 402a 	ldrb.w	r4, [r0, #42]	; 0x2a
    c24e:	fbb3 f1f4 	udiv	r1, r3, r4
    c252:	fb04 3411 	mls	r4, r4, r1, r3
    c256:	b2e4      	uxtb	r4, r4
    c258:	3019      	adds	r0, #25
        /* NOTE: possible to build a map but this would use memory. For now,
           we just calculate */
        /* Iterate through channel map to find this channel */
        chan = 0;
        cntr = 0;
        for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; i++) {
    c25a:	4616      	mov	r6, r2
            usable_chans = conn->chanmap[i];
    c25c:	f810 ef01 	ldrb.w	lr, [r0, #1]!
    c260:	00f7      	lsls	r7, r6, #3
    c262:	b2ff      	uxtb	r7, r7
            if (usable_chans != 0) {
    c264:	f1be 0f00 	cmp.w	lr, #0
    c268:	d010      	beq.n	c28c <ble_ll_conn_calc_dci+0x6e>
    c26a:	2501      	movs	r5, #1
    c26c:	2100      	movs	r1, #0
                mask = 0x01;
                for (j = 0; j < 8; j++) {
                    if (usable_chans & mask) {
    c26e:	ea15 0f0e 	tst.w	r5, lr
    c272:	d006      	beq.n	c282 <ble_ll_conn_calc_dci+0x64>
                        if (cntr == remap_index) {
    c274:	42a2      	cmp	r2, r4
    c276:	d102      	bne.n	c27e <ble_ll_conn_calc_dci+0x60>
                            return (chan + j);
    c278:	187b      	adds	r3, r7, r1
    c27a:	b2d8      	uxtb	r0, r3
    c27c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        }
                        ++cntr;
    c27e:	3201      	adds	r2, #1
    c280:	b2d2      	uxtb	r2, r2
        cntr = 0;
        for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; i++) {
            usable_chans = conn->chanmap[i];
            if (usable_chans != 0) {
                mask = 0x01;
                for (j = 0; j < 8; j++) {
    c282:	3101      	adds	r1, #1
                        if (cntr == remap_index) {
                            return (chan + j);
                        }
                        ++cntr;
                    }
                    mask <<= 1;
    c284:	006d      	lsls	r5, r5, #1
        cntr = 0;
        for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; i++) {
            usable_chans = conn->chanmap[i];
            if (usable_chans != 0) {
                mask = 0x01;
                for (j = 0; j < 8; j++) {
    c286:	2908      	cmp	r1, #8
                        if (cntr == remap_index) {
                            return (chan + j);
                        }
                        ++cntr;
                    }
                    mask <<= 1;
    c288:	b2ed      	uxtb	r5, r5
        cntr = 0;
        for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; i++) {
            usable_chans = conn->chanmap[i];
            if (usable_chans != 0) {
                mask = 0x01;
                for (j = 0; j < 8; j++) {
    c28a:	d1f0      	bne.n	c26e <ble_ll_conn_calc_dci+0x50>
        /* NOTE: possible to build a map but this would use memory. For now,
           we just calculate */
        /* Iterate through channel map to find this channel */
        chan = 0;
        cntr = 0;
        for (i = 0; i < BLE_LL_CONN_CHMAP_LEN; i++) {
    c28c:	3601      	adds	r6, #1
    c28e:	2e05      	cmp	r6, #5
    c290:	d1e4      	bne.n	c25c <ble_ll_conn_calc_dci+0x3e>
            }
            chan += 8;
        }
    }

    return curchan;
    c292:	4618      	mov	r0, r3
}
    c294:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000c296 <ble_ll_conn_next_event>:
 *
 * @return int
 */
static int
ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
{
    c296:	b570      	push	{r4, r5, r6, lr}
    c298:	4604      	mov	r4, r0
    uint32_t cur_ww;
    uint32_t max_ww;
    struct ble_ll_conn_upd_req *upd;

    /* XXX: deal with connection request procedure here as well */
    ble_ll_conn_chk_csm_flags(connsm);
    c29a:	f7ff ff2f 	bl	c0fc <ble_ll_conn_chk_csm_flags>

    /* Set event counter to the next connection event that we will tx/rx in */
    itvl = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    c29e:	f8b4 0060 	ldrh.w	r0, [r4, #96]	; 0x60
    c2a2:	f240 43e2 	movw	r3, #1250	; 0x4e2
    c2a6:	4358      	muls	r0, r3
    latency = 1;
    if (connsm->csmflags.cfbit.allow_slave_latency      &&
        !connsm->csmflags.cfbit.conn_update_sched       &&
    c2a8:	8823      	ldrh	r3, [r4, #0]
    ble_ll_conn_chk_csm_flags(connsm);

    /* Set event counter to the next connection event that we will tx/rx in */
    itvl = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    latency = 1;
    if (connsm->csmflags.cfbit.allow_slave_latency      &&
    c2aa:	f423 63ee 	bic.w	r3, r3, #1904	; 0x770
    c2ae:	f023 0307 	bic.w	r3, r3, #7
    c2b2:	051b      	lsls	r3, r3, #20
    c2b4:	0d1b      	lsrs	r3, r3, #20
    c2b6:	2b08      	cmp	r3, #8
    c2b8:	d108      	bne.n	c2cc <ble_ll_conn_next_event+0x36>
        !connsm->csmflags.cfbit.conn_update_sched       &&
        !connsm->csmflags.cfbit.chanmap_update_scheduled) {
        if (connsm->csmflags.cfbit.pkt_rxd) {
    c2ba:	7823      	ldrb	r3, [r4, #0]
    c2bc:	07dd      	lsls	r5, r3, #31
    c2be:	d505      	bpl.n	c2cc <ble_ll_conn_next_event+0x36>
            latency += connsm->slave_latency;
    c2c0:	f8b4 5062 	ldrh.w	r5, [r4, #98]	; 0x62
    c2c4:	3501      	adds	r5, #1
    c2c6:	b2ad      	uxth	r5, r5
            itvl = itvl * latency;
    c2c8:	4368      	muls	r0, r5
    c2ca:	e000      	b.n	c2ce <ble_ll_conn_next_event+0x38>
    /* XXX: deal with connection request procedure here as well */
    ble_ll_conn_chk_csm_flags(connsm);

    /* Set event counter to the next connection event that we will tx/rx in */
    itvl = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    latency = 1;
    c2cc:	2501      	movs	r5, #1
        if (connsm->csmflags.cfbit.pkt_rxd) {
            latency += connsm->slave_latency;
            itvl = itvl * latency;
        }
    }
    connsm->event_cntr += latency;
    c2ce:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    c2d0:	442b      	add	r3, r5
    c2d2:	87e3      	strh	r3, [r4, #62]	; 0x3e

    /* Set next connection event start time */
    connsm->anchor_point += cputime_usecs_to_ticks(itvl);
    c2d4:	f7fc fcee 	bl	8cb4 <cputime_usecs_to_ticks>
    c2d8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    c2da:	4418      	add	r0, r3
     * If a connection update has been scheduled and the event counter
     * is now equal to the instant, we need to adjust the start of the
     * connection by the the transmit window offset. We also copy in the
     * update parameters as they now should take effect.
     */
    if (connsm->csmflags.cfbit.conn_update_sched &&
    c2dc:	7823      	ldrb	r3, [r4, #0]
        }
    }
    connsm->event_cntr += latency;

    /* Set next connection event start time */
    connsm->anchor_point += cputime_usecs_to_ticks(itvl);
    c2de:	66e0      	str	r0, [r4, #108]	; 0x6c
     * If a connection update has been scheduled and the event counter
     * is now equal to the instant, we need to adjust the start of the
     * connection by the the transmit window offset. We also copy in the
     * update parameters as they now should take effect.
     */
    if (connsm->csmflags.cfbit.conn_update_sched &&
    c2e0:	0619      	lsls	r1, r3, #24
    c2e2:	d550      	bpl.n	c386 <ble_ll_conn_next_event+0xf0>
    c2e4:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    c2e6:	f8b4 3180 	ldrh.w	r3, [r4, #384]	; 0x180
    c2ea:	429a      	cmp	r2, r3
    c2ec:	d14b      	bne.n	c386 <ble_ll_conn_next_event+0xf0>
        (connsm->event_cntr == connsm->conn_update_req.instant)) {

        /* Set flag so we send connection update event */
        upd = &connsm->conn_update_req;
        if ((connsm->conn_role == BLE_LL_CONN_ROLE_MASTER)  ||
    c2ee:	79e3      	ldrb	r3, [r4, #7]
    c2f0:	2b01      	cmp	r3, #1
    c2f2:	d011      	beq.n	c318 <ble_ll_conn_next_event+0x82>
    c2f4:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    c2f8:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    c2fc:	429a      	cmp	r2, r3
    c2fe:	d10b      	bne.n	c318 <ble_ll_conn_next_event+0x82>
            (connsm->conn_itvl != upd->interval)            ||
    c300:	f8b4 2062 	ldrh.w	r2, [r4, #98]	; 0x62
    c304:	f8b4 317c 	ldrh.w	r3, [r4, #380]	; 0x17c
    c308:	429a      	cmp	r2, r3
    c30a:	d105      	bne.n	c318 <ble_ll_conn_next_event+0x82>
            (connsm->slave_latency != upd->latency)         ||
    c30c:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
    c310:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
    c314:	429a      	cmp	r2, r3
    c316:	d003      	beq.n	c320 <ble_ll_conn_next_event+0x8a>
            (connsm->supervision_tmo != upd->timeout)) {
            connsm->csmflags.cfbit.host_expects_upd_event = 1;
    c318:	7863      	ldrb	r3, [r4, #1]
    c31a:	f043 0301 	orr.w	r3, r3, #1
    c31e:	7063      	strb	r3, [r4, #1]
        }

        connsm->conn_itvl = upd->interval;
    c320:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    c324:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        connsm->supervision_tmo = upd->timeout;
    c328:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
    c32c:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
        connsm->slave_latency = upd->latency;
    c330:	f8b4 317c 	ldrh.w	r3, [r4, #380]	; 0x17c
    c334:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
        connsm->tx_win_size = upd->winsize;
    c338:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
    c33c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        connsm->slave_cur_tx_win_usecs =
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
    c340:	f240 40e2 	movw	r0, #1250	; 0x4e2
    c344:	4343      	muls	r3, r0

        connsm->conn_itvl = upd->interval;
        connsm->supervision_tmo = upd->timeout;
        connsm->slave_latency = upd->latency;
        connsm->tx_win_size = upd->winsize;
        connsm->slave_cur_tx_win_usecs =
    c346:	6763      	str	r3, [r4, #116]	; 0x74
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
        connsm->tx_win_off = upd->winoffset;
    c348:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    c34c:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
        connsm->anchor_point +=
            cputime_usecs_to_ticks(upd->winoffset * BLE_LL_CONN_ITVL_USECS);
    c350:	4358      	muls	r0, r3
    c352:	f7fc fcaf 	bl	8cb4 <cputime_usecs_to_ticks>
        connsm->slave_latency = upd->latency;
        connsm->tx_win_size = upd->winsize;
        connsm->slave_cur_tx_win_usecs =
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
        connsm->tx_win_off = upd->winoffset;
        connsm->anchor_point +=
    c356:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
            cputime_usecs_to_ticks(upd->winoffset * BLE_LL_CONN_ITVL_USECS);

        /* Reset the connection supervision timeout */
        cputime_timer_stop(&connsm->conn_spvn_timer);
    c358:	f104 0684 	add.w	r6, r4, #132	; 0x84
        connsm->slave_latency = upd->latency;
        connsm->tx_win_size = upd->winsize;
        connsm->slave_cur_tx_win_usecs =
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
        connsm->tx_win_off = upd->winoffset;
        connsm->anchor_point +=
    c35c:	4418      	add	r0, r3
    c35e:	66e0      	str	r0, [r4, #108]	; 0x6c
            cputime_usecs_to_ticks(upd->winoffset * BLE_LL_CONN_ITVL_USECS);

        /* Reset the connection supervision timeout */
        cputime_timer_stop(&connsm->conn_spvn_timer);
    c360:	4630      	mov	r0, r6
    c362:	f7fc fd2d 	bl	8dc0 <cputime_timer_stop>
        tmo = connsm->supervision_tmo;
    c366:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
        tmo = tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
        tmo = cputime_usecs_to_ticks(tmo);
    c36a:	f242 7010 	movw	r0, #10000	; 0x2710
    c36e:	4358      	muls	r0, r3
    c370:	f7fc fca0 	bl	8cb4 <cputime_usecs_to_ticks>
        cputime_timer_start(&connsm->conn_spvn_timer, connsm->anchor_point+tmo);
    c374:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    c376:	4401      	add	r1, r0
    c378:	4630      	mov	r0, r6
    c37a:	f7fc fcc1 	bl	8d00 <cputime_timer_start>

        /* Reset update scheduled flag */
        connsm->csmflags.cfbit.conn_update_sched = 0;
    c37e:	7823      	ldrb	r3, [r4, #0]
    c380:	f36f 13c7 	bfc	r3, #7, #1
    c384:	7023      	strb	r3, [r4, #0]
     * counter, when we get here the event counter has already been
     * incremented by 1. That is why we do a signed comparison and change to
     * new channel map once the event counter equals or has passed channel
     * map update instant.
     */
    if (connsm->csmflags.cfbit.chanmap_update_scheduled &&
    c386:	7863      	ldrb	r3, [r4, #1]
    c388:	071a      	lsls	r2, r3, #28
    c38a:	d51b      	bpl.n	c3c4 <ble_ll_conn_next_event+0x12e>
        ((int16_t)(connsm->chanmap_instant - connsm->event_cntr) <= 0)) {
    c38c:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
    c38e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    c390:	1a9b      	subs	r3, r3, r2
     * counter, when we get here the event counter has already been
     * incremented by 1. That is why we do a signed comparison and change to
     * new channel map once the event counter equals or has passed channel
     * map update instant.
     */
    if (connsm->csmflags.cfbit.chanmap_update_scheduled &&
    c392:	b21b      	sxth	r3, r3
    c394:	2b00      	cmp	r3, #0
    c396:	dc15      	bgt.n	c3c4 <ble_ll_conn_next_event+0x12e>
        /* XXX: there is a chance that the control packet is still on
         * the queue of the master. This means that we never successfully
         * transmitted update request. Would end up killing connection
           on slave side. Could ignore it or see if still enqueued. */
        connsm->num_used_chans =
            ble_ll_conn_calc_used_chans(connsm->req_chanmap);
    c398:	f104 061f 	add.w	r6, r4, #31
    c39c:	4630      	mov	r0, r6
    c39e:	f7ff ff25 	bl	c1ec <ble_ll_conn_calc_used_chans>
        memcpy(connsm->chanmap, connsm->req_chanmap, BLE_LL_CONN_CHMAP_LEN);
    c3a2:	f8d4 301f 	ldr.w	r3, [r4, #31]
    c3a6:	f8c4 301a 	str.w	r3, [r4, #26]
    c3aa:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    c3ae:	77a3      	strb	r3, [r4, #30]

        connsm->csmflags.cfbit.chanmap_update_scheduled = 0;
    c3b0:	7863      	ldrb	r3, [r4, #1]

        /* XXX: there is a chance that the control packet is still on
         * the queue of the master. This means that we never successfully
         * transmitted update request. Would end up killing connection
           on slave side. Could ignore it or see if still enqueued. */
        connsm->num_used_chans =
    c3b2:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
            ble_ll_conn_calc_used_chans(connsm->req_chanmap);
        memcpy(connsm->chanmap, connsm->req_chanmap, BLE_LL_CONN_CHMAP_LEN);

        connsm->csmflags.cfbit.chanmap_update_scheduled = 0;
    c3b6:	f36f 03c3 	bfc	r3, #3, #1
    c3ba:	7063      	strb	r3, [r4, #1]

        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CHAN_MAP_UPD);
    c3bc:	4620      	mov	r0, r4
    c3be:	2101      	movs	r1, #1
    c3c0:	f002 f8c8 	bl	e554 <ble_ll_ctrl_proc_stop>
        /* XXX: host could have resent channel map command. Need to
           check to make sure we dont have to restart! */
    }

    /* Calculate data channel index of next connection event */
    while (latency > 0) {
    c3c4:	b15d      	cbz	r5, c3de <ble_ll_conn_next_event+0x148>
        connsm->last_unmapped_chan = connsm->unmapped_chan;
    c3c6:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    c3ca:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
        connsm->data_chan_index = ble_ll_conn_calc_dci(connsm);
    c3ce:	4620      	mov	r0, r4
    c3d0:	f7ff ff25 	bl	c21e <ble_ll_conn_calc_dci>
        --latency;
    c3d4:	3d01      	subs	r5, #1
    }

    /* Calculate data channel index of next connection event */
    while (latency > 0) {
        connsm->last_unmapped_chan = connsm->unmapped_chan;
        connsm->data_chan_index = ble_ll_conn_calc_dci(connsm);
    c3d6:	f884 0027 	strb.w	r0, [r4, #39]	; 0x27
        --latency;
    c3da:	b2ad      	uxth	r5, r5
    c3dc:	e7f2      	b.n	c3c4 <ble_ll_conn_next_event+0x12e>
    /*
     * If we are trying to terminate connection, check if next wake time is
     * passed the termination timeout. If so, no need to continue with
     * connection as we will time out anyway.
     */
    if (connsm->pending_ctrl_procs & (1 << BLE_LL_CTRL_PROC_TERMINATE)) {
    c3de:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    c3e0:	069b      	lsls	r3, r3, #26
    c3e2:	d507      	bpl.n	c3f4 <ble_ll_conn_next_event+0x15e>
        if ((int32_t)(connsm->terminate_timeout - connsm->anchor_point) <= 0) {
    c3e4:	6d63      	ldr	r3, [r4, #84]	; 0x54
    c3e6:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    c3e8:	1a9b      	subs	r3, r3, r2
    c3ea:	2b00      	cmp	r3, #0
    c3ec:	dc02      	bgt.n	c3f4 <ble_ll_conn_next_event+0x15e>
            return -1;
    c3ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c3f2:	bd70      	pop	{r4, r5, r6, pc}
    /*
     * Calculate ce end time. For a slave, we need to add window widening and
     * the transmit window if we still have one.
     */
    itvl = NIMBLE_OPT_LL_CONN_INIT_SLOTS * BLE_LL_SCHED_USECS_PER_SLOT;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    c3f4:	79e3      	ldrb	r3, [r4, #7]
    c3f6:	2b02      	cmp	r3, #2
    c3f8:	d110      	bne.n	c41c <ble_ll_conn_next_event+0x186>
        cur_ww = ble_ll_conn_calc_window_widening(connsm);
    c3fa:	4620      	mov	r0, r4
    c3fc:	f7ff feda 	bl	c1b4 <ble_ll_conn_calc_window_widening>
        max_ww = (connsm->conn_itvl * (BLE_LL_CONN_ITVL_USECS/2)) - BLE_LL_IFS;
    c400:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    c404:	f240 2371 	movw	r3, #625	; 0x271
    c408:	4353      	muls	r3, r2
    c40a:	3b96      	subs	r3, #150	; 0x96
        if (cur_ww >= max_ww) {
    c40c:	4298      	cmp	r0, r3
    c40e:	d2ee      	bcs.n	c3ee <ble_ll_conn_next_event+0x158>
    c410:	6f63      	ldr	r3, [r4, #116]	; 0x74
            return -1;
        }
        connsm->slave_cur_window_widening = cur_ww;
    c412:	67a0      	str	r0, [r4, #120]	; 0x78
    c414:	f603 13c4 	addw	r3, r3, #2500	; 0x9c4
        itvl += cur_ww + connsm->slave_cur_tx_win_usecs;
    c418:	4418      	add	r0, r3
    c41a:	e001      	b.n	c420 <ble_ll_conn_next_event+0x18a>
    } else {
        /* We adjust end time for connection to end of time slot */
        itvl -= XCVR_TX_SCHED_DELAY_USECS;
    c41c:	f640 1006 	movw	r0, #2310	; 0x906
    }
    connsm->ce_end_time = connsm->anchor_point + cputime_usecs_to_ticks(itvl);
    c420:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    c422:	f7fc fc47 	bl	8cb4 <cputime_usecs_to_ticks>
    c426:	4428      	add	r0, r5
    c428:	6520      	str	r0, [r4, #80]	; 0x50

    return 0;
    c42a:	2000      	movs	r0, #0
}
    c42c:	bd70      	pop	{r4, r5, r6, pc}
	...

0000c430 <ble_ll_conn_created>:
 *
 * @ return 0: connection NOT created. 1: connection created
 */
static int
ble_ll_conn_created(struct ble_ll_conn_sm *connsm, uint32_t endtime)
{
    c430:	b538      	push	{r3, r4, r5, lr}
    int rc;
    uint32_t usecs;

    /* Set state to created */
    connsm->conn_state = BLE_LL_CONN_STATE_CREATED;
    c432:	2301      	movs	r3, #1
    c434:	7183      	strb	r3, [r0, #6]

    /* Set supervision timeout */
    usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS * 6;
    c436:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
 *
 * @ return 0: connection NOT created. 1: connection created
 */
static int
ble_ll_conn_created(struct ble_ll_conn_sm *connsm, uint32_t endtime)
{
    c43a:	4604      	mov	r4, r0
    c43c:	460d      	mov	r5, r1
    /* Set state to created */
    connsm->conn_state = BLE_LL_CONN_STATE_CREATED;

    /* Set supervision timeout */
    usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS * 6;
    cputime_timer_relative(&connsm->conn_spvn_timer, usecs);
    c43e:	f641 514c 	movw	r1, #7500	; 0x1d4c
    c442:	4359      	muls	r1, r3
    c444:	3084      	adds	r0, #132	; 0x84
    c446:	f7fc fca1 	bl	8d8c <cputime_timer_relative>

    /* Clear packet received flag */
    connsm->csmflags.cfbit.pkt_rxd = 0;
    c44a:	7823      	ldrb	r3, [r4, #0]
    c44c:	f36f 0300 	bfc	r3, #0, #1
    c450:	7023      	strb	r3, [r4, #0]

    /* Consider time created the last scheduled time */
    connsm->last_scheduled = cputime_get32();
    c452:	f7fc fd73 	bl	8f3c <cputime_get32>
     * time of the connect request. The actual connection starts 1.25 msecs plus
     * the transmit window offset from the end of the connection request.
     */
    rc = 1;
    connsm->last_anchor_point = endtime;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    c456:	79e3      	ldrb	r3, [r4, #7]

    /* Clear packet received flag */
    connsm->csmflags.cfbit.pkt_rxd = 0;

    /* Consider time created the last scheduled time */
    connsm->last_scheduled = cputime_get32();
    c458:	65a0      	str	r0, [r4, #88]	; 0x58
     * time of the connect request. The actual connection starts 1.25 msecs plus
     * the transmit window offset from the end of the connection request.
     */
    rc = 1;
    connsm->last_anchor_point = endtime;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    c45a:	2b02      	cmp	r3, #2
     * Set first connection event time. If slave the endtime is the receive end
     * time of the connect request. The actual connection starts 1.25 msecs plus
     * the transmit window offset from the end of the connection request.
     */
    rc = 1;
    connsm->last_anchor_point = endtime;
    c45c:	6725      	str	r5, [r4, #112]	; 0x70
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    c45e:	d125      	bne.n	c4ac <ble_ll_conn_created+0x7c>
        connsm->slave_cur_tx_win_usecs =
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
    c460:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    c464:	f240 40e2 	movw	r0, #1250	; 0x4e2
    c468:	4343      	muls	r3, r0
     * the transmit window offset from the end of the connection request.
     */
    rc = 1;
    connsm->last_anchor_point = endtime;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
        connsm->slave_cur_tx_win_usecs =
    c46a:	6763      	str	r3, [r4, #116]	; 0x74
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
        usecs = 1250 + (connsm->tx_win_off * BLE_LL_CONN_TX_WIN_USECS);
    c46c:	f8b4 306a 	ldrh.w	r3, [r4, #106]	; 0x6a
        connsm->anchor_point = endtime + cputime_usecs_to_ticks(usecs);
    c470:	fb03 0000 	mla	r0, r3, r0, r0
    c474:	f7fc fc1e 	bl	8cb4 <cputime_usecs_to_ticks>
    c478:	4405      	add	r5, r0
        usecs = connsm->slave_cur_tx_win_usecs +
    c47a:	6f60      	ldr	r0, [r4, #116]	; 0x74
    connsm->last_anchor_point = endtime;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
        connsm->slave_cur_tx_win_usecs =
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
        usecs = 1250 + (connsm->tx_win_off * BLE_LL_CONN_TX_WIN_USECS);
        connsm->anchor_point = endtime + cputime_usecs_to_ticks(usecs);
    c47c:	66e5      	str	r5, [r4, #108]	; 0x6c
        usecs = connsm->slave_cur_tx_win_usecs +
            (NIMBLE_OPT_LL_CONN_INIT_SLOTS * BLE_LL_SCHED_USECS_PER_SLOT);
        connsm->ce_end_time = connsm->anchor_point +
            cputime_usecs_to_ticks(usecs);
    c47e:	f600 10c4 	addw	r0, r0, #2500	; 0x9c4
    c482:	f7fc fc17 	bl	8cb4 <cputime_usecs_to_ticks>
        connsm->slave_cur_window_widening = 0;
    c486:	2300      	movs	r3, #0
            connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
        usecs = 1250 + (connsm->tx_win_off * BLE_LL_CONN_TX_WIN_USECS);
        connsm->anchor_point = endtime + cputime_usecs_to_ticks(usecs);
        usecs = connsm->slave_cur_tx_win_usecs +
            (NIMBLE_OPT_LL_CONN_INIT_SLOTS * BLE_LL_SCHED_USECS_PER_SLOT);
        connsm->ce_end_time = connsm->anchor_point +
    c488:	4428      	add	r0, r5
    c48a:	6520      	str	r0, [r4, #80]	; 0x50
            cputime_usecs_to_ticks(usecs);
        connsm->slave_cur_window_widening = 0;
    c48c:	67a3      	str	r3, [r4, #120]	; 0x78

        /* Start the scheduler for the first connection event */
        while (ble_ll_sched_slave_new(connsm)) {
    c48e:	4620      	mov	r0, r4
    c490:	f004 f94e 	bl	10730 <ble_ll_sched_slave_new>
    c494:	b150      	cbz	r0, c4ac <ble_ll_conn_created+0x7c>
            if (ble_ll_conn_next_event(connsm)) {
    c496:	4620      	mov	r0, r4
    c498:	f7ff fefd 	bl	c296 <ble_ll_conn_next_event>
    c49c:	2800      	cmp	r0, #0
    c49e:	d0f6      	beq.n	c48e <ble_ll_conn_created+0x5e>
                STATS_INC(ble_ll_conn_stats, cant_set_sched);
    c4a0:	4a10      	ldr	r2, [pc, #64]	; (c4e4 <ble_ll_conn_created+0xb4>)
    c4a2:	68d3      	ldr	r3, [r2, #12]
    c4a4:	3301      	adds	r3, #1
    c4a6:	60d3      	str	r3, [r2, #12]
                rc = 0;
    c4a8:	2000      	movs	r0, #0
    c4aa:	bd38      	pop	{r3, r4, r5, pc}
    if (rc) {
        /*
         * Section 4.5.10 Vol 6 PART B. If the max tx/rx time or octets
         * exceeds the minimum, data length procedure needs to occur
         */
        if ((connsm->max_tx_octets > BLE_LL_CONN_SUPP_BYTES_MIN) ||
    c4ac:	7a23      	ldrb	r3, [r4, #8]
    c4ae:	2b1b      	cmp	r3, #27
    c4b0:	d80a      	bhi.n	c4c8 <ble_ll_conn_created+0x98>
    c4b2:	7a63      	ldrb	r3, [r4, #9]
    c4b4:	2b1b      	cmp	r3, #27
    c4b6:	d807      	bhi.n	c4c8 <ble_ll_conn_created+0x98>
            (connsm->max_rx_octets > BLE_LL_CONN_SUPP_BYTES_MIN) ||
    c4b8:	89e3      	ldrh	r3, [r4, #14]
    c4ba:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
    c4be:	d803      	bhi.n	c4c8 <ble_ll_conn_created+0x98>
            (connsm->max_tx_time > BLE_LL_CONN_SUPP_TIME_MIN) ||
    c4c0:	8a23      	ldrh	r3, [r4, #16]
    c4c2:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
    c4c6:	d907      	bls.n	c4d8 <ble_ll_conn_created+0xa8>
            (connsm->max_rx_time > BLE_LL_CONN_SUPP_TIME_MIN)) {
            /* Start the data length update procedure */
            if (ble_ll_read_supp_features() & BLE_LL_FEAT_DATA_LEN_EXT) {
    c4c8:	f7fe fe24 	bl	b114 <ble_ll_read_supp_features>
    c4cc:	0683      	lsls	r3, r0, #26
    c4ce:	d503      	bpl.n	c4d8 <ble_ll_conn_created+0xa8>
                ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
    c4d0:	4620      	mov	r0, r4
    c4d2:	2108      	movs	r1, #8
    c4d4:	f001 ffe4 	bl	e4a0 <ble_ll_ctrl_proc_start>
            }
        }
        ble_ll_conn_comp_event_send(connsm, BLE_ERR_SUCCESS);
    c4d8:	4620      	mov	r0, r4
    c4da:	2100      	movs	r1, #0
    c4dc:	f001 f810 	bl	d500 <ble_ll_conn_comp_event_send>
    c4e0:	2001      	movs	r0, #1
    c4e2:	bd38      	pop	{r3, r4, r5, pc}
    c4e4:	20003580 	.word	0x20003580

0000c4e8 <ble_ll_conn_wfr_timer_exp>:
void
ble_ll_conn_wfr_timer_exp(void)
{
    struct ble_ll_conn_sm *connsm;

    connsm = g_ble_ll_conn_cur_sm;
    c4e8:	4b07      	ldr	r3, [pc, #28]	; (c508 <ble_ll_conn_wfr_timer_exp+0x20>)
 *
 * Context: Interrupt
 */
void
ble_ll_conn_wfr_timer_exp(void)
{
    c4ea:	b510      	push	{r4, lr}
    struct ble_ll_conn_sm *connsm;

    connsm = g_ble_ll_conn_cur_sm;
    c4ec:	681c      	ldr	r4, [r3, #0]
    ble_ll_conn_current_sm_over();
    c4ee:	f7ff fb4b 	bl	bb88 <ble_ll_conn_current_sm_over>
    if (connsm) {
    c4f2:	b13c      	cbz	r4, c504 <ble_ll_conn_wfr_timer_exp+0x1c>
        ble_ll_event_send(&connsm->conn_ev_end);
    c4f4:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
    c4f8:	f7fe fe00 	bl	b0fc <ble_ll_event_send>
        STATS_INC(ble_ll_conn_stats, wfr_expirations);
    c4fc:	4a03      	ldr	r2, [pc, #12]	; (c50c <ble_ll_conn_wfr_timer_exp+0x24>)
    c4fe:	6953      	ldr	r3, [r2, #20]
    c500:	3301      	adds	r3, #1
    c502:	6153      	str	r3, [r2, #20]
    c504:	bd10      	pop	{r4, pc}
    c506:	bf00      	nop
    c508:	200033cc 	.word	0x200033cc
    c50c:	20003580 	.word	0x20003580

0000c510 <ble_ll_conn_auth_pyld_timer_start>:
ble_ll_conn_auth_pyld_timer_start(struct ble_ll_conn_sm *connsm)
{
    int32_t tmo;

    /* Timeout in is in 10 msec units */
    tmo = (int32_t)BLE_LL_CONN_AUTH_PYLD_OS_TMO(connsm->auth_pyld_tmo);
    c510:	f8b0 1046 	ldrh.w	r1, [r0, #70]	; 0x46
    c514:	f44f 63a0 	mov.w	r3, #1280	; 0x500
    c518:	434b      	muls	r3, r1
    os_callout_reset(&connsm->auth_pyld_timer.cf_c, tmo);
    c51a:	30fc      	adds	r0, #252	; 0xfc
    c51c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    c520:	fbb3 f1f1 	udiv	r1, r3, r1
    c524:	f7fd baec 	b.w	9b00 <os_callout_reset>

0000c528 <ble_ll_conn_auth_pyld_timer_cb>:
 *
 * @param arg
 */
void
ble_ll_conn_auth_pyld_timer_cb(void *arg)
{
    c528:	b510      	push	{r4, lr}
    c52a:	4604      	mov	r4, r0
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    ble_ll_auth_pyld_tmo_event_send(connsm);
    c52c:	f001 f8d8 	bl	d6e0 <ble_ll_auth_pyld_tmo_event_send>
    ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_LE_PING);
    c530:	4620      	mov	r0, r4
    c532:	2107      	movs	r1, #7
    c534:	f001 ffb4 	bl	e4a0 <ble_ll_ctrl_proc_start>
    ble_ll_conn_auth_pyld_timer_start(connsm);
    c538:	4620      	mov	r0, r4
}
    c53a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    struct ble_ll_conn_sm *connsm;

    connsm = (struct ble_ll_conn_sm *)arg;
    ble_ll_auth_pyld_tmo_event_send(connsm);
    ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_LE_PING);
    ble_ll_conn_auth_pyld_timer_start(connsm);
    c53e:	f7ff bfe7 	b.w	c510 <ble_ll_conn_auth_pyld_timer_start>
	...

0000c544 <ble_ll_conn_master_init>:
void
ble_ll_conn_master_init(struct ble_ll_conn_sm *connsm,
                        struct hci_create_conn *hcc)
{
    /* Set master role */
    connsm->conn_role = BLE_LL_CONN_ROLE_MASTER;
    c544:	2301      	movs	r3, #1
 * @param hcc
 */
void
ble_ll_conn_master_init(struct ble_ll_conn_sm *connsm,
                        struct hci_create_conn *hcc)
{
    c546:	b570      	push	{r4, r5, r6, lr}
    /* Set master role */
    connsm->conn_role = BLE_LL_CONN_ROLE_MASTER;
    c548:	71c3      	strb	r3, [r0, #7]

    /* Set default ce parameters */
    connsm->tx_win_size = BLE_LL_CONN_TX_WIN_MIN;
    c54a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    connsm->tx_win_off = 0;
    c54e:	2300      	movs	r3, #0
    c550:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
    connsm->master_sca = NIMBLE_OPT_LL_MASTER_SCA;
    c554:	2304      	movs	r3, #4
    c556:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
 * @param hcc
 */
void
ble_ll_conn_master_init(struct ble_ll_conn_sm *connsm,
                        struct hci_create_conn *hcc)
{
    c55a:	4604      	mov	r4, r0
    c55c:	460d      	mov	r5, r1
    c55e:	f7fc fd37 	bl	8fd0 <lrand48>
    connsm->tx_win_size = BLE_LL_CONN_TX_WIN_MIN;
    connsm->tx_win_off = 0;
    connsm->master_sca = NIMBLE_OPT_LL_MASTER_SCA;

    /* Hop increment is a random value between 5 and 16. */
    connsm->hop_inc = (rand() % 12) + 5;
    c562:	230c      	movs	r3, #12
    c564:	fb90 f2f3 	sdiv	r2, r0, r3
    c568:	fb02 0013 	mls	r0, r2, r3, r0
    c56c:	3005      	adds	r0, #5
    c56e:	f884 0026 	strb.w	r0, [r4, #38]	; 0x26

    /* Set slave latency and supervision timeout */
    connsm->slave_latency = hcc->conn_latency;
    c572:	8a6b      	ldrh	r3, [r5, #18]
    c574:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
    connsm->supervision_tmo = hcc->supervision_timeout;
    c578:	8aab      	ldrh	r3, [r5, #20]
    c57a:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64

    /* Set own address type and peer address if needed */
    connsm->own_addr_type = hcc->own_addr_type;
    c57e:	7b2b      	ldrb	r3, [r5, #12]
    c580:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    if (hcc->filter_policy == 0) {
    c584:	792b      	ldrb	r3, [r5, #4]
    c586:	b953      	cbnz	r3, c59e <ble_ll_conn_master_init+0x5a>
        memcpy(&connsm->peer_addr, &hcc->peer_addr, BLE_DEV_ADDR_LEN);
    c588:	462b      	mov	r3, r5
    c58a:	f853 2f06 	ldr.w	r2, [r3, #6]!
    c58e:	f8c4 207e 	str.w	r2, [r4, #126]	; 0x7e
    c592:	889b      	ldrh	r3, [r3, #4]
    c594:	f8a4 3082 	strh.w	r3, [r4, #130]	; 0x82
        connsm->peer_addr_type = hcc->peer_addr_type;
    c598:	796b      	ldrb	r3, [r5, #5]
    c59a:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
    }

    /* XXX: for now, just make connection interval equal to max */
    connsm->conn_itvl_min = hcc->conn_itvl_min;
    c59e:	89eb      	ldrh	r3, [r5, #14]
    c5a0:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    connsm->conn_itvl_max = hcc->conn_itvl_max;
    c5a4:	8a2b      	ldrh	r3, [r5, #16]
    connsm->conn_itvl = hcc->conn_itvl_max;

    /* Check the min/max CE lengths are less than connection interval */
    if (hcc->min_ce_len > (connsm->conn_itvl * 2)) {
    c5a6:	8aea      	ldrh	r2, [r5, #22]
        connsm->peer_addr_type = hcc->peer_addr_type;
    }

    /* XXX: for now, just make connection interval equal to max */
    connsm->conn_itvl_min = hcc->conn_itvl_min;
    connsm->conn_itvl_max = hcc->conn_itvl_max;
    c5a8:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
    connsm->conn_itvl = hcc->conn_itvl_max;
    c5ac:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60

    /* Check the min/max CE lengths are less than connection interval */
    if (hcc->min_ce_len > (connsm->conn_itvl * 2)) {
    c5b0:	005b      	lsls	r3, r3, #1
    c5b2:	429a      	cmp	r2, r3
        connsm->min_ce_len = connsm->conn_itvl * 2;
    } else {
        connsm->min_ce_len = hcc->min_ce_len;
    c5b4:	bfd8      	it	le
    c5b6:	f8a4 2066 	strhle.w	r2, [r4, #102]	; 0x66
    }

    if (hcc->max_ce_len > (connsm->conn_itvl * 2)) {
    c5ba:	8b2a      	ldrh	r2, [r5, #24]
    connsm->conn_itvl_max = hcc->conn_itvl_max;
    connsm->conn_itvl = hcc->conn_itvl_max;

    /* Check the min/max CE lengths are less than connection interval */
    if (hcc->min_ce_len > (connsm->conn_itvl * 2)) {
        connsm->min_ce_len = connsm->conn_itvl * 2;
    c5bc:	bfc8      	it	gt
    c5be:	f8a4 3066 	strhgt.w	r3, [r4, #102]	; 0x66
    } else {
        connsm->min_ce_len = hcc->min_ce_len;
    }

    if (hcc->max_ce_len > (connsm->conn_itvl * 2)) {
    c5c2:	429a      	cmp	r2, r3
        connsm->max_ce_len = connsm->conn_itvl * 2;
    c5c4:	bfc8      	it	gt
    c5c6:	f8a4 3068 	strhgt.w	r3, [r4, #104]	; 0x68
    } else {
        connsm->max_ce_len = hcc->max_ce_len;
    }

    /* Set channel map to map requested by host */
    connsm->num_used_chans = g_ble_ll_conn_params.num_used_chans;
    c5ca:	4b27      	ldr	r3, [pc, #156]	; (c668 <ble_ll_conn_master_init+0x124>)
    }

    if (hcc->max_ce_len > (connsm->conn_itvl * 2)) {
        connsm->max_ce_len = connsm->conn_itvl * 2;
    } else {
        connsm->max_ce_len = hcc->max_ce_len;
    c5cc:	bfd8      	it	le
    c5ce:	f8a4 2068 	strhle.w	r2, [r4, #104]	; 0x68
    }

    /* Set channel map to map requested by host */
    connsm->num_used_chans = g_ble_ll_conn_params.num_used_chans;
    c5d2:	795a      	ldrb	r2, [r3, #5]
    c5d4:	f884 202a 	strb.w	r2, [r4, #42]	; 0x2a
    memcpy(connsm->chanmap, g_ble_ll_conn_params.master_chan_map,
    c5d8:	681a      	ldr	r2, [r3, #0]
    c5da:	791b      	ldrb	r3, [r3, #4]
    c5dc:	f8c4 201a 	str.w	r2, [r4, #26]
    c5e0:	77a3      	strb	r3, [r4, #30]
    c5e2:	f7fc fcf5 	bl	8fd0 <lrand48>
    c5e6:	4605      	mov	r5, r0
    c5e8:	f7fc fcf2 	bl	8fd0 <lrand48>
        /* Get two, 16-bit random numbers */
        aa_low = rand() & 0xFFFF;
        aa_high = rand() & 0xFFFF;

        /* All four bytes cannot be equal */
        if (aa_low == aa_high) {
    c5ec:	b2ab      	uxth	r3, r5
    c5ee:	b280      	uxth	r0, r0
    c5f0:	4283      	cmp	r3, r0
    c5f2:	d0f6      	beq.n	c5e2 <ble_ll_conn_master_init+0x9e>
            continue;
        }

        /* Upper 6 bits must have 2 transitions */
        temp = aa_high & 0xFC00;
        if ((temp == 0) || (temp == 0xFC00)) {
    c5f4:	f410 427c 	ands.w	r2, r0, #64512	; 0xfc00
    c5f8:	d0f3      	beq.n	c5e2 <ble_ll_conn_master_init+0x9e>
    c5fa:	f5b2 4f7c 	cmp.w	r2, #64512	; 0xfc00
    c5fe:	d0f0      	beq.n	c5e2 <ble_ll_conn_master_init+0x9e>

        /* Cannot be access address or be 1 bit different */
        aa = aa_high;
        aa = (aa << 16) | aa_low;
        bits_diff = 0;
        temp = aa ^ BLE_ACCESS_ADDR_ADV;
    c600:	4d1a      	ldr	r5, [pc, #104]	; (c66c <ble_ll_conn_master_init+0x128>)
            continue;
        }

        /* Cannot be access address or be 1 bit different */
        aa = aa_high;
        aa = (aa << 16) | aa_low;
    c602:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
        bits_diff = 0;
        temp = aa ^ BLE_ACCESS_ADDR_ADV;
    c606:	4045      	eors	r5, r0
    c608:	2320      	movs	r3, #32
        }

        /* Cannot be access address or be 1 bit different */
        aa = aa_high;
        aa = (aa << 16) | aa_low;
        bits_diff = 0;
    c60a:	2100      	movs	r1, #0
        temp = aa ^ BLE_ACCESS_ADDR_ADV;
        for (mask = 0x00000001; mask != 0; mask <<= 1) {
    c60c:	2201      	movs	r2, #1
            if (mask & temp) {
    c60e:	422a      	tst	r2, r5
    c610:	d001      	beq.n	c616 <ble_ll_conn_master_init+0xd2>
                ++bits_diff;
                if (bits_diff > 1) {
    c612:	b929      	cbnz	r1, c620 <ble_ll_conn_master_init+0xdc>
    c614:	2101      	movs	r1, #1
        /* Cannot be access address or be 1 bit different */
        aa = aa_high;
        aa = (aa << 16) | aa_low;
        bits_diff = 0;
        temp = aa ^ BLE_ACCESS_ADDR_ADV;
        for (mask = 0x00000001; mask != 0; mask <<= 1) {
    c616:	3b01      	subs	r3, #1
    c618:	ea4f 0242 	mov.w	r2, r2, lsl #1
    c61c:	d1f7      	bne.n	c60e <ble_ll_conn_master_init+0xca>
    c61e:	e7e0      	b.n	c5e2 <ble_ll_conn_master_init+0x9e>
        if (bits_diff <= 1) {
            continue;
        }

        /* Cannot have more than 24 transitions */
        transitions = 0;
    c620:	2200      	movs	r2, #0
        consecutive = 0;
        mask = 0x00000001;
        prev_bit = aa & mask;
    c622:	f000 0601 	and.w	r6, r0, #1
    c626:	2520      	movs	r5, #32
            continue;
        }

        /* Cannot have more than 24 transitions */
        transitions = 0;
        consecutive = 0;
    c628:	4613      	mov	r3, r2
        mask = 0x00000001;
        prev_bit = aa & mask;
        while (mask < 0x80000000) {
    c62a:	3d01      	subs	r5, #1
    c62c:	d00e      	beq.n	c64c <ble_ll_conn_master_init+0x108>
            mask <<= 1;
    c62e:	0049      	lsls	r1, r1, #1
            if (mask & aa) {
    c630:	4201      	tst	r1, r0
    c632:	d001      	beq.n	c638 <ble_ll_conn_master_init+0xf4>
                if (prev_bit == 0) {
    c634:	b90e      	cbnz	r6, c63a <ble_ll_conn_master_init+0xf6>
    c636:	e005      	b.n	c644 <ble_ll_conn_master_init+0x100>
                    consecutive = 0;
                } else {
                    ++consecutive;
                }
            } else {
                if (prev_bit == 0) {
    c638:	b926      	cbnz	r6, c644 <ble_ll_conn_master_init+0x100>
                    ++consecutive;
    c63a:	3301      	adds	r3, #1
    c63c:	b2db      	uxtb	r3, r3
                    consecutive = 0;
                }
            }

            /* This is invalid! */
            if (consecutive > 6) {
    c63e:	2b06      	cmp	r3, #6
    c640:	d9f3      	bls.n	c62a <ble_ll_conn_master_init+0xe6>
    c642:	e7ce      	b.n	c5e2 <ble_ll_conn_master_init+0x9e>
                }
            } else {
                if (prev_bit == 0) {
                    ++consecutive;
                } else {
                    ++transitions;
    c644:	3201      	adds	r2, #1
    c646:	b2d2      	uxtb	r2, r2
        bits_diff = 0;
        temp = aa ^ BLE_ACCESS_ADDR_ADV;
        for (mask = 0x00000001; mask != 0; mask <<= 1) {
            if (mask & temp) {
                ++bits_diff;
                if (bits_diff > 1) {
    c648:	2300      	movs	r3, #0
    c64a:	e7ee      	b.n	c62a <ble_ll_conn_master_init+0xe6>
                break;
            }
        }

        /* Cannot be more than 24 transitions */
        if ((consecutive > 6) || (transitions > 24)) {
    c64c:	2b06      	cmp	r3, #6
    c64e:	d8c8      	bhi.n	c5e2 <ble_ll_conn_master_init+0x9e>
    c650:	2a18      	cmp	r2, #24
    c652:	d8c6      	bhi.n	c5e2 <ble_ll_conn_master_init+0x9e>
    connsm->num_used_chans = g_ble_ll_conn_params.num_used_chans;
    memcpy(connsm->chanmap, g_ble_ll_conn_params.master_chan_map,
           BLE_LL_CONN_CHMAP_LEN);

    /*  Calculate random access address and crc initialization value */
    connsm->access_addr = ble_ll_conn_calc_access_addr();
    c654:	64a0      	str	r0, [r4, #72]	; 0x48
    c656:	f7fc fcbb 	bl	8fd0 <lrand48>
    connsm->crcinit = rand() & 0xffffff;

    /* Set initial schedule callback */
    connsm->conn_sch.sched_cb = ble_ll_conn_event_start_cb;
    c65a:	4b05      	ldr	r3, [pc, #20]	; (c670 <ble_ll_conn_master_init+0x12c>)
    c65c:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    memcpy(connsm->chanmap, g_ble_ll_conn_params.master_chan_map,
           BLE_LL_CONN_CHMAP_LEN);

    /*  Calculate random access address and crc initialization value */
    connsm->access_addr = ble_ll_conn_calc_access_addr();
    connsm->crcinit = rand() & 0xffffff;
    c660:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    c664:	64e0      	str	r0, [r4, #76]	; 0x4c
    c666:	bd70      	pop	{r4, r5, r6, pc}
    c668:	200033b8 	.word	0x200033b8
    c66c:	8e89bed6 	.word	0x8e89bed6
    c670:	0000c005 	.word	0x0000c005

0000c674 <ble_ll_conn_sm_new>:
    connsm->common_features = 0;
    connsm->vers_nr = 0;
    connsm->comp_id = 0;
    connsm->sub_vers_nr = 0;
    connsm->reject_reason = BLE_ERR_SUCCESS;
    connsm->conn_rssi = BLE_LL_CONN_UNKNOWN_RSSI;
    c674:	237f      	movs	r3, #127	; 0x7f
 *
 * @param connsm
 */
void
ble_ll_conn_sm_new(struct ble_ll_conn_sm *connsm)
{
    c676:	b570      	push	{r4, r5, r6, lr}
    c678:	4604      	mov	r4, r0
    struct ble_ll_conn_global_params *conn_params;

    /* Reset following elements */
    connsm->csmflags.conn_flags = 0;
    c67a:	2500      	movs	r5, #0
    connsm->common_features = 0;
    connsm->vers_nr = 0;
    connsm->comp_id = 0;
    connsm->sub_vers_nr = 0;
    connsm->reject_reason = BLE_ERR_SUCCESS;
    connsm->conn_rssi = BLE_LL_CONN_UNKNOWN_RSSI;
    c67c:	f880 302b 	strb.w	r3, [r0, #43]	; 0x2b
    connsm->rpa_index = -1;
    c680:	23ff      	movs	r3, #255	; 0xff
    c682:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31

    /* Reset current control procedure */
    connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
    c686:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
ble_ll_conn_sm_new(struct ble_ll_conn_sm *connsm)
{
    struct ble_ll_conn_global_params *conn_params;

    /* Reset following elements */
    connsm->csmflags.conn_flags = 0;
    c68a:	6005      	str	r5, [r0, #0]
    connsm->event_cntr = 0;
    c68c:	87c5      	strh	r5, [r0, #62]	; 0x3e
    connsm->conn_state = BLE_LL_CONN_STATE_IDLE;
    c68e:	7185      	strb	r5, [r0, #6]
    connsm->disconnect_reason = 0;
    c690:	f880 5037 	strb.w	r5, [r0, #55]	; 0x37
    connsm->common_features = 0;
    c694:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
    connsm->vers_nr = 0;
    c698:	f880 503a 	strb.w	r5, [r0, #58]	; 0x3a
    connsm->comp_id = 0;
    c69c:	f8a0 5042 	strh.w	r5, [r0, #66]	; 0x42
    connsm->sub_vers_nr = 0;
    c6a0:	f8a0 5044 	strh.w	r5, [r0, #68]	; 0x44
    connsm->reject_reason = BLE_ERR_SUCCESS;
    c6a4:	f880 5032 	strb.w	r5, [r0, #50]	; 0x32
    connsm->conn_rssi = BLE_LL_CONN_UNKNOWN_RSSI;
    connsm->rpa_index = -1;

    /* Reset current control procedure */
    connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
    connsm->pending_ctrl_procs = 0;
    c6a8:	8785      	strh	r5, [r0, #60]	; 0x3c
    /*
     * Set handle in connection update procedure to 0. If the handle
     * is non-zero it means that the host initiated the connection
     * parameter update request and the rest of the parameters are valid.
     */
    connsm->conn_param_req.handle = 0;
    c6aa:	f8a0 5168 	strh.w	r5, [r0, #360]	; 0x168

    /* Initialize connection supervision timer */
    cputime_timer_init(&connsm->conn_spvn_timer, ble_ll_conn_spvn_timer_cb,
    c6ae:	492e      	ldr	r1, [pc, #184]	; (c768 <ble_ll_conn_sm_new+0xf4>)
    c6b0:	4622      	mov	r2, r4
    c6b2:	3084      	adds	r0, #132	; 0x84
    c6b4:	f7fc fb0e 	bl	8cd4 <cputime_timer_init>
                       connsm);

    /* Calculate the next data channel */
    connsm->last_unmapped_chan = 0;
    c6b8:	f884 5029 	strb.w	r5, [r4, #41]	; 0x29
    connsm->data_chan_index = ble_ll_conn_calc_dci(connsm);
    c6bc:	4620      	mov	r0, r4
    c6be:	f7ff fdae 	bl	c21e <ble_ll_conn_calc_dci>

    /* Initialize event */
    connsm->conn_spvn_ev.ev_arg = connsm;
    connsm->conn_spvn_ev.ev_queued = 0;
    connsm->conn_spvn_ev.ev_type = BLE_LL_EVENT_CONN_SPVN_TMO;
    c6c2:	2314      	movs	r3, #20
    c6c4:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99

    /* Connection end event */
    connsm->conn_ev_end.ev_arg = connsm;
    connsm->conn_ev_end.ev_queued = 0;
    connsm->conn_ev_end.ev_type = BLE_LL_EVENT_CONN_EV_END;
    c6c8:	2315      	movs	r3, #21
    c6ca:	f884 30a5 	strb.w	r3, [r4, #165]	; 0xa5

    /* Initialize transmit queue and ack/flow control elements */
    STAILQ_INIT(&connsm->conn_txq);
    c6ce:	4623      	mov	r3, r4
    cputime_timer_init(&connsm->conn_spvn_timer, ble_ll_conn_spvn_timer_cb,
                       connsm);

    /* Calculate the next data channel */
    connsm->last_unmapped_chan = 0;
    connsm->data_chan_index = ble_ll_conn_calc_dci(connsm);
    c6d0:	f884 0027 	strb.w	r0, [r4, #39]	; 0x27

    /* Initialize event */
    connsm->conn_spvn_ev.ev_arg = connsm;
    c6d4:	f8c4 409c 	str.w	r4, [r4, #156]	; 0x9c
    connsm->conn_spvn_ev.ev_queued = 0;
    c6d8:	f884 5098 	strb.w	r5, [r4, #152]	; 0x98
    connsm->conn_spvn_ev.ev_type = BLE_LL_EVENT_CONN_SPVN_TMO;

    /* Connection end event */
    connsm->conn_ev_end.ev_arg = connsm;
    c6dc:	f8c4 40a8 	str.w	r4, [r4, #168]	; 0xa8
    connsm->conn_ev_end.ev_queued = 0;
    c6e0:	f884 50a4 	strb.w	r5, [r4, #164]	; 0xa4
    connsm->conn_ev_end.ev_type = BLE_LL_EVENT_CONN_EV_END;

    /* Initialize transmit queue and ack/flow control elements */
    STAILQ_INIT(&connsm->conn_txq);
    c6e4:	f843 5fb4 	str.w	r5, [r3, #180]!
    c6e8:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
    connsm->last_rxd_sn = 1;
    connsm->completed_pkts = 0;

    /* initialize data length mgmt */
    conn_params = &g_ble_ll_conn_params;
    connsm->max_tx_octets = conn_params->conn_init_max_tx_octets;
    c6ec:	4b1f      	ldr	r3, [pc, #124]	; (c76c <ble_ll_conn_sm_new+0xf8>)
    connsm->conn_ev_end.ev_queued = 0;
    connsm->conn_ev_end.ev_type = BLE_LL_EVENT_CONN_EV_END;

    /* Initialize transmit queue and ack/flow control elements */
    STAILQ_INIT(&connsm->conn_txq);
    connsm->cur_tx_pdu = NULL;
    c6ee:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
    connsm->last_rxd_sn = 1;
    connsm->completed_pkts = 0;

    /* initialize data length mgmt */
    conn_params = &g_ble_ll_conn_params;
    connsm->max_tx_octets = conn_params->conn_init_max_tx_octets;
    c6f2:	7a1a      	ldrb	r2, [r3, #8]
    c6f4:	7222      	strb	r2, [r4, #8]
    connsm->max_rx_octets = conn_params->supp_max_rx_octets;
    c6f6:	79da      	ldrb	r2, [r3, #7]
    c6f8:	7262      	strb	r2, [r4, #9]
    connsm->max_tx_time = conn_params->conn_init_max_tx_time;
    c6fa:	899a      	ldrh	r2, [r3, #12]
    connsm->max_rx_time = conn_params->supp_max_rx_time;
    c6fc:	8a1b      	ldrh	r3, [r3, #16]
    c6fe:	8223      	strh	r3, [r4, #16]
    connsm->rem_max_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    c700:	f44f 73a4 	mov.w	r3, #328	; 0x148
    STAILQ_INIT(&connsm->conn_txq);
    connsm->cur_tx_pdu = NULL;
    connsm->tx_seqnum = 0;
    connsm->next_exp_seqnum = 0;
    connsm->cons_rxd_bad_crc = 0;
    connsm->last_rxd_sn = 1;
    c704:	2601      	movs	r6, #1
    conn_params = &g_ble_ll_conn_params;
    connsm->max_tx_octets = conn_params->conn_init_max_tx_octets;
    connsm->max_rx_octets = conn_params->supp_max_rx_octets;
    connsm->max_tx_time = conn_params->conn_init_max_tx_time;
    connsm->max_rx_time = conn_params->supp_max_rx_time;
    connsm->rem_max_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    c706:	8263      	strh	r3, [r4, #18]
    connsm->rem_max_rx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    c708:	82a3      	strh	r3, [r4, #20]
    connsm->eff_max_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    c70a:	82e3      	strh	r3, [r4, #22]
    connsm->eff_max_rx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    c70c:	8323      	strh	r3, [r4, #24]
    connsm->rem_max_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    c70e:	231b      	movs	r3, #27

    /* initialize data length mgmt */
    conn_params = &g_ble_ll_conn_params;
    connsm->max_tx_octets = conn_params->conn_init_max_tx_octets;
    connsm->max_rx_octets = conn_params->supp_max_rx_octets;
    connsm->max_tx_time = conn_params->conn_init_max_tx_time;
    c710:	81e2      	strh	r2, [r4, #14]
    connsm->max_rx_time = conn_params->supp_max_rx_time;
    connsm->rem_max_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    connsm->rem_max_rx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    connsm->eff_max_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    connsm->eff_max_rx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    connsm->rem_max_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    c712:	72a3      	strb	r3, [r4, #10]
    connsm->rem_max_rx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    c714:	72e3      	strb	r3, [r4, #11]
    connsm->eff_max_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    c716:	7323      	strb	r3, [r4, #12]
    connsm->eff_max_rx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    c718:	7363      	strb	r3, [r4, #13]

    /* Reset encryption data */
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    memset(&connsm->enc_data, 0, sizeof(struct ble_ll_conn_enc_data));
    c71a:	4629      	mov	r1, r5
    c71c:	2248      	movs	r2, #72	; 0x48
    connsm->conn_ev_end.ev_type = BLE_LL_EVENT_CONN_EV_END;

    /* Initialize transmit queue and ack/flow control elements */
    STAILQ_INIT(&connsm->conn_txq);
    connsm->cur_tx_pdu = NULL;
    connsm->tx_seqnum = 0;
    c71e:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
    connsm->next_exp_seqnum = 0;
    c722:	f884 502d 	strb.w	r5, [r4, #45]	; 0x2d
    connsm->cons_rxd_bad_crc = 0;
    c726:	f884 502e 	strb.w	r5, [r4, #46]	; 0x2e
    connsm->last_rxd_sn = 1;
    c72a:	f884 602f 	strb.w	r6, [r4, #47]	; 0x2f
    connsm->completed_pkts = 0;
    c72e:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
    connsm->eff_max_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    connsm->eff_max_rx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;

    /* Reset encryption data */
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    memset(&connsm->enc_data, 0, sizeof(struct ble_ll_conn_enc_data));
    c732:	f504 7090 	add.w	r0, r4, #288	; 0x120
    c736:	f7fc fc6c 	bl	9012 <memset>
    connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
#endif

#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    connsm->auth_pyld_tmo = BLE_LL_CONN_DEF_AUTH_PYLD_TMO;
    c73a:	f640 33b8 	movw	r3, #3000	; 0xbb8
    c73e:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    CONN_F_LE_PING_SUPP(connsm) = 1;
    c742:	78a3      	ldrb	r3, [r4, #2]
    os_callout_func_init(&connsm->auth_pyld_timer,
    c744:	4a0a      	ldr	r2, [pc, #40]	; (c770 <ble_ll_conn_sm_new+0xfc>)
    connsm->eff_max_rx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;

    /* Reset encryption data */
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    memset(&connsm->enc_data, 0, sizeof(struct ble_ll_conn_enc_data));
    connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
    c746:	f884 6120 	strb.w	r6, [r4, #288]	; 0x120
#endif

#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    connsm->auth_pyld_tmo = BLE_LL_CONN_DEF_AUTH_PYLD_TMO;
    CONN_F_LE_PING_SUPP(connsm) = 1;
    c74a:	f043 0304 	orr.w	r3, r3, #4
    c74e:	70a3      	strb	r3, [r4, #2]
    os_callout_func_init(&connsm->auth_pyld_timer,
    c750:	f104 00fc 	add.w	r0, r4, #252	; 0xfc
    c754:	4623      	mov	r3, r4
    c756:	4907      	ldr	r1, [pc, #28]	; (c774 <ble_ll_conn_sm_new+0x100>)
    c758:	f7fd f9a4 	bl	9aa4 <os_callout_func_init>
                         ble_ll_conn_auth_pyld_timer_cb,
                         connsm);
#endif

    /* Add to list of active connections */
    SLIST_INSERT_HEAD(&g_ble_ll_conn_active_list, connsm, act_sle);
    c75c:	4b06      	ldr	r3, [pc, #24]	; (c778 <ble_ll_conn_sm_new+0x104>)
    c75e:	681a      	ldr	r2, [r3, #0]
    c760:	f8c4 20bc 	str.w	r2, [r4, #188]	; 0xbc
    c764:	601c      	str	r4, [r3, #0]
    c766:	bd70      	pop	{r4, r5, r6, pc}
    c768:	0000bb83 	.word	0x0000bb83
    c76c:	200033b8 	.word	0x200033b8
    c770:	0000c529 	.word	0x0000c529
    c774:	200032c8 	.word	0x200032c8
    c778:	200035f4 	.word	0x200035f4

0000c77c <ble_ll_conn_datalen_update>:
 * @param req
 */
void
ble_ll_conn_datalen_update(struct ble_ll_conn_sm *connsm,
                           struct ble_ll_len_req *req)
{
    c77c:	b530      	push	{r4, r5, lr}
    uint16_t eff_bytes;

    /* Update parameters */
    connsm->rem_max_rx_time = req->max_rx_time;
    connsm->rem_max_tx_time = req->max_tx_time;
    connsm->rem_max_rx_octets = req->max_rx_bytes;
    c77e:	780c      	ldrb	r4, [r1, #0]
    uint16_t eff_time;
    uint16_t eff_bytes;

    /* Update parameters */
    connsm->rem_max_rx_time = req->max_rx_time;
    connsm->rem_max_tx_time = req->max_tx_time;
    c780:	88ca      	ldrh	r2, [r1, #6]
    int send_event;
    uint16_t eff_time;
    uint16_t eff_bytes;

    /* Update parameters */
    connsm->rem_max_rx_time = req->max_rx_time;
    c782:	884b      	ldrh	r3, [r1, #2]
    connsm->rem_max_tx_time = req->max_tx_time;
    connsm->rem_max_rx_octets = req->max_rx_bytes;
    c784:	72c4      	strb	r4, [r0, #11]
    connsm->rem_max_tx_octets = req->max_tx_bytes;
    c786:	790d      	ldrb	r5, [r1, #4]

    /* Assume no event sent */
    send_event = 0;

    /* See if effective times have changed */
    eff_time = min(connsm->rem_max_tx_time, connsm->max_rx_time);
    c788:	8a01      	ldrh	r1, [r0, #16]
    uint16_t eff_time;
    uint16_t eff_bytes;

    /* Update parameters */
    connsm->rem_max_rx_time = req->max_rx_time;
    connsm->rem_max_tx_time = req->max_tx_time;
    c78a:	8242      	strh	r2, [r0, #18]

    /* Assume no event sent */
    send_event = 0;

    /* See if effective times have changed */
    eff_time = min(connsm->rem_max_tx_time, connsm->max_rx_time);
    c78c:	428a      	cmp	r2, r1
    c78e:	bf28      	it	cs
    c790:	460a      	movcs	r2, r1
    if (eff_time != connsm->eff_max_rx_time) {
    c792:	8b01      	ldrh	r1, [r0, #24]
    int send_event;
    uint16_t eff_time;
    uint16_t eff_bytes;

    /* Update parameters */
    connsm->rem_max_rx_time = req->max_rx_time;
    c794:	8283      	strh	r3, [r0, #20]
    /* Assume no event sent */
    send_event = 0;

    /* See if effective times have changed */
    eff_time = min(connsm->rem_max_tx_time, connsm->max_rx_time);
    if (eff_time != connsm->eff_max_rx_time) {
    c796:	4291      	cmp	r1, r2
        connsm->eff_max_rx_time = eff_time;
        send_event = 1;
    }
    eff_time = min(connsm->rem_max_rx_time, connsm->max_tx_time);
    c798:	89c1      	ldrh	r1, [r0, #14]
    send_event = 0;

    /* See if effective times have changed */
    eff_time = min(connsm->rem_max_tx_time, connsm->max_rx_time);
    if (eff_time != connsm->eff_max_rx_time) {
        connsm->eff_max_rx_time = eff_time;
    c79a:	bf16      	itet	ne
    c79c:	8302      	strhne	r2, [r0, #24]
    connsm->rem_max_tx_time = req->max_tx_time;
    connsm->rem_max_rx_octets = req->max_rx_bytes;
    connsm->rem_max_tx_octets = req->max_tx_bytes;

    /* Assume no event sent */
    send_event = 0;
    c79e:	2200      	moveq	r2, #0

    /* See if effective times have changed */
    eff_time = min(connsm->rem_max_tx_time, connsm->max_rx_time);
    if (eff_time != connsm->eff_max_rx_time) {
        connsm->eff_max_rx_time = eff_time;
        send_event = 1;
    c7a0:	2201      	movne	r2, #1
    }
    eff_time = min(connsm->rem_max_rx_time, connsm->max_tx_time);
    c7a2:	428b      	cmp	r3, r1
    c7a4:	bf28      	it	cs
    c7a6:	460b      	movcs	r3, r1
    if (eff_time != connsm->eff_max_tx_time) {
    c7a8:	8ac1      	ldrh	r1, [r0, #22]

    /* Update parameters */
    connsm->rem_max_rx_time = req->max_rx_time;
    connsm->rem_max_tx_time = req->max_tx_time;
    connsm->rem_max_rx_octets = req->max_rx_bytes;
    connsm->rem_max_tx_octets = req->max_tx_bytes;
    c7aa:	7285      	strb	r5, [r0, #10]
    if (eff_time != connsm->eff_max_rx_time) {
        connsm->eff_max_rx_time = eff_time;
        send_event = 1;
    }
    eff_time = min(connsm->rem_max_rx_time, connsm->max_tx_time);
    if (eff_time != connsm->eff_max_tx_time) {
    c7ac:	4299      	cmp	r1, r3
        connsm->eff_max_tx_time = eff_time;
        send_event = 1;
    }
    eff_bytes = min(connsm->rem_max_tx_octets, connsm->max_rx_octets);
    c7ae:	7a41      	ldrb	r1, [r0, #9]
        connsm->eff_max_rx_time = eff_time;
        send_event = 1;
    }
    eff_time = min(connsm->rem_max_rx_time, connsm->max_tx_time);
    if (eff_time != connsm->eff_max_tx_time) {
        connsm->eff_max_tx_time = eff_time;
    c7b0:	bf1c      	itt	ne
    c7b2:	82c3      	strhne	r3, [r0, #22]
        send_event = 1;
    c7b4:	2201      	movne	r2, #1
    }
    eff_bytes = min(connsm->rem_max_tx_octets, connsm->max_rx_octets);
    if (eff_bytes != connsm->eff_max_rx_octets) {
    c7b6:	7b43      	ldrb	r3, [r0, #13]
    eff_time = min(connsm->rem_max_rx_time, connsm->max_tx_time);
    if (eff_time != connsm->eff_max_tx_time) {
        connsm->eff_max_tx_time = eff_time;
        send_event = 1;
    }
    eff_bytes = min(connsm->rem_max_tx_octets, connsm->max_rx_octets);
    c7b8:	42a9      	cmp	r1, r5
    c7ba:	bf28      	it	cs
    c7bc:	4629      	movcs	r1, r5
    if (eff_bytes != connsm->eff_max_rx_octets) {
    c7be:	428b      	cmp	r3, r1
        connsm->eff_max_rx_octets = eff_bytes;
        send_event = 1;
    }
    eff_bytes = min(connsm->rem_max_rx_octets, connsm->max_tx_octets);
    c7c0:	7a03      	ldrb	r3, [r0, #8]
        connsm->eff_max_tx_time = eff_time;
        send_event = 1;
    }
    eff_bytes = min(connsm->rem_max_tx_octets, connsm->max_rx_octets);
    if (eff_bytes != connsm->eff_max_rx_octets) {
        connsm->eff_max_rx_octets = eff_bytes;
    c7c2:	bf1c      	itt	ne
    c7c4:	7341      	strbne	r1, [r0, #13]
        send_event = 1;
    c7c6:	2201      	movne	r2, #1
    }
    eff_bytes = min(connsm->rem_max_rx_octets, connsm->max_tx_octets);
    if (eff_bytes != connsm->eff_max_tx_octets) {
    c7c8:	7b01      	ldrb	r1, [r0, #12]
    eff_bytes = min(connsm->rem_max_tx_octets, connsm->max_rx_octets);
    if (eff_bytes != connsm->eff_max_rx_octets) {
        connsm->eff_max_rx_octets = eff_bytes;
        send_event = 1;
    }
    eff_bytes = min(connsm->rem_max_rx_octets, connsm->max_tx_octets);
    c7ca:	42a3      	cmp	r3, r4
    c7cc:	bf28      	it	cs
    c7ce:	4623      	movcs	r3, r4
    if (eff_bytes != connsm->eff_max_tx_octets) {
    c7d0:	4299      	cmp	r1, r3
    c7d2:	d001      	beq.n	c7d8 <ble_ll_conn_datalen_update+0x5c>
        connsm->eff_max_tx_octets = eff_bytes;
    c7d4:	7303      	strb	r3, [r0, #12]
    c7d6:	e000      	b.n	c7da <ble_ll_conn_datalen_update+0x5e>
        send_event = 1;
    }

    if (send_event) {
    c7d8:	b11a      	cbz	r2, c7e2 <ble_ll_conn_datalen_update+0x66>
        ble_ll_hci_ev_datalen_chg(connsm);
    }
}
    c7da:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        connsm->eff_max_tx_octets = eff_bytes;
        send_event = 1;
    }

    if (send_event) {
        ble_ll_hci_ev_datalen_chg(connsm);
    c7de:	f002 bce7 	b.w	f1b0 <ble_ll_hci_ev_datalen_chg>
    c7e2:	bd30      	pop	{r4, r5, pc}

0000c7e4 <ble_ll_conn_end>:
 * @param connsm
 * @param ble_err
 */
void
ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
{
    c7e4:	b570      	push	{r4, r5, r6, lr}
    c7e6:	4604      	mov	r4, r0
    struct os_mbuf *m;
    struct os_mbuf_pkthdr *pkthdr;

    /* Remove scheduler events just in case */
    ble_ll_sched_rmv_elem(&connsm->conn_sch);
    c7e8:	30e0      	adds	r0, #224	; 0xe0
 * @param connsm
 * @param ble_err
 */
void
ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
{
    c7ea:	460d      	mov	r5, r1
    struct os_mbuf *m;
    struct os_mbuf_pkthdr *pkthdr;

    /* Remove scheduler events just in case */
    ble_ll_sched_rmv_elem(&connsm->conn_sch);
    c7ec:	f004 f8bc 	bl	10968 <ble_ll_sched_rmv_elem>

    /* Stop supervision timer */
    cputime_timer_stop(&connsm->conn_spvn_timer);
    c7f0:	f104 0084 	add.w	r0, r4, #132	; 0x84
    c7f4:	f7fc fae4 	bl	8dc0 <cputime_timer_stop>

    /* Stop any control procedures that might be running */
    os_callout_stop(&connsm->ctrl_proc_rsp_timer.cf_c);
    c7f8:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
    c7fc:	f7fd f962 	bl	9ac4 <os_callout_stop>

#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    os_callout_stop(&connsm->auth_pyld_timer.cf_c);
    c800:	f104 00fc 	add.w	r0, r4, #252	; 0xfc
    c804:	f7fd f95e 	bl	9ac4 <os_callout_stop>
#endif

    /* Remove from the active connection list */
    SLIST_REMOVE(&g_ble_ll_conn_active_list, connsm, ble_ll_conn_sm, act_sle);
    c808:	4a23      	ldr	r2, [pc, #140]	; (c898 <ble_ll_conn_end+0xb4>)
    c80a:	6813      	ldr	r3, [r2, #0]
    c80c:	42a3      	cmp	r3, r4
    c80e:	d103      	bne.n	c818 <ble_ll_conn_end+0x34>
    c810:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
    c814:	6013      	str	r3, [r2, #0]
    c816:	e009      	b.n	c82c <ble_ll_conn_end+0x48>
    c818:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
    c81c:	42a2      	cmp	r2, r4
    c81e:	d001      	beq.n	c824 <ble_ll_conn_end+0x40>
    c820:	4613      	mov	r3, r2
    c822:	e7f9      	b.n	c818 <ble_ll_conn_end+0x34>
    c824:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    c828:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc

    /* Free the current transmit pdu if there is one. */
    if (connsm->cur_tx_pdu) {
    c82c:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
    c830:	b120      	cbz	r0, c83c <ble_ll_conn_end+0x58>
        os_mbuf_free_chain(connsm->cur_tx_pdu);
    c832:	f7fd fb94 	bl	9f5e <os_mbuf_free_chain>
        connsm->cur_tx_pdu = NULL;
    c836:	2300      	movs	r3, #0
    c838:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
    }

    /* Free all packets on transmit queue */
    while (1) {
        /* Get mbuf pointer from packet header pointer */
        pkthdr = STAILQ_FIRST(&connsm->conn_txq);
    c83c:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
        if (!pkthdr) {
    c840:	b166      	cbz	r6, c85c <ble_ll_conn_end+0x78>
            break;
        }
        STAILQ_REMOVE_HEAD(&connsm->conn_txq, omp_next);
    c842:	6873      	ldr	r3, [r6, #4]
    c844:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
    c848:	b91b      	cbnz	r3, c852 <ble_ll_conn_end+0x6e>
    c84a:	f104 03b4 	add.w	r3, r4, #180	; 0xb4
    c84e:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8

        m = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));
        os_mbuf_free_chain(m);
    c852:	f1a6 0010 	sub.w	r0, r6, #16
    c856:	f7fd fb82 	bl	9f5e <os_mbuf_free_chain>
    }
    c85a:	e7ef      	b.n	c83c <ble_ll_conn_end+0x58>

    /* Make sure events off queue */
    os_eventq_remove(&g_ble_ll_data.ll_evq, &connsm->conn_spvn_ev);
    c85c:	480f      	ldr	r0, [pc, #60]	; (c89c <ble_ll_conn_end+0xb8>)
    c85e:	f104 0198 	add.w	r1, r4, #152	; 0x98
    c862:	f7fd fa16 	bl	9c92 <os_eventq_remove>
    os_eventq_remove(&g_ble_ll_data.ll_evq, &connsm->conn_ev_end);
    c866:	480d      	ldr	r0, [pc, #52]	; (c89c <ble_ll_conn_end+0xb8>)
    c868:	f104 01a4 	add.w	r1, r4, #164	; 0xa4
    c86c:	f7fd fa11 	bl	9c92 <os_eventq_remove>

    /* Connection state machine is now idle */
    connsm->conn_state = BLE_LL_CONN_STATE_IDLE;
    c870:	71a6      	strb	r6, [r4, #6]
     * event when the connection ends. We send a connection complete event
     * only when we were told to cancel the connection creation. If the
     * ble error is "success" it means that the reset command was received
     * and we should not send an event
     */
    if (ble_err) {
    c872:	b145      	cbz	r5, c886 <ble_ll_conn_end+0xa2>
        if (ble_err == BLE_ERR_UNK_CONN_ID) {
    c874:	2d02      	cmp	r5, #2
            ble_ll_conn_comp_event_send(connsm, ble_err);
    c876:	4620      	mov	r0, r4
    c878:	4629      	mov	r1, r5
     * only when we were told to cancel the connection creation. If the
     * ble error is "success" it means that the reset command was received
     * and we should not send an event
     */
    if (ble_err) {
        if (ble_err == BLE_ERR_UNK_CONN_ID) {
    c87a:	d102      	bne.n	c882 <ble_ll_conn_end+0x9e>
            ble_ll_conn_comp_event_send(connsm, ble_err);
    c87c:	f000 fe40 	bl	d500 <ble_ll_conn_comp_event_send>
    c880:	e001      	b.n	c886 <ble_ll_conn_end+0xa2>
        } else {
            ble_ll_disconn_comp_event_send(connsm, ble_err);
    c882:	f000 ff49 	bl	d718 <ble_ll_disconn_comp_event_send>
        }
    }

    /* Put connection state machine back on free list */
    STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    c886:	2300      	movs	r3, #0
    c888:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
    c88c:	4b04      	ldr	r3, [pc, #16]	; (c8a0 <ble_ll_conn_end+0xbc>)
    c88e:	685a      	ldr	r2, [r3, #4]
    c890:	6014      	str	r4, [r2, #0]
    c892:	34bc      	adds	r4, #188	; 0xbc
    c894:	605c      	str	r4, [r3, #4]
    c896:	bd70      	pop	{r4, r5, r6, pc}
    c898:	200035f4 	.word	0x200035f4
    c89c:	200032c8 	.word	0x200032c8
    c8a0:	200033d0 	.word	0x200033d0

0000c8a4 <ble_ll_conn_event_end>:
 * @param void *arg Pointer to connection state machine
 *
 */
void
ble_ll_conn_event_end(void *arg)
{
    c8a4:	b538      	push	{r3, r4, r5, lr}
    uint8_t ble_err;
    struct ble_ll_conn_sm *connsm;

    /* Better be a connection state machine! */
    connsm = (struct ble_ll_conn_sm *)arg;
    assert(connsm);
    c8a6:	4604      	mov	r4, r0
    c8a8:	b930      	cbnz	r0, c8b8 <ble_ll_conn_event_end+0x14>
    c8aa:	4824      	ldr	r0, [pc, #144]	; (c93c <ble_ll_conn_event_end+0x98>)
    c8ac:	f240 7144 	movw	r1, #1860	; 0x744
    c8b0:	4622      	mov	r2, r4
    c8b2:	4623      	mov	r3, r4
    c8b4:	f7fd fa0c 	bl	9cd0 <__assert_func>

    /* Check if we need to resume scanning */
    ble_ll_scan_chk_resume();
    c8b8:	f003 fae4 	bl	fe84 <ble_ll_scan_chk_resume>
    /* Log event end */
    ble_ll_log(BLE_LL_LOG_ID_CONN_EV_END, 0, connsm->event_cntr,
               connsm->ce_end_time);

    /* If we have transmitted the terminate IND successfully, we are done */
    if ((connsm->csmflags.cfbit.terminate_ind_txd) ||
    c8bc:	7823      	ldrb	r3, [r4, #0]
    c8be:	f013 0506 	ands.w	r5, r3, #6
    c8c2:	d00a      	beq.n	c8da <ble_ll_conn_event_end+0x36>
        (connsm->csmflags.cfbit.terminate_ind_rxd)) {
        if (connsm->csmflags.cfbit.terminate_ind_txd) {
    c8c4:	079a      	lsls	r2, r3, #30
    c8c6:	d405      	bmi.n	c8d4 <ble_ll_conn_event_end+0x30>
            ble_err = BLE_ERR_CONN_TERM_LOCAL;
        } else {
            /* Make sure the disconnect reason is valid! */
            ble_err = connsm->rxd_disconnect_reason;
    c8c8:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
            if (ble_err == 0) {
                ble_err = BLE_ERR_REM_USER_CONN_TERM;
    c8cc:	2900      	cmp	r1, #0
    c8ce:	bf08      	it	eq
    c8d0:	2113      	moveq	r1, #19
    c8d2:	e000      	b.n	c8d6 <ble_ll_conn_event_end+0x32>

    /* If we have transmitted the terminate IND successfully, we are done */
    if ((connsm->csmflags.cfbit.terminate_ind_txd) ||
        (connsm->csmflags.cfbit.terminate_ind_rxd)) {
        if (connsm->csmflags.cfbit.terminate_ind_txd) {
            ble_err = BLE_ERR_CONN_TERM_LOCAL;
    c8d4:	2116      	movs	r1, #22
            ble_err = connsm->rxd_disconnect_reason;
            if (ble_err == 0) {
                ble_err = BLE_ERR_REM_USER_CONN_TERM;
            }
        }
        ble_ll_conn_end(connsm, ble_err);
    c8d6:	4620      	mov	r0, r4
    c8d8:	e00e      	b.n	c8f8 <ble_ll_conn_event_end+0x54>
        return;
    }

    /* Remove any connection end events that might be enqueued */
    os_eventq_remove(&g_ble_ll_data.ll_evq, &connsm->conn_ev_end);
    c8da:	4819      	ldr	r0, [pc, #100]	; (c940 <ble_ll_conn_event_end+0x9c>)
    c8dc:	f104 01a4 	add.w	r1, r4, #164	; 0xa4
    c8e0:	f7fd f9d7 	bl	9c92 <os_eventq_remove>

    /*
     * If we have received a packet, we can set the current transmit window
     * usecs to 0 since we dont need to listen in the transmit window.
     */
    if (connsm->csmflags.cfbit.pkt_rxd) {
    c8e4:	7823      	ldrb	r3, [r4, #0]
    c8e6:	07db      	lsls	r3, r3, #31
        connsm->slave_cur_tx_win_usecs = 0;
    c8e8:	bf48      	it	mi
    c8ea:	6765      	strmi	r5, [r4, #116]	; 0x74
     * should run even when encryption is paused.
     */
#endif

    /* Move to next connection event */
    if (ble_ll_conn_next_event(connsm)) {
    c8ec:	4620      	mov	r0, r4
    c8ee:	f7ff fcd2 	bl	c296 <ble_ll_conn_next_event>
    c8f2:	b128      	cbz	r0, c900 <ble_ll_conn_event_end+0x5c>
        ble_ll_conn_end(connsm, BLE_ERR_CONN_TERM_LOCAL);
    c8f4:	4620      	mov	r0, r4
    c8f6:	2116      	movs	r1, #22

    /* If we have completed packets, send an event */
    if (connsm->completed_pkts) {
        ble_ll_conn_num_comp_pkts_event_send();
    }
}
    c8f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     */
#endif

    /* Move to next connection event */
    if (ble_ll_conn_next_event(connsm)) {
        ble_ll_conn_end(connsm, BLE_ERR_CONN_TERM_LOCAL);
    c8fc:	f7ff bf72 	b.w	c7e4 <ble_ll_conn_end>
        return;
    }

    /* Reset "per connection event" variables */
    connsm->cons_rxd_bad_crc = 0;
    connsm->csmflags.cfbit.pkt_rxd = 0;
    c900:	7823      	ldrb	r3, [r4, #0]
        ble_ll_conn_end(connsm, BLE_ERR_CONN_TERM_LOCAL);
        return;
    }

    /* Reset "per connection event" variables */
    connsm->cons_rxd_bad_crc = 0;
    c902:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
    connsm->csmflags.cfbit.pkt_rxd = 0;
    c906:	f360 0300 	bfi	r3, r0, #0, #1
    c90a:	7023      	strb	r3, [r4, #0]

    /* See if we need to start any control procedures */
    ble_ll_ctrl_chk_proc_start(connsm);
    c90c:	4620      	mov	r0, r4
    c90e:	f001 fdf7 	bl	e500 <ble_ll_ctrl_chk_proc_start>

    /* Set initial schedule callback */
    connsm->conn_sch.sched_cb = ble_ll_conn_event_start_cb;
    c912:	4b0c      	ldr	r3, [pc, #48]	; (c944 <ble_ll_conn_event_end+0xa0>)
    c914:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0

    /* XXX: I think all this fine for when we do connection updates, but
       we may want to force the first event to be scheduled. Not sure */
    /* Schedule the next connection event */
    while (ble_ll_sched_conn_reschedule(connsm)) {
    c918:	4620      	mov	r0, r4
    c91a:	f003 fdc9 	bl	104b0 <ble_ll_sched_conn_reschedule>
    c91e:	b128      	cbz	r0, c92c <ble_ll_conn_event_end+0x88>
        if (ble_ll_conn_next_event(connsm)) {
    c920:	4620      	mov	r0, r4
    c922:	f7ff fcb8 	bl	c296 <ble_ll_conn_next_event>
    c926:	2800      	cmp	r0, #0
    c928:	d0f6      	beq.n	c918 <ble_ll_conn_event_end+0x74>
    c92a:	e7e3      	b.n	c8f4 <ble_ll_conn_event_end+0x50>
            return;
        }
    }

    /* If we have completed packets, send an event */
    if (connsm->completed_pkts) {
    c92c:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    c930:	b11b      	cbz	r3, c93a <ble_ll_conn_event_end+0x96>
        ble_ll_conn_num_comp_pkts_event_send();
    }
}
    c932:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        }
    }

    /* If we have completed packets, send an event */
    if (connsm->completed_pkts) {
        ble_ll_conn_num_comp_pkts_event_send();
    c936:	f000 be67 	b.w	d608 <ble_ll_conn_num_comp_pkts_event_send>
    c93a:	bd38      	pop	{r3, r4, r5, pc}
    c93c:	0001f253 	.word	0x0001f253
    c940:	200032c8 	.word	0x200032c8
    c944:	0000c005 	.word	0x0000c005

0000c948 <ble_ll_conn_event_halt>:
 * NOTE: the phy has been disabled as well as the wfr timer before this is
 * called.
 */
void
ble_ll_conn_event_halt(void)
{
    c948:	b510      	push	{r4, lr}
    ble_ll_state_set(BLE_LL_STATE_STANDBY);
    if (g_ble_ll_conn_cur_sm) {
    c94a:	4c08      	ldr	r4, [pc, #32]	; (c96c <ble_ll_conn_event_halt+0x24>)
 * called.
 */
void
ble_ll_conn_event_halt(void)
{
    ble_ll_state_set(BLE_LL_STATE_STANDBY);
    c94c:	2000      	movs	r0, #0
    c94e:	f7fe fbc9 	bl	b0e4 <ble_ll_state_set>
    if (g_ble_ll_conn_cur_sm) {
    c952:	6820      	ldr	r0, [r4, #0]
    c954:	b140      	cbz	r0, c968 <ble_ll_conn_event_halt+0x20>
        g_ble_ll_conn_cur_sm->csmflags.cfbit.pkt_rxd = 0;
    c956:	7803      	ldrb	r3, [r0, #0]
    c958:	f36f 0300 	bfc	r3, #0, #1
    c95c:	f800 3ba4 	strb.w	r3, [r0], #164
        ble_ll_event_send(&g_ble_ll_conn_cur_sm->conn_ev_end);
    c960:	f7fe fbcc 	bl	b0fc <ble_ll_event_send>
        g_ble_ll_conn_cur_sm = NULL;
    c964:	2300      	movs	r3, #0
    c966:	6023      	str	r3, [r4, #0]
    c968:	bd10      	pop	{r4, pc}
    c96a:	bf00      	nop
    c96c:	200033cc 	.word	0x200033cc

0000c970 <ble_ll_init_rx_pkt_in>:
 * @param pdu_type
 * @param rxbuf
 */
void
ble_ll_init_rx_pkt_in(uint8_t *rxbuf, struct ble_mbuf_hdr *ble_hdr)
{
    c970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t *addr;
    uint32_t endtime;
    struct ble_ll_conn_sm *connsm;

    /* Get the connection state machine we are trying to create */
    connsm = g_ble_ll_conn_create_sm;
    c972:	4e20      	ldr	r6, [pc, #128]	; (c9f4 <ble_ll_init_rx_pkt_in+0x84>)
    c974:	6834      	ldr	r4, [r6, #0]
 * @param pdu_type
 * @param rxbuf
 */
void
ble_ll_init_rx_pkt_in(uint8_t *rxbuf, struct ble_mbuf_hdr *ble_hdr)
{
    c976:	4605      	mov	r5, r0
    c978:	460f      	mov	r7, r1

    /* Get the connection state machine we are trying to create */
    connsm = g_ble_ll_conn_create_sm;

    /* If we have sent a connect request, we need to enter CONNECTION state */
    if (connsm && CONN_F_CONN_REQ_TXD(connsm)) {
    c97a:	2c00      	cmp	r4, #0
    c97c:	d036      	beq.n	c9ec <ble_ll_init_rx_pkt_in+0x7c>
    c97e:	7863      	ldrb	r3, [r4, #1]
    c980:	065b      	lsls	r3, r3, #25
    c982:	d533      	bpl.n	c9ec <ble_ll_init_rx_pkt_in+0x7c>
        /* Set address of advertiser to which we are connecting. */
        if (ble_ll_scan_whitelist_enabled()) {
    c984:	f003 fc9e 	bl	102c4 <ble_ll_scan_whitelist_enabled>
    c988:	b1c8      	cbz	r0, c9be <ble_ll_init_rx_pkt_in+0x4e>
             * Did we resolve this address? If so, set correct peer address
             * and peer address type.
             */
            rpa_index = connsm->rpa_index;

            if (rpa_index >= 0) {
    c98a:	f994 2031 	ldrsb.w	r2, [r4, #49]	; 0x31
    /* If we have sent a connect request, we need to enter CONNECTION state */
    if (connsm && CONN_F_CONN_REQ_TXD(connsm)) {
        /* Set address of advertiser to which we are connecting. */
        if (ble_ll_scan_whitelist_enabled()) {
            /* Get address type of advertiser */
            if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
    c98e:	782b      	ldrb	r3, [r5, #0]
             * Did we resolve this address? If so, set correct peer address
             * and peer address type.
             */
            rpa_index = connsm->rpa_index;

            if (rpa_index >= 0) {
    c990:	2a00      	cmp	r2, #0
                addr_type = g_ble_ll_resolv_list[rpa_index].rl_addr_type + 2;
    c992:	bfa3      	ittte	ge
    c994:	4b18      	ldrge	r3, [pc, #96]	; (c9f8 <ble_ll_init_rx_pkt_in+0x88>)
    c996:	2128      	movge	r1, #40	; 0x28
    c998:	fb01 3302 	mlage	r3, r1, r2, r3
    if (connsm && CONN_F_CONN_REQ_TXD(connsm)) {
        /* Set address of advertiser to which we are connecting. */
        if (ble_ll_scan_whitelist_enabled()) {
            /* Get address type of advertiser */
            if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
                addr_type = BLE_HCI_CONN_PEER_ADDR_RANDOM;
    c99c:	f3c3 1280 	ubfxlt	r2, r3, #6, #1
             * and peer address type.
             */
            rpa_index = connsm->rpa_index;

            if (rpa_index >= 0) {
                addr_type = g_ble_ll_resolv_list[rpa_index].rl_addr_type + 2;
    c9a0:	bfa1      	itttt	ge
    c9a2:	785a      	ldrbge	r2, [r3, #1]
    c9a4:	3202      	addge	r2, #2
    c9a6:	b2d2      	uxtbge	r2, r2
                addr = g_ble_ll_resolv_list[rpa_index].rl_identity_addr;
    c9a8:	3302      	addge	r3, #2
            } else {
                addr = rxbuf + BLE_LL_PDU_HDR_LEN;
    c9aa:	bfb8      	it	lt
    c9ac:	1cab      	addlt	r3, r5, #2
            }

            connsm->peer_addr_type = addr_type;
    c9ae:	f884 207d 	strb.w	r2, [r4, #125]	; 0x7d
            memcpy(connsm->peer_addr, addr, BLE_DEV_ADDR_LEN);
    c9b2:	681a      	ldr	r2, [r3, #0]
    c9b4:	f8c4 207e 	str.w	r2, [r4, #126]	; 0x7e
    c9b8:	889b      	ldrh	r3, [r3, #4]
    c9ba:	f8a4 3082 	strh.w	r3, [r4, #130]	; 0x82
        }

        if (connsm->rpa_index >= 0) {
    c9be:	f994 3031 	ldrsb.w	r3, [r4, #49]	; 0x31
    c9c2:	2b00      	cmp	r3, #0
    c9c4:	db02      	blt.n	c9cc <ble_ll_init_rx_pkt_in+0x5c>
            ble_ll_scan_set_peer_rpa(rxbuf + BLE_LL_PDU_HDR_LEN);
    c9c6:	1ca8      	adds	r0, r5, #2
    c9c8:	f003 fc6e 	bl	102a8 <ble_ll_scan_set_peer_rpa>
        }

        /* Connection has been created. Stop scanning */
        g_ble_ll_conn_create_sm = NULL;
    c9cc:	2000      	movs	r0, #0
    c9ce:	6030      	str	r0, [r6, #0]
        ble_ll_scan_sm_stop(0);
    c9d0:	f003 f8c6 	bl	fb60 <ble_ll_scan_sm_stop>
        payload_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
    c9d4:	786b      	ldrb	r3, [r5, #1]
        endtime = ble_hdr->beg_cputime + BLE_TX_DUR_USECS_M(payload_len);
    c9d6:	6879      	ldr	r1, [r7, #4]
    c9d8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c9dc:	330a      	adds	r3, #10
        ble_ll_conn_created(connsm, endtime);
    c9de:	4620      	mov	r0, r4
    c9e0:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    } else {
        ble_ll_scan_chk_resume();
    }
}
    c9e4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        /* Connection has been created. Stop scanning */
        g_ble_ll_conn_create_sm = NULL;
        ble_ll_scan_sm_stop(0);
        payload_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
        endtime = ble_hdr->beg_cputime + BLE_TX_DUR_USECS_M(payload_len);
        ble_ll_conn_created(connsm, endtime);
    c9e8:	f7ff bd22 	b.w	c430 <ble_ll_conn_created>
    } else {
        ble_ll_scan_chk_resume();
    }
}
    c9ec:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        ble_ll_scan_sm_stop(0);
        payload_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
        endtime = ble_hdr->beg_cputime + BLE_TX_DUR_USECS_M(payload_len);
        ble_ll_conn_created(connsm, endtime);
    } else {
        ble_ll_scan_chk_resume();
    c9f0:	f003 ba48 	b.w	fe84 <ble_ll_scan_chk_resume>
    c9f4:	200033d8 	.word	0x200033d8
    c9f8:	20003624 	.word	0x20003624

0000c9fc <ble_ll_init_rx_isr_end>:
 *      == 0: Success. Do not disable the PHY.
 *       > 0: Do not disable PHY as that has already been done.
 */
int
ble_ll_init_rx_isr_end(struct os_mbuf *rxpdu, uint8_t crcok)
{
    c9fc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /*
     * We have to restart receive if we cant hand up pdu. We return 0 so that
     * the phy does not get disabled.
     */
    if (!rxpdu) {
    ca00:	4604      	mov	r4, r0
    ca02:	b920      	cbnz	r0, ca0e <ble_ll_init_rx_isr_end+0x12>
        ble_phy_disable();
    ca04:	f004 fc0a 	bl	1121c <ble_phy_disable>
        ble_phy_rx();
    ca08:	f004 fd54 	bl	114b4 <ble_phy_rx>
        return 0;
    ca0c:	e12f      	b.n	cc6e <ble_ll_init_rx_isr_end+0x272>
    }

    rc = -1;
    if (!crcok) {
    ca0e:	2900      	cmp	r1, #0
    ca10:	d06c      	beq.n	caec <ble_ll_init_rx_isr_end+0xf0>

    /* Get connection state machine to use if connection to be established */
    connsm = g_ble_ll_conn_create_sm;

    /* Only interested in ADV IND or ADV DIRECT IND */
    rxbuf = rxpdu->om_data;
    ca12:	6805      	ldr	r5, [r0, #0]
    if (!crcok) {
        goto init_rx_isr_exit;
    }

    /* Get connection state machine to use if connection to be established */
    connsm = g_ble_ll_conn_create_sm;
    ca14:	4a98      	ldr	r2, [pc, #608]	; (cc78 <ble_ll_init_rx_isr_end+0x27c>)

    /* Only interested in ADV IND or ADV DIRECT IND */
    rxbuf = rxpdu->om_data;
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    ca16:	782b      	ldrb	r3, [r5, #0]
    pyld_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
    ca18:	7869      	ldrb	r1, [r5, #1]
    if (!crcok) {
        goto init_rx_isr_exit;
    }

    /* Get connection state machine to use if connection to be established */
    connsm = g_ble_ll_conn_create_sm;
    ca1a:	f8d2 8000 	ldr.w	r8, [r2]

    /* Only interested in ADV IND or ADV DIRECT IND */
    rxbuf = rxpdu->om_data;
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    pyld_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
    ca1e:	9101      	str	r1, [sp, #4]

    inita_is_rpa = 0;

    switch (pdu_type) {
    ca20:	f013 070f 	ands.w	r7, r3, #15
    ca24:	9200      	str	r2, [sp, #0]
    ca26:	d01c      	beq.n	ca62 <ble_ll_init_rx_isr_end+0x66>
    ca28:	2f01      	cmp	r7, #1
    ca2a:	d15f      	bne.n	caec <ble_ll_init_rx_isr_end+0xf0>
        break;
    case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
        /* XXX: needs to be fixed for privacy */
        chk_send_req = 0;
        init_addr = rxbuf + BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN;
        addr_type = rxbuf[0] & BLE_ADV_PDU_HDR_RXADD_MASK;
    ca2c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
        chk_send_req = 1;
        break;
    case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
        /* XXX: needs to be fixed for privacy */
        chk_send_req = 0;
        init_addr = rxbuf + BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN;
    ca30:	f105 0908 	add.w	r9, r5, #8
        addr_type = rxbuf[0] & BLE_ADV_PDU_HDR_RXADD_MASK;
        if (addr_type) {
    ca34:	f003 06ff 	and.w	r6, r3, #255	; 0xff
    ca38:	b12b      	cbz	r3, ca46 <ble_ll_init_rx_isr_end+0x4a>
            inita_is_rpa = (uint8_t)ble_ll_is_rpa(init_addr, addr_type);
    ca3a:	4648      	mov	r0, r9
    ca3c:	4631      	mov	r1, r6
    ca3e:	f7fe fa09 	bl	ae54 <ble_ll_is_rpa>
    ca42:	b2c7      	uxtb	r7, r0
    ca44:	e000      	b.n	ca48 <ble_ll_init_rx_isr_end+0x4c>
    /* Only interested in ADV IND or ADV DIRECT IND */
    rxbuf = rxpdu->om_data;
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    pyld_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;

    inita_is_rpa = 0;
    ca46:	4637      	mov	r7, r6

        /*
         * If we expect our address to be private and the INITA is not,
         * we dont respond!
         */
        if (connsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    ca48:	f898 307c 	ldrb.w	r3, [r8, #124]	; 0x7c
    ca4c:	2b01      	cmp	r3, #1
    ca4e:	d902      	bls.n	ca56 <ble_ll_init_rx_isr_end+0x5a>
            if (!inita_is_rpa) {
    ca50:	2f00      	cmp	r7, #0
    ca52:	d04b      	beq.n	caec <ble_ll_init_rx_isr_end+0xf0>
    ca54:	e005      	b.n	ca62 <ble_ll_init_rx_isr_end+0x66>
                goto init_rx_isr_exit;
            } else {
                chk_send_req = 1;
            }
        } else {
            if (ble_ll_is_our_devaddr(init_addr, addr_type)) {
    ca56:	4648      	mov	r0, r9
    ca58:	4631      	mov	r1, r6
    ca5a:	f7fe fa4d 	bl	aef8 <ble_ll_is_our_devaddr>
    ca5e:	2800      	cmp	r0, #0
    ca60:	d044      	beq.n	caec <ble_ll_init_rx_isr_end+0xf0>
    }

    /* Should we send a connect request? */
    if (chk_send_req) {
        /* Get advertisers address type */
        adv_addr = rxbuf + BLE_LL_PDU_HDR_LEN;
    ca62:	1cae      	adds	r6, r5, #2
        if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
    ca64:	782d      	ldrb	r5, [r5, #0]
        ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
        peer = adv_addr;
        peer_addr_type = addr_type;

        resolved = 0;
        chk_wl = ble_ll_scan_whitelist_enabled();
    ca66:	f003 fc2d 	bl	102c4 <ble_ll_scan_whitelist_enabled>

    /* Should we send a connect request? */
    if (chk_send_req) {
        /* Get advertisers address type */
        adv_addr = rxbuf + BLE_LL_PDU_HDR_LEN;
        if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
    ca6a:	f3c5 1580 	ubfx	r5, r5, #6, #1
        ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
        peer = adv_addr;
        peer_addr_type = addr_type;

        resolved = 0;
        chk_wl = ble_ll_scan_whitelist_enabled();
    ca6e:	4682      	mov	sl, r0

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
        if (ble_ll_is_rpa(adv_addr, addr_type) && ble_ll_resolv_enabled()) {
    ca70:	4629      	mov	r1, r5
    ca72:	4630      	mov	r0, r6
    ca74:	f7fe f9ee 	bl	ae54 <ble_ll_is_rpa>
    ca78:	4602      	mov	r2, r0
    ca7a:	2800      	cmp	r0, #0
    ca7c:	d041      	beq.n	cb02 <ble_ll_init_rx_isr_end+0x106>
    ca7e:	f002 ff1b 	bl	f8b8 <ble_ll_resolv_enabled>
    ca82:	4602      	mov	r2, r0
    ca84:	2800      	cmp	r0, #0
    ca86:	d03c      	beq.n	cb02 <ble_ll_init_rx_isr_end+0x106>
            index = ble_hw_resolv_list_match();
    ca88:	f004 f9b8 	bl	10dfc <ble_hw_resolv_list_match>
            if (index >= 0) {
    ca8c:	f1b0 0b00 	subs.w	fp, r0, #0
    ca90:	db33      	blt.n	cafa <ble_ll_init_rx_isr_end+0xfe>
                ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_RESOLVED;
    ca92:	7e22      	ldrb	r2, [r4, #24]
                connsm->rpa_index = index;
                peer = g_ble_ll_resolv_list[index].rl_identity_addr;
    ca94:	4979      	ldr	r1, [pc, #484]	; (cc7c <ble_ll_init_rx_isr_end+0x280>)

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
        if (ble_ll_is_rpa(adv_addr, addr_type) && ble_ll_resolv_enabled()) {
            index = ble_hw_resolv_list_match();
            if (index >= 0) {
                ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_RESOLVED;
    ca96:	f042 0204 	orr.w	r2, r2, #4
    ca9a:	7622      	strb	r2, [r4, #24]
                connsm->rpa_index = index;
                peer = g_ble_ll_resolv_list[index].rl_identity_addr;
    ca9c:	2228      	movs	r2, #40	; 0x28
    ca9e:	fb02 120b 	mla	r2, r2, fp, r1
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
        if (ble_ll_is_rpa(adv_addr, addr_type) && ble_ll_resolv_enabled()) {
            index = ble_hw_resolv_list_match();
            if (index >= 0) {
                ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_RESOLVED;
                connsm->rpa_index = index;
    caa2:	f888 b031 	strb.w	fp, [r8, #49]	; 0x31
                peer = g_ble_ll_resolv_list[index].rl_identity_addr;
    caa6:	1c90      	adds	r0, r2, #2
                peer_addr_type = g_ble_ll_resolv_list[index].rl_addr_type;
    caa8:	7851      	ldrb	r1, [r2, #1]
                resolved = 1;
    caaa:	2201      	movs	r2, #1
            }
        }
#endif

        /* Check filter policy */
        if (chk_wl) {
    caac:	f1ba 0f00 	cmp.w	sl, #0
    cab0:	d02c      	beq.n	cb0c <ble_ll_init_rx_isr_end+0x110>
            if (!ble_ll_whitelist_match(peer, peer_addr_type, resolved)) {
    cab2:	f003 fff1 	bl	10a98 <ble_ll_whitelist_match>
    cab6:	2800      	cmp	r0, #0
    cab8:	f000 80d7 	beq.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
            /* Must match the connection address */
            if (!ble_ll_conn_is_peer_adv(addr_type, adv_addr, index)) {
                return -1;
            }
        }
        ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_DEVMATCH;
    cabc:	7e22      	ldrb	r2, [r4, #24]
    cabe:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    cac2:	7622      	strb	r2, [r4, #24]

        /*
         * If the inita is a RPA, we must see if it resolves based on the
         * identity address of the resolved ADVA.
         */
        if (inita_is_rpa) {
    cac4:	2f00      	cmp	r7, #0
    cac6:	d157      	bne.n	cb78 <ble_ll_init_rx_isr_end+0x17c>
                return -1;
            }
        }

        /* Attempt to schedule new connection. Possible that this might fail */
        endtime = ble_hdr->beg_cputime + BLE_TX_DUR_USECS_M(pyld_len);
    cac8:	9b01      	ldr	r3, [sp, #4]
    caca:	69e2      	ldr	r2, [r4, #28]
    cacc:	f003 013f 	and.w	r1, r3, #63	; 0x3f
    cad0:	310a      	adds	r1, #10
        if (!ble_ll_sched_master_new(connsm, endtime,
    cad2:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
    cad6:	4640      	mov	r0, r8
    cad8:	2202      	movs	r2, #2
    cada:	f003 fd7b 	bl	105d4 <ble_ll_sched_master_new>
    cade:	4604      	mov	r4, r0
    cae0:	2800      	cmp	r0, #0
    cae2:	d056      	beq.n	cb92 <ble_ll_init_rx_isr_end+0x196>
                CONN_F_CONN_REQ_TXD(connsm) = 1;
                STATS_INC(ble_ll_conn_stats, conn_req_txd);
            }
        } else {
            /* Count # of times we could not set schedule */
            STATS_INC(ble_ll_conn_stats, cant_set_sched);
    cae4:	4a66      	ldr	r2, [pc, #408]	; (cc80 <ble_ll_init_rx_isr_end+0x284>)
    cae6:	68d3      	ldr	r3, [r2, #12]
    cae8:	3301      	adds	r3, #1
    caea:	60d3      	str	r3, [r2, #12]
        ble_phy_disable();
        ble_phy_rx();
        return 0;
    }

    rc = -1;
    caec:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
        }
    }

init_rx_isr_exit:
    if (rc) {
        ble_ll_state_set(BLE_LL_STATE_STANDBY);
    caf0:	2000      	movs	r0, #0
    caf2:	f7fe faf7 	bl	b0e4 <ble_ll_state_set>
    caf6:	462c      	mov	r4, r5
    caf8:	e0b9      	b.n	cc6e <ble_ll_init_rx_isr_end+0x272>
                connsm->rpa_index = index;
                peer = g_ble_ll_resolv_list[index].rl_identity_addr;
                peer_addr_type = g_ble_ll_resolv_list[index].rl_addr_type;
                resolved = 1;
            } else {
                if (chk_wl) {
    cafa:	f1ba 0f00 	cmp.w	sl, #0
    cafe:	d005      	beq.n	cb0c <ble_ll_init_rx_isr_end+0x110>
    cb00:	e0b3      	b.n	cc6a <ble_ll_init_rx_isr_end+0x26e>
    }

    /* Should we send a connect request? */
    if (chk_send_req) {
        /* Get advertisers address type */
        adv_addr = rxbuf + BLE_LL_PDU_HDR_LEN;
    cb02:	4630      	mov	r0, r6
        if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
            addr_type = BLE_HCI_CONN_PEER_ADDR_RANDOM;
    cb04:	4629      	mov	r1, r5
        } else {
            addr_type = BLE_HCI_CONN_PEER_ADDR_PUBLIC;
        }

        index = -1;
    cb06:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    cb0a:	e7cf      	b.n	caac <ble_ll_init_rx_isr_end+0xb0>
    int rc;
    uint8_t *peer_addr;
    struct ble_ll_conn_sm *connsm;

    /* XXX: Deal with different types of random addresses here! */
    connsm = g_ble_ll_conn_create_sm;
    cb0c:	9b00      	ldr	r3, [sp, #0]
    cb0e:	6819      	ldr	r1, [r3, #0]
    if (!connsm) {
    cb10:	2900      	cmp	r1, #0
    cb12:	f000 80aa 	beq.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
        return 0;
    }

    switch (connsm->peer_addr_type) {
    cb16:	f891 207d 	ldrb.w	r2, [r1, #125]	; 0x7d
    cb1a:	2a03      	cmp	r2, #3
    cb1c:	f200 80a5 	bhi.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
    cb20:	e8df f002 	tbb	[pc, r2]
    cb24:	11060202 	.word	0x11060202
    /* Fall-through intentional */
    case BLE_HCI_CONN_PEER_ADDR_PUBLIC:
    case BLE_HCI_CONN_PEER_ADDR_RANDOM:
        if (addr_type != connsm->peer_addr_type) {
    cb28:	4295      	cmp	r5, r2
    cb2a:	f040 809e 	bne.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
    cb2e:	e018      	b.n	cb62 <ble_ll_init_rx_isr_end+0x166>
            return 0;
        }
        peer_addr = adva;
        break;
    case BLE_HCI_CONN_PEER_ADDR_PUBLIC_IDENT:
        if ((index < 0) ||
    cb30:	f1bb 0f00 	cmp.w	fp, #0
    cb34:	f2c0 8099 	blt.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
            (g_ble_ll_resolv_list[index].rl_addr_type != 0)) {
    cb38:	4850      	ldr	r0, [pc, #320]	; (cc7c <ble_ll_init_rx_isr_end+0x280>)
    cb3a:	2228      	movs	r2, #40	; 0x28
    cb3c:	fb02 000b 	mla	r0, r2, fp, r0
            return 0;
        }
        peer_addr = adva;
        break;
    case BLE_HCI_CONN_PEER_ADDR_PUBLIC_IDENT:
        if ((index < 0) ||
    cb40:	7842      	ldrb	r2, [r0, #1]
    cb42:	b162      	cbz	r2, cb5e <ble_ll_init_rx_isr_end+0x162>
    cb44:	e091      	b.n	cc6a <ble_ll_init_rx_isr_end+0x26e>
            return 0;
        }
        peer_addr = g_ble_ll_resolv_list[index].rl_identity_addr;
        break;
    case BLE_HCI_CONN_PEER_ADDR_RANDOM_IDENT:
        if ((index < 0) ||
    cb46:	f1bb 0f00 	cmp.w	fp, #0
    cb4a:	f2c0 808e 	blt.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
            (g_ble_ll_resolv_list[index].rl_addr_type != 1)) {
    cb4e:	484b      	ldr	r0, [pc, #300]	; (cc7c <ble_ll_init_rx_isr_end+0x280>)
    cb50:	2228      	movs	r2, #40	; 0x28
    cb52:	fb02 000b 	mla	r0, r2, fp, r0
            return 0;
        }
        peer_addr = g_ble_ll_resolv_list[index].rl_identity_addr;
        break;
    case BLE_HCI_CONN_PEER_ADDR_RANDOM_IDENT:
        if ((index < 0) ||
    cb56:	7842      	ldrb	r2, [r0, #1]
    cb58:	2a01      	cmp	r2, #1
    cb5a:	f040 8086 	bne.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
            (g_ble_ll_resolv_list[index].rl_addr_type != 1)) {
            return 0;
        }
        peer_addr = g_ble_ll_resolv_list[index].rl_identity_addr;
    cb5e:	3002      	adds	r0, #2
    cb60:	e003      	b.n	cb6a <ble_ll_init_rx_isr_end+0x16e>
        peer_addr = NULL;
        break;
    }

    rc = 0;
    if (peer_addr) {
    cb62:	2e00      	cmp	r6, #0
    cb64:	f000 8081 	beq.w	cc6a <ble_ll_init_rx_isr_end+0x26e>
    cb68:	4630      	mov	r0, r6
        if (!memcmp(peer_addr, connsm->peer_addr, BLE_DEV_ADDR_LEN)) {
    cb6a:	317e      	adds	r1, #126	; 0x7e
    cb6c:	2206      	movs	r2, #6
    cb6e:	f7fc fa37 	bl	8fe0 <memcmp>
    cb72:	2800      	cmp	r0, #0
    cb74:	d179      	bne.n	cc6a <ble_ll_init_rx_isr_end+0x26e>
    cb76:	e7a1      	b.n	cabc <ble_ll_init_rx_isr_end+0xc0>
        /*
         * If the inita is a RPA, we must see if it resolves based on the
         * identity address of the resolved ADVA.
         */
        if (inita_is_rpa) {
            if ((index < 0) ||
    cb78:	f1bb 0f00 	cmp.w	fp, #0
    cb7c:	db75      	blt.n	cc6a <ble_ll_init_rx_isr_end+0x26e>
                !ble_ll_resolv_rpa(init_addr,
    cb7e:	4a41      	ldr	r2, [pc, #260]	; (cc84 <ble_ll_init_rx_isr_end+0x288>)
    cb80:	2128      	movs	r1, #40	; 0x28
    cb82:	4648      	mov	r0, r9
    cb84:	fb01 210b 	mla	r1, r1, fp, r2
    cb88:	f002 fe64 	bl	f854 <ble_ll_resolv_rpa>
        /*
         * If the inita is a RPA, we must see if it resolves based on the
         * identity address of the resolved ADVA.
         */
        if (inita_is_rpa) {
            if ((index < 0) ||
    cb8c:	2800      	cmp	r0, #0
    cb8e:	d19b      	bne.n	cac8 <ble_ll_init_rx_isr_end+0xcc>
    cb90:	e06b      	b.n	cc6a <ble_ll_init_rx_isr_end+0x26e>
        /* Attempt to schedule new connection. Possible that this might fail */
        endtime = ble_hdr->beg_cputime + BLE_TX_DUR_USECS_M(pyld_len);
        if (!ble_ll_sched_master_new(connsm, endtime,
                                     NIMBLE_OPT_LL_CONN_INIT_SLOTS)) {
            /* Setup to transmit the connect request */
            rc = ble_ll_conn_request_send(addr_type, adv_addr,
    cb92:	f8b8 306a 	ldrh.w	r3, [r8, #106]	; 0x6a
    cb96:	9301      	str	r3, [sp, #4]
                         int rpa_index)
{
    int rc;
    struct os_mbuf *m;

    m = ble_ll_scan_get_pdu();
    cb98:	f003 fb8e 	bl	102b8 <ble_ll_scan_get_pdu>
    uint8_t *addr;
    struct ble_mbuf_hdr *ble_hdr;
    struct ble_ll_resolv_entry *rl;
    struct ble_ll_conn_sm *connsm;

    assert(m != NULL);
    cb9c:	4681      	mov	r9, r0
    cb9e:	b930      	cbnz	r0, cbae <ble_ll_init_rx_isr_end+0x1b2>
    cba0:	4839      	ldr	r0, [pc, #228]	; (cc88 <ble_ll_init_rx_isr_end+0x28c>)
    cba2:	f240 71ab 	movw	r1, #1963	; 0x7ab
    cba6:	464a      	mov	r2, r9
    cba8:	464b      	mov	r3, r9
    cbaa:	f7fd f891 	bl	9cd0 <__assert_func>

    /* Retain pdu type but clear txadd/rxadd bits */
    ble_hdr = BLE_MBUF_HDR_PTR(m);
    hdr = ble_hdr->txinfo.hdr_byte & BLE_ADV_PDU_HDR_TYPE_MASK;
    cbae:	7ec7      	ldrb	r7, [r0, #27]
    cbb0:	f007 070f 	and.w	r7, r7, #15
    if (addr_type) {
    cbb4:	b10d      	cbz	r5, cbba <ble_ll_init_rx_isr_end+0x1be>
        /* Set random address */
        hdr |= BLE_ADV_PDU_HDR_RXADD_MASK;
    cbb6:	f047 0780 	orr.w	r7, r7, #128	; 0x80

    dptr = m->om_data;

    /* Get pointer to our device address */
    connsm = g_ble_ll_conn_create_sm;
    if ((connsm->own_addr_type & 1) == 0) {
    cbba:	9b00      	ldr	r3, [sp, #0]
    if (addr_type) {
        /* Set random address */
        hdr |= BLE_ADV_PDU_HDR_RXADD_MASK;
    }

    dptr = m->om_data;
    cbbc:	f8d9 a000 	ldr.w	sl, [r9]

    /* Get pointer to our device address */
    connsm = g_ble_ll_conn_create_sm;
    if ((connsm->own_addr_type & 1) == 0) {
    cbc0:	681a      	ldr	r2, [r3, #0]
    cbc2:	f892 207c 	ldrb.w	r2, [r2, #124]	; 0x7c
    cbc6:	07d3      	lsls	r3, r2, #31
        addr = g_dev_addr;
    } else {
        hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
        addr = g_random_addr;
    cbc8:	bf4c      	ite	mi
    cbca:	4b30      	ldrmi	r3, [pc, #192]	; (cc8c <ble_ll_init_rx_isr_end+0x290>)
    dptr = m->om_data;

    /* Get pointer to our device address */
    connsm = g_ble_ll_conn_create_sm;
    if ((connsm->own_addr_type & 1) == 0) {
        addr = g_dev_addr;
    cbcc:	4b30      	ldrpl	r3, [pc, #192]	; (cc90 <ble_ll_init_rx_isr_end+0x294>)
    cbce:	9300      	str	r3, [sp, #0]
    } else {
        hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
    cbd0:	bf48      	it	mi
    cbd2:	f047 0740 	orrmi.w	r7, r7, #64	; 0x40
        addr = g_random_addr;
    }

    /* XXX: do this ahead of time? Calculate the local rpa I mean */
    if (connsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    cbd6:	2a01      	cmp	r2, #1
    cbd8:	d91b      	bls.n	cc12 <ble_ll_init_rx_isr_end+0x216>
        rl = NULL;
        is_rpa = ble_ll_is_rpa(adva, addr_type);
    cbda:	4630      	mov	r0, r6
    cbdc:	4629      	mov	r1, r5
    cbde:	f7fe f939 	bl	ae54 <ble_ll_is_rpa>
        if (is_rpa) {
    cbe2:	b138      	cbz	r0, cbf4 <ble_ll_init_rx_isr_end+0x1f8>
            if (rpa_index >= 0) {
    cbe4:	f1bb 0f00 	cmp.w	fp, #0
    cbe8:	db13      	blt.n	cc12 <ble_ll_init_rx_isr_end+0x216>
                rl = &g_ble_ll_resolv_list[rpa_index];
    cbea:	4824      	ldr	r0, [pc, #144]	; (cc7c <ble_ll_init_rx_isr_end+0x280>)
    cbec:	2228      	movs	r2, #40	; 0x28
    cbee:	fb02 000b 	mla	r0, r2, fp, r0
    cbf2:	e007      	b.n	cc04 <ble_ll_init_rx_isr_end+0x208>
            }
        } else {
            if (ble_ll_resolv_enabled()) {
    cbf4:	f002 fe60 	bl	f8b8 <ble_ll_resolv_enabled>
    cbf8:	b158      	cbz	r0, cc12 <ble_ll_init_rx_isr_end+0x216>
                rl = ble_ll_resolv_list_find(adva, addr_type);
    cbfa:	4630      	mov	r0, r6
    cbfc:	4629      	mov	r1, r5
    cbfe:	f002 fd0f 	bl	f620 <ble_ll_resolv_list_find>
            }
        }

        if (rl) {
    cc02:	b130      	cbz	r0, cc12 <ble_ll_init_rx_isr_end+0x216>
            hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
            ble_ll_resolv_gen_priv_addr(rl, 1, dptr);
    cc04:	2101      	movs	r1, #1
    cc06:	4652      	mov	r2, sl
                rl = ble_ll_resolv_list_find(adva, addr_type);
            }
        }

        if (rl) {
            hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
    cc08:	f047 0740 	orr.w	r7, r7, #64	; 0x40
            ble_ll_resolv_gen_priv_addr(rl, 1, dptr);
    cc0c:	f002 fdca 	bl	f7a4 <ble_ll_resolv_gen_priv_addr>
    cc10:	e007      	b.n	cc22 <ble_ll_init_rx_isr_end+0x226>
            addr = NULL;
        }
    }

    if (addr) {
        memcpy(dptr, addr, BLE_DEV_ADDR_LEN);
    cc12:	9b00      	ldr	r3, [sp, #0]
    cc14:	681b      	ldr	r3, [r3, #0]
    cc16:	f8ca 3000 	str.w	r3, [sl]
    cc1a:	9b00      	ldr	r3, [sp, #0]
    cc1c:	889b      	ldrh	r3, [r3, #4]
    cc1e:	f8aa 3004 	strh.w	r3, [sl, #4]
    }
    memcpy(dptr + BLE_DEV_ADDR_LEN, adva, BLE_DEV_ADDR_LEN);
    cc22:	6833      	ldr	r3, [r6, #0]
    cc24:	f8ca 3006 	str.w	r3, [sl, #6]
    cc28:	88b3      	ldrh	r3, [r6, #4]
    cc2a:	f8aa 300a 	strh.w	r3, [sl, #10]
    htole16(dptr + 20, txoffset);
    cc2e:	f10a 0014 	add.w	r0, sl, #20
    cc32:	9901      	ldr	r1, [sp, #4]
    cc34:	f010 fa10 	bl	1d058 <htole16>
    int rc;
    struct os_mbuf *m;

    m = ble_ll_scan_get_pdu();
    ble_ll_conn_req_pdu_update(m, adva, addr_type, txoffset, rpa_index);
    ble_phy_set_txend_cb(ble_ll_conn_req_txend, NULL);
    cc38:	4816      	ldr	r0, [pc, #88]	; (cc94 <ble_ll_init_rx_isr_end+0x298>)
    }
    memcpy(dptr + BLE_DEV_ADDR_LEN, adva, BLE_DEV_ADDR_LEN);
    htole16(dptr + 20, txoffset);

    /* Set BLE transmit header */
    ble_hdr->txinfo.hdr_byte = hdr;
    cc3a:	f889 701b 	strb.w	r7, [r9, #27]
    int rc;
    struct os_mbuf *m;

    m = ble_ll_scan_get_pdu();
    ble_ll_conn_req_pdu_update(m, adva, addr_type, txoffset, rpa_index);
    ble_phy_set_txend_cb(ble_ll_conn_req_txend, NULL);
    cc3e:	2100      	movs	r1, #0
    cc40:	f004 fa72 	bl	11128 <ble_phy_set_txend_cb>
    rc = ble_phy_tx(m, BLE_PHY_TRANSITION_NONE);
    cc44:	4648      	mov	r0, r9
    cc46:	2100      	movs	r1, #0
    cc48:	f004 fc8e 	bl	11568 <ble_phy_tx>
        if (!ble_ll_sched_master_new(connsm, endtime,
                                     NIMBLE_OPT_LL_CONN_INIT_SLOTS)) {
            /* Setup to transmit the connect request */
            rc = ble_ll_conn_request_send(addr_type, adv_addr,
                                          connsm->tx_win_off, index);
            if (!rc) {
    cc4c:	4605      	mov	r5, r0
    cc4e:	2800      	cmp	r0, #0
    cc50:	f47f af4e 	bne.w	caf0 <ble_ll_init_rx_isr_end+0xf4>
                CONN_F_CONN_REQ_TXD(connsm) = 1;
    cc54:	f898 3001 	ldrb.w	r3, [r8, #1]
                STATS_INC(ble_ll_conn_stats, conn_req_txd);
    cc58:	4a09      	ldr	r2, [pc, #36]	; (cc80 <ble_ll_init_rx_isr_end+0x284>)
                                     NIMBLE_OPT_LL_CONN_INIT_SLOTS)) {
            /* Setup to transmit the connect request */
            rc = ble_ll_conn_request_send(addr_type, adv_addr,
                                          connsm->tx_win_off, index);
            if (!rc) {
                CONN_F_CONN_REQ_TXD(connsm) = 1;
    cc5a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    cc5e:	f888 3001 	strb.w	r3, [r8, #1]
                STATS_INC(ble_ll_conn_stats, conn_req_txd);
    cc62:	6c13      	ldr	r3, [r2, #64]	; 0x40
    cc64:	3301      	adds	r3, #1
    cc66:	6413      	str	r3, [r2, #64]	; 0x40
    cc68:	e001      	b.n	cc6e <ble_ll_init_rx_isr_end+0x272>
                return -1;
            }
        } else {
            /* Must match the connection address */
            if (!ble_ll_conn_is_peer_adv(addr_type, adv_addr, index)) {
                return -1;
    cc6a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
init_rx_isr_exit:
    if (rc) {
        ble_ll_state_set(BLE_LL_STATE_STANDBY);
    }
    return rc;
}
    cc6e:	4620      	mov	r0, r4
    cc70:	b003      	add	sp, #12
    cc72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cc76:	bf00      	nop
    cc78:	200033d8 	.word	0x200033d8
    cc7c:	20003624 	.word	0x20003624
    cc80:	20003580 	.word	0x20003580
    cc84:	2000362c 	.word	0x2000362c
    cc88:	0001f253 	.word	0x0001f253
    cc8c:	20002810 	.word	0x20002810
    cc90:	200000d8 	.word	0x200000d8
    cc94:	0000bbf1 	.word	0x0000bbf1

0000cc98 <ble_ll_conn_timeout>:
 * @param connsm
 * @param ble_err
 */
void
ble_ll_conn_timeout(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
{
    cc98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cc9a:	4604      	mov	r4, r0
    cc9c:	460e      	mov	r6, r1
    int was_current;
    os_sr_t sr;

    was_current = 0;
    OS_ENTER_CRITICAL(sr);
    cc9e:	f7fc fe3f 	bl	9920 <os_arch_save_sr>
    if (g_ble_ll_conn_cur_sm == connsm) {
    cca2:	4b0b      	ldr	r3, [pc, #44]	; (ccd0 <ble_ll_conn_timeout+0x38>)
    cca4:	681b      	ldr	r3, [r3, #0]
    cca6:	42a3      	cmp	r3, r4
{
    int was_current;
    os_sr_t sr;

    was_current = 0;
    OS_ENTER_CRITICAL(sr);
    cca8:	4607      	mov	r7, r0
    if (g_ble_ll_conn_cur_sm == connsm) {
    ccaa:	d103      	bne.n	ccb4 <ble_ll_conn_timeout+0x1c>
        ble_ll_conn_current_sm_over();
    ccac:	f7fe ff6c 	bl	bb88 <ble_ll_conn_current_sm_over>
        was_current = 1;
    ccb0:	2501      	movs	r5, #1
    ccb2:	e000      	b.n	ccb6 <ble_ll_conn_timeout+0x1e>
ble_ll_conn_timeout(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
{
    int was_current;
    os_sr_t sr;

    was_current = 0;
    ccb4:	2500      	movs	r5, #0
    OS_ENTER_CRITICAL(sr);
    if (g_ble_ll_conn_cur_sm == connsm) {
        ble_ll_conn_current_sm_over();
        was_current = 1;
    }
    OS_EXIT_CRITICAL(sr);
    ccb6:	4638      	mov	r0, r7
    ccb8:	f7fc fe38 	bl	992c <os_arch_restore_sr>

    /* Check if we need to resume scanning */
    if (was_current) {
    ccbc:	b10d      	cbz	r5, ccc2 <ble_ll_conn_timeout+0x2a>
        ble_ll_scan_chk_resume();
    ccbe:	f003 f8e1 	bl	fe84 <ble_ll_scan_chk_resume>
    }

    ble_ll_conn_end(connsm, ble_err);
    ccc2:	4620      	mov	r0, r4
    ccc4:	4631      	mov	r1, r6
}
    ccc6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Check if we need to resume scanning */
    if (was_current) {
        ble_ll_scan_chk_resume();
    }

    ble_ll_conn_end(connsm, ble_err);
    ccca:	f7ff bd8b 	b.w	c7e4 <ble_ll_conn_end>
    ccce:	bf00      	nop
    ccd0:	200033cc 	.word	0x200033cc

0000ccd4 <ble_ll_conn_spvn_timeout>:
 * @param arg Pointer to connection state machine.
 */
void
ble_ll_conn_spvn_timeout(void *arg)
{
    ble_ll_conn_timeout((struct ble_ll_conn_sm *)arg, BLE_ERR_CONN_SPVN_TMO);
    ccd4:	2108      	movs	r1, #8
    ccd6:	f7ff bfdf 	b.w	cc98 <ble_ll_conn_timeout>
	...

0000ccdc <ble_ll_conn_rx_isr_start>:
 *
 * @param rxhdr
 */
int
ble_ll_conn_rx_isr_start(struct ble_mbuf_hdr *rxhdr, uint32_t aa)
{
    ccdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     * care if this is the response we were waiting for or not; the code
     * called at receive end will deal with ending the connection event
     * if needed
     */
    ble_ll_wfr_disable();
    connsm = g_ble_ll_conn_cur_sm;
    ccde:	4e15      	ldr	r6, [pc, #84]	; (cd34 <ble_ll_conn_rx_isr_start+0x58>)
 *
 * @param rxhdr
 */
int
ble_ll_conn_rx_isr_start(struct ble_mbuf_hdr *rxhdr, uint32_t aa)
{
    cce0:	4605      	mov	r5, r0
    cce2:	460f      	mov	r7, r1
     * Disable wait for response timer since we receive a response. We dont
     * care if this is the response we were waiting for or not; the code
     * called at receive end will deal with ending the connection event
     * if needed
     */
    ble_ll_wfr_disable();
    cce4:	f7fe f922 	bl	af2c <ble_ll_wfr_disable>
    connsm = g_ble_ll_conn_cur_sm;
    cce8:	6834      	ldr	r4, [r6, #0]
    if (connsm) {
    ccea:	b30c      	cbz	r4, cd30 <ble_ll_conn_rx_isr_start+0x54>
        /* Double check access address. Better match connection state machine */
        if (aa != connsm->access_addr) {
    ccec:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    ccee:	429f      	cmp	r7, r3
    ccf0:	d00f      	beq.n	cd12 <ble_ll_conn_rx_isr_start+0x36>
            STATS_INC(ble_ll_conn_stats, rx_data_pdu_bad_aa);
    ccf2:	4a11      	ldr	r2, [pc, #68]	; (cd38 <ble_ll_conn_rx_isr_start+0x5c>)
    ccf4:	6a93      	ldr	r3, [r2, #40]	; 0x28
            ble_ll_state_set(BLE_LL_STATE_STANDBY);
    ccf6:	2000      	movs	r0, #0
    ble_ll_wfr_disable();
    connsm = g_ble_ll_conn_cur_sm;
    if (connsm) {
        /* Double check access address. Better match connection state machine */
        if (aa != connsm->access_addr) {
            STATS_INC(ble_ll_conn_stats, rx_data_pdu_bad_aa);
    ccf8:	3301      	adds	r3, #1
    ccfa:	6293      	str	r3, [r2, #40]	; 0x28
            ble_ll_state_set(BLE_LL_STATE_STANDBY);
    ccfc:	f7fe f9f2 	bl	b0e4 <ble_ll_state_set>
            ble_ll_event_send(&connsm->conn_ev_end);
    cd00:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
    cd04:	f7fe f9fa 	bl	b0fc <ble_ll_event_send>
            g_ble_ll_conn_cur_sm = NULL;
    cd08:	2300      	movs	r3, #0
    cd0a:	6033      	str	r3, [r6, #0]
            return -1;
    cd0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    cd10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }

        /* Set connection handle in mbuf header */
        rxhdr->rxinfo.handle = connsm->conn_handle;
    cd12:	88a3      	ldrh	r3, [r4, #4]
    cd14:	70ab      	strb	r3, [r5, #2]

        /* Set flag denoting we have received a packet in connection event */
        connsm->csmflags.cfbit.pkt_rxd = 1;
    cd16:	7823      	ldrb	r3, [r4, #0]
    cd18:	f043 0301 	orr.w	r3, r3, #1

        /* Set anchor point (and last) if 1st rxd frame in connection event */
        if (connsm->csmflags.cfbit.slave_set_last_anchor) {
    cd1c:	06da      	lsls	r2, r3, #27

        /* Set connection handle in mbuf header */
        rxhdr->rxinfo.handle = connsm->conn_handle;

        /* Set flag denoting we have received a packet in connection event */
        connsm->csmflags.cfbit.pkt_rxd = 1;
    cd1e:	7023      	strb	r3, [r4, #0]

        /* Set anchor point (and last) if 1st rxd frame in connection event */
        if (connsm->csmflags.cfbit.slave_set_last_anchor) {
            connsm->csmflags.cfbit.slave_set_last_anchor = 0;
    cd20:	bf41      	itttt	mi
    cd22:	f36f 1304 	bfcmi	r3, #4, #1
    cd26:	7023      	strbmi	r3, [r4, #0]
            connsm->last_anchor_point = rxhdr->beg_cputime;
    cd28:	686b      	ldrmi	r3, [r5, #4]
    cd2a:	6723      	strmi	r3, [r4, #112]	; 0x70
            connsm->anchor_point = connsm->last_anchor_point;
    cd2c:	bf48      	it	mi
    cd2e:	66e3      	strmi	r3, [r4, #108]	; 0x6c
        }
    }

    return 1;
    cd30:	2001      	movs	r0, #1
}
    cd32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    cd34:	200033cc 	.word	0x200033cc
    cd38:	20003580 	.word	0x20003580

0000cd3c <ble_ll_conn_rx_data_pdu>:
 * @param rxpdu Pointer to received pdu
 * @param rxpdu Pointer to ble mbuf header of received pdu
 */
void
ble_ll_conn_rx_data_pdu(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *hdr)
{
    cd3c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint16_t acl_len;
    uint16_t acl_hdr;
    uint32_t tmo;
    struct ble_ll_conn_sm *connsm;

    if (BLE_MBUF_HDR_CRC_OK(hdr)) {
    cd40:	f991 3000 	ldrsb.w	r3, [r1]
    cd44:	2b00      	cmp	r3, #0
 * @param rxpdu Pointer to received pdu
 * @param rxpdu Pointer to ble mbuf header of received pdu
 */
void
ble_ll_conn_rx_data_pdu(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *hdr)
{
    cd46:	4606      	mov	r6, r0
    cd48:	4689      	mov	r9, r1
    uint16_t acl_len;
    uint16_t acl_hdr;
    uint32_t tmo;
    struct ble_ll_conn_sm *connsm;

    if (BLE_MBUF_HDR_CRC_OK(hdr)) {
    cd4a:	f280 80a5 	bge.w	ce98 <ble_ll_conn_rx_data_pdu+0x15c>
        /* XXX: there is a chance that the connection was thrown away and
           re-used before processing packets here. Fix this. */
        /* We better have a connection state machine */
        connsm = ble_ll_conn_find_active_conn(hdr->rxinfo.handle);
    cd4e:	7888      	ldrb	r0, [r1, #2]
    cd50:	f7ff fa12 	bl	c178 <ble_ll_conn_find_active_conn>
        if (connsm) {
    cd54:	4604      	mov	r4, r0
    cd56:	2800      	cmp	r0, #0
    cd58:	f000 809a 	beq.w	ce90 <ble_ll_conn_rx_data_pdu+0x154>
            /* Reset the connection supervision timeout */
            cputime_timer_stop(&connsm->conn_spvn_timer);
    cd5c:	f100 0584 	add.w	r5, r0, #132	; 0x84
    cd60:	4628      	mov	r0, r5
    cd62:	f7fc f82d 	bl	8dc0 <cputime_timer_stop>
            tmo = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
    cd66:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
            cputime_timer_relative(&connsm->conn_spvn_timer, tmo);
    cd6a:	f242 7110 	movw	r1, #10000	; 0x2710
    cd6e:	4628      	mov	r0, r5
    cd70:	4359      	muls	r1, r3
    cd72:	f7fc f80b 	bl	8d8c <cputime_timer_relative>

            /* Check state machine */
            ble_ll_conn_chk_csm_flags(connsm);
    cd76:	4620      	mov	r0, r4
    cd78:	f7ff f9c0 	bl	c0fc <ble_ll_conn_chk_csm_flags>

            /* Validate rx data pdu */
            rxbuf = rxpdu->om_data;
    cd7c:	6833      	ldr	r3, [r6, #0]
            hdr_byte = rxbuf[0];
    cd7e:	781d      	ldrb	r5, [r3, #0]
            acl_len = rxbuf[1];
    cd80:	f893 a001 	ldrb.w	sl, [r3, #1]
            acl_hdr = hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;

            /* Check that the LLID is reasonable */
            if ((acl_hdr == 0) ||
    cd84:	f015 0803 	ands.w	r8, r5, #3
    cd88:	d005      	beq.n	cd96 <ble_ll_conn_rx_data_pdu+0x5a>
    cd8a:	f1b8 0f02 	cmp.w	r8, #2
            ble_ll_conn_chk_csm_flags(connsm);

            /* Validate rx data pdu */
            rxbuf = rxpdu->om_data;
            hdr_byte = rxbuf[0];
            acl_len = rxbuf[1];
    cd8e:	fa1f f78a 	uxth.w	r7, sl
            acl_hdr = hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;

            /* Check that the LLID is reasonable */
            if ((acl_hdr == 0) ||
    cd92:	d105      	bne.n	cda0 <ble_ll_conn_rx_data_pdu+0x64>
                ((acl_hdr == BLE_LL_LLID_DATA_START) && (acl_len == 0))) {
    cd94:	b927      	cbnz	r7, cda0 <ble_ll_conn_rx_data_pdu+0x64>
                STATS_INC(ble_ll_conn_stats, rx_bad_llid);
    cd96:	4a44      	ldr	r2, [pc, #272]	; (cea8 <ble_ll_conn_rx_data_pdu+0x16c>)
    cd98:	6d93      	ldr	r3, [r2, #88]	; 0x58
    cd9a:	3301      	adds	r3, #1
    cd9c:	6593      	str	r3, [r2, #88]	; 0x58
                goto conn_rx_data_pdu_end;
    cd9e:	e07b      	b.n	ce98 <ble_ll_conn_rx_data_pdu+0x15c>
            /*
             * Reset authenticated payload timeout if valid MIC. NOTE: we dont
             * check the MIC failure bit as that would have terminated the
             * connection
             */
            if ((connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) &&
    cda0:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
    cda4:	2b02      	cmp	r3, #2
    cda6:	d106      	bne.n	cdb6 <ble_ll_conn_rx_data_pdu+0x7a>
    cda8:	78a3      	ldrb	r3, [r4, #2]
    cdaa:	075a      	lsls	r2, r3, #29
    cdac:	d503      	bpl.n	cdb6 <ble_ll_conn_rx_data_pdu+0x7a>
                CONN_F_LE_PING_SUPP(connsm) && (acl_len != 0)) {
    cdae:	b117      	cbz	r7, cdb6 <ble_ll_conn_rx_data_pdu+0x7a>
                ble_ll_conn_auth_pyld_timer_start(connsm);
    cdb0:	4620      	mov	r0, r4
    cdb2:	f7ff fbad 	bl	c510 <ble_ll_conn_auth_pyld_timer_start>
            }
#endif

            /* Update RSSI */
            connsm->conn_rssi = hdr->rxinfo.rssi;
    cdb6:	f899 3003 	ldrb.w	r3, [r9, #3]
    cdba:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b

            /*
             * If we are a slave, we can only start to use slave latency
             * once we have received a NESN of 1 from the master
             */
            if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    cdbe:	79e3      	ldrb	r3, [r4, #7]
    cdc0:	2b02      	cmp	r3, #2
    cdc2:	d105      	bne.n	cdd0 <ble_ll_conn_rx_data_pdu+0x94>
                if (hdr_byte & BLE_LL_DATA_HDR_NESN_MASK) {
    cdc4:	076b      	lsls	r3, r5, #29
                    connsm->csmflags.cfbit.allow_slave_latency = 1;
    cdc6:	bf42      	ittt	mi
    cdc8:	7823      	ldrbmi	r3, [r4, #0]
    cdca:	f043 0308 	orrmi.w	r3, r3, #8
    cdce:	7023      	strbmi	r3, [r4, #0]

            /*
             * Discard the received PDU if the sequence number is the same
             * as the last received sequence number
             */
            rxd_sn = hdr_byte & BLE_LL_DATA_HDR_SN_MASK;
    cdd0:	f005 0508 	and.w	r5, r5, #8
            if (rxd_sn != connsm->last_rxd_sn) {
    cdd4:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f

            /*
             * Discard the received PDU if the sequence number is the same
             * as the last received sequence number
             */
            rxd_sn = hdr_byte & BLE_LL_DATA_HDR_SN_MASK;
    cdd8:	b2ed      	uxtb	r5, r5
            if (rxd_sn != connsm->last_rxd_sn) {
    cdda:	42ab      	cmp	r3, r5
    cddc:	d053      	beq.n	ce86 <ble_ll_conn_rx_data_pdu+0x14a>
                /* Update last rxd sn */
                connsm->last_rxd_sn = rxd_sn;

                /* No need to do anything if empty pdu */
                if ((acl_hdr == BLE_LL_LLID_DATA_FRAG) && (acl_len == 0)) {
    cdde:	f1b8 0f01 	cmp.w	r8, #1
             * as the last received sequence number
             */
            rxd_sn = hdr_byte & BLE_LL_DATA_HDR_SN_MASK;
            if (rxd_sn != connsm->last_rxd_sn) {
                /* Update last rxd sn */
                connsm->last_rxd_sn = rxd_sn;
    cde2:	f884 502f 	strb.w	r5, [r4, #47]	; 0x2f

                /* No need to do anything if empty pdu */
                if ((acl_hdr == BLE_LL_LLID_DATA_FRAG) && (acl_len == 0)) {
    cde6:	d101      	bne.n	cdec <ble_ll_conn_rx_data_pdu+0xb0>
    cde8:	2f00      	cmp	r7, #0
    cdea:	d055      	beq.n	ce98 <ble_ll_conn_rx_data_pdu+0x15c>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
                /*
                 * XXX: should we check to see if we are in a state where we
                 * might expect to get an encrypted PDU?
                 */
                if (BLE_MBUF_HDR_MIC_FAILURE(hdr)) {
    cdec:	f899 2000 	ldrb.w	r2, [r9]
    cdf0:	4d2d      	ldr	r5, [pc, #180]	; (cea8 <ble_ll_conn_rx_data_pdu+0x16c>)
    cdf2:	f002 0220 	and.w	r2, r2, #32
    cdf6:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    cdfa:	b13a      	cbz	r2, ce0c <ble_ll_conn_rx_data_pdu+0xd0>
                    STATS_INC(ble_ll_conn_stats, mic_failures);
    cdfc:	6f2b      	ldr	r3, [r5, #112]	; 0x70
                    ble_ll_conn_timeout(connsm, BLE_ERR_CONN_TERM_MIC);
    cdfe:	4620      	mov	r0, r4
                /*
                 * XXX: should we check to see if we are in a state where we
                 * might expect to get an encrypted PDU?
                 */
                if (BLE_MBUF_HDR_MIC_FAILURE(hdr)) {
                    STATS_INC(ble_ll_conn_stats, mic_failures);
    ce00:	3301      	adds	r3, #1
                    ble_ll_conn_timeout(connsm, BLE_ERR_CONN_TERM_MIC);
    ce02:	213d      	movs	r1, #61	; 0x3d
                /*
                 * XXX: should we check to see if we are in a state where we
                 * might expect to get an encrypted PDU?
                 */
                if (BLE_MBUF_HDR_MIC_FAILURE(hdr)) {
                    STATS_INC(ble_ll_conn_stats, mic_failures);
    ce04:	672b      	str	r3, [r5, #112]	; 0x70
                    ble_ll_conn_timeout(connsm, BLE_ERR_CONN_TERM_MIC);
    ce06:	f7ff ff47 	bl	cc98 <ble_ll_conn_timeout>
                    goto conn_rx_data_pdu_end;
    ce0a:	e045      	b.n	ce98 <ble_ll_conn_rx_data_pdu+0x15c>
                }
#endif

                if (acl_hdr == BLE_LL_LLID_CTRL) {
    ce0c:	f1b8 0f03 	cmp.w	r8, #3
    ce10:	d10d      	bne.n	ce2e <ble_ll_conn_rx_data_pdu+0xf2>
                    /* Process control frame */
                    STATS_INC(ble_ll_conn_stats, rx_ctrl_pdus);
    ce12:	6cab      	ldr	r3, [r5, #72]	; 0x48
                    if (ble_ll_ctrl_rx_pdu(connsm, rxpdu)) {
    ce14:	4620      	mov	r0, r4
                }
#endif

                if (acl_hdr == BLE_LL_LLID_CTRL) {
                    /* Process control frame */
                    STATS_INC(ble_ll_conn_stats, rx_ctrl_pdus);
    ce16:	3301      	adds	r3, #1
                    if (ble_ll_ctrl_rx_pdu(connsm, rxpdu)) {
    ce18:	4631      	mov	r1, r6
                }
#endif

                if (acl_hdr == BLE_LL_LLID_CTRL) {
                    /* Process control frame */
                    STATS_INC(ble_ll_conn_stats, rx_ctrl_pdus);
    ce1a:	64ab      	str	r3, [r5, #72]	; 0x48
                    if (ble_ll_ctrl_rx_pdu(connsm, rxpdu)) {
    ce1c:	f001 fbb2 	bl	e584 <ble_ll_ctrl_rx_pdu>
    ce20:	2800      	cmp	r0, #0
    ce22:	d03e      	beq.n	cea2 <ble_ll_conn_rx_data_pdu+0x166>
                        STATS_INC(ble_ll_conn_stats, rx_malformed_ctrl_pdus);
    ce24:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    ce26:	3301      	adds	r3, #1
    ce28:	656b      	str	r3, [r5, #84]	; 0x54
    ce2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    }
                } else {
                    /* Count # of received l2cap frames and byes */
                    STATS_INC(ble_ll_conn_stats, rx_l2cap_pdus);
    ce2e:	6cea      	ldr	r2, [r5, #76]	; 0x4c
    ce30:	3201      	adds	r2, #1
    ce32:	64ea      	str	r2, [r5, #76]	; 0x4c
                    STATS_INCN(ble_ll_conn_stats, rx_l2cap_bytes, acl_len);
    ce34:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    ce36:	4452      	add	r2, sl
    ce38:	652a      	str	r2, [r5, #80]	; 0x50
{
    uint16_t startoff;
    uint16_t leadingspace;

    startoff = 0;
    if (OS_MBUF_IS_PKTHDR(om)) {
    ce3a:	7972      	ldrb	r2, [r6, #5]
    ce3c:	2a07      	cmp	r2, #7
        startoff = om->om_pkthdr_len;
    ce3e:	bf88      	it	hi
    ce40:	b293      	uxthhi	r3, r2
    }

    leadingspace = (uint16_t) (OS_MBUF_DATA(om, uint8_t *) - 
        ((uint8_t *) &om->om_databuf[0] + startoff));
    ce42:	3310      	adds	r3, #16
    startoff = 0;
    if (OS_MBUF_IS_PKTHDR(om)) {
        startoff = om->om_pkthdr_len;
    }

    leadingspace = (uint16_t) (OS_MBUF_DATA(om, uint8_t *) - 
    ce44:	6832      	ldr	r2, [r6, #0]
        ((uint8_t *) &om->om_databuf[0] + startoff));
    ce46:	4433      	add	r3, r6
    startoff = 0;
    if (OS_MBUF_IS_PKTHDR(om)) {
        startoff = om->om_pkthdr_len;
    }

    leadingspace = (uint16_t) (OS_MBUF_DATA(om, uint8_t *) - 
    ce48:	1ad3      	subs	r3, r2, r3

                    /* NOTE: there should be at least two bytes available */
                    assert(OS_MBUF_LEADINGSPACE(rxpdu) >= 2);
    ce4a:	b29b      	uxth	r3, r3
    ce4c:	2b01      	cmp	r3, #1
    ce4e:	d806      	bhi.n	ce5e <ble_ll_conn_rx_data_pdu+0x122>
    ce50:	2200      	movs	r2, #0
    ce52:	4816      	ldr	r0, [pc, #88]	; (ceac <ble_ll_conn_rx_data_pdu+0x170>)
    ce54:	f640 2105 	movw	r1, #2565	; 0xa05
    ce58:	4613      	mov	r3, r2
    ce5a:	f7fc ff39 	bl	9cd0 <__assert_func>
                    os_mbuf_prepend(rxpdu, 2);
    ce5e:	4630      	mov	r0, r6
    ce60:	2102      	movs	r1, #2
    ce62:	f7fd f9a4 	bl	a1ae <os_mbuf_prepend>
                    rxbuf = rxpdu->om_data;
    ce66:	6835      	ldr	r5, [r6, #0]

                    acl_hdr = (acl_hdr << 12) | connsm->conn_handle;
    ce68:	88a1      	ldrh	r1, [r4, #4]
                    htole16(rxbuf, acl_hdr);
    ce6a:	4628      	mov	r0, r5
    ce6c:	ea41 3108 	orr.w	r1, r1, r8, lsl #12
    ce70:	f010 f8f2 	bl	1d058 <htole16>
                    htole16(rxbuf + 2, acl_len);
    ce74:	1ca8      	adds	r0, r5, #2
    ce76:	4639      	mov	r1, r7
    ce78:	f010 f8ee 	bl	1d058 <htole16>
                    ble_hs_rx_data(rxpdu);
    ce7c:	4630      	mov	r0, r6
    }

    /* Free buffer */
conn_rx_data_pdu_end:
    os_mbuf_free_chain(rxpdu);
}
    ce7e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                    rxbuf = rxpdu->om_data;

                    acl_hdr = (acl_hdr << 12) | connsm->conn_handle;
                    htole16(rxbuf, acl_hdr);
                    htole16(rxbuf + 2, acl_len);
                    ble_hs_rx_data(rxpdu);
    ce82:	f007 bd15 	b.w	148b0 <ble_hs_rx_data>
                }

                /* NOTE: we dont free the mbuf since we handed it off! */
                return;
            } else {
                STATS_INC(ble_ll_conn_stats, data_pdu_rx_dup);
    ce86:	4a08      	ldr	r2, [pc, #32]	; (cea8 <ble_ll_conn_rx_data_pdu+0x16c>)
    ce88:	6b53      	ldr	r3, [r2, #52]	; 0x34
    ce8a:	3301      	adds	r3, #1
    ce8c:	6353      	str	r3, [r2, #52]	; 0x34
    ce8e:	e003      	b.n	ce98 <ble_ll_conn_rx_data_pdu+0x15c>
            }
        } else {
            STATS_INC(ble_ll_conn_stats, no_conn_sm);
    ce90:	4a05      	ldr	r2, [pc, #20]	; (cea8 <ble_ll_conn_rx_data_pdu+0x16c>)
    ce92:	69d3      	ldr	r3, [r2, #28]
    ce94:	3301      	adds	r3, #1
    ce96:	61d3      	str	r3, [r2, #28]
        }
    }

    /* Free buffer */
conn_rx_data_pdu_end:
    os_mbuf_free_chain(rxpdu);
    ce98:	4630      	mov	r0, r6
}
    ce9a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        }
    }

    /* Free buffer */
conn_rx_data_pdu_end:
    os_mbuf_free_chain(rxpdu);
    ce9e:	f7fd b85e 	b.w	9f5e <os_mbuf_free_chain>
    cea2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cea6:	bf00      	nop
    cea8:	20003580 	.word	0x20003580
    ceac:	0001f253 	.word	0x0001f253

0000ceb0 <ble_ll_conn_rx_isr_end>:
    /*
     * We should have a current connection state machine. If we dont, we just
     * hand the packet to the higher layer to count it.
     */
    rc = -1;
    connsm = g_ble_ll_conn_cur_sm;
    ceb0:	4b8e      	ldr	r3, [pc, #568]	; (d0ec <ble_ll_conn_rx_isr_end+0x23c>)
 *      == 0: Success. Do not disable the PHY.
 *       > 0: Do not disable PHY as that has already been done.
 */
int
ble_ll_conn_rx_isr_end(struct os_mbuf *rxpdu)
{
    ceb2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    /*
     * We should have a current connection state machine. If we dont, we just
     * hand the packet to the higher layer to count it.
     */
    rc = -1;
    connsm = g_ble_ll_conn_cur_sm;
    ceb6:	681c      	ldr	r4, [r3, #0]
 *      == 0: Success. Do not disable the PHY.
 *       > 0: Do not disable PHY as that has already been done.
 */
int
ble_ll_conn_rx_isr_end(struct os_mbuf *rxpdu)
{
    ceb8:	4607      	mov	r7, r0
     * We should have a current connection state machine. If we dont, we just
     * hand the packet to the higher layer to count it.
     */
    rc = -1;
    connsm = g_ble_ll_conn_cur_sm;
    if (!connsm) {
    ceba:	b924      	cbnz	r4, cec6 <ble_ll_conn_rx_isr_end+0x16>
        STATS_INC(ble_ll_conn_stats, rx_data_pdu_no_conn);
    cebc:	4a8c      	ldr	r2, [pc, #560]	; (d0f0 <ble_ll_conn_rx_isr_end+0x240>)
    cebe:	6a53      	ldr	r3, [r2, #36]	; 0x24
    cec0:	3301      	adds	r3, #1
    cec2:	6253      	str	r3, [r2, #36]	; 0x24
    cec4:	e0f2      	b.n	d0ac <ble_ll_conn_rx_isr_end+0x1fc>
        goto conn_exit;
    }

    /* Set the handle in the ble mbuf header */
    rxhdr = BLE_MBUF_HDR_PTR(rxpdu);
    hdr_byte = rxpdu->om_data[0];
    cec6:	6803      	ldr	r3, [r0, #0]
    cec8:	f893 a000 	ldrb.w	sl, [r3]
    rx_pyld_len = rxpdu->om_data[1];
    cecc:	785d      	ldrb	r5, [r3, #1]
    /*
     * Check the packet CRC. A connection event can continue even if the
     * received PDU does not pass the CRC check. If we receive two consecutive
     * CRC errors we end the conection event.
     */
    if (!BLE_MBUF_HDR_CRC_OK(rxhdr)) {
    cece:	f990 3018 	ldrsb.w	r3, [r0, #24]
    ced2:	2b00      	cmp	r3, #0
    ced4:	db10      	blt.n	cef8 <ble_ll_conn_rx_isr_end+0x48>
        /*
         * Increment # of consecutively received CRC errors. If more than
         * one we will end the connection event.
         */
        ++connsm->cons_rxd_bad_crc;
    ced6:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    ceda:	3301      	adds	r3, #1
    cedc:	b2db      	uxtb	r3, r3
        if (connsm->cons_rxd_bad_crc >= 2) {
    cede:	2b01      	cmp	r3, #1
    if (!BLE_MBUF_HDR_CRC_OK(rxhdr)) {
        /*
         * Increment # of consecutively received CRC errors. If more than
         * one we will end the connection event.
         */
        ++connsm->cons_rxd_bad_crc;
    cee0:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
        if (connsm->cons_rxd_bad_crc >= 2) {
    cee4:	f200 80fb 	bhi.w	d0de <ble_ll_conn_rx_isr_end+0x22e>
            reply = 0;
        } else {
            if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    cee8:	79e3      	ldrb	r3, [r4, #7]
    ceea:	2b01      	cmp	r3, #1
    ceec:	f040 80a9 	bne.w	d042 <ble_ll_conn_rx_isr_end+0x192>
                reply = CONN_F_LAST_TXD_MD(connsm);
    cef0:	7863      	ldrb	r3, [r4, #1]
    cef2:	f3c3 1340 	ubfx	r3, r3, #5, #1
    cef6:	e0a2      	b.n	d03e <ble_ll_conn_rx_isr_end+0x18e>
                reply = 1;
            }
        }
    } else {
        /* Reset consecutively received bad crcs (since this one was good!) */
        connsm->cons_rxd_bad_crc = 0;
    cef8:	2300      	movs	r3, #0

        /* Check for valid LLID before proceeding. */
        if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == 0) {
    cefa:	f01a 0903 	ands.w	r9, sl, #3
                reply = 1;
            }
        }
    } else {
        /* Reset consecutively received bad crcs (since this one was good!) */
        connsm->cons_rxd_bad_crc = 0;
    cefe:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e

        /* Check for valid LLID before proceeding. */
        if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == 0) {
    cf02:	f000 80d3 	beq.w	d0ac <ble_ll_conn_rx_isr_end+0x1fc>
         * If SN bit from header does not match NESN in connection, this is
         * a resent PDU and should be ignored.
         */
        hdr_sn = hdr_byte & BLE_LL_DATA_HDR_SN_MASK;
        conn_nesn = connsm->next_exp_seqnum;
        if ((hdr_sn && conn_nesn) || (!hdr_sn && !conn_nesn)) {
    cf06:	f01a 0f08 	tst.w	sl, #8
            reply = 0;
            goto conn_exit;
        }

        /* Set last received header byte */
        connsm->last_rxd_hdr_byte = hdr_byte;
    cf0a:	f884 a030 	strb.w	sl, [r4, #48]	; 0x30
        /*
         * If SN bit from header does not match NESN in connection, this is
         * a resent PDU and should be ignored.
         */
        hdr_sn = hdr_byte & BLE_LL_DATA_HDR_SN_MASK;
        conn_nesn = connsm->next_exp_seqnum;
    cf0e:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
        if ((hdr_sn && conn_nesn) || (!hdr_sn && !conn_nesn)) {
    cf12:	d001      	beq.n	cf18 <ble_ll_conn_rx_isr_end+0x68>
    cf14:	b90b      	cbnz	r3, cf1a <ble_ll_conn_rx_isr_end+0x6a>
    cf16:	e012      	b.n	cf3e <ble_ll_conn_rx_isr_end+0x8e>
    cf18:	b98b      	cbnz	r3, cf3e <ble_ll_conn_rx_isr_end+0x8e>
            connsm->next_exp_seqnum ^= 1;
    cf1a:	f083 0301 	eor.w	r3, r3, #1
    cf1e:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (CONN_F_ENCRYPTED(connsm) && !ble_ll_conn_is_empty_pdu(rxpdu)) {
    cf22:	78a3      	ldrb	r3, [r4, #2]
    cf24:	07d8      	lsls	r0, r3, #31
    cf26:	d50a      	bpl.n	cf3e <ble_ll_conn_rx_isr_end+0x8e>
    cf28:	683a      	ldr	r2, [r7, #0]
ble_ll_conn_is_empty_pdu(struct os_mbuf *rxpdu)
{
    int rc;
    uint8_t llid;

    llid = rxpdu->om_data[0] & BLE_LL_DATA_HDR_LLID_MASK;
    cf2a:	7813      	ldrb	r3, [r2, #0]
    if ((llid == BLE_LL_LLID_DATA_FRAG) && (rxpdu->om_data[1] == 0)) {
    cf2c:	f003 0303 	and.w	r3, r3, #3
    cf30:	2b01      	cmp	r3, #1
    cf32:	f040 80c5 	bne.w	d0c0 <ble_ll_conn_rx_isr_end+0x210>
    cf36:	7853      	ldrb	r3, [r2, #1]
    cf38:	2b00      	cmp	r3, #0
    cf3a:	f040 80c1 	bne.w	d0c0 <ble_ll_conn_rx_isr_end+0x210>

        /*
         * Check NESN bit from header. If same as tx seq num, the transmission
         * is acknowledged. Otherwise we need to resend this PDU.
         */
        if (CONN_F_EMPTY_PDU_TXD(connsm) || connsm->cur_tx_pdu) {
    cf3e:	7863      	ldrb	r3, [r4, #1]
    cf40:	f003 0310 	and.w	r3, r3, #16
    cf44:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    cf48:	b91b      	cbnz	r3, cf52 <ble_ll_conn_rx_isr_end+0xa2>
    cf4a:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
    cf4e:	2b00      	cmp	r3, #0
    cf50:	d04e      	beq.n	cff0 <ble_ll_conn_rx_isr_end+0x140>
            hdr_nesn = hdr_byte & BLE_LL_DATA_HDR_NESN_MASK;
            conn_sn = connsm->tx_seqnum;
            if ((hdr_nesn && conn_sn) || (!hdr_nesn && !conn_sn)) {
    cf52:	f01a 0f04 	tst.w	sl, #4
         * Check NESN bit from header. If same as tx seq num, the transmission
         * is acknowledged. Otherwise we need to resend this PDU.
         */
        if (CONN_F_EMPTY_PDU_TXD(connsm) || connsm->cur_tx_pdu) {
            hdr_nesn = hdr_byte & BLE_LL_DATA_HDR_NESN_MASK;
            conn_sn = connsm->tx_seqnum;
    cf56:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    cf5a:	4a65      	ldr	r2, [pc, #404]	; (d0f0 <ble_ll_conn_rx_isr_end+0x240>)
            if ((hdr_nesn && conn_sn) || (!hdr_nesn && !conn_sn)) {
    cf5c:	d001      	beq.n	cf62 <ble_ll_conn_rx_isr_end+0xb2>
    cf5e:	b90b      	cbnz	r3, cf64 <ble_ll_conn_rx_isr_end+0xb4>
    cf60:	e004      	b.n	cf6c <ble_ll_conn_rx_isr_end+0xbc>
    cf62:	b91b      	cbnz	r3, cf6c <ble_ll_conn_rx_isr_end+0xbc>
                /* We did not get an ACK. Must retry the PDU */
                STATS_INC(ble_ll_conn_stats, data_pdu_txf);
    cf64:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    cf66:	3301      	adds	r3, #1
    cf68:	63d3      	str	r3, [r2, #60]	; 0x3c
    cf6a:	e041      	b.n	cff0 <ble_ll_conn_rx_isr_end+0x140>
            } else {
                /* Transmit success */
                connsm->tx_seqnum ^= 1;
    cf6c:	f083 0301 	eor.w	r3, r3, #1
    cf70:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
                STATS_INC(ble_ll_conn_stats, data_pdu_txg);
    cf74:	6b93      	ldr	r3, [r2, #56]	; 0x38
    cf76:	3301      	adds	r3, #1
    cf78:	6393      	str	r3, [r2, #56]	; 0x38

                /* If we transmitted the empty pdu, clear flag */
                if (CONN_F_EMPTY_PDU_TXD(connsm)) {
    cf7a:	b121      	cbz	r1, cf86 <ble_ll_conn_rx_isr_end+0xd6>
                    CONN_F_EMPTY_PDU_TXD(connsm) = 0;
    cf7c:	7863      	ldrb	r3, [r4, #1]
    cf7e:	f36f 1304 	bfc	r3, #4, #1
    cf82:	7063      	strb	r3, [r4, #1]
                    goto chk_rx_terminate_ind;
    cf84:	e034      	b.n	cff0 <ble_ll_conn_rx_isr_end+0x140>

                /*
                 * Determine if we should remove packet from queue or if there
                 * are more fragments to send.
                 */
                txpdu = connsm->cur_tx_pdu;
    cf86:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
                if (txpdu) {
    cf8a:	b388      	cbz	r0, cff0 <ble_ll_conn_rx_isr_end+0x140>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
                    if (connsm->enc_data.tx_encrypted) {
    cf8c:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
    cf90:	b123      	cbz	r3, cf9c <ble_ll_conn_rx_isr_end+0xec>
                        ++connsm->enc_data.tx_pkt_cntr;
    cf92:	f8b4 3124 	ldrh.w	r3, [r4, #292]	; 0x124
    cf96:	3301      	adds	r3, #1
    cf98:	f8a4 3124 	strh.w	r3, [r4, #292]	; 0x124
                    }
#endif
                    txhdr = BLE_MBUF_HDR_PTR(txpdu);
                    if ((txhdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK)
    cf9c:	7ec3      	ldrb	r3, [r0, #27]
    cf9e:	f003 0303 	and.w	r3, r3, #3
    cfa2:	2b03      	cmp	r3, #3
    cfa4:	d109      	bne.n	cfba <ble_ll_conn_rx_isr_end+0x10a>
                        == BLE_LL_LLID_CTRL) {
                        connsm->cur_tx_pdu = NULL;
    cfa6:	2300      	movs	r3, #0
    cfa8:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
                        /* Note: the mbuf is freed by this call */
                        rc = ble_ll_ctrl_tx_done(txpdu, connsm);
    cfac:	4621      	mov	r1, r4
    cfae:	f001 fd86 	bl	eabe <ble_ll_ctrl_tx_done>
                        if (rc) {
    cfb2:	4606      	mov	r6, r0
    cfb4:	2800      	cmp	r0, #0
    cfb6:	d17b      	bne.n	d0b0 <ble_ll_conn_rx_isr_end+0x200>
    cfb8:	e01a      	b.n	cff0 <ble_ll_conn_rx_isr_end+0x140>
                            goto chk_rx_terminate_ind;
                        }
                    }

                    /* Increment offset based on number of bytes sent */
                    txhdr->txinfo.offset += txhdr->txinfo.pyld_len;
    cfba:	7e42      	ldrb	r2, [r0, #25]
    cfbc:	7e81      	ldrb	r1, [r0, #26]
                    if (txhdr->txinfo.offset >= OS_MBUF_PKTLEN(txpdu)) {
    cfbe:	8a03      	ldrh	r3, [r0, #16]
                            goto chk_rx_terminate_ind;
                        }
                    }

                    /* Increment offset based on number of bytes sent */
                    txhdr->txinfo.offset += txhdr->txinfo.pyld_len;
    cfc0:	440a      	add	r2, r1
    cfc2:	b2d2      	uxtb	r2, r2
                    if (txhdr->txinfo.offset >= OS_MBUF_PKTLEN(txpdu)) {
    cfc4:	429a      	cmp	r2, r3
                            goto chk_rx_terminate_ind;
                        }
                    }

                    /* Increment offset based on number of bytes sent */
                    txhdr->txinfo.offset += txhdr->txinfo.pyld_len;
    cfc6:	7642      	strb	r2, [r0, #25]
                    if (txhdr->txinfo.offset >= OS_MBUF_PKTLEN(txpdu)) {
    cfc8:	d30b      	bcc.n	cfe2 <ble_ll_conn_rx_isr_end+0x132>
                        /* If l2cap pdu, increment # of completed packets */
                        if (txhdr->txinfo.pyld_len != 0) {
    cfca:	b121      	cbz	r1, cfd6 <ble_ll_conn_rx_isr_end+0x126>
#if (BLETEST_THROUGHPUT_TEST == 1)
                            bletest_completed_pkt(connsm->conn_handle);
#endif
                            ++connsm->completed_pkts;
    cfcc:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    cfd0:	3301      	adds	r3, #1
    cfd2:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
                        }
                        os_mbuf_free_chain(txpdu);
    cfd6:	f7fc ffc2 	bl	9f5e <os_mbuf_free_chain>
                        connsm->cur_tx_pdu = NULL;
    cfda:	2300      	movs	r3, #0
    cfdc:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
    cfe0:	e006      	b.n	cff0 <ble_ll_conn_rx_isr_end+0x140>
                    } else {
                        rem_bytes = OS_MBUF_PKTLEN(txpdu) - txhdr->txinfo.offset;
    cfe2:	1a9a      	subs	r2, r3, r2
                        if (rem_bytes > connsm->eff_max_tx_octets) {
    cfe4:	7b23      	ldrb	r3, [r4, #12]
                            ++connsm->completed_pkts;
                        }
                        os_mbuf_free_chain(txpdu);
                        connsm->cur_tx_pdu = NULL;
                    } else {
                        rem_bytes = OS_MBUF_PKTLEN(txpdu) - txhdr->txinfo.offset;
    cfe6:	b2d2      	uxtb	r2, r2
                        if (rem_bytes > connsm->eff_max_tx_octets) {
                            txhdr->txinfo.pyld_len = connsm->eff_max_tx_octets;
    cfe8:	429a      	cmp	r2, r3
    cfea:	bf28      	it	cs
    cfec:	461a      	movcs	r2, r3
    cfee:	7682      	strb	r2, [r0, #26]

        /* Should we continue connection event? */
        /* If this is a TERMINATE_IND, we have to reply */
chk_rx_terminate_ind:
        is_ctrl = 0;
        if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
    cff0:	f1b9 0f03 	cmp.w	r9, #3
    cff4:	d10e      	bne.n	d014 <ble_ll_conn_rx_isr_end+0x164>
            is_ctrl = 1;
            opcode = rxpdu->om_data[2];
    cff6:	683b      	ldr	r3, [r7, #0]
    cff8:	f893 8002 	ldrb.w	r8, [r3, #2]
        }

        /* If we received a terminate IND, we must set some flags */
        if (is_ctrl && (opcode == BLE_LL_CTRL_TERMINATE_IND)) {
    cffc:	f1b8 0f02 	cmp.w	r8, #2
    d000:	d10a      	bne.n	d018 <ble_ll_conn_rx_isr_end+0x168>
            connsm->csmflags.cfbit.terminate_ind_rxd = 1;
    d002:	7823      	ldrb	r3, [r4, #0]
    d004:	f043 0304 	orr.w	r3, r3, #4
    d008:	7023      	strb	r3, [r4, #0]
            connsm->rxd_disconnect_reason = rxpdu->om_data[3];
    d00a:	683b      	ldr	r3, [r7, #0]
    d00c:	78db      	ldrb	r3, [r3, #3]
    d00e:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
            reply = 1;
    d012:	e016      	b.n	d042 <ble_ll_conn_rx_isr_end+0x192>
        }

        /* Should we continue connection event? */
        /* If this is a TERMINATE_IND, we have to reply */
chk_rx_terminate_ind:
        is_ctrl = 0;
    d014:	2200      	movs	r2, #0
    d016:	e000      	b.n	d01a <ble_ll_conn_rx_isr_end+0x16a>
        if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
            is_ctrl = 1;
    d018:	2201      	movs	r2, #1
        /* If we received a terminate IND, we must set some flags */
        if (is_ctrl && (opcode == BLE_LL_CTRL_TERMINATE_IND)) {
            connsm->csmflags.cfbit.terminate_ind_rxd = 1;
            connsm->rxd_disconnect_reason = rxpdu->om_data[3];
            reply = 1;
        } else if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    d01a:	79e3      	ldrb	r3, [r4, #7]
    d01c:	2b01      	cmp	r3, #1
    d01e:	d106      	bne.n	d02e <ble_ll_conn_rx_isr_end+0x17e>
            reply = CONN_F_LAST_TXD_MD(connsm) || (hdr_byte & BLE_LL_DATA_HDR_MD_MASK);
    d020:	7862      	ldrb	r2, [r4, #1]
    d022:	0691      	lsls	r1, r2, #26
    d024:	bf58      	it	pl
    d026:	f3ca 1300 	ubfxpl	r3, sl, #4, #1
    d02a:	b2db      	uxtb	r3, r3
    d02c:	e007      	b.n	d03e <ble_ll_conn_rx_isr_end+0x18e>
        } else {
            /* A slave always replies */
            reply = 1;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (is_ctrl && (opcode == BLE_LL_CTRL_PAUSE_ENC_RSP)) {
    d02e:	b142      	cbz	r2, d042 <ble_ll_conn_rx_isr_end+0x192>
    d030:	f1b8 0f0b 	cmp.w	r8, #11
    d034:	d105      	bne.n	d042 <ble_ll_conn_rx_isr_end+0x192>
                connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
    d036:	2301      	movs	r3, #1
    d038:	f884 3120 	strb.w	r3, [r4, #288]	; 0x120
    d03c:	e001      	b.n	d042 <ble_ll_conn_rx_isr_end+0x192>
        }
    }

    /* If reply flag set, send data pdu and continue connection event */
    rc = -1;
    if (rx_pyld_len && CONN_F_ENCRYPTED(connsm)) {
    d03e:	b145      	cbz	r5, d052 <ble_ll_conn_rx_isr_end+0x1a2>
    d040:	e002      	b.n	d048 <ble_ll_conn_rx_isr_end+0x198>
    d042:	2d00      	cmp	r5, #0
    d044:	d048      	beq.n	d0d8 <ble_ll_conn_rx_isr_end+0x228>
    d046:	2301      	movs	r3, #1
    d048:	78a2      	ldrb	r2, [r4, #2]
    d04a:	07d2      	lsls	r2, r2, #31
        rx_pyld_len += BLE_LL_DATA_MIC_LEN;
    d04c:	bf44      	itt	mi
    d04e:	3504      	addmi	r5, #4
    d050:	b2ed      	uxtbmi	r5, r5
    }
    endtime = rxhdr->beg_cputime + BLE_TX_DUR_USECS_M(rx_pyld_len);
    d052:	69fa      	ldr	r2, [r7, #28]
    d054:	350a      	adds	r5, #10
    d056:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
    if (reply && ble_ll_conn_can_send_next_pdu(connsm, endtime)) {
    d05a:	b33b      	cbz	r3, d0ac <ble_ll_conn_rx_isr_end+0x1fc>
    struct os_mbuf *txpdu;
    struct os_mbuf_pkthdr *pkthdr;
    struct ble_mbuf_hdr *txhdr;

    rc = 1;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    d05c:	79e3      	ldrb	r3, [r4, #7]
    d05e:	2b01      	cmp	r3, #1
    d060:	d134      	bne.n	d0cc <ble_ll_conn_rx_isr_end+0x21c>
        /* Get next scheduled item time */
        next_sched_time = ble_ll_conn_get_next_sched_time(connsm);
    d062:	4620      	mov	r0, r4
    d064:	f7fe fdf0 	bl	bc48 <ble_ll_conn_get_next_sched_time>

        txpdu = connsm->cur_tx_pdu;
    d068:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    struct ble_mbuf_hdr *txhdr;

    rc = 1;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
        /* Get next scheduled item time */
        next_sched_time = ble_ll_conn_get_next_sched_time(connsm);
    d06c:	4606      	mov	r6, r0

        txpdu = connsm->cur_tx_pdu;
        if (!txpdu) {
    d06e:	b932      	cbnz	r2, d07e <ble_ll_conn_rx_isr_end+0x1ce>
            pkthdr = STAILQ_FIRST(&connsm->conn_txq);
    d070:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
            if (pkthdr) {
    d074:	b183      	cbz	r3, d098 <ble_ll_conn_rx_isr_end+0x1e8>
            }
        } else {
            pkthdr = OS_MBUF_PKTHDR(txpdu);
        }

        if (txpdu) {
    d076:	f1b3 0210 	subs.w	r2, r3, #16
    d07a:	d00d      	beq.n	d098 <ble_ll_conn_rx_isr_end+0x1e8>
    d07c:	e001      	b.n	d082 <ble_ll_conn_rx_isr_end+0x1d2>
            pkthdr = STAILQ_FIRST(&connsm->conn_txq);
            if (pkthdr) {
                txpdu = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
            }
        } else {
            pkthdr = OS_MBUF_PKTHDR(txpdu);
    d07e:	f102 0310 	add.w	r3, r2, #16
        }

        if (txpdu) {
            txhdr = BLE_MBUF_HDR_PTR(txpdu);
            rem_bytes = pkthdr->omp_len - txhdr->txinfo.offset;
    d082:	7e52      	ldrb	r2, [r2, #25]
    d084:	781b      	ldrb	r3, [r3, #0]
    d086:	1a9b      	subs	r3, r3, r2
            if (rem_bytes > connsm->eff_max_tx_octets) {
    d088:	7b22      	ldrb	r2, [r4, #12]
            pkthdr = OS_MBUF_PKTHDR(txpdu);
        }

        if (txpdu) {
            txhdr = BLE_MBUF_HDR_PTR(txpdu);
            rem_bytes = pkthdr->omp_len - txhdr->txinfo.offset;
    d08a:	b2db      	uxtb	r3, r3
            if (rem_bytes > connsm->eff_max_tx_octets) {
                rem_bytes = connsm->eff_max_tx_octets;
            }
            ticks = BLE_TX_DUR_USECS_M(rem_bytes);
    d08c:	4293      	cmp	r3, r2
    d08e:	bf28      	it	cs
    d090:	4613      	movcs	r3, r2
    d092:	330a      	adds	r3, #10
    d094:	00db      	lsls	r3, r3, #3
    d096:	e000      	b.n	d09a <ble_ll_conn_rx_isr_end+0x1ea>
        } else {
            /* We will send empty pdu (just a LL header) */
            ticks = BLE_TX_DUR_USECS_M(0);
    d098:	2350      	movs	r3, #80	; 0x50
        }
        ticks += (BLE_LL_IFS * 2) + connsm->eff_max_rx_time;
    d09a:	8b20      	ldrh	r0, [r4, #24]
    d09c:	f500 7096 	add.w	r0, r0, #300	; 0x12c
        ticks = cputime_usecs_to_ticks(ticks);
    d0a0:	4418      	add	r0, r3
    d0a2:	f7fb fe07 	bl	8cb4 <cputime_usecs_to_ticks>
        if ((begtime + ticks) >= next_sched_time) {
    d0a6:	4428      	add	r0, r5
    d0a8:	42b0      	cmp	r0, r6
    d0aa:	d30f      	bcc.n	d0cc <ble_ll_conn_rx_isr_end+0x21c>
#endif
        }
    }

    /* If reply flag set, send data pdu and continue connection event */
    rc = -1;
    d0ac:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    }

conn_exit:
    /* Send link layer a connection end event if over */
    if (rc) {
        ble_ll_conn_current_sm_over();
    d0b0:	f7fe fd6a 	bl	bb88 <ble_ll_conn_current_sm_over>
        if (connsm) {
    d0b4:	b1bc      	cbz	r4, d0e6 <ble_ll_conn_rx_isr_end+0x236>
            ble_ll_event_send(&connsm->conn_ev_end);
    d0b6:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
    d0ba:	f7fe f81f 	bl	b0fc <ble_ll_event_send>
    d0be:	e012      	b.n	d0e6 <ble_ll_conn_rx_isr_end+0x236>
        conn_nesn = connsm->next_exp_seqnum;
        if ((hdr_sn && conn_nesn) || (!hdr_sn && !conn_nesn)) {
            connsm->next_exp_seqnum ^= 1;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
            if (CONN_F_ENCRYPTED(connsm) && !ble_ll_conn_is_empty_pdu(rxpdu)) {
                ++connsm->enc_data.rx_pkt_cntr;
    d0c0:	f8b4 3126 	ldrh.w	r3, [r4, #294]	; 0x126
    d0c4:	3301      	adds	r3, #1
    d0c6:	f8a4 3126 	strh.w	r3, [r4, #294]	; 0x126
    d0ca:	e738      	b.n	cf3e <ble_ll_conn_rx_isr_end+0x8e>
    if (rx_pyld_len && CONN_F_ENCRYPTED(connsm)) {
        rx_pyld_len += BLE_LL_DATA_MIC_LEN;
    }
    endtime = rxhdr->beg_cputime + BLE_TX_DUR_USECS_M(rx_pyld_len);
    if (reply && ble_ll_conn_can_send_next_pdu(connsm, endtime)) {
        rc = ble_ll_conn_tx_data_pdu(connsm);
    d0cc:	4620      	mov	r0, r4
    d0ce:	f7fe fdd3 	bl	bc78 <ble_ll_conn_tx_data_pdu>
    }

conn_exit:
    /* Send link layer a connection end event if over */
    if (rc) {
    d0d2:	4606      	mov	r6, r0
    d0d4:	b138      	cbz	r0, d0e6 <ble_ll_conn_rx_isr_end+0x236>
    d0d6:	e7eb      	b.n	d0b0 <ble_ll_conn_rx_isr_end+0x200>
    /* If reply flag set, send data pdu and continue connection event */
    rc = -1;
    if (rx_pyld_len && CONN_F_ENCRYPTED(connsm)) {
        rx_pyld_len += BLE_LL_DATA_MIC_LEN;
    }
    endtime = rxhdr->beg_cputime + BLE_TX_DUR_USECS_M(rx_pyld_len);
    d0d8:	69fd      	ldr	r5, [r7, #28]
    d0da:	3550      	adds	r5, #80	; 0x50
    d0dc:	e7be      	b.n	d05c <ble_ll_conn_rx_isr_end+0x1ac>
        }
    }

    /* If reply flag set, send data pdu and continue connection event */
    rc = -1;
    if (rx_pyld_len && CONN_F_ENCRYPTED(connsm)) {
    d0de:	2d00      	cmp	r5, #0
    d0e0:	d0e4      	beq.n	d0ac <ble_ll_conn_rx_isr_end+0x1fc>
         * Increment # of consecutively received CRC errors. If more than
         * one we will end the connection event.
         */
        ++connsm->cons_rxd_bad_crc;
        if (connsm->cons_rxd_bad_crc >= 2) {
            reply = 0;
    d0e2:	2300      	movs	r3, #0
    d0e4:	e7b0      	b.n	d048 <ble_ll_conn_rx_isr_end+0x198>
            ble_ll_event_send(&connsm->conn_ev_end);
        }
    }

    return rc;
}
    d0e6:	4630      	mov	r0, r6
    d0e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d0ec:	200033cc 	.word	0x200033cc
    d0f0:	20003580 	.word	0x20003580

0000d0f4 <ble_ll_conn_enqueue_pkt>:
 * @param om
 */
void
ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm *connsm, struct os_mbuf *om,
                        uint8_t hdr_byte, uint8_t length)
{
    d0f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d0f6:	4606      	mov	r6, r0
    d0f8:	460c      	mov	r4, r1
    struct os_mbuf_pkthdr *pkthdr;
    struct ble_mbuf_hdr *ble_hdr;
    int lifo;

    /* Initialize the mbuf */
    ble_ll_mbuf_init(om, length, hdr_byte);
    d0fa:	4608      	mov	r0, r1
    d0fc:	4619      	mov	r1, r3
 * @param om
 */
void
ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm *connsm, struct os_mbuf *om,
                        uint8_t hdr_byte, uint8_t length)
{
    d0fe:	461d      	mov	r5, r3
    struct os_mbuf_pkthdr *pkthdr;
    struct ble_mbuf_hdr *ble_hdr;
    int lifo;

    /* Initialize the mbuf */
    ble_ll_mbuf_init(om, length, hdr_byte);
    d100:	f7fe f80e 	bl	b120 <ble_ll_mbuf_init>

    /*
     * We need to set the initial payload length if the total length of the
     * PDU exceeds the maximum allowed for the connection for any single tx.
     */
    if (length > connsm->eff_max_tx_octets) {
    d104:	7b32      	ldrb	r2, [r6, #12]
    d106:	4295      	cmp	r5, r2
        ble_hdr = BLE_MBUF_HDR_PTR(om);
        ble_hdr->txinfo.pyld_len = connsm->eff_max_tx_octets;
    d108:	bf88      	it	hi
    d10a:	76a2      	strbhi	r2, [r4, #26]
    }

    lifo = 0;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
    d10c:	f896 3120 	ldrb.w	r3, [r6, #288]	; 0x120
    d110:	2b02      	cmp	r3, #2
    d112:	d919      	bls.n	d148 <ble_ll_conn_enqueue_pkt+0x54>
        /*
         * If this is one of the following types we need to insert it at
         * head of queue.
         */
        ble_hdr = BLE_MBUF_HDR_PTR(om);
        llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
    d114:	7ee3      	ldrb	r3, [r4, #27]
        if (llid == BLE_LL_LLID_CTRL) {
    d116:	f003 0303 	and.w	r3, r3, #3
    d11a:	2b03      	cmp	r3, #3
    d11c:	d114      	bne.n	d148 <ble_ll_conn_enqueue_pkt+0x54>
            switch (om->om_data[0]) {
    d11e:	6823      	ldr	r3, [r4, #0]
    d120:	781b      	ldrb	r3, [r3, #0]
    d122:	3b02      	subs	r3, #2
    d124:	b2db      	uxtb	r3, r3
    d126:	2b0f      	cmp	r3, #15
    d128:	d80e      	bhi.n	d148 <ble_ll_conn_enqueue_pkt+0x54>
    d12a:	2501      	movs	r5, #1
    d12c:	fa05 f303 	lsl.w	r3, r5, r3
    d130:	f648 0219 	movw	r2, #34841	; 0x8819
    d134:	401a      	ands	r2, r3
    d136:	b942      	cbnz	r2, d14a <ble_ll_conn_enqueue_pkt+0x56>
    d138:	f413 7500 	ands.w	r5, r3, #512	; 0x200
    d13c:	d005      	beq.n	d14a <ble_ll_conn_enqueue_pkt+0x56>
            case BLE_LL_CTRL_START_ENC_REQ:
            case BLE_LL_CTRL_START_ENC_RSP:
                lifo = 1;
                break;
            case BLE_LL_CTRL_PAUSE_ENC_RSP:
                if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    d13e:	79f5      	ldrb	r5, [r6, #7]
    d140:	1e6b      	subs	r3, r5, #1
    d142:	425d      	negs	r5, r3
    d144:	415d      	adcs	r5, r3
    d146:	e000      	b.n	d14a <ble_ll_conn_enqueue_pkt+0x56>
    if (length > connsm->eff_max_tx_octets) {
        ble_hdr = BLE_MBUF_HDR_PTR(om);
        ble_hdr->txinfo.pyld_len = connsm->eff_max_tx_octets;
    }

    lifo = 0;
    d148:	2500      	movs	r5, #0
        }
    }
#endif

    /* Add to transmit queue for the connection */
    pkthdr = OS_MBUF_PKTHDR(om);
    d14a:	f104 0710 	add.w	r7, r4, #16
    OS_ENTER_CRITICAL(sr);
    d14e:	f7fc fbe7 	bl	9920 <os_arch_save_sr>
    if (lifo) {
    d152:	b14d      	cbz	r5, d168 <ble_ll_conn_enqueue_pkt+0x74>
        STAILQ_INSERT_HEAD(&connsm->conn_txq, pkthdr, omp_next);
    d154:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
    d158:	6163      	str	r3, [r4, #20]
    d15a:	b913      	cbnz	r3, d162 <ble_ll_conn_enqueue_pkt+0x6e>
    d15c:	3414      	adds	r4, #20
    d15e:	f8c6 40b8 	str.w	r4, [r6, #184]	; 0xb8
    d162:	f8c6 70b4 	str.w	r7, [r6, #180]	; 0xb4
    d166:	e006      	b.n	d176 <ble_ll_conn_enqueue_pkt+0x82>
    } else {
        STAILQ_INSERT_TAIL(&connsm->conn_txq, pkthdr, omp_next);
    d168:	f844 5f14 	str.w	r5, [r4, #20]!
    d16c:	f8d6 30b8 	ldr.w	r3, [r6, #184]	; 0xb8
    d170:	601f      	str	r7, [r3, #0]
    d172:	f8c6 40b8 	str.w	r4, [r6, #184]	; 0xb8
    }
    OS_EXIT_CRITICAL(sr);
}
    d176:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (lifo) {
        STAILQ_INSERT_HEAD(&connsm->conn_txq, pkthdr, omp_next);
    } else {
        STAILQ_INSERT_TAIL(&connsm->conn_txq, pkthdr, omp_next);
    }
    OS_EXIT_CRITICAL(sr);
    d17a:	f7fc bbd7 	b.w	992c <os_arch_restore_sr>
	...

0000d180 <ble_ll_conn_tx_pkt_in>:
 *
 * @return int
 */
void
ble_ll_conn_tx_pkt_in(struct os_mbuf *om, uint16_t handle, uint16_t length)
{
    d180:	b570      	push	{r4, r5, r6, lr}
    d182:	4604      	mov	r4, r0
    uint16_t pb;
    struct ble_ll_conn_sm *connsm;

    /* See if we have an active matching connection handle */
    conn_handle = handle & 0x0FFF;
    connsm = ble_ll_conn_find_active_conn(conn_handle);
    d184:	f3c1 000b 	ubfx	r0, r1, #0, #12
 *
 * @return int
 */
void
ble_ll_conn_tx_pkt_in(struct os_mbuf *om, uint16_t handle, uint16_t length)
{
    d188:	4616      	mov	r6, r2
    d18a:	460d      	mov	r5, r1
    uint16_t pb;
    struct ble_ll_conn_sm *connsm;

    /* See if we have an active matching connection handle */
    conn_handle = handle & 0x0FFF;
    connsm = ble_ll_conn_find_active_conn(conn_handle);
    d18c:	f7fe fff4 	bl	c178 <ble_ll_conn_find_active_conn>
    d190:	4a0c      	ldr	r2, [pc, #48]	; (d1c4 <ble_ll_conn_tx_pkt_in+0x44>)
    if (connsm) {
    d192:	b170      	cbz	r0, d1b2 <ble_ll_conn_tx_pkt_in+0x32>
        } else {
            hdr_byte = BLE_LL_LLID_DATA_FRAG;
        }

        /* Add to total l2cap pdus enqueue */
        STATS_INC(ble_ll_conn_stats, l2cap_enqueued);
    d194:	6c51      	ldr	r1, [r2, #68]	; 0x44
    conn_handle = handle & 0x0FFF;
    connsm = ble_ll_conn_find_active_conn(conn_handle);
    if (connsm) {
        /* Construct LL header in buffer (NOTE: pb already checked) */
        pb = handle & 0x3000;
        if (pb == 0) {
    d196:	f415 5f40 	tst.w	r5, #12288	; 0x3000
        } else {
            hdr_byte = BLE_LL_LLID_DATA_FRAG;
        }

        /* Add to total l2cap pdus enqueue */
        STATS_INC(ble_ll_conn_stats, l2cap_enqueued);
    d19a:	f101 0101 	add.w	r1, r1, #1
    d19e:	6451      	str	r1, [r2, #68]	; 0x44

        /* Clear flags field in BLE header */
        ble_ll_conn_enqueue_pkt(connsm, om, hdr_byte, length);
    d1a0:	b2f3      	uxtb	r3, r6
    d1a2:	4621      	mov	r1, r4
    d1a4:	bf0c      	ite	eq
    d1a6:	2202      	moveq	r2, #2
    d1a8:	2201      	movne	r2, #1
    } else {
        /* No connection found! */
        STATS_INC(ble_ll_conn_stats, handle_not_found);
        os_mbuf_free_chain(om);
    }
}
    d1aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

        /* Add to total l2cap pdus enqueue */
        STATS_INC(ble_ll_conn_stats, l2cap_enqueued);

        /* Clear flags field in BLE header */
        ble_ll_conn_enqueue_pkt(connsm, om, hdr_byte, length);
    d1ae:	f7ff bfa1 	b.w	d0f4 <ble_ll_conn_enqueue_pkt>
    } else {
        /* No connection found! */
        STATS_INC(ble_ll_conn_stats, handle_not_found);
    d1b2:	6993      	ldr	r3, [r2, #24]
        os_mbuf_free_chain(om);
    d1b4:	4620      	mov	r0, r4

        /* Clear flags field in BLE header */
        ble_ll_conn_enqueue_pkt(connsm, om, hdr_byte, length);
    } else {
        /* No connection found! */
        STATS_INC(ble_ll_conn_stats, handle_not_found);
    d1b6:	3301      	adds	r3, #1
        os_mbuf_free_chain(om);
    }
}
    d1b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

        /* Clear flags field in BLE header */
        ble_ll_conn_enqueue_pkt(connsm, om, hdr_byte, length);
    } else {
        /* No connection found! */
        STATS_INC(ble_ll_conn_stats, handle_not_found);
    d1bc:	6193      	str	r3, [r2, #24]
        os_mbuf_free_chain(om);
    d1be:	f7fc bece 	b.w	9f5e <os_mbuf_free_chain>
    d1c2:	bf00      	nop
    d1c4:	20003580 	.word	0x20003580

0000d1c8 <ble_ll_conn_set_global_chanmap>:
 * @param num_used_chans
 * @param chanmap
 */
void
ble_ll_conn_set_global_chanmap(uint8_t num_used_chans, uint8_t *chanmap)
{
    d1c8:	b570      	push	{r4, r5, r6, lr}
    struct ble_ll_conn_sm *connsm;
    struct ble_ll_conn_global_params *conn_params;

    /* Do nothing if same channel map */
    conn_params = &g_ble_ll_conn_params;
    if (!memcmp(conn_params->master_chan_map, chanmap, BLE_LL_CONN_CHMAP_LEN)) {
    d1ca:	4c0d      	ldr	r4, [pc, #52]	; (d200 <ble_ll_conn_set_global_chanmap+0x38>)
 * @param num_used_chans
 * @param chanmap
 */
void
ble_ll_conn_set_global_chanmap(uint8_t num_used_chans, uint8_t *chanmap)
{
    d1cc:	4606      	mov	r6, r0
    struct ble_ll_conn_sm *connsm;
    struct ble_ll_conn_global_params *conn_params;

    /* Do nothing if same channel map */
    conn_params = &g_ble_ll_conn_params;
    if (!memcmp(conn_params->master_chan_map, chanmap, BLE_LL_CONN_CHMAP_LEN)) {
    d1ce:	2205      	movs	r2, #5
    d1d0:	4620      	mov	r0, r4
 * @param num_used_chans
 * @param chanmap
 */
void
ble_ll_conn_set_global_chanmap(uint8_t num_used_chans, uint8_t *chanmap)
{
    d1d2:	460d      	mov	r5, r1
    struct ble_ll_conn_sm *connsm;
    struct ble_ll_conn_global_params *conn_params;

    /* Do nothing if same channel map */
    conn_params = &g_ble_ll_conn_params;
    if (!memcmp(conn_params->master_chan_map, chanmap, BLE_LL_CONN_CHMAP_LEN)) {
    d1d4:	f7fb ff04 	bl	8fe0 <memcmp>
    d1d8:	b180      	cbz	r0, d1fc <ble_ll_conn_set_global_chanmap+0x34>
        return;
    }

    /* Change channel map and cause channel map update procedure to start */
    conn_params->num_used_chans = num_used_chans;
    d1da:	7166      	strb	r6, [r4, #5]
    memcpy(conn_params->master_chan_map, chanmap, BLE_LL_CONN_CHMAP_LEN);
    d1dc:	682b      	ldr	r3, [r5, #0]
    d1de:	6023      	str	r3, [r4, #0]
    d1e0:	792b      	ldrb	r3, [r5, #4]
    d1e2:	7123      	strb	r3, [r4, #4]

    /* Perform channel map update */
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d1e4:	4b07      	ldr	r3, [pc, #28]	; (d204 <ble_ll_conn_set_global_chanmap+0x3c>)
    d1e6:	681c      	ldr	r4, [r3, #0]
    d1e8:	b144      	cbz	r4, d1fc <ble_ll_conn_set_global_chanmap+0x34>
        if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    d1ea:	79e1      	ldrb	r1, [r4, #7]
    d1ec:	2901      	cmp	r1, #1
    d1ee:	d102      	bne.n	d1f6 <ble_ll_conn_set_global_chanmap+0x2e>
            ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_CHAN_MAP_UPD);
    d1f0:	4620      	mov	r0, r4
    d1f2:	f001 f955 	bl	e4a0 <ble_ll_ctrl_proc_start>
    /* Change channel map and cause channel map update procedure to start */
    conn_params->num_used_chans = num_used_chans;
    memcpy(conn_params->master_chan_map, chanmap, BLE_LL_CONN_CHMAP_LEN);

    /* Perform channel map update */
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d1f6:	f8d4 40bc 	ldr.w	r4, [r4, #188]	; 0xbc
    d1fa:	e7f5      	b.n	d1e8 <ble_ll_conn_set_global_chanmap+0x20>
    d1fc:	bd70      	pop	{r4, r5, r6, pc}
    d1fe:	bf00      	nop
    d200:	200033b8 	.word	0x200033b8
    d204:	200035f4 	.word	0x200035f4

0000d208 <ble_ll_conn_slave_start>:
 *
 * @return 0: connection not started; 1 connecton started
 */
int
ble_ll_conn_slave_start(uint8_t *rxbuf, uint32_t conn_req_end, uint8_t pat)
{
    d208:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint8_t *dptr;
    struct ble_ll_conn_sm *connsm;

    /* Ignore the connection request if we are already connected*/
    inita = rxbuf + BLE_LL_PDU_HDR_LEN;
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d20c:	4e66      	ldr	r6, [pc, #408]	; (d3a8 <ble_ll_conn_slave_start+0x1a0>)
    d20e:	6834      	ldr	r4, [r6, #0]
 *
 * @return 0: connection not started; 1 connecton started
 */
int
ble_ll_conn_slave_start(uint8_t *rxbuf, uint32_t conn_req_end, uint8_t pat)
{
    d210:	4605      	mov	r5, r0
    d212:	4688      	mov	r8, r1
    d214:	4691      	mov	r9, r2
    uint8_t *inita;
    uint8_t *dptr;
    struct ble_ll_conn_sm *connsm;

    /* Ignore the connection request if we are already connected*/
    inita = rxbuf + BLE_LL_PDU_HDR_LEN;
    d216:	1c87      	adds	r7, r0, #2
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d218:	b1b4      	cbz	r4, d248 <ble_ll_conn_slave_start+0x40>
        if (!memcmp(&connsm->peer_addr, inita, BLE_DEV_ADDR_LEN)) {
    d21a:	f104 007e 	add.w	r0, r4, #126	; 0x7e
    d21e:	4639      	mov	r1, r7
    d220:	2206      	movs	r2, #6
    d222:	f7fb fedd 	bl	8fe0 <memcmp>
    d226:	b960      	cbnz	r0, d242 <ble_ll_conn_slave_start+0x3a>
            if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
    d228:	782b      	ldrb	r3, [r5, #0]
    d22a:	f013 0f40 	tst.w	r3, #64	; 0x40
    d22e:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
    d232:	d004      	beq.n	d23e <ble_ll_conn_slave_start+0x36>
                if (connsm->peer_addr_type & 1) {
    d234:	07da      	lsls	r2, r3, #31
    d236:	d504      	bpl.n	d242 <ble_ll_conn_slave_start+0x3a>
                    return 0;
    d238:	2000      	movs	r0, #0
    d23a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                }
            } else {
                if ((connsm->peer_addr_type & 1) == 0) {
    d23e:	07db      	lsls	r3, r3, #31
    d240:	d5fa      	bpl.n	d238 <ble_ll_conn_slave_start+0x30>
    uint8_t *dptr;
    struct ble_ll_conn_sm *connsm;

    /* Ignore the connection request if we are already connected*/
    inita = rxbuf + BLE_LL_PDU_HDR_LEN;
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d242:	f8d4 40bc 	ldr.w	r4, [r4, #188]	; 0xbc
    d246:	e7e7      	b.n	d218 <ble_ll_conn_slave_start+0x10>
            }
        }
    }

    /* Allocate a connection. If none available, dont do anything */
    connsm = ble_ll_conn_sm_get();
    d248:	f7fe ffa2 	bl	c190 <ble_ll_conn_sm_get>
    if (connsm == NULL) {
    d24c:	4604      	mov	r4, r0
    d24e:	2800      	cmp	r0, #0
    d250:	d0f2      	beq.n	d238 <ble_ll_conn_slave_start+0x30>

    /* Set the pointer at the start of the connection data */
    dptr = rxbuf + BLE_LL_CONN_REQ_ADVA_OFF + BLE_DEV_ADDR_LEN;

    /* Set connection state machine information */
    connsm->access_addr = le32toh(dptr);
    d252:	f105 000e 	add.w	r0, r5, #14
    d256:	f00f ff1f 	bl	1d098 <le32toh>
    d25a:	64a0      	str	r0, [r4, #72]	; 0x48
    crcinit = dptr[6];
    crcinit = (crcinit << 8) | dptr[5];
    d25c:	7ceb      	ldrb	r3, [r5, #19]
    /* Set the pointer at the start of the connection data */
    dptr = rxbuf + BLE_LL_CONN_REQ_ADVA_OFF + BLE_DEV_ADDR_LEN;

    /* Set connection state machine information */
    connsm->access_addr = le32toh(dptr);
    crcinit = dptr[6];
    d25e:	7d2a      	ldrb	r2, [r5, #20]
    crcinit = (crcinit << 8) | dptr[5];
    d260:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
    crcinit = (crcinit << 8) | dptr[4];
    d264:	7cab      	ldrb	r3, [r5, #18]
    d266:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    connsm->crcinit = crcinit;
    d26a:	64e3      	str	r3, [r4, #76]	; 0x4c
    connsm->tx_win_size = dptr[7];
    d26c:	7d6b      	ldrb	r3, [r5, #21]
    d26e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    connsm->tx_win_off = le16toh(dptr + 8);
    d272:	f105 0016 	add.w	r0, r5, #22
    d276:	f00f ff0a 	bl	1d08e <le16toh>
    d27a:	f8a4 006a 	strh.w	r0, [r4, #106]	; 0x6a
    connsm->conn_itvl = le16toh(dptr + 10);
    d27e:	f105 0018 	add.w	r0, r5, #24
    d282:	f00f ff04 	bl	1d08e <le16toh>
    d286:	f8a4 0060 	strh.w	r0, [r4, #96]	; 0x60
    connsm->slave_latency = le16toh(dptr + 12);
    d28a:	f105 001a 	add.w	r0, r5, #26
    d28e:	f00f fefe 	bl	1d08e <le16toh>
    d292:	f8a4 0062 	strh.w	r0, [r4, #98]	; 0x62
    connsm->supervision_tmo = le16toh(dptr + 14);
    d296:	f105 001c 	add.w	r0, r5, #28
    d29a:	f00f fef8 	bl	1d08e <le16toh>
    memcpy(&connsm->chanmap, dptr + 16, BLE_LL_CONN_CHMAP_LEN);
    d29e:	462b      	mov	r3, r5
    connsm->crcinit = crcinit;
    connsm->tx_win_size = dptr[7];
    connsm->tx_win_off = le16toh(dptr + 8);
    connsm->conn_itvl = le16toh(dptr + 10);
    connsm->slave_latency = le16toh(dptr + 12);
    connsm->supervision_tmo = le16toh(dptr + 14);
    d2a0:	f8a4 0064 	strh.w	r0, [r4, #100]	; 0x64
    memcpy(&connsm->chanmap, dptr + 16, BLE_LL_CONN_CHMAP_LEN);
    d2a4:	f853 2f1e 	ldr.w	r2, [r3, #30]!
    d2a8:	f8c4 201a 	str.w	r2, [r4, #26]
    d2ac:	791b      	ldrb	r3, [r3, #4]
    d2ae:	77a3      	strb	r3, [r4, #30]
    connsm->hop_inc = dptr[21] & 0x1F;
    d2b0:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
    connsm->master_sca = dptr[21] >> 5;

    /* Error check parameters */
    if ((connsm->tx_win_off > connsm->conn_itvl) ||
    d2b4:	f8b4 206a 	ldrh.w	r2, [r4, #106]	; 0x6a
    connsm->tx_win_off = le16toh(dptr + 8);
    connsm->conn_itvl = le16toh(dptr + 10);
    connsm->slave_latency = le16toh(dptr + 12);
    connsm->supervision_tmo = le16toh(dptr + 14);
    memcpy(&connsm->chanmap, dptr + 16, BLE_LL_CONN_CHMAP_LEN);
    connsm->hop_inc = dptr[21] & 0x1F;
    d2b8:	f003 031f 	and.w	r3, r3, #31
    d2bc:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
    connsm->master_sca = dptr[21] >> 5;
    d2c0:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
    d2c4:	095b      	lsrs	r3, r3, #5
    d2c6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    /* Error check parameters */
    if ((connsm->tx_win_off > connsm->conn_itvl) ||
    d2ca:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    d2ce:	429a      	cmp	r2, r3
    connsm->tx_win_size = dptr[7];
    connsm->tx_win_off = le16toh(dptr + 8);
    connsm->conn_itvl = le16toh(dptr + 10);
    connsm->slave_latency = le16toh(dptr + 12);
    connsm->supervision_tmo = le16toh(dptr + 14);
    memcpy(&connsm->chanmap, dptr + 16, BLE_LL_CONN_CHMAP_LEN);
    d2d0:	f104 0e1a 	add.w	lr, r4, #26
    connsm->hop_inc = dptr[21] & 0x1F;
    connsm->master_sca = dptr[21] >> 5;

    /* Error check parameters */
    if ((connsm->tx_win_off > connsm->conn_itvl) ||
    d2d4:	d859      	bhi.n	d38a <ble_ll_conn_slave_start+0x182>
    d2d6:	1f9a      	subs	r2, r3, #6
    d2d8:	b292      	uxth	r2, r2
    d2da:	f640 417a 	movw	r1, #3194	; 0xc7a
    d2de:	428a      	cmp	r2, r1
    d2e0:	d853      	bhi.n	d38a <ble_ll_conn_slave_start+0x182>
        (connsm->conn_itvl < BLE_HCI_CONN_ITVL_MIN) ||
        (connsm->conn_itvl > BLE_HCI_CONN_ITVL_MAX) ||
        (connsm->tx_win_size < BLE_LL_CONN_TX_WIN_MIN) ||
    d2e2:	f894 c035 	ldrb.w	ip, [r4, #53]	; 0x35
    connsm->master_sca = dptr[21] >> 5;

    /* Error check parameters */
    if ((connsm->tx_win_off > connsm->conn_itvl) ||
        (connsm->conn_itvl < BLE_HCI_CONN_ITVL_MIN) ||
        (connsm->conn_itvl > BLE_HCI_CONN_ITVL_MAX) ||
    d2e6:	f1bc 0f00 	cmp.w	ip, #0
    d2ea:	d04e      	beq.n	d38a <ble_ll_conn_slave_start+0x182>
        (connsm->tx_win_size < BLE_LL_CONN_TX_WIN_MIN) ||
        (connsm->slave_latency > BLE_LL_CONN_SLAVE_LATENCY_MAX)) {
    d2ec:	f8b4 a062 	ldrh.w	sl, [r4, #98]	; 0x62

    /* Error check parameters */
    if ((connsm->tx_win_off > connsm->conn_itvl) ||
        (connsm->conn_itvl < BLE_HCI_CONN_ITVL_MIN) ||
        (connsm->conn_itvl > BLE_HCI_CONN_ITVL_MAX) ||
        (connsm->tx_win_size < BLE_LL_CONN_TX_WIN_MIN) ||
    d2f0:	f5ba 7ffa 	cmp.w	sl, #500	; 0x1f4
    d2f4:	d249      	bcs.n	d38a <ble_ll_conn_slave_start+0x182>
    }

    /* Slave latency cannot cause a supervision timeout */
    temp = (connsm->slave_latency + 1) * (connsm->conn_itvl * 2) *
            BLE_LL_CONN_ITVL_USECS;
    if ((connsm->supervision_tmo * 10000) <= temp ) {
    d2f6:	f242 7110 	movw	r1, #10000	; 0x2710
    d2fa:	fb01 f500 	mul.w	r5, r1, r0
        (connsm->slave_latency > BLE_LL_CONN_SLAVE_LATENCY_MAX)) {
        goto err_slave_start;
    }

    /* Slave latency cannot cause a supervision timeout */
    temp = (connsm->slave_latency + 1) * (connsm->conn_itvl * 2) *
    d2fe:	f640 11c4 	movw	r1, #2500	; 0x9c4
    d302:	fb01 f203 	mul.w	r2, r1, r3
    d306:	fb0a 2202 	mla	r2, sl, r2, r2
            BLE_LL_CONN_ITVL_USECS;
    if ((connsm->supervision_tmo * 10000) <= temp ) {
    d30a:	4295      	cmp	r5, r2
    d30c:	d93d      	bls.n	d38a <ble_ll_conn_slave_start+0x182>

    /*
     * The transmit window must be less than or equal to the lesser of 10
     * msecs or the connection interval minus 1.25 msecs.
     */
    temp = connsm->conn_itvl - 1;
    d30e:	3b01      	subs	r3, #1
    d310:	2b08      	cmp	r3, #8
    d312:	bfa8      	it	ge
    d314:	2308      	movge	r3, #8
    if (temp > 8) {
        temp = 8;
    }
    if (connsm->tx_win_size > temp) {
    d316:	459c      	cmp	ip, r3
    d318:	d837      	bhi.n	d38a <ble_ll_conn_slave_start+0x182>
        goto err_slave_start;
    }

    /* Set the address of device that we are connecting with */
    memcpy(&connsm->peer_addr, inita, BLE_DEV_ADDR_LEN);
    d31a:	683b      	ldr	r3, [r7, #0]
    d31c:	f8c4 307e 	str.w	r3, [r4, #126]	; 0x7e
    d320:	88bb      	ldrh	r3, [r7, #4]
    d322:	f8a4 3082 	strh.w	r3, [r4, #130]	; 0x82
    connsm->peer_addr_type = pat;
    d326:	f884 907d 	strb.w	r9, [r4, #125]	; 0x7d

    /* Calculate number of used channels; make sure it meets min requirement */
    connsm->num_used_chans = ble_ll_conn_calc_used_chans(connsm->chanmap);
    d32a:	4670      	mov	r0, lr
    d32c:	f7fe ff5e 	bl	c1ec <ble_ll_conn_calc_used_chans>
    if (connsm->num_used_chans < 2) {
    d330:	2801      	cmp	r0, #1
    /* Set the address of device that we are connecting with */
    memcpy(&connsm->peer_addr, inita, BLE_DEV_ADDR_LEN);
    connsm->peer_addr_type = pat;

    /* Calculate number of used channels; make sure it meets min requirement */
    connsm->num_used_chans = ble_ll_conn_calc_used_chans(connsm->chanmap);
    d332:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
    if (connsm->num_used_chans < 2) {
    d336:	d928      	bls.n	d38a <ble_ll_conn_slave_start+0x182>
        goto err_slave_start;
    }

    /* Start the connection state machine */
    connsm->conn_role = BLE_LL_CONN_ROLE_SLAVE;
    d338:	2302      	movs	r3, #2
    d33a:	71e3      	strb	r3, [r4, #7]
    ble_ll_conn_sm_new(connsm);
    d33c:	4620      	mov	r0, r4
    d33e:	f7ff f999 	bl	c674 <ble_ll_conn_sm_new>

    /* Set initial schedule callback */
    connsm->conn_sch.sched_cb = ble_ll_conn_event_start_cb;
    d342:	4b1a      	ldr	r3, [pc, #104]	; (d3ac <ble_ll_conn_slave_start+0x1a4>)
    d344:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0

    rc = ble_ll_conn_created(connsm, conn_req_end);
    d348:	4620      	mov	r0, r4
    d34a:	4641      	mov	r1, r8
    d34c:	f7ff f870 	bl	c430 <ble_ll_conn_created>
    if (!rc) {
    d350:	bb38      	cbnz	r0, d3a2 <ble_ll_conn_slave_start+0x19a>
        SLIST_REMOVE(&g_ble_ll_conn_active_list, connsm, ble_ll_conn_sm, act_sle);
    d352:	6833      	ldr	r3, [r6, #0]
    d354:	42a3      	cmp	r3, r4
    d356:	d104      	bne.n	d362 <ble_ll_conn_slave_start+0x15a>
    d358:	4b13      	ldr	r3, [pc, #76]	; (d3a8 <ble_ll_conn_slave_start+0x1a0>)
    d35a:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    d35e:	601a      	str	r2, [r3, #0]
    d360:	e009      	b.n	d376 <ble_ll_conn_slave_start+0x16e>
    d362:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
    d366:	42a2      	cmp	r2, r4
    d368:	d001      	beq.n	d36e <ble_ll_conn_slave_start+0x166>
    d36a:	4613      	mov	r3, r2
    d36c:	e7f9      	b.n	d362 <ble_ll_conn_slave_start+0x15a>
    d36e:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    d372:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
        STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    d376:	4b0e      	ldr	r3, [pc, #56]	; (d3b0 <ble_ll_conn_slave_start+0x1a8>)
    d378:	685a      	ldr	r2, [r3, #4]
    d37a:	2000      	movs	r0, #0
    d37c:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    d380:	6014      	str	r4, [r2, #0]
    d382:	34bc      	adds	r4, #188	; 0xbc
    d384:	605c      	str	r4, [r3, #4]
    d386:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
    return rc;

err_slave_start:
    STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    d38a:	4b09      	ldr	r3, [pc, #36]	; (d3b0 <ble_ll_conn_slave_start+0x1a8>)
    d38c:	685a      	ldr	r2, [r3, #4]
    d38e:	2000      	movs	r0, #0
    d390:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    d394:	6014      	str	r4, [r2, #0]
    STATS_INC(ble_ll_conn_stats, slave_rxd_bad_conn_req_params);
    d396:	4a07      	ldr	r2, [pc, #28]	; (d3b4 <ble_ll_conn_slave_start+0x1ac>)
        STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    }
    return rc;

err_slave_start:
    STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    d398:	34bc      	adds	r4, #188	; 0xbc
    d39a:	605c      	str	r4, [r3, #4]
    STATS_INC(ble_ll_conn_stats, slave_rxd_bad_conn_req_params);
    d39c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    d39e:	3301      	adds	r3, #1
    d3a0:	62d3      	str	r3, [r2, #44]	; 0x2c
    return 0;
}
    d3a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d3a6:	bf00      	nop
    d3a8:	200035f4 	.word	0x200035f4
    d3ac:	0000c005 	.word	0x0000c005
    d3b0:	200033d0 	.word	0x200033d0
    d3b4:	20003580 	.word	0x20003580

0000d3b8 <ble_ll_conn_module_reset>:
    uint16_t maxbytes;
    struct ble_ll_conn_sm *connsm;
    struct ble_ll_conn_global_params *conn_params;

    /* Kill the current one first (if one is running) */
    if (g_ble_ll_conn_cur_sm) {
    d3b8:	4b1f      	ldr	r3, [pc, #124]	; (d438 <ble_ll_conn_module_reset+0x80>)
    d3ba:	6818      	ldr	r0, [r3, #0]
 *
 * Context: Link Layer task
 */
void
ble_ll_conn_module_reset(void)
{
    d3bc:	b510      	push	{r4, lr}
    uint16_t maxbytes;
    struct ble_ll_conn_sm *connsm;
    struct ble_ll_conn_global_params *conn_params;

    /* Kill the current one first (if one is running) */
    if (g_ble_ll_conn_cur_sm) {
    d3be:	b118      	cbz	r0, d3c8 <ble_ll_conn_module_reset+0x10>
        connsm = g_ble_ll_conn_cur_sm;
        g_ble_ll_conn_cur_sm = NULL;
    d3c0:	2100      	movs	r1, #0
    d3c2:	6019      	str	r1, [r3, #0]
        ble_ll_conn_end(connsm, BLE_ERR_SUCCESS);
    d3c4:	f7ff fa0e 	bl	c7e4 <ble_ll_conn_end>
    }

    /* Now go through and end all the connections */
    while (1) {
        connsm = SLIST_FIRST(&g_ble_ll_conn_active_list);
    d3c8:	4b1c      	ldr	r3, [pc, #112]	; (d43c <ble_ll_conn_module_reset+0x84>)
    d3ca:	6818      	ldr	r0, [r3, #0]
        if (!connsm) {
    d3cc:	b108      	cbz	r0, d3d2 <ble_ll_conn_module_reset+0x1a>
            break;
        }
        ble_ll_conn_end(connsm, BLE_ERR_SUCCESS);
    d3ce:	2100      	movs	r1, #0
    d3d0:	e7f8      	b.n	d3c4 <ble_ll_conn_module_reset+0xc>

    /* Get the maximum supported PHY PDU size from the PHY */

    /* Configure the global LL parameters */
    conn_params = &g_ble_ll_conn_params;
    max_phy_pyld = ble_phy_max_data_pdu_pyld();
    d3d2:	f004 f969 	bl	116a8 <ble_phy_max_data_pdu_pyld>

    maxbytes = min(NIMBLE_OPT_LL_SUPP_MAX_RX_BYTES, max_phy_pyld);
    conn_params->supp_max_rx_octets = maxbytes;
    d3d6:	4c1a      	ldr	r4, [pc, #104]	; (d440 <ble_ll_conn_module_reset+0x88>)

    /* Configure the global LL parameters */
    conn_params = &g_ble_ll_conn_params;
    max_phy_pyld = ble_phy_max_data_pdu_pyld();

    maxbytes = min(NIMBLE_OPT_LL_SUPP_MAX_RX_BYTES, max_phy_pyld);
    d3d8:	28fb      	cmp	r0, #251	; 0xfb
    d3da:	bf94      	ite	ls
    d3dc:	b283      	uxthls	r3, r0
    d3de:	23fb      	movhi	r3, #251	; 0xfb
    conn_params->supp_max_rx_octets = maxbytes;
    d3e0:	71e3      	strb	r3, [r4, #7]
    conn_params->supp_max_rx_time =
    d3e2:	330e      	adds	r3, #14
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_SUPP_MAX_TX_BYTES, max_phy_pyld);
    d3e4:	28fb      	cmp	r0, #251	; 0xfb
    conn_params = &g_ble_ll_conn_params;
    max_phy_pyld = ble_phy_max_data_pdu_pyld();

    maxbytes = min(NIMBLE_OPT_LL_SUPP_MAX_RX_BYTES, max_phy_pyld);
    conn_params->supp_max_rx_octets = maxbytes;
    conn_params->supp_max_rx_time =
    d3e6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    d3ea:	8223      	strh	r3, [r4, #16]
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_SUPP_MAX_TX_BYTES, max_phy_pyld);
    d3ec:	bf94      	ite	ls
    d3ee:	b283      	uxthls	r3, r0
    d3f0:	23fb      	movhi	r3, #251	; 0xfb
    conn_params->supp_max_tx_octets = maxbytes;
    d3f2:	71a3      	strb	r3, [r4, #6]
    conn_params->supp_max_tx_time =
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_CONN_INIT_MAX_TX_BYTES, max_phy_pyld);
    d3f4:	281b      	cmp	r0, #27
    conn_params->supp_max_rx_time =
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_SUPP_MAX_TX_BYTES, max_phy_pyld);
    conn_params->supp_max_tx_octets = maxbytes;
    conn_params->supp_max_tx_time =
    d3f6:	f103 030e 	add.w	r3, r3, #14
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_CONN_INIT_MAX_TX_BYTES, max_phy_pyld);
    d3fa:	bf94      	ite	ls
    d3fc:	b280      	uxthls	r0, r0
    d3fe:	201b      	movhi	r0, #27
    conn_params->supp_max_rx_time =
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_SUPP_MAX_TX_BYTES, max_phy_pyld);
    conn_params->supp_max_tx_octets = maxbytes;
    conn_params->supp_max_tx_time =
    d400:	00db      	lsls	r3, r3, #3
    d402:	81e3      	strh	r3, [r4, #14]
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_CONN_INIT_MAX_TX_BYTES, max_phy_pyld);
    conn_params->conn_init_max_tx_octets = maxbytes;
    d404:	7220      	strb	r0, [r4, #8]
    conn_params->conn_init_max_tx_time =
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    conn_params->sugg_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    d406:	231b      	movs	r3, #27
    conn_params->supp_max_tx_time =
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_CONN_INIT_MAX_TX_BYTES, max_phy_pyld);
    conn_params->conn_init_max_tx_octets = maxbytes;
    conn_params->conn_init_max_tx_time =
    d408:	300e      	adds	r0, #14
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    conn_params->sugg_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    d40a:	7263      	strb	r3, [r4, #9]
    conn_params->supp_max_tx_time =
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_CONN_INIT_MAX_TX_BYTES, max_phy_pyld);
    conn_params->conn_init_max_tx_octets = maxbytes;
    conn_params->conn_init_max_tx_time =
    d40c:	00c0      	lsls	r0, r0, #3
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    conn_params->sugg_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    conn_params->sugg_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    d40e:	f44f 73a4 	mov.w	r3, #328	; 0x148
    conn_params->supp_max_tx_time =
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    maxbytes = min(NIMBLE_OPT_LL_CONN_INIT_MAX_TX_BYTES, max_phy_pyld);
    conn_params->conn_init_max_tx_octets = maxbytes;
    conn_params->conn_init_max_tx_time =
    d412:	81a0      	strh	r0, [r4, #12]
        BLE_TX_DUR_USECS_M(maxbytes + BLE_LL_DATA_MIC_LEN);

    conn_params->sugg_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    conn_params->sugg_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;
    d414:	8163      	strh	r3, [r4, #10]

    /* Mask in all channels by default */
    conn_params->num_used_chans = BLE_PHY_NUM_DATA_CHANS;
    memset(conn_params->master_chan_map, 0xff, BLE_LL_CONN_CHMAP_LEN - 1);
    d416:	21ff      	movs	r1, #255	; 0xff

    conn_params->sugg_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    conn_params->sugg_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;

    /* Mask in all channels by default */
    conn_params->num_used_chans = BLE_PHY_NUM_DATA_CHANS;
    d418:	2325      	movs	r3, #37	; 0x25
    memset(conn_params->master_chan_map, 0xff, BLE_LL_CONN_CHMAP_LEN - 1);
    d41a:	2204      	movs	r2, #4
    d41c:	4808      	ldr	r0, [pc, #32]	; (d440 <ble_ll_conn_module_reset+0x88>)

    conn_params->sugg_tx_octets = BLE_LL_CONN_SUPP_BYTES_MIN;
    conn_params->sugg_tx_time = BLE_LL_CONN_SUPP_TIME_MIN;

    /* Mask in all channels by default */
    conn_params->num_used_chans = BLE_PHY_NUM_DATA_CHANS;
    d41e:	7163      	strb	r3, [r4, #5]
    memset(conn_params->master_chan_map, 0xff, BLE_LL_CONN_CHMAP_LEN - 1);
    d420:	f7fb fdf7 	bl	9012 <memset>
    conn_params->master_chan_map[4] = 0x1f;
    d424:	231f      	movs	r3, #31
    d426:	7123      	strb	r3, [r4, #4]

    /* Reset statistics */
    memset((uint8_t *)&ble_ll_conn_stats + sizeof(struct stats_hdr), 0,
    d428:	4806      	ldr	r0, [pc, #24]	; (d444 <ble_ll_conn_module_reset+0x8c>)
    d42a:	2100      	movs	r1, #0
    d42c:	2268      	movs	r2, #104	; 0x68
           sizeof(struct stats_ble_ll_conn_stats) - sizeof(struct stats_hdr));
}
    d42e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    conn_params->num_used_chans = BLE_PHY_NUM_DATA_CHANS;
    memset(conn_params->master_chan_map, 0xff, BLE_LL_CONN_CHMAP_LEN - 1);
    conn_params->master_chan_map[4] = 0x1f;

    /* Reset statistics */
    memset((uint8_t *)&ble_ll_conn_stats + sizeof(struct stats_hdr), 0,
    d432:	f7fb bdee 	b.w	9012 <memset>
    d436:	bf00      	nop
    d438:	200033cc 	.word	0x200033cc
    d43c:	200035f4 	.word	0x200035f4
    d440:	200033b8 	.word	0x200033b8
    d444:	2000358c 	.word	0x2000358c

0000d448 <ble_ll_conn_module_init>:
}

/* Initialize the connection module */
void
ble_ll_conn_module_init(void)
{
    d448:	b537      	push	{r0, r1, r2, r4, r5, lr}
     * the specification allows a handle of zero; we just avoid using it.
     */
    connsm = &g_ble_ll_conn_sm[0];
    for (i = 0; i < NIMBLE_OPT_MAX_CONNECTIONS; ++i) {

        memset(connsm, 0, sizeof(struct ble_ll_conn_sm));
    d44a:	4c16      	ldr	r4, [pc, #88]	; (d4a4 <ble_ll_conn_module_init+0x5c>)
    int rc;
    uint16_t i;
    struct ble_ll_conn_sm *connsm;

    /* Initialize list of active conections */
    SLIST_INIT(&g_ble_ll_conn_active_list);
    d44c:	4b16      	ldr	r3, [pc, #88]	; (d4a8 <ble_ll_conn_module_init+0x60>)
    d44e:	2500      	movs	r5, #0
     * the specification allows a handle of zero; we just avoid using it.
     */
    connsm = &g_ble_ll_conn_sm[0];
    for (i = 0; i < NIMBLE_OPT_MAX_CONNECTIONS; ++i) {

        memset(connsm, 0, sizeof(struct ble_ll_conn_sm));
    d450:	4629      	mov	r1, r5
    d452:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
    d456:	4620      	mov	r0, r4
    int rc;
    uint16_t i;
    struct ble_ll_conn_sm *connsm;

    /* Initialize list of active conections */
    SLIST_INIT(&g_ble_ll_conn_active_list);
    d458:	601d      	str	r5, [r3, #0]
     * the specification allows a handle of zero; we just avoid using it.
     */
    connsm = &g_ble_ll_conn_sm[0];
    for (i = 0; i < NIMBLE_OPT_MAX_CONNECTIONS; ++i) {

        memset(connsm, 0, sizeof(struct ble_ll_conn_sm));
    d45a:	f7fb fdda 	bl	9012 <memset>
        connsm->conn_handle = i + 1;
    d45e:	2301      	movs	r3, #1
    d460:	80a3      	strh	r3, [r4, #4]
        STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    d462:	4b12      	ldr	r3, [pc, #72]	; (d4ac <ble_ll_conn_module_init+0x64>)
        connsm->conn_sch.cb_arg = connsm;
        ++connsm;
    }

    /* Register connection statistics */
    rc = stats_init_and_reg(STATS_HDR(ble_ll_conn_stats),
    d464:	4812      	ldr	r0, [pc, #72]	; (d4b0 <ble_ll_conn_module_init+0x68>)
    connsm = &g_ble_ll_conn_sm[0];
    for (i = 0; i < NIMBLE_OPT_MAX_CONNECTIONS; ++i) {

        memset(connsm, 0, sizeof(struct ble_ll_conn_sm));
        connsm->conn_handle = i + 1;
        STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    d466:	601c      	str	r4, [r3, #0]
    d468:	f104 02bc 	add.w	r2, r4, #188	; 0xbc
    d46c:	605a      	str	r2, [r3, #4]

        /* Initialize fixed schedule elements */
        connsm->conn_sch.sched_type = BLE_LL_SCHED_TYPE_CONN;
    d46e:	2303      	movs	r3, #3
    d470:	f884 30e0 	strb.w	r3, [r4, #224]	; 0xe0
        connsm->conn_sch.cb_arg = connsm;
        ++connsm;
    }

    /* Register connection statistics */
    rc = stats_init_and_reg(STATS_HDR(ble_ll_conn_stats),
    d474:	4b0f      	ldr	r3, [pc, #60]	; (d4b4 <ble_ll_conn_module_init+0x6c>)
    d476:	9301      	str	r3, [sp, #4]
    d478:	9500      	str	r5, [sp, #0]
    d47a:	2104      	movs	r1, #4
    d47c:	221a      	movs	r2, #26
    d47e:	462b      	mov	r3, r5
        connsm->conn_handle = i + 1;
        STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);

        /* Initialize fixed schedule elements */
        connsm->conn_sch.sched_type = BLE_LL_SCHED_TYPE_CONN;
        connsm->conn_sch.cb_arg = connsm;
    d480:	f8c4 40ec 	str.w	r4, [r4, #236]	; 0xec
        ++connsm;
    }

    /* Register connection statistics */
    rc = stats_init_and_reg(STATS_HDR(ble_ll_conn_stats),
    d484:	f00f ff62 	bl	1d34c <stats_init_and_reg>
                            STATS_SIZE_INIT_PARMS(ble_ll_conn_stats, STATS_SIZE_32),
                            STATS_NAME_INIT_PARMS(ble_ll_conn_stats),
                            "ble_ll_conn");
    assert(rc == 0);
    d488:	b130      	cbz	r0, d498 <ble_ll_conn_module_init+0x50>
    d48a:	480b      	ldr	r0, [pc, #44]	; (d4b8 <ble_ll_conn_module_init+0x70>)
    d48c:	f640 4179 	movw	r1, #3193	; 0xc79
    d490:	462a      	mov	r2, r5
    d492:	462b      	mov	r3, r5
    d494:	f7fc fc1c 	bl	9cd0 <__assert_func>

    /* Call reset to finish reset of initialization */
    ble_ll_conn_module_reset();
}
    d498:	b003      	add	sp, #12
    d49a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
                            STATS_NAME_INIT_PARMS(ble_ll_conn_stats),
                            "ble_ll_conn");
    assert(rc == 0);

    /* Call reset to finish reset of initialization */
    ble_ll_conn_module_reset();
    d49e:	f7ff bf8b 	b.w	d3b8 <ble_ll_conn_module_reset>
    d4a2:	bf00      	nop
    d4a4:	200033e0 	.word	0x200033e0
    d4a8:	200035f4 	.word	0x200035f4
    d4ac:	200033d0 	.word	0x200033d0
    d4b0:	20003580 	.word	0x20003580
    d4b4:	0001f261 	.word	0x0001f261
    d4b8:	0001f253 	.word	0x0001f253

0000d4bc <ble_ll_conn_hci_chk_conn_params>:
                                uint16_t latency, uint16_t spvn_tmo)
{
    uint32_t spvn_tmo_usecs;
    uint32_t min_spvn_tmo_usecs;

    if ((itvl_min > itvl_max) ||
    d4bc:	4288      	cmp	r0, r1
 * @return int BLE_ERR_INV_HCI_CMD_PARMS if invalid parameters, 0 otherwise
 */
int
ble_ll_conn_hci_chk_conn_params(uint16_t itvl_min, uint16_t itvl_max,
                                uint16_t latency, uint16_t spvn_tmo)
{
    d4be:	b510      	push	{r4, lr}
    uint32_t spvn_tmo_usecs;
    uint32_t min_spvn_tmo_usecs;

    if ((itvl_min > itvl_max) ||
    d4c0:	d81c      	bhi.n	d4fc <ble_ll_conn_hci_chk_conn_params+0x40>
    d4c2:	1f84      	subs	r4, r0, #6
    d4c4:	b2a4      	uxth	r4, r4
    d4c6:	f640 407a 	movw	r0, #3194	; 0xc7a
    d4ca:	4284      	cmp	r4, r0
    d4cc:	d816      	bhi.n	d4fc <ble_ll_conn_hci_chk_conn_params+0x40>
        (itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
        (itvl_min > BLE_HCI_CONN_ITVL_MAX) ||
    d4ce:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
    d4d2:	d213      	bcs.n	d4fc <ble_ll_conn_hci_chk_conn_params+0x40>
        (latency > BLE_HCI_CONN_LATENCY_MAX) ||
    d4d4:	f1a3 040a 	sub.w	r4, r3, #10
    d4d8:	b2a4      	uxth	r4, r4
    d4da:	f640 4076 	movw	r0, #3190	; 0xc76
    d4de:	4284      	cmp	r4, r0
    d4e0:	d80c      	bhi.n	d4fc <ble_ll_conn_hci_chk_conn_params+0x40>
    * Supervision timeout (in msecs) must be more than:
    *  (1 + connLatency) * connIntervalMax * 1.25 msecs * 2.
    */
    spvn_tmo_usecs = spvn_tmo;
    spvn_tmo_usecs *= (BLE_HCI_CONN_SPVN_TMO_UNITS * 1000);
    min_spvn_tmo_usecs = (uint32_t)itvl_max * 2 * BLE_LL_CONN_ITVL_USECS;
    d4e2:	f640 14c4 	movw	r4, #2500	; 0x9c4
    d4e6:	4361      	muls	r1, r4
    /*
    * Supervision timeout (in msecs) must be more than:
    *  (1 + connLatency) * connIntervalMax * 1.25 msecs * 2.
    */
    spvn_tmo_usecs = spvn_tmo;
    spvn_tmo_usecs *= (BLE_HCI_CONN_SPVN_TMO_UNITS * 1000);
    d4e8:	f242 7410 	movw	r4, #10000	; 0x2710
    d4ec:	4363      	muls	r3, r4
    min_spvn_tmo_usecs = (uint32_t)itvl_max * 2 * BLE_LL_CONN_ITVL_USECS;
    min_spvn_tmo_usecs *= (1 + latency);
    d4ee:	fb02 1101 	mla	r1, r2, r1, r1
    if (spvn_tmo_usecs <= min_spvn_tmo_usecs) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    return BLE_ERR_SUCCESS;
    d4f2:	428b      	cmp	r3, r1
    d4f4:	bf94      	ite	ls
    d4f6:	2012      	movls	r0, #18
    d4f8:	2000      	movhi	r0, #0
    d4fa:	bd10      	pop	{r4, pc}
        (itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
        (itvl_min > BLE_HCI_CONN_ITVL_MAX) ||
        (latency > BLE_HCI_CONN_LATENCY_MAX) ||
        (spvn_tmo < BLE_HCI_CONN_SPVN_TIMEOUT_MIN) ||
        (spvn_tmo > BLE_HCI_CONN_SPVN_TIMEOUT_MAX)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    d4fc:	2012      	movs	r0, #18
    if (spvn_tmo_usecs <= min_spvn_tmo_usecs) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    return BLE_ERR_SUCCESS;
}
    d4fe:	bd10      	pop	{r4, pc}

0000d500 <ble_ll_conn_comp_event_send>:
 *
 * @param status The BLE error code associated with the event
 */
void
ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    d500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d504:	4605      	mov	r5, r0
    uint8_t enh_enabled;
    uint8_t *evbuf;
    uint8_t *evdata;
    uint8_t *rpa;

    enabled = ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_CONN_COMPLETE);
    d506:	2001      	movs	r0, #1
 *
 * @param status The BLE error code associated with the event
 */
void
ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    d508:	460e      	mov	r6, r1
    uint8_t enh_enabled;
    uint8_t *evbuf;
    uint8_t *evdata;
    uint8_t *rpa;

    enabled = ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_CONN_COMPLETE);
    d50a:	f001 fb47 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
    d50e:	4604      	mov	r4, r0
    enh_enabled = ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE);
    d510:	200a      	movs	r0, #10
    d512:	f001 fb43 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
    d516:	4680      	mov	r8, r0

    if (enabled || enh_enabled) {
    d518:	b90c      	cbnz	r4, d51e <ble_ll_conn_comp_event_send+0x1e>
    d51a:	2800      	cmp	r0, #0
    d51c:	d06f      	beq.n	d5fe <ble_ll_conn_comp_event_send+0xfe>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    d51e:	4839      	ldr	r0, [pc, #228]	; (d604 <ble_ll_conn_comp_event_send+0x104>)
    d520:	f7fc ff6a 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    d524:	4604      	mov	r4, r0
    d526:	2800      	cmp	r0, #0
    d528:	d069      	beq.n	d5fe <ble_ll_conn_comp_event_send+0xfe>
            /* Put common elements in event */
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
    d52a:	233e      	movs	r3, #62	; 0x3e
    d52c:	7003      	strb	r3, [r0, #0]
            if (enh_enabled) {
    d52e:	f1b8 0f00 	cmp.w	r8, #0
    d532:	d003      	beq.n	d53c <ble_ll_conn_comp_event_send+0x3c>
                evbuf[1] = BLE_HCI_LE_ENH_CONN_COMPLETE_LEN;
    d534:	231f      	movs	r3, #31
    d536:	7043      	strb	r3, [r0, #1]
                evbuf[2] = BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE;
    d538:	230a      	movs	r3, #10
    d53a:	e002      	b.n	d542 <ble_ll_conn_comp_event_send+0x42>
            } else {
                evbuf[1] = BLE_HCI_LE_CONN_COMPLETE_LEN;
    d53c:	2313      	movs	r3, #19
    d53e:	7043      	strb	r3, [r0, #1]
                evbuf[2] = BLE_HCI_LE_SUBEV_CONN_COMPLETE;
    d540:	2301      	movs	r3, #1
    d542:	70a3      	strb	r3, [r4, #2]
            }
            evbuf[3] = status;
    d544:	70e6      	strb	r6, [r4, #3]

            if (connsm) {
    d546:	2d00      	cmp	r5, #0
    d548:	d054      	beq.n	d5f4 <ble_ll_conn_comp_event_send+0xf4>
                htole16(evbuf + 4, connsm->conn_handle);
    d54a:	1d20      	adds	r0, r4, #4
    d54c:	88a9      	ldrh	r1, [r5, #4]
    d54e:	f00f fd83 	bl	1d058 <htole16>
                evbuf[6] = connsm->conn_role - 1;
    d552:	79eb      	ldrb	r3, [r5, #7]
    d554:	3b01      	subs	r3, #1
    d556:	71a3      	strb	r3, [r4, #6]
                peer_addr_type = connsm->peer_addr_type;
    d558:	f895 707d 	ldrb.w	r7, [r5, #125]	; 0x7d

                evdata = evbuf + 14;
    d55c:	f104 060e 	add.w	r6, r4, #14
                if (enh_enabled) {
    d560:	f1b8 0f00 	cmp.w	r8, #0
    d564:	d029      	beq.n	d5ba <ble_ll_conn_comp_event_send+0xba>
                    memset(evdata, 0, 2 * BLE_DEV_ADDR_LEN);
    d566:	4630      	mov	r0, r6
    d568:	2100      	movs	r1, #0
    d56a:	220c      	movs	r2, #12
    d56c:	f7fb fd51 	bl	9012 <memset>
                    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    d570:	79eb      	ldrb	r3, [r5, #7]
    d572:	2b01      	cmp	r3, #1
    d574:	d106      	bne.n	d584 <ble_ll_conn_comp_event_send+0x84>
                        if (connsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    d576:	f895 307c 	ldrb.w	r3, [r5, #124]	; 0x7c
    d57a:	2b01      	cmp	r3, #1
    d57c:	d90a      	bls.n	d594 <ble_ll_conn_comp_event_send+0x94>
                            rpa = ble_ll_scan_get_local_rpa();
    d57e:	f002 fe8d 	bl	1029c <ble_ll_scan_get_local_rpa>
    d582:	e001      	b.n	d588 <ble_ll_conn_comp_event_send+0x88>
                        } else {
                            rpa = NULL;
                        }
                    } else {
                        rpa = ble_ll_adv_get_local_rpa();
    d584:	f7fe fac2 	bl	bb0c <ble_ll_adv_get_local_rpa>
                    }
                    if (rpa) {
    d588:	b120      	cbz	r0, d594 <ble_ll_conn_comp_event_send+0x94>
                        memcpy(evdata, rpa, BLE_DEV_ADDR_LEN);
    d58a:	6803      	ldr	r3, [r0, #0]
    d58c:	f8c4 300e 	str.w	r3, [r4, #14]
    d590:	8883      	ldrh	r3, [r0, #4]
    d592:	80b3      	strh	r3, [r6, #4]
                    }

                    if (connsm->peer_addr_type > BLE_HCI_CONN_PEER_ADDR_RANDOM) {
    d594:	f895 307d 	ldrb.w	r3, [r5, #125]	; 0x7d
    d598:	2b01      	cmp	r3, #1
    d59a:	d90b      	bls.n	d5b4 <ble_ll_conn_comp_event_send+0xb4>
                        if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    d59c:	79eb      	ldrb	r3, [r5, #7]
    d59e:	2b01      	cmp	r3, #1
    d5a0:	d102      	bne.n	d5a8 <ble_ll_conn_comp_event_send+0xa8>
                            rpa = ble_ll_scan_get_peer_rpa();
    d5a2:	f002 fe77 	bl	10294 <ble_ll_scan_get_peer_rpa>
    d5a6:	e001      	b.n	d5ac <ble_ll_conn_comp_event_send+0xac>
                        } else {
                            rpa = ble_ll_adv_get_peer_rpa();
    d5a8:	f7fe faba 	bl	bb20 <ble_ll_adv_get_peer_rpa>
                        }
                        memcpy(evdata + 6, rpa, BLE_DEV_ADDR_LEN);
    d5ac:	6803      	ldr	r3, [r0, #0]
    d5ae:	6163      	str	r3, [r4, #20]
    d5b0:	8883      	ldrh	r3, [r0, #4]
    d5b2:	8323      	strh	r3, [r4, #24]
                    }
                    evdata += 12;
    d5b4:	f104 061a 	add.w	r6, r4, #26
    d5b8:	e003      	b.n	d5c2 <ble_ll_conn_comp_event_send+0xc2>
                } else {
                    if (peer_addr_type > BLE_HCI_CONN_PEER_ADDR_RANDOM) {
    d5ba:	2f01      	cmp	r7, #1
                        peer_addr_type -= 2;
    d5bc:	bf84      	itt	hi
    d5be:	3f02      	subhi	r7, #2
    d5c0:	b2ff      	uxtbhi	r7, r7
                    }
                }

                evbuf[7] = peer_addr_type;
                memcpy(evbuf + 8, connsm->peer_addr, BLE_DEV_ADDR_LEN);
    d5c2:	462b      	mov	r3, r5
                    if (peer_addr_type > BLE_HCI_CONN_PEER_ADDR_RANDOM) {
                        peer_addr_type -= 2;
                    }
                }

                evbuf[7] = peer_addr_type;
    d5c4:	71e7      	strb	r7, [r4, #7]
                memcpy(evbuf + 8, connsm->peer_addr, BLE_DEV_ADDR_LEN);
    d5c6:	f853 2f7e 	ldr.w	r2, [r3, #126]!
    d5ca:	60a2      	str	r2, [r4, #8]
    d5cc:	889b      	ldrh	r3, [r3, #4]
    d5ce:	81a3      	strh	r3, [r4, #12]

                htole16(evdata, connsm->conn_itvl);
    d5d0:	4630      	mov	r0, r6
    d5d2:	f8b5 1060 	ldrh.w	r1, [r5, #96]	; 0x60
    d5d6:	f00f fd3f 	bl	1d058 <htole16>
                htole16(evdata + 2, connsm->slave_latency);
    d5da:	1cb0      	adds	r0, r6, #2
    d5dc:	f8b5 1062 	ldrh.w	r1, [r5, #98]	; 0x62
    d5e0:	f00f fd3a 	bl	1d058 <htole16>
                htole16(evdata + 4, connsm->supervision_tmo);
    d5e4:	1d30      	adds	r0, r6, #4
    d5e6:	f8b5 1064 	ldrh.w	r1, [r5, #100]	; 0x64
    d5ea:	f00f fd35 	bl	1d058 <htole16>
                evdata[6] = connsm->master_sca;
    d5ee:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
    d5f2:	71b3      	strb	r3, [r6, #6]
            }
            ble_ll_hci_event_send(evbuf);
    d5f4:	4620      	mov	r0, r4
        }
    }
}
    d5f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
                htole16(evdata, connsm->conn_itvl);
                htole16(evdata + 2, connsm->slave_latency);
                htole16(evdata + 4, connsm->supervision_tmo);
                evdata[6] = connsm->master_sca;
            }
            ble_ll_hci_event_send(evbuf);
    d5fa:	f001 baad 	b.w	eb58 <ble_ll_hci_event_send>
    d5fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d602:	bf00      	nop
    d604:	20003b5c 	.word	0x20003b5c

0000d608 <ble_ll_conn_num_comp_pkts_event_send>:
 *
 * @param connsm
 */
void
ble_ll_conn_num_comp_pkts_event_send(void)
{
    d608:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t *comp_pkt_ptr;
    uint8_t handles;
    struct ble_ll_conn_sm *connsm;

    /* Check rate limit */
    if ((uint32_t)(g_ble_ll_next_num_comp_pkt_evt - os_time_get()) <
    d60c:	4d31      	ldr	r5, [pc, #196]	; (d6d4 <ble_ll_conn_num_comp_pkts_event_send+0xcc>)
    d60e:	682c      	ldr	r4, [r5, #0]
    d610:	f7fd f8d6 	bl	a7c0 <os_time_get>
    d614:	1a20      	subs	r0, r4, r0
    d616:	28ff      	cmp	r0, #255	; 0xff
    d618:	46a8      	mov	r8, r5
    d61a:	d959      	bls.n	d6d0 <ble_ll_conn_num_comp_pkts_event_send+0xc8>
    evbuf = NULL;
    handles = 0;
    handle_ptr = NULL;
    comp_pkt_ptr = NULL;
    event_sent = 0;
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d61c:	4b2e      	ldr	r3, [pc, #184]	; (d6d8 <ble_ll_conn_num_comp_pkts_event_send+0xd0>)
        return;
    }

    /* Iterate through all the active, created connections */
    evbuf = NULL;
    handles = 0;
    d61e:	2400      	movs	r4, #0
    handle_ptr = NULL;
    comp_pkt_ptr = NULL;
    event_sent = 0;
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d620:	681e      	ldr	r6, [r3, #0]

    /* Iterate through all the active, created connections */
    evbuf = NULL;
    handles = 0;
    handle_ptr = NULL;
    comp_pkt_ptr = NULL;
    d622:	46a1      	mov	r9, r4
    }

    /* Iterate through all the active, created connections */
    evbuf = NULL;
    handles = 0;
    handle_ptr = NULL;
    d624:	4627      	mov	r7, r4
         NIMBLE_OPT_NUM_COMP_PKT_RATE) {
        return;
    }

    /* Iterate through all the active, created connections */
    evbuf = NULL;
    d626:	4625      	mov	r5, r4
    handles = 0;
    handle_ptr = NULL;
    comp_pkt_ptr = NULL;
    event_sent = 0;
    d628:	46a2      	mov	sl, r4
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d62a:	b3ae      	cbz	r6, d698 <ble_ll_conn_num_comp_pkts_event_send+0x90>
        /*
         * Only look at connections that we have sent a connection complete
         * event and that either has packets enqueued or has completed packets.
         */
        if ((connsm->conn_state != BLE_LL_CONN_STATE_IDLE) &&
    d62c:	79b3      	ldrb	r3, [r6, #6]
    d62e:	b383      	cbz	r3, d692 <ble_ll_conn_num_comp_pkts_event_send+0x8a>
    d630:	f8b6 3040 	ldrh.w	r3, [r6, #64]	; 0x40
    d634:	b913      	cbnz	r3, d63c <ble_ll_conn_num_comp_pkts_event_send+0x34>
            (connsm->completed_pkts || !STAILQ_EMPTY(&connsm->conn_txq))) {
    d636:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
    d63a:	b353      	cbz	r3, d692 <ble_ll_conn_num_comp_pkts_event_send+0x8a>
            /* If no buffer, get one, If cant get one, leave. */
            if (!evbuf) {
    d63c:	b945      	cbnz	r5, d650 <ble_ll_conn_num_comp_pkts_event_send+0x48>
                evbuf = os_memblock_get(&g_hci_evt_pool);
    d63e:	4827      	ldr	r0, [pc, #156]	; (d6dc <ble_ll_conn_num_comp_pkts_event_send+0xd4>)
    d640:	f7fc feda 	bl	a3f8 <os_memblock_get>
                if (!evbuf) {
    d644:	4605      	mov	r5, r0
    d646:	b3d0      	cbz	r0, d6be <ble_ll_conn_num_comp_pkts_event_send+0xb6>
                    break;
                }
                handles = 0;
                handle_ptr = evbuf + 3;
    d648:	1cc7      	adds	r7, r0, #3
                comp_pkt_ptr = handle_ptr + (sizeof(uint16_t) * 60);
    d64a:	f100 097b 	add.w	r9, r0, #123	; 0x7b
            if (!evbuf) {
                evbuf = os_memblock_get(&g_hci_evt_pool);
                if (!evbuf) {
                    break;
                }
                handles = 0;
    d64e:	2400      	movs	r4, #0
                handle_ptr = evbuf + 3;
                comp_pkt_ptr = handle_ptr + (sizeof(uint16_t) * 60);
            }

            /* Add handle and complete packets */
            htole16(handle_ptr, connsm->conn_handle);
    d650:	4638      	mov	r0, r7
    d652:	88b1      	ldrh	r1, [r6, #4]
            htole16(comp_pkt_ptr, connsm->completed_pkts);
            connsm->completed_pkts = 0;
            handle_ptr += sizeof(uint16_t);
            comp_pkt_ptr += sizeof(uint16_t);
            ++handles;
    d654:	3401      	adds	r4, #1
                handle_ptr = evbuf + 3;
                comp_pkt_ptr = handle_ptr + (sizeof(uint16_t) * 60);
            }

            /* Add handle and complete packets */
            htole16(handle_ptr, connsm->conn_handle);
    d656:	f00f fcff 	bl	1d058 <htole16>
            htole16(comp_pkt_ptr, connsm->completed_pkts);
            connsm->completed_pkts = 0;
            handle_ptr += sizeof(uint16_t);
            comp_pkt_ptr += sizeof(uint16_t);
            ++handles;
    d65a:	b2e4      	uxtb	r4, r4
                comp_pkt_ptr = handle_ptr + (sizeof(uint16_t) * 60);
            }

            /* Add handle and complete packets */
            htole16(handle_ptr, connsm->conn_handle);
            htole16(comp_pkt_ptr, connsm->completed_pkts);
    d65c:	4648      	mov	r0, r9
    d65e:	f8b6 1040 	ldrh.w	r1, [r6, #64]	; 0x40
    d662:	f00f fcf9 	bl	1d058 <htole16>
            connsm->completed_pkts = 0;
    d666:	f04f 0b00 	mov.w	fp, #0

            /*
             * The event buffer should fit at least 255 bytes so this means we
             * can fit up to 60 handles per event (a little more but who cares).
             */
            if (handles == 60) {
    d66a:	2c3c      	cmp	r4, #60	; 0x3c
            }

            /* Add handle and complete packets */
            htole16(handle_ptr, connsm->conn_handle);
            htole16(comp_pkt_ptr, connsm->completed_pkts);
            connsm->completed_pkts = 0;
    d66c:	f8a6 b040 	strh.w	fp, [r6, #64]	; 0x40
            handle_ptr += sizeof(uint16_t);
    d670:	f107 0702 	add.w	r7, r7, #2
            comp_pkt_ptr += sizeof(uint16_t);
    d674:	f109 0902 	add.w	r9, r9, #2

            /*
             * The event buffer should fit at least 255 bytes so this means we
             * can fit up to 60 handles per event (a little more but who cares).
             */
            if (handles == 60) {
    d678:	d10b      	bne.n	d692 <ble_ll_conn_num_comp_pkts_event_send+0x8a>
                evbuf[0] = BLE_HCI_EVCODE_NUM_COMP_PKTS;
    d67a:	2313      	movs	r3, #19
    d67c:	702b      	strb	r3, [r5, #0]
                evbuf[1] = (handles * 2 * sizeof(uint16_t)) + 1;
    d67e:	23f1      	movs	r3, #241	; 0xf1
                evbuf[2] = handles;
    d680:	70ac      	strb	r4, [r5, #2]
             * The event buffer should fit at least 255 bytes so this means we
             * can fit up to 60 handles per event (a little more but who cares).
             */
            if (handles == 60) {
                evbuf[0] = BLE_HCI_EVCODE_NUM_COMP_PKTS;
                evbuf[1] = (handles * 2 * sizeof(uint16_t)) + 1;
    d682:	706b      	strb	r3, [r5, #1]
                evbuf[2] = handles;
                ble_ll_hci_event_send(evbuf);
    d684:	4628      	mov	r0, r5
    d686:	f001 fa67 	bl	eb58 <ble_ll_hci_event_send>
                evbuf = NULL;
                handles = 0;
    d68a:	465c      	mov	r4, fp
            if (handles == 60) {
                evbuf[0] = BLE_HCI_EVCODE_NUM_COMP_PKTS;
                evbuf[1] = (handles * 2 * sizeof(uint16_t)) + 1;
                evbuf[2] = handles;
                ble_ll_hci_event_send(evbuf);
                evbuf = NULL;
    d68c:	465d      	mov	r5, fp
                handles = 0;
                event_sent = 1;
    d68e:	f04f 0a01 	mov.w	sl, #1
    evbuf = NULL;
    handles = 0;
    handle_ptr = NULL;
    comp_pkt_ptr = NULL;
    event_sent = 0;
    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
    d692:	f8d6 60bc 	ldr.w	r6, [r6, #188]	; 0xbc
    d696:	e7c8      	b.n	d62a <ble_ll_conn_num_comp_pkts_event_send+0x22>
            }
        }
    }

    /* Send event if there is an event to send */
    if (evbuf) {
    d698:	b18d      	cbz	r5, d6be <ble_ll_conn_num_comp_pkts_event_send+0xb6>
        evbuf[0] = BLE_HCI_EVCODE_NUM_COMP_PKTS;
    d69a:	2313      	movs	r3, #19
    d69c:	702b      	strb	r3, [r5, #0]
        evbuf[1] = (handles * 2 * sizeof(uint16_t)) + 1;
    d69e:	00a3      	lsls	r3, r4, #2
    d6a0:	3301      	adds	r3, #1
        evbuf[2] = handles;
        if (handles < 60) {
    d6a2:	2c3b      	cmp	r4, #59	; 0x3b
    }

    /* Send event if there is an event to send */
    if (evbuf) {
        evbuf[0] = BLE_HCI_EVCODE_NUM_COMP_PKTS;
        evbuf[1] = (handles * 2 * sizeof(uint16_t)) + 1;
    d6a4:	706b      	strb	r3, [r5, #1]
        evbuf[2] = handles;
    d6a6:	70ac      	strb	r4, [r5, #2]
        if (handles < 60) {
    d6a8:	d805      	bhi.n	d6b6 <ble_ll_conn_num_comp_pkts_event_send+0xae>
            /* Make the pkt counts contiguous with handles */
            memmove(handle_ptr, evbuf + 3 + (60 * 2), handles * 2);
    d6aa:	4638      	mov	r0, r7
    d6ac:	f105 017b 	add.w	r1, r5, #123	; 0x7b
    d6b0:	0062      	lsls	r2, r4, #1
    d6b2:	f010 fa0f 	bl	1dad4 <memmove>
        }
        ble_ll_hci_event_send(evbuf);
    d6b6:	4628      	mov	r0, r5
    d6b8:	f001 fa4e 	bl	eb58 <ble_ll_hci_event_send>
    d6bc:	e002      	b.n	d6c4 <ble_ll_conn_num_comp_pkts_event_send+0xbc>
        event_sent = 1;
    }

    if (event_sent) {
    d6be:	f1ba 0f00 	cmp.w	sl, #0
    d6c2:	d005      	beq.n	d6d0 <ble_ll_conn_num_comp_pkts_event_send+0xc8>
        g_ble_ll_next_num_comp_pkt_evt = os_time_get() +
    d6c4:	f7fd f87c 	bl	a7c0 <os_time_get>
    d6c8:	f500 7080 	add.w	r0, r0, #256	; 0x100
    d6cc:	f8c8 0000 	str.w	r0, [r8]
    d6d0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d6d4:	20001e94 	.word	0x20001e94
    d6d8:	200035f4 	.word	0x200035f4
    d6dc:	20003b5c 	.word	0x20003b5c

0000d6e0 <ble_ll_auth_pyld_tmo_event_send>:
 *
 * @param reason The BLE error code to send as a disconnect reason
 */
void
ble_ll_auth_pyld_tmo_event_send(struct ble_ll_conn_sm *connsm)
{
    d6e0:	b538      	push	{r3, r4, r5, lr}
    d6e2:	4605      	mov	r5, r0
    uint8_t *evbuf;

    if (ble_ll_hci_is_event_enabled(BLE_HCI_EVCODE_AUTH_PYLD_TMO)) {
    d6e4:	2057      	movs	r0, #87	; 0x57
    d6e6:	f001 fa73 	bl	ebd0 <ble_ll_hci_is_event_enabled>
    d6ea:	b188      	cbz	r0, d710 <ble_ll_auth_pyld_tmo_event_send+0x30>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    d6ec:	4809      	ldr	r0, [pc, #36]	; (d714 <ble_ll_auth_pyld_tmo_event_send+0x34>)
    d6ee:	f7fc fe83 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    d6f2:	4604      	mov	r4, r0
    d6f4:	b160      	cbz	r0, d710 <ble_ll_auth_pyld_tmo_event_send+0x30>
            evbuf[0] = BLE_HCI_EVCODE_AUTH_PYLD_TMO;
    d6f6:	2357      	movs	r3, #87	; 0x57
    d6f8:	7003      	strb	r3, [r0, #0]
            evbuf[1] = sizeof(uint16_t);
    d6fa:	2302      	movs	r3, #2
    d6fc:	7043      	strb	r3, [r0, #1]
            htole16(evbuf + 2, connsm->conn_handle);
    d6fe:	88a9      	ldrh	r1, [r5, #4]
    d700:	4418      	add	r0, r3
    d702:	f00f fca9 	bl	1d058 <htole16>
            ble_ll_hci_event_send(evbuf);
    d706:	4620      	mov	r0, r4
        }
    }
}
    d708:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        evbuf = os_memblock_get(&g_hci_evt_pool);
        if (evbuf) {
            evbuf[0] = BLE_HCI_EVCODE_AUTH_PYLD_TMO;
            evbuf[1] = sizeof(uint16_t);
            htole16(evbuf + 2, connsm->conn_handle);
            ble_ll_hci_event_send(evbuf);
    d70c:	f001 ba24 	b.w	eb58 <ble_ll_hci_event_send>
    d710:	bd38      	pop	{r3, r4, r5, pc}
    d712:	bf00      	nop
    d714:	20003b5c 	.word	0x20003b5c

0000d718 <ble_ll_disconn_comp_event_send>:
 *
 * @param reason The BLE error code to send as a disconnect reason
 */
void
ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t reason)
{
    d718:	b570      	push	{r4, r5, r6, lr}
    d71a:	4606      	mov	r6, r0
    uint8_t *evbuf;

    if (ble_ll_hci_is_event_enabled(BLE_HCI_EVCODE_DISCONN_CMP)) {
    d71c:	2005      	movs	r0, #5
 *
 * @param reason The BLE error code to send as a disconnect reason
 */
void
ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t reason)
{
    d71e:	460d      	mov	r5, r1
    uint8_t *evbuf;

    if (ble_ll_hci_is_event_enabled(BLE_HCI_EVCODE_DISCONN_CMP)) {
    d720:	f001 fa56 	bl	ebd0 <ble_ll_hci_is_event_enabled>
    d724:	b1a0      	cbz	r0, d750 <ble_ll_disconn_comp_event_send+0x38>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    d726:	480b      	ldr	r0, [pc, #44]	; (d754 <ble_ll_disconn_comp_event_send+0x3c>)
    d728:	f7fc fe66 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    d72c:	4604      	mov	r4, r0
    d72e:	b178      	cbz	r0, d750 <ble_ll_disconn_comp_event_send+0x38>
            evbuf[0] = BLE_HCI_EVCODE_DISCONN_CMP;
    d730:	2305      	movs	r3, #5
    d732:	7003      	strb	r3, [r0, #0]
            evbuf[1] = BLE_HCI_EVENT_DISCONN_COMPLETE_LEN;
    d734:	2304      	movs	r3, #4
    d736:	7043      	strb	r3, [r0, #1]
            evbuf[2] = BLE_ERR_SUCCESS;
    d738:	2300      	movs	r3, #0
    d73a:	7083      	strb	r3, [r0, #2]
            htole16(evbuf + 3, connsm->conn_handle);
    d73c:	88b1      	ldrh	r1, [r6, #4]
    d73e:	3003      	adds	r0, #3
    d740:	f00f fc8a 	bl	1d058 <htole16>
            evbuf[5] = reason;
    d744:	7165      	strb	r5, [r4, #5]
            ble_ll_hci_event_send(evbuf);
    d746:	4620      	mov	r0, r4
        }
    }
}
    d748:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            evbuf[0] = BLE_HCI_EVCODE_DISCONN_CMP;
            evbuf[1] = BLE_HCI_EVENT_DISCONN_COMPLETE_LEN;
            evbuf[2] = BLE_ERR_SUCCESS;
            htole16(evbuf + 3, connsm->conn_handle);
            evbuf[5] = reason;
            ble_ll_hci_event_send(evbuf);
    d74c:	f001 ba04 	b.w	eb58 <ble_ll_hci_event_send>
    d750:	bd70      	pop	{r4, r5, r6, pc}
    d752:	bf00      	nop
    d754:	20003b5c 	.word	0x20003b5c

0000d758 <ble_ll_conn_create>:
 *
 * @return int
 */
int
ble_ll_conn_create(uint8_t *cmdbuf)
{
    d758:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct hci_create_conn ccdata;
    struct hci_create_conn *hcc;
    struct ble_ll_conn_sm *connsm;

    /* If we are already creating a connection we should leave */
    if (g_ble_ll_conn_create_sm) {
    d75a:	4f75      	ldr	r7, [pc, #468]	; (d930 <ble_ll_conn_create+0x1d8>)
    d75c:	683b      	ldr	r3, [r7, #0]
 *
 * @return int
 */
int
ble_ll_conn_create(uint8_t *cmdbuf)
{
    d75e:	b089      	sub	sp, #36	; 0x24
    d760:	4604      	mov	r4, r0
    struct hci_create_conn ccdata;
    struct hci_create_conn *hcc;
    struct ble_ll_conn_sm *connsm;

    /* If we are already creating a connection we should leave */
    if (g_ble_ll_conn_create_sm) {
    d762:	b10b      	cbz	r3, d768 <ble_ll_conn_create+0x10>
        return BLE_ERR_CMD_DISALLOWED;
    d764:	260c      	movs	r6, #12
    d766:	e0df      	b.n	d928 <ble_ll_conn_create+0x1d0>
    }

    /* If already enabled, we return an error */
    if (ble_ll_scan_enabled()) {
    d768:	f002 fd8e 	bl	10288 <ble_ll_scan_enabled>
    d76c:	4606      	mov	r6, r0
    d76e:	2800      	cmp	r0, #0
    d770:	d1f8      	bne.n	d764 <ble_ll_conn_create+0xc>
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* Retrieve command data */
    hcc = &ccdata;
    hcc->scan_itvl = le16toh(cmdbuf);
    d772:	4620      	mov	r0, r4
    d774:	f00f fc8b 	bl	1d08e <le16toh>
    d778:	f8ad 0004 	strh.w	r0, [sp, #4]
    hcc->scan_window = le16toh(cmdbuf + 2);
    d77c:	1ca0      	adds	r0, r4, #2
    d77e:	f00f fc86 	bl	1d08e <le16toh>

    /* Check interval and window */
    if ((hcc->scan_itvl < BLE_HCI_SCAN_ITVL_MIN) ||
    d782:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    }

    /* Retrieve command data */
    hcc = &ccdata;
    hcc->scan_itvl = le16toh(cmdbuf);
    hcc->scan_window = le16toh(cmdbuf + 2);
    d786:	f8ad 0006 	strh.w	r0, [sp, #6]

    /* Check interval and window */
    if ((hcc->scan_itvl < BLE_HCI_SCAN_ITVL_MIN) ||
    d78a:	1f13      	subs	r3, r2, #4
    d78c:	b29b      	uxth	r3, r3
    d78e:	f643 71fc 	movw	r1, #16380	; 0x3ffc
    d792:	428b      	cmp	r3, r1
    d794:	d901      	bls.n	d79a <ble_ll_conn_create+0x42>
        (hcc->scan_itvl > BLE_HCI_SCAN_ITVL_MAX) ||
        (hcc->scan_window < BLE_HCI_SCAN_WINDOW_MIN) ||
        (hcc->scan_window > BLE_HCI_SCAN_WINDOW_MAX) ||
        (hcc->scan_itvl < hcc->scan_window)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    d796:	2612      	movs	r6, #18
    d798:	e0c6      	b.n	d928 <ble_ll_conn_create+0x1d0>
    hcc->scan_itvl = le16toh(cmdbuf);
    hcc->scan_window = le16toh(cmdbuf + 2);

    /* Check interval and window */
    if ((hcc->scan_itvl < BLE_HCI_SCAN_ITVL_MIN) ||
        (hcc->scan_itvl > BLE_HCI_SCAN_ITVL_MAX) ||
    d79a:	1f03      	subs	r3, r0, #4
    d79c:	b29b      	uxth	r3, r3
    d79e:	428b      	cmp	r3, r1
    d7a0:	d8f9      	bhi.n	d796 <ble_ll_conn_create+0x3e>
        (hcc->scan_window < BLE_HCI_SCAN_WINDOW_MIN) ||
        (hcc->scan_window > BLE_HCI_SCAN_WINDOW_MAX) ||
    d7a2:	4282      	cmp	r2, r0
    d7a4:	d3f7      	bcc.n	d796 <ble_ll_conn_create+0x3e>
        (hcc->scan_itvl < hcc->scan_window)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check filter policy */
    hcc->filter_policy = cmdbuf[4];
    d7a6:	7923      	ldrb	r3, [r4, #4]
    d7a8:	f88d 3008 	strb.w	r3, [sp, #8]
    if (hcc->filter_policy > BLE_HCI_INITIATOR_FILT_POLICY_MAX) {
    d7ac:	2b01      	cmp	r3, #1
    d7ae:	d8f2      	bhi.n	d796 <ble_ll_conn_create+0x3e>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Get peer address type and address only if no whitelist used */
    if (hcc->filter_policy == 0) {
    d7b0:	b963      	cbnz	r3, d7cc <ble_ll_conn_create+0x74>
        hcc->peer_addr_type = cmdbuf[5];
    d7b2:	7963      	ldrb	r3, [r4, #5]
    d7b4:	f88d 3009 	strb.w	r3, [sp, #9]
        if (hcc->peer_addr_type > BLE_HCI_CONN_PEER_ADDR_MAX) {
    d7b8:	2b03      	cmp	r3, #3
    d7ba:	d8ec      	bhi.n	d796 <ble_ll_conn_create+0x3e>
            return BLE_ERR_INV_HCI_CMD_PARMS;
        }

        memcpy(&hcc->peer_addr, cmdbuf + 6, BLE_DEV_ADDR_LEN);
    d7bc:	4623      	mov	r3, r4
    d7be:	f853 2f06 	ldr.w	r2, [r3, #6]!
    d7c2:	f8cd 200a 	str.w	r2, [sp, #10]
    d7c6:	889b      	ldrh	r3, [r3, #4]
    d7c8:	f8ad 300e 	strh.w	r3, [sp, #14]
    }

    /* Get own address type (used in connection request) */
    hcc->own_addr_type = cmdbuf[12];
    d7cc:	7b23      	ldrb	r3, [r4, #12]
    d7ce:	f88d 3010 	strb.w	r3, [sp, #16]
    if (hcc->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
    d7d2:	2b03      	cmp	r3, #3
    d7d4:	d8df      	bhi.n	d796 <ble_ll_conn_create+0x3e>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check connection interval, latency and supervision timeoout */
    hcc->conn_itvl_min = le16toh(cmdbuf + 13);
    d7d6:	f104 000d 	add.w	r0, r4, #13
    d7da:	f00f fc58 	bl	1d08e <le16toh>
    d7de:	f8ad 0012 	strh.w	r0, [sp, #18]
    hcc->conn_itvl_max = le16toh(cmdbuf + 15);
    d7e2:	f104 000f 	add.w	r0, r4, #15
    d7e6:	f00f fc52 	bl	1d08e <le16toh>
    d7ea:	f8ad 0014 	strh.w	r0, [sp, #20]
    hcc->conn_latency = le16toh(cmdbuf + 17);
    d7ee:	f104 0011 	add.w	r0, r4, #17
    d7f2:	f00f fc4c 	bl	1d08e <le16toh>
    d7f6:	f8ad 0016 	strh.w	r0, [sp, #22]
    hcc->supervision_timeout = le16toh(cmdbuf + 19);
    d7fa:	f104 0013 	add.w	r0, r4, #19
    d7fe:	f00f fc46 	bl	1d08e <le16toh>
    rc = ble_ll_conn_hci_chk_conn_params(hcc->conn_itvl_min,
    d802:	f8bd 1014 	ldrh.w	r1, [sp, #20]

    /* Check connection interval, latency and supervision timeoout */
    hcc->conn_itvl_min = le16toh(cmdbuf + 13);
    hcc->conn_itvl_max = le16toh(cmdbuf + 15);
    hcc->conn_latency = le16toh(cmdbuf + 17);
    hcc->supervision_timeout = le16toh(cmdbuf + 19);
    d806:	f8ad 0018 	strh.w	r0, [sp, #24]
    d80a:	4603      	mov	r3, r0
    rc = ble_ll_conn_hci_chk_conn_params(hcc->conn_itvl_min,
    d80c:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    d810:	f8bd 0012 	ldrh.w	r0, [sp, #18]
    d814:	f7ff fe52 	bl	d4bc <ble_ll_conn_hci_chk_conn_params>
                                         hcc->conn_itvl_max,
                                         hcc->conn_latency,
                                         hcc->supervision_timeout);
    if (rc) {
    d818:	2800      	cmp	r0, #0
    d81a:	f040 8082 	bne.w	d922 <ble_ll_conn_create+0x1ca>
        return rc;
    }

    /* Min/max connection event lengths */
    hcc->min_ce_len = le16toh(cmdbuf + 21);
    d81e:	f104 0015 	add.w	r0, r4, #21
    d822:	f00f fc34 	bl	1d08e <le16toh>
    d826:	f8ad 001a 	strh.w	r0, [sp, #26]
    hcc->max_ce_len = le16toh(cmdbuf + 23);
    d82a:	f104 0017 	add.w	r0, r4, #23
    d82e:	f00f fc2e 	bl	1d08e <le16toh>
    if (hcc->min_ce_len > hcc->max_ce_len) {
    d832:	f8bd 301a 	ldrh.w	r3, [sp, #26]
        return rc;
    }

    /* Min/max connection event lengths */
    hcc->min_ce_len = le16toh(cmdbuf + 21);
    hcc->max_ce_len = le16toh(cmdbuf + 23);
    d836:	f8ad 001c 	strh.w	r0, [sp, #28]
    if (hcc->min_ce_len > hcc->max_ce_len) {
    d83a:	4283      	cmp	r3, r0
    d83c:	d8ab      	bhi.n	d796 <ble_ll_conn_create+0x3e>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Make sure we can accept a connection! */
    connsm = ble_ll_conn_sm_get();
    d83e:	f7fe fca7 	bl	c190 <ble_ll_conn_sm_get>
    if (connsm == NULL) {
    d842:	4604      	mov	r4, r0
    d844:	2800      	cmp	r0, #0
    d846:	d06e      	beq.n	d926 <ble_ll_conn_create+0x1ce>
        return BLE_ERR_CONN_LIMIT;
    }

    /* Initialize state machine in master role and start state machine */
    ble_ll_conn_master_init(connsm, hcc);
    d848:	a901      	add	r1, sp, #4
    d84a:	f7fe fe7b 	bl	c544 <ble_ll_conn_master_init>
    ble_ll_conn_sm_new(connsm);
    d84e:	4620      	mov	r0, r4
    d850:	f7fe ff10 	bl	c674 <ble_ll_conn_sm_new>
{
    uint8_t pdu_type;
    uint8_t *dptr;
    struct os_mbuf *m;

    m = ble_ll_scan_get_pdu();
    d854:	f002 fd30 	bl	102b8 <ble_ll_scan_get_pdu>
    assert(m != NULL);
    d858:	4605      	mov	r5, r0
    d85a:	b928      	cbnz	r0, d868 <ble_ll_conn_create+0x110>
    d85c:	4835      	ldr	r0, [pc, #212]	; (d934 <ble_ll_conn_create+0x1dc>)
    d85e:	2160      	movs	r1, #96	; 0x60
    d860:	462a      	mov	r2, r5
    d862:	462b      	mov	r3, r5
    d864:	f7fc fa34 	bl	9cd0 <__assert_func>

    /* Construct first PDU header byte */
    pdu_type = BLE_ADV_PDU_TYPE_CONNECT_REQ;

    /* Set BLE transmit header */
    ble_ll_mbuf_init(m, BLE_CONNECT_REQ_LEN, pdu_type);
    d868:	2205      	movs	r2, #5
    d86a:	2122      	movs	r1, #34	; 0x22
    d86c:	f7fd fc58 	bl	b120 <ble_ll_mbuf_init>

    /* Construct the connect request */
    dptr = m->om_data;
    d870:	682d      	ldr	r5, [r5, #0]

    /* Skip inita and adva advertiser's address as we dont know that yet */
    dptr += (2 * BLE_DEV_ADDR_LEN);

    /* Access address */
    htole32(dptr, connsm->access_addr);
    d872:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    d874:	f105 000c 	add.w	r0, r5, #12
    d878:	f00f fbf2 	bl	1d060 <htole32>
    dptr[4] = (uint8_t)connsm->crcinit;
    d87c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    d87e:	742b      	strb	r3, [r5, #16]
    dptr[5] = (uint8_t)(connsm->crcinit >> 8);
    d880:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    d882:	0a1b      	lsrs	r3, r3, #8
    d884:	746b      	strb	r3, [r5, #17]
    dptr[6] = (uint8_t)(connsm->crcinit >> 16);
    d886:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
    d88a:	74ab      	strb	r3, [r5, #18]
    dptr[7] = connsm->tx_win_size;
    d88c:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    d890:	74eb      	strb	r3, [r5, #19]
    htole16(dptr + 8, connsm->tx_win_off);
    d892:	f105 0014 	add.w	r0, r5, #20
    d896:	f8b4 106a 	ldrh.w	r1, [r4, #106]	; 0x6a
    d89a:	f00f fbdd 	bl	1d058 <htole16>
    htole16(dptr + 10, connsm->conn_itvl);
    d89e:	f105 0016 	add.w	r0, r5, #22
    d8a2:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
    d8a6:	f00f fbd7 	bl	1d058 <htole16>
    htole16(dptr + 12, connsm->slave_latency);
    d8aa:	f105 0018 	add.w	r0, r5, #24
    d8ae:	f8b4 1062 	ldrh.w	r1, [r4, #98]	; 0x62
    d8b2:	f00f fbd1 	bl	1d058 <htole16>
    htole16(dptr + 14, connsm->supervision_tmo);
    d8b6:	f105 001a 	add.w	r0, r5, #26
    d8ba:	f8b4 1064 	ldrh.w	r1, [r4, #100]	; 0x64
    d8be:	f00f fbcb 	bl	1d058 <htole16>
    memcpy(dptr + 16, &connsm->chanmap, BLE_LL_CONN_CHMAP_LEN);
    d8c2:	4623      	mov	r3, r4

    /* Create the connection request */
    ble_ll_conn_req_pdu_make(connsm);

    /* Start scanning */
    rc = ble_ll_scan_initiator_start(hcc);
    d8c4:	a801      	add	r0, sp, #4
    dptr[7] = connsm->tx_win_size;
    htole16(dptr + 8, connsm->tx_win_off);
    htole16(dptr + 10, connsm->conn_itvl);
    htole16(dptr + 12, connsm->slave_latency);
    htole16(dptr + 14, connsm->supervision_tmo);
    memcpy(dptr + 16, &connsm->chanmap, BLE_LL_CONN_CHMAP_LEN);
    d8c6:	f853 2f1a 	ldr.w	r2, [r3, #26]!
    d8ca:	61ea      	str	r2, [r5, #28]
    d8cc:	791b      	ldrb	r3, [r3, #4]
    d8ce:	f885 3020 	strb.w	r3, [r5, #32]
    dptr[21] = connsm->hop_inc | (connsm->master_sca << 5);
    d8d2:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
    d8d6:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
    d8da:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
    d8de:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21

    /* Create the connection request */
    ble_ll_conn_req_pdu_make(connsm);

    /* Start scanning */
    rc = ble_ll_scan_initiator_start(hcc);
    d8e2:	f002 fcc1 	bl	10268 <ble_ll_scan_initiator_start>
    if (rc) {
    d8e6:	b1d0      	cbz	r0, d91e <ble_ll_conn_create+0x1c6>
        SLIST_REMOVE(&g_ble_ll_conn_active_list,connsm,ble_ll_conn_sm,act_sle);
    d8e8:	4a13      	ldr	r2, [pc, #76]	; (d938 <ble_ll_conn_create+0x1e0>)
    d8ea:	6813      	ldr	r3, [r2, #0]
    d8ec:	42a3      	cmp	r3, r4
    d8ee:	d103      	bne.n	d8f8 <ble_ll_conn_create+0x1a0>
    d8f0:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
    d8f4:	6013      	str	r3, [r2, #0]
    d8f6:	e009      	b.n	d90c <ble_ll_conn_create+0x1b4>
    d8f8:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
    d8fc:	42a2      	cmp	r2, r4
    d8fe:	d001      	beq.n	d904 <ble_ll_conn_create+0x1ac>
    d900:	4613      	mov	r3, r2
    d902:	e7f9      	b.n	d8f8 <ble_ll_conn_create+0x1a0>
    d904:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    d908:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
        STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
    d90c:	2300      	movs	r3, #0
    d90e:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
    d912:	4b0a      	ldr	r3, [pc, #40]	; (d93c <ble_ll_conn_create+0x1e4>)
    d914:	685a      	ldr	r2, [r3, #4]
    d916:	6014      	str	r4, [r2, #0]
    d918:	34bc      	adds	r4, #188	; 0xbc
    d91a:	605c      	str	r4, [r3, #4]
    d91c:	e001      	b.n	d922 <ble_ll_conn_create+0x1ca>
    } else {
        /* Set the connection state machine we are trying to create. */
        g_ble_ll_conn_create_sm = connsm;
    d91e:	603c      	str	r4, [r7, #0]
    d920:	e002      	b.n	d928 <ble_ll_conn_create+0x1d0>
    d922:	4606      	mov	r6, r0
    d924:	e000      	b.n	d928 <ble_ll_conn_create+0x1d0>
    }

    /* Make sure we can accept a connection! */
    connsm = ble_ll_conn_sm_get();
    if (connsm == NULL) {
        return BLE_ERR_CONN_LIMIT;
    d926:	2609      	movs	r6, #9
        /* Set the connection state machine we are trying to create. */
        g_ble_ll_conn_create_sm = connsm;
    }

    return rc;
}
    d928:	4630      	mov	r0, r6
    d92a:	b009      	add	sp, #36	; 0x24
    d92c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d92e:	bf00      	nop
    d930:	200033d8 	.word	0x200033d8
    d934:	0001f27e 	.word	0x0001f27e
    d938:	200035f4 	.word	0x200035f4
    d93c:	200033d0 	.word	0x200033d0

0000d940 <ble_ll_conn_hci_read_rem_features>:
 *
 * @return int
 */
int
ble_ll_conn_hci_read_rem_features(uint8_t *cmdbuf)
{
    d940:	b510      	push	{r4, lr}
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    /* If no connection handle exit with error */
    handle = le16toh(cmdbuf);
    d942:	f00f fba4 	bl	1d08e <le16toh>
    connsm = ble_ll_conn_find_active_conn(handle);
    d946:	f7fe fc17 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    d94a:	4604      	mov	r4, r0
    d94c:	b170      	cbz	r0, d96c <ble_ll_conn_hci_read_rem_features+0x2c>
        return BLE_ERR_UNK_CONN_ID;
    }

    /* See if we support this feature */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    d94e:	79c3      	ldrb	r3, [r0, #7]
    d950:	2b02      	cmp	r3, #2
    d952:	d005      	beq.n	d960 <ble_ll_conn_hci_read_rem_features+0x20>
            return BLE_ERR_UNKNOWN_HCI_CMD;
        }
    }

    /* Start the control procedure */
    ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);
    d954:	4620      	mov	r0, r4
    d956:	2103      	movs	r1, #3
    d958:	f000 fda2 	bl	e4a0 <ble_ll_ctrl_proc_start>

    return BLE_ERR_SUCCESS;
    d95c:	2000      	movs	r0, #0
    d95e:	bd10      	pop	{r4, pc}
        return BLE_ERR_UNK_CONN_ID;
    }

    /* See if we support this feature */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
        if ((ble_ll_read_supp_features() & BLE_LL_FEAT_SLAVE_INIT) == 0) {
    d960:	f7fd fbd8 	bl	b114 <ble_ll_read_supp_features>
    d964:	0703      	lsls	r3, r0, #28
    d966:	d4f5      	bmi.n	d954 <ble_ll_conn_hci_read_rem_features+0x14>
            return BLE_ERR_UNKNOWN_HCI_CMD;
    d968:	2001      	movs	r0, #1
    d96a:	bd10      	pop	{r4, pc}

    /* If no connection handle exit with error */
    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        return BLE_ERR_UNK_CONN_ID;
    d96c:	2002      	movs	r0, #2

    /* Start the control procedure */
    ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);

    return BLE_ERR_SUCCESS;
}
    d96e:	bd10      	pop	{r4, pc}

0000d970 <ble_ll_conn_hci_update>:
 *
 * @return int
 */
int
ble_ll_conn_hci_update(uint8_t *cmdbuf)
{
    d970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d972:	4605      	mov	r5, r0
     * getting an UNKOWN_RSP ctrl pdu and resorting to use normal
     * connection update procedure.
     */

    /* If no connection handle exit with error */
    handle = le16toh(cmdbuf);
    d974:	f00f fb8b 	bl	1d08e <le16toh>
    d978:	4607      	mov	r7, r0
    connsm = ble_ll_conn_find_active_conn(handle);
    d97a:	f7fe fbfd 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    d97e:	4604      	mov	r4, r0
    d980:	2800      	cmp	r0, #0
    d982:	d05d      	beq.n	da40 <ble_ll_conn_hci_update+0xd0>
        return BLE_ERR_UNK_CONN_ID;
    }

    /* Better not have this procedure ongoing! */
    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ) ||
    d984:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
    d986:	f003 0341 	and.w	r3, r3, #65	; 0x41
    d98a:	2b00      	cmp	r3, #0
    d98c:	d15a      	bne.n	da44 <ble_ll_conn_hci_update+0xd4>
        IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE)) {
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* See if we support this feature */
    if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_PARM_REQ) == 0) {
    d98e:	f7fd fbc1 	bl	b114 <ble_ll_read_supp_features>
    d992:	f000 0002 	and.w	r0, r0, #2
    d996:	f000 06ff 	and.w	r6, r0, #255	; 0xff
    d99a:	b918      	cbnz	r0, d9a4 <ble_ll_conn_hci_update+0x34>
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    d99c:	79e3      	ldrb	r3, [r4, #7]
    d99e:	2b02      	cmp	r3, #2
    d9a0:	d101      	bne.n	d9a6 <ble_ll_conn_hci_update+0x36>
    d9a2:	e051      	b.n	da48 <ble_ll_conn_hci_update+0xd8>
            return BLE_ERR_UNKNOWN_HCI_CMD;
        }
        ctrl_proc = BLE_LL_CTRL_PROC_CONN_UPDATE;
    } else {
        ctrl_proc = BLE_LL_CTRL_PROC_CONN_PARAM_REQ;
    d9a4:	2606      	movs	r6, #6
     * If we are a slave and the master has initiated the procedure already
     * we should deny the slave request for now. If we are a master and the
     * slave has initiated the procedure, we need to send a reject to the
     * slave.
     */
    if (connsm->csmflags.cfbit.awaiting_host_reply) {
    d9a6:	7823      	ldrb	r3, [r4, #0]
    d9a8:	069a      	lsls	r2, r3, #26
    d9aa:	d50b      	bpl.n	d9c4 <ble_ll_conn_hci_update+0x54>
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    d9ac:	79e2      	ldrb	r2, [r4, #7]
    d9ae:	2a02      	cmp	r2, #2
    d9b0:	d04c      	beq.n	da4c <ble_ll_conn_hci_update+0xdc>
            return BLE_ERR_LMP_COLLISION;
        } else {
            connsm->csmflags.cfbit.awaiting_host_reply = 0;
    d9b2:	f36f 1345 	bfc	r3, #5, #1
    d9b6:	7023      	strb	r3, [r4, #0]

            /* XXX: If this fails no reject ind will be sent! */
            ble_ll_ctrl_reject_ind_send(connsm, connsm->host_reply_opcode,
    d9b8:	4620      	mov	r0, r4
    d9ba:	f894 1033 	ldrb.w	r1, [r4, #51]	; 0x33
    d9be:	2223      	movs	r2, #35	; 0x23
    d9c0:	f001 f856 	bl	ea70 <ble_ll_ctrl_reject_ind_send>

    /*
     * If we are a slave and the master has initiated the channel map
     * update procedure we should deny the slave request for now.
     */
    if (connsm->csmflags.cfbit.chanmap_update_scheduled) {
    d9c4:	7863      	ldrb	r3, [r4, #1]
    d9c6:	071b      	lsls	r3, r3, #28
    d9c8:	d502      	bpl.n	d9d0 <ble_ll_conn_hci_update+0x60>
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    d9ca:	79e3      	ldrb	r3, [r4, #7]
    d9cc:	2b02      	cmp	r3, #2
    d9ce:	d03f      	beq.n	da50 <ble_ll_conn_hci_update+0xe0>
        }
    }

    /* Retrieve command data */
    hcu = &connsm->conn_param_req;
    hcu->handle = handle;
    d9d0:	f8a4 7168 	strh.w	r7, [r4, #360]	; 0x168
    hcu->conn_itvl_min = le16toh(cmdbuf + 2);
    d9d4:	1ca8      	adds	r0, r5, #2
    d9d6:	f00f fb5a 	bl	1d08e <le16toh>
    d9da:	f8a4 016a 	strh.w	r0, [r4, #362]	; 0x16a
    hcu->conn_itvl_max = le16toh(cmdbuf + 4);
    d9de:	1d28      	adds	r0, r5, #4
    d9e0:	f00f fb55 	bl	1d08e <le16toh>
    d9e4:	f8a4 016c 	strh.w	r0, [r4, #364]	; 0x16c
    hcu->conn_latency = le16toh(cmdbuf + 6);
    d9e8:	1da8      	adds	r0, r5, #6
    d9ea:	f00f fb50 	bl	1d08e <le16toh>
    d9ee:	f8a4 016e 	strh.w	r0, [r4, #366]	; 0x16e
    hcu->supervision_timeout = le16toh(cmdbuf + 8);
    d9f2:	f105 0008 	add.w	r0, r5, #8
    d9f6:	f00f fb4a 	bl	1d08e <le16toh>
    d9fa:	f8a4 0170 	strh.w	r0, [r4, #368]	; 0x170
    hcu->min_ce_len = le16toh(cmdbuf + 10);
    d9fe:	f105 000a 	add.w	r0, r5, #10
    da02:	f00f fb44 	bl	1d08e <le16toh>
    da06:	f8a4 0172 	strh.w	r0, [r4, #370]	; 0x172
    hcu->max_ce_len = le16toh(cmdbuf + 12);
    da0a:	f105 000c 	add.w	r0, r5, #12
    da0e:	f00f fb3e 	bl	1d08e <le16toh>
    if (hcu->min_ce_len > hcu->max_ce_len) {
    da12:	f8b4 3172 	ldrh.w	r3, [r4, #370]	; 0x172
    hcu->conn_itvl_min = le16toh(cmdbuf + 2);
    hcu->conn_itvl_max = le16toh(cmdbuf + 4);
    hcu->conn_latency = le16toh(cmdbuf + 6);
    hcu->supervision_timeout = le16toh(cmdbuf + 8);
    hcu->min_ce_len = le16toh(cmdbuf + 10);
    hcu->max_ce_len = le16toh(cmdbuf + 12);
    da16:	f8a4 0174 	strh.w	r0, [r4, #372]	; 0x174
    if (hcu->min_ce_len > hcu->max_ce_len) {
    da1a:	4283      	cmp	r3, r0
    da1c:	d81a      	bhi.n	da54 <ble_ll_conn_hci_update+0xe4>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check that parameter values are in range */
    rc = ble_ll_conn_hci_chk_conn_params(hcu->conn_itvl_min,
    da1e:	f8b4 016a 	ldrh.w	r0, [r4, #362]	; 0x16a
    da22:	f8b4 116c 	ldrh.w	r1, [r4, #364]	; 0x16c
    da26:	f8b4 216e 	ldrh.w	r2, [r4, #366]	; 0x16e
    da2a:	f8b4 3170 	ldrh.w	r3, [r4, #368]	; 0x170
    da2e:	f7ff fd45 	bl	d4bc <ble_ll_conn_hci_chk_conn_params>
                                         hcu->conn_itvl_max,
                                         hcu->conn_latency,
                                         hcu->supervision_timeout);
    if (!rc) {
    da32:	4605      	mov	r5, r0
    da34:	b980      	cbnz	r0, da58 <ble_ll_conn_hci_update+0xe8>
        /* Start the control procedure */
        ble_ll_ctrl_proc_start(connsm, ctrl_proc);
    da36:	4620      	mov	r0, r4
    da38:	4631      	mov	r1, r6
    da3a:	f000 fd31 	bl	e4a0 <ble_ll_ctrl_proc_start>
    da3e:	e00b      	b.n	da58 <ble_ll_conn_hci_update+0xe8>

    /* If no connection handle exit with error */
    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        return BLE_ERR_UNK_CONN_ID;
    da40:	2002      	movs	r0, #2
    da42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Better not have this procedure ongoing! */
    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ) ||
        IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE)) {
        return BLE_ERR_CMD_DISALLOWED;
    da44:	200c      	movs	r0, #12
    da46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* See if we support this feature */
    if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_PARM_REQ) == 0) {
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
            return BLE_ERR_UNKNOWN_HCI_CMD;
    da48:	2001      	movs	r0, #1
    da4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     * slave has initiated the procedure, we need to send a reject to the
     * slave.
     */
    if (connsm->csmflags.cfbit.awaiting_host_reply) {
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
            return BLE_ERR_LMP_COLLISION;
    da4c:	2023      	movs	r0, #35	; 0x23
    da4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     * If we are a slave and the master has initiated the channel map
     * update procedure we should deny the slave request for now.
     */
    if (connsm->csmflags.cfbit.chanmap_update_scheduled) {
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
            return BLE_ERR_DIFF_TRANS_COLL;
    da50:	202a      	movs	r0, #42	; 0x2a
    da52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hcu->conn_latency = le16toh(cmdbuf + 6);
    hcu->supervision_timeout = le16toh(cmdbuf + 8);
    hcu->min_ce_len = le16toh(cmdbuf + 10);
    hcu->max_ce_len = le16toh(cmdbuf + 12);
    if (hcu->min_ce_len > hcu->max_ce_len) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    da54:	2012      	movs	r0, #18
    da56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    da58:	4628      	mov	r0, r5
        /* Start the control procedure */
        ble_ll_ctrl_proc_start(connsm, ctrl_proc);
    }

    return rc;
}
    da5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000da5c <ble_ll_conn_hci_param_reply>:

int
ble_ll_conn_hci_param_reply(uint8_t *cmdbuf, int positive_reply)
{
    da5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    da5e:	4605      	mov	r5, r0
    da60:	460e      	mov	r6, r1
    uint16_t handle;
    struct os_mbuf *om;
    struct ble_ll_conn_sm *connsm;

    /* See if we support this feature */
    if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_PARM_REQ) == 0) {
    da62:	f7fd fb57 	bl	b114 <ble_ll_read_supp_features>
    da66:	0782      	lsls	r2, r0, #30
    da68:	d56e      	bpl.n	db48 <ble_ll_conn_hci_param_reply+0xec>
        return BLE_ERR_UNKNOWN_HCI_CMD;
    }

    /* If no connection handle exit with error */
    handle = le16toh(cmdbuf);
    da6a:	4628      	mov	r0, r5
    da6c:	f00f fb0f 	bl	1d08e <le16toh>

    /* If we dont have a handle we cant do anything */
    connsm = ble_ll_conn_find_active_conn(handle);
    da70:	f7fe fb82 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    da74:	4604      	mov	r4, r0
    da76:	2800      	cmp	r0, #0
    da78:	d068      	beq.n	db4c <ble_ll_conn_hci_param_reply+0xf0>
        return BLE_ERR_UNK_CONN_ID;
    }

    /* Make sure connection parameters are valid if this is a positive reply */
    rc = BLE_ERR_SUCCESS;
    ble_err = cmdbuf[2];
    da7a:	78af      	ldrb	r7, [r5, #2]
    if (positive_reply) {
    da7c:	b3ce      	cbz	r6, daf2 <ble_ll_conn_hci_param_reply+0x96>
    int rc;
    struct hci_conn_update *hcu;

    /* Retrieve command data */
    hcu = &connsm->conn_param_req;
    hcu->handle = connsm->conn_handle;
    da7e:	8883      	ldrh	r3, [r0, #4]
    da80:	f8a0 3168 	strh.w	r3, [r0, #360]	; 0x168
    hcu->conn_itvl_min = le16toh(cmdbuf + 2);
    da84:	1ca8      	adds	r0, r5, #2
    da86:	f00f fb02 	bl	1d08e <le16toh>
    da8a:	f8a4 016a 	strh.w	r0, [r4, #362]	; 0x16a
    hcu->conn_itvl_max = le16toh(cmdbuf + 4);
    da8e:	1d28      	adds	r0, r5, #4
    da90:	f00f fafd 	bl	1d08e <le16toh>
    da94:	f8a4 016c 	strh.w	r0, [r4, #364]	; 0x16c
    hcu->conn_latency = le16toh(cmdbuf + 6);
    da98:	1da8      	adds	r0, r5, #6
    da9a:	f00f faf8 	bl	1d08e <le16toh>
    da9e:	f8a4 016e 	strh.w	r0, [r4, #366]	; 0x16e
    hcu->supervision_timeout = le16toh(cmdbuf + 8);
    daa2:	f105 0008 	add.w	r0, r5, #8
    daa6:	f00f faf2 	bl	1d08e <le16toh>
    daaa:	f8a4 0170 	strh.w	r0, [r4, #368]	; 0x170
    hcu->min_ce_len = le16toh(cmdbuf + 10);
    daae:	f105 000a 	add.w	r0, r5, #10
    dab2:	f00f faec 	bl	1d08e <le16toh>
    dab6:	f8a4 0172 	strh.w	r0, [r4, #370]	; 0x172
    hcu->max_ce_len = le16toh(cmdbuf + 12);
    daba:	f105 000c 	add.w	r0, r5, #12
    dabe:	f00f fae6 	bl	1d08e <le16toh>

    /* Check that parameter values are in range */
    rc = ble_ll_conn_hci_chk_conn_params(hcu->conn_itvl_min,
    dac2:	f8b4 116c 	ldrh.w	r1, [r4, #364]	; 0x16c
    hcu->conn_itvl_min = le16toh(cmdbuf + 2);
    hcu->conn_itvl_max = le16toh(cmdbuf + 4);
    hcu->conn_latency = le16toh(cmdbuf + 6);
    hcu->supervision_timeout = le16toh(cmdbuf + 8);
    hcu->min_ce_len = le16toh(cmdbuf + 10);
    hcu->max_ce_len = le16toh(cmdbuf + 12);
    dac6:	f8a4 0174 	strh.w	r0, [r4, #372]	; 0x174
    daca:	4605      	mov	r5, r0

    /* Check that parameter values are in range */
    rc = ble_ll_conn_hci_chk_conn_params(hcu->conn_itvl_min,
    dacc:	f8b4 216e 	ldrh.w	r2, [r4, #366]	; 0x16e
    dad0:	f8b4 016a 	ldrh.w	r0, [r4, #362]	; 0x16a
    dad4:	f8b4 3170 	ldrh.w	r3, [r4, #368]	; 0x170
    dad8:	f7ff fcf0 	bl	d4bc <ble_ll_conn_hci_chk_conn_params>
                                         hcu->conn_itvl_max,
                                         hcu->conn_latency,
                                         hcu->supervision_timeout);

    /* Check valid min/max ce length */
    if (rc || (hcu->min_ce_len > hcu->max_ce_len)) {
    dadc:	b918      	cbnz	r0, dae6 <ble_ll_conn_hci_param_reply+0x8a>
    dade:	f8b4 3172 	ldrh.w	r3, [r4, #370]	; 0x172
    dae2:	42ab      	cmp	r3, r5
    dae4:	d907      	bls.n	daf6 <ble_ll_conn_hci_param_reply+0x9a>
        hcu->handle = 0;
    dae6:	2300      	movs	r3, #0
    dae8:	f8a4 3168 	strh.w	r3, [r4, #360]	; 0x168
    rc = BLE_ERR_SUCCESS;
    ble_err = cmdbuf[2];
    if (positive_reply) {
        rc = ble_ll_conn_process_conn_params(cmdbuf, connsm);
        if (rc) {
            ble_err = BLE_ERR_CONN_PARMS;
    daec:	273b      	movs	r7, #59	; 0x3b
                                         hcu->supervision_timeout);

    /* Check valid min/max ce length */
    if (rc || (hcu->min_ce_len > hcu->max_ce_len)) {
        hcu->handle = 0;
        return BLE_ERR_INV_HCI_CMD_PARMS;
    daee:	2512      	movs	r5, #18
    daf0:	e002      	b.n	daf8 <ble_ll_conn_hci_param_reply+0x9c>
    if (!connsm) {
        return BLE_ERR_UNK_CONN_ID;
    }

    /* Make sure connection parameters are valid if this is a positive reply */
    rc = BLE_ERR_SUCCESS;
    daf2:	4635      	mov	r5, r6
    daf4:	e000      	b.n	daf8 <ble_ll_conn_hci_param_reply+0x9c>
                                         hcu->conn_itvl_max,
                                         hcu->conn_latency,
                                         hcu->supervision_timeout);

    /* Check valid min/max ce length */
    if (rc || (hcu->min_ce_len > hcu->max_ce_len)) {
    daf6:	4605      	mov	r5, r0
            ble_err = BLE_ERR_CONN_PARMS;
        }
    }

    /* The connection should be awaiting a reply. If not, just discard */
    if (connsm->csmflags.cfbit.awaiting_host_reply) {
    daf8:	7823      	ldrb	r3, [r4, #0]
    dafa:	069b      	lsls	r3, r3, #26
    dafc:	d528      	bpl.n	db50 <ble_ll_conn_hci_param_reply+0xf4>
        /* Get a control packet buffer */
        if (positive_reply && (rc == BLE_ERR_SUCCESS)) {
    dafe:	b1c6      	cbz	r6, db32 <ble_ll_conn_hci_param_reply+0xd6>
    db00:	b9bd      	cbnz	r5, db32 <ble_ll_conn_hci_param_reply+0xd6>
            om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PAYLOAD + 1,
    db02:	201b      	movs	r0, #27
    db04:	2108      	movs	r1, #8
    db06:	f7fc fa14 	bl	9f32 <os_msys_get_pkthdr>
                                    sizeof(struct ble_mbuf_hdr));
            if (om) {
    db0a:	4606      	mov	r6, r0
    db0c:	b1b8      	cbz	r0, db3e <ble_ll_conn_hci_param_reply+0xe2>
                dptr = om->om_data;
    db0e:	6807      	ldr	r7, [r0, #0]
                rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, dptr,
    db10:	f504 72c1 	add.w	r2, r4, #386	; 0x182
    db14:	4639      	mov	r1, r7
    db16:	4620      	mov	r0, r4
    db18:	f000 fbe0 	bl	e2dc <ble_ll_ctrl_conn_param_reply>
                                                          &connsm->conn_cp);
                dptr[0] = rsp_opcode;
                len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
    db1c:	4b0d      	ldr	r3, [pc, #52]	; (db54 <ble_ll_conn_hci_param_reply+0xf8>)
                                    sizeof(struct ble_mbuf_hdr));
            if (om) {
                dptr = om->om_data;
                rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, dptr,
                                                          &connsm->conn_cp);
                dptr[0] = rsp_opcode;
    db1e:	7038      	strb	r0, [r7, #0]
                len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
    db20:	5c1b      	ldrb	r3, [r3, r0]
    db22:	3301      	adds	r3, #1
                ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
    db24:	4620      	mov	r0, r4
    db26:	4631      	mov	r1, r6
    db28:	2203      	movs	r2, #3
    db2a:	b2db      	uxtb	r3, r3
    db2c:	f7ff fae2 	bl	d0f4 <ble_ll_conn_enqueue_pkt>
    db30:	e005      	b.n	db3e <ble_ll_conn_hci_param_reply+0xe2>
            }
        } else {
            /* XXX: check return code and deal */
            ble_ll_ctrl_reject_ind_send(connsm, connsm->host_reply_opcode,
    db32:	4620      	mov	r0, r4
    db34:	f894 1033 	ldrb.w	r1, [r4, #51]	; 0x33
    db38:	463a      	mov	r2, r7
    db3a:	f000 ff99 	bl	ea70 <ble_ll_ctrl_reject_ind_send>
                                        ble_err);
        }
        connsm->csmflags.cfbit.awaiting_host_reply = 0;
    db3e:	7823      	ldrb	r3, [r4, #0]
    db40:	f36f 1345 	bfc	r3, #5, #1
    db44:	7023      	strb	r3, [r4, #0]
    db46:	e003      	b.n	db50 <ble_ll_conn_hci_param_reply+0xf4>
    struct os_mbuf *om;
    struct ble_ll_conn_sm *connsm;

    /* See if we support this feature */
    if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_PARM_REQ) == 0) {
        return BLE_ERR_UNKNOWN_HCI_CMD;
    db48:	2001      	movs	r0, #1
    db4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    handle = le16toh(cmdbuf);

    /* If we dont have a handle we cant do anything */
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        return BLE_ERR_UNK_CONN_ID;
    db4c:	2002      	movs	r0, #2
    db4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    db50:	4628      	mov	r0, r5
         * reason if it was a negative reply. We also would need to have
           some state to tell us this happened */
    }

    return rc;
}
    db52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    db54:	0001f29e 	.word	0x0001f29e

0000db58 <ble_ll_conn_create_cancel>:
 *
 * @return int
 */
int
ble_ll_conn_create_cancel(void)
{
    db58:	b538      	push	{r3, r4, r5, lr}
     * If we receive this command and we have not got a connection
     * create command, we have to return disallowed. The spec does not say
     * what happens if the connection has already been established. We
     * return disallowed as well
     */
    connsm = g_ble_ll_conn_create_sm;
    db5a:	4b08      	ldr	r3, [pc, #32]	; (db7c <ble_ll_conn_create_cancel+0x24>)
    db5c:	681d      	ldr	r5, [r3, #0]
    if (connsm && (connsm->conn_state == BLE_LL_CONN_STATE_IDLE)) {
    db5e:	b15d      	cbz	r5, db78 <ble_ll_conn_create_cancel+0x20>
    db60:	79ac      	ldrb	r4, [r5, #6]
    db62:	b94c      	cbnz	r4, db78 <ble_ll_conn_create_cancel+0x20>
        /* stop scanning and end the connection event */
        g_ble_ll_conn_create_sm = NULL;
        ble_ll_scan_sm_stop(1);
    db64:	2001      	movs	r0, #1
     * return disallowed as well
     */
    connsm = g_ble_ll_conn_create_sm;
    if (connsm && (connsm->conn_state == BLE_LL_CONN_STATE_IDLE)) {
        /* stop scanning and end the connection event */
        g_ble_ll_conn_create_sm = NULL;
    db66:	601c      	str	r4, [r3, #0]
        ble_ll_scan_sm_stop(1);
    db68:	f001 fffa 	bl	fb60 <ble_ll_scan_sm_stop>
        ble_ll_conn_end(connsm, BLE_ERR_UNK_CONN_ID);
    db6c:	4628      	mov	r0, r5
    db6e:	2102      	movs	r1, #2
    db70:	f7fe fe38 	bl	c7e4 <ble_ll_conn_end>
        rc = BLE_ERR_SUCCESS;
    db74:	4620      	mov	r0, r4
    db76:	bd38      	pop	{r3, r4, r5, pc}
    } else {
        /* If we are not attempting to create a connection*/
        rc = BLE_ERR_CMD_DISALLOWED;
    db78:	200c      	movs	r0, #12
    }

    return rc;
}
    db7a:	bd38      	pop	{r3, r4, r5, pc}
    db7c:	200033d8 	.word	0x200033d8

0000db80 <ble_ll_conn_hci_disconnect_cmd>:
 *
 * @return int
 */
int
ble_ll_conn_hci_disconnect_cmd(uint8_t *cmdbuf)
{
    db80:	b538      	push	{r3, r4, r5, lr}
    db82:	4604      	mov	r4, r0
    uint8_t reason;
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    /* Check for valid parameters */
    handle = le16toh(cmdbuf);
    db84:	f00f fa83 	bl	1d08e <le16toh>
    reason = cmdbuf[2];

    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    if (handle <= BLE_LL_CONN_MAX_CONN_HANDLE) {
    db88:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    /* Check for valid parameters */
    handle = le16toh(cmdbuf);
    reason = cmdbuf[2];
    db8c:	78a5      	ldrb	r5, [r4, #2]

    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    if (handle <= BLE_LL_CONN_MAX_CONN_HANDLE) {
    db8e:	d222      	bcs.n	dbd6 <ble_ll_conn_hci_disconnect_cmd+0x56>
        /* Make sure reason is valid */
        switch (reason) {
    db90:	2d15      	cmp	r5, #21
    db92:	d803      	bhi.n	db9c <ble_ll_conn_hci_disconnect_cmd+0x1c>
    db94:	2d13      	cmp	r5, #19
    db96:	d207      	bcs.n	dba8 <ble_ll_conn_hci_disconnect_cmd+0x28>
    db98:	2d05      	cmp	r5, #5
    db9a:	e004      	b.n	dba6 <ble_ll_conn_hci_disconnect_cmd+0x26>
    db9c:	2d29      	cmp	r5, #41	; 0x29
    db9e:	d003      	beq.n	dba8 <ble_ll_conn_hci_disconnect_cmd+0x28>
    dba0:	2d3b      	cmp	r5, #59	; 0x3b
    dba2:	d001      	beq.n	dba8 <ble_ll_conn_hci_disconnect_cmd+0x28>
    dba4:	2d1a      	cmp	r5, #26
    dba6:	d116      	bne.n	dbd6 <ble_ll_conn_hci_disconnect_cmd+0x56>
        case BLE_ERR_RD_CONN_TERM_RESRCS:
        case BLE_ERR_RD_CONN_TERM_PWROFF:
        case BLE_ERR_UNSUPP_REM_FEATURE:
        case BLE_ERR_UNIT_KEY_PAIRING:
        case BLE_ERR_CONN_PARMS:
            connsm = ble_ll_conn_find_active_conn(handle);
    dba8:	f7fe fae6 	bl	c178 <ble_ll_conn_find_active_conn>
            if (connsm) {
    dbac:	b1a8      	cbz	r0, dbda <ble_ll_conn_hci_disconnect_cmd+0x5a>
                /* Do not allow command if we are in process of disconnecting */
                if (connsm->disconnect_reason) {
    dbae:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
    dbb2:	b9a2      	cbnz	r2, dbde <ble_ll_conn_hci_disconnect_cmd+0x5e>
                    rc = BLE_ERR_CMD_DISALLOWED;
                } else {
                    /* This control procedure better not be pending! */
                    assert(!IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_TERMINATE));
    dbb4:	8f84      	ldrh	r4, [r0, #60]	; 0x3c
    dbb6:	f004 0420 	and.w	r4, r4, #32
    dbba:	b2a4      	uxth	r4, r4
    dbbc:	b12c      	cbz	r4, dbca <ble_ll_conn_hci_disconnect_cmd+0x4a>
    dbbe:	4809      	ldr	r0, [pc, #36]	; (dbe4 <ble_ll_conn_hci_disconnect_cmd+0x64>)
    dbc0:	f240 21ff 	movw	r1, #767	; 0x2ff
    dbc4:	4613      	mov	r3, r2
    dbc6:	f7fc f883 	bl	9cd0 <__assert_func>

                    /* Record the disconnect reason */
                    connsm->disconnect_reason = reason;
    dbca:	f880 5037 	strb.w	r5, [r0, #55]	; 0x37

                    /* Start this control procedure */
                    ble_ll_ctrl_terminate_start(connsm);
    dbce:	f000 fc43 	bl	e458 <ble_ll_ctrl_terminate_start>

                    rc = BLE_ERR_SUCCESS;
    dbd2:	4620      	mov	r0, r4
    dbd4:	bd38      	pop	{r3, r4, r5, pc}

    /* Check for valid parameters */
    handle = le16toh(cmdbuf);
    reason = cmdbuf[2];

    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    dbd6:	2012      	movs	r0, #18
    dbd8:	bd38      	pop	{r3, r4, r5, pc}
                    ble_ll_ctrl_terminate_start(connsm);

                    rc = BLE_ERR_SUCCESS;
                }
            } else {
                rc = BLE_ERR_UNK_CONN_ID;
    dbda:	2002      	movs	r0, #2
    dbdc:	bd38      	pop	{r3, r4, r5, pc}
        case BLE_ERR_CONN_PARMS:
            connsm = ble_ll_conn_find_active_conn(handle);
            if (connsm) {
                /* Do not allow command if we are in process of disconnecting */
                if (connsm->disconnect_reason) {
                    rc = BLE_ERR_CMD_DISALLOWED;
    dbde:	200c      	movs	r0, #12
            break;
        }
    }

    return rc;
}
    dbe0:	bd38      	pop	{r3, r4, r5, pc}
    dbe2:	bf00      	nop
    dbe4:	0001f27e 	.word	0x0001f27e

0000dbe8 <ble_ll_conn_hci_rd_rem_ver_cmd>:
 *
 * @return int
 */
int
ble_ll_conn_hci_rd_rem_ver_cmd(uint8_t *cmdbuf)
{
    dbe8:	b538      	push	{r3, r4, r5, lr}
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    /* Check for valid parameters */
    handle = le16toh(cmdbuf);
    dbea:	f00f fa50 	bl	1d08e <le16toh>
    connsm = ble_ll_conn_find_active_conn(handle);
    dbee:	f7fe fac3 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    dbf2:	b1a0      	cbz	r0, dc1e <ble_ll_conn_hci_rd_rem_ver_cmd+0x36>
        return BLE_ERR_UNK_CONN_ID;
    }

    /* Return error if in progress */
    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG)) {
    dbf4:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
    dbf6:	f002 0310 	and.w	r3, r2, #16
    dbfa:	b29b      	uxth	r3, r3
    dbfc:	b98b      	cbnz	r3, dc22 <ble_ll_conn_hci_rd_rem_ver_cmd+0x3a>
     * procedure we set the pending bit so that the host gets an event because
     * it is obviously expecting one (or would not have sent the command).
     * NOTE: we cant just send the event here. That would cause the event to
     * be queued before the command status.
     */
    if (!connsm->csmflags.cfbit.version_ind_sent) {
    dbfe:	7841      	ldrb	r1, [r0, #1]
    dc00:	f001 0102 	and.w	r1, r1, #2
    dc04:	f001 05ff 	and.w	r5, r1, #255	; 0xff
    dc08:	b921      	cbnz	r1, dc14 <ble_ll_conn_hci_rd_rem_ver_cmd+0x2c>
        ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG);
    dc0a:	2104      	movs	r1, #4
    dc0c:	f000 fc48 	bl	e4a0 <ble_ll_ctrl_proc_start>
    } else {
        connsm->pending_ctrl_procs |= (1 << BLE_LL_CTRL_PROC_VERSION_XCHG);
    }

    return BLE_ERR_SUCCESS;
    dc10:	4628      	mov	r0, r5
    dc12:	bd38      	pop	{r3, r4, r5, pc}
     * be queued before the command status.
     */
    if (!connsm->csmflags.cfbit.version_ind_sent) {
        ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG);
    } else {
        connsm->pending_ctrl_procs |= (1 << BLE_LL_CTRL_PROC_VERSION_XCHG);
    dc14:	f042 0210 	orr.w	r2, r2, #16
    dc18:	8782      	strh	r2, [r0, #60]	; 0x3c
    }

    return BLE_ERR_SUCCESS;
    dc1a:	4618      	mov	r0, r3
    dc1c:	bd38      	pop	{r3, r4, r5, pc}

    /* Check for valid parameters */
    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        return BLE_ERR_UNK_CONN_ID;
    dc1e:	2002      	movs	r0, #2
    dc20:	bd38      	pop	{r3, r4, r5, pc}
    }

    /* Return error if in progress */
    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG)) {
        return BLE_ERR_CMD_DISALLOWED;
    dc22:	200c      	movs	r0, #12
    } else {
        connsm->pending_ctrl_procs |= (1 << BLE_LL_CTRL_PROC_VERSION_XCHG);
    }

    return BLE_ERR_SUCCESS;
}
    dc24:	bd38      	pop	{r3, r4, r5, pc}

0000dc26 <ble_ll_conn_hci_rd_rssi>:
 *
 * @return int
 */
int
ble_ll_conn_hci_rd_rssi(uint8_t *cmdbuf, uint8_t *rspbuf, uint8_t *rsplen)
{
    dc26:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dc2a:	460d      	mov	r5, r1
    dc2c:	4617      	mov	r7, r2
    int rc;
    int8_t rssi;
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    handle = le16toh(cmdbuf);
    dc2e:	f00f fa2e 	bl	1d08e <le16toh>
    dc32:	4680      	mov	r8, r0
    connsm = ble_ll_conn_find_active_conn(handle);
    dc34:	f7fe faa0 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    dc38:	b118      	cbz	r0, dc42 <ble_ll_conn_hci_rd_rssi+0x1c>
        rssi = 127;
        rc = BLE_ERR_UNK_CONN_ID;
    } else {
        rssi = connsm->conn_rssi;
    dc3a:	f890 602b 	ldrb.w	r6, [r0, #43]	; 0x2b
        rc = BLE_ERR_SUCCESS;
    dc3e:	2400      	movs	r4, #0
    dc40:	e001      	b.n	dc46 <ble_ll_conn_hci_rd_rssi+0x20>
    struct ble_ll_conn_sm *connsm;

    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        rssi = 127;
    dc42:	267f      	movs	r6, #127	; 0x7f
        rc = BLE_ERR_UNK_CONN_ID;
    dc44:	2402      	movs	r4, #2
    } else {
        rssi = connsm->conn_rssi;
        rc = BLE_ERR_SUCCESS;
    }

    htole16(rspbuf, handle);
    dc46:	4628      	mov	r0, r5
    dc48:	4641      	mov	r1, r8
    dc4a:	f00f fa05 	bl	1d058 <htole16>
    rspbuf[2] = (uint8_t)rssi;
    *rsplen = 3;
    dc4e:	2303      	movs	r3, #3
        rssi = connsm->conn_rssi;
        rc = BLE_ERR_SUCCESS;
    }

    htole16(rspbuf, handle);
    rspbuf[2] = (uint8_t)rssi;
    dc50:	70ae      	strb	r6, [r5, #2]
    *rsplen = 3;
    dc52:	703b      	strb	r3, [r7, #0]

    /* Place the RSSI of the connection into the response buffer */
    return rc;
}
    dc54:	4620      	mov	r0, r4
    dc56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000dc5a <ble_ll_conn_hci_rd_chan_map>:
 *
 * @return int
 */
int
ble_ll_conn_hci_rd_chan_map(uint8_t *cmdbuf, uint8_t *rspbuf, uint8_t *rsplen)
{
    dc5a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dc5c:	460d      	mov	r5, r1
    dc5e:	4616      	mov	r6, r2
    int rc;
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    handle = le16toh(cmdbuf);
    dc60:	f00f fa15 	bl	1d08e <le16toh>
    dc64:	4607      	mov	r7, r0
    connsm = ble_ll_conn_find_active_conn(handle);
    dc66:	f7fe fa87 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    dc6a:	b1a8      	cbz	r0, dc98 <ble_ll_conn_hci_rd_chan_map+0x3e>
        rc = BLE_ERR_UNK_CONN_ID;
    } else {
        if (connsm->csmflags.cfbit.chanmap_update_scheduled) {
    dc6c:	7843      	ldrb	r3, [r0, #1]
    dc6e:	f003 0308 	and.w	r3, r3, #8
    dc72:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    dc76:	1caa      	adds	r2, r5, #2
    dc78:	b13b      	cbz	r3, dc8a <ble_ll_conn_hci_rd_chan_map+0x30>
            memcpy(rspbuf + 2, &connsm->req_chanmap[0], BLE_LL_CONN_CHMAP_LEN);
    dc7a:	f850 3f1f 	ldr.w	r3, [r0, #31]!
    dc7e:	f8c5 3002 	str.w	r3, [r5, #2]
    dc82:	7903      	ldrb	r3, [r0, #4]
    dc84:	7113      	strb	r3, [r2, #4]
        } else {
            memcpy(rspbuf + 2, &connsm->chanmap[0], BLE_LL_CONN_CHMAP_LEN);
        }
        rc = BLE_ERR_SUCCESS;
    dc86:	2400      	movs	r4, #0
    dc88:	e007      	b.n	dc9a <ble_ll_conn_hci_rd_chan_map+0x40>
        rc = BLE_ERR_UNK_CONN_ID;
    } else {
        if (connsm->csmflags.cfbit.chanmap_update_scheduled) {
            memcpy(rspbuf + 2, &connsm->req_chanmap[0], BLE_LL_CONN_CHMAP_LEN);
        } else {
            memcpy(rspbuf + 2, &connsm->chanmap[0], BLE_LL_CONN_CHMAP_LEN);
    dc8a:	f850 3f1a 	ldr.w	r3, [r0, #26]!
    dc8e:	f8c5 3002 	str.w	r3, [r5, #2]
    dc92:	7903      	ldrb	r3, [r0, #4]
    dc94:	7113      	strb	r3, [r2, #4]
    dc96:	e000      	b.n	dc9a <ble_ll_conn_hci_rd_chan_map+0x40>
    struct ble_ll_conn_sm *connsm;

    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        rc = BLE_ERR_UNK_CONN_ID;
    dc98:	2402      	movs	r4, #2
            memcpy(rspbuf + 2, &connsm->chanmap[0], BLE_LL_CONN_CHMAP_LEN);
        }
        rc = BLE_ERR_SUCCESS;
    }

    htole16(rspbuf, handle);
    dc9a:	4628      	mov	r0, r5
    dc9c:	4639      	mov	r1, r7
    dc9e:	f00f f9db 	bl	1d058 <htole16>
    *rsplen = sizeof(uint16_t) + BLE_LL_CONN_CHMAP_LEN;
    dca2:	2307      	movs	r3, #7
    dca4:	7033      	strb	r3, [r6, #0]
    return rc;
}
    dca6:	4620      	mov	r0, r4
    dca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000dcaa <ble_ll_conn_hci_set_chan_class>:
 *
 * @return int
 */
int
ble_ll_conn_hci_set_chan_class(uint8_t *cmdbuf)
{
    dcaa:	b538      	push	{r3, r4, r5, lr}
    dcac:	4605      	mov	r5, r0
     * The HCI command states that the host is allowed to mask in just one
     * channel but the Link Layer needs minimum two channels to operate. So
     * I will not allow this command if there are less than 2 channels masked.
     */
    rc = BLE_ERR_SUCCESS;
    num_used_chans = ble_ll_conn_calc_used_chans(cmdbuf);
    dcae:	f7fe fa9d 	bl	c1ec <ble_ll_conn_calc_used_chans>
    if ((num_used_chans < 2) || ((cmdbuf[4] & 0xe0) != 0)) {
    dcb2:	2801      	cmp	r0, #1
    dcb4:	d906      	bls.n	dcc4 <ble_ll_conn_hci_set_chan_class+0x1a>
    dcb6:	792b      	ldrb	r3, [r5, #4]
    dcb8:	f013 0fe0 	tst.w	r3, #224	; 0xe0
    /*
     * The HCI command states that the host is allowed to mask in just one
     * channel but the Link Layer needs minimum two channels to operate. So
     * I will not allow this command if there are less than 2 channels masked.
     */
    rc = BLE_ERR_SUCCESS;
    dcbc:	bf14      	ite	ne
    dcbe:	2412      	movne	r4, #18
    dcc0:	2400      	moveq	r4, #0
    dcc2:	e000      	b.n	dcc6 <ble_ll_conn_hci_set_chan_class+0x1c>
    num_used_chans = ble_ll_conn_calc_used_chans(cmdbuf);
    if ((num_used_chans < 2) || ((cmdbuf[4] & 0xe0) != 0)) {
        rc = BLE_ERR_INV_HCI_CMD_PARMS;
    dcc4:	2412      	movs	r4, #18
    }

    /* Set the host channel mask */
    ble_ll_conn_set_global_chanmap(num_used_chans, cmdbuf);
    dcc6:	4629      	mov	r1, r5
    dcc8:	f7ff fa7e 	bl	d1c8 <ble_ll_conn_set_global_chanmap>
    return rc;
}
    dccc:	4620      	mov	r0, r4
    dcce:	bd38      	pop	{r3, r4, r5, pc}

0000dcd0 <ble_ll_conn_hci_set_data_len>:

#if (BLE_LL_CFG_FEAT_DATA_LEN_EXT == 1)
int
ble_ll_conn_hci_set_data_len(uint8_t *cmdbuf, uint8_t *rspbuf, uint8_t *rsplen)
{
    dcd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dcd4:	4604      	mov	r4, r0
    dcd6:	460f      	mov	r7, r1
    dcd8:	4615      	mov	r5, r2
    uint16_t txoctets;
    uint16_t txtime;
    struct ble_ll_conn_sm *connsm;

    /* Find connection */
    handle = le16toh(cmdbuf);
    dcda:	f00f f9d8 	bl	1d08e <le16toh>
    dcde:	4606      	mov	r6, r0
    connsm = ble_ll_conn_find_active_conn(handle);
    dce0:	f7fe fa4a 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    dce4:	b198      	cbz	r0, dd0e <ble_ll_conn_hci_set_data_len+0x3e>
        rc = BLE_ERR_UNK_CONN_ID;
    } else {
        txoctets = le16toh(cmdbuf + 2);
    dce6:	1ca0      	adds	r0, r4, #2
    dce8:	f00f f9d1 	bl	1d08e <le16toh>
    dcec:	4680      	mov	r8, r0
        txtime = le16toh(cmdbuf + 4);
    dcee:	1d20      	adds	r0, r4, #4
    dcf0:	f00f f9cd 	bl	1d08e <le16toh>
    dcf4:	4604      	mov	r4, r0

        /* Make sure it is valid */
        if (!ble_ll_chk_txrx_octets(txoctets) ||
    dcf6:	4640      	mov	r0, r8
    dcf8:	f7fd f89e 	bl	ae38 <ble_ll_chk_txrx_octets>
    dcfc:	b148      	cbz	r0, dd12 <ble_ll_conn_hci_set_data_len+0x42>
            !ble_ll_chk_txrx_time(txtime)) {
    dcfe:	4620      	mov	r0, r4
    dd00:	f7fd f8a0 	bl	ae44 <ble_ll_chk_txrx_time>
    } else {
        txoctets = le16toh(cmdbuf + 2);
        txtime = le16toh(cmdbuf + 4);

        /* Make sure it is valid */
        if (!ble_ll_chk_txrx_octets(txoctets) ||
    dd04:	2800      	cmp	r0, #0
            !ble_ll_chk_txrx_time(txtime)) {
            rc = BLE_ERR_INV_HCI_CMD_PARMS;
    dd06:	bf14      	ite	ne
    dd08:	2400      	movne	r4, #0
    dd0a:	2412      	moveq	r4, #18
    dd0c:	e002      	b.n	dd14 <ble_ll_conn_hci_set_data_len+0x44>

    /* Find connection */
    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        rc = BLE_ERR_UNK_CONN_ID;
    dd0e:	2402      	movs	r4, #2
    dd10:	e000      	b.n	dd14 <ble_ll_conn_hci_set_data_len+0x44>
        txtime = le16toh(cmdbuf + 4);

        /* Make sure it is valid */
        if (!ble_ll_chk_txrx_octets(txoctets) ||
            !ble_ll_chk_txrx_time(txtime)) {
            rc = BLE_ERR_INV_HCI_CMD_PARMS;
    dd12:	2412      	movs	r4, #18
         * XXX: For now; we will simply ignore what the host asks as we are
         * allowed to do so by the spec.
         */
    }

    htole16(rspbuf, handle);
    dd14:	4638      	mov	r0, r7
    dd16:	4631      	mov	r1, r6
    dd18:	f00f f99e 	bl	1d058 <htole16>
    *rsplen = sizeof(uint16_t);
    dd1c:	2302      	movs	r3, #2
    dd1e:	702b      	strb	r3, [r5, #0]
    return rc;
}
    dd20:	4620      	mov	r0, r4
    dd22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000dd26 <ble_ll_conn_hci_le_start_encrypt>:
 *
 * @return int
 */
int
ble_ll_conn_hci_le_start_encrypt(uint8_t *cmdbuf)
{
    dd26:	b538      	push	{r3, r4, r5, lr}
    dd28:	4605      	mov	r5, r0
    int rc;
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    handle = le16toh(cmdbuf);
    dd2a:	f00f f9b0 	bl	1d08e <le16toh>
    connsm = ble_ll_conn_find_active_conn(handle);
    dd2e:	f7fe fa23 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    dd32:	4604      	mov	r4, r0
    dd34:	b300      	cbz	r0, dd78 <ble_ll_conn_hci_le_start_encrypt+0x52>
        rc = BLE_ERR_UNK_CONN_ID;
    } else if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    dd36:	79c3      	ldrb	r3, [r0, #7]
    dd38:	2b02      	cmp	r3, #2
    dd3a:	d01f      	beq.n	dd7c <ble_ll_conn_hci_le_start_encrypt+0x56>
        rc = BLE_ERR_UNSPECIFIED;
    } else if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
    dd3c:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    dd40:	2b02      	cmp	r3, #2
    dd42:	d01d      	beq.n	dd80 <ble_ll_conn_hci_le_start_encrypt+0x5a>
         * of honoring a previous start encrypt.
         */
        rc = BLE_ERR_CMD_DISALLOWED;
    } else {
        /* Start the control procedure */
        connsm->enc_data.host_rand_num = le64toh(cmdbuf + 2);
    dd44:	1ca8      	adds	r0, r5, #2
    dd46:	f00f f9b2 	bl	1d0ae <le64toh>
    dd4a:	f504 7394 	add.w	r3, r4, #296	; 0x128
    dd4e:	e9c3 0100 	strd	r0, r1, [r3]
        connsm->enc_data.enc_div = le16toh(cmdbuf + 10);
    dd52:	f105 000a 	add.w	r0, r5, #10
    dd56:	f00f f99a 	bl	1d08e <le16toh>
        swap_buf(connsm->enc_data.enc_block.key, cmdbuf + 12, 16);
    dd5a:	f105 010c 	add.w	r1, r5, #12
         */
        rc = BLE_ERR_CMD_DISALLOWED;
    } else {
        /* Start the control procedure */
        connsm->enc_data.host_rand_num = le64toh(cmdbuf + 2);
        connsm->enc_data.enc_div = le16toh(cmdbuf + 10);
    dd5e:	f8a4 0122 	strh.w	r0, [r4, #290]	; 0x122
        swap_buf(connsm->enc_data.enc_block.key, cmdbuf + 12, 16);
    dd62:	2210      	movs	r2, #16
    dd64:	f504 709c 	add.w	r0, r4, #312	; 0x138
    dd68:	f00f f9da 	bl	1d120 <swap_buf>
        ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
    dd6c:	4620      	mov	r0, r4
    dd6e:	2102      	movs	r1, #2
    dd70:	f000 fb96 	bl	e4a0 <ble_ll_ctrl_proc_start>
        rc = BLE_ERR_SUCCESS;
    dd74:	2000      	movs	r0, #0
    dd76:	bd38      	pop	{r3, r4, r5, pc}
    struct ble_ll_conn_sm *connsm;

    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        rc = BLE_ERR_UNK_CONN_ID;
    dd78:	2002      	movs	r0, #2
    dd7a:	bd38      	pop	{r3, r4, r5, pc}
    } else if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
        rc = BLE_ERR_UNSPECIFIED;
    dd7c:	201f      	movs	r0, #31
    dd7e:	bd38      	pop	{r3, r4, r5, pc}
        /*
         * The specification does not say what to do here but the host should
         * not be telling us to start encryption while we are in the process
         * of honoring a previous start encrypt.
         */
        rc = BLE_ERR_CMD_DISALLOWED;
    dd80:	200c      	movs	r0, #12
        ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
        rc = BLE_ERR_SUCCESS;
    }

    return rc;
}
    dd82:	bd38      	pop	{r3, r4, r5, pc}

0000dd84 <ble_ll_conn_hci_le_ltk_reply>:
 *
 * @return int
 */
int
ble_ll_conn_hci_le_ltk_reply(uint8_t *cmdbuf, uint8_t *rspbuf, uint8_t ocf)
{
    dd84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dd88:	460e      	mov	r6, r1
    dd8a:	4690      	mov	r8, r2
    dd8c:	4607      	mov	r7, r0
    int rc;
    uint16_t handle;
    struct ble_ll_conn_sm *connsm;

    /* Find connection handle */
    handle = le16toh(cmdbuf);
    dd8e:	f00f f97e 	bl	1d08e <le16toh>
    dd92:	4605      	mov	r5, r0
    connsm = ble_ll_conn_find_active_conn(handle);
    dd94:	f7fe f9f0 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    dd98:	4604      	mov	r4, r0
    dd9a:	b1f8      	cbz	r0, dddc <ble_ll_conn_hci_le_ltk_reply+0x58>
        rc = BLE_ERR_UNK_CONN_ID;
        goto ltk_key_cmd_complete;
    }

    /* Should never get this if we are a master! */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    dd9c:	79c3      	ldrb	r3, [r0, #7]
    dd9e:	2b01      	cmp	r3, #1
    dda0:	d01e      	beq.n	dde0 <ble_ll_conn_hci_le_ltk_reply+0x5c>
        rc = BLE_ERR_UNSPECIFIED;
        goto ltk_key_cmd_complete;
    }

    /* The connection should be awaiting a reply. If not, just discard */
    if (connsm->enc_data.enc_state == CONN_ENC_S_LTK_REQ_WAIT) {
    dda2:	f890 3120 	ldrb.w	r3, [r0, #288]	; 0x120
    dda6:	2b07      	cmp	r3, #7
    dda8:	d11c      	bne.n	dde4 <ble_ll_conn_hci_le_ltk_reply+0x60>
        if (ocf == BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY) {
    ddaa:	f1b8 0f1a 	cmp.w	r8, #26
    ddae:	d10d      	bne.n	ddcc <ble_ll_conn_hci_le_ltk_reply+0x48>
            swap_buf(connsm->enc_data.enc_block.key, cmdbuf + 2, 16);
    ddb0:	1cb9      	adds	r1, r7, #2
    ddb2:	2210      	movs	r2, #16
    ddb4:	f500 709c 	add.w	r0, r0, #312	; 0x138
    ddb8:	f00f f9b2 	bl	1d120 <swap_buf>
            ble_ll_calc_session_key(connsm);
    ddbc:	4620      	mov	r0, r4
    ddbe:	f000 fa4a 	bl	e256 <ble_ll_calc_session_key>
            ble_ll_ctrl_start_enc_send(connsm, BLE_LL_CTRL_START_ENC_REQ);
    ddc2:	4620      	mov	r0, r4
    ddc4:	2105      	movs	r1, #5
    ddc6:	f000 fa74 	bl	e2b2 <ble_ll_ctrl_start_enc_send>
    ddca:	e00b      	b.n	dde4 <ble_ll_conn_hci_le_ltk_reply+0x60>
        } else {
            /* We received a negative reply! Send REJECT_IND */
            ble_ll_ctrl_reject_ind_send(connsm, BLE_LL_CTRL_ENC_REQ,
    ddcc:	2103      	movs	r1, #3
    ddce:	2206      	movs	r2, #6
    ddd0:	f000 fe4e 	bl	ea70 <ble_ll_ctrl_reject_ind_send>
                                        BLE_ERR_PINKEY_MISSING);
            connsm->enc_data.enc_state = CONN_ENC_S_LTK_NEG_REPLY;
    ddd4:	2308      	movs	r3, #8
    ddd6:	f884 3120 	strb.w	r3, [r4, #288]	; 0x120
    ddda:	e003      	b.n	dde4 <ble_ll_conn_hci_le_ltk_reply+0x60>

    /* Find connection handle */
    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        rc = BLE_ERR_UNK_CONN_ID;
    dddc:	2402      	movs	r4, #2
    ddde:	e002      	b.n	dde6 <ble_ll_conn_hci_le_ltk_reply+0x62>
        goto ltk_key_cmd_complete;
    }

    /* Should never get this if we are a master! */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
        rc = BLE_ERR_UNSPECIFIED;
    dde0:	241f      	movs	r4, #31
    dde2:	e000      	b.n	dde6 <ble_ll_conn_hci_le_ltk_reply+0x62>
            ble_ll_ctrl_reject_ind_send(connsm, BLE_LL_CTRL_ENC_REQ,
                                        BLE_ERR_PINKEY_MISSING);
            connsm->enc_data.enc_state = CONN_ENC_S_LTK_NEG_REPLY;
        }
    }
    rc = BLE_ERR_SUCCESS;
    dde4:	2400      	movs	r4, #0

ltk_key_cmd_complete:
    htole16(rspbuf, handle);
    dde6:	4630      	mov	r0, r6
    dde8:	4629      	mov	r1, r5
    ddea:	f00f f935 	bl	1d058 <htole16>
    return rc;
}
    ddee:	4620      	mov	r0, r4
    ddf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000ddf4 <ble_ll_conn_hci_wr_auth_pyld_tmo>:
 *
 * @return int
 */
int
ble_ll_conn_hci_wr_auth_pyld_tmo(uint8_t *cmdbuf, uint8_t *rsp, uint8_t *rsplen)
{
    ddf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ddf8:	460f      	mov	r7, r1
    ddfa:	4615      	mov	r5, r2
    ddfc:	4604      	mov	r4, r0
    uint32_t min_tmo;
    struct ble_ll_conn_sm *connsm;

    rc = BLE_ERR_SUCCESS;

    handle = le16toh(cmdbuf);
    ddfe:	f00f f946 	bl	1d08e <le16toh>
    de02:	4606      	mov	r6, r0
    connsm = ble_ll_conn_find_active_conn(handle);
    de04:	f7fe f9b8 	bl	c178 <ble_ll_conn_find_active_conn>
    if (!connsm) {
    de08:	4680      	mov	r8, r0
    de0a:	b1d8      	cbz	r0, de44 <ble_ll_conn_hci_wr_auth_pyld_tmo+0x50>

    /*
     * The timeout is in units of 10 msecs. We need to make sure that the
     * timeout is greater than or equal to connItvl * (1 + slaveLatency)
     */
    tmo = le16toh(cmdbuf + 2);
    de0c:	1ca0      	adds	r0, r4, #2
    de0e:	f00f f93e 	bl	1d08e <le16toh>
    min_tmo = (uint32_t)connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    de12:	f8b8 2060 	ldrh.w	r2, [r8, #96]	; 0x60
    de16:	f240 43e2 	movw	r3, #1250	; 0x4e2
    de1a:	4353      	muls	r3, r2
    min_tmo *= (connsm->slave_latency + 1);
    de1c:	f8b8 2062 	ldrh.w	r2, [r8, #98]	; 0x62
    de20:	fb02 3303 	mla	r3, r2, r3, r3
    min_tmo /= 10000;
    de24:	f242 7210 	movw	r2, #10000	; 0x2710
    de28:	fbb3 f3f2 	udiv	r3, r3, r2

    if (tmo < min_tmo) {
    de2c:	4298      	cmp	r0, r3
    de2e:	d30b      	bcc.n	de48 <ble_ll_conn_hci_wr_auth_pyld_tmo+0x54>
        rc = BLE_ERR_INV_HCI_CMD_PARMS;
    } else {
        connsm->auth_pyld_tmo = tmo;
        if (os_callout_queued(&connsm->auth_pyld_timer.cf_c)) {
    de30:	f8d8 4114 	ldr.w	r4, [r8, #276]	; 0x114
    min_tmo /= 10000;

    if (tmo < min_tmo) {
        rc = BLE_ERR_INV_HCI_CMD_PARMS;
    } else {
        connsm->auth_pyld_tmo = tmo;
    de34:	f8a8 0046 	strh.w	r0, [r8, #70]	; 0x46
        if (os_callout_queued(&connsm->auth_pyld_timer.cf_c)) {
    de38:	b13c      	cbz	r4, de4a <ble_ll_conn_hci_wr_auth_pyld_tmo+0x56>
            ble_ll_conn_auth_pyld_timer_start(connsm);
    de3a:	4640      	mov	r0, r8
    de3c:	f7fe fb68 	bl	c510 <ble_ll_conn_auth_pyld_timer_start>
    uint16_t handle;
    uint16_t tmo;
    uint32_t min_tmo;
    struct ble_ll_conn_sm *connsm;

    rc = BLE_ERR_SUCCESS;
    de40:	2400      	movs	r4, #0
    de42:	e002      	b.n	de4a <ble_ll_conn_hci_wr_auth_pyld_tmo+0x56>

    handle = le16toh(cmdbuf);
    connsm = ble_ll_conn_find_active_conn(handle);
    if (!connsm) {
        rc = BLE_ERR_UNK_CONN_ID;
    de44:	2402      	movs	r4, #2
    de46:	e000      	b.n	de4a <ble_ll_conn_hci_wr_auth_pyld_tmo+0x56>
    min_tmo = (uint32_t)connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    min_tmo *= (connsm->slave_latency + 1);
    min_tmo /= 10000;

    if (tmo < min_tmo) {
        rc = BLE_ERR_INV_HCI_CMD_PARMS;
    de48:	2412      	movs	r4, #18
            ble_ll_conn_auth_pyld_timer_start(connsm);
        }
    }

wr_auth_exit:
    htole16(rsp, handle);
    de4a:	4638      	mov	r0, r7
    de4c:	4631      	mov	r1, r6
    de4e:	f00f f903 	bl	1d058 <htole16>
    *rsplen = BLE_HCI_WR_AUTH_PYLD_TMO_LEN;
    de52:	2302      	movs	r3, #2
    de54:	702b      	strb	r3, [r5, #0]
    return rc;
}
    de56:	4620      	mov	r0, r4
    de58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000de5c <ble_ll_ctrl_conn_upd_make>:
 * @param rsp
 */
static void
ble_ll_ctrl_conn_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
                          struct ble_ll_conn_params *cp)
{
    de5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     * the amount of slave latency as the slave may not be listening
     * at every connection interval and we are not sure when the connect
     * request will actually get sent. We add one more event plus the
     * minimum as per the spec of 6 connection events.
     */
    instant = connsm->event_cntr + connsm->slave_latency + 6 + 1;
    de5e:	8fc5      	ldrh	r5, [r0, #62]	; 0x3e
    de60:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
    de64:	441d      	add	r5, r3
    de66:	3507      	adds	r5, #7
 * @param rsp
 */
static void
ble_ll_ctrl_conn_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
                          struct ble_ll_conn_params *cp)
{
    de68:	4604      	mov	r4, r0
    de6a:	460e      	mov	r6, r1
     * the amount of slave latency as the slave may not be listening
     * at every connection interval and we are not sure when the connect
     * request will actually get sent. We add one more event plus the
     * minimum as per the spec of 6 connection events.
     */
    instant = connsm->event_cntr + connsm->slave_latency + 6 + 1;
    de6c:	b2ad      	uxth	r5, r5
     * start the new instant at the same anchor using win offset 0.
     */
    /* Copy parameters in connection update structure */
    hcu = &connsm->conn_param_req;
    req = &connsm->conn_update_req;
    if (cp) {
    de6e:	2a00      	cmp	r2, #0
    de70:	d03b      	beq.n	deea <ble_ll_ctrl_conn_upd_make+0x8e>
        /* XXX: so we need to make the new anchor point some time away
         * from txwinoffset by some amount of msecs. Not sure how to do
           that here. We dont need to, but we should. */
        /* Calculate offset from requested offsets (if any) */
        if (cp->offset0 != 0xFFFF) {
    de72:	8991      	ldrh	r1, [r2, #12]
    de74:	f64f 73ff 	movw	r3, #65535	; 0xffff
    de78:	4299      	cmp	r1, r3
    de7a:	d028      	beq.n	dece <ble_ll_ctrl_conn_upd_make+0x72>
            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    de7c:	f8b0 c060 	ldrh.w	ip, [r0, #96]	; 0x60
            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
    de80:	8950      	ldrh	r0, [r2, #10]
        /* XXX: so we need to make the new anchor point some time away
         * from txwinoffset by some amount of msecs. Not sure how to do
           that here. We dont need to, but we should. */
        /* Calculate offset from requested offsets (if any) */
        if (cp->offset0 != 0xFFFF) {
            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
    de82:	8853      	ldrh	r3, [r2, #2]
            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
    de84:	1b47      	subs	r7, r0, r5
    de86:	f417 4f00 	tst.w	r7, #32768	; 0x8000
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
            } else {
                num_old_ce = instant - cp->ref_conn_event_cnt;
                dt = old_itvl_usecs * num_old_ce;
                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
    de8a:	bf18      	it	ne
    de8c:	4f32      	ldrne	r7, [pc, #200]	; (df58 <ble_ll_ctrl_conn_upd_make+0xfc>)
        /* XXX: so we need to make the new anchor point some time away
         * from txwinoffset by some amount of msecs. Not sure how to do
           that here. We dont need to, but we should. */
        /* Calculate offset from requested offsets (if any) */
        if (cp->offset0 != 0xFFFF) {
            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
    de8e:	f240 4ee2 	movw	lr, #1250	; 0x4e2
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
            } else {
                num_old_ce = instant - cp->ref_conn_event_cnt;
                dt = old_itvl_usecs * num_old_ce;
                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
    de92:	bf18      	it	ne
    de94:	4379      	mulne	r1, r7
         * from txwinoffset by some amount of msecs. Not sure how to do
           that here. We dont need to, but we should. */
        /* Calculate offset from requested offsets (if any) */
        if (cp->offset0 != 0xFFFF) {
            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
    de96:	fb0e fc0c 	mul.w	ip, lr, ip
                num_old_ce = cp->ref_conn_event_cnt - instant;
                dt = old_itvl_usecs * num_old_ce;
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
            } else {
                num_old_ce = instant - cp->ref_conn_event_cnt;
    de9a:	bf18      	it	ne
    de9c:	1a28      	subne	r0, r5, r0
        /* XXX: so we need to make the new anchor point some time away
         * from txwinoffset by some amount of msecs. Not sure how to do
           that here. We dont need to, but we should. */
        /* Calculate offset from requested offsets (if any) */
        if (cp->offset0 != 0xFFFF) {
            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
    de9e:	fb0e f303 	mul.w	r3, lr, r3
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
            } else {
                num_old_ce = instant - cp->ref_conn_event_cnt;
                dt = old_itvl_usecs * num_old_ce;
                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
    dea2:	bf15      	itete	ne
    dea4:	fb0c 1100 	mlane	r1, ip, r0, r1
            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
                num_old_ce = cp->ref_conn_event_cnt - instant;
                dt = old_itvl_usecs * num_old_ce;
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
    dea8:	fb0e fe01 	muleq.w	lr, lr, r1
                dt = dt % new_itvl_usecs;
            } else {
                num_old_ce = instant - cp->ref_conn_event_cnt;
                dt = old_itvl_usecs * num_old_ce;
                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
    deac:	fbb1 f0f3 	udivne	r0, r1, r3
            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
                num_old_ce = cp->ref_conn_event_cnt - instant;
                dt = old_itvl_usecs * num_old_ce;
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
    deb0:	fb0c e107 	mlaeq	r1, ip, r7, lr
                dt = dt % new_itvl_usecs;
            } else {
                num_old_ce = instant - cp->ref_conn_event_cnt;
                dt = old_itvl_usecs * num_old_ce;
                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
    deb4:	bf15      	itete	ne
    deb6:	fb03 1110 	mlsne	r1, r3, r0, r1
            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
                num_old_ce = cp->ref_conn_event_cnt - instant;
                dt = old_itvl_usecs * num_old_ce;
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
    deba:	fbb1 f0f3 	udiveq	r0, r1, r3
            } else {
                num_old_ce = instant - cp->ref_conn_event_cnt;
                dt = old_itvl_usecs * num_old_ce;
                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
                dt = new_itvl_usecs - dt;
    debe:	1a5b      	subne	r3, r3, r1
            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
                num_old_ce = cp->ref_conn_event_cnt - instant;
                dt = old_itvl_usecs * num_old_ce;
                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
    dec0:	fb03 1310 	mlseq	r3, r3, r0, r1
                dt = old_itvl_usecs * num_old_ce;
                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                dt = dt % new_itvl_usecs;
                dt = new_itvl_usecs - dt;
            }
            req->winoffset = dt / BLE_LL_CONN_TX_WIN_USECS;
    dec4:	f240 41e2 	movw	r1, #1250	; 0x4e2
    dec8:	fbb3 f3f1 	udiv	r3, r3, r1
    decc:	e000      	b.n	ded0 <ble_ll_ctrl_conn_upd_make+0x74>
        } else {
            req->winoffset = 0;
    dece:	2300      	movs	r3, #0
    ded0:	f8a4 3178 	strh.w	r3, [r4, #376]	; 0x178
        }
        req->interval = cp->interval_max;
    ded4:	8853      	ldrh	r3, [r2, #2]
    ded6:	f8a4 317a 	strh.w	r3, [r4, #378]	; 0x17a
        req->timeout = cp->timeout;
    deda:	88d3      	ldrh	r3, [r2, #6]
    dedc:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
        req->latency = cp->latency;
    dee0:	8893      	ldrh	r3, [r2, #4]
    dee2:	f8a4 317c 	strh.w	r3, [r4, #380]	; 0x17c
        req->winsize = 1;
    dee6:	2301      	movs	r3, #1
    dee8:	e00f      	b.n	df0a <ble_ll_ctrl_conn_upd_make+0xae>
    } else {
        req->interval = hcu->conn_itvl_max;
    deea:	f8b0 316c 	ldrh.w	r3, [r0, #364]	; 0x16c
    deee:	f8a0 317a 	strh.w	r3, [r0, #378]	; 0x17a
        req->timeout = hcu->supervision_timeout;
    def2:	f8b0 3170 	ldrh.w	r3, [r0, #368]	; 0x170
    def6:	f8a0 317e 	strh.w	r3, [r0, #382]	; 0x17e
        req->latency = hcu->conn_latency;
    defa:	f8b0 316e 	ldrh.w	r3, [r0, #366]	; 0x16e
    defe:	f8a0 317c 	strh.w	r3, [r0, #380]	; 0x17c
        req->winoffset = 0;
        req->winsize = connsm->tx_win_size;
    df02:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
        req->winsize = 1;
    } else {
        req->interval = hcu->conn_itvl_max;
        req->timeout = hcu->supervision_timeout;
        req->latency = hcu->conn_latency;
        req->winoffset = 0;
    df06:	f8a0 2178 	strh.w	r2, [r0, #376]	; 0x178
        req->winsize = connsm->tx_win_size;
    df0a:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
    }
    req->instant = instant;

    /* XXX: make sure this works for the connection parameter request proc. */
    pyld[0] = req->winsize;
    df0e:	4630      	mov	r0, r6
    df10:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
        req->timeout = hcu->supervision_timeout;
        req->latency = hcu->conn_latency;
        req->winoffset = 0;
        req->winsize = connsm->tx_win_size;
    }
    req->instant = instant;
    df14:	f8a4 5180 	strh.w	r5, [r4, #384]	; 0x180

    /* XXX: make sure this works for the connection parameter request proc. */
    pyld[0] = req->winsize;
    df18:	f800 3b01 	strb.w	r3, [r0], #1
    htole16(pyld + 1, req->winoffset);
    df1c:	f8b4 1178 	ldrh.w	r1, [r4, #376]	; 0x178
    df20:	f00f f89a 	bl	1d058 <htole16>
    htole16(pyld + 3, req->interval);
    df24:	1cf0      	adds	r0, r6, #3
    df26:	f8b4 117a 	ldrh.w	r1, [r4, #378]	; 0x17a
    df2a:	f00f f895 	bl	1d058 <htole16>
    htole16(pyld + 5, req->latency);
    df2e:	1d70      	adds	r0, r6, #5
    df30:	f8b4 117c 	ldrh.w	r1, [r4, #380]	; 0x17c
    df34:	f00f f890 	bl	1d058 <htole16>
    htole16(pyld + 7, req->timeout);
    df38:	1df0      	adds	r0, r6, #7
    df3a:	f8b4 117e 	ldrh.w	r1, [r4, #382]	; 0x17e
    df3e:	f00f f88b 	bl	1d058 <htole16>
    htole16(pyld + 9, instant);
    df42:	f106 0009 	add.w	r0, r6, #9
    df46:	4629      	mov	r1, r5
    df48:	f00f f886 	bl	1d058 <htole16>

    /* Set flag in state machine to denote we have scheduled an update */
    connsm->csmflags.cfbit.conn_update_sched = 1;
    df4c:	7823      	ldrb	r3, [r4, #0]
    df4e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    df52:	7023      	strb	r3, [r4, #0]
    df54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    df56:	bf00      	nop
    df58:	fffffb1e 	.word	0xfffffb1e

0000df5c <ble_ll_ctrl_datalen_upd_make>:
 * @param connsm
 * @param dptr: Pointer to where control pdu payload starts
 */
static void
ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
{
    df5c:	b538      	push	{r3, r4, r5, lr}
    df5e:	4604      	mov	r4, r0
    df60:	460d      	mov	r5, r1
    htole16(dptr + 1, connsm->max_rx_octets);
    df62:	1c48      	adds	r0, r1, #1
    df64:	7a61      	ldrb	r1, [r4, #9]
    df66:	f00f f877 	bl	1d058 <htole16>
    htole16(dptr + 3, connsm->max_rx_time);
    df6a:	1ce8      	adds	r0, r5, #3
    df6c:	8a21      	ldrh	r1, [r4, #16]
    df6e:	f00f f873 	bl	1d058 <htole16>
    htole16(dptr + 5, connsm->max_tx_octets);
    df72:	1d68      	adds	r0, r5, #5
    df74:	7a21      	ldrb	r1, [r4, #8]
    df76:	f00f f86f 	bl	1d058 <htole16>
    htole16(dptr + 7, connsm->max_tx_time);
    df7a:	1de8      	adds	r0, r5, #7
    df7c:	89e1      	ldrh	r1, [r4, #14]
}
    df7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
{
    htole16(dptr + 1, connsm->max_rx_octets);
    htole16(dptr + 3, connsm->max_rx_time);
    htole16(dptr + 5, connsm->max_tx_octets);
    htole16(dptr + 7, connsm->max_tx_time);
    df82:	f00f b869 	b.w	1d058 <htole16>
	...

0000df88 <ble_ll_ctrl_conn_param_pdu_make>:
 *             of the data.
 */
static void
ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                                struct ble_ll_conn_params *req)
{
    df88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    df8c:	4605      	mov	r5, r0
    df8e:	460c      	mov	r4, r1
    uint16_t offset;
    struct hci_conn_update *hcu;

    /* If we were passed in a request, we use the parameters from the request */
    if (req) {
    df90:	4616      	mov	r6, r2
    df92:	f101 0902 	add.w	r9, r1, #2
    df96:	f101 0804 	add.w	r8, r1, #4
    df9a:	1d8f      	adds	r7, r1, #6
    df9c:	b172      	cbz	r2, dfbc <ble_ll_ctrl_conn_param_pdu_make+0x34>
        htole16(dptr, req->interval_min);
    df9e:	4608      	mov	r0, r1
    dfa0:	8811      	ldrh	r1, [r2, #0]
    dfa2:	f00f f859 	bl	1d058 <htole16>
        htole16(dptr + 2, req->interval_max);
    dfa6:	4648      	mov	r0, r9
    dfa8:	8871      	ldrh	r1, [r6, #2]
    dfaa:	f00f f855 	bl	1d058 <htole16>
        htole16(dptr + 4, req->latency);
    dfae:	4640      	mov	r0, r8
    dfb0:	88b1      	ldrh	r1, [r6, #4]
    dfb2:	f00f f851 	bl	1d058 <htole16>
        htole16(dptr + 6, req->timeout);
    dfb6:	4638      	mov	r0, r7
    dfb8:	88f1      	ldrh	r1, [r6, #6]
    dfba:	e019      	b.n	dff0 <ble_ll_ctrl_conn_param_pdu_make+0x68>
    } else {
        hcu = &connsm->conn_param_req;
        /* The host should have provided the parameters! */
        assert(hcu->handle != 0);
    dfbc:	f8b0 3168 	ldrh.w	r3, [r0, #360]	; 0x168
    dfc0:	b923      	cbnz	r3, dfcc <ble_ll_ctrl_conn_param_pdu_make+0x44>
    dfc2:	4823      	ldr	r0, [pc, #140]	; (e050 <ble_ll_ctrl_conn_param_pdu_make+0xc8>)
    dfc4:	f44f 713a 	mov.w	r1, #744	; 0x2e8
    dfc8:	f7fb fe82 	bl	9cd0 <__assert_func>
        htole16(dptr, hcu->conn_itvl_min);
    dfcc:	4608      	mov	r0, r1
    dfce:	f8b5 116a 	ldrh.w	r1, [r5, #362]	; 0x16a
    dfd2:	f00f f841 	bl	1d058 <htole16>
        htole16(dptr + 2, hcu->conn_itvl_max);
    dfd6:	4648      	mov	r0, r9
    dfd8:	f8b5 116c 	ldrh.w	r1, [r5, #364]	; 0x16c
    dfdc:	f00f f83c 	bl	1d058 <htole16>
        htole16(dptr + 4, hcu->conn_latency);
    dfe0:	4640      	mov	r0, r8
    dfe2:	f8b5 116e 	ldrh.w	r1, [r5, #366]	; 0x16e
    dfe6:	f00f f837 	bl	1d058 <htole16>
        htole16(dptr + 6, hcu->supervision_timeout);
    dfea:	f8b5 1170 	ldrh.w	r1, [r5, #368]	; 0x170
    dfee:	4638      	mov	r0, r7
    dff0:	f00f f832 	bl	1d058 <htole16>
     * other this value should be set to non-zero. I think this
     * applies only when an offset field is set. See section 5.1.7.1 pg 103
     * Vol 6 Part B.
     */
    /* XXX: for now, set periodicity to 0 */
    dptr[8] = 0;
    dff4:	2300      	movs	r3, #0
    dff6:	7223      	strb	r3, [r4, #8]

    /* XXX: deal with reference event count. what to put here? */
    htole16(dptr + 9, connsm->event_cntr);
    dff8:	f104 0009 	add.w	r0, r4, #9
    dffc:	8fe9      	ldrh	r1, [r5, #62]	; 0x3e
    dffe:	f00f f82b 	bl	1d058 <htole16>

    /* XXX: For now, dont use offsets */
    offset = 0xFFFF;
    htole16(dptr + 11, offset);
    e002:	f104 000b 	add.w	r0, r4, #11
    e006:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e00a:	f00f f825 	bl	1d058 <htole16>
    htole16(dptr + 13, offset);
    e00e:	f104 000d 	add.w	r0, r4, #13
    e012:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e016:	f00f f81f 	bl	1d058 <htole16>
    htole16(dptr + 15, offset);
    e01a:	f104 000f 	add.w	r0, r4, #15
    e01e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e022:	f00f f819 	bl	1d058 <htole16>
    htole16(dptr + 17, offset);
    e026:	f104 0011 	add.w	r0, r4, #17
    e02a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e02e:	f00f f813 	bl	1d058 <htole16>
    htole16(dptr + 19, offset);
    e032:	f104 0013 	add.w	r0, r4, #19
    e036:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e03a:	f00f f80d 	bl	1d058 <htole16>
    htole16(dptr + 21, offset);
    e03e:	f104 0015 	add.w	r0, r4, #21
    e042:	f64f 71ff 	movw	r1, #65535	; 0xffff
}
    e046:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    htole16(dptr + 11, offset);
    htole16(dptr + 13, offset);
    htole16(dptr + 15, offset);
    htole16(dptr + 17, offset);
    htole16(dptr + 19, offset);
    htole16(dptr + 21, offset);
    e04a:	f00f b805 	b.w	1d058 <htole16>
    e04e:	bf00      	nop
    e050:	0001f290 	.word	0x0001f290

0000e054 <ble_ll_ctrl_proc_rsp_timer_cb>:
 */
void
ble_ll_ctrl_proc_rsp_timer_cb(void *arg)
{
    /* Control procedure has timed out. Kill the connection */
    ble_ll_conn_timeout((struct ble_ll_conn_sm *)arg, BLE_ERR_LMP_LL_RSP_TMO);
    e054:	2122      	movs	r1, #34	; 0x22
    e056:	f7fe be1f 	b.w	cc98 <ble_ll_conn_timeout>
	...

0000e05c <ble_ll_ctrl_proc_init>:
 * @param connsm
 * @param ctrl_proc
 */
static struct os_mbuf *
ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc)
{
    e05c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e05e:	4604      	mov	r4, r0
    e060:	460e      	mov	r6, r1
    uint8_t *dptr;
    uint8_t *ctrdata;
    struct os_mbuf *om;

    /* Get an mbuf for the control pdu */
    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
    e062:	201b      	movs	r0, #27
    e064:	2108      	movs	r1, #8
    e066:	f7fb ff64 	bl	9f32 <os_msys_get_pkthdr>

    if (om) {
    e06a:	4607      	mov	r7, r0
    e06c:	2800      	cmp	r0, #0
    e06e:	f000 8095 	beq.w	e19c <ble_ll_ctrl_proc_init+0x140>
        /* The control data starts after the opcode (1 byte) */
        dptr = om->om_data;
    e072:	6805      	ldr	r5, [r0, #0]
        ctrdata = dptr + 1;
    e074:	1c69      	adds	r1, r5, #1

        switch (ctrl_proc) {
    e076:	2e08      	cmp	r6, #8
    e078:	d87c      	bhi.n	e174 <ble_ll_ctrl_proc_init+0x118>
    e07a:	e8df f006 	tbb	[pc, r6]
    e07e:	0b05      	.short	0x0b05
    e080:	41302752 	.word	0x41302752
    e084:	8246      	.short	0x8246
    e086:	4c          	.byte	0x4c
    e087:	00          	.byte	0x00
        case BLE_LL_CTRL_PROC_CONN_UPDATE:
            opcode = BLE_LL_CTRL_CONN_UPDATE_REQ;
            ble_ll_ctrl_conn_upd_make(connsm, ctrdata, NULL);
    e088:	4620      	mov	r0, r4
    e08a:	2200      	movs	r2, #0
    e08c:	f7ff fee6 	bl	de5c <ble_ll_ctrl_conn_upd_make>
        dptr = om->om_data;
        ctrdata = dptr + 1;

        switch (ctrl_proc) {
        case BLE_LL_CTRL_PROC_CONN_UPDATE:
            opcode = BLE_LL_CTRL_CONN_UPDATE_REQ;
    e090:	2600      	movs	r6, #0
            ble_ll_ctrl_conn_upd_make(connsm, ctrdata, NULL);
            break;
    e092:	e079      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
 */
static void
ble_ll_ctrl_chanmap_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
{
    /* Copy channel map that host desires into request */
    memcpy(pyld, g_ble_ll_conn_params.master_chan_map, BLE_LL_CONN_CHMAP_LEN);
    e094:	4b42      	ldr	r3, [pc, #264]	; (e1a0 <ble_ll_ctrl_proc_init+0x144>)
    e096:	681a      	ldr	r2, [r3, #0]
    e098:	f8c5 2001 	str.w	r2, [r5, #1]
    e09c:	791b      	ldrb	r3, [r3, #4]
    e09e:	710b      	strb	r3, [r1, #4]
    memcpy(connsm->req_chanmap, pyld, BLE_LL_CONN_CHMAP_LEN);
    e0a0:	680b      	ldr	r3, [r1, #0]
    e0a2:	f8c4 301f 	str.w	r3, [r4, #31]
    e0a6:	790b      	ldrb	r3, [r1, #4]
    e0a8:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23

    /* Place instant into request */
    connsm->chanmap_instant = connsm->event_cntr + connsm->slave_latency + 6 + 1;
    e0ac:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    e0ae:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
    e0b2:	4419      	add	r1, r3
    e0b4:	3107      	adds	r1, #7
    e0b6:	b289      	uxth	r1, r1
    e0b8:	84a1      	strh	r1, [r4, #36]	; 0x24
    htole16(pyld + BLE_LL_CONN_CHMAP_LEN, connsm->chanmap_instant);
    e0ba:	1da8      	adds	r0, r5, #6
    e0bc:	f00e ffcc 	bl	1d058 <htole16>

    /* Set scheduled flag */
    connsm->csmflags.cfbit.chanmap_update_scheduled = 1;
    e0c0:	7863      	ldrb	r3, [r4, #1]
    e0c2:	f043 0308 	orr.w	r3, r3, #8
    e0c6:	7063      	strb	r3, [r4, #1]
        case BLE_LL_CTRL_PROC_CONN_UPDATE:
            opcode = BLE_LL_CTRL_CONN_UPDATE_REQ;
            ble_ll_ctrl_conn_upd_make(connsm, ctrdata, NULL);
            break;
        case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
            opcode = BLE_LL_CTRL_CHANNEL_MAP_REQ;
    e0c8:	2601      	movs	r6, #1
    e0ca:	e05d      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
            ble_ll_ctrl_chanmap_req_make(connsm, ctrdata);
            break;
        case BLE_LL_CTRL_PROC_FEATURE_XCHG:
            if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    e0cc:	79e3      	ldrb	r3, [r4, #7]
                opcode = BLE_LL_CTRL_FEATURE_REQ;
            } else {
                opcode = BLE_LL_CTRL_SLAVE_FEATURE_REQ;
    e0ce:	2b01      	cmp	r3, #1
    e0d0:	bf0c      	ite	eq
    e0d2:	2608      	moveq	r6, #8
    e0d4:	260e      	movne	r6, #14
            }
            ctrdata[0] = ble_ll_read_supp_features();
    e0d6:	f7fd f81d 	bl	b114 <ble_ll_read_supp_features>
    e0da:	7068      	strb	r0, [r5, #1]
            break;
    e0dc:	e054      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>

static void
ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
{
    /* Set flag to denote we have sent/received this */
    connsm->csmflags.cfbit.version_ind_sent = 1;
    e0de:	7863      	ldrb	r3, [r4, #1]
    e0e0:	f043 0302 	orr.w	r3, r3, #2
    e0e4:	7063      	strb	r3, [r4, #1]

    /* Fill out response */
    pyld[0] = BLE_HCI_VER_BCS_4_2;
    e0e6:	2308      	movs	r3, #8
    e0e8:	706b      	strb	r3, [r5, #1]
    htole16(pyld + 1, NIMBLE_OPT_LL_MFRG_ID);
    e0ea:	1ca8      	adds	r0, r5, #2
    e0ec:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e0f0:	f00e ffb2 	bl	1d058 <htole16>
    htole16(pyld + 3, BLE_LL_SUB_VERS_NR);
    e0f4:	1d28      	adds	r0, r5, #4
    e0f6:	2100      	movs	r1, #0
    e0f8:	f00e ffae 	bl	1d058 <htole16>
                opcode = BLE_LL_CTRL_SLAVE_FEATURE_REQ;
            }
            ctrdata[0] = ble_ll_read_supp_features();
            break;
        case BLE_LL_CTRL_PROC_VERSION_XCHG:
            opcode = BLE_LL_CTRL_VERSION_IND;
    e0fc:	260c      	movs	r6, #12
    e0fe:	e043      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
            ble_ll_ctrl_version_ind_make(connsm, ctrdata);
            break;
        case BLE_LL_CTRL_PROC_TERMINATE:
            opcode = BLE_LL_CTRL_TERMINATE_IND;
            ctrdata[0] = connsm->disconnect_reason;
    e100:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    e104:	706b      	strb	r3, [r5, #1]
        case BLE_LL_CTRL_PROC_VERSION_XCHG:
            opcode = BLE_LL_CTRL_VERSION_IND;
            ble_ll_ctrl_version_ind_make(connsm, ctrdata);
            break;
        case BLE_LL_CTRL_PROC_TERMINATE:
            opcode = BLE_LL_CTRL_TERMINATE_IND;
    e106:	2602      	movs	r6, #2
            ctrdata[0] = connsm->disconnect_reason;
            break;
    e108:	e03e      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
        case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
            opcode = BLE_LL_CTRL_CONN_PARM_REQ;
            ble_ll_ctrl_conn_param_pdu_make(connsm, ctrdata, NULL);
    e10a:	4620      	mov	r0, r4
    e10c:	2200      	movs	r2, #0
    e10e:	f7ff ff3b 	bl	df88 <ble_ll_ctrl_conn_param_pdu_make>
        case BLE_LL_CTRL_PROC_TERMINATE:
            opcode = BLE_LL_CTRL_TERMINATE_IND;
            ctrdata[0] = connsm->disconnect_reason;
            break;
        case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
            opcode = BLE_LL_CTRL_CONN_PARM_REQ;
    e112:	260f      	movs	r6, #15
            ble_ll_ctrl_conn_param_pdu_make(connsm, ctrdata, NULL);
            break;
    e114:	e038      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
        case BLE_LL_CTRL_PROC_LE_PING:
            opcode = BLE_LL_CTRL_PING_REQ;
            break;
        case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
            opcode = BLE_LL_CTRL_LENGTH_REQ;
            ble_ll_ctrl_datalen_upd_make(connsm, dptr);
    e116:	4620      	mov	r0, r4
    e118:	4629      	mov	r1, r5
    e11a:	f7ff ff1f 	bl	df5c <ble_ll_ctrl_datalen_upd_make>
            break;
        case BLE_LL_CTRL_PROC_LE_PING:
            opcode = BLE_LL_CTRL_PING_REQ;
            break;
        case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
            opcode = BLE_LL_CTRL_LENGTH_REQ;
    e11e:	2614      	movs	r6, #20
            ble_ll_ctrl_datalen_upd_make(connsm, dptr);
            break;
    e120:	e032      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        /* XXX: deal with already encrypted connection.*/
        case BLE_LL_CTRL_PROC_ENCRYPT:
            /* If we are already encrypted we do pause procedure */
            if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) {
    e122:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
    e126:	2b02      	cmp	r3, #2
    e128:	d02d      	beq.n	e186 <ble_ll_ctrl_proc_init+0x12a>
 * @param dptr: Pointer to where control pdu payload starts
 */
static void
ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
{
    htole64(dptr, connsm->enc_data.host_rand_num);
    e12a:	f504 7394 	add.w	r3, r4, #296	; 0x128
    e12e:	e9d3 2300 	ldrd	r2, r3, [r3]
    e132:	4608      	mov	r0, r1
    e134:	f00e ff9c 	bl	1d070 <htole64>
    htole32(dptr + 18, g_bletest_IVm);
    memcpy(connsm->enc_data.iv, dptr + 18, 4);
    return;
#endif

    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text + 8, 8);
    e138:	f504 76a8 	add.w	r6, r4, #336	; 0x150
 */
static void
ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
{
    htole64(dptr, connsm->enc_data.host_rand_num);
    htole16(dptr + 8, connsm->enc_data.enc_div);
    e13c:	f105 0009 	add.w	r0, r5, #9
    e140:	f8b4 1122 	ldrh.w	r1, [r4, #290]	; 0x122
    e144:	f00e ff88 	bl	1d058 <htole16>
    htole32(dptr + 18, g_bletest_IVm);
    memcpy(connsm->enc_data.iv, dptr + 18, 4);
    return;
#endif

    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text + 8, 8);
    e148:	4630      	mov	r0, r6
    e14a:	2108      	movs	r1, #8
    e14c:	f001 f996 	bl	f47c <ble_ll_rand_data_get>
    swap_buf(dptr + 10, connsm->enc_data.enc_block.plain_text + 8, 8);
    e150:	4631      	mov	r1, r6
    e152:	f105 000b 	add.w	r0, r5, #11
    e156:	2208      	movs	r2, #8
    ble_ll_rand_data_get(connsm->enc_data.iv, 4);
    e158:	f504 7698 	add.w	r6, r4, #304	; 0x130
    memcpy(connsm->enc_data.iv, dptr + 18, 4);
    return;
#endif

    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text + 8, 8);
    swap_buf(dptr + 10, connsm->enc_data.enc_block.plain_text + 8, 8);
    e15c:	f00e ffe0 	bl	1d120 <swap_buf>
    ble_ll_rand_data_get(connsm->enc_data.iv, 4);
    e160:	4630      	mov	r0, r6
    e162:	2104      	movs	r1, #4
    e164:	f001 f98a 	bl	f47c <ble_ll_rand_data_get>
    memcpy(dptr + 18, connsm->enc_data.iv, 4);
    e168:	f8d4 3130 	ldr.w	r3, [r4, #304]	; 0x130
    e16c:	f8c5 3013 	str.w	r3, [r5, #19]
        case BLE_LL_CTRL_PROC_ENCRYPT:
            /* If we are already encrypted we do pause procedure */
            if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) {
                opcode = BLE_LL_CTRL_PAUSE_ENC_REQ;
            } else {
                opcode = BLE_LL_CTRL_ENC_REQ;
    e170:	2603      	movs	r6, #3
    e172:	e009      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
                ble_ll_ctrl_enc_req_make(connsm, ctrdata);
            }
            break;
#endif
        default:
            assert(0);
    e174:	2200      	movs	r2, #0
    e176:	480b      	ldr	r0, [pc, #44]	; (e1a4 <ble_ll_ctrl_proc_init+0x148>)
    e178:	f240 5126 	movw	r1, #1318	; 0x526
    e17c:	4613      	mov	r3, r2
    e17e:	f7fb fda7 	bl	9cd0 <__assert_func>
        case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
            opcode = BLE_LL_CTRL_CONN_PARM_REQ;
            ble_ll_ctrl_conn_param_pdu_make(connsm, ctrdata, NULL);
            break;
        case BLE_LL_CTRL_PROC_LE_PING:
            opcode = BLE_LL_CTRL_PING_REQ;
    e182:	2612      	movs	r6, #18
    e184:	e000      	b.n	e188 <ble_ll_ctrl_proc_init+0x12c>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        /* XXX: deal with already encrypted connection.*/
        case BLE_LL_CTRL_PROC_ENCRYPT:
            /* If we are already encrypted we do pause procedure */
            if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) {
                opcode = BLE_LL_CTRL_PAUSE_ENC_REQ;
    e186:	260a      	movs	r6, #10
            break;
        }

        /* Set llid, length and opcode */
        dptr[0] = opcode;
        len = g_ble_ll_ctrl_pkt_lengths[opcode] + 1;
    e188:	4b07      	ldr	r3, [pc, #28]	; (e1a8 <ble_ll_ctrl_proc_init+0x14c>)
            assert(0);
            break;
        }

        /* Set llid, length and opcode */
        dptr[0] = opcode;
    e18a:	702e      	strb	r6, [r5, #0]
        len = g_ble_ll_ctrl_pkt_lengths[opcode] + 1;
    e18c:	5d9b      	ldrb	r3, [r3, r6]
    e18e:	3301      	adds	r3, #1

        /* Add packet to transmit queue of connection */
        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
    e190:	4620      	mov	r0, r4
    e192:	4639      	mov	r1, r7
    e194:	2203      	movs	r2, #3
    e196:	b2db      	uxtb	r3, r3
    e198:	f7fe ffac 	bl	d0f4 <ble_ll_conn_enqueue_pkt>
    }

    return om;
}
    e19c:	4638      	mov	r0, r7
    e19e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e1a0:	200033b8 	.word	0x200033b8
    e1a4:	0001f290 	.word	0x0001f290
    e1a8:	0001f29e 	.word	0x0001f29e

0000e1ac <ble_ll_ctrl_len_proc>:
    return rc;
}

static int
ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
{
    e1ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e1ae:	4604      	mov	r4, r0
    int rc;
    struct ble_ll_len_req ctrl_req;

    /* Extract parameters and check if valid */
    ctrl_req.max_rx_bytes = le16toh(dptr);
    e1b0:	4608      	mov	r0, r1
    return rc;
}

static int
ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
{
    e1b2:	460d      	mov	r5, r1
    int rc;
    struct ble_ll_len_req ctrl_req;

    /* Extract parameters and check if valid */
    ctrl_req.max_rx_bytes = le16toh(dptr);
    e1b4:	f00e ff6b 	bl	1d08e <le16toh>
    e1b8:	f8ad 0000 	strh.w	r0, [sp]
    ctrl_req.max_rx_time = le16toh(dptr + 2);
    e1bc:	1ca8      	adds	r0, r5, #2
    e1be:	f00e ff66 	bl	1d08e <le16toh>
    e1c2:	f8ad 0002 	strh.w	r0, [sp, #2]
    ctrl_req.max_tx_bytes = le16toh(dptr + 4);
    e1c6:	1d28      	adds	r0, r5, #4
    e1c8:	f00e ff61 	bl	1d08e <le16toh>
    e1cc:	f8ad 0004 	strh.w	r0, [sp, #4]
    ctrl_req.max_tx_time = le16toh(dptr + 6);
    e1d0:	1da8      	adds	r0, r5, #6
    e1d2:	f00e ff5c 	bl	1d08e <le16toh>
static int
ble_ll_ctrl_chk_supp_bytes(uint16_t bytes)
{
    int rc;

    if ((bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
    e1d6:	f8bd 3000 	ldrh.w	r3, [sp]

    /* Extract parameters and check if valid */
    ctrl_req.max_rx_bytes = le16toh(dptr);
    ctrl_req.max_rx_time = le16toh(dptr + 2);
    ctrl_req.max_tx_bytes = le16toh(dptr + 4);
    ctrl_req.max_tx_time = le16toh(dptr + 6);
    e1da:	f8ad 0006 	strh.w	r0, [sp, #6]
static int
ble_ll_ctrl_chk_supp_bytes(uint16_t bytes)
{
    int rc;

    if ((bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
    e1de:	3b1b      	subs	r3, #27
    e1e0:	b29b      	uxth	r3, r3
    e1e2:	2be0      	cmp	r3, #224	; 0xe0
    e1e4:	d901      	bls.n	e1ea <ble_ll_ctrl_len_proc+0x3e>

    if (!ble_ll_ctrl_chk_supp_bytes(ctrl_req.max_rx_bytes) ||
        !ble_ll_ctrl_chk_supp_bytes(ctrl_req.max_tx_bytes) ||
        !ble_ll_ctrl_chk_supp_time(ctrl_req.max_tx_time) ||
        !ble_ll_ctrl_chk_supp_time(ctrl_req.max_rx_time)) {
        rc = 1;
    e1e6:	2001      	movs	r0, #1
    e1e8:	e017      	b.n	e21a <ble_ll_ctrl_len_proc+0x6e>
static int
ble_ll_ctrl_chk_supp_bytes(uint16_t bytes)
{
    int rc;

    if ((bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
    e1ea:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    e1ee:	3b1b      	subs	r3, #27
    e1f0:	b29b      	uxth	r3, r3
    e1f2:	2be0      	cmp	r3, #224	; 0xe0
    e1f4:	d8f7      	bhi.n	e1e6 <ble_ll_ctrl_len_proc+0x3a>
static int
ble_ll_ctrl_chk_supp_time(uint16_t t)
{
    int rc;

    if ((t < BLE_LL_CONN_SUPP_TIME_MIN) || (t > BLE_LL_CONN_SUPP_TIME_MAX)) {
    e1f6:	f5a0 70a4 	sub.w	r0, r0, #328	; 0x148
    e1fa:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    e1fe:	d8f2      	bhi.n	e1e6 <ble_ll_ctrl_len_proc+0x3a>
    e200:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    e204:	f5a3 73a4 	sub.w	r3, r3, #328	; 0x148
    e208:	b29b      	uxth	r3, r3
    e20a:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
    e20e:	d8ea      	bhi.n	e1e6 <ble_ll_ctrl_len_proc+0x3a>
        !ble_ll_ctrl_chk_supp_time(ctrl_req.max_tx_time) ||
        !ble_ll_ctrl_chk_supp_time(ctrl_req.max_rx_time)) {
        rc = 1;
    } else {
        /* Update the connection with the new parameters */
        ble_ll_conn_datalen_update(connsm, &ctrl_req);
    e210:	4620      	mov	r0, r4
    e212:	4669      	mov	r1, sp
    e214:	f7fe fab2 	bl	c77c <ble_ll_conn_datalen_update>
        rc = 0;
    e218:	2000      	movs	r0, #0
    }

    return rc;
}
    e21a:	b003      	add	sp, #12
    e21c:	bd30      	pop	{r4, r5, pc}

0000e21e <ble_ll_ctrl_rx_feature_req>:
 * @return int
 */
static int
ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                           uint8_t *rspbuf, uint8_t opcode)
{
    e21e:	b570      	push	{r4, r5, r6, lr}

    /*
     * Only accept slave feature requests if we are a master and feature
     * requests if we are a slave.
     */
    if (opcode ==  BLE_LL_CTRL_SLAVE_FEATURE_REQ) {
    e220:	2b0e      	cmp	r3, #14
 * @return int
 */
static int
ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                           uint8_t *rspbuf, uint8_t opcode)
{
    e222:	4604      	mov	r4, r0
    e224:	4616      	mov	r6, r2
    e226:	79c3      	ldrb	r3, [r0, #7]

    /*
     * Only accept slave feature requests if we are a master and feature
     * requests if we are a slave.
     */
    if (opcode ==  BLE_LL_CTRL_SLAVE_FEATURE_REQ) {
    e228:	d101      	bne.n	e22e <ble_ll_ctrl_rx_feature_req+0x10>
        if (connsm->conn_role != BLE_LL_CONN_ROLE_MASTER) {
    e22a:	2b01      	cmp	r3, #1
    e22c:	e000      	b.n	e230 <ble_ll_ctrl_rx_feature_req+0x12>
            return BLE_LL_CTRL_UNKNOWN_RSP;
        }
    } else {
        /* XXX: not sure this is correct but do it anyway */
        if (connsm->conn_role != BLE_LL_CONN_ROLE_SLAVE) {
    e22e:	2b02      	cmp	r3, #2
    e230:	d10f      	bne.n	e252 <ble_ll_ctrl_rx_feature_req+0x34>
        }
    }

    /* Set common features and reply */
    rsp_opcode = BLE_LL_CTRL_FEATURE_RSP;
    connsm->common_features = dptr[0] & ble_ll_read_supp_features();
    e232:	780d      	ldrb	r5, [r1, #0]
    e234:	f7fc ff6e 	bl	b114 <ble_ll_read_supp_features>
    e238:	4028      	ands	r0, r5
    e23a:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
    memset(rspbuf + 1, 0, 8);
    e23e:	2100      	movs	r1, #0
    e240:	1c70      	adds	r0, r6, #1
    e242:	2208      	movs	r2, #8
    e244:	f7fa fee5 	bl	9012 <memset>
    rspbuf[1] = connsm->common_features;
    e248:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    e24c:	7073      	strb	r3, [r6, #1]
    e24e:	2009      	movs	r0, #9
    e250:	bd70      	pop	{r4, r5, r6, pc}
     * Only accept slave feature requests if we are a master and feature
     * requests if we are a slave.
     */
    if (opcode ==  BLE_LL_CTRL_SLAVE_FEATURE_REQ) {
        if (connsm->conn_role != BLE_LL_CONN_ROLE_MASTER) {
            return BLE_LL_CTRL_UNKNOWN_RSP;
    e252:	2007      	movs	r0, #7
    connsm->common_features = dptr[0] & ble_ll_read_supp_features();
    memset(rspbuf + 1, 0, 8);
    rspbuf[1] = connsm->common_features;

    return rsp_opcode;
}
    e254:	bd70      	pop	{r4, r5, r6, pc}

0000e256 <ble_ll_calc_session_key>:
}

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
void
ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
{
    e256:	b510      	push	{r4, lr}
    e258:	4604      	mov	r4, r0
    int cnt;
#endif

    /* XXX: possibly have some way out of this if this locks up */
    while (1) {
        if (!ble_hw_encrypt_block(&connsm->enc_data.enc_block)) {
    e25a:	f504 709c 	add.w	r0, r4, #312	; 0x138
    e25e:	f002 fd27 	bl	10cb0 <ble_hw_encrypt_block>
    e262:	2800      	cmp	r0, #0
    e264:	d1f9      	bne.n	e25a <ble_ll_calc_session_key+0x4>
    for (cnt = 0; cnt < 8; ++ cnt) {
        console_printf("%02x", connsm->enc_data.iv[cnt]);
    }
    console_printf("\n");
#endif
}
    e266:	bd10      	pop	{r4, pc}

0000e268 <ble_ll_ctrl_enc_allowed_pdu>:

    allowed = 0;
    m = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
    ble_hdr = BLE_MBUF_HDR_PTR(m);

    llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
    e268:	7ac3      	ldrb	r3, [r0, #11]
    if (llid == BLE_LL_LLID_CTRL) {
    e26a:	f003 0303 	and.w	r3, r3, #3
    e26e:	2b03      	cmp	r3, #3
    e270:	d110      	bne.n	e294 <ble_ll_ctrl_enc_allowed_pdu+0x2c>
        opcode = m->om_data[0];
    e272:	f850 3c10 	ldr.w	r3, [r0, #-16]
    e276:	781b      	ldrb	r3, [r3, #0]
    e278:	3b02      	subs	r3, #2
    e27a:	b2db      	uxtb	r3, r3
    e27c:	2b0f      	cmp	r3, #15
    e27e:	d809      	bhi.n	e294 <ble_ll_ctrl_enc_allowed_pdu+0x2c>
    e280:	2201      	movs	r2, #1
    e282:	fa02 f303 	lsl.w	r3, r2, r3
    e286:	f648 301f 	movw	r0, #35615	; 0x8b1f
    e28a:	4018      	ands	r0, r3
    e28c:	3000      	adds	r0, #0
    e28e:	bf18      	it	ne
    e290:	2001      	movne	r0, #1
    e292:	4770      	bx	lr
    uint8_t opcode;
    uint8_t llid;
    struct os_mbuf *m;
    struct ble_mbuf_hdr *ble_hdr;

    allowed = 0;
    e294:	2000      	movs	r0, #0
            break;
        }
    }

    return allowed;
}
    e296:	4770      	bx	lr

0000e298 <ble_ll_ctrl_is_start_enc_rsp>:
    struct ble_mbuf_hdr *ble_hdr;

    is_start_enc_rsp = 0;
    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);

    llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
    e298:	7ec3      	ldrb	r3, [r0, #27]
    if (llid == BLE_LL_LLID_CTRL) {
    e29a:	f003 0303 	and.w	r3, r3, #3
    e29e:	2b03      	cmp	r3, #3
    e2a0:	d105      	bne.n	e2ae <ble_ll_ctrl_is_start_enc_rsp+0x16>
        opcode = txpdu->om_data[0];
    e2a2:	6803      	ldr	r3, [r0, #0]
        if (opcode == BLE_LL_CTRL_START_ENC_RSP) {
    e2a4:	7818      	ldrb	r0, [r3, #0]
    e2a6:	1f83      	subs	r3, r0, #6
    e2a8:	4258      	negs	r0, r3
    e2aa:	4158      	adcs	r0, r3
    e2ac:	4770      	bx	lr
    int is_start_enc_rsp;
    uint8_t opcode;
    uint8_t llid;
    struct ble_mbuf_hdr *ble_hdr;

    is_start_enc_rsp = 0;
    e2ae:	2000      	movs	r0, #0
            is_start_enc_rsp = 1;
        }
    }

    return is_start_enc_rsp;
}
    e2b0:	4770      	bx	lr

0000e2b2 <ble_ll_ctrl_start_enc_send>:
 *
 * @return int
 */
int
ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm, uint8_t opcode)
{
    e2b2:	b538      	push	{r3, r4, r5, lr}
    e2b4:	4604      	mov	r4, r0
    e2b6:	460d      	mov	r5, r1
    int rc;
    struct os_mbuf *om;

    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
    e2b8:	201b      	movs	r0, #27
    e2ba:	2108      	movs	r1, #8
    e2bc:	f7fb fe39 	bl	9f32 <os_msys_get_pkthdr>
                            sizeof(struct ble_mbuf_hdr));
    if (om) {
    e2c0:	4601      	mov	r1, r0
    e2c2:	b140      	cbz	r0, e2d6 <ble_ll_ctrl_start_enc_send+0x24>
        om->om_data[0] = opcode;
    e2c4:	6803      	ldr	r3, [r0, #0]
        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
    e2c6:	2203      	movs	r2, #3
    struct os_mbuf *om;

    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
                            sizeof(struct ble_mbuf_hdr));
    if (om) {
        om->om_data[0] = opcode;
    e2c8:	701d      	strb	r5, [r3, #0]
        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
    e2ca:	4620      	mov	r0, r4
    e2cc:	2301      	movs	r3, #1
    e2ce:	f7fe ff11 	bl	d0f4 <ble_ll_conn_enqueue_pkt>
        rc = 0;
    e2d2:	2000      	movs	r0, #0
    e2d4:	bd38      	pop	{r3, r4, r5, pc}
    } else {
        rc = -1;
    e2d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }
    return rc;
}
    e2da:	bd38      	pop	{r3, r4, r5, pc}

0000e2dc <ble_ll_ctrl_conn_param_reply>:
 * @return uint8_t
 */
uint8_t
ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
                             struct ble_ll_conn_params *req)
{
    e2dc:	b508      	push	{r3, lr}
    uint8_t rsp_opcode;

    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    e2de:	79c3      	ldrb	r3, [r0, #7]
    e2e0:	2b02      	cmp	r3, #2
    e2e2:	f101 0101 	add.w	r1, r1, #1
    e2e6:	d103      	bne.n	e2f0 <ble_ll_ctrl_conn_param_reply+0x14>
        /* Create a connection parameter response */
        ble_ll_ctrl_conn_param_pdu_make(connsm, rsp + 1, req);
    e2e8:	f7ff fe4e 	bl	df88 <ble_ll_ctrl_conn_param_pdu_make>
        rsp_opcode = BLE_LL_CTRL_CONN_PARM_RSP;
    e2ec:	2010      	movs	r0, #16
    e2ee:	bd08      	pop	{r3, pc}
    } else {
        /* Create a connection update pdu */
        ble_ll_ctrl_conn_upd_make(connsm, rsp + 1, req);
    e2f0:	f7ff fdb4 	bl	de5c <ble_ll_ctrl_conn_upd_make>
        rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_REQ;
    e2f4:	2000      	movs	r0, #0
    }

    return rsp_opcode;
}
    e2f6:	bd08      	pop	{r3, pc}

0000e2f8 <ble_ll_ctrl_conn_param_pdu_proc>:
 * @return int
 */
static int
ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                                uint8_t *rspbuf, uint8_t opcode)
{
    e2f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e2fa:	4604      	mov	r4, r0
    struct ble_ll_conn_params *req;
    struct hci_conn_update *hcu;

    /* Extract parameters and check if valid */
    req = &connsm->conn_cp;
    req->interval_min = le16toh(dptr);
    e2fc:	4608      	mov	r0, r1
 * @return int
 */
static int
ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                                uint8_t *rspbuf, uint8_t opcode)
{
    e2fe:	460d      	mov	r5, r1
    e300:	4617      	mov	r7, r2
    e302:	461e      	mov	r6, r3
    struct ble_ll_conn_params *req;
    struct hci_conn_update *hcu;

    /* Extract parameters and check if valid */
    req = &connsm->conn_cp;
    req->interval_min = le16toh(dptr);
    e304:	f00e fec3 	bl	1d08e <le16toh>
    e308:	f8a4 0182 	strh.w	r0, [r4, #386]	; 0x182
    req->interval_max = le16toh(dptr + 2);
    e30c:	1ca8      	adds	r0, r5, #2
    e30e:	f00e febe 	bl	1d08e <le16toh>
    e312:	f8a4 0184 	strh.w	r0, [r4, #388]	; 0x184
    req->latency = le16toh(dptr + 4);
    e316:	1d28      	adds	r0, r5, #4
    e318:	f00e feb9 	bl	1d08e <le16toh>
    e31c:	f8a4 0186 	strh.w	r0, [r4, #390]	; 0x186
    req->timeout = le16toh(dptr + 6);
    e320:	1da8      	adds	r0, r5, #6
    e322:	f00e feb4 	bl	1d08e <le16toh>
    e326:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
    req->pref_periodicity = dptr[8];
    e32a:	7a2b      	ldrb	r3, [r5, #8]
    e32c:	f884 318a 	strb.w	r3, [r4, #394]	; 0x18a
    req->ref_conn_event_cnt  = le16toh(dptr + 9);
    e330:	f105 0009 	add.w	r0, r5, #9
    e334:	f00e feab 	bl	1d08e <le16toh>
    e338:	f8a4 018c 	strh.w	r0, [r4, #396]	; 0x18c
    req->offset0 = le16toh(dptr + 11);
    e33c:	f105 000b 	add.w	r0, r5, #11
    e340:	f00e fea5 	bl	1d08e <le16toh>
    e344:	f8a4 018e 	strh.w	r0, [r4, #398]	; 0x18e
    req->offset1 = le16toh(dptr + 13);
    e348:	f105 000d 	add.w	r0, r5, #13
    e34c:	f00e fe9f 	bl	1d08e <le16toh>
    e350:	f8a4 0190 	strh.w	r0, [r4, #400]	; 0x190
    req->offset2 = le16toh(dptr + 15);
    e354:	f105 000f 	add.w	r0, r5, #15
    e358:	f00e fe99 	bl	1d08e <le16toh>
    e35c:	f8a4 0192 	strh.w	r0, [r4, #402]	; 0x192
    req->offset3 = le16toh(dptr + 17);
    e360:	f105 0011 	add.w	r0, r5, #17
    e364:	f00e fe93 	bl	1d08e <le16toh>
    e368:	f8a4 0194 	strh.w	r0, [r4, #404]	; 0x194
    req->offset4 = le16toh(dptr + 19);
    e36c:	f105 0013 	add.w	r0, r5, #19
    e370:	f00e fe8d 	bl	1d08e <le16toh>
    e374:	f8a4 0196 	strh.w	r0, [r4, #406]	; 0x196
    req->offset5 = le16toh(dptr + 21);
    e378:	f105 0015 	add.w	r0, r5, #21
    e37c:	f00e fe87 	bl	1d08e <le16toh>

    /* Check if parameters are valid */
    ble_err = BLE_ERR_SUCCESS;
    rc = ble_ll_conn_hci_chk_conn_params(req->interval_min,
    e380:	f8b4 1184 	ldrh.w	r1, [r4, #388]	; 0x184
    req->offset0 = le16toh(dptr + 11);
    req->offset1 = le16toh(dptr + 13);
    req->offset2 = le16toh(dptr + 15);
    req->offset3 = le16toh(dptr + 17);
    req->offset4 = le16toh(dptr + 19);
    req->offset5 = le16toh(dptr + 21);
    e384:	f8a4 0198 	strh.w	r0, [r4, #408]	; 0x198

    /* Check if parameters are valid */
    ble_err = BLE_ERR_SUCCESS;
    rc = ble_ll_conn_hci_chk_conn_params(req->interval_min,
    e388:	f8b4 2186 	ldrh.w	r2, [r4, #390]	; 0x186
    e38c:	f8b4 0182 	ldrh.w	r0, [r4, #386]	; 0x182
    e390:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    e394:	f7ff f892 	bl	d4bc <ble_ll_conn_hci_chk_conn_params>
                                         req->interval_max,
                                         req->latency,
                                         req->timeout);
    if (rc) {
    e398:	2800      	cmp	r0, #0
    e39a:	d14e      	bne.n	e43a <ble_ll_ctrl_conn_param_pdu_proc+0x142>
     * or latency. If not, this may just be an anchor point change and we do
     * not have to notify the host.
     *  XXX: what if we dont like the parameters? When do we check that out?
     */
    indicate = 1;
    if (opcode == BLE_LL_CTRL_CONN_PARM_REQ) {
    e39c:	2e0f      	cmp	r6, #15
    uint8_t ble_err;
    struct ble_ll_conn_params *req;
    struct hci_conn_update *hcu;

    /* Extract parameters and check if valid */
    req = &connsm->conn_cp;
    e39e:	f504 72c1 	add.w	r2, r4, #386	; 0x182
     * or latency. If not, this may just be an anchor point change and we do
     * not have to notify the host.
     *  XXX: what if we dont like the parameters? When do we check that out?
     */
    indicate = 1;
    if (opcode == BLE_LL_CTRL_CONN_PARM_REQ) {
    e3a2:	d115      	bne.n	e3d0 <ble_ll_ctrl_conn_param_pdu_proc+0xd8>
        if ((connsm->conn_itvl >= req->interval_min) &&
    e3a4:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    e3a8:	f8b4 1182 	ldrh.w	r1, [r4, #386]	; 0x182
    e3ac:	4299      	cmp	r1, r3
    e3ae:	d80f      	bhi.n	e3d0 <ble_ll_ctrl_conn_param_pdu_proc+0xd8>
    e3b0:	f8b4 1184 	ldrh.w	r1, [r4, #388]	; 0x184
    e3b4:	4299      	cmp	r1, r3
    e3b6:	d30b      	bcc.n	e3d0 <ble_ll_ctrl_conn_param_pdu_proc+0xd8>
            (connsm->conn_itvl <= req->interval_max) &&
    e3b8:	f8b4 1064 	ldrh.w	r1, [r4, #100]	; 0x64
    e3bc:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    e3c0:	4299      	cmp	r1, r3
    e3c2:	d105      	bne.n	e3d0 <ble_ll_ctrl_conn_param_pdu_proc+0xd8>
            (connsm->supervision_tmo == req->timeout) &&
    e3c4:	f8b4 1062 	ldrh.w	r1, [r4, #98]	; 0x62
    e3c8:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
    e3cc:	4299      	cmp	r1, r3
    e3ce:	d02f      	beq.n	e430 <ble_ll_ctrl_conn_param_pdu_proc+0x138>
     * the host? Note that for a master we will not be processing a
     * connect param request from a slave if we are currently trying to
     * update the connection parameters. This means that the previous
     * check is all we need for a master (when receiving a request).
     */
    if ((connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) ||
    e3d0:	79e3      	ldrb	r3, [r4, #7]
    e3d2:	2b02      	cmp	r3, #2
    e3d4:	d001      	beq.n	e3da <ble_ll_ctrl_conn_param_pdu_proc+0xe2>
    e3d6:	2e10      	cmp	r6, #16
    e3d8:	d11e      	bne.n	e418 <ble_ll_ctrl_conn_param_pdu_proc+0x120>
         * has provided? Not sure what to do here. Do we need to remember what
         * host sent us? For now, I will assume that we need to remember what
         * the host sent us and check it out.
         */
        hcu = &connsm->conn_param_req;
        if (hcu->handle != 0) {
    e3da:	f8b4 3168 	ldrh.w	r3, [r4, #360]	; 0x168
    e3de:	b1db      	cbz	r3, e418 <ble_ll_ctrl_conn_param_pdu_proc+0x120>
            if (!((req->interval_min < hcu->conn_itvl_min) ||
    e3e0:	f8b4 1182 	ldrh.w	r1, [r4, #386]	; 0x182
    e3e4:	f8b4 016a 	ldrh.w	r0, [r4, #362]	; 0x16a
    e3e8:	4281      	cmp	r1, r0
    e3ea:	d315      	bcc.n	e418 <ble_ll_ctrl_conn_param_pdu_proc+0x120>
                  (req->interval_min > hcu->conn_itvl_max) ||
    e3ec:	f8b4 316c 	ldrh.w	r3, [r4, #364]	; 0x16c
         * host sent us? For now, I will assume that we need to remember what
         * the host sent us and check it out.
         */
        hcu = &connsm->conn_param_req;
        if (hcu->handle != 0) {
            if (!((req->interval_min < hcu->conn_itvl_min) ||
    e3f0:	4299      	cmp	r1, r3
    e3f2:	d811      	bhi.n	e418 <ble_ll_ctrl_conn_param_pdu_proc+0x120>
                  (req->interval_min > hcu->conn_itvl_max) ||
                  (req->interval_max < hcu->conn_itvl_min) ||
    e3f4:	f8b4 1184 	ldrh.w	r1, [r4, #388]	; 0x184
         * the host sent us and check it out.
         */
        hcu = &connsm->conn_param_req;
        if (hcu->handle != 0) {
            if (!((req->interval_min < hcu->conn_itvl_min) ||
                  (req->interval_min > hcu->conn_itvl_max) ||
    e3f8:	4281      	cmp	r1, r0
    e3fa:	d30d      	bcc.n	e418 <ble_ll_ctrl_conn_param_pdu_proc+0x120>
                  (req->interval_max < hcu->conn_itvl_min) ||
    e3fc:	4299      	cmp	r1, r3
    e3fe:	d80b      	bhi.n	e418 <ble_ll_ctrl_conn_param_pdu_proc+0x120>
                  (req->interval_max > hcu->conn_itvl_max) ||
    e400:	f8b4 1186 	ldrh.w	r1, [r4, #390]	; 0x186
    e404:	f8b4 316e 	ldrh.w	r3, [r4, #366]	; 0x16e
    e408:	4299      	cmp	r1, r3
    e40a:	d105      	bne.n	e418 <ble_ll_ctrl_conn_param_pdu_proc+0x120>
         * host sent us? For now, I will assume that we need to remember what
         * the host sent us and check it out.
         */
        hcu = &connsm->conn_param_req;
        if (hcu->handle != 0) {
            if (!((req->interval_min < hcu->conn_itvl_min) ||
    e40c:	f8b4 1188 	ldrh.w	r1, [r4, #392]	; 0x188
    e410:	f8b4 3170 	ldrh.w	r3, [r4, #368]	; 0x170
    e414:	4299      	cmp	r1, r3
    e416:	d00b      	beq.n	e430 <ble_ll_ctrl_conn_param_pdu_proc+0x138>
        /*
         * Send event to host. At this point we leave and wait to get
         * an answer.
         */
        /* XXX: what about masked out event? */
        ble_ll_hci_ev_rem_conn_parm_req(connsm, req);
    e418:	4620      	mov	r0, r4
    e41a:	4611      	mov	r1, r2
    e41c:	f000 fef8 	bl	f210 <ble_ll_hci_ev_rem_conn_parm_req>
        connsm->host_reply_opcode = opcode;
        connsm->csmflags.cfbit.awaiting_host_reply = 1;
    e420:	7823      	ldrb	r3, [r4, #0]
         * Send event to host. At this point we leave and wait to get
         * an answer.
         */
        /* XXX: what about masked out event? */
        ble_ll_hci_ev_rem_conn_parm_req(connsm, req);
        connsm->host_reply_opcode = opcode;
    e422:	f884 6033 	strb.w	r6, [r4, #51]	; 0x33
        connsm->csmflags.cfbit.awaiting_host_reply = 1;
    e426:	f043 0320 	orr.w	r3, r3, #32
    e42a:	7023      	strb	r3, [r4, #0]
        rsp_opcode = 255;
    e42c:	20ff      	movs	r0, #255	; 0xff
    e42e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else {
        /* Create reply to connection request */
        rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, rspbuf, req);
    e430:	4620      	mov	r0, r4
    e432:	4639      	mov	r1, r7
    e434:	f7ff ff52 	bl	e2dc <ble_ll_ctrl_conn_param_reply>
    e438:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

conn_param_pdu_exit:
    if (ble_err) {
        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
        rspbuf[1] = opcode;
        rspbuf[2] = ble_err;
    e43a:	231e      	movs	r3, #30
    }

conn_param_pdu_exit:
    if (ble_err) {
        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
        rspbuf[1] = opcode;
    e43c:	707e      	strb	r6, [r7, #1]
        rspbuf[2] = ble_err;
    e43e:	70bb      	strb	r3, [r7, #2]
        rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, rspbuf, req);
    }

conn_param_pdu_exit:
    if (ble_err) {
        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
    e440:	2011      	movs	r0, #17
        rspbuf[1] = opcode;
        rspbuf[2] = ble_err;
    }
    return rsp_opcode;
}
    e442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000e444 <ble_ll_ctrl_is_terminate_ind>:
ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
{
    int rc;

    rc = 0;
    if ((hdr & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
    e444:	f000 0003 	and.w	r0, r0, #3
    e448:	2803      	cmp	r0, #3
    e44a:	d103      	bne.n	e454 <ble_ll_ctrl_is_terminate_ind+0x10>
        if (opcode == BLE_LL_CTRL_TERMINATE_IND) {
    e44c:	1e8b      	subs	r3, r1, #2
    e44e:	4258      	negs	r0, r3
    e450:	4158      	adcs	r0, r3
    e452:	4770      	bx	lr
int
ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
{
    int rc;

    rc = 0;
    e454:	2000      	movs	r0, #0
        if (opcode == BLE_LL_CTRL_TERMINATE_IND) {
            rc = 1;
        }
    }
    return rc;
}
    e456:	4770      	bx	lr

0000e458 <ble_ll_ctrl_terminate_start>:
 *
 * @param connsm
 */
void
ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
{
    e458:	b570      	push	{r4, r5, r6, lr}
    int ctrl_proc;
    uint32_t usecs;
    struct os_mbuf *om;

    assert(connsm->disconnect_reason != 0);
    e45a:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
 *
 * @param connsm
 */
void
ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
{
    e45e:	4604      	mov	r4, r0
    int ctrl_proc;
    uint32_t usecs;
    struct os_mbuf *om;

    assert(connsm->disconnect_reason != 0);
    e460:	b92a      	cbnz	r2, e46e <ble_ll_ctrl_terminate_start+0x16>
    e462:	480e      	ldr	r0, [pc, #56]	; (e49c <ble_ll_ctrl_terminate_start+0x44>)
    e464:	f240 516e 	movw	r1, #1390	; 0x56e
    e468:	4613      	mov	r3, r2
    e46a:	f7fb fc31 	bl	9cd0 <__assert_func>

    ctrl_proc = BLE_LL_CTRL_PROC_TERMINATE;
    om = ble_ll_ctrl_proc_init(connsm, ctrl_proc);
    e46e:	2105      	movs	r1, #5
    e470:	f7ff fdf4 	bl	e05c <ble_ll_ctrl_proc_init>
    if (om) {
    e474:	b180      	cbz	r0, e498 <ble_ll_ctrl_terminate_start+0x40>
        connsm->pending_ctrl_procs |= (1 << ctrl_proc);
    e476:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c

        /* Set terminate "timeout" */
        usecs = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
    e478:	f8b4 6064 	ldrh.w	r6, [r4, #100]	; 0x64
    assert(connsm->disconnect_reason != 0);

    ctrl_proc = BLE_LL_CTRL_PROC_TERMINATE;
    om = ble_ll_ctrl_proc_init(connsm, ctrl_proc);
    if (om) {
        connsm->pending_ctrl_procs |= (1 << ctrl_proc);
    e47c:	f043 0320 	orr.w	r3, r3, #32
    e480:	87a3      	strh	r3, [r4, #60]	; 0x3c

        /* Set terminate "timeout" */
        usecs = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
    e482:	f242 7310 	movw	r3, #10000	; 0x2710
    e486:	435e      	muls	r6, r3
        connsm->terminate_timeout = cputime_get32() +
    e488:	f7fa fd58 	bl	8f3c <cputime_get32>
    e48c:	4605      	mov	r5, r0
            cputime_usecs_to_ticks(usecs);
    e48e:	4630      	mov	r0, r6
    e490:	f7fa fc10 	bl	8cb4 <cputime_usecs_to_ticks>
    if (om) {
        connsm->pending_ctrl_procs |= (1 << ctrl_proc);

        /* Set terminate "timeout" */
        usecs = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
        connsm->terminate_timeout = cputime_get32() +
    e494:	4428      	add	r0, r5
    e496:	6560      	str	r0, [r4, #84]	; 0x54
    e498:	bd70      	pop	{r4, r5, r6, pc}
    e49a:	bf00      	nop
    e49c:	0001f290 	.word	0x0001f290

0000e4a0 <ble_ll_ctrl_proc_start>:
void
ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc)
{
    struct os_mbuf *om;

    assert(ctrl_proc != BLE_LL_CTRL_PROC_TERMINATE);
    e4a0:	2905      	cmp	r1, #5
 *
 * @param connsm Pointer to connection state machine.
 */
void
ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc)
{
    e4a2:	b570      	push	{r4, r5, r6, lr}
    e4a4:	4604      	mov	r4, r0
    e4a6:	460d      	mov	r5, r1
    struct os_mbuf *om;

    assert(ctrl_proc != BLE_LL_CTRL_PROC_TERMINATE);
    e4a8:	d106      	bne.n	e4b8 <ble_ll_ctrl_proc_start+0x18>
    e4aa:	2200      	movs	r2, #0
    e4ac:	4811      	ldr	r0, [pc, #68]	; (e4f4 <ble_ll_ctrl_proc_start+0x54>)
    e4ae:	f240 518a 	movw	r1, #1418	; 0x58a
    e4b2:	4613      	mov	r3, r2
    e4b4:	f7fb fc0c 	bl	9cd0 <__assert_func>

    om = NULL;
    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
    e4b8:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    e4bc:	2bff      	cmp	r3, #255	; 0xff
    e4be:	d113      	bne.n	e4e8 <ble_ll_ctrl_proc_start+0x48>
        /* Initiate the control procedure. */
        om = ble_ll_ctrl_proc_init(connsm, ctrl_proc);
    e4c0:	f7ff fdcc 	bl	e05c <ble_ll_ctrl_proc_init>
        if (om) {
    e4c4:	b180      	cbz	r0, e4e8 <ble_ll_ctrl_proc_start+0x48>
            /* Set the current control procedure */
            connsm->cur_ctrl_proc = ctrl_proc;

            /* Initialize the procedure response timeout */
            if (ctrl_proc != BLE_LL_CTRL_PROC_CHAN_MAP_UPD) {
    e4c6:	2d01      	cmp	r5, #1
    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
        /* Initiate the control procedure. */
        om = ble_ll_ctrl_proc_init(connsm, ctrl_proc);
        if (om) {
            /* Set the current control procedure */
            connsm->cur_ctrl_proc = ctrl_proc;
    e4c8:	f884 5036 	strb.w	r5, [r4, #54]	; 0x36

            /* Initialize the procedure response timeout */
            if (ctrl_proc != BLE_LL_CTRL_PROC_CHAN_MAP_UPD) {
    e4cc:	d00c      	beq.n	e4e8 <ble_ll_ctrl_proc_start+0x48>
                os_callout_func_init(&connsm->ctrl_proc_rsp_timer,
    e4ce:	f104 06c0 	add.w	r6, r4, #192	; 0xc0
    e4d2:	4630      	mov	r0, r6
    e4d4:	4908      	ldr	r1, [pc, #32]	; (e4f8 <ble_ll_ctrl_proc_start+0x58>)
    e4d6:	4a09      	ldr	r2, [pc, #36]	; (e4fc <ble_ll_ctrl_proc_start+0x5c>)
    e4d8:	4623      	mov	r3, r4
    e4da:	f7fb fae3 	bl	9aa4 <os_callout_func_init>
                                     &g_ble_ll_data.ll_evq,
                                     ble_ll_ctrl_proc_rsp_timer_cb,
                                     connsm);

                /* Re-start timer. Control procedure timeout is 40 seconds */
                os_callout_reset(&connsm->ctrl_proc_rsp_timer.cf_c,
    e4de:	4630      	mov	r0, r6
    e4e0:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
    e4e4:	f7fb fb0c 	bl	9b00 <os_callout_reset>
            }
        }
    }

    /* Set bitmask denoting control procedure is pending */
    connsm->pending_ctrl_procs |= (1 << ctrl_proc);
    e4e8:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
    e4ea:	2301      	movs	r3, #1
    e4ec:	40ab      	lsls	r3, r5
    e4ee:	4313      	orrs	r3, r2
    e4f0:	87a3      	strh	r3, [r4, #60]	; 0x3c
    e4f2:	bd70      	pop	{r4, r5, r6, pc}
    e4f4:	0001f290 	.word	0x0001f290
    e4f8:	200032c8 	.word	0x200032c8
    e4fc:	0000e055 	.word	0x0000e055

0000e500 <ble_ll_ctrl_chk_proc_start>:
 *
 * @param connsm Pointer to connection state machine.
 */
void
ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
{
    e500:	b538      	push	{r3, r4, r5, lr}
    int i;

    /* If we are terminating, dont start any new procedures */
    if (connsm->disconnect_reason) {
    e502:	f890 4037 	ldrb.w	r4, [r0, #55]	; 0x37
 *
 * @param connsm Pointer to connection state machine.
 */
void
ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
{
    e506:	4605      	mov	r5, r0
    int i;

    /* If we are terminating, dont start any new procedures */
    if (connsm->disconnect_reason) {
    e508:	b11c      	cbz	r4, e512 <ble_ll_ctrl_chk_proc_start+0x12>
                    break;
                }
            }
        }
    }
}
    e50a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        /*
         * If the terminate procedure is not pending it means we were not
         * able to start it right away (no control pdu was available).
         * Start it now.
         */
        ble_ll_ctrl_terminate_start(connsm);
    e50e:	f7ff bfa3 	b.w	e458 <ble_ll_ctrl_terminate_start>
        return;
    }

    /* If there is a running procedure or no pending, do nothing */
    if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) &&
    e512:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    e516:	2bff      	cmp	r3, #255	; 0xff
    e518:	d11b      	bne.n	e552 <ble_ll_ctrl_chk_proc_start+0x52>
    e51a:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
    e51c:	b1cb      	cbz	r3, e552 <ble_ll_ctrl_chk_proc_start+0x52>
        /*
         * The specification says there is no priority to control procedures
         * so just start from the first one for now.
         */
        for (i = 0; i < BLE_LL_CTRL_PROC_NUM; ++i) {
            if (IS_PENDING_CTRL_PROC(connsm, i)) {
    e51e:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    e520:	4123      	asrs	r3, r4
    e522:	07da      	lsls	r2, r3, #31
    e524:	d512      	bpl.n	e54c <ble_ll_ctrl_chk_proc_start+0x4c>
                /*
                 * The version exchange is a special case. If we have already
                 * received the information dont start it.
                 */
                if ((i == BLE_LL_CTRL_PROC_VERSION_XCHG) &&
    e526:	2c04      	cmp	r4, #4
                    (connsm->csmflags.cfbit.rxd_version_ind)) {
                    ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
    e528:	4628      	mov	r0, r5
            if (IS_PENDING_CTRL_PROC(connsm, i)) {
                /*
                 * The version exchange is a special case. If we have already
                 * received the information dont start it.
                 */
                if ((i == BLE_LL_CTRL_PROC_VERSION_XCHG) &&
    e52a:	d10a      	bne.n	e542 <ble_ll_ctrl_chk_proc_start+0x42>
    e52c:	786b      	ldrb	r3, [r5, #1]
    e52e:	075b      	lsls	r3, r3, #29
    e530:	d507      	bpl.n	e542 <ble_ll_ctrl_chk_proc_start+0x42>
                    (connsm->csmflags.cfbit.rxd_version_ind)) {
                    ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
    e532:	2100      	movs	r1, #0
    e534:	f000 ff54 	bl	f3e0 <ble_ll_hci_ev_rd_rem_ver>
                    CLR_PENDING_CTRL_PROC(connsm, i);
    e538:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    e53a:	f023 0310 	bic.w	r3, r3, #16
    e53e:	87ab      	strh	r3, [r5, #60]	; 0x3c
    e540:	e004      	b.n	e54c <ble_ll_ctrl_chk_proc_start+0x4c>
                } else {
                    ble_ll_ctrl_proc_start(connsm, i);
    e542:	4621      	mov	r1, r4
                    break;
                }
            }
        }
    }
}
    e544:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                if ((i == BLE_LL_CTRL_PROC_VERSION_XCHG) &&
                    (connsm->csmflags.cfbit.rxd_version_ind)) {
                    ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
                    CLR_PENDING_CTRL_PROC(connsm, i);
                } else {
                    ble_ll_ctrl_proc_start(connsm, i);
    e548:	f7ff bfaa 	b.w	e4a0 <ble_ll_ctrl_proc_start>
        (connsm->pending_ctrl_procs != 0)) {
        /*
         * The specification says there is no priority to control procedures
         * so just start from the first one for now.
         */
        for (i = 0; i < BLE_LL_CTRL_PROC_NUM; ++i) {
    e54c:	3401      	adds	r4, #1
    e54e:	2c09      	cmp	r4, #9
    e550:	d1e5      	bne.n	e51e <ble_ll_ctrl_chk_proc_start+0x1e>
    e552:	bd38      	pop	{r3, r4, r5, pc}

0000e554 <ble_ll_ctrl_proc_stop>:
 * @param connsm
 * @param ctrl_proc
 */
void
ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
{
    e554:	b538      	push	{r3, r4, r5, lr}
    if (connsm->cur_ctrl_proc == ctrl_proc) {
    e556:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    e55a:	428b      	cmp	r3, r1
 * @param connsm
 * @param ctrl_proc
 */
void
ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
{
    e55c:	4604      	mov	r4, r0
    e55e:	460d      	mov	r5, r1
    if (connsm->cur_ctrl_proc == ctrl_proc) {
    e560:	d105      	bne.n	e56e <ble_ll_ctrl_proc_stop+0x1a>
        os_callout_stop(&connsm->ctrl_proc_rsp_timer.cf_c);
    e562:	30c0      	adds	r0, #192	; 0xc0
    e564:	f7fb faae 	bl	9ac4 <os_callout_stop>
        connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
    e568:	23ff      	movs	r3, #255	; 0xff
    e56a:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
    }
    CLR_PENDING_CTRL_PROC(connsm, ctrl_proc);
    e56e:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
    e570:	2301      	movs	r3, #1
    e572:	40ab      	lsls	r3, r5
    e574:	ea22 0303 	bic.w	r3, r2, r3
    e578:	87a3      	strh	r3, [r4, #60]	; 0x3c

    /* If there are others, start them */
    ble_ll_ctrl_chk_proc_start(connsm);
    e57a:	4620      	mov	r0, r4
}
    e57c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
    }
    CLR_PENDING_CTRL_PROC(connsm, ctrl_proc);

    /* If there are others, start them */
    ble_ll_ctrl_chk_proc_start(connsm);
    e580:	f7ff bfbe 	b.w	e500 <ble_ll_ctrl_chk_proc_start>

0000e584 <ble_ll_ctrl_rx_pdu>:
 * @param om
 * @param connsm
 */
int
ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
{
    e584:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    /*
     * dptr points to om_data pointer. The first byte of om_data is the
     * first byte of the Data Channel PDU header. Get length from header and
     * opcode from LL control PDU.
     */
    dptr = om->om_data;
    e588:	680d      	ldr	r5, [r1, #0]
    len = dptr[1];
    e58a:	786b      	ldrb	r3, [r5, #1]
    opcode = dptr[2];
    e58c:	78af      	ldrb	r7, [r5, #2]
    /*
     * Subtract the opcode from the length. Note that if the length was zero,
     * which would be an error, we will fail the check against the length
     * of the control packet.
     */
    --len;
    e58e:	3b01      	subs	r3, #1

    ble_ll_log(BLE_LL_LOG_ID_LL_CTRL_RX, opcode, len, 0);

    /* opcode must be good */
    if ((opcode >= BLE_LL_CTRL_OPCODES) ||
    e590:	2f15      	cmp	r7, #21
 * @param om
 * @param connsm
 */
int
ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
{
    e592:	4604      	mov	r4, r0
    e594:	4688      	mov	r8, r1
     */
    rspbuf = dptr;
    rspdata = rspbuf + 1;

    /* Move data pointer to start of control data (2 byte PDU hdr + opcode) */
    dptr += (BLE_LL_PDU_HDR_LEN + 1);
    e596:	f105 0b03 	add.w	fp, r5, #3
    /*
     * Subtract the opcode from the length. Note that if the length was zero,
     * which would be an error, we will fail the check against the length
     * of the control packet.
     */
    --len;
    e59a:	b2db      	uxtb	r3, r3

    ble_ll_log(BLE_LL_LOG_ID_LL_CTRL_RX, opcode, len, 0);

    /* opcode must be good */
    if ((opcode >= BLE_LL_CTRL_OPCODES) ||
    e59c:	f200 8252 	bhi.w	ea44 <ble_ll_ctrl_rx_pdu+0x4c0>
        (len != g_ble_ll_ctrl_pkt_lengths[opcode])) {
    e5a0:	4ac9      	ldr	r2, [pc, #804]	; (e8c8 <ble_ll_ctrl_rx_pdu+0x344>)
    --len;

    ble_ll_log(BLE_LL_LOG_ID_LL_CTRL_RX, opcode, len, 0);

    /* opcode must be good */
    if ((opcode >= BLE_LL_CTRL_OPCODES) ||
    e5a2:	5dd1      	ldrb	r1, [r2, r7]
    e5a4:	4299      	cmp	r1, r3
    e5a6:	4691      	mov	r9, r2
    e5a8:	f040 824c 	bne.w	ea44 <ble_ll_ctrl_rx_pdu+0x4c0>
    e5ac:	1efb      	subs	r3, r7, #3
    e5ae:	b2db      	uxtb	r3, r3
    e5b0:	2b11      	cmp	r3, #17
    e5b2:	d81a      	bhi.n	e5ea <ble_ll_ctrl_rx_pdu+0x66>
    e5b4:	4ac5      	ldr	r2, [pc, #788]	; (e8cc <ble_ll_ctrl_rx_pdu+0x348>)
    e5b6:	5cd6      	ldrb	r6, [r2, r3]
    default:
        feature = 0;
        break;
    }

    if (feature) {
    e5b8:	b1be      	cbz	r6, e5ea <ble_ll_ctrl_rx_pdu+0x66>
        features = ble_ll_read_supp_features();
    e5ba:	f7fc fdab 	bl	b114 <ble_ll_read_supp_features>
        if ((features & feature) == 0) {
    e5be:	ea10 0a06 	ands.w	sl, r0, r6
    e5c2:	d112      	bne.n	e5ea <ble_ll_ctrl_rx_pdu+0x66>
            if (opcode == BLE_LL_CTRL_ENC_REQ) {
    e5c4:	2f03      	cmp	r7, #3
    e5c6:	f040 8244 	bne.w	ea52 <ble_ll_ctrl_rx_pdu+0x4ce>
                if (connsm->common_features & BLE_LL_FEAT_EXTENDED_REJ) {
    e5ca:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    e5ce:	f003 0304 	and.w	r3, r3, #4
    e5d2:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    e5d6:	221a      	movs	r2, #26
    e5d8:	b11b      	cbz	r3, e5e2 <ble_ll_ctrl_rx_pdu+0x5e>
                    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
                    rspbuf[1] = opcode;
    e5da:	706f      	strb	r7, [r5, #1]
                    rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
    e5dc:	70aa      	strb	r2, [r5, #2]
    if (feature) {
        features = ble_ll_read_supp_features();
        if ((features & feature) == 0) {
            if (opcode == BLE_LL_CTRL_ENC_REQ) {
                if (connsm->common_features & BLE_LL_FEAT_EXTENDED_REJ) {
                    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
    e5de:	2611      	movs	r6, #17
    e5e0:	e219      	b.n	ea16 <ble_ll_ctrl_rx_pdu+0x492>
                    rspbuf[1] = opcode;
                    rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;

                } else {
                    rsp_opcode = BLE_LL_CTRL_REJECT_IND;
                    rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
    e5e2:	706a      	strb	r2, [r5, #1]
        (len != g_ble_ll_ctrl_pkt_lengths[opcode])) {
        goto rx_malformed_ctrl;
    }

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    restart_encryption = 0;
    e5e4:	4682      	mov	sl, r0
                    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
                    rspbuf[1] = opcode;
                    rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;

                } else {
                    rsp_opcode = BLE_LL_CTRL_REJECT_IND;
    e5e6:	260d      	movs	r6, #13
    e5e8:	e215      	b.n	ea16 <ble_ll_ctrl_rx_pdu+0x492>
        }
    }

    /* Process opcode */
    rsp_opcode = BLE_ERR_MAX;
    switch (opcode) {
    e5ea:	2f15      	cmp	r7, #21
    e5ec:	f200 820d 	bhi.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
    e5f0:	e8df f017 	tbh	[pc, r7, lsl #1]
    e5f4:	004a0016 	.word	0x004a0016
    e5f8:	0114020b 	.word	0x0114020b
    e5fc:	016e014f 	.word	0x016e014f
    e600:	008f017c 	.word	0x008f017c
    e604:	00c800c3 	.word	0x00c800c3
    e608:	01a30196 	.word	0x01a30196
    e60c:	01ea00d8 	.word	0x01ea00d8
    e610:	01ac010d 	.word	0x01ac010d
    e614:	01ea01d3 	.word	0x01ea01d3
    e618:	01a90231 	.word	0x01a90231
    e61c:	00800067 	.word	0x00800067
    uint8_t rsp_opcode;
    uint16_t conn_events;
    struct ble_ll_conn_upd_req *reqdata;

    /* Only a slave should receive this */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    e620:	79e3      	ldrb	r3, [r4, #7]
    e622:	2b01      	cmp	r3, #1
    e624:	f000 81f1 	beq.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        return BLE_ERR_MAX;
    }

    /* Retrieve parameters */
    reqdata = &connsm->conn_update_req;
    reqdata->winsize = dptr[0];
    e628:	78eb      	ldrb	r3, [r5, #3]
    e62a:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
    reqdata->winoffset = le16toh(dptr + 1);
    e62e:	1d28      	adds	r0, r5, #4
    e630:	f00e fd2d 	bl	1d08e <le16toh>
    e634:	f8a4 0178 	strh.w	r0, [r4, #376]	; 0x178
    reqdata->interval = le16toh(dptr + 3);
    e638:	1da8      	adds	r0, r5, #6
    e63a:	f00e fd28 	bl	1d08e <le16toh>
    e63e:	f8a4 017a 	strh.w	r0, [r4, #378]	; 0x17a
    reqdata->latency = le16toh(dptr + 5);
    e642:	f105 0008 	add.w	r0, r5, #8
    e646:	f00e fd22 	bl	1d08e <le16toh>
    e64a:	f8a4 017c 	strh.w	r0, [r4, #380]	; 0x17c
    reqdata->timeout = le16toh(dptr + 7);
    e64e:	f105 000a 	add.w	r0, r5, #10
    e652:	f00e fd1c 	bl	1d08e <le16toh>
    e656:	f8a4 017e 	strh.w	r0, [r4, #382]	; 0x17e
    reqdata->instant = le16toh(dptr + 9);
    e65a:	f105 000c 	add.w	r0, r5, #12
    e65e:	f00e fd16 	bl	1d08e <le16toh>

    /* XXX: validate them at some point. If they dont check out, we
       return the unknown response */

    /* If instant is in the past, we have to end the connection */
    conn_events = (reqdata->instant - connsm->event_cntr) & 0xFFFF;
    e662:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    reqdata->winsize = dptr[0];
    reqdata->winoffset = le16toh(dptr + 1);
    reqdata->interval = le16toh(dptr + 3);
    reqdata->latency = le16toh(dptr + 5);
    reqdata->timeout = le16toh(dptr + 7);
    reqdata->instant = le16toh(dptr + 9);
    e664:	f8a4 0180 	strh.w	r0, [r4, #384]	; 0x180

    /* XXX: validate them at some point. If they dont check out, we
       return the unknown response */

    /* If instant is in the past, we have to end the connection */
    conn_events = (reqdata->instant - connsm->event_cntr) & 0xFFFF;
    e668:	1ac0      	subs	r0, r0, r3
    if (conn_events >= 32767) {
    e66a:	b280      	uxth	r0, r0
    e66c:	f647 73fe 	movw	r3, #32766	; 0x7ffe
    e670:	4298      	cmp	r0, r3
    e672:	d904      	bls.n	e67e <ble_ll_ctrl_rx_pdu+0xfa>
        ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
    e674:	4620      	mov	r0, r4
    e676:	2128      	movs	r1, #40	; 0x28
    e678:	f7fe fb0e 	bl	cc98 <ble_ll_conn_timeout>
    e67c:	e1c5      	b.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        rsp_opcode = BLE_ERR_MAX;
    } else {
        connsm->csmflags.cfbit.conn_update_sched = 1;
    e67e:	7823      	ldrb	r3, [r4, #0]
    e680:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    e684:	7023      	strb	r3, [r4, #0]
    e686:	e1c0      	b.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
{
    uint16_t instant;
    uint16_t conn_events;

    /* If instant is in the past, we have to end the connection */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    e688:	79e3      	ldrb	r3, [r4, #7]
    e68a:	2b02      	cmp	r3, #2
    e68c:	f040 81bd 	bne.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        instant = le16toh(dptr + BLE_LL_CONN_CHMAP_LEN);
    e690:	f105 0008 	add.w	r0, r5, #8
    e694:	f00e fcfb 	bl	1d08e <le16toh>
        conn_events = (instant - connsm->event_cntr) & 0xFFFF;
    e698:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    e69a:	1ac3      	subs	r3, r0, r3
        if (conn_events >= 32767) {
    e69c:	b29b      	uxth	r3, r3
    e69e:	f647 72fe 	movw	r2, #32766	; 0x7ffe
    e6a2:	4293      	cmp	r3, r2
    e6a4:	d8e6      	bhi.n	e674 <ble_ll_ctrl_rx_pdu+0xf0>
            ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
        } else {
            connsm->chanmap_instant = instant;
    e6a6:	84a0      	strh	r0, [r4, #36]	; 0x24
            memcpy(connsm->req_chanmap, dptr, BLE_LL_CONN_CHMAP_LEN);
    e6a8:	f8db 3000 	ldr.w	r3, [fp]
    e6ac:	f8c4 301f 	str.w	r3, [r4, #31]
    e6b0:	f89b 3004 	ldrb.w	r3, [fp, #4]
    e6b4:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
            connsm->csmflags.cfbit.chanmap_update_scheduled = 1;
    e6b8:	7863      	ldrb	r3, [r4, #1]
    e6ba:	f043 0308 	orr.w	r3, r3, #8
    e6be:	7063      	strb	r3, [r4, #1]
    e6c0:	e1a3      	b.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
    case BLE_LL_CTRL_CHANNEL_MAP_REQ:
        ble_ll_ctrl_rx_chanmap_req(connsm, dptr);
        break;
    case BLE_LL_CTRL_LENGTH_REQ:
        /* Extract parameters and check if valid */
        if (ble_ll_ctrl_len_proc(connsm, dptr)) {
    e6c2:	4620      	mov	r0, r4
    e6c4:	4659      	mov	r1, fp
    e6c6:	f7ff fd71 	bl	e1ac <ble_ll_ctrl_len_proc>
    e6ca:	2800      	cmp	r0, #0
    e6cc:	f040 81ba 	bne.w	ea44 <ble_ll_ctrl_rx_pdu+0x4c0>

        /*
         * If we have not started this procedure ourselves and it is
         * pending, no need to perform it.
         */
        if ((connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_DATA_LEN_UPD) &&
    e6d0:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    e6d4:	2b08      	cmp	r3, #8
    e6d6:	d005      	beq.n	e6e4 <ble_ll_ctrl_rx_pdu+0x160>
            IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD)) {
    e6d8:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c

        /*
         * If we have not started this procedure ourselves and it is
         * pending, no need to perform it.
         */
        if ((connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_DATA_LEN_UPD) &&
    e6da:	05da      	lsls	r2, r3, #23
            IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD)) {
            CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
    e6dc:	bf44      	itt	mi
    e6de:	f423 7380 	bicmi.w	r3, r3, #256	; 0x100
    e6e2:	87a3      	strhmi	r3, [r4, #60]	; 0x3c
        }

        /* Send a response */
        rsp_opcode = BLE_LL_CTRL_LENGTH_RSP;
        ble_ll_ctrl_datalen_upd_make(connsm, rspbuf);
    e6e4:	4620      	mov	r0, r4
    e6e6:	4629      	mov	r1, r5
    e6e8:	f7ff fc38 	bl	df5c <ble_ll_ctrl_datalen_upd_make>
        (len != g_ble_ll_ctrl_pkt_lengths[opcode])) {
        goto rx_malformed_ctrl;
    }

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    restart_encryption = 0;
    e6ec:	f04f 0a00 	mov.w	sl, #0
            IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD)) {
            CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
        }

        /* Send a response */
        rsp_opcode = BLE_LL_CTRL_LENGTH_RSP;
    e6f0:	2615      	movs	r6, #21
        ble_ll_ctrl_datalen_upd_make(connsm, rspbuf);
        break;
    e6f2:	e190      	b.n	ea16 <ble_ll_ctrl_rx_pdu+0x492>
    case BLE_LL_CTRL_LENGTH_RSP:
        /* According to specification, process this only if we asked for it. */
        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_DATA_LEN_UPD) {
    e6f4:	f894 5036 	ldrb.w	r5, [r4, #54]	; 0x36
    e6f8:	2d08      	cmp	r5, #8
    e6fa:	f040 8186 	bne.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
            /* Process the received data */
            if (ble_ll_ctrl_len_proc(connsm, dptr)) {
    e6fe:	4620      	mov	r0, r4
    e700:	4659      	mov	r1, fp
    e702:	f7ff fd53 	bl	e1ac <ble_ll_ctrl_len_proc>
    e706:	2800      	cmp	r0, #0
    e708:	f040 819c 	bne.w	ea44 <ble_ll_ctrl_rx_pdu+0x4c0>
                goto rx_malformed_ctrl;
            }

            /* Stop the control procedure */
            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
    e70c:	4620      	mov	r0, r4
    e70e:	4629      	mov	r1, r5
    e710:	e045      	b.n	e79e <ble_ll_ctrl_rx_pdu+0x21a>

    /* Get opcode of unknown LL control frame */
    opcode = dptr[0];

    /* Convert opcode to control procedure id */
    switch (opcode) {
    e712:	78ed      	ldrb	r5, [r5, #3]
    e714:	2d10      	cmp	r5, #16
    e716:	d806      	bhi.n	e726 <ble_ll_ctrl_rx_pdu+0x1a2>
    e718:	2d0f      	cmp	r5, #15
    e71a:	d209      	bcs.n	e730 <ble_ll_ctrl_rx_pdu+0x1ac>
    e71c:	b1bd      	cbz	r5, e74e <ble_ll_ctrl_rx_pdu+0x1ca>
    e71e:	2d0e      	cmp	r5, #14
    e720:	d112      	bne.n	e748 <ble_ll_ctrl_rx_pdu+0x1c4>
        break;
    case BLE_LL_CTRL_CONN_UPDATE_REQ:
        ctrl_proc = BLE_LL_CTRL_PROC_CONN_UPDATE;
        break;
    case BLE_LL_CTRL_SLAVE_FEATURE_REQ:
        ctrl_proc = BLE_LL_CTRL_PROC_FEATURE_XCHG;
    e722:	2503      	movs	r5, #3
    e724:	e013      	b.n	e74e <ble_ll_ctrl_rx_pdu+0x1ca>

    /* Get opcode of unknown LL control frame */
    opcode = dptr[0];

    /* Convert opcode to control procedure id */
    switch (opcode) {
    e726:	2d12      	cmp	r5, #18
    e728:	d004      	beq.n	e734 <ble_ll_ctrl_rx_pdu+0x1b0>
    e72a:	2d14      	cmp	r5, #20
    e72c:	d00e      	beq.n	e74c <ble_ll_ctrl_rx_pdu+0x1c8>
    e72e:	e00b      	b.n	e748 <ble_ll_ctrl_rx_pdu+0x1c4>
    case BLE_LL_CTRL_SLAVE_FEATURE_REQ:
        ctrl_proc = BLE_LL_CTRL_PROC_FEATURE_XCHG;
        break;
    case BLE_LL_CTRL_CONN_PARM_RSP:
    case BLE_LL_CTRL_CONN_PARM_REQ:
        ctrl_proc = BLE_LL_CTRL_PROC_CONN_PARAM_REQ;
    e730:	2506      	movs	r5, #6
    e732:	e00c      	b.n	e74e <ble_ll_ctrl_rx_pdu+0x1ca>
        break;
    case BLE_LL_CTRL_PING_REQ:
        CONN_F_LE_PING_SUPP(connsm) = 0;
    e734:	78a3      	ldrb	r3, [r4, #2]
    e736:	f36f 0382 	bfc	r3, #2, #1
    e73a:	70a3      	strb	r3, [r4, #2]
#if (BLE_LL_CFG_FEAT_LE_PING == 1)
        os_callout_stop(&connsm->auth_pyld_timer.cf_c);
    e73c:	f104 00fc 	add.w	r0, r4, #252	; 0xfc
    e740:	f7fb f9c0 	bl	9ac4 <os_callout_stop>
#endif
        ctrl_proc = BLE_LL_CTRL_PROC_LE_PING;
    e744:	2507      	movs	r5, #7
    e746:	e002      	b.n	e74e <ble_ll_ctrl_rx_pdu+0x1ca>
        break;
    default:
        ctrl_proc = BLE_LL_CTRL_PROC_NUM;
    e748:	2509      	movs	r5, #9
    e74a:	e000      	b.n	e74e <ble_ll_ctrl_rx_pdu+0x1ca>
    opcode = dptr[0];

    /* Convert opcode to control procedure id */
    switch (opcode) {
    case BLE_LL_CTRL_LENGTH_REQ:
        ctrl_proc = BLE_LL_CTRL_PROC_DATA_LEN_UPD;
    e74c:	2508      	movs	r5, #8
        ctrl_proc = BLE_LL_CTRL_PROC_NUM;
        break;
    }

    /* If we are running this one currently, stop it */
    if (connsm->cur_ctrl_proc == ctrl_proc) {
    e74e:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    e752:	42ab      	cmp	r3, r5
    e754:	f040 8159 	bne.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        /* Stop the control procedure */
        ble_ll_ctrl_proc_stop(connsm, ctrl_proc);
    e758:	4620      	mov	r0, r4
    e75a:	4629      	mov	r1, r5
    e75c:	f7ff fefa 	bl	e554 <ble_ll_ctrl_proc_stop>
        if (ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
    e760:	2d06      	cmp	r5, #6
    e762:	d102      	bne.n	e76a <ble_ll_ctrl_rx_pdu+0x1e6>
            ble_ll_hci_ev_conn_update(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
    e764:	4620      	mov	r0, r4
    e766:	211a      	movs	r1, #26
    e768:	e13f      	b.n	e9ea <ble_ll_ctrl_rx_pdu+0x466>
        } else if (ctrl_proc == BLE_LL_CTRL_PROC_FEATURE_XCHG) {
    e76a:	2d03      	cmp	r5, #3
    e76c:	f040 814d 	bne.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
            ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
    e770:	4620      	mov	r0, r4
    e772:	211a      	movs	r1, #26
    e774:	f000 fe0c 	bl	f390 <ble_ll_hci_ev_rd_rem_used_feat>
    e778:	e147      	b.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        break;
    case BLE_LL_CTRL_UNKNOWN_RSP:
        ble_ll_ctrl_proc_unk_rsp(connsm, dptr);
        break;
    case BLE_LL_CTRL_FEATURE_REQ:
        rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
    e77a:	4620      	mov	r0, r4
    e77c:	4659      	mov	r1, fp
    e77e:	462a      	mov	r2, r5
    e780:	2308      	movs	r3, #8
    e782:	e048      	b.n	e816 <ble_ll_ctrl_rx_pdu+0x292>
        break;
    /* XXX: check to see if ctrl procedure was running? Do we care? */
    case BLE_LL_CTRL_FEATURE_RSP:
        /* Stop the control procedure */
        connsm->common_features = dptr[0];
    e784:	78eb      	ldrb	r3, [r5, #3]
    e786:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG)) {
    e78a:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    e78c:	071b      	lsls	r3, r3, #28
    e78e:	f140 813c 	bpl.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
            ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_SUCCESS);
    e792:	4620      	mov	r0, r4
    e794:	2100      	movs	r1, #0
    e796:	f000 fdfb 	bl	f390 <ble_ll_hci_ev_rd_rem_used_feat>
            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);
    e79a:	4620      	mov	r0, r4
    e79c:	2103      	movs	r1, #3
    e79e:	f7ff fed9 	bl	e554 <ble_ll_ctrl_proc_stop>
    e7a2:	e132      	b.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
                           uint8_t *rspbuf)
{
    uint8_t rsp_opcode;

    /* Process the packet */
    connsm->vers_nr = dptr[0];
    e7a4:	78eb      	ldrb	r3, [r5, #3]
    e7a6:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
    connsm->comp_id = le16toh(dptr + 1);
    e7aa:	1d2e      	adds	r6, r5, #4
    e7ac:	4630      	mov	r0, r6
    e7ae:	f00e fc6e 	bl	1d08e <le16toh>
    e7b2:	f8a4 0042 	strh.w	r0, [r4, #66]	; 0x42
    connsm->sub_vers_nr = le16toh(dptr + 3);
    e7b6:	1da8      	adds	r0, r5, #6
    e7b8:	f00e fc69 	bl	1d08e <le16toh>
    connsm->csmflags.cfbit.rxd_version_ind = 1;
    e7bc:	7863      	ldrb	r3, [r4, #1]
    uint8_t rsp_opcode;

    /* Process the packet */
    connsm->vers_nr = dptr[0];
    connsm->comp_id = le16toh(dptr + 1);
    connsm->sub_vers_nr = le16toh(dptr + 3);
    e7be:	f8a4 0044 	strh.w	r0, [r4, #68]	; 0x44
    connsm->csmflags.cfbit.rxd_version_ind = 1;
    e7c2:	f043 0304 	orr.w	r3, r3, #4

    rsp_opcode = BLE_ERR_MAX;
    if (!connsm->csmflags.cfbit.version_ind_sent) {
    e7c6:	f003 0202 	and.w	r2, r3, #2

    /* Process the packet */
    connsm->vers_nr = dptr[0];
    connsm->comp_id = le16toh(dptr + 1);
    connsm->sub_vers_nr = le16toh(dptr + 3);
    connsm->csmflags.cfbit.rxd_version_ind = 1;
    e7ca:	7063      	strb	r3, [r4, #1]

    rsp_opcode = BLE_ERR_MAX;
    if (!connsm->csmflags.cfbit.version_ind_sent) {
    e7cc:	f002 07ff 	and.w	r7, r2, #255	; 0xff
    e7d0:	b97a      	cbnz	r2, e7f2 <ble_ll_ctrl_rx_pdu+0x26e>

static void
ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
{
    /* Set flag to denote we have sent/received this */
    connsm->csmflags.cfbit.version_ind_sent = 1;
    e7d2:	f043 0302 	orr.w	r3, r3, #2
    e7d6:	7063      	strb	r3, [r4, #1]

    /* Fill out response */
    pyld[0] = BLE_HCI_VER_BCS_4_2;
    e7d8:	2308      	movs	r3, #8
    e7da:	706b      	strb	r3, [r5, #1]
    htole16(pyld + 1, NIMBLE_OPT_LL_MFRG_ID);
    e7dc:	1ca8      	adds	r0, r5, #2
    e7de:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e7e2:	f00e fc39 	bl	1d058 <htole16>
    htole16(pyld + 3, BLE_LL_SUB_VERS_NR);
    e7e6:	4630      	mov	r0, r6
    e7e8:	4639      	mov	r1, r7
    e7ea:	f00e fc35 	bl	1d058 <htole16>
    connsm->sub_vers_nr = le16toh(dptr + 3);
    connsm->csmflags.cfbit.rxd_version_ind = 1;

    rsp_opcode = BLE_ERR_MAX;
    if (!connsm->csmflags.cfbit.version_ind_sent) {
        rsp_opcode = BLE_LL_CTRL_VERSION_IND;
    e7ee:	260c      	movs	r6, #12
    e7f0:	e000      	b.n	e7f4 <ble_ll_ctrl_rx_pdu+0x270>
    connsm->vers_nr = dptr[0];
    connsm->comp_id = le16toh(dptr + 1);
    connsm->sub_vers_nr = le16toh(dptr + 3);
    connsm->csmflags.cfbit.rxd_version_ind = 1;

    rsp_opcode = BLE_ERR_MAX;
    e7f2:	26ff      	movs	r6, #255	; 0xff
        rsp_opcode = BLE_LL_CTRL_VERSION_IND;
        ble_ll_ctrl_version_ind_make(connsm, rspbuf);
    }

    /* Stop the control procedure */
    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG)) {
    e7f4:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    e7f6:	06df      	lsls	r7, r3, #27
    e7f8:	f140 8133 	bpl.w	ea62 <ble_ll_ctrl_rx_pdu+0x4de>
        ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
    e7fc:	4620      	mov	r0, r4
    e7fe:	2100      	movs	r1, #0
    e800:	f000 fdee 	bl	f3e0 <ble_ll_hci_ev_rd_rem_ver>
        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG);
    e804:	4620      	mov	r0, r4
    e806:	2104      	movs	r1, #4
    e808:	f7ff fea4 	bl	e554 <ble_ll_ctrl_proc_stop>
            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);
        }
        break;
    case BLE_LL_CTRL_VERSION_IND:
        rsp_opcode = ble_ll_ctrl_rx_version_ind(connsm, dptr, rspdata);
        break;
    e80c:	e129      	b.n	ea62 <ble_ll_ctrl_rx_pdu+0x4de>
    case BLE_LL_CTRL_SLAVE_FEATURE_REQ:
        rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
    e80e:	4620      	mov	r0, r4
    e810:	4659      	mov	r1, fp
    e812:	462a      	mov	r2, r5
    e814:	230e      	movs	r3, #14
    e816:	f7ff fd02 	bl	e21e <ble_ll_ctrl_rx_feature_req>
    e81a:	e0d3      	b.n	e9c4 <ble_ll_ctrl_rx_pdu+0x440>
 */
static uint8_t
ble_ll_ctrl_rx_enc_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                       uint8_t *rspdata)
{
    if (connsm->conn_role != BLE_LL_CONN_ROLE_SLAVE) {
    e81c:	79e3      	ldrb	r3, [r4, #7]
    e81e:	2b02      	cmp	r3, #2
    e820:	f040 80f3 	bne.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        return BLE_ERR_MAX;
    }

    /* In case we were already encrypted we need to reset packet counters */
    connsm->enc_data.rx_pkt_cntr = 0;
    e824:	f04f 0a00 	mov.w	sl, #0
    e828:	f8a4 a126 	strh.w	sl, [r4, #294]	; 0x126
    connsm->enc_data.tx_pkt_cntr = 0;
    e82c:	f8a4 a124 	strh.w	sl, [r4, #292]	; 0x124
    connsm->enc_data.tx_encrypted = 0;
    e830:	f884 a121 	strb.w	sl, [r4, #289]	; 0x121

    /* Extract information from request */
    connsm->enc_data.host_rand_num = le64toh(dptr);
    e834:	4658      	mov	r0, fp
    e836:	f00e fc3a 	bl	1d0ae <le64toh>
    e83a:	f504 7394 	add.w	r3, r4, #296	; 0x128
    e83e:	e9c3 0100 	strd	r0, r1, [r3]
    connsm->enc_data.enc_div = le16toh(dptr + 8);
    e842:	f105 000b 	add.w	r0, r5, #11
    e846:	f00e fc22 	bl	1d08e <le16toh>
    htole32(rspdata + 8, g_bletest_IVs);
    memcpy(connsm->enc_data.iv + 4, rspdata + 8, 4);
    return BLE_LL_CTRL_ENC_RSP;
#endif

    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
    e84a:	2208      	movs	r2, #8
    connsm->enc_data.tx_pkt_cntr = 0;
    connsm->enc_data.tx_encrypted = 0;

    /* Extract information from request */
    connsm->enc_data.host_rand_num = le64toh(dptr);
    connsm->enc_data.enc_div = le16toh(dptr + 8);
    e84c:	f8a4 0122 	strh.w	r0, [r4, #290]	; 0x122
    htole32(rspdata + 8, g_bletest_IVs);
    memcpy(connsm->enc_data.iv + 4, rspdata + 8, 4);
    return BLE_LL_CTRL_ENC_RSP;
#endif

    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
    e850:	f105 010d 	add.w	r1, r5, #13
    e854:	f504 70a8 	add.w	r0, r4, #336	; 0x150
    e858:	f00e fc62 	bl	1d120 <swap_buf>
    memcpy(connsm->enc_data.iv, dptr + 18, 4);

    /* Create the ENC_RSP. Concatenate our SKD and IV */
    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text, 8);
    e85c:	f504 76a4 	add.w	r6, r4, #328	; 0x148
    memcpy(connsm->enc_data.iv + 4, rspdata + 8, 4);
    return BLE_LL_CTRL_ENC_RSP;
#endif

    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
    memcpy(connsm->enc_data.iv, dptr + 18, 4);
    e860:	f8d5 3015 	ldr.w	r3, [r5, #21]
    e864:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130

    /* Create the ENC_RSP. Concatenate our SKD and IV */
    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text, 8);
    e868:	4630      	mov	r0, r6
    e86a:	2108      	movs	r1, #8
    e86c:	f000 fe06 	bl	f47c <ble_ll_rand_data_get>
    swap_buf(rspdata, connsm->enc_data.enc_block.plain_text, 8);
    e870:	4631      	mov	r1, r6
    e872:	1c68      	adds	r0, r5, #1
    e874:	2208      	movs	r2, #8
    ble_ll_rand_data_get(connsm->enc_data.iv + 4, 4);
    e876:	f504 769a 	add.w	r6, r4, #308	; 0x134
    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
    memcpy(connsm->enc_data.iv, dptr + 18, 4);

    /* Create the ENC_RSP. Concatenate our SKD and IV */
    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text, 8);
    swap_buf(rspdata, connsm->enc_data.enc_block.plain_text, 8);
    e87a:	f00e fc51 	bl	1d120 <swap_buf>
    ble_ll_rand_data_get(connsm->enc_data.iv + 4, 4);
    e87e:	4630      	mov	r0, r6
    e880:	2104      	movs	r1, #4
    e882:	f000 fdfb 	bl	f47c <ble_ll_rand_data_get>
    memcpy(rspdata + 8, connsm->enc_data.iv + 4, 4);
    e886:	f8d4 3134 	ldr.w	r3, [r4, #308]	; 0x134
    e88a:	f8c5 3009 	str.w	r3, [r5, #9]

    return BLE_LL_CTRL_ENC_RSP;
    e88e:	2604      	movs	r6, #4
    e890:	e0c1      	b.n	ea16 <ble_ll_ctrl_rx_pdu+0x492>
 */
static void
ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
{
    /* Calculate session key now that we have received the ENC_RSP */
    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
    e892:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    e896:	2b02      	cmp	r3, #2
    e898:	f040 80b7 	bne.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        /* In case we were already encrypted we need to reset packet counters */
        connsm->enc_data.rx_pkt_cntr = 0;
    e89c:	2300      	movs	r3, #0
    e89e:	f8a4 3126 	strh.w	r3, [r4, #294]	; 0x126
        connsm->enc_data.tx_pkt_cntr = 0;
    e8a2:	f8a4 3124 	strh.w	r3, [r4, #292]	; 0x124
        connsm->enc_data.tx_encrypted = 0;
    e8a6:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121

        swap_buf(connsm->enc_data.enc_block.plain_text, dptr, 8);
    e8aa:	f504 70a4 	add.w	r0, r4, #328	; 0x148
    e8ae:	4659      	mov	r1, fp
    e8b0:	2208      	movs	r2, #8
    e8b2:	f00e fc35 	bl	1d120 <swap_buf>
        memcpy(connsm->enc_data.iv + 4, dptr + 8, 4);
    e8b6:	f8d5 300b 	ldr.w	r3, [r5, #11]
    e8ba:	f8c4 3134 	str.w	r3, [r4, #308]	; 0x134
        ble_ll_calc_session_key(connsm);
    e8be:	4620      	mov	r0, r4
    e8c0:	f7ff fcc9 	bl	e256 <ble_ll_calc_session_key>
        connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_REQ_WAIT;
    e8c4:	2304      	movs	r3, #4
    e8c6:	e09b      	b.n	ea00 <ble_ll_ctrl_rx_pdu+0x47c>
    e8c8:	0001f29e 	.word	0x0001f29e
    e8cc:	0001f2b4 	.word	0x0001f2b4
{
    int rc;

    /* Only master should receive start enc request */
    rc = BLE_ERR_MAX;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    e8d0:	79e3      	ldrb	r3, [r4, #7]
    e8d2:	2b01      	cmp	r3, #1
    e8d4:	d108      	bne.n	e8e8 <ble_ll_ctrl_rx_pdu+0x364>
        /* We only want to send a START_ENC_RSP if we havent yet */
        if (connsm->enc_data.enc_state == CONN_ENC_S_START_ENC_REQ_WAIT) {
    e8d6:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
    e8da:	2b04      	cmp	r3, #4
    e8dc:	d104      	bne.n	e8e8 <ble_ll_ctrl_rx_pdu+0x364>
            connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
    e8de:	2305      	movs	r3, #5
    e8e0:	f884 3120 	strb.w	r3, [r4, #288]	; 0x120
            rc = BLE_LL_CTRL_START_ENC_RSP;
    e8e4:	2606      	movs	r6, #6
    e8e6:	e019      	b.n	e91c <ble_ll_ctrl_rx_pdu+0x398>
ble_ll_ctrl_rx_start_enc_req(struct ble_ll_conn_sm *connsm)
{
    int rc;

    /* Only master should receive start enc request */
    rc = BLE_ERR_MAX;
    e8e8:	26ff      	movs	r6, #255	; 0xff
    e8ea:	e017      	b.n	e91c <ble_ll_ctrl_rx_pdu+0x398>
ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm *connsm)
{
    int rc;

    /* Not in proper state. Discard */
    if (connsm->enc_data.enc_state != CONN_ENC_S_START_ENC_RSP_WAIT) {
    e8ec:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
    e8f0:	2b05      	cmp	r3, #5
    e8f2:	f040 808a 	bne.w	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        return BLE_ERR_MAX;
    }

    /* If master, we are done. Stop control procedure and sent event to host */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    e8f6:	79e3      	ldrb	r3, [r4, #7]
    e8f8:	2b01      	cmp	r3, #1
    e8fa:	d10a      	bne.n	e912 <ble_ll_ctrl_rx_pdu+0x38e>
        /* We are encrypted */
        connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
    e8fc:	2102      	movs	r1, #2
    e8fe:	f884 1120 	strb.w	r1, [r4, #288]	; 0x120
        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
    e902:	4620      	mov	r0, r4
    e904:	f7ff fe26 	bl	e554 <ble_ll_ctrl_proc_stop>
#if (BLE_LL_CFG_FEAT_LE_PING == 1)
        ble_ll_conn_auth_pyld_timer_start(connsm);
    e908:	4620      	mov	r0, r4
    e90a:	f7fd fe01 	bl	c510 <ble_ll_conn_auth_pyld_timer_start>
#endif
        rc = BLE_ERR_MAX;
    e90e:	26ff      	movs	r6, #255	; 0xff
    e910:	e000      	b.n	e914 <ble_ll_ctrl_rx_pdu+0x390>
    } else {
        /* Procedure has completed but slave needs to send START_ENC_RSP */
        rc = BLE_LL_CTRL_START_ENC_RSP;
    e912:	2606      	movs	r6, #6
    /*
     * XXX: for now, a Slave sends this event when it receivest the
     * START_ENC_RSP from the master. It might be technically incorrect
     * to send it before we transmit our own START_ENC_RSP.
     */
    ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
    e914:	4620      	mov	r0, r4
    e916:	2100      	movs	r1, #0
    e918:	f000 fcda 	bl	f2d0 <ble_ll_hci_ev_encrypt_chg>

    return rc;
    e91c:	b2f6      	uxtb	r6, r6
    e91e:	e072      	b.n	ea06 <ble_ll_ctrl_rx_pdu+0x482>
     * The spec does not say what to do here, but if we receive a pause
     * encryption request and we are not encrypted, what do we do? We
     * ignore it...
     */
    rc = BLE_ERR_MAX;
    if ((connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) &&
    e920:	79e3      	ldrb	r3, [r4, #7]
    e922:	2b02      	cmp	r3, #2
    e924:	d106      	bne.n	e934 <ble_ll_ctrl_rx_pdu+0x3b0>
    e926:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
        (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED)) {
        rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
    e92a:	2b02      	cmp	r3, #2
    e92c:	bf14      	ite	ne
    e92e:	26ff      	movne	r6, #255	; 0xff
    e930:	260b      	moveq	r6, #11
    e932:	e000      	b.n	e936 <ble_ll_ctrl_rx_pdu+0x3b2>
    /*
     * The spec does not say what to do here, but if we receive a pause
     * encryption request and we are not encrypted, what do we do? We
     * ignore it...
     */
    rc = BLE_ERR_MAX;
    e934:	26ff      	movs	r6, #255	; 0xff
    if ((connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) &&
        (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED)) {
        rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
    }

    return rc;
    e936:	b2f6      	uxtb	r6, r6
    case BLE_LL_CTRL_START_ENC_RSP:
        rsp_opcode = ble_ll_ctrl_rx_start_enc_rsp(connsm);
        break;
    case BLE_LL_CTRL_PAUSE_ENC_REQ:
        rsp_opcode = ble_ll_ctrl_rx_pause_enc_req(connsm);
        break;
    e938:	e093      	b.n	ea62 <ble_ll_ctrl_rx_pdu+0x4de>
ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
{
    int rc;

    rc = BLE_ERR_MAX;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    e93a:	f894 a007 	ldrb.w	sl, [r4, #7]
    e93e:	f1ba 0f01 	cmp.w	sl, #1
    e942:	d162      	bne.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
    e944:	e08b      	b.n	ea5e <ble_ll_ctrl_rx_pdu+0x4da>
 */
static void
ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
{
    /* Stop the control procedure */
    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_LE_PING);
    e946:	4620      	mov	r0, r4
    e948:	2107      	movs	r1, #7
    e94a:	e728      	b.n	e79e <ble_ll_ctrl_rx_pdu+0x21a>
     * are awaiting a reply from the host, simply ignore the request. This
     * might not be a good idea if the parameters are different, but oh
     * well. This is not expected to happen anyway. A return of BLE_ERR_MAX
     * means that we will simply discard the connection parameter request
     */
    if (connsm->csmflags.cfbit.awaiting_host_reply) {
    e94c:	7823      	ldrb	r3, [r4, #0]
    e94e:	069e      	lsls	r6, r3, #26
    e950:	d426      	bmi.n	e9a0 <ble_ll_ctrl_rx_pdu+0x41c>
     * event (with error).
     *
     * If a master, we send reject with a
     * transaction collision error code.
     */
    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
    e952:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    e954:	0658      	lsls	r0, r3, #25
    e956:	d50f      	bpl.n	e978 <ble_ll_ctrl_rx_pdu+0x3f4>
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    e958:	79e3      	ldrb	r3, [r4, #7]
    e95a:	2b02      	cmp	r3, #2
    e95c:	d108      	bne.n	e970 <ble_ll_ctrl_rx_pdu+0x3ec>
            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
    e95e:	4620      	mov	r0, r4
    e960:	2106      	movs	r1, #6
    e962:	f7ff fdf7 	bl	e554 <ble_ll_ctrl_proc_stop>
            ble_ll_hci_ev_conn_update(connsm, BLE_ERR_LMP_COLLISION);
    e966:	4620      	mov	r0, r4
    e968:	2123      	movs	r1, #35	; 0x23
    e96a:	f000 fc81 	bl	f270 <ble_ll_hci_ev_conn_update>
    e96e:	e003      	b.n	e978 <ble_ll_ctrl_rx_pdu+0x3f4>
        } else {
            /* The master sends reject ind ext w/error code 0x23 */
            rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
            rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
    e970:	230f      	movs	r3, #15
    e972:	706b      	strb	r3, [r5, #1]
            rspbuf[2] = BLE_ERR_LMP_COLLISION;
    e974:	2323      	movs	r3, #35	; 0x23
    e976:	e008      	b.n	e98a <ble_ll_ctrl_rx_pdu+0x406>

    /*
     * If we are a master and we currently performing a channel map
     * update procedure we need to return an error
     */
    if ((connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) &&
    e978:	79e3      	ldrb	r3, [r4, #7]
    e97a:	2b01      	cmp	r3, #1
    e97c:	d108      	bne.n	e990 <ble_ll_ctrl_rx_pdu+0x40c>
    e97e:	7863      	ldrb	r3, [r4, #1]
    e980:	0719      	lsls	r1, r3, #28
    e982:	d505      	bpl.n	e990 <ble_ll_ctrl_rx_pdu+0x40c>
        (connsm->csmflags.cfbit.chanmap_update_scheduled)) {
        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
        rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
    e984:	230f      	movs	r3, #15
    e986:	706b      	strb	r3, [r5, #1]
        rspbuf[2] = BLE_ERR_DIFF_TRANS_COLL;
    e988:	232a      	movs	r3, #42	; 0x2a
    e98a:	70ab      	strb	r3, [r5, #2]
        return rsp_opcode;
    e98c:	2011      	movs	r0, #17
    e98e:	e019      	b.n	e9c4 <ble_ll_ctrl_rx_pdu+0x440>
    }

    /* Process the received connection parameter request */
    rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
    e990:	4620      	mov	r0, r4
    e992:	4659      	mov	r1, fp
    e994:	462a      	mov	r2, r5
    e996:	230f      	movs	r3, #15
    e998:	e011      	b.n	e9be <ble_ll_ctrl_rx_pdu+0x43a>
                              uint8_t *rspbuf)
{
    uint8_t rsp_opcode;

    /* A slave should never receive this response */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    e99a:	79e3      	ldrb	r3, [r4, #7]
    e99c:	2b02      	cmp	r3, #2
    e99e:	d101      	bne.n	e9a4 <ble_ll_ctrl_rx_pdu+0x420>
        return BLE_ERR_MAX;
    e9a0:	20ff      	movs	r0, #255	; 0xff
    e9a2:	e00f      	b.n	e9c4 <ble_ll_ctrl_rx_pdu+0x440>
     * This case should never happen! It means that the slave initiated a
     * procedure and the master initiated one as well. If we do get in this
     * state just clear the awaiting reply. The slave will hopefully stop its
     * procedure when we reply.
     */
    if (connsm->csmflags.cfbit.awaiting_host_reply) {
    e9a4:	7823      	ldrb	r3, [r4, #0]
    e9a6:	069a      	lsls	r2, r3, #26
        connsm->csmflags.cfbit.awaiting_host_reply = 0;
    e9a8:	bf44      	itt	mi
    e9aa:	f36f 1345 	bfcmi	r3, #5, #1
    e9ae:	7023      	strbmi	r3, [r4, #0]
    }

    /* If we receive a response and no procedure is pending, just leave */
    if (!IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
    e9b0:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    e9b2:	065b      	lsls	r3, r3, #25
    e9b4:	d5f4      	bpl.n	e9a0 <ble_ll_ctrl_rx_pdu+0x41c>
        return BLE_ERR_MAX;
    }

    /* Process the received connection parameter response */
    rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
    e9b6:	4620      	mov	r0, r4
    e9b8:	4659      	mov	r1, fp
    e9ba:	462a      	mov	r2, r5
    e9bc:	2310      	movs	r3, #16
    e9be:	f7ff fc9b 	bl	e2f8 <ble_ll_ctrl_conn_param_pdu_proc>
                                                 BLE_LL_CTRL_CONN_PARM_RSP);
    return rsp_opcode;
    e9c2:	b2c0      	uxtb	r0, r0
        break;
    case BLE_LL_CTRL_CONN_PARM_REQ:
        rsp_opcode = ble_ll_ctrl_rx_conn_param_req(connsm, dptr, rspbuf);
        break;
    case BLE_LL_CTRL_CONN_PARM_RSP:
        rsp_opcode = ble_ll_ctrl_rx_conn_param_rsp(connsm, dptr, rspbuf);
    e9c4:	b2c6      	uxtb	r6, r0
        break;
    e9c6:	e01e      	b.n	ea06 <ble_ll_ctrl_rx_pdu+0x482>
        ble_error = dptr[1];
    }

    /* XXX: should I check to make sure the rejected opcode is sane
       if we receive ind ext? */
    switch (connsm->cur_ctrl_proc) {
    e9c8:	f894 1036 	ldrb.w	r1, [r4, #54]	; 0x36
                          uint8_t opcode)
{
    uint8_t ble_error;

    /* Get error out of received PDU */
    if (opcode == BLE_LL_CTRL_REJECT_IND) {
    e9cc:	2f0d      	cmp	r7, #13
        ble_error = dptr[0];
    e9ce:	bf0c      	ite	eq
    e9d0:	78ed      	ldrbeq	r5, [r5, #3]
    } else {
        ble_error = dptr[1];
    e9d2:	792d      	ldrbne	r5, [r5, #4]
    }

    /* XXX: should I check to make sure the rejected opcode is sane
       if we receive ind ext? */
    switch (connsm->cur_ctrl_proc) {
    e9d4:	2902      	cmp	r1, #2
    e9d6:	d00b      	beq.n	e9f0 <ble_ll_ctrl_rx_pdu+0x46c>
    e9d8:	2906      	cmp	r1, #6
    e9da:	d116      	bne.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
    case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
        if (opcode == BLE_LL_CTRL_REJECT_IND_EXT) {
    e9dc:	2f11      	cmp	r7, #17
    e9de:	d114      	bne.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
    e9e0:	4620      	mov	r0, r4
    e9e2:	f7ff fdb7 	bl	e554 <ble_ll_ctrl_proc_stop>
            ble_ll_hci_ev_conn_update(connsm, ble_error);
    e9e6:	4620      	mov	r0, r4
    e9e8:	4629      	mov	r1, r5
    e9ea:	f000 fc41 	bl	f270 <ble_ll_hci_ev_conn_update>
    e9ee:	e00c      	b.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        }
        break;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    case BLE_LL_CTRL_PROC_ENCRYPT:
        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
    e9f0:	4620      	mov	r0, r4
    e9f2:	f7ff fdaf 	bl	e554 <ble_ll_ctrl_proc_stop>
        ble_ll_hci_ev_encrypt_chg(connsm, ble_error);
    e9f6:	4620      	mov	r0, r4
    e9f8:	4629      	mov	r1, r5
    e9fa:	f000 fc69 	bl	f2d0 <ble_ll_hci_ev_encrypt_chg>
        connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
    e9fe:	2301      	movs	r3, #1
    ea00:	f884 3120 	strb.w	r3, [r4, #288]	; 0x120
    ea04:	e001      	b.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
        break;
    }

    /* Free mbuf or send response */
ll_ctrl_send_rsp:
    if (rsp_opcode == 255) {
    ea06:	2eff      	cmp	r6, #255	; 0xff
    ea08:	d103      	bne.n	ea12 <ble_ll_ctrl_rx_pdu+0x48e>
        os_mbuf_free_chain(om);
    ea0a:	4640      	mov	r0, r8
    ea0c:	f7fb faa7 	bl	9f5e <os_mbuf_free_chain>
    ea10:	e015      	b.n	ea3e <ble_ll_ctrl_rx_pdu+0x4ba>
    ea12:	f04f 0a00 	mov.w	sl, #0
        /*
         * Write the response opcode into the buffer. If this is an unknown
         * response, put opcode of unknown pdu into buffer.
         */
        rspbuf[0] = rsp_opcode;
        if (rsp_opcode == BLE_LL_CTRL_UNKNOWN_RSP) {
    ea16:	2e07      	cmp	r6, #7
    } else {
        /*
         * Write the response opcode into the buffer. If this is an unknown
         * response, put opcode of unknown pdu into buffer.
         */
        rspbuf[0] = rsp_opcode;
    ea18:	702e      	strb	r6, [r5, #0]
        if (rsp_opcode == BLE_LL_CTRL_UNKNOWN_RSP) {
            rspbuf[1] = opcode;
    ea1a:	bf08      	it	eq
    ea1c:	706f      	strbeq	r7, [r5, #1]
        }
        len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
    ea1e:	f819 3006 	ldrb.w	r3, [r9, r6]
    ea22:	3301      	adds	r3, #1
        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
    ea24:	4620      	mov	r0, r4
    ea26:	4641      	mov	r1, r8
    ea28:	2203      	movs	r2, #3
    ea2a:	b2db      	uxtb	r3, r3
    ea2c:	f7fe fb62 	bl	d0f4 <ble_ll_conn_enqueue_pkt>
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        if (restart_encryption) {
    ea30:	f1ba 0f00 	cmp.w	sl, #0
    ea34:	d003      	beq.n	ea3e <ble_ll_ctrl_rx_pdu+0x4ba>
            /* XXX: what happens if this fails? Meaning we cant allocate
               mbuf? */
            ble_ll_ctrl_proc_init(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
    ea36:	4620      	mov	r0, r4
    ea38:	2102      	movs	r1, #2
    ea3a:	f7ff fb0f 	bl	e05c <ble_ll_ctrl_proc_init>
        }
#endif
    }
    return 0;
    ea3e:	2000      	movs	r0, #0
    ea40:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

rx_malformed_ctrl:
    os_mbuf_free_chain(om);
    ea44:	4640      	mov	r0, r8
    ea46:	f7fb fa8a 	bl	9f5e <os_mbuf_free_chain>
    return -1;
    ea4a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ea4e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    rsp_opcode = BLE_LL_CTRL_REJECT_IND;
                    rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
                }
            } else {
                /* Construct unknown rsp pdu */
                rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
    ea52:	2607      	movs	r6, #7
    ea54:	e7df      	b.n	ea16 <ble_ll_ctrl_rx_pdu+0x492>
        (len != g_ble_ll_ctrl_pkt_lengths[opcode])) {
        goto rx_malformed_ctrl;
    }

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    restart_encryption = 0;
    ea56:	f04f 0a00 	mov.w	sl, #0
            restart_encryption = 1;
        }
        break;
#endif
    case BLE_LL_CTRL_PING_REQ:
        rsp_opcode = BLE_LL_CTRL_PING_RSP;
    ea5a:	2613      	movs	r6, #19
    ea5c:	e7db      	b.n	ea16 <ble_ll_ctrl_rx_pdu+0x492>
ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
{
    int rc;

    rc = BLE_ERR_MAX;
    if (connsm->conn_role == BLE_LL_CONN_ROLE_MASTER) {
    ea5e:	260b      	movs	r6, #11
    ea60:	e7d9      	b.n	ea16 <ble_ll_ctrl_rx_pdu+0x492>
        break;
    }

    /* Free mbuf or send response */
ll_ctrl_send_rsp:
    if (rsp_opcode == 255) {
    ea62:	2eff      	cmp	r6, #255	; 0xff
    ea64:	d0d1      	beq.n	ea0a <ble_ll_ctrl_rx_pdu+0x486>
    } else {
        /*
         * Write the response opcode into the buffer. If this is an unknown
         * response, put opcode of unknown pdu into buffer.
         */
        rspbuf[0] = rsp_opcode;
    ea66:	702e      	strb	r6, [r5, #0]
    ea68:	f04f 0a00 	mov.w	sl, #0
    ea6c:	e7d7      	b.n	ea1e <ble_ll_ctrl_rx_pdu+0x49a>
    ea6e:	bf00      	nop

0000ea70 <ble_ll_ctrl_reject_ind_send>:
 * @return int
 */
int
ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
                            uint8_t err)
{
    ea70:	b570      	push	{r4, r5, r6, lr}
    ea72:	4604      	mov	r4, r0
    ea74:	460e      	mov	r6, r1
    uint8_t len;
    uint8_t opcode;
    uint8_t *rspbuf;
    struct os_mbuf *om;

    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
    ea76:	201b      	movs	r0, #27
    ea78:	2108      	movs	r1, #8
 * @return int
 */
int
ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
                            uint8_t err)
{
    ea7a:	4615      	mov	r5, r2
    uint8_t len;
    uint8_t opcode;
    uint8_t *rspbuf;
    struct os_mbuf *om;

    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
    ea7c:	f7fb fa59 	bl	9f32 <os_msys_get_pkthdr>
                            sizeof(struct ble_mbuf_hdr));
    if (om) {
    ea80:	4601      	mov	r1, r0
    ea82:	b1d0      	cbz	r0, eaba <ble_ll_ctrl_reject_ind_send+0x4a>
        rspbuf = om->om_data;
        opcode = BLE_LL_CTRL_REJECT_IND_EXT;
        if (rej_opcode == BLE_LL_CTRL_ENC_REQ) {
    ea84:	2e03      	cmp	r6, #3
    struct os_mbuf *om;

    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
                            sizeof(struct ble_mbuf_hdr));
    if (om) {
        rspbuf = om->om_data;
    ea86:	6803      	ldr	r3, [r0, #0]
        opcode = BLE_LL_CTRL_REJECT_IND_EXT;
        if (rej_opcode == BLE_LL_CTRL_ENC_REQ) {
    ea88:	d107      	bne.n	ea9a <ble_ll_ctrl_reject_ind_send+0x2a>
            if ((connsm->common_features & BLE_LL_FEAT_EXTENDED_REJ) == 0) {
    ea8a:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
    ea8e:	f012 0f04 	tst.w	r2, #4
                opcode = BLE_LL_CTRL_REJECT_IND;
    ea92:	bf14      	ite	ne
    ea94:	2011      	movne	r0, #17
    ea96:	200d      	moveq	r0, #13
    ea98:	e000      	b.n	ea9c <ble_ll_ctrl_reject_ind_send+0x2c>

    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
                            sizeof(struct ble_mbuf_hdr));
    if (om) {
        rspbuf = om->om_data;
        opcode = BLE_LL_CTRL_REJECT_IND_EXT;
    ea9a:	2011      	movs	r0, #17
            if ((connsm->common_features & BLE_LL_FEAT_EXTENDED_REJ) == 0) {
                opcode = BLE_LL_CTRL_REJECT_IND;
            }
        }
        rspbuf[0] = opcode;
        if (opcode == BLE_LL_CTRL_REJECT_IND) {
    ea9c:	280d      	cmp	r0, #13
        if (rej_opcode == BLE_LL_CTRL_ENC_REQ) {
            if ((connsm->common_features & BLE_LL_FEAT_EXTENDED_REJ) == 0) {
                opcode = BLE_LL_CTRL_REJECT_IND;
            }
        }
        rspbuf[0] = opcode;
    ea9e:	7018      	strb	r0, [r3, #0]
        if (opcode == BLE_LL_CTRL_REJECT_IND) {
            rspbuf[1] = err;
    eaa0:	bf0e      	itee	eq
    eaa2:	705d      	strbeq	r5, [r3, #1]
            len = BLE_LL_CTRL_REJ_IND_LEN + 1;
        } else {
            rspbuf[1] = rej_opcode;
    eaa4:	705e      	strbne	r6, [r3, #1]
            rspbuf[2] = err;
    eaa6:	709d      	strbne	r5, [r3, #2]
            len = BLE_LL_CTRL_REJECT_IND_EXT_LEN + 1;
        }
        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
    eaa8:	4620      	mov	r0, r4
            }
        }
        rspbuf[0] = opcode;
        if (opcode == BLE_LL_CTRL_REJECT_IND) {
            rspbuf[1] = err;
            len = BLE_LL_CTRL_REJ_IND_LEN + 1;
    eaaa:	bf0c      	ite	eq
    eaac:	2302      	moveq	r3, #2
        } else {
            rspbuf[1] = rej_opcode;
            rspbuf[2] = err;
            len = BLE_LL_CTRL_REJECT_IND_EXT_LEN + 1;
    eaae:	2303      	movne	r3, #3
        }
        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
    eab0:	2203      	movs	r2, #3
    eab2:	f7fe fb1f 	bl	d0f4 <ble_ll_conn_enqueue_pkt>
        rc = 0;
    eab6:	2000      	movs	r0, #0
    eab8:	bd70      	pop	{r4, r5, r6, pc}
    } else {
        rc = 1;
    eaba:	2001      	movs	r0, #1
    }
    return rc;
}
    eabc:	bd70      	pop	{r4, r5, r6, pc}

0000eabe <ble_ll_ctrl_tx_done>:
 *
 * @return int
 */
int
ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
{
    eabe:	b538      	push	{r3, r4, r5, lr}
    int rc;
    uint8_t opcode;

    rc = 0;
    opcode = txpdu->om_data[0];
    eac0:	6802      	ldr	r2, [r0, #0]
    switch (opcode) {
    eac2:	7813      	ldrb	r3, [r2, #0]
    eac4:	3b02      	subs	r3, #2
 *
 * @return int
 */
int
ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
{
    eac6:	4605      	mov	r5, r0
    int rc;
    uint8_t opcode;

    rc = 0;
    opcode = txpdu->om_data[0];
    switch (opcode) {
    eac8:	2b0f      	cmp	r3, #15
    eaca:	d83e      	bhi.n	eb4a <ble_ll_ctrl_tx_done+0x8c>
    eacc:	e8df f003 	tbb	[pc, r3]
    ead0:	3d232108 	.word	0x3d232108
    ead4:	3d3d3d2b 	.word	0x3d3d3d2b
    ead8:	1f3d3721 	.word	0x1f3d3721
    eadc:	0f3d3d3d 	.word	0x0f3d3d3d
    case BLE_LL_CTRL_TERMINATE_IND:
        connsm->csmflags.cfbit.terminate_ind_txd = 1;
    eae0:	780b      	ldrb	r3, [r1, #0]
    eae2:	f043 0302 	orr.w	r3, r3, #2
    eae6:	700b      	strb	r3, [r1, #0]
        rc = -1;
    eae8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        break;
    eaec:	e02e      	b.n	eb4c <ble_ll_ctrl_tx_done+0x8e>
    case BLE_LL_CTRL_REJECT_IND_EXT:
        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
    eaee:	f891 3036 	ldrb.w	r3, [r1, #54]	; 0x36
    eaf2:	2b06      	cmp	r3, #6
            connsm->reject_reason = txpdu->om_data[2];
    eaf4:	bf01      	itttt	eq
    eaf6:	7893      	ldrbeq	r3, [r2, #2]
    eaf8:	f881 3032 	strbeq.w	r3, [r1, #50]	; 0x32
            connsm->csmflags.cfbit.host_expects_upd_event = 1;
    eafc:	784b      	ldrbeq	r3, [r1, #1]
    eafe:	f043 0301 	orreq.w	r3, r3, #1
    eb02:	bf08      	it	eq
    eb04:	704b      	strbeq	r3, [r1, #1]
        }
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
    eb06:	f891 3120 	ldrb.w	r3, [r1, #288]	; 0x120
    eb0a:	2b02      	cmp	r3, #2
    eb0c:	d91d      	bls.n	eb4a <ble_ll_ctrl_tx_done+0x8c>
        }
#endif
        break;
    case BLE_LL_CTRL_REJECT_IND:
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
    eb0e:	2301      	movs	r3, #1
    eb10:	e019      	b.n	eb46 <ble_ll_ctrl_tx_done+0x88>
        break;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    case BLE_LL_CTRL_PAUSE_ENC_REQ:
        /* note: fall-through intentional */
    case BLE_LL_CTRL_ENC_REQ:
        connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_WAIT;
    eb12:	2303      	movs	r3, #3
    eb14:	e017      	b.n	eb46 <ble_ll_ctrl_tx_done+0x88>
        break;
    case BLE_LL_CTRL_ENC_RSP:
        connsm->enc_data.enc_state = CONN_ENC_S_LTK_REQ_WAIT;
    eb16:	2307      	movs	r3, #7
    eb18:	f881 3120 	strb.w	r3, [r1, #288]	; 0x120
        connsm->csmflags.cfbit.send_ltk_req = 1;
    eb1c:	784b      	ldrb	r3, [r1, #1]
    eb1e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    eb22:	704b      	strb	r3, [r1, #1]
    eb24:	e011      	b.n	eb4a <ble_ll_ctrl_tx_done+0x8c>
        break;
    case BLE_LL_CTRL_START_ENC_RSP:
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    eb26:	79cb      	ldrb	r3, [r1, #7]
    eb28:	2b02      	cmp	r3, #2
    eb2a:	d10e      	bne.n	eb4a <ble_ll_ctrl_tx_done+0x8c>
            connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
    eb2c:	f881 3120 	strb.w	r3, [r1, #288]	; 0x120
            if (CONN_F_LE_PING_SUPP(connsm)) {
    eb30:	788b      	ldrb	r3, [r1, #2]
    eb32:	075b      	lsls	r3, r3, #29
    eb34:	d509      	bpl.n	eb4a <ble_ll_ctrl_tx_done+0x8c>
                ble_ll_conn_auth_pyld_timer_start(connsm);
    eb36:	4608      	mov	r0, r1
    eb38:	f7fd fcea 	bl	c510 <ble_ll_conn_auth_pyld_timer_start>
    eb3c:	e005      	b.n	eb4a <ble_ll_ctrl_tx_done+0x8c>
            }
        }
        break;
    case BLE_LL_CTRL_PAUSE_ENC_RSP:
        if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
    eb3e:	79cb      	ldrb	r3, [r1, #7]
    eb40:	2b02      	cmp	r3, #2
    eb42:	d102      	bne.n	eb4a <ble_ll_ctrl_tx_done+0x8c>
            connsm->enc_data.enc_state = CONN_ENC_S_PAUSE_ENC_RSP_WAIT;
    eb44:	2306      	movs	r3, #6
    eb46:	f881 3120 	strb.w	r3, [r1, #288]	; 0x120
ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
{
    int rc;
    uint8_t opcode;

    rc = 0;
    eb4a:	2400      	movs	r4, #0
#endif
    default:
        break;
    }

    os_mbuf_free_chain(txpdu);
    eb4c:	4628      	mov	r0, r5
    eb4e:	f7fb fa06 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
    eb52:	4620      	mov	r0, r4
    eb54:	bd38      	pop	{r3, r4, r5, pc}
	...

0000eb58 <ble_ll_hci_event_send>:
ble_ll_hci_event_send(uint8_t *evbuf)
{
    int rc;

    /* Count number of events sent */
    STATS_INC(ble_ll_stats, hci_events_sent);
    eb58:	4a02      	ldr	r2, [pc, #8]	; (eb64 <ble_ll_hci_event_send+0xc>)
    eb5a:	6953      	ldr	r3, [r2, #20]
    eb5c:	3301      	adds	r3, #1
    eb5e:	6153      	str	r3, [r2, #20]

    /* Send the event to the host */
    rc = ble_hci_transport_ctlr_event_send(evbuf);
    eb60:	f00a bb80 	b.w	19264 <ble_hci_transport_ctlr_event_send>
    eb64:	200030ac 	.word	0x200030ac

0000eb68 <ble_ll_hci_send_noop>:
 *
 * @return int 0: ok, ble error code otherwise.
 */
int
ble_ll_hci_send_noop(void)
{
    eb68:	b510      	push	{r4, lr}
    int rc;
    uint8_t *evbuf;
    uint16_t opcode;

    evbuf = os_memblock_get(&g_hci_evt_pool);
    eb6a:	480b      	ldr	r0, [pc, #44]	; (eb98 <ble_ll_hci_send_noop+0x30>)
    eb6c:	f7fb fc44 	bl	a3f8 <os_memblock_get>
    if (evbuf) {
    eb70:	4604      	mov	r4, r0
    eb72:	b170      	cbz	r0, eb92 <ble_ll_hci_send_noop+0x2a>
        /* Create a command complete event with a NO-OP opcode */
        opcode = 0;
        evbuf[0] = BLE_HCI_EVCODE_COMMAND_COMPLETE;
    eb74:	230e      	movs	r3, #14
    eb76:	7003      	strb	r3, [r0, #0]
        evbuf[1] = 3;
    eb78:	2303      	movs	r3, #3
    eb7a:	7043      	strb	r3, [r0, #1]
        evbuf[2] = ble_ll_hci_get_num_cmd_pkts();
    eb7c:	2301      	movs	r3, #1
    eb7e:	7083      	strb	r3, [r0, #2]
        htole16(evbuf + 3, opcode);
    eb80:	2100      	movs	r1, #0
    eb82:	3003      	adds	r0, #3
    eb84:	f00e fa68 	bl	1d058 <htole16>
        ble_ll_hci_event_send(evbuf);
    eb88:	4620      	mov	r0, r4
    eb8a:	f7ff ffe5 	bl	eb58 <ble_ll_hci_event_send>
        rc = BLE_ERR_SUCCESS;
    eb8e:	2000      	movs	r0, #0
    eb90:	bd10      	pop	{r4, pc}
    } else {
        rc = BLE_ERR_MEM_CAPACITY;
    eb92:	2007      	movs	r0, #7
    }

    return rc;
}
    eb94:	bd10      	pop	{r4, pc}
    eb96:	bf00      	nop
    eb98:	20003b5c 	.word	0x20003b5c

0000eb9c <ble_ll_hci_is_le_event_enabled>:
    int bitpos;

    /* The LE meta event must be enabled for any LE event to be enabled */
    enabled = 0;
    bitpos = subev - 1;
    if (g_ble_ll_hci_event_mask[7] & 0x20) {
    eb9c:	4b0a      	ldr	r3, [pc, #40]	; (ebc8 <ble_ll_hci_is_le_event_enabled+0x2c>)
    eb9e:	79da      	ldrb	r2, [r3, #7]
    eba0:	f002 0220 	and.w	r2, r2, #32
    eba4:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    eba8:	b162      	cbz	r2, ebc4 <ble_ll_hci_is_le_event_enabled+0x28>
    uint8_t bitmask;
    int bitpos;

    /* The LE meta event must be enabled for any LE event to be enabled */
    enabled = 0;
    bitpos = subev - 1;
    ebaa:	3801      	subs	r0, #1
    if (g_ble_ll_hci_event_mask[7] & 0x20) {
        bytenum = bitpos / 8;
        bitmask = 1 << (bitpos & 0x7);
    ebac:	f000 0307 	and.w	r3, r0, #7

    /* The LE meta event must be enabled for any LE event to be enabled */
    enabled = 0;
    bitpos = subev - 1;
    if (g_ble_ll_hci_event_mask[7] & 0x20) {
        bytenum = bitpos / 8;
    ebb0:	2208      	movs	r2, #8
    ebb2:	fb90 f2f2 	sdiv	r2, r0, r2
        bitmask = 1 << (bitpos & 0x7);
    ebb6:	2001      	movs	r0, #1
        enabled = g_ble_ll_hci_le_event_mask[bytenum] & bitmask;
    ebb8:	b2d2      	uxtb	r2, r2
    /* The LE meta event must be enabled for any LE event to be enabled */
    enabled = 0;
    bitpos = subev - 1;
    if (g_ble_ll_hci_event_mask[7] & 0x20) {
        bytenum = bitpos / 8;
        bitmask = 1 << (bitpos & 0x7);
    ebba:	4098      	lsls	r0, r3
        enabled = g_ble_ll_hci_le_event_mask[bytenum] & bitmask;
    ebbc:	4b03      	ldr	r3, [pc, #12]	; (ebcc <ble_ll_hci_is_le_event_enabled+0x30>)
    ebbe:	5c9b      	ldrb	r3, [r3, r2]
    ebc0:	4018      	ands	r0, r3
    ebc2:	4770      	bx	lr
    uint8_t bytenum;
    uint8_t bitmask;
    int bitpos;

    /* The LE meta event must be enabled for any LE event to be enabled */
    enabled = 0;
    ebc4:	4618      	mov	r0, r3
        bitmask = 1 << (bitpos & 0x7);
        enabled = g_ble_ll_hci_le_event_mask[bytenum] & bitmask;
    }

    return enabled;
}
    ebc6:	4770      	bx	lr
    ebc8:	20001ea0 	.word	0x20001ea0
    ebcc:	20001ea8 	.word	0x20001ea8

0000ebd0 <ble_ll_hci_is_event_enabled>:
    uint8_t bytenum;
    uint8_t bitmask;
    uint8_t *evptr;
    int bitpos;

    if (evcode >= 64) {
    ebd0:	283f      	cmp	r0, #63	; 0x3f
        evptr = &g_ble_ll_hci_event_mask2[0];
        bitpos = evcode - 64;
    ebd2:	bfcb      	itete	gt
    ebd4:	3840      	subgt	r0, #64	; 0x40
    } else {
        evptr = &g_ble_ll_hci_event_mask[0];
        bitpos = evcode - 1;
    ebd6:	f100 30ff 	addle.w	r0, r0, #4294967295	; 0xffffffff
    uint8_t bitmask;
    uint8_t *evptr;
    int bitpos;

    if (evcode >= 64) {
        evptr = &g_ble_ll_hci_event_mask2[0];
    ebda:	4906      	ldrgt	r1, [pc, #24]	; (ebf4 <ble_ll_hci_is_event_enabled+0x24>)
        bitpos = evcode - 64;
    } else {
        evptr = &g_ble_ll_hci_event_mask[0];
    ebdc:	4906      	ldrle	r1, [pc, #24]	; (ebf8 <ble_ll_hci_is_event_enabled+0x28>)
        bitpos = evcode - 1;
    }

    bytenum = bitpos / 8;
    ebde:	2208      	movs	r2, #8
    ebe0:	fb90 f2f2 	sdiv	r2, r0, r2
    ebe4:	b2d2      	uxtb	r2, r2
    bitmask = 1 << (bitpos & 0x7);
    ebe6:	f000 0307 	and.w	r3, r0, #7
    ebea:	2001      	movs	r0, #1
    ebec:	4098      	lsls	r0, r3
    enabled = evptr[bytenum] & bitmask;
    ebee:	5c8b      	ldrb	r3, [r1, r2]

    return enabled;
}
    ebf0:	4018      	ands	r0, r3
    ebf2:	4770      	bx	lr
    ebf4:	20001e98 	.word	0x20001e98
    ebf8:	20001ea0 	.word	0x20001ea0

0000ebfc <ble_ll_hci_cmd_proc>:
 *
 * @param ev Pointer to os event containing a pointer to command buffer
 */
void
ble_ll_hci_cmd_proc(struct os_event *ev)
{
    ebfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint16_t opcode;
    uint16_t ocf;
    os_error_t err;

    /* The command buffer is the event argument */
    cmdbuf = (uint8_t *)ev->ev_arg;
    ec00:	6846      	ldr	r6, [r0, #4]
 *
 * @param ev Pointer to os event containing a pointer to command buffer
 */
void
ble_ll_hci_cmd_proc(struct os_event *ev)
{
    ec02:	b08e      	sub	sp, #56	; 0x38
    ec04:	4601      	mov	r1, r0
    uint16_t ocf;
    os_error_t err;

    /* The command buffer is the event argument */
    cmdbuf = (uint8_t *)ev->ev_arg;
    assert(cmdbuf != NULL);
    ec06:	b926      	cbnz	r6, ec12 <ble_ll_hci_cmd_proc+0x16>
    ec08:	48b4      	ldr	r0, [pc, #720]	; (eedc <ble_ll_hci_cmd_proc+0x2e0>)
    ec0a:	f240 3197 	movw	r1, #919	; 0x397
    ec0e:	4632      	mov	r2, r6
    ec10:	e008      	b.n	ec24 <ble_ll_hci_cmd_proc+0x28>

    /* Free the event */
    err = os_memblock_put(&g_hci_os_event_pool, ev);
    ec12:	48b3      	ldr	r0, [pc, #716]	; (eee0 <ble_ll_hci_cmd_proc+0x2e4>)
    ec14:	f7fb fc04 	bl	a420 <os_memblock_put>
    assert(err == OS_OK);
    ec18:	4604      	mov	r4, r0
    ec1a:	b130      	cbz	r0, ec2a <ble_ll_hci_cmd_proc+0x2e>
    ec1c:	48af      	ldr	r0, [pc, #700]	; (eedc <ble_ll_hci_cmd_proc+0x2e0>)
    ec1e:	f240 319b 	movw	r1, #923	; 0x39b
    ec22:	2200      	movs	r2, #0
    ec24:	4613      	mov	r3, r2
    ec26:	f7fb f853 	bl	9cd0 <__assert_func>

    /* Get the opcode from the command buffer */
    opcode = le16toh(cmdbuf);
    ec2a:	4630      	mov	r0, r6
    ec2c:	f00e fa2f 	bl	1d08e <le16toh>
    ogf = BLE_HCI_OGF(opcode);

    /* Assume response length is zero */
    rsplen = 0;

    switch (ogf) {
    ec30:	f3c0 2385 	ubfx	r3, r0, #10, #6
    ec34:	3b01      	subs	r3, #1
    /* Free the event */
    err = os_memblock_put(&g_hci_os_event_pool, ev);
    assert(err == OS_OK);

    /* Get the opcode from the command buffer */
    opcode = le16toh(cmdbuf);
    ec36:	4607      	mov	r7, r0
    ocf = BLE_HCI_OCF(opcode);
    ec38:	f3c0 0809 	ubfx	r8, r0, #0, #10
    ogf = BLE_HCI_OGF(opcode);

    /* Assume response length is zero */
    rsplen = 0;
    ec3c:	f88d 4007 	strb.w	r4, [sp, #7]

    switch (ogf) {
    ec40:	2b07      	cmp	r3, #7
    ec42:	f200 8274 	bhi.w	f12e <ble_ll_hci_cmd_proc+0x532>
    ec46:	e8df f013 	tbh	[pc, r3, lsl #1]
    ec4a:	0008      	.short	0x0008
    ec4c:	00200272 	.word	0x00200272
    ec50:	00ac0051 	.word	0x00ac0051
    ec54:	02720272 	.word	0x02720272
    ec58:	00bc      	.short	0x00bc
    len = cmdbuf[sizeof(uint16_t)];

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;

    switch (ocf) {
    ec5a:	f1b8 0f06 	cmp.w	r8, #6

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;

    /* Get length from command */
    len = cmdbuf[sizeof(uint16_t)];
    ec5e:	78b3      	ldrb	r3, [r6, #2]

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;
    ec60:	f106 0003 	add.w	r0, r6, #3

    switch (ocf) {
    ec64:	d003      	beq.n	ec6e <ble_ll_hci_cmd_proc+0x72>
    ec66:	f1b8 0f1d 	cmp.w	r8, #29
    ec6a:	d005      	beq.n	ec78 <ble_ll_hci_cmd_proc+0x7c>
    ec6c:	e25f      	b.n	f12e <ble_ll_hci_cmd_proc+0x532>
    case BLE_HCI_OCF_DISCONNECT_CMD:
        if (len == BLE_HCI_DISCONNECT_CMD_LEN) {
    ec6e:	2b03      	cmp	r3, #3
    ec70:	d107      	bne.n	ec82 <ble_ll_hci_cmd_proc+0x86>
            rc = ble_ll_conn_hci_disconnect_cmd(cmdbuf);
    ec72:	f7fe ff85 	bl	db80 <ble_ll_conn_hci_disconnect_cmd>
    ec76:	e005      	b.n	ec84 <ble_ll_hci_cmd_proc+0x88>
        /* Send command status instead of command complete */
        rc += (BLE_ERR_MAX + 1);
        break;

    case BLE_HCI_OCF_RD_REM_VER_INFO:
        if (len == sizeof(uint16_t)) {
    ec78:	2b02      	cmp	r3, #2
    ec7a:	d102      	bne.n	ec82 <ble_ll_hci_cmd_proc+0x86>
            rc = ble_ll_conn_hci_rd_rem_ver_cmd(cmdbuf);
    ec7c:	f7fe ffb4 	bl	dbe8 <ble_ll_conn_hci_rd_rem_ver_cmd>
    ec80:	e000      	b.n	ec84 <ble_ll_hci_cmd_proc+0x88>
{
    int rc;
    uint8_t len;

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    ec82:	2012      	movs	r0, #18
    case BLE_HCI_OCF_RD_REM_VER_INFO:
        if (len == sizeof(uint16_t)) {
            rc = ble_ll_conn_hci_rd_rem_ver_cmd(cmdbuf);
        }
        /* Send command status instead of command complete */
        rc += (BLE_ERR_MAX + 1);
    ec84:	f500 7480 	add.w	r4, r0, #256	; 0x100
    ec88:	e21c      	b.n	f0c4 <ble_ll_hci_cmd_proc+0x4c8>
    cmdbuf += BLE_HCI_CMD_HDR_LEN;
#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;
#endif

    switch (ocf) {
    ec8a:	f1b8 0f63 	cmp.w	r8, #99	; 0x63

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;

    /* Get length from command */
    len = cmdbuf[sizeof(uint16_t)];
    ec8e:	78b3      	ldrb	r3, [r6, #2]

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;
    ec90:	f106 0003 	add.w	r0, r6, #3
#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;
    ec94:	f106 0109 	add.w	r1, r6, #9
#endif

    switch (ocf) {
    ec98:	d019      	beq.n	ecce <ble_ll_hci_cmd_proc+0xd2>
    ec9a:	d806      	bhi.n	ecaa <ble_ll_hci_cmd_proc+0xae>
    ec9c:	f1b8 0f01 	cmp.w	r8, #1
    eca0:	d00a      	beq.n	ecb8 <ble_ll_hci_cmd_proc+0xbc>
    eca2:	f1b8 0f03 	cmp.w	r8, #3
    eca6:	d00c      	beq.n	ecc2 <ble_ll_hci_cmd_proc+0xc6>
    eca8:	e241      	b.n	f12e <ble_ll_hci_cmd_proc+0x532>
    ecaa:	f1b8 0f7b 	cmp.w	r8, #123	; 0x7b
    ecae:	d018      	beq.n	ece2 <ble_ll_hci_cmd_proc+0xe6>
    ecb0:	f1b8 0f7c 	cmp.w	r8, #124	; 0x7c
    ecb4:	d015      	beq.n	ece2 <ble_ll_hci_cmd_proc+0xe6>
    ecb6:	e23a      	b.n	f12e <ble_ll_hci_cmd_proc+0x532>
    case BLE_HCI_OCF_CB_SET_EVENT_MASK:
        if (len == BLE_HCI_SET_EVENT_MASK_LEN) {
    ecb8:	2b08      	cmp	r3, #8
    ecba:	f040 823a 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
            memcpy(g_ble_ll_hci_event_mask, cmdbuf, len);
    ecbe:	4a89      	ldr	r2, [pc, #548]	; (eee4 <ble_ll_hci_cmd_proc+0x2e8>)
    ecc0:	e009      	b.n	ecd6 <ble_ll_hci_cmd_proc+0xda>
            rc = BLE_ERR_SUCCESS;
        }
        break;
    case BLE_HCI_OCF_CB_RESET:
        if (len == 0) {
    ecc2:	2b00      	cmp	r3, #0
    ecc4:	f040 8235 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
            rc = ble_ll_reset();
    ecc8:	f7fc fa34 	bl	b134 <ble_ll_reset>
    eccc:	e077      	b.n	edbe <ble_ll_hci_cmd_proc+0x1c2>
        }
        break;
    case BLE_HCI_OCF_CB_SET_EVENT_MASK2:
        if (len == BLE_HCI_SET_EVENT_MASK_LEN) {
    ecce:	2b08      	cmp	r3, #8
    ecd0:	f040 822f 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
            memcpy(g_ble_ll_hci_event_mask2, cmdbuf, len);
    ecd4:	4a84      	ldr	r2, [pc, #528]	; (eee8 <ble_ll_hci_cmd_proc+0x2ec>)
    ecd6:	6803      	ldr	r3, [r0, #0]
    ecd8:	6013      	str	r3, [r2, #0]
    ecda:	6843      	ldr	r3, [r0, #4]
    ecdc:	6053      	str	r3, [r2, #4]
            rc = BLE_ERR_SUCCESS;
    ecde:	2400      	movs	r4, #0
    ece0:	e1f8      	b.n	f0d4 <ble_ll_hci_cmd_proc+0x4d8>
#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    case BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO:
        rc = ble_ll_conn_hci_wr_auth_pyld_tmo(cmdbuf, rspbuf, rsplen);
        break;
    case BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO:
        rc = ble_ll_conn_hci_wr_auth_pyld_tmo(cmdbuf, rspbuf, rsplen);
    ece2:	f10d 0207 	add.w	r2, sp, #7
    ece6:	f7ff f885 	bl	ddf4 <ble_ll_conn_hci_wr_auth_pyld_tmo>
    ecea:	e068      	b.n	edbe <ble_ll_hci_cmd_proc+0x1c2>
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;

    switch (ocf) {
    ecec:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;

    /* Get length from command */
    len = cmdbuf[sizeof(uint16_t)];
    ecf0:	78b4      	ldrb	r4, [r6, #2]
    /*
     * The command response pointer points into the same buffer as the
     * command data itself. That is fine, as each command reads all the data
     * before crafting a response.
     */
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;
    ecf2:	1db5      	adds	r5, r6, #6

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;

    switch (ocf) {
    ecf4:	2b08      	cmp	r3, #8
    ecf6:	f200 821a 	bhi.w	f12e <ble_ll_hci_cmd_proc+0x532>
    ecfa:	e8df f013 	tbh	[pc, r3, lsl #1]
    ecfe:	0009      	.short	0x0009
    ed00:	00360021 	.word	0x00360021
    ed04:	02180218 	.word	0x02180218
    ed08:	02180218 	.word	0x02180218
    ed0c:	00450218 	.word	0x00450218
    case BLE_HCI_OCF_IP_RD_LOCAL_VER:
        if (len == 0) {
    ed10:	2c00      	cmp	r4, #0
    ed12:	f040 820e 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
    hci_rev = 0;
    lmp_subver = 0;
    mfrg = NIMBLE_OPT_LL_MFRG_ID;

    /* Place the data packet length and number of packets in the buffer */
    rspbuf[0] = BLE_HCI_VER_BCS_4_2;
    ed16:	2508      	movs	r5, #8
    htole16(rspbuf + 1, hci_rev);
    ed18:	1df0      	adds	r0, r6, #7
    ed1a:	4621      	mov	r1, r4
    hci_rev = 0;
    lmp_subver = 0;
    mfrg = NIMBLE_OPT_LL_MFRG_ID;

    /* Place the data packet length and number of packets in the buffer */
    rspbuf[0] = BLE_HCI_VER_BCS_4_2;
    ed1c:	71b5      	strb	r5, [r6, #6]
    htole16(rspbuf + 1, hci_rev);
    ed1e:	f00e f99b 	bl	1d058 <htole16>
    rspbuf[3] = BLE_LMP_VER_BCS_4_2;
    htole16(rspbuf + 4, mfrg);
    ed22:	f106 000a 	add.w	r0, r6, #10
    ed26:	f64f 71ff 	movw	r1, #65535	; 0xffff
    mfrg = NIMBLE_OPT_LL_MFRG_ID;

    /* Place the data packet length and number of packets in the buffer */
    rspbuf[0] = BLE_HCI_VER_BCS_4_2;
    htole16(rspbuf + 1, hci_rev);
    rspbuf[3] = BLE_LMP_VER_BCS_4_2;
    ed2a:	7275      	strb	r5, [r6, #9]
    htole16(rspbuf + 4, mfrg);
    ed2c:	f00e f994 	bl	1d058 <htole16>
    htole16(rspbuf + 6, lmp_subver);
    ed30:	f106 000c 	add.w	r0, r6, #12
    ed34:	4621      	mov	r1, r4
    ed36:	f00e f98f 	bl	1d058 <htole16>
    *rsplen = BLE_HCI_RD_LOC_VER_INFO_RSPLEN;
    ed3a:	f88d 5007 	strb.w	r5, [sp, #7]
    ed3e:	e1c9      	b.n	f0d4 <ble_ll_hci_cmd_proc+0x4d8>
        if (len == 0) {
            rc = ble_ll_hci_rd_local_version(rspbuf, rsplen);
        }
        break;
    case BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD:
        if (len == 0) {
    ed40:	2c00      	cmp	r4, #0
    ed42:	f040 81f6 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
 * @return int
 */
static int
ble_ll_hci_rd_local_supp_cmd(uint8_t *rspbuf, uint8_t *rsplen)
{
    memset(rspbuf, 0, BLE_HCI_RD_LOC_SUPP_CMD_RSPLEN);
    ed46:	2240      	movs	r2, #64	; 0x40
    ed48:	4628      	mov	r0, r5
    ed4a:	4621      	mov	r1, r4
    ed4c:	f7fa f961 	bl	9012 <memset>
    memcpy(rspbuf, g_ble_ll_supp_cmds, sizeof(g_ble_ll_supp_cmds));
    ed50:	4b66      	ldr	r3, [pc, #408]	; (eeec <ble_ll_hci_cmd_proc+0x2f0>)
    ed52:	f103 0224 	add.w	r2, r3, #36	; 0x24
    ed56:	f853 1b04 	ldr.w	r1, [r3], #4
    ed5a:	f845 1b04 	str.w	r1, [r5], #4
    ed5e:	4293      	cmp	r3, r2
    ed60:	d1f9      	bne.n	ed56 <ble_ll_hci_cmd_proc+0x15a>
    *rsplen = BLE_HCI_RD_LOC_SUPP_CMD_RSPLEN;
    ed62:	2340      	movs	r3, #64	; 0x40
    ed64:	f88d 3007 	strb.w	r3, [sp, #7]
    ed68:	e7b9      	b.n	ecde <ble_ll_hci_cmd_proc+0xe2>
        if (len == 0) {
            rc = ble_ll_hci_rd_local_supp_cmd(rspbuf, rsplen);
        }
        break;
    case BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT:
        if (len == 0) {
    ed6a:	2c00      	cmp	r4, #0
    ed6c:	f040 81e1 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
    /*
     * The only two bits we set here currently are:
     *      BR/EDR not supported        (bit 5)
     *      LE supported (controller)   (bit 6)
     */
    memset(rspbuf, 0, BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN);
    ed70:	f04f 0808 	mov.w	r8, #8
    ed74:	4628      	mov	r0, r5
    ed76:	4621      	mov	r1, r4
    ed78:	4642      	mov	r2, r8
    ed7a:	f7fa f94a 	bl	9012 <memset>
    rspbuf[4] = 0x60;
    ed7e:	2360      	movs	r3, #96	; 0x60
    ed80:	72b3      	strb	r3, [r6, #10]
    *rsplen = BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN;
    ed82:	f88d 8007 	strb.w	r8, [sp, #7]
    ed86:	e1a5      	b.n	f0d4 <ble_ll_hci_cmd_proc+0x4d8>
        if (len == 0) {
            rc = ble_ll_hci_rd_local_supp_feat(rspbuf, rsplen);
        }
        break;
    case BLE_HCI_OCF_IP_RD_BD_ADDR:
        if (len == 0) {
    ed88:	2c00      	cmp	r4, #0
    ed8a:	f040 81d2 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
{
    /*
     * XXX: for now, assume we always have a public device address. If we
     * dont, we should set this to zero
     */
    memcpy(rspbuf, g_dev_addr, BLE_DEV_ADDR_LEN);
    ed8e:	4b58      	ldr	r3, [pc, #352]	; (eef0 <ble_ll_hci_cmd_proc+0x2f4>)
    ed90:	681a      	ldr	r2, [r3, #0]
    ed92:	f8c6 2006 	str.w	r2, [r6, #6]
    ed96:	889b      	ldrh	r3, [r3, #4]
    ed98:	80ab      	strh	r3, [r5, #4]
    *rsplen = BLE_DEV_ADDR_LEN;
    ed9a:	2306      	movs	r3, #6
    ed9c:	f88d 3007 	strb.w	r3, [sp, #7]
    eda0:	e198      	b.n	f0d4 <ble_ll_hci_cmd_proc+0x4d8>
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;

    switch (ocf) {
    eda2:	f1b8 0f05 	cmp.w	r8, #5

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;

    /* Get length from command */
    len = cmdbuf[sizeof(uint16_t)];
    eda6:	78b3      	ldrb	r3, [r6, #2]
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;

    switch (ocf) {
    eda8:	f040 81c1 	bne.w	f12e <ble_ll_hci_cmd_proc+0x532>
    case BLE_HCI_OCF_RD_RSSI:
        if (len == sizeof(uint16_t)) {
    edac:	2b02      	cmp	r3, #2
    edae:	f040 81c0 	bne.w	f132 <ble_ll_hci_cmd_proc+0x536>
            rc = ble_ll_conn_hci_rd_rssi(cmdbuf, rspbuf, rsplen);
    edb2:	1cf0      	adds	r0, r6, #3
    edb4:	1db1      	adds	r1, r6, #6
    edb6:	f10d 0207 	add.w	r2, sp, #7
    edba:	f7fe ff34 	bl	dc26 <ble_ll_conn_hci_rd_rssi>
    edbe:	4604      	mov	r4, r0
    edc0:	e180      	b.n	f0c4 <ble_ll_hci_cmd_proc+0x4c8>

    /* Get length from command */
    len = cmdbuf[sizeof(uint16_t)];

    /* Check the length to make sure it is valid */
    cmdlen = g_ble_hci_le_cmd_len[ocf];
    edc2:	4a4c      	ldr	r2, [pc, #304]	; (eef4 <ble_ll_hci_cmd_proc+0x2f8>)

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;

    /* Get length from command */
    len = cmdbuf[sizeof(uint16_t)];
    edc4:	78b3      	ldrb	r3, [r6, #2]

    /* Check the length to make sure it is valid */
    cmdlen = g_ble_hci_le_cmd_len[ocf];
    edc6:	f812 2008 	ldrb.w	r2, [r2, r8]
    if ((cmdlen != 0xFF) && (len != cmdlen)) {
    edca:	2aff      	cmp	r2, #255	; 0xff
    edcc:	d002      	beq.n	edd4 <ble_ll_hci_cmd_proc+0x1d8>
    edce:	4293      	cmp	r3, r2
    edd0:	f040 8148 	bne.w	f064 <ble_ll_hci_cmd_proc+0x468>
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;

    switch (ocf) {
    edd4:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    /*
     * The command response pointer points into the same buffer as the
     * command data itself. That is fine, as each command reads all the data
     * before crafting a response.
     */
    rspbuf = cmdbuf + BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN;
    edd8:	1db5      	adds	r5, r6, #6

    /* Move past HCI command header */
    cmdbuf += BLE_HCI_CMD_HDR_LEN;
    edda:	1cf1      	adds	r1, r6, #3

    switch (ocf) {
    eddc:	2a2e      	cmp	r2, #46	; 0x2e
    edde:	f200 8164 	bhi.w	f0aa <ble_ll_hci_cmd_proc+0x4ae>
    ede2:	e8df f012 	tbh	[pc, r2, lsl #1]
    ede6:	002f      	.short	0x002f
    ede8:	003e0035 	.word	0x003e0035
    edec:	004a0162 	.word	0x004a0162
    edf0:	0052004e 	.word	0x0052004e
    edf4:	00610058 	.word	0x00610058
    edf8:	0072006a 	.word	0x0072006a
    edfc:	0076006e 	.word	0x0076006e
    ee00:	0093008d 	.word	0x0093008d
    ee04:	00990090 	.word	0x00990090
    ee08:	00a3009e 	.word	0x00a3009e
    ee0c:	00ab00a7 	.word	0x00ab00a7
    ee10:	00b600b2 	.word	0x00b600b2
    ee14:	00d800d1 	.word	0x00d800d1
    ee18:	00dc00dc 	.word	0x00dc00dc
    ee1c:	016200e7 	.word	0x016200e7
    ee20:	01620162 	.word	0x01620162
    ee24:	00ef00f2 	.word	0x00ef00f2
    ee28:	00fe00f7 	.word	0x00fe00f7
    ee2c:	0162010a 	.word	0x0162010a
    ee30:	01270162 	.word	0x01270162
    ee34:	012f012b 	.word	0x012f012b
    ee38:	01380132 	.word	0x01380132
    ee3c:	0141013c 	.word	0x0141013c
    ee40:	014a0145 	.word	0x014a0145
 */
static int
ble_ll_hci_set_le_event_mask(uint8_t *cmdbuf)
{
    /* Copy the data into the event mask */
    memcpy(g_ble_ll_hci_le_event_mask, cmdbuf, BLE_HCI_SET_LE_EVENT_MASK_LEN);
    ee44:	4a2c      	ldr	r2, [pc, #176]	; (eef8 <ble_ll_hci_cmd_proc+0x2fc>)
    ee46:	680b      	ldr	r3, [r1, #0]
    ee48:	6013      	str	r3, [r2, #0]
    ee4a:	684b      	ldr	r3, [r1, #4]
    ee4c:	6053      	str	r3, [r2, #4]
    ee4e:	e12e      	b.n	f0ae <ble_ll_hci_cmd_proc+0x4b2>
 */
static int
ble_ll_hci_le_read_bufsize(uint8_t *rspbuf, uint8_t *rsplen)
{
    /* Place the data packet length and number of packets in the buffer */
    htole16(rspbuf, g_ble_ll_data.ll_acl_pkt_size);
    ee50:	4c2a      	ldr	r4, [pc, #168]	; (eefc <ble_ll_hci_cmd_proc+0x300>)
    ee52:	4628      	mov	r0, r5
    ee54:	88a1      	ldrh	r1, [r4, #4]
    ee56:	f00e f8ff 	bl	1d058 <htole16>
    rspbuf[2] = g_ble_ll_data.ll_num_acl_pkts;
    ee5a:	78a3      	ldrb	r3, [r4, #2]
    ee5c:	7233      	strb	r3, [r6, #8]
    *rsplen = BLE_HCI_RD_BUF_SIZE_RSPLEN;
    ee5e:	2303      	movs	r3, #3
    ee60:	e120      	b.n	f0a4 <ble_ll_hci_cmd_proc+0x4a8>
 */
static int
ble_ll_hci_le_read_local_features(uint8_t *rspbuf, uint8_t *rsplen)
{
    /* Add list of supported features. */
    memset(rspbuf, 0, BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN);
    ee62:	2408      	movs	r4, #8
    ee64:	2100      	movs	r1, #0
    ee66:	4622      	mov	r2, r4
    ee68:	4628      	mov	r0, r5
    ee6a:	f7fa f8d2 	bl	9012 <memset>
    rspbuf[0] = ble_ll_read_supp_features();
    ee6e:	f7fc f951 	bl	b114 <ble_ll_read_supp_features>
    *rsplen = BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN;
    ee72:	f88d 4007 	strb.w	r4, [sp, #7]
static int
ble_ll_hci_le_read_local_features(uint8_t *rspbuf, uint8_t *rsplen)
{
    /* Add list of supported features. */
    memset(rspbuf, 0, BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN);
    rspbuf[0] = ble_ll_read_supp_features();
    ee76:	71b0      	strb	r0, [r6, #6]
    ee78:	e119      	b.n	f0ae <ble_ll_hci_cmd_proc+0x4b2>
        break;
    case BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT:
        rc = ble_ll_hci_le_read_local_features(rspbuf, rsplen);
        break;
    case BLE_HCI_OCF_LE_SET_RAND_ADDR:
        rc = ble_ll_set_random_addr(cmdbuf);
    ee7a:	4608      	mov	r0, r1
    ee7c:	f7fc f82c 	bl	aed8 <ble_ll_set_random_addr>
    ee80:	e0f9      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_SET_ADV_PARAMS:
        /* Length should be one byte */
        rc = ble_ll_adv_set_adv_params(cmdbuf);
    ee82:	4608      	mov	r0, r1
    ee84:	f7fc fb32 	bl	b4ec <ble_ll_adv_set_adv_params>
    ee88:	e0f5      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR:
        rc = ble_ll_adv_read_txpwr(rspbuf, rsplen);
    ee8a:	4628      	mov	r0, r5
    ee8c:	f10d 0107 	add.w	r1, sp, #7
    ee90:	f7fc fbb6 	bl	b600 <ble_ll_adv_read_txpwr>
    ee94:	e0ef      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_SET_ADV_DATA:
        if (len > 0) {
    ee96:	2b00      	cmp	r3, #0
    ee98:	f000 80e4 	beq.w	f064 <ble_ll_hci_cmd_proc+0x468>
            --len;
    ee9c:	3b01      	subs	r3, #1
            rc = ble_ll_adv_set_adv_data(cmdbuf, len);
    ee9e:	4608      	mov	r0, r1
    eea0:	b2d9      	uxtb	r1, r3
    eea2:	f7fc fc29 	bl	b6f8 <ble_ll_adv_set_adv_data>
    eea6:	e0e6      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        }
        break;
    case BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA:
        if (len > 0) {
    eea8:	2b00      	cmp	r3, #0
    eeaa:	f000 80db 	beq.w	f064 <ble_ll_hci_cmd_proc+0x468>
            --len;
    eeae:	3b01      	subs	r3, #1
            rc = ble_ll_adv_set_scan_rsp_data(cmdbuf, len);
    eeb0:	4608      	mov	r0, r1
    eeb2:	b2d9      	uxtb	r1, r3
    eeb4:	f7fc fc0e 	bl	b6d4 <ble_ll_adv_set_scan_rsp_data>
    eeb8:	e0dd      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        }
        break;
    case BLE_HCI_OCF_LE_SET_ADV_ENABLE:
        /* Length should be one byte */
        rc = ble_ll_adv_set_enable(cmdbuf);
    eeba:	4608      	mov	r0, r1
    eebc:	f7fc fba6 	bl	b60c <ble_ll_adv_set_enable>
    eec0:	e0d9      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_SET_SCAN_ENABLE:
        rc = ble_ll_scan_set_enable(cmdbuf);
    eec2:	4608      	mov	r0, r1
    eec4:	f001 f9a0 	bl	10208 <ble_ll_scan_set_enable>
    eec8:	e0d5      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_SET_SCAN_PARAMS:
        rc = ble_ll_scan_set_scan_params(cmdbuf);
    eeca:	4608      	mov	r0, r1
    eecc:	f001 f968 	bl	101a0 <ble_ll_scan_set_scan_params>
    eed0:	e0d1      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_CREATE_CONN:
        rc = ble_ll_conn_create(cmdbuf);
    eed2:	4608      	mov	r0, r1
    eed4:	f7fe fc40 	bl	d758 <ble_ll_conn_create>
    eed8:	e0cd      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
    eeda:	bf00      	nop
    eedc:	0001f2c6 	.word	0x0001f2c6
    eee0:	20003b40 	.word	0x20003b40
    eee4:	20001ea0 	.word	0x20001ea0
    eee8:	20001e98 	.word	0x20001e98
    eeec:	0001f300 	.word	0x0001f300
    eef0:	200000d8 	.word	0x200000d8
    eef4:	00020bca 	.word	0x00020bca
    eef8:	20001ea8 	.word	0x20001ea8
    eefc:	200032c0 	.word	0x200032c0
        break;
    case BLE_HCI_OCF_LE_CREATE_CONN_CANCEL:
        rc = ble_ll_conn_create_cancel();
    ef00:	f7fe fe2a 	bl	db58 <ble_ll_conn_create_cancel>
    ef04:	e0b7      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_CLEAR_WHITE_LIST:
        rc = ble_ll_whitelist_clear();
    ef06:	f001 fda7 	bl	10a58 <ble_ll_whitelist_clear>
    ef0a:	e0b4      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE:
        rc = ble_ll_whitelist_read_size(rspbuf, rsplen);
    ef0c:	4628      	mov	r0, r5
    ef0e:	f10d 0107 	add.w	r1, sp, #7
    ef12:	f001 fdbb 	bl	10a8c <ble_ll_whitelist_read_size>
    ef16:	e0ae      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_ADD_WHITE_LIST:
        rc = ble_ll_whitelist_add(cmdbuf + 1, cmdbuf[0]);
    ef18:	1d30      	adds	r0, r6, #4
    ef1a:	78f1      	ldrb	r1, [r6, #3]
    ef1c:	f001 fdc2 	bl	10aa4 <ble_ll_whitelist_add>
    ef20:	e0a9      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RMV_WHITE_LIST:
        rc = ble_ll_whitelist_rmv(cmdbuf + 1, cmdbuf[0]);
    ef22:	1d30      	adds	r0, r6, #4
    ef24:	78f1      	ldrb	r1, [r6, #3]
    ef26:	f001 fde5 	bl	10af4 <ble_ll_whitelist_rmv>
    ef2a:	e0a4      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_CONN_UPDATE:
        rc = ble_ll_conn_hci_update(cmdbuf);
    ef2c:	4608      	mov	r0, r1
    ef2e:	f7fe fd1f 	bl	d970 <ble_ll_conn_hci_update>
    ef32:	e0a0      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS:
        rc = ble_ll_conn_hci_set_chan_class(cmdbuf);
    ef34:	4608      	mov	r0, r1
    ef36:	f7fe feb8 	bl	dcaa <ble_ll_conn_hci_set_chan_class>
    ef3a:	e09c      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RD_CHAN_MAP:
        rc = ble_ll_conn_hci_rd_chan_map(cmdbuf, rspbuf, rsplen);
    ef3c:	4608      	mov	r0, r1
    ef3e:	f10d 0207 	add.w	r2, sp, #7
    ef42:	4629      	mov	r1, r5
    ef44:	f7fe fe89 	bl	dc5a <ble_ll_conn_hci_rd_chan_map>
    ef48:	e095      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RD_REM_FEAT:
        rc = ble_ll_conn_hci_read_rem_features(cmdbuf);
    ef4a:	4608      	mov	r0, r1
    ef4c:	f7fe fcf8 	bl	d940 <ble_ll_conn_hci_read_rem_features>
    ef50:	e091      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
{
    int rc;
    struct ble_encryption_block ecb;

    /* Call the link layer to encrypt the data */
    swap_buf(ecb.key, cmdbuf, BLE_ENC_BLOCK_SIZE);
    ef52:	a802      	add	r0, sp, #8
    ef54:	2210      	movs	r2, #16
    ef56:	f00e f8e3 	bl	1d120 <swap_buf>
    swap_buf(ecb.plain_text, cmdbuf + BLE_ENC_BLOCK_SIZE, BLE_ENC_BLOCK_SIZE);
    ef5a:	a806      	add	r0, sp, #24
    ef5c:	f106 0113 	add.w	r1, r6, #19
    ef60:	2210      	movs	r2, #16
    ef62:	f00e f8dd 	bl	1d120 <swap_buf>
    rc = ble_hw_encrypt_block(&ecb);
    ef66:	a802      	add	r0, sp, #8
    ef68:	f001 fea2 	bl	10cb0 <ble_hw_encrypt_block>
    if (!rc) {
    ef6c:	4604      	mov	r4, r0
    ef6e:	b930      	cbnz	r0, ef7e <ble_ll_hci_cmd_proc+0x382>
        swap_buf(rspbuf, ecb.cipher_text, BLE_ENC_BLOCK_SIZE);
    ef70:	4628      	mov	r0, r5
    ef72:	a90a      	add	r1, sp, #40	; 0x28
    ef74:	2210      	movs	r2, #16
    ef76:	f00e f8d3 	bl	1d120 <swap_buf>
        *rsplen = BLE_ENC_BLOCK_SIZE;
    ef7a:	2310      	movs	r3, #16
    ef7c:	e017      	b.n	efae <ble_ll_hci_cmd_proc+0x3b2>
        rc = BLE_ERR_SUCCESS;
    } else {
        *rsplen = 0;
    ef7e:	2300      	movs	r3, #0
    ef80:	f88d 3007 	strb.w	r3, [sp, #7]
        rc = BLE_ERR_CTLR_BUSY;
    ef84:	243a      	movs	r4, #58	; 0x3a
    ef86:	e093      	b.n	f0b0 <ble_ll_hci_cmd_proc+0x4b4>
static int
ble_ll_hci_le_rand(uint8_t *rspbuf, uint8_t *rsplen)
{
    int rc;

    rc = ble_ll_rand_data_get(rspbuf, BLE_HCI_LE_RAND_LEN);
    ef88:	4628      	mov	r0, r5
    ef8a:	2108      	movs	r1, #8
    ef8c:	f000 fa76 	bl	f47c <ble_ll_rand_data_get>
    *rsplen = BLE_HCI_LE_RAND_LEN;
    ef90:	2308      	movs	r3, #8
static int
ble_ll_hci_le_rand(uint8_t *rspbuf, uint8_t *rsplen)
{
    int rc;

    rc = ble_ll_rand_data_get(rspbuf, BLE_HCI_LE_RAND_LEN);
    ef92:	4604      	mov	r4, r0
    ef94:	e00b      	b.n	efae <ble_ll_hci_cmd_proc+0x3b2>
    case BLE_HCI_OCF_LE_RAND:
        rc = ble_ll_hci_le_rand(rspbuf, rsplen);
        break;
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    case BLE_HCI_OCF_LE_START_ENCRYPT:
        rc = ble_ll_conn_hci_le_start_encrypt(cmdbuf);
    ef96:	4608      	mov	r0, r1
    ef98:	f7fe fec5 	bl	dd26 <ble_ll_conn_hci_le_start_encrypt>
    ef9c:	e06b      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY:
    case BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY:
        rc = ble_ll_conn_hci_le_ltk_reply(cmdbuf, rspbuf, ocf);
    ef9e:	4608      	mov	r0, r1
    efa0:	fa5f f288 	uxtb.w	r2, r8
    efa4:	4629      	mov	r1, r5
    efa6:	f7fe feed 	bl	dd84 <ble_ll_conn_hci_le_ltk_reply>
        *rsplen = sizeof(uint16_t);
    efaa:	2302      	movs	r3, #2
    case BLE_HCI_OCF_LE_START_ENCRYPT:
        rc = ble_ll_conn_hci_le_start_encrypt(cmdbuf);
        break;
    case BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY:
    case BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY:
        rc = ble_ll_conn_hci_le_ltk_reply(cmdbuf, rspbuf, ocf);
    efac:	4604      	mov	r4, r0
        *rsplen = sizeof(uint16_t);
    efae:	f88d 3007 	strb.w	r3, [sp, #7]
    efb2:	e07d      	b.n	f0b0 <ble_ll_hci_cmd_proc+0x4b4>
ble_ll_hci_le_read_supp_states(uint8_t *rspbuf, uint8_t *rsplen)
{
    uint64_t supp_states;

    /* Add list of supported states. */
    supp_states = ble_ll_read_supp_states();
    efb4:	f7fc f8a8 	bl	b108 <ble_ll_read_supp_states>
    efb8:	4602      	mov	r2, r0
    efba:	460b      	mov	r3, r1
    htole64(rspbuf, supp_states);
    efbc:	4628      	mov	r0, r5
    efbe:	f00e f857 	bl	1d070 <htole64>
    efc2:	e06e      	b.n	f0a2 <ble_ll_hci_cmd_proc+0x4a6>
#endif
    case BLE_HCI_OCF_LE_RD_SUPP_STATES :
        rc = ble_ll_hci_le_read_supp_states(rspbuf, rsplen);
        break;
    case BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR:
        rc = ble_ll_conn_hci_param_reply(cmdbuf, 0);
    efc4:	4608      	mov	r0, r1
    efc6:	2100      	movs	r1, #0
    efc8:	e001      	b.n	efce <ble_ll_hci_cmd_proc+0x3d2>
        break;
    case BLE_HCI_OCF_LE_REM_CONN_PARAM_RR:
        rc = ble_ll_conn_hci_param_reply(cmdbuf, 1);
    efca:	4608      	mov	r0, r1
    efcc:	2101      	movs	r1, #1
    efce:	f7fe fd45 	bl	da5c <ble_ll_conn_hci_param_reply>
    efd2:	e050      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
#if (BLE_LL_CFG_FEAT_DATA_LEN_EXT == 1)
    case BLE_HCI_OCF_LE_SET_DATA_LEN:
        rc = ble_ll_conn_hci_set_data_len(cmdbuf, rspbuf, rsplen);
    efd4:	4608      	mov	r0, r1
    efd6:	f10d 0207 	add.w	r2, sp, #7
    efda:	4629      	mov	r1, r5
    efdc:	f7fe fe78 	bl	dcd0 <ble_ll_conn_hci_set_data_len>
    efe0:	e049      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
 */
static int
ble_ll_hci_le_rd_sugg_data_len(uint8_t *rspbuf, uint8_t *rsplen)
{
    /* Place the data packet length and number of packets in the buffer */
    htole16(rspbuf, g_ble_ll_conn_params.sugg_tx_octets);
    efe2:	4c55      	ldr	r4, [pc, #340]	; (f138 <ble_ll_hci_cmd_proc+0x53c>)
    efe4:	4628      	mov	r0, r5
    efe6:	7a61      	ldrb	r1, [r4, #9]
    efe8:	f00e f836 	bl	1d058 <htole16>
    htole16(rspbuf + 2, g_ble_ll_conn_params.sugg_tx_time);
    efec:	f106 0008 	add.w	r0, r6, #8
    eff0:	8961      	ldrh	r1, [r4, #10]
    eff2:	f00e f831 	bl	1d058 <htole16>
    *rsplen = BLE_HCI_RD_SUGG_DATALEN_RSPLEN;
    eff6:	2304      	movs	r3, #4
    eff8:	e054      	b.n	f0a4 <ble_ll_hci_cmd_proc+0x4a8>
    int rc;
    uint16_t tx_oct;
    uint16_t tx_time;

    /* Get suggested octets and time */
    tx_oct = le16toh(cmdbuf);
    effa:	4608      	mov	r0, r1
    effc:	f00e f847 	bl	1d08e <le16toh>
    f000:	4605      	mov	r5, r0
    tx_time = le16toh(cmdbuf + 2);
    f002:	1d70      	adds	r0, r6, #5
    f004:	f00e f843 	bl	1d08e <le16toh>
    f008:	4604      	mov	r4, r0

    /* If valid, write into suggested and change connection initial times */
    if (ble_ll_chk_txrx_octets(tx_oct) && ble_ll_chk_txrx_time(tx_time)) {
    f00a:	4628      	mov	r0, r5
    f00c:	f7fb ff14 	bl	ae38 <ble_ll_chk_txrx_octets>
    f010:	b340      	cbz	r0, f064 <ble_ll_hci_cmd_proc+0x468>
    f012:	4620      	mov	r0, r4
    f014:	f7fb ff16 	bl	ae44 <ble_ll_chk_txrx_time>
    f018:	b320      	cbz	r0, f064 <ble_ll_hci_cmd_proc+0x468>
        g_ble_ll_conn_params.sugg_tx_octets = (uint8_t)tx_oct;
    f01a:	4b47      	ldr	r3, [pc, #284]	; (f138 <ble_ll_hci_cmd_proc+0x53c>)
        g_ble_ll_conn_params.sugg_tx_time = tx_time;

        if ((tx_time <= g_ble_ll_conn_params.supp_max_tx_time) &&
    f01c:	89d9      	ldrh	r1, [r3, #14]
    tx_time = le16toh(cmdbuf + 2);

    /* If valid, write into suggested and change connection initial times */
    if (ble_ll_chk_txrx_octets(tx_oct) && ble_ll_chk_txrx_time(tx_time)) {
        g_ble_ll_conn_params.sugg_tx_octets = (uint8_t)tx_oct;
        g_ble_ll_conn_params.sugg_tx_time = tx_time;
    f01e:	815c      	strh	r4, [r3, #10]
    tx_oct = le16toh(cmdbuf);
    tx_time = le16toh(cmdbuf + 2);

    /* If valid, write into suggested and change connection initial times */
    if (ble_ll_chk_txrx_octets(tx_oct) && ble_ll_chk_txrx_time(tx_time)) {
        g_ble_ll_conn_params.sugg_tx_octets = (uint8_t)tx_oct;
    f020:	b2ea      	uxtb	r2, r5
        g_ble_ll_conn_params.sugg_tx_time = tx_time;

        if ((tx_time <= g_ble_ll_conn_params.supp_max_tx_time) &&
    f022:	42a1      	cmp	r1, r4
    tx_oct = le16toh(cmdbuf);
    tx_time = le16toh(cmdbuf + 2);

    /* If valid, write into suggested and change connection initial times */
    if (ble_ll_chk_txrx_octets(tx_oct) && ble_ll_chk_txrx_time(tx_time)) {
        g_ble_ll_conn_params.sugg_tx_octets = (uint8_t)tx_oct;
    f024:	725a      	strb	r2, [r3, #9]
        g_ble_ll_conn_params.sugg_tx_time = tx_time;

        if ((tx_time <= g_ble_ll_conn_params.supp_max_tx_time) &&
    f026:	d342      	bcc.n	f0ae <ble_ll_hci_cmd_proc+0x4b2>
    f028:	7999      	ldrb	r1, [r3, #6]
    f02a:	42a9      	cmp	r1, r5
    f02c:	d33f      	bcc.n	f0ae <ble_ll_hci_cmd_proc+0x4b2>
            (tx_oct <= g_ble_ll_conn_params.supp_max_tx_octets)) {
            g_ble_ll_conn_params.conn_init_max_tx_octets = tx_oct;
    f02e:	721a      	strb	r2, [r3, #8]
            g_ble_ll_conn_params.conn_init_max_tx_time = tx_time;
    f030:	819c      	strh	r4, [r3, #12]
    f032:	e03c      	b.n	f0ae <ble_ll_hci_cmd_proc+0x4b2>
        rc = ble_ll_hci_le_wr_sugg_data_len(cmdbuf);
        break;
#endif
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    case BLE_HCI_OCF_LE_ADD_RESOLV_LIST :
        rc = ble_ll_resolv_list_add(cmdbuf);
    f034:	4608      	mov	r0, r1
    f036:	f000 fb13 	bl	f660 <ble_ll_resolv_list_add>
    f03a:	e01c      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RMV_RESOLV_LIST:
        rc = ble_ll_resolv_list_rmv(cmdbuf);
    f03c:	4608      	mov	r0, r1
    f03e:	f000 fb57 	bl	f6f0 <ble_ll_resolv_list_rmv>
    f042:	e018      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_CLR_RESOLV_LIST:
        rc = ble_ll_resolv_list_clr();
    f044:	f000 fad2 	bl	f5ec <ble_ll_resolv_list_clr>
    f048:	e015      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE:
        rc = ble_ll_resolv_list_read_size(rspbuf, rsplen);
    f04a:	4628      	mov	r0, r5
    f04c:	f10d 0107 	add.w	r1, sp, #7
    f050:	f000 fadc 	bl	f60c <ble_ll_resolv_list_read_size>
    f054:	e00f      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR:
        rc = ble_ll_resolv_peer_addr_rd(cmdbuf);
    f056:	4608      	mov	r0, r1
    f058:	f000 fb8a 	bl	f770 <ble_ll_resolv_peer_addr_rd>
    f05c:	e00b      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR:
        ble_ll_resolv_local_addr_rd(cmdbuf);
    f05e:	4608      	mov	r0, r1
    f060:	f000 fb88 	bl	f774 <ble_ll_resolv_local_addr_rd>
    uint8_t cmdlen;
    uint8_t len;
    uint8_t *rspbuf;

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    f064:	2412      	movs	r4, #18
    f066:	e023      	b.n	f0b0 <ble_ll_hci_cmd_proc+0x4b4>
        break;
    case BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR:
        ble_ll_resolv_local_addr_rd(cmdbuf);
        break;
    case BLE_HCI_OCF_LE_SET_ADDR_RES_EN:
        rc = ble_ll_resolv_enable_cmd(cmdbuf);
    f068:	4608      	mov	r0, r1
    f06a:	f000 fb69 	bl	f740 <ble_ll_resolv_enable_cmd>
    f06e:	e002      	b.n	f076 <ble_ll_hci_cmd_proc+0x47a>
        break;
    case BLE_HCI_OCF_LE_SET_RPA_TMO:
        rc = ble_ll_resolv_set_rpa_tmo(cmdbuf);
    f070:	4608      	mov	r0, r1
    f072:	f000 fb81 	bl	f778 <ble_ll_resolv_set_rpa_tmo>
    f076:	4604      	mov	r4, r0
    f078:	e01a      	b.n	f0b0 <ble_ll_hci_cmd_proc+0x4b4>
 */
static int
ble_ll_hci_le_rd_max_data_len(uint8_t *rspbuf, uint8_t *rsplen)
{
    /* Place the data packet length and number of packets in the buffer */
    htole16(rspbuf, g_ble_ll_conn_params.supp_max_tx_octets);
    f07a:	4c2f      	ldr	r4, [pc, #188]	; (f138 <ble_ll_hci_cmd_proc+0x53c>)
    f07c:	4628      	mov	r0, r5
    f07e:	79a1      	ldrb	r1, [r4, #6]
    f080:	f00d ffea 	bl	1d058 <htole16>
    htole16(rspbuf + 2, g_ble_ll_conn_params.supp_max_tx_time);
    f084:	f106 0008 	add.w	r0, r6, #8
    f088:	89e1      	ldrh	r1, [r4, #14]
    f08a:	f00d ffe5 	bl	1d058 <htole16>
    htole16(rspbuf + 4, g_ble_ll_conn_params.supp_max_rx_octets);
    f08e:	f106 000a 	add.w	r0, r6, #10
    f092:	79e1      	ldrb	r1, [r4, #7]
    f094:	f00d ffe0 	bl	1d058 <htole16>
    htole16(rspbuf + 6, g_ble_ll_conn_params.supp_max_rx_time);
    f098:	f106 000c 	add.w	r0, r6, #12
    f09c:	8a21      	ldrh	r1, [r4, #16]
    f09e:	f00d ffdb 	bl	1d058 <htole16>
    *rsplen = BLE_HCI_RD_MAX_DATALEN_RSPLEN;
    f0a2:	2308      	movs	r3, #8
    f0a4:	f88d 3007 	strb.w	r3, [sp, #7]
    f0a8:	e001      	b.n	f0ae <ble_ll_hci_cmd_proc+0x4b2>
#endif
    case BLE_HCI_OCF_LE_RD_MAX_DATA_LEN:
        rc = ble_ll_hci_le_rd_max_data_len(rspbuf, rsplen);
        break;
    default:
        rc = BLE_ERR_UNKNOWN_HCI_CMD;
    f0aa:	2401      	movs	r4, #1
    f0ac:	e000      	b.n	f0b0 <ble_ll_hci_cmd_proc+0x4b4>
        if ((tx_time <= g_ble_ll_conn_params.supp_max_tx_time) &&
            (tx_oct <= g_ble_ll_conn_params.supp_max_tx_octets)) {
            g_ble_ll_conn_params.conn_init_max_tx_octets = tx_oct;
            g_ble_ll_conn_params.conn_init_max_tx_time = tx_time;
        }
        rc = BLE_ERR_SUCCESS;
    f0ae:	2400      	movs	r4, #0
    f0b0:	f1a8 030d 	sub.w	r3, r8, #13
    f0b4:	b29b      	uxth	r3, r3
    f0b6:	2b19      	cmp	r3, #25
    f0b8:	d804      	bhi.n	f0c4 <ble_ll_hci_cmd_proc+0x4c8>
    f0ba:	2201      	movs	r2, #1
    f0bc:	409a      	lsls	r2, r3
    f0be:	4b1f      	ldr	r3, [pc, #124]	; (f13c <ble_ll_hci_cmd_proc+0x540>)
    f0c0:	4013      	ands	r3, r2
    f0c2:	bb8b      	cbnz	r3, f128 <ble_ll_hci_cmd_proc+0x52c>
        rc = BLE_ERR_UNKNOWN_HCI_CMD;
        break;
    }

    /* If no response is generated, we free the buffers */
    assert(rc >= 0);
    f0c4:	2c00      	cmp	r4, #0
    f0c6:	da03      	bge.n	f0d0 <ble_ll_hci_cmd_proc+0x4d4>
    f0c8:	481d      	ldr	r0, [pc, #116]	; (f140 <ble_ll_hci_cmd_proc+0x544>)
    f0ca:	f44f 716f 	mov.w	r1, #956	; 0x3bc
    f0ce:	e5a8      	b.n	ec22 <ble_ll_hci_cmd_proc+0x26>
    if (rc <= BLE_ERR_MAX) {
    f0d0:	2cff      	cmp	r4, #255	; 0xff
    f0d2:	dc0d      	bgt.n	f0f0 <ble_ll_hci_cmd_proc+0x4f4>
        /* Create a command complete event with status from command */
        cmdbuf[0] = BLE_HCI_EVCODE_COMMAND_COMPLETE;
    f0d4:	230e      	movs	r3, #14
    f0d6:	7033      	strb	r3, [r6, #0]
        cmdbuf[1] = 4 + rsplen;
    f0d8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f0dc:	3304      	adds	r3, #4
    f0de:	7073      	strb	r3, [r6, #1]
        cmdbuf[2] = ble_ll_hci_get_num_cmd_pkts();
    f0e0:	2301      	movs	r3, #1
    f0e2:	70b3      	strb	r3, [r6, #2]
        htole16(cmdbuf + 3, opcode);
    f0e4:	1cf0      	adds	r0, r6, #3
    f0e6:	4639      	mov	r1, r7
    f0e8:	f00d ffb6 	bl	1d058 <htole16>
        cmdbuf[5] = (uint8_t)rc;
    f0ec:	7174      	strb	r4, [r6, #5]
    f0ee:	e00c      	b.n	f10a <ble_ll_hci_cmd_proc+0x50e>
    } else {
        /* Create a command status event */
        rc -= (BLE_ERR_MAX + 1);
        cmdbuf[0] = BLE_HCI_EVCODE_COMMAND_STATUS;
    f0f0:	230f      	movs	r3, #15
    f0f2:	7033      	strb	r3, [r6, #0]
        cmdbuf[1] = 4;
    f0f4:	2304      	movs	r3, #4
        cmdbuf[2] = ble_ll_hci_get_num_cmd_pkts();
        htole16(cmdbuf + 3, opcode);
        cmdbuf[5] = (uint8_t)rc;
    } else {
        /* Create a command status event */
        rc -= (BLE_ERR_MAX + 1);
    f0f6:	f5a4 7480 	sub.w	r4, r4, #256	; 0x100
        cmdbuf[0] = BLE_HCI_EVCODE_COMMAND_STATUS;
        cmdbuf[1] = 4;
    f0fa:	7073      	strb	r3, [r6, #1]
        cmdbuf[2] = (uint8_t)rc;
        cmdbuf[3] = ble_ll_hci_get_num_cmd_pkts();
    f0fc:	2301      	movs	r3, #1
    } else {
        /* Create a command status event */
        rc -= (BLE_ERR_MAX + 1);
        cmdbuf[0] = BLE_HCI_EVCODE_COMMAND_STATUS;
        cmdbuf[1] = 4;
        cmdbuf[2] = (uint8_t)rc;
    f0fe:	70b4      	strb	r4, [r6, #2]
        cmdbuf[3] = ble_ll_hci_get_num_cmd_pkts();
    f100:	70f3      	strb	r3, [r6, #3]
        htole16(cmdbuf + 4, opcode);
    f102:	1d30      	adds	r0, r6, #4
    f104:	4639      	mov	r1, r7
    f106:	f00d ffa7 	bl	1d058 <htole16>
    f10a:	4b0e      	ldr	r3, [pc, #56]	; (f144 <ble_ll_hci_cmd_proc+0x548>)
    }

    /* Count commands and those in error */
    if (rc) {
    f10c:	b11c      	cbz	r4, f116 <ble_ll_hci_cmd_proc+0x51a>
        STATS_INC(ble_ll_stats, hci_cmd_errs);
    f10e:	691a      	ldr	r2, [r3, #16]
    f110:	3201      	adds	r2, #1
    f112:	611a      	str	r2, [r3, #16]
    f114:	e002      	b.n	f11c <ble_ll_hci_cmd_proc+0x520>
    } else {
        STATS_INC(ble_ll_stats, hci_cmds);
    f116:	68da      	ldr	r2, [r3, #12]
    f118:	3201      	adds	r2, #1
    f11a:	60da      	str	r2, [r3, #12]
    }

    /* Send the event (events cannot be masked) */
    ble_ll_hci_event_send(cmdbuf);
    f11c:	4630      	mov	r0, r6
    f11e:	f7ff fd1b 	bl	eb58 <ble_ll_hci_event_send>
}
    f122:	b00e      	add	sp, #56	; 0x38
    f124:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     * that the reply to this command should be command status (as opposed to
     * command complete).
     */
ll_hci_le_cmd_exit:
    if (ble_ll_hci_le_cmd_send_cmd_status(ocf)) {
        rc += (BLE_ERR_MAX + 1);
    f128:	f504 7480 	add.w	r4, r4, #256	; 0x100
    f12c:	e7ca      	b.n	f0c4 <ble_ll_hci_cmd_proc+0x4c8>
        if (len == sizeof(uint16_t)) {
            rc = ble_ll_conn_hci_rd_rssi(cmdbuf, rspbuf, rsplen);
        }
        break;
    default:
        rc = BLE_ERR_UNKNOWN_HCI_CMD;
    f12e:	2401      	movs	r4, #1
    f130:	e7d0      	b.n	f0d4 <ble_ll_hci_cmd_proc+0x4d8>
#if (BLE_LL_CFG_FEAT_LE_PING == 1)
    uint8_t *rspbuf;
#endif

    /* Assume error; if all pass rc gets set to 0 */
    rc = BLE_ERR_INV_HCI_CMD_PARMS;
    f132:	2412      	movs	r4, #18
    f134:	e7ce      	b.n	f0d4 <ble_ll_hci_cmd_proc+0x4d8>
    f136:	bf00      	nop
    f138:	200033b8 	.word	0x200033b8
    f13c:	03001241 	.word	0x03001241
    f140:	0001f2c6 	.word	0x0001f2c6
    f144:	200030ac 	.word	0x200030ac

0000f148 <ble_hci_transport_host_cmd_send>:
 * @return                      0 on success;
 *                              BLE_ERR_MEM_CAPACITY on HCI buffer exhaustion.
 */
int
ble_hci_transport_host_cmd_send(uint8_t *cmd)
{
    f148:	b538      	push	{r3, r4, r5, lr}
    f14a:	4605      	mov	r5, r0
    struct os_event *ev;

    /* Get an event structure off the queue */
    ev = (struct os_event *)os_memblock_get(&g_hci_os_event_pool);
    f14c:	4808      	ldr	r0, [pc, #32]	; (f170 <ble_hci_transport_host_cmd_send+0x28>)
    f14e:	f7fb f953 	bl	a3f8 <os_memblock_get>
    if (!ev) {
    f152:	4601      	mov	r1, r0
    f154:	b148      	cbz	r0, f16a <ble_hci_transport_host_cmd_send+0x22>
        return BLE_ERR_MEM_CAPACITY;
    }

    /* Fill out the event and post to Link Layer */
    ev->ev_queued = 0;
    f156:	2400      	movs	r4, #0
    ev->ev_type = BLE_LL_EVENT_HCI_CMD;
    f158:	2310      	movs	r3, #16
    if (!ev) {
        return BLE_ERR_MEM_CAPACITY;
    }

    /* Fill out the event and post to Link Layer */
    ev->ev_queued = 0;
    f15a:	7004      	strb	r4, [r0, #0]
    ev->ev_type = BLE_LL_EVENT_HCI_CMD;
    f15c:	7043      	strb	r3, [r0, #1]
    ev->ev_arg = cmd;
    f15e:	6045      	str	r5, [r0, #4]
    os_eventq_put(&g_ble_ll_data.ll_evq, ev);
    f160:	4804      	ldr	r0, [pc, #16]	; (f174 <ble_hci_transport_host_cmd_send+0x2c>)
    f162:	f7fa fd46 	bl	9bf2 <os_eventq_put>

    return 0;
    f166:	4620      	mov	r0, r4
    f168:	bd38      	pop	{r3, r4, r5, pc}
    struct os_event *ev;

    /* Get an event structure off the queue */
    ev = (struct os_event *)os_memblock_get(&g_hci_os_event_pool);
    if (!ev) {
        return BLE_ERR_MEM_CAPACITY;
    f16a:	2007      	movs	r0, #7
    ev->ev_type = BLE_LL_EVENT_HCI_CMD;
    ev->ev_arg = cmd;
    os_eventq_put(&g_ble_ll_data.ll_evq, ev);

    return 0;
}
    f16c:	bd38      	pop	{r3, r4, r5, pc}
    f16e:	bf00      	nop
    f170:	20003b40 	.word	0x20003b40
    f174:	200032c8 	.word	0x200032c8

0000f178 <ble_hci_transport_host_acl_data_send>:

/* Send ACL data from host to contoller */
int
ble_hci_transport_host_acl_data_send(struct os_mbuf *om)
{
    f178:	b508      	push	{r3, lr}
    ble_ll_acl_data_in(om);
    f17a:	f7fb feed 	bl	af58 <ble_ll_acl_data_in>
    return 0;
}
    f17e:	2000      	movs	r0, #0
    f180:	bd08      	pop	{r3, pc}
	...

0000f184 <ble_ll_hci_init>:
 */
void
ble_ll_hci_init(void)
{
    /* Set defaults for LE events: Vol 2 Part E 7.8.1 */
    g_ble_ll_hci_le_event_mask[0] = 0x1f;
    f184:	4b07      	ldr	r3, [pc, #28]	; (f1a4 <ble_ll_hci_init+0x20>)
    g_ble_ll_hci_event_mask[3] = 0xff;
    g_ble_ll_hci_event_mask[4] = 0xff;
    g_ble_ll_hci_event_mask[5] = 0x1f;

    /* Set page 2 to 0 */
    memset(g_ble_ll_hci_event_mask2, 0, BLE_HCI_SET_EVENT_MASK_LEN);
    f186:	4808      	ldr	r0, [pc, #32]	; (f1a8 <ble_ll_hci_init+0x24>)
 */
void
ble_ll_hci_init(void)
{
    /* Set defaults for LE events: Vol 2 Part E 7.8.1 */
    g_ble_ll_hci_le_event_mask[0] = 0x1f;
    f188:	211f      	movs	r1, #31
    f18a:	7019      	strb	r1, [r3, #0]

    /* Set defaults for controller/baseband events: Vol 2 Part E 7.3.1 */
    g_ble_ll_hci_event_mask[0] = 0xff;
    f18c:	4b07      	ldr	r3, [pc, #28]	; (f1ac <ble_ll_hci_init+0x28>)
    f18e:	22ff      	movs	r2, #255	; 0xff
    f190:	701a      	strb	r2, [r3, #0]
    g_ble_ll_hci_event_mask[1] = 0xff;
    f192:	705a      	strb	r2, [r3, #1]
    g_ble_ll_hci_event_mask[2] = 0xff;
    f194:	709a      	strb	r2, [r3, #2]
    g_ble_ll_hci_event_mask[3] = 0xff;
    f196:	70da      	strb	r2, [r3, #3]
    g_ble_ll_hci_event_mask[4] = 0xff;
    f198:	711a      	strb	r2, [r3, #4]
    g_ble_ll_hci_event_mask[5] = 0x1f;
    f19a:	7159      	strb	r1, [r3, #5]

    /* Set page 2 to 0 */
    memset(g_ble_ll_hci_event_mask2, 0, BLE_HCI_SET_EVENT_MASK_LEN);
    f19c:	2208      	movs	r2, #8
    f19e:	2100      	movs	r1, #0
    f1a0:	f7f9 bf37 	b.w	9012 <memset>
    f1a4:	20001ea8 	.word	0x20001ea8
    f1a8:	20001e98 	.word	0x20001e98
    f1ac:	20001ea0 	.word	0x20001ea0

0000f1b0 <ble_ll_hci_ev_datalen_chg>:
 *
 * @param connsm Pointer to connection state machine
 */
void
ble_ll_hci_ev_datalen_chg(struct ble_ll_conn_sm *connsm)
{
    f1b0:	b538      	push	{r3, r4, r5, lr}
    f1b2:	4605      	mov	r5, r0
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_DATA_LEN_CHG)) {
    f1b4:	2007      	movs	r0, #7
    f1b6:	f7ff fcf1 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
    f1ba:	b328      	cbz	r0, f208 <ble_ll_hci_ev_datalen_chg+0x58>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    f1bc:	4813      	ldr	r0, [pc, #76]	; (f20c <ble_ll_hci_ev_datalen_chg+0x5c>)
    f1be:	f7fb f91b 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    f1c2:	4604      	mov	r4, r0
    f1c4:	b300      	cbz	r0, f208 <ble_ll_hci_ev_datalen_chg+0x58>
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
    f1c6:	233e      	movs	r3, #62	; 0x3e
    f1c8:	7003      	strb	r3, [r0, #0]
            evbuf[1] = BLE_HCI_LE_DATA_LEN_CHG_LEN;
    f1ca:	230b      	movs	r3, #11
    f1cc:	7043      	strb	r3, [r0, #1]
            evbuf[2] = BLE_HCI_LE_SUBEV_DATA_LEN_CHG;
    f1ce:	2307      	movs	r3, #7
    f1d0:	7083      	strb	r3, [r0, #2]
            htole16(evbuf + 3, connsm->conn_handle);
    f1d2:	88a9      	ldrh	r1, [r5, #4]
    f1d4:	3003      	adds	r0, #3
    f1d6:	f00d ff3f 	bl	1d058 <htole16>
            htole16(evbuf + 5, connsm->eff_max_tx_octets);
    f1da:	1d60      	adds	r0, r4, #5
    f1dc:	7b29      	ldrb	r1, [r5, #12]
    f1de:	f00d ff3b 	bl	1d058 <htole16>
            htole16(evbuf + 7, connsm->eff_max_tx_time);
    f1e2:	1de0      	adds	r0, r4, #7
    f1e4:	8ae9      	ldrh	r1, [r5, #22]
    f1e6:	f00d ff37 	bl	1d058 <htole16>
            htole16(evbuf + 9, connsm->eff_max_rx_octets);
    f1ea:	f104 0009 	add.w	r0, r4, #9
    f1ee:	7b69      	ldrb	r1, [r5, #13]
    f1f0:	f00d ff32 	bl	1d058 <htole16>
            htole16(evbuf + 11, connsm->eff_max_rx_time);
    f1f4:	f104 000b 	add.w	r0, r4, #11
    f1f8:	8b29      	ldrh	r1, [r5, #24]
    f1fa:	f00d ff2d 	bl	1d058 <htole16>
            ble_ll_hci_event_send(evbuf);
    f1fe:	4620      	mov	r0, r4
        }
    }
}
    f200:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            htole16(evbuf + 3, connsm->conn_handle);
            htole16(evbuf + 5, connsm->eff_max_tx_octets);
            htole16(evbuf + 7, connsm->eff_max_tx_time);
            htole16(evbuf + 9, connsm->eff_max_rx_octets);
            htole16(evbuf + 11, connsm->eff_max_rx_time);
            ble_ll_hci_event_send(evbuf);
    f204:	f7ff bca8 	b.w	eb58 <ble_ll_hci_event_send>
    f208:	bd38      	pop	{r3, r4, r5, pc}
    f20a:	bf00      	nop
    f20c:	20003b5c 	.word	0x20003b5c

0000f210 <ble_ll_hci_ev_rem_conn_parm_req>:
 * @param connsm Pointer to connection state machine
 */
void
ble_ll_hci_ev_rem_conn_parm_req(struct ble_ll_conn_sm *connsm,
                                struct ble_ll_conn_params *cp)
{
    f210:	b570      	push	{r4, r5, r6, lr}
    f212:	4606      	mov	r6, r0
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ)) {
    f214:	2006      	movs	r0, #6
 * @param connsm Pointer to connection state machine
 */
void
ble_ll_hci_ev_rem_conn_parm_req(struct ble_ll_conn_sm *connsm,
                                struct ble_ll_conn_params *cp)
{
    f216:	460d      	mov	r5, r1
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ)) {
    f218:	f7ff fcc0 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
    f21c:	b328      	cbz	r0, f26a <ble_ll_hci_ev_rem_conn_parm_req+0x5a>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    f21e:	4813      	ldr	r0, [pc, #76]	; (f26c <ble_ll_hci_ev_rem_conn_parm_req+0x5c>)
    f220:	f7fb f8ea 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    f224:	4604      	mov	r4, r0
    f226:	b300      	cbz	r0, f26a <ble_ll_hci_ev_rem_conn_parm_req+0x5a>
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
    f228:	233e      	movs	r3, #62	; 0x3e
    f22a:	7003      	strb	r3, [r0, #0]
            evbuf[1] = BLE_HCI_LE_REM_CONN_PARM_REQ_LEN;
    f22c:	230b      	movs	r3, #11
    f22e:	7043      	strb	r3, [r0, #1]
            evbuf[2] = BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ;
    f230:	2306      	movs	r3, #6
    f232:	7083      	strb	r3, [r0, #2]
            htole16(evbuf + 3, connsm->conn_handle);
    f234:	88b1      	ldrh	r1, [r6, #4]
    f236:	3003      	adds	r0, #3
    f238:	f00d ff0e 	bl	1d058 <htole16>
            htole16(evbuf + 5, cp->interval_min);
    f23c:	1d60      	adds	r0, r4, #5
    f23e:	8829      	ldrh	r1, [r5, #0]
    f240:	f00d ff0a 	bl	1d058 <htole16>
            htole16(evbuf + 7, cp->interval_max);
    f244:	1de0      	adds	r0, r4, #7
    f246:	8869      	ldrh	r1, [r5, #2]
    f248:	f00d ff06 	bl	1d058 <htole16>
            htole16(evbuf + 9, cp->latency);
    f24c:	f104 0009 	add.w	r0, r4, #9
    f250:	88a9      	ldrh	r1, [r5, #4]
    f252:	f00d ff01 	bl	1d058 <htole16>
            htole16(evbuf + 11, cp->timeout);
    f256:	f104 000b 	add.w	r0, r4, #11
    f25a:	88e9      	ldrh	r1, [r5, #6]
    f25c:	f00d fefc 	bl	1d058 <htole16>
            ble_ll_hci_event_send(evbuf);
    f260:	4620      	mov	r0, r4
        }
    }
}
    f262:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            htole16(evbuf + 3, connsm->conn_handle);
            htole16(evbuf + 5, cp->interval_min);
            htole16(evbuf + 7, cp->interval_max);
            htole16(evbuf + 9, cp->latency);
            htole16(evbuf + 11, cp->timeout);
            ble_ll_hci_event_send(evbuf);
    f266:	f7ff bc77 	b.w	eb58 <ble_ll_hci_event_send>
    f26a:	bd70      	pop	{r4, r5, r6, pc}
    f26c:	20003b5c 	.word	0x20003b5c

0000f270 <ble_ll_hci_ev_conn_update>:
 * @param connsm Pointer to connection state machine
 * @param status The error code.
 */
void
ble_ll_hci_ev_conn_update(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f270:	b570      	push	{r4, r5, r6, lr}
    f272:	4605      	mov	r5, r0
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE)) {
    f274:	2003      	movs	r0, #3
 * @param connsm Pointer to connection state machine
 * @param status The error code.
 */
void
ble_ll_hci_ev_conn_update(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f276:	460e      	mov	r6, r1
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE)) {
    f278:	f7ff fc90 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
    f27c:	b328      	cbz	r0, f2ca <ble_ll_hci_ev_conn_update+0x5a>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    f27e:	4813      	ldr	r0, [pc, #76]	; (f2cc <ble_ll_hci_ev_conn_update+0x5c>)
    f280:	f7fb f8ba 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    f284:	4604      	mov	r4, r0
    f286:	b300      	cbz	r0, f2ca <ble_ll_hci_ev_conn_update+0x5a>
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
    f288:	233e      	movs	r3, #62	; 0x3e
    f28a:	7003      	strb	r3, [r0, #0]
            evbuf[1] = BLE_HCI_LE_CONN_UPD_LEN;
    f28c:	230a      	movs	r3, #10
    f28e:	7043      	strb	r3, [r0, #1]
            evbuf[2] = BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE;
    f290:	2303      	movs	r3, #3
    f292:	7083      	strb	r3, [r0, #2]
            evbuf[3] = status;
    f294:	70c6      	strb	r6, [r0, #3]
            htole16(evbuf + 4, connsm->conn_handle);
    f296:	88a9      	ldrh	r1, [r5, #4]
    f298:	3004      	adds	r0, #4
    f29a:	f00d fedd 	bl	1d058 <htole16>
            htole16(evbuf + 6, connsm->conn_itvl);
    f29e:	1da0      	adds	r0, r4, #6
    f2a0:	f8b5 1060 	ldrh.w	r1, [r5, #96]	; 0x60
    f2a4:	f00d fed8 	bl	1d058 <htole16>
            htole16(evbuf + 8, connsm->slave_latency);
    f2a8:	f104 0008 	add.w	r0, r4, #8
    f2ac:	f8b5 1062 	ldrh.w	r1, [r5, #98]	; 0x62
    f2b0:	f00d fed2 	bl	1d058 <htole16>
            htole16(evbuf + 10, connsm->supervision_tmo);
    f2b4:	f104 000a 	add.w	r0, r4, #10
    f2b8:	f8b5 1064 	ldrh.w	r1, [r5, #100]	; 0x64
    f2bc:	f00d fecc 	bl	1d058 <htole16>
            ble_ll_hci_event_send(evbuf);
    f2c0:	4620      	mov	r0, r4
        }
    }
}
    f2c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            evbuf[3] = status;
            htole16(evbuf + 4, connsm->conn_handle);
            htole16(evbuf + 6, connsm->conn_itvl);
            htole16(evbuf + 8, connsm->slave_latency);
            htole16(evbuf + 10, connsm->supervision_tmo);
            ble_ll_hci_event_send(evbuf);
    f2c6:	f7ff bc47 	b.w	eb58 <ble_ll_hci_event_send>
    f2ca:	bd70      	pop	{r4, r5, r6, pc}
    f2cc:	20003b5c 	.word	0x20003b5c

0000f2d0 <ble_ll_hci_ev_encrypt_chg>:
}

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
void
ble_ll_hci_ev_encrypt_chg(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f2d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t evcode;
    uint8_t *evbuf;
    uint8_t evlen;

    if (CONN_F_ENC_CHANGE_SENT(connsm) == 0) {
    f2d4:	7883      	ldrb	r3, [r0, #2]
    f2d6:	f003 0302 	and.w	r3, r3, #2
        evcode = BLE_HCI_EVCODE_ENCRYPT_CHG;
        evlen = BLE_HCI_EVENT_ENCRYPT_CHG_LEN;
    } else {
        evcode = BLE_HCI_EVCODE_ENC_KEY_REFRESH;
        evlen = BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN;
    f2da:	2b00      	cmp	r3, #0
    f2dc:	bf0c      	ite	eq
    f2de:	2608      	moveq	r6, #8
    f2e0:	2630      	movne	r6, #48	; 0x30
}

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
void
ble_ll_hci_ev_encrypt_chg(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f2e2:	4605      	mov	r5, r0
    } else {
        evcode = BLE_HCI_EVCODE_ENC_KEY_REFRESH;
        evlen = BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN;
    }

    if (ble_ll_hci_is_event_enabled(evcode)) {
    f2e4:	4630      	mov	r0, r6
    if (CONN_F_ENC_CHANGE_SENT(connsm) == 0) {
        evcode = BLE_HCI_EVCODE_ENCRYPT_CHG;
        evlen = BLE_HCI_EVENT_ENCRYPT_CHG_LEN;
    } else {
        evcode = BLE_HCI_EVCODE_ENC_KEY_REFRESH;
        evlen = BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN;
    f2e6:	bf0c      	ite	eq
    f2e8:	f04f 0804 	moveq.w	r8, #4
    f2ec:	f04f 0803 	movne.w	r8, #3
}

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
void
ble_ll_hci_ev_encrypt_chg(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f2f0:	460f      	mov	r7, r1
    } else {
        evcode = BLE_HCI_EVCODE_ENC_KEY_REFRESH;
        evlen = BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN;
    }

    if (ble_ll_hci_is_event_enabled(evcode)) {
    f2f2:	f7ff fc6d 	bl	ebd0 <ble_ll_hci_is_event_enabled>
    f2f6:	b1b0      	cbz	r0, f326 <ble_ll_hci_ev_encrypt_chg+0x56>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    f2f8:	480e      	ldr	r0, [pc, #56]	; (f334 <ble_ll_hci_ev_encrypt_chg+0x64>)
    f2fa:	f7fb f87d 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    f2fe:	4604      	mov	r4, r0
    f300:	b188      	cbz	r0, f326 <ble_ll_hci_ev_encrypt_chg+0x56>
            evbuf[0] = evcode;
    f302:	7006      	strb	r6, [r0, #0]
            evbuf[1] = evlen;
    f304:	f880 8001 	strb.w	r8, [r0, #1]
            evbuf[2] = status;
    f308:	7087      	strb	r7, [r0, #2]
            htole16(evbuf + 3, connsm->conn_handle);
    f30a:	88a9      	ldrh	r1, [r5, #4]
    f30c:	3003      	adds	r0, #3
    f30e:	f00d fea3 	bl	1d058 <htole16>
            if (evcode == BLE_HCI_EVCODE_ENCRYPT_CHG) {
    f312:	2e08      	cmp	r6, #8
    f314:	d104      	bne.n	f320 <ble_ll_hci_ev_encrypt_chg+0x50>
                if (status == BLE_ERR_SUCCESS) {
    f316:	b90f      	cbnz	r7, f31c <ble_ll_hci_ev_encrypt_chg+0x4c>
                    evbuf[5] = 0x01;
    f318:	2301      	movs	r3, #1
    f31a:	e000      	b.n	f31e <ble_ll_hci_ev_encrypt_chg+0x4e>
                } else {
                    evbuf[5] = 0;
    f31c:	2300      	movs	r3, #0
    f31e:	7163      	strb	r3, [r4, #5]
                }
            }
            ble_ll_hci_event_send(evbuf);
    f320:	4620      	mov	r0, r4
    f322:	f7ff fc19 	bl	eb58 <ble_ll_hci_event_send>
        }
    }
    CONN_F_ENC_CHANGE_SENT(connsm) = 1;
    f326:	78ab      	ldrb	r3, [r5, #2]
    f328:	f043 0302 	orr.w	r3, r3, #2
    f32c:	70ab      	strb	r3, [r5, #2]
    f32e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f332:	bf00      	nop
    f334:	20003b5c 	.word	0x20003b5c

0000f338 <ble_ll_hci_ev_ltk_req>:
 *
 * @param connsm Pointer to connection state machine
 */
int
ble_ll_hci_ev_ltk_req(struct ble_ll_conn_sm *connsm)
{
    f338:	b538      	push	{r3, r4, r5, lr}
    f33a:	4605      	mov	r5, r0
    int rc;
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_LT_KEY_REQ)) {
    f33c:	2005      	movs	r0, #5
    f33e:	f7ff fc2d 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
    f342:	b300      	cbz	r0, f386 <ble_ll_hci_ev_ltk_req+0x4e>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    f344:	4811      	ldr	r0, [pc, #68]	; (f38c <ble_ll_hci_ev_ltk_req+0x54>)
    f346:	f7fb f857 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    f34a:	4604      	mov	r4, r0
    f34c:	b1c8      	cbz	r0, f382 <ble_ll_hci_ev_ltk_req+0x4a>
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
    f34e:	233e      	movs	r3, #62	; 0x3e
    f350:	7003      	strb	r3, [r0, #0]
            evbuf[1] = BLE_HCI_LE_LT_KEY_REQ_LEN;
    f352:	230d      	movs	r3, #13
    f354:	7043      	strb	r3, [r0, #1]
            evbuf[2] = BLE_HCI_LE_SUBEV_LT_KEY_REQ;
    f356:	2305      	movs	r3, #5
    f358:	7083      	strb	r3, [r0, #2]
            htole16(evbuf + 3, connsm->conn_handle);
    f35a:	88a9      	ldrh	r1, [r5, #4]
    f35c:	3003      	adds	r0, #3
    f35e:	f00d fe7b 	bl	1d058 <htole16>
            htole64(evbuf + 5, connsm->enc_data.host_rand_num);
    f362:	f505 7394 	add.w	r3, r5, #296	; 0x128
    f366:	1d60      	adds	r0, r4, #5
    f368:	e9d3 2300 	ldrd	r2, r3, [r3]
    f36c:	f00d fe80 	bl	1d070 <htole64>
            htole16(evbuf + 13, connsm->enc_data.enc_div);
    f370:	f104 000d 	add.w	r0, r4, #13
    f374:	f8b5 1122 	ldrh.w	r1, [r5, #290]	; 0x122
    f378:	f00d fe6e 	bl	1d058 <htole16>
            ble_ll_hci_event_send(evbuf);
    f37c:	4620      	mov	r0, r4
    f37e:	f7ff fbeb 	bl	eb58 <ble_ll_hci_event_send>
        }
        rc = 0;
    f382:	2000      	movs	r0, #0
    f384:	bd38      	pop	{r3, r4, r5, pc}
    } else {
        rc = -1;
    f386:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f38a:	bd38      	pop	{r3, r4, r5, pc}
    f38c:	20003b5c 	.word	0x20003b5c

0000f390 <ble_ll_hci_ev_rd_rem_used_feat>:
}
#endif

void
ble_ll_hci_ev_rd_rem_used_feat(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f390:	b570      	push	{r4, r5, r6, lr}
    f392:	4605      	mov	r5, r0
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT)) {
    f394:	2004      	movs	r0, #4
}
#endif

void
ble_ll_hci_ev_rd_rem_used_feat(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f396:	460e      	mov	r6, r1
    uint8_t *evbuf;

    if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT)) {
    f398:	f7ff fc00 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
    f39c:	b1e0      	cbz	r0, f3d8 <ble_ll_hci_ev_rd_rem_used_feat+0x48>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    f39e:	480f      	ldr	r0, [pc, #60]	; (f3dc <ble_ll_hci_ev_rd_rem_used_feat+0x4c>)
    f3a0:	f7fb f82a 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    f3a4:	4604      	mov	r4, r0
    f3a6:	b1b8      	cbz	r0, f3d8 <ble_ll_hci_ev_rd_rem_used_feat+0x48>
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
    f3a8:	233e      	movs	r3, #62	; 0x3e
    f3aa:	7003      	strb	r3, [r0, #0]
            evbuf[1] = BLE_HCI_LE_RD_REM_USED_FEAT_LEN;
    f3ac:	230c      	movs	r3, #12
    f3ae:	7043      	strb	r3, [r0, #1]
            evbuf[2] = BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT;
    f3b0:	2304      	movs	r3, #4
    f3b2:	7083      	strb	r3, [r0, #2]
            evbuf[3] = status;
    f3b4:	70c6      	strb	r6, [r0, #3]
            htole16(evbuf + 4, connsm->conn_handle);
    f3b6:	88a9      	ldrh	r1, [r5, #4]
    f3b8:	4418      	add	r0, r3
    f3ba:	f00d fe4d 	bl	1d058 <htole16>
            memset(evbuf + 6, 0, BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN);
    f3be:	1da0      	adds	r0, r4, #6
    f3c0:	2100      	movs	r1, #0
    f3c2:	2208      	movs	r2, #8
    f3c4:	f7f9 fe25 	bl	9012 <memset>
            evbuf[6] = connsm->common_features;
    f3c8:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
    f3cc:	71a3      	strb	r3, [r4, #6]
            ble_ll_hci_event_send(evbuf);
    f3ce:	4620      	mov	r0, r4
        }
    }
}
    f3d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            evbuf[2] = BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT;
            evbuf[3] = status;
            htole16(evbuf + 4, connsm->conn_handle);
            memset(evbuf + 6, 0, BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN);
            evbuf[6] = connsm->common_features;
            ble_ll_hci_event_send(evbuf);
    f3d4:	f7ff bbc0 	b.w	eb58 <ble_ll_hci_event_send>
    f3d8:	bd70      	pop	{r4, r5, r6, pc}
    f3da:	bf00      	nop
    f3dc:	20003b5c 	.word	0x20003b5c

0000f3e0 <ble_ll_hci_ev_rd_rem_ver>:
    }
}

void
ble_ll_hci_ev_rd_rem_ver(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f3e0:	b570      	push	{r4, r5, r6, lr}
    f3e2:	4605      	mov	r5, r0
    uint8_t *evbuf;

    if (ble_ll_hci_is_event_enabled(BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP)) {
    f3e4:	200c      	movs	r0, #12
    }
}

void
ble_ll_hci_ev_rd_rem_ver(struct ble_ll_conn_sm *connsm, uint8_t status)
{
    f3e6:	460e      	mov	r6, r1
    uint8_t *evbuf;

    if (ble_ll_hci_is_event_enabled(BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP)) {
    f3e8:	f7ff fbf2 	bl	ebd0 <ble_ll_hci_is_event_enabled>
    f3ec:	b300      	cbz	r0, f430 <ble_ll_hci_ev_rd_rem_ver+0x50>
        evbuf = os_memblock_get(&g_hci_evt_pool);
    f3ee:	4811      	ldr	r0, [pc, #68]	; (f434 <ble_ll_hci_ev_rd_rem_ver+0x54>)
    f3f0:	f7fb f802 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
    f3f4:	4604      	mov	r4, r0
    f3f6:	b1d8      	cbz	r0, f430 <ble_ll_hci_ev_rd_rem_ver+0x50>
            evbuf[0] = BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP;
    f3f8:	230c      	movs	r3, #12
    f3fa:	7003      	strb	r3, [r0, #0]
            evbuf[1] = BLE_HCI_EVENT_RD_RM_VER_LEN;
    f3fc:	2308      	movs	r3, #8
    f3fe:	7043      	strb	r3, [r0, #1]
            evbuf[2] = status;
    f400:	7086      	strb	r6, [r0, #2]
            htole16(evbuf + 3, connsm->conn_handle);
    f402:	88a9      	ldrh	r1, [r5, #4]
    f404:	3003      	adds	r0, #3
    f406:	f00d fe27 	bl	1d058 <htole16>
            evbuf[5] = connsm->vers_nr;
    f40a:	f895 303a 	ldrb.w	r3, [r5, #58]	; 0x3a
    f40e:	7163      	strb	r3, [r4, #5]
            htole16(evbuf + 6, connsm->comp_id);
    f410:	1da0      	adds	r0, r4, #6
    f412:	f8b5 1042 	ldrh.w	r1, [r5, #66]	; 0x42
    f416:	f00d fe1f 	bl	1d058 <htole16>
            htole16(evbuf + 8, connsm->sub_vers_nr);
    f41a:	f104 0008 	add.w	r0, r4, #8
    f41e:	f8b5 1044 	ldrh.w	r1, [r5, #68]	; 0x44
    f422:	f00d fe19 	bl	1d058 <htole16>
            ble_ll_hci_event_send(evbuf);
    f426:	4620      	mov	r0, r4
        }
    }
}
    f428:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            evbuf[2] = status;
            htole16(evbuf + 3, connsm->conn_handle);
            evbuf[5] = connsm->vers_nr;
            htole16(evbuf + 6, connsm->comp_id);
            htole16(evbuf + 8, connsm->sub_vers_nr);
            ble_ll_hci_event_send(evbuf);
    f42c:	f7ff bb94 	b.w	eb58 <ble_ll_hci_event_send>
    f430:	bd70      	pop	{r4, r5, r6, pc}
    f432:	bf00      	nop
    f434:	20003b5c 	.word	0x20003b5c

0000f438 <ble_ll_rand_sample>:

#define IS_RNUM_BUF_END(x)  (x == &g_ble_ll_rnum_buf[NIMBLE_OPT_LL_RNG_BUFSIZE])

void
ble_ll_rand_sample(uint8_t rnum)
{
    f438:	b538      	push	{r3, r4, r5, lr}
    f43a:	4605      	mov	r5, r0
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    f43c:	f7fa fa70 	bl	9920 <os_arch_save_sr>
    if (g_ble_ll_rnum_data.rnd_size < NIMBLE_OPT_LL_RNG_BUFSIZE) {
    f440:	4b0c      	ldr	r3, [pc, #48]	; (f474 <ble_ll_rand_sample+0x3c>)
    f442:	7a1a      	ldrb	r2, [r3, #8]
    f444:	2a1f      	cmp	r2, #31
void
ble_ll_rand_sample(uint8_t rnum)
{
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    f446:	4604      	mov	r4, r0
    if (g_ble_ll_rnum_data.rnd_size < NIMBLE_OPT_LL_RNG_BUFSIZE) {
    f448:	d80d      	bhi.n	f466 <ble_ll_rand_sample+0x2e>
        ++g_ble_ll_rnum_data.rnd_size;
    f44a:	7a1a      	ldrb	r2, [r3, #8]
        g_ble_ll_rnum_data.rnd_in[0] = rnum;
        if (IS_RNUM_BUF_END(g_ble_ll_rnum_data.rnd_in)) {
    f44c:	490a      	ldr	r1, [pc, #40]	; (f478 <ble_ll_rand_sample+0x40>)
{
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    if (g_ble_ll_rnum_data.rnd_size < NIMBLE_OPT_LL_RNG_BUFSIZE) {
        ++g_ble_ll_rnum_data.rnd_size;
    f44e:	3201      	adds	r2, #1
    f450:	b2d2      	uxtb	r2, r2
    f452:	721a      	strb	r2, [r3, #8]
        g_ble_ll_rnum_data.rnd_in[0] = rnum;
    f454:	681a      	ldr	r2, [r3, #0]
    f456:	7015      	strb	r5, [r2, #0]
        if (IS_RNUM_BUF_END(g_ble_ll_rnum_data.rnd_in)) {
    f458:	681a      	ldr	r2, [r3, #0]
    f45a:	428a      	cmp	r2, r1
            g_ble_ll_rnum_data.rnd_in = g_ble_ll_rnum_buf;
    f45c:	bf0c      	ite	eq
    f45e:	3a20      	subeq	r2, #32
        } else {
            ++g_ble_ll_rnum_data.rnd_in;
    f460:	3201      	addne	r2, #1
    f462:	601a      	str	r2, [r3, #0]
    f464:	e001      	b.n	f46a <ble_ll_rand_sample+0x32>
        }
    } else {
        /* Stop generating random numbers as we are full */
        ble_hw_rng_stop();
    f466:	f001 fc79 	bl	10d5c <ble_hw_rng_stop>
    }
    OS_EXIT_CRITICAL(sr);
    f46a:	4620      	mov	r0, r4
}
    f46c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        }
    } else {
        /* Stop generating random numbers as we are full */
        ble_hw_rng_stop();
    }
    OS_EXIT_CRITICAL(sr);
    f470:	f7fa ba5c 	b.w	992c <os_arch_restore_sr>
    f474:	200035f8 	.word	0x200035f8
    f478:	20003624 	.word	0x20003624

0000f47c <ble_ll_rand_data_get>:
}

/* Get 'len' bytes of random data */
int
ble_ll_rand_data_get(uint8_t *buf, uint8_t len)
{
    f47c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f47e:	4606      	mov	r6, r0
    f480:	460c      	mov	r4, r1
    uint8_t rnums;
    os_sr_t sr;

    while (len != 0) {
    f482:	b374      	cbz	r4, f4e2 <ble_ll_rand_data_get+0x66>
        OS_ENTER_CRITICAL(sr);
        rnums = g_ble_ll_rnum_data.rnd_size;
    f484:	4d18      	ldr	r5, [pc, #96]	; (f4e8 <ble_ll_rand_data_get+0x6c>)
{
    uint8_t rnums;
    os_sr_t sr;

    while (len != 0) {
        OS_ENTER_CRITICAL(sr);
    f486:	f7fa fa4b 	bl	9920 <os_arch_save_sr>
        rnums = g_ble_ll_rnum_data.rnd_size;
    f48a:	7a2a      	ldrb	r2, [r5, #8]
        if (rnums > len) {
            rnums = len;
        }
        len -= rnums;
        g_ble_ll_rnum_data.rnd_size -= rnums;
    f48c:	7a2b      	ldrb	r3, [r5, #8]
    f48e:	42a2      	cmp	r2, r4
    f490:	bf28      	it	cs
    f492:	4622      	movcs	r2, r4
    f494:	1a9b      	subs	r3, r3, r2
        OS_ENTER_CRITICAL(sr);
        rnums = g_ble_ll_rnum_data.rnd_size;
        if (rnums > len) {
            rnums = len;
        }
        len -= rnums;
    f496:	1aa4      	subs	r4, r4, r2
        g_ble_ll_rnum_data.rnd_size -= rnums;
    f498:	b2db      	uxtb	r3, r3
        OS_ENTER_CRITICAL(sr);
        rnums = g_ble_ll_rnum_data.rnd_size;
        if (rnums > len) {
            rnums = len;
        }
        len -= rnums;
    f49a:	b2e4      	uxtb	r4, r4
        g_ble_ll_rnum_data.rnd_size -= rnums;
    f49c:	722b      	strb	r3, [r5, #8]
    f49e:	f106 3eff 	add.w	lr, r6, #4294967295	; 0xffffffff
        while (rnums) {
    f4a2:	4611      	mov	r1, r2
    f4a4:	b179      	cbz	r1, f4c6 <ble_ll_rand_data_get+0x4a>
            buf[0] = g_ble_ll_rnum_data.rnd_out[0];
    f4a6:	686b      	ldr	r3, [r5, #4]
            if (IS_RNUM_BUF_END(g_ble_ll_rnum_data.rnd_out)) {
    f4a8:	f8df c040 	ldr.w	ip, [pc, #64]	; f4ec <ble_ll_rand_data_get+0x70>
            rnums = len;
        }
        len -= rnums;
        g_ble_ll_rnum_data.rnd_size -= rnums;
        while (rnums) {
            buf[0] = g_ble_ll_rnum_data.rnd_out[0];
    f4ac:	781b      	ldrb	r3, [r3, #0]
    f4ae:	f80e 3f01 	strb.w	r3, [lr, #1]!
            if (IS_RNUM_BUF_END(g_ble_ll_rnum_data.rnd_out)) {
    f4b2:	686b      	ldr	r3, [r5, #4]
            rnums = len;
        }
        len -= rnums;
        g_ble_ll_rnum_data.rnd_size -= rnums;
        while (rnums) {
            buf[0] = g_ble_ll_rnum_data.rnd_out[0];
    f4b4:	4f0c      	ldr	r7, [pc, #48]	; (f4e8 <ble_ll_rand_data_get+0x6c>)
            if (IS_RNUM_BUF_END(g_ble_ll_rnum_data.rnd_out)) {
    f4b6:	4563      	cmp	r3, ip
                g_ble_ll_rnum_data.rnd_out = g_ble_ll_rnum_buf;
    f4b8:	bf0c      	ite	eq
    f4ba:	3b20      	subeq	r3, #32
            } else {
                ++g_ble_ll_rnum_data.rnd_out;
    f4bc:	3301      	addne	r3, #1
            }
            ++buf;
            --rnums;
    f4be:	3901      	subs	r1, #1
        while (rnums) {
            buf[0] = g_ble_ll_rnum_data.rnd_out[0];
            if (IS_RNUM_BUF_END(g_ble_ll_rnum_data.rnd_out)) {
                g_ble_ll_rnum_data.rnd_out = g_ble_ll_rnum_buf;
            } else {
                ++g_ble_ll_rnum_data.rnd_out;
    f4c0:	607b      	str	r3, [r7, #4]
            }
            ++buf;
            --rnums;
    f4c2:	b2c9      	uxtb	r1, r1
    f4c4:	e7ee      	b.n	f4a4 <ble_ll_rand_data_get+0x28>
    f4c6:	4416      	add	r6, r2
        }
        OS_EXIT_CRITICAL(sr);
    f4c8:	f7fa fa30 	bl	992c <os_arch_restore_sr>

        /* Make sure rng is started! */
        ble_hw_rng_start();
    f4cc:	f001 fc2e 	bl	10d2c <ble_hw_rng_start>

        /* Wait till bytes are in buffer. */
        if (len) {
    f4d0:	b13c      	cbz	r4, f4e2 <ble_ll_rand_data_get+0x66>
            while ((g_ble_ll_rnum_data.rnd_size < len) &&
    f4d2:	7a2b      	ldrb	r3, [r5, #8]
    f4d4:	42a3      	cmp	r3, r4
    f4d6:	d2d4      	bcs.n	f482 <ble_ll_rand_data_get+0x6>
                   (g_ble_ll_rnum_data.rnd_size < NIMBLE_OPT_LL_RNG_BUFSIZE)) {
    f4d8:	4b03      	ldr	r3, [pc, #12]	; (f4e8 <ble_ll_rand_data_get+0x6c>)
    f4da:	7a1b      	ldrb	r3, [r3, #8]
        /* Make sure rng is started! */
        ble_hw_rng_start();

        /* Wait till bytes are in buffer. */
        if (len) {
            while ((g_ble_ll_rnum_data.rnd_size < len) &&
    f4dc:	2b1f      	cmp	r3, #31
    f4de:	d9f8      	bls.n	f4d2 <ble_ll_rand_data_get+0x56>
    f4e0:	e7cf      	b.n	f482 <ble_ll_rand_data_get+0x6>
            }
        }
    }

    return BLE_ERR_SUCCESS;
}
    f4e2:	2000      	movs	r0, #0
    f4e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f4e6:	bf00      	nop
    f4e8:	200035f8 	.word	0x200035f8
    f4ec:	20003624 	.word	0x20003624

0000f4f0 <ble_ll_rand_prand_get>:
 *
 * @param prand
 */
void
ble_ll_rand_prand_get(uint8_t *prand)
{
    f4f0:	b510      	push	{r4, lr}
    f4f2:	4604      	mov	r4, r0
    uint16_t sum;

    while (1) {
        /* Get 24 bits of random data */
        ble_ll_rand_data_get(prand, 3);
    f4f4:	2103      	movs	r1, #3
    f4f6:	4620      	mov	r0, r4
    f4f8:	f7ff ffc0 	bl	f47c <ble_ll_rand_data_get>

        /* Prand cannot be all zeros or 1's. */
        sum = prand[0] + prand[1] + prand[2];
    f4fc:	78a3      	ldrb	r3, [r4, #2]
    f4fe:	7861      	ldrb	r1, [r4, #1]
    f500:	7820      	ldrb	r0, [r4, #0]
    f502:	185a      	adds	r2, r3, r1
        if ((sum != 0) && (sum != (3 * 0xff))) {
    f504:	1812      	adds	r2, r2, r0
    f506:	d0f5      	beq.n	f4f4 <ble_ll_rand_prand_get+0x4>
    f508:	f240 21fd 	movw	r1, #765	; 0x2fd
    f50c:	428a      	cmp	r2, r1
    f50e:	d0f1      	beq.n	f4f4 <ble_ll_rand_prand_get+0x4>
            break;
        }
    }

    /* Upper two bits must be 01 */
    prand[2] &= ~0xc0;
    f510:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    prand[2] |= 0x40;
    f514:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f518:	70a3      	strb	r3, [r4, #2]
    f51a:	bd10      	pop	{r4, pc}

0000f51c <ble_ll_rand_start>:
 *
 * @return int
 */
int
ble_ll_rand_start(void)
{
    f51c:	b508      	push	{r3, lr}
    /* Start the generation of numbers if we are not full */
    if (g_ble_ll_rnum_data.rnd_size < NIMBLE_OPT_LL_RNG_BUFSIZE) {
    f51e:	4b04      	ldr	r3, [pc, #16]	; (f530 <ble_ll_rand_start+0x14>)
    f520:	7a1b      	ldrb	r3, [r3, #8]
    f522:	2b1f      	cmp	r3, #31
    f524:	d801      	bhi.n	f52a <ble_ll_rand_start+0xe>
        ble_hw_rng_start();
    f526:	f001 fc01 	bl	10d2c <ble_hw_rng_start>
    }
    return 0;
}
    f52a:	2000      	movs	r0, #0
    f52c:	bd08      	pop	{r3, pc}
    f52e:	bf00      	nop
    f530:	200035f8 	.word	0x200035f8

0000f534 <ble_ll_rand_init>:
 *
 * @return int
 */
int
ble_ll_rand_init(void)
{
    f534:	b508      	push	{r3, lr}
    g_ble_ll_rnum_data.rnd_in = g_ble_ll_rnum_buf;
    f536:	4b05      	ldr	r3, [pc, #20]	; (f54c <ble_ll_rand_init+0x18>)
    f538:	4a05      	ldr	r2, [pc, #20]	; (f550 <ble_ll_rand_init+0x1c>)
    g_ble_ll_rnum_data.rnd_out = g_ble_ll_rnum_buf;
    ble_hw_rng_init(ble_ll_rand_sample, 1);
    f53a:	4806      	ldr	r0, [pc, #24]	; (f554 <ble_ll_rand_init+0x20>)
 * @return int
 */
int
ble_ll_rand_init(void)
{
    g_ble_ll_rnum_data.rnd_in = g_ble_ll_rnum_buf;
    f53c:	601a      	str	r2, [r3, #0]
    g_ble_ll_rnum_data.rnd_out = g_ble_ll_rnum_buf;
    ble_hw_rng_init(ble_ll_rand_sample, 1);
    f53e:	2101      	movs	r1, #1
 */
int
ble_ll_rand_init(void)
{
    g_ble_ll_rnum_data.rnd_in = g_ble_ll_rnum_buf;
    g_ble_ll_rnum_data.rnd_out = g_ble_ll_rnum_buf;
    f540:	605a      	str	r2, [r3, #4]
    ble_hw_rng_init(ble_ll_rand_sample, 1);
    f542:	f001 fbd1 	bl	10ce8 <ble_hw_rng_init>
    return 0;
}
    f546:	2000      	movs	r0, #0
    f548:	bd08      	pop	{r3, pc}
    f54a:	bf00      	nop
    f54c:	200035f8 	.word	0x200035f8
    f550:	20003604 	.word	0x20003604
    f554:	0000f439 	.word	0x0000f439

0000f558 <ble_ll_is_on_resolv_list>:
 * is the 'position' of the device in the resolving list (the index of the
 * element plus 1).
 */
static int
ble_ll_is_on_resolv_list(uint8_t *addr, uint8_t addr_type)
{
    f558:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
    f55c:	4b0e      	ldr	r3, [pc, #56]	; (f598 <ble_ll_is_on_resolv_list+0x40>)
    f55e:	4d0f      	ldr	r5, [pc, #60]	; (f59c <ble_ll_is_on_resolv_list+0x44>)
    f560:	781e      	ldrb	r6, [r3, #0]
 * is the 'position' of the device in the resolving list (the index of the
 * element plus 1).
 */
static int
ble_ll_is_on_resolv_list(uint8_t *addr, uint8_t addr_type)
{
    f562:	4607      	mov	r7, r0
    f564:	4688      	mov	r8, r1
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
    f566:	2000      	movs	r0, #0
    f568:	42b0      	cmp	r0, r6
    f56a:	da11      	bge.n	f590 <ble_ll_is_on_resolv_list+0x38>
        if ((rl->rl_addr_type == addr_type) &&
    f56c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    f570:	4543      	cmp	r3, r8
    f572:	f100 0401 	add.w	r4, r0, #1
    f576:	d108      	bne.n	f58a <ble_ll_is_on_resolv_list+0x32>
            (!memcmp(&rl->rl_identity_addr[0], addr, BLE_DEV_ADDR_LEN))) {
    f578:	4628      	mov	r0, r5
    f57a:	4639      	mov	r1, r7
    f57c:	2206      	movs	r2, #6
    f57e:	f7f9 fd2f 	bl	8fe0 <memcmp>
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
        if ((rl->rl_addr_type == addr_type) &&
    f582:	b910      	cbnz	r0, f58a <ble_ll_is_on_resolv_list+0x32>
            (!memcmp(&rl->rl_identity_addr[0], addr, BLE_DEV_ADDR_LEN))) {
            return i + 1;
    f584:	4620      	mov	r0, r4
    f586:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
    f58a:	4620      	mov	r0, r4
    f58c:	3528      	adds	r5, #40	; 0x28
    f58e:	e7eb      	b.n	f568 <ble_ll_is_on_resolv_list+0x10>
            return i + 1;
        }
        ++rl;
    }

    return 0;
    f590:	2000      	movs	r0, #0
}
    f592:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f596:	bf00      	nop
    f598:	200036cc 	.word	0x200036cc
    f59c:	20003626 	.word	0x20003626

0000f5a0 <ble_ll_resolv_list_chg_allowed>:
 *
 * @return int 0: not allowed. 1: allowed.
 */
static int
ble_ll_resolv_list_chg_allowed(void)
{
    f5a0:	b508      	push	{r3, lr}
    int rc;

    if (g_ble_ll_addr_res_enabled && (ble_ll_adv_enabled()  ||
    f5a2:	4b0a      	ldr	r3, [pc, #40]	; (f5cc <ble_ll_resolv_list_chg_allowed+0x2c>)
    f5a4:	781b      	ldrb	r3, [r3, #0]
    f5a6:	b173      	cbz	r3, f5c6 <ble_ll_resolv_list_chg_allowed+0x26>
    f5a8:	f7fc fac8 	bl	bb3c <ble_ll_adv_enabled>
    f5ac:	b108      	cbz	r0, f5b2 <ble_ll_resolv_list_chg_allowed+0x12>
                                      ble_ll_scan_enabled() ||
                                      g_ble_ll_conn_create_sm)) {
        rc = 0;
    f5ae:	2000      	movs	r0, #0
    f5b0:	bd08      	pop	{r3, pc}
ble_ll_resolv_list_chg_allowed(void)
{
    int rc;

    if (g_ble_ll_addr_res_enabled && (ble_ll_adv_enabled()  ||
                                      ble_ll_scan_enabled() ||
    f5b2:	f000 fe69 	bl	10288 <ble_ll_scan_enabled>
static int
ble_ll_resolv_list_chg_allowed(void)
{
    int rc;

    if (g_ble_ll_addr_res_enabled && (ble_ll_adv_enabled()  ||
    f5b6:	2800      	cmp	r0, #0
    f5b8:	d1f9      	bne.n	f5ae <ble_ll_resolv_list_chg_allowed+0xe>
                                      ble_ll_scan_enabled() ||
    f5ba:	4b05      	ldr	r3, [pc, #20]	; (f5d0 <ble_ll_resolv_list_chg_allowed+0x30>)
    f5bc:	6818      	ldr	r0, [r3, #0]
    f5be:	fab0 f080 	clz	r0, r0
    f5c2:	0940      	lsrs	r0, r0, #5
    f5c4:	bd08      	pop	{r3, pc}
                                      g_ble_ll_conn_create_sm)) {
        rc = 0;
    } else {
        rc = 1;
    f5c6:	2001      	movs	r0, #1
    }
    return rc;
}
    f5c8:	bd08      	pop	{r3, pc}
    f5ca:	bf00      	nop
    f5cc:	200036c4 	.word	0x200036c4
    f5d0:	200033d8 	.word	0x200033d8

0000f5d4 <ble_ll_resolv_irk_nonzero>:
 *
 * @return int 0: IRK is zero . 1: IRK has non-zero value.
 */
int
ble_ll_resolv_irk_nonzero(uint8_t *irk)
{
    f5d4:	1e42      	subs	r2, r0, #1
    f5d6:	f100 030f 	add.w	r3, r0, #15
    int i;
    int rc;

    rc = 0;
    for (i = 0; i < 16; ++i) {
        if (*irk != 0) {
    f5da:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    f5de:	b910      	cbnz	r0, f5e6 <ble_ll_resolv_irk_nonzero+0x12>
{
    int i;
    int rc;

    rc = 0;
    for (i = 0; i < 16; ++i) {
    f5e0:	429a      	cmp	r2, r3
    f5e2:	d1fa      	bne.n	f5da <ble_ll_resolv_irk_nonzero+0x6>
    f5e4:	4770      	bx	lr
        if (*irk != 0) {
            rc = 1;
    f5e6:	2001      	movs	r0, #1
        }
        ++irk;
    }

    return rc;
}
    f5e8:	4770      	bx	lr
	...

0000f5ec <ble_ll_resolv_list_clr>:
 *
 * @return int 0: success, BLE error code otherwise
 */
int
ble_ll_resolv_list_clr(void)
{
    f5ec:	b510      	push	{r4, lr}
    /* Check proper state */
    if (!ble_ll_resolv_list_chg_allowed()) {
    f5ee:	f7ff ffd7 	bl	f5a0 <ble_ll_resolv_list_chg_allowed>
    f5f2:	b130      	cbz	r0, f602 <ble_ll_resolv_list_clr+0x16>
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* Sets total on list to 0. Clears HW resolve list */
    g_ble_ll_resolv_list_cnt = 0;
    f5f4:	4b04      	ldr	r3, [pc, #16]	; (f608 <ble_ll_resolv_list_clr+0x1c>)
    f5f6:	2400      	movs	r4, #0
    f5f8:	701c      	strb	r4, [r3, #0]
    ble_hw_resolv_list_clear();
    f5fa:	f001 fbc1 	bl	10d80 <ble_hw_resolv_list_clear>

    return BLE_ERR_SUCCESS;
    f5fe:	4620      	mov	r0, r4
    f600:	bd10      	pop	{r4, pc}
int
ble_ll_resolv_list_clr(void)
{
    /* Check proper state */
    if (!ble_ll_resolv_list_chg_allowed()) {
        return BLE_ERR_CMD_DISALLOWED;
    f602:	200c      	movs	r0, #12
    /* Sets total on list to 0. Clears HW resolve list */
    g_ble_ll_resolv_list_cnt = 0;
    ble_hw_resolv_list_clear();

    return BLE_ERR_SUCCESS;
}
    f604:	bd10      	pop	{r4, pc}
    f606:	bf00      	nop
    f608:	200036cc 	.word	0x200036cc

0000f60c <ble_ll_resolv_list_read_size>:
 * @return int 0: success.
 */
int
ble_ll_resolv_list_read_size(uint8_t *rspbuf, uint8_t *rsplen)
{
    rspbuf[0] = g_ble_ll_resolv_list_size;
    f60c:	4b03      	ldr	r3, [pc, #12]	; (f61c <ble_ll_resolv_list_read_size+0x10>)
    f60e:	781b      	ldrb	r3, [r3, #0]
    f610:	7003      	strb	r3, [r0, #0]
    *rsplen = 1;
    f612:	2301      	movs	r3, #1
    f614:	700b      	strb	r3, [r1, #0]
    return BLE_ERR_SUCCESS;
}
    f616:	2000      	movs	r0, #0
    f618:	4770      	bx	lr
    f61a:	bf00      	nop
    f61c:	200036c5 	.word	0x200036c5

0000f620 <ble_ll_resolv_list_find>:
 *
 * @return Pointer to resolving list entry or NULL if no entry found.
 */
struct ble_ll_resolv_entry *
ble_ll_resolv_list_find(uint8_t *addr, uint8_t addr_type)
{
    f620:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
    f624:	4b0c      	ldr	r3, [pc, #48]	; (f658 <ble_ll_resolv_list_find+0x38>)
ble_ll_resolv_list_find(uint8_t *addr, uint8_t addr_type)
{
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    f626:	4c0d      	ldr	r4, [pc, #52]	; (f65c <ble_ll_resolv_list_find+0x3c>)
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
    f628:	781e      	ldrb	r6, [r3, #0]
 *
 * @return Pointer to resolving list entry or NULL if no entry found.
 */
struct ble_ll_resolv_entry *
ble_ll_resolv_list_find(uint8_t *addr, uint8_t addr_type)
{
    f62a:	4607      	mov	r7, r0
    f62c:	4688      	mov	r8, r1
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
    f62e:	2500      	movs	r5, #0
    f630:	42b5      	cmp	r5, r6
    f632:	da0b      	bge.n	f64c <ble_ll_resolv_list_find+0x2c>
        if ((rl->rl_addr_type == addr_type) &&
    f634:	7863      	ldrb	r3, [r4, #1]
    f636:	4543      	cmp	r3, r8
    f638:	d105      	bne.n	f646 <ble_ll_resolv_list_find+0x26>
            (!memcmp(&rl->rl_identity_addr[0], addr, BLE_DEV_ADDR_LEN))) {
    f63a:	1ca0      	adds	r0, r4, #2
    f63c:	4639      	mov	r1, r7
    f63e:	2206      	movs	r2, #6
    f640:	f7f9 fcce 	bl	8fe0 <memcmp>
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
        if ((rl->rl_addr_type == addr_type) &&
    f644:	b128      	cbz	r0, f652 <ble_ll_resolv_list_find+0x32>
            (!memcmp(&rl->rl_identity_addr[0], addr, BLE_DEV_ADDR_LEN))) {
            return rl;
        }
        ++rl;
    f646:	3428      	adds	r4, #40	; 0x28
{
    int i;
    struct ble_ll_resolv_entry *rl;

    rl = &g_ble_ll_resolv_list[0];
    for (i = 0; i < g_ble_ll_resolv_list_cnt; ++i) {
    f648:	3501      	adds	r5, #1
    f64a:	e7f1      	b.n	f630 <ble_ll_resolv_list_find+0x10>
            return rl;
        }
        ++rl;
    }

    return NULL;
    f64c:	2000      	movs	r0, #0
    f64e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f652:	4620      	mov	r0, r4
}
    f654:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f658:	200036cc 	.word	0x200036cc
    f65c:	20003624 	.word	0x20003624

0000f660 <ble_ll_resolv_list_add>:
 *
 * @return int
 */
int
ble_ll_resolv_list_add(uint8_t *cmdbuf)
{
    f660:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f664:	4607      	mov	r7, r0
    uint8_t addr_type;
    uint8_t *ident_addr;
    struct ble_ll_resolv_entry *rl;

    /* Must be in proper state */
    if (!ble_ll_resolv_list_chg_allowed()) {
    f666:	f7ff ff9b 	bl	f5a0 <ble_ll_resolv_list_chg_allowed>
    f66a:	b390      	cbz	r0, f6d2 <ble_ll_resolv_list_add+0x72>
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* Check if we have any open entries */
    if (g_ble_ll_resolv_list_cnt >= g_ble_ll_resolv_list_size) {
    f66c:	4e1d      	ldr	r6, [pc, #116]	; (f6e4 <ble_ll_resolv_list_add+0x84>)
    f66e:	4b1e      	ldr	r3, [pc, #120]	; (f6e8 <ble_ll_resolv_list_add+0x88>)
    f670:	7834      	ldrb	r4, [r6, #0]
    f672:	781b      	ldrb	r3, [r3, #0]
    f674:	42a3      	cmp	r3, r4
    f676:	d92f      	bls.n	f6d8 <ble_ll_resolv_list_add+0x78>
        return BLE_ERR_MEM_CAPACITY;
    }

    addr_type = cmdbuf[0];
    f678:	463d      	mov	r5, r7
    f67a:	f815 9b01 	ldrb.w	r9, [r5], #1
    ident_addr = cmdbuf + 1;

    rc = BLE_ERR_SUCCESS;
    if (!ble_ll_is_on_resolv_list(ident_addr, addr_type)) {
    f67e:	4628      	mov	r0, r5
    f680:	4649      	mov	r1, r9
    f682:	f7ff ff69 	bl	f558 <ble_ll_is_on_resolv_list>
    f686:	bb50      	cbnz	r0, f6de <ble_ll_resolv_list_add+0x7e>
        rl = &g_ble_ll_resolv_list[g_ble_ll_resolv_list_cnt];
        rl->rl_addr_type = addr_type;
    f688:	f8df 8060 	ldr.w	r8, [pc, #96]	; f6ec <ble_ll_resolv_list_add+0x8c>
    f68c:	2028      	movs	r0, #40	; 0x28
    f68e:	4344      	muls	r4, r0
    f690:	eb08 0304 	add.w	r3, r8, r4
        memcpy(&rl->rl_identity_addr[0], ident_addr, BLE_DEV_ADDR_LEN);
        swap_buf(rl->rl_peer_irk, cmdbuf + 7, 16);
    f694:	1df9      	adds	r1, r7, #7
    ident_addr = cmdbuf + 1;

    rc = BLE_ERR_SUCCESS;
    if (!ble_ll_is_on_resolv_list(ident_addr, addr_type)) {
        rl = &g_ble_ll_resolv_list[g_ble_ll_resolv_list_cnt];
        rl->rl_addr_type = addr_type;
    f696:	f883 9001 	strb.w	r9, [r3, #1]
        memcpy(&rl->rl_identity_addr[0], ident_addr, BLE_DEV_ADDR_LEN);
    f69a:	682a      	ldr	r2, [r5, #0]
    f69c:	f8c3 2002 	str.w	r2, [r3, #2]
    f6a0:	88aa      	ldrh	r2, [r5, #4]
    f6a2:	80da      	strh	r2, [r3, #6]
        swap_buf(rl->rl_peer_irk, cmdbuf + 7, 16);
    f6a4:	f104 0518 	add.w	r5, r4, #24
    f6a8:	4445      	add	r5, r8
    f6aa:	4628      	mov	r0, r5
    f6ac:	2210      	movs	r2, #16
    f6ae:	f00d fd37 	bl	1d120 <swap_buf>
        swap_buf(rl->rl_local_irk, cmdbuf + 23, 16);
    f6b2:	f104 0008 	add.w	r0, r4, #8
    f6b6:	4440      	add	r0, r8
    f6b8:	f107 0117 	add.w	r1, r7, #23
    f6bc:	2210      	movs	r2, #16
    f6be:	f00d fd2f 	bl	1d120 <swap_buf>
        ++g_ble_ll_resolv_list_cnt;
    f6c2:	7833      	ldrb	r3, [r6, #0]
    f6c4:	3301      	adds	r3, #1
    f6c6:	7033      	strb	r3, [r6, #0]

        rc = ble_hw_resolv_list_add(rl->rl_peer_irk);
    f6c8:	4628      	mov	r0, r5
    }

    return rc;
}
    f6ca:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        memcpy(&rl->rl_identity_addr[0], ident_addr, BLE_DEV_ADDR_LEN);
        swap_buf(rl->rl_peer_irk, cmdbuf + 7, 16);
        swap_buf(rl->rl_local_irk, cmdbuf + 23, 16);
        ++g_ble_ll_resolv_list_cnt;

        rc = ble_hw_resolv_list_add(rl->rl_peer_irk);
    f6ce:	f001 bb5d 	b.w	10d8c <ble_hw_resolv_list_add>
    uint8_t *ident_addr;
    struct ble_ll_resolv_entry *rl;

    /* Must be in proper state */
    if (!ble_ll_resolv_list_chg_allowed()) {
        return BLE_ERR_CMD_DISALLOWED;
    f6d2:	200c      	movs	r0, #12
    f6d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }

    /* Check if we have any open entries */
    if (g_ble_ll_resolv_list_cnt >= g_ble_ll_resolv_list_size) {
        return BLE_ERR_MEM_CAPACITY;
    f6d8:	2007      	movs	r0, #7
    f6da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }

    addr_type = cmdbuf[0];
    ident_addr = cmdbuf + 1;

    rc = BLE_ERR_SUCCESS;
    f6de:	2000      	movs	r0, #0

        rc = ble_hw_resolv_list_add(rl->rl_peer_irk);
    }

    return rc;
}
    f6e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    f6e4:	200036cc 	.word	0x200036cc
    f6e8:	200036c5 	.word	0x200036c5
    f6ec:	20003624 	.word	0x20003624

0000f6f0 <ble_ll_resolv_list_rmv>:
 *
 * @return int 0: success, BLE error code otherwise
 */
int
ble_ll_resolv_list_rmv(uint8_t *cmdbuf)
{
    f6f0:	b570      	push	{r4, r5, r6, lr}
    f6f2:	4604      	mov	r4, r0
    int position;
    uint8_t addr_type;
    uint8_t *ident_addr;

    /* Must be in proper state */
    if (!ble_ll_resolv_list_chg_allowed()) {
    f6f4:	f7ff ff54 	bl	f5a0 <ble_ll_resolv_list_chg_allowed>
    f6f8:	b1c8      	cbz	r0, f72e <ble_ll_resolv_list_rmv+0x3e>

    addr_type = cmdbuf[0];
    ident_addr = cmdbuf + 1;

    /* Remove from IRK records */
    position = ble_ll_is_on_resolv_list(ident_addr, addr_type);
    f6fa:	1c60      	adds	r0, r4, #1
    f6fc:	7821      	ldrb	r1, [r4, #0]
    f6fe:	f7ff ff2b 	bl	f558 <ble_ll_is_on_resolv_list>
    if (position && (position < g_ble_ll_resolv_list_cnt)) {
    f702:	4602      	mov	r2, r0
    f704:	b1a8      	cbz	r0, f732 <ble_ll_resolv_list_rmv+0x42>
    f706:	4e0c      	ldr	r6, [pc, #48]	; (f738 <ble_ll_resolv_list_rmv+0x48>)
    f708:	7834      	ldrb	r4, [r6, #0]
    f70a:	42a0      	cmp	r0, r4
    f70c:	da11      	bge.n	f732 <ble_ll_resolv_list_rmv+0x42>
        memmove(&g_ble_ll_resolv_list[position - 1],
    f70e:	4b0b      	ldr	r3, [pc, #44]	; (f73c <ble_ll_resolv_list_rmv+0x4c>)
    f710:	1e45      	subs	r5, r0, #1
    f712:	2128      	movs	r1, #40	; 0x28
    f714:	fb01 3005 	mla	r0, r1, r5, r3
    f718:	fb01 3102 	mla	r1, r1, r2, r3
    f71c:	1aa2      	subs	r2, r4, r2
    f71e:	f00e f9d9 	bl	1dad4 <memmove>
                &g_ble_ll_resolv_list[position],
                g_ble_ll_resolv_list_cnt - position);
        --g_ble_ll_resolv_list_cnt;
    f722:	3c01      	subs	r4, #1

        /* Remove from HW list */
        ble_hw_resolv_list_rmv(position - 1);
    f724:	4628      	mov	r0, r5
    position = ble_ll_is_on_resolv_list(ident_addr, addr_type);
    if (position && (position < g_ble_ll_resolv_list_cnt)) {
        memmove(&g_ble_ll_resolv_list[position - 1],
                &g_ble_ll_resolv_list[position],
                g_ble_ll_resolv_list_cnt - position);
        --g_ble_ll_resolv_list_cnt;
    f726:	7034      	strb	r4, [r6, #0]

        /* Remove from HW list */
        ble_hw_resolv_list_rmv(position - 1);
    f728:	f001 fb4e 	bl	10dc8 <ble_hw_resolv_list_rmv>
    f72c:	e001      	b.n	f732 <ble_ll_resolv_list_rmv+0x42>
    uint8_t addr_type;
    uint8_t *ident_addr;

    /* Must be in proper state */
    if (!ble_ll_resolv_list_chg_allowed()) {
        return BLE_ERR_CMD_DISALLOWED;
    f72e:	200c      	movs	r0, #12
    f730:	bd70      	pop	{r4, r5, r6, pc}

        /* Remove from HW list */
        ble_hw_resolv_list_rmv(position - 1);
    }

    return BLE_ERR_SUCCESS;
    f732:	2000      	movs	r0, #0
}
    f734:	bd70      	pop	{r4, r5, r6, pc}
    f736:	bf00      	nop
    f738:	200036cc 	.word	0x200036cc
    f73c:	20003624 	.word	0x20003624

0000f740 <ble_ll_resolv_enable_cmd>:
 *
 * @return int
 */
int
ble_ll_resolv_enable_cmd(uint8_t *cmdbuf)
{
    f740:	b510      	push	{r4, lr}
    f742:	4604      	mov	r4, r0
    int rc;

    if (ble_ll_adv_enabled() || ble_ll_scan_enabled() ||
    f744:	f7fc f9fa 	bl	bb3c <ble_ll_adv_enabled>
    f748:	b108      	cbz	r0, f74e <ble_ll_resolv_enable_cmd+0xe>
        g_ble_ll_conn_create_sm) {
        rc = BLE_ERR_CMD_DISALLOWED;
    f74a:	200c      	movs	r0, #12
    f74c:	bd10      	pop	{r4, pc}
int
ble_ll_resolv_enable_cmd(uint8_t *cmdbuf)
{
    int rc;

    if (ble_ll_adv_enabled() || ble_ll_scan_enabled() ||
    f74e:	f000 fd9b 	bl	10288 <ble_ll_scan_enabled>
    f752:	2800      	cmp	r0, #0
    f754:	d1f9      	bne.n	f74a <ble_ll_resolv_enable_cmd+0xa>
    f756:	4b04      	ldr	r3, [pc, #16]	; (f768 <ble_ll_resolv_enable_cmd+0x28>)
    f758:	6818      	ldr	r0, [r3, #0]
    f75a:	2800      	cmp	r0, #0
    f75c:	d1f5      	bne.n	f74a <ble_ll_resolv_enable_cmd+0xa>
        g_ble_ll_conn_create_sm) {
        rc = BLE_ERR_CMD_DISALLOWED;
    } else {
        g_ble_ll_addr_res_enabled = cmdbuf[0];
    f75e:	4b03      	ldr	r3, [pc, #12]	; (f76c <ble_ll_resolv_enable_cmd+0x2c>)
    f760:	7822      	ldrb	r2, [r4, #0]
    f762:	701a      	strb	r2, [r3, #0]
        rc = BLE_ERR_SUCCESS;
    }

    return rc;
}
    f764:	bd10      	pop	{r4, pc}
    f766:	bf00      	nop
    f768:	200033d8 	.word	0x200033d8
    f76c:	200036c4 	.word	0x200036c4

0000f770 <ble_ll_resolv_peer_addr_rd>:
int
ble_ll_resolv_peer_addr_rd(uint8_t *cmdbuf)
{
    /* XXX */
    return 0;
}
    f770:	2000      	movs	r0, #0
    f772:	4770      	bx	lr

0000f774 <ble_ll_resolv_local_addr_rd>:

void
ble_ll_resolv_local_addr_rd(uint8_t *cmdbuf)
{
    f774:	4770      	bx	lr
	...

0000f778 <ble_ll_resolv_set_rpa_tmo>:
 *
 * @return int
 */
int
ble_ll_resolv_set_rpa_tmo(uint8_t *cmdbuf)
{
    f778:	b508      	push	{r3, lr}
    int rc;
    uint16_t tmo_secs;

    tmo_secs = le16toh(cmdbuf);
    f77a:	f00d fc88 	bl	1d08e <le16toh>
    if ((tmo_secs > 0) && (tmo_secs <= 0xA1B8)) {
    f77e:	1e43      	subs	r3, r0, #1
    f780:	b29b      	uxth	r3, r3
    f782:	f24a 12b7 	movw	r2, #41399	; 0xa1b7
    f786:	4293      	cmp	r3, r2
        g_ble_ll_resolv_rpa_tmo = tmo_secs * OS_TICKS_PER_SEC;
    f788:	bf9e      	ittt	ls
    f78a:	4b02      	ldrls	r3, [pc, #8]	; (f794 <ble_ll_resolv_set_rpa_tmo+0x1c>)
    f78c:	01c0      	lslls	r0, r0, #7
    f78e:	6018      	strls	r0, [r3, #0]
    } else {
        rc = BLE_ERR_INV_HCI_CMD_PARMS;
    }

    return rc;
}
    f790:	2012      	movs	r0, #18
    f792:	bd08      	pop	{r3, pc}
    f794:	200036c8 	.word	0x200036c8

0000f798 <ble_ll_resolv_get_rpa_tmo>:
 */
uint32_t
ble_ll_resolv_get_rpa_tmo(void)
{
    return g_ble_ll_resolv_rpa_tmo;
}
    f798:	4b01      	ldr	r3, [pc, #4]	; (f7a0 <ble_ll_resolv_get_rpa_tmo+0x8>)
    f79a:	6818      	ldr	r0, [r3, #0]
    f79c:	4770      	bx	lr
    f79e:	bf00      	nop
    f7a0:	200036c8 	.word	0x200036c8

0000f7a4 <ble_ll_resolv_gen_priv_addr>:
 * @param addr Pointer to resolvable private address
 */
void
ble_ll_resolv_gen_priv_addr(struct ble_ll_resolv_entry *rl, int local,
                            uint8_t *addr)
{
    f7a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    f7a6:	460f      	mov	r7, r1
    f7a8:	b08d      	sub	sp, #52	; 0x34
    f7aa:	4615      	mov	r5, r2
    uint8_t *irk;
    uint8_t *prand;
    struct ble_encryption_block ecb;

    assert(rl != NULL);
    f7ac:	4604      	mov	r4, r0
    f7ae:	b928      	cbnz	r0, f7bc <ble_ll_resolv_gen_priv_addr+0x18>
    f7b0:	481c      	ldr	r0, [pc, #112]	; (f824 <ble_ll_resolv_gen_priv_addr+0x80>)
    f7b2:	f240 1159 	movw	r1, #345	; 0x159
    f7b6:	4622      	mov	r2, r4
    f7b8:	4623      	mov	r3, r4
    f7ba:	e004      	b.n	f7c6 <ble_ll_resolv_gen_priv_addr+0x22>
    assert(addr != NULL);
    f7bc:	b92a      	cbnz	r2, f7ca <ble_ll_resolv_gen_priv_addr+0x26>
    f7be:	4819      	ldr	r0, [pc, #100]	; (f824 <ble_ll_resolv_gen_priv_addr+0x80>)
    f7c0:	f44f 71ad 	mov.w	r1, #346	; 0x15a
    f7c4:	4613      	mov	r3, r2
    f7c6:	f7fa fa83 	bl	9cd0 <__assert_func>

    /* Get prand */
    prand = addr + 3;
    f7ca:	1cd6      	adds	r6, r2, #3
    ble_ll_rand_prand_get(prand);
    f7cc:	4630      	mov	r0, r6
    f7ce:	f7ff fe8f 	bl	f4f0 <ble_ll_rand_prand_get>

    /* Calculate hash, hash = ah(local IRK, prand) */
    if (local) {
    f7d2:	b117      	cbz	r7, f7da <ble_ll_resolv_gen_priv_addr+0x36>
        irk = rl->rl_local_irk;
    f7d4:	f104 0208 	add.w	r2, r4, #8
    f7d8:	e001      	b.n	f7de <ble_ll_resolv_gen_priv_addr+0x3a>
    } else {
        irk = rl->rl_peer_irk;
    f7da:	f104 0218 	add.w	r2, r4, #24
    }

    memcpy(ecb.key, irk, BLE_ENC_BLOCK_SIZE);
    f7de:	466b      	mov	r3, sp
    f7e0:	f102 0e10 	add.w	lr, r2, #16
    f7e4:	466f      	mov	r7, sp
    f7e6:	6810      	ldr	r0, [r2, #0]
    f7e8:	6851      	ldr	r1, [r2, #4]
    f7ea:	461c      	mov	r4, r3
    f7ec:	c403      	stmia	r4!, {r0, r1}
    f7ee:	3208      	adds	r2, #8
    f7f0:	4572      	cmp	r2, lr
    f7f2:	4623      	mov	r3, r4
    f7f4:	d1f7      	bne.n	f7e6 <ble_ll_resolv_gen_priv_addr+0x42>
    memset(ecb.plain_text, 0, BLE_ENC_BLOCK_SIZE);
    f7f6:	a804      	add	r0, sp, #16
    f7f8:	2100      	movs	r1, #0
    f7fa:	2210      	movs	r2, #16
    f7fc:	f7f9 fc09 	bl	9012 <memset>
    swap_buf(&ecb.plain_text[13], prand, 3);
    f800:	4631      	mov	r1, r6
    f802:	f10d 001d 	add.w	r0, sp, #29
    f806:	2203      	movs	r2, #3
    f808:	f00d fc8a 	bl	1d120 <swap_buf>

    /* Calculate hash */
    ble_hw_encrypt_block(&ecb);
    f80c:	4638      	mov	r0, r7
    f80e:	f001 fa4f 	bl	10cb0 <ble_hw_encrypt_block>
    swap_buf(addr, ecb.cipher_text + 13, 3);
    f812:	4628      	mov	r0, r5
    f814:	f10d 012d 	add.w	r1, sp, #45	; 0x2d
    f818:	2203      	movs	r2, #3
    f81a:	f00d fc81 	bl	1d120 <swap_buf>
}
    f81e:	b00d      	add	sp, #52	; 0x34
    f820:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f822:	bf00      	nop
    f824:	0001f2d3 	.word	0x0001f2d3

0000f828 <ble_ll_resolv_gen_rpa>:
 *
 * @return int
 */
int
ble_ll_resolv_gen_rpa(uint8_t *addr, uint8_t addr_type, uint8_t *rpa, int local)
{
    f828:	b570      	push	{r4, r5, r6, lr}
    f82a:	4616      	mov	r6, r2
    f82c:	461d      	mov	r5, r3
    int rc;
    uint8_t *irk;
    struct ble_ll_resolv_entry *rl;

    rc = 0;
    rl = ble_ll_resolv_list_find(addr, addr_type);
    f82e:	f7ff fef7 	bl	f620 <ble_ll_resolv_list_find>
    if (rl) {
    f832:	4604      	mov	r4, r0
    f834:	b168      	cbz	r0, f852 <ble_ll_resolv_gen_rpa+0x2a>
        if (local) {
    f836:	b10d      	cbz	r5, f83c <ble_ll_resolv_gen_rpa+0x14>
            irk = rl->rl_local_irk;
    f838:	3008      	adds	r0, #8
    f83a:	e000      	b.n	f83e <ble_ll_resolv_gen_rpa+0x16>
        } else {
            irk = rl->rl_peer_irk;
    f83c:	3018      	adds	r0, #24
        }
        if (ble_ll_resolv_irk_nonzero(irk)) {
    f83e:	f7ff fec9 	bl	f5d4 <ble_ll_resolv_irk_nonzero>
    f842:	b130      	cbz	r0, f852 <ble_ll_resolv_gen_rpa+0x2a>
            ble_ll_resolv_gen_priv_addr(rl, local, rpa);
    f844:	4620      	mov	r0, r4
    f846:	4629      	mov	r1, r5
    f848:	4632      	mov	r2, r6
    f84a:	f7ff ffab 	bl	f7a4 <ble_ll_resolv_gen_priv_addr>
            rc = 1;
    f84e:	2001      	movs	r0, #1
    f850:	bd70      	pop	{r4, r5, r6, pc}
        }
    }

    return rc;
}
    f852:	bd70      	pop	{r4, r5, r6, pc}

0000f854 <ble_ll_resolv_rpa>:
 *
 * @return int
 */
int
ble_ll_resolv_rpa(uint8_t *rpa, uint8_t *irk)
{
    f854:	b5f0      	push	{r4, r5, r6, r7, lr}
    f856:	b08d      	sub	sp, #52	; 0x34
    f858:	4604      	mov	r4, r0
    f85a:	460b      	mov	r3, r1
    int rc;
    struct ble_encryption_block ecb;

    memcpy(ecb.key, irk, BLE_ENC_BLOCK_SIZE);
    f85c:	466a      	mov	r2, sp
    f85e:	f101 0710 	add.w	r7, r1, #16
    f862:	466e      	mov	r6, sp
    f864:	6818      	ldr	r0, [r3, #0]
    f866:	6859      	ldr	r1, [r3, #4]
    f868:	4615      	mov	r5, r2
    f86a:	c503      	stmia	r5!, {r0, r1}
    f86c:	3308      	adds	r3, #8
    f86e:	42bb      	cmp	r3, r7
    f870:	462a      	mov	r2, r5
    f872:	d1f7      	bne.n	f864 <ble_ll_resolv_rpa+0x10>
    memset(ecb.plain_text, 0, BLE_ENC_BLOCK_SIZE);
    f874:	2100      	movs	r1, #0
    f876:	2210      	movs	r2, #16
    f878:	a804      	add	r0, sp, #16
    f87a:	f7f9 fbca 	bl	9012 <memset>
    swap_buf(&ecb.plain_text[13], rpa + 3, 3);
    f87e:	2203      	movs	r2, #3
    f880:	f10d 001d 	add.w	r0, sp, #29
    f884:	1ce1      	adds	r1, r4, #3
    f886:	f00d fc4b 	bl	1d120 <swap_buf>
    ble_hw_encrypt_block(&ecb);
    f88a:	4630      	mov	r0, r6
    f88c:	f001 fa10 	bl	10cb0 <ble_hw_encrypt_block>
    if ((ecb.cipher_text[15] == rpa[0]) && (ecb.cipher_text[14] == rpa[1]) &&
    f890:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    f894:	7823      	ldrb	r3, [r4, #0]
    f896:	429a      	cmp	r2, r3
    f898:	d10b      	bne.n	f8b2 <ble_ll_resolv_rpa+0x5e>
    f89a:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
    f89e:	7863      	ldrb	r3, [r4, #1]
    f8a0:	429a      	cmp	r2, r3
    f8a2:	d106      	bne.n	f8b2 <ble_ll_resolv_rpa+0x5e>
    f8a4:	78a0      	ldrb	r0, [r4, #2]
    f8a6:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
    f8aa:	1a1b      	subs	r3, r3, r0
    f8ac:	4258      	negs	r0, r3
    f8ae:	4158      	adcs	r0, r3
    f8b0:	e000      	b.n	f8b4 <ble_ll_resolv_rpa+0x60>
        (ecb.cipher_text[13] == rpa[2])) {
        rc = 1;
    } else {
        rc = 0;
    f8b2:	2000      	movs	r0, #0
    }

    return rc;
}
    f8b4:	b00d      	add	sp, #52	; 0x34
    f8b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000f8b8 <ble_ll_resolv_enabled>:
 */
uint8_t
ble_ll_resolv_enabled(void)
{
    return g_ble_ll_addr_res_enabled;
}
    f8b8:	4b01      	ldr	r3, [pc, #4]	; (f8c0 <ble_ll_resolv_enabled+0x8>)
    f8ba:	7818      	ldrb	r0, [r3, #0]
    f8bc:	4770      	bx	lr
    f8be:	bf00      	nop
    f8c0:	200036c4 	.word	0x200036c4

0000f8c4 <ble_ll_resolv_init>:
    ble_ll_resolv_init();
}

void
ble_ll_resolv_init(void)
{
    f8c4:	b508      	push	{r3, lr}
    uint8_t hw_size;

    /* Default is 15 minutes */
    g_ble_ll_resolv_rpa_tmo = 15 * 60 * OS_TICKS_PER_SEC;
    f8c6:	4b06      	ldr	r3, [pc, #24]	; (f8e0 <ble_ll_resolv_init+0x1c>)
    f8c8:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
    f8cc:	601a      	str	r2, [r3, #0]

    hw_size = ble_hw_resolv_list_size();
    f8ce:	f001 fa93 	bl	10df8 <ble_hw_resolv_list_size>
    if (hw_size > NIMBLE_OPT_LL_RESOLV_LIST_SIZE) {
        hw_size = NIMBLE_OPT_LL_RESOLV_LIST_SIZE;
    }
    g_ble_ll_resolv_list_size = hw_size;
    f8d2:	4b04      	ldr	r3, [pc, #16]	; (f8e4 <ble_ll_resolv_init+0x20>)
    f8d4:	2804      	cmp	r0, #4
    f8d6:	bf28      	it	cs
    f8d8:	2004      	movcs	r0, #4
    f8da:	7018      	strb	r0, [r3, #0]
    f8dc:	bd08      	pop	{r3, pc}
    f8de:	bf00      	nop
    f8e0:	200036c8 	.word	0x200036c8
    f8e4:	200036c5 	.word	0x200036c5

0000f8e8 <ble_ll_resolv_list_reset>:
/**
 * Called to reset private address resolution module.
 */
void
ble_ll_resolv_list_reset(void)
{
    f8e8:	b508      	push	{r3, lr}
    g_ble_ll_addr_res_enabled = 0;
    f8ea:	4b04      	ldr	r3, [pc, #16]	; (f8fc <ble_ll_resolv_list_reset+0x14>)
    f8ec:	2200      	movs	r2, #0
    f8ee:	701a      	strb	r2, [r3, #0]
    ble_ll_resolv_list_clr();
    f8f0:	f7ff fe7c 	bl	f5ec <ble_ll_resolv_list_clr>
    ble_ll_resolv_init();
}
    f8f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void
ble_ll_resolv_list_reset(void)
{
    g_ble_ll_addr_res_enabled = 0;
    ble_ll_resolv_list_clr();
    ble_ll_resolv_init();
    f8f8:	f7ff bfe4 	b.w	f8c4 <ble_ll_resolv_init>
    f8fc:	200036c4 	.word	0x200036c4

0000f900 <ble_ll_scan_find_dup_adv>:
 *
 * @return uint8_t 0: not on list; any other value is
 */
static struct ble_ll_scan_advertisers *
ble_ll_scan_find_dup_adv(uint8_t *addr, uint8_t txadd)
{
    f900:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t num_advs;
    struct ble_ll_scan_advertisers *adv;

    /* Do we have an address match? Must match address type */
    adv = &g_ble_ll_scan_dup_advs[0];
    num_advs = g_ble_ll_scan_num_dup_advs;
    f904:	4b0f      	ldr	r3, [pc, #60]	; (f944 <ble_ll_scan_find_dup_adv+0x44>)
    f906:	4d10      	ldr	r5, [pc, #64]	; (f948 <ble_ll_scan_find_dup_adv+0x48>)
    f908:	781c      	ldrb	r4, [r3, #0]
 *
 * @return uint8_t 0: not on list; any other value is
 */
static struct ble_ll_scan_advertisers *
ble_ll_scan_find_dup_adv(uint8_t *addr, uint8_t txadd)
{
    f90a:	4607      	mov	r7, r0
    f90c:	4688      	mov	r8, r1
    f90e:	1eae      	subs	r6, r5, #2
    struct ble_ll_scan_advertisers *adv;

    /* Do we have an address match? Must match address type */
    adv = &g_ble_ll_scan_dup_advs[0];
    num_advs = g_ble_ll_scan_num_dup_advs;
    while (num_advs) {
    f910:	b19c      	cbz	r4, f93a <ble_ll_scan_find_dup_adv+0x3a>
        if (!memcmp(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN)) {
    f912:	4628      	mov	r0, r5
    f914:	4639      	mov	r1, r7
    f916:	2206      	movs	r2, #6
    f918:	f7f9 fb62 	bl	8fe0 <memcmp>
    f91c:	b948      	cbnz	r0, f932 <ble_ll_scan_find_dup_adv+0x32>
    f91e:	f835 3c02 	ldrh.w	r3, [r5, #-2]
            /* Address type must match */
            if (txadd) {
    f922:	f1b8 0f00 	cmp.w	r8, #0
    f926:	d002      	beq.n	f92e <ble_ll_scan_find_dup_adv+0x2e>
                if ((adv->sc_adv_flags & BLE_LL_SC_ADV_F_RANDOM_ADDR) == 0) {
    f928:	07da      	lsls	r2, r3, #31
    f92a:	d502      	bpl.n	f932 <ble_ll_scan_find_dup_adv+0x32>
    f92c:	e006      	b.n	f93c <ble_ll_scan_find_dup_adv+0x3c>
                    goto next_dup_adv;
                }
            } else {
                if (adv->sc_adv_flags & BLE_LL_SC_ADV_F_RANDOM_ADDR) {
    f92e:	07db      	lsls	r3, r3, #31
    f930:	d504      	bpl.n	f93c <ble_ll_scan_find_dup_adv+0x3c>
            return adv;
        }

next_dup_adv:
        ++adv;
        --num_advs;
    f932:	3c01      	subs	r4, #1
    f934:	b2e4      	uxtb	r4, r4
    f936:	3508      	adds	r5, #8
    f938:	e7e9      	b.n	f90e <ble_ll_scan_find_dup_adv+0xe>
    }

    return NULL;
    f93a:	4626      	mov	r6, r4
}
    f93c:	4630      	mov	r0, r6
    f93e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f942:	bf00      	nop
    f944:	20001eb1 	.word	0x20001eb1
    f948:	200036d2 	.word	0x200036d2

0000f94c <ble_ll_scan_have_rxd_scan_rsp>:
 *
 * @return int 0: have not received a scan response; 1 otherwise.
 */
static int
ble_ll_scan_have_rxd_scan_rsp(uint8_t *addr, uint8_t txadd)
{
    f94c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t num_advs;
    struct ble_ll_scan_advertisers *adv;

    /* Do we have an address match? Must match address type */
    adv = &g_ble_ll_scan_rsp_advs[0];
    num_advs = g_ble_ll_scan_num_rsp_advs;
    f94e:	4b0e      	ldr	r3, [pc, #56]	; (f988 <ble_ll_scan_have_rxd_scan_rsp+0x3c>)
    f950:	4d0e      	ldr	r5, [pc, #56]	; (f98c <ble_ll_scan_have_rxd_scan_rsp+0x40>)
    f952:	781c      	ldrb	r4, [r3, #0]
 *
 * @return int 0: have not received a scan response; 1 otherwise.
 */
static int
ble_ll_scan_have_rxd_scan_rsp(uint8_t *addr, uint8_t txadd)
{
    f954:	4606      	mov	r6, r0
    f956:	460f      	mov	r7, r1
    struct ble_ll_scan_advertisers *adv;

    /* Do we have an address match? Must match address type */
    adv = &g_ble_ll_scan_rsp_advs[0];
    num_advs = g_ble_ll_scan_num_rsp_advs;
    while (num_advs) {
    f958:	b18c      	cbz	r4, f97e <ble_ll_scan_have_rxd_scan_rsp+0x32>
        if (!memcmp(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN)) {
    f95a:	4628      	mov	r0, r5
    f95c:	4631      	mov	r1, r6
    f95e:	2206      	movs	r2, #6
    f960:	f7f9 fb3e 	bl	8fe0 <memcmp>
    f964:	b938      	cbnz	r0, f976 <ble_ll_scan_have_rxd_scan_rsp+0x2a>
    f966:	f835 3c02 	ldrh.w	r3, [r5, #-2]
            /* Address type must match */
            if (txadd) {
    f96a:	b117      	cbz	r7, f972 <ble_ll_scan_have_rxd_scan_rsp+0x26>
                if (adv->sc_adv_flags & BLE_LL_SC_ADV_F_RANDOM_ADDR) {
    f96c:	07da      	lsls	r2, r3, #31
    f96e:	d502      	bpl.n	f976 <ble_ll_scan_have_rxd_scan_rsp+0x2a>
    f970:	e007      	b.n	f982 <ble_ll_scan_have_rxd_scan_rsp+0x36>
                    return 1;
                }
            } else {
                if ((adv->sc_adv_flags & BLE_LL_SC_ADV_F_RANDOM_ADDR) == 0) {
    f972:	07db      	lsls	r3, r3, #31
    f974:	d505      	bpl.n	f982 <ble_ll_scan_have_rxd_scan_rsp+0x36>
                    return 1;
                }
            }
        }
        ++adv;
        --num_advs;
    f976:	3c01      	subs	r4, #1
    f978:	b2e4      	uxtb	r4, r4
    f97a:	3508      	adds	r5, #8
    f97c:	e7ec      	b.n	f958 <ble_ll_scan_have_rxd_scan_rsp+0xc>
    }

    return 0;
    f97e:	4620      	mov	r0, r4
    f980:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while (num_advs) {
        if (!memcmp(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN)) {
            /* Address type must match */
            if (txadd) {
                if (adv->sc_adv_flags & BLE_LL_SC_ADV_F_RANDOM_ADDR) {
                    return 1;
    f982:	2001      	movs	r0, #1
        ++adv;
        --num_advs;
    }

    return 0;
}
    f984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f986:	bf00      	nop
    f988:	20001eb0 	.word	0x20001eb0
    f98c:	20003712 	.word	0x20003712

0000f990 <ble_ll_scan_req_backoff>:
g_ble_ll_scan_dup_advs[NIMBLE_OPT_LL_NUM_SCAN_DUP_ADVS];

/* See Vol 6 Part B Section 4.4.3.2. Active scanning backoff */
static void
ble_ll_scan_req_backoff(struct ble_ll_scan_sm *scansm, int success)
{
    f990:	b510      	push	{r4, lr}
    f992:	4604      	mov	r4, r0
    scansm->scan_rsp_pending = 0;
    f994:	2000      	movs	r0, #0
    f996:	71a0      	strb	r0, [r4, #6]
    f998:	4a1b      	ldr	r2, [pc, #108]	; (fa08 <ble_ll_scan_req_backoff+0x78>)
    if (success) {
    f99a:	b189      	cbz	r1, f9c0 <ble_ll_scan_req_backoff+0x30>
        scansm->scan_rsp_cons_fails = 0;
        ++scansm->scan_rsp_cons_ok;
    f99c:	7a23      	ldrb	r3, [r4, #8]
static void
ble_ll_scan_req_backoff(struct ble_ll_scan_sm *scansm, int success)
{
    scansm->scan_rsp_pending = 0;
    if (success) {
        scansm->scan_rsp_cons_fails = 0;
    f99e:	71e0      	strb	r0, [r4, #7]
        ++scansm->scan_rsp_cons_ok;
    f9a0:	3301      	adds	r3, #1
    f9a2:	b2db      	uxtb	r3, r3
        if (scansm->scan_rsp_cons_ok == 2) {
    f9a4:	2b02      	cmp	r3, #2
    f9a6:	d001      	beq.n	f9ac <ble_ll_scan_req_backoff+0x1c>
ble_ll_scan_req_backoff(struct ble_ll_scan_sm *scansm, int success)
{
    scansm->scan_rsp_pending = 0;
    if (success) {
        scansm->scan_rsp_cons_fails = 0;
        ++scansm->scan_rsp_cons_ok;
    f9a8:	7223      	strb	r3, [r4, #8]
    f9aa:	e005      	b.n	f9b8 <ble_ll_scan_req_backoff+0x28>
        if (scansm->scan_rsp_cons_ok == 2) {
            scansm->scan_rsp_cons_ok = 0;
            if (scansm->upper_limit > 1) {
    f9ac:	8a23      	ldrh	r3, [r4, #16]
    scansm->scan_rsp_pending = 0;
    if (success) {
        scansm->scan_rsp_cons_fails = 0;
        ++scansm->scan_rsp_cons_ok;
        if (scansm->scan_rsp_cons_ok == 2) {
            scansm->scan_rsp_cons_ok = 0;
    f9ae:	7220      	strb	r0, [r4, #8]
            if (scansm->upper_limit > 1) {
    f9b0:	2b01      	cmp	r3, #1
                scansm->upper_limit >>= 1;
    f9b2:	bf84      	itt	hi
    f9b4:	085b      	lsrhi	r3, r3, #1
    f9b6:	8223      	strhhi	r3, [r4, #16]
            }
        }
        STATS_INC(ble_ll_stats, scan_req_txg);
    f9b8:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    f9ba:	3301      	adds	r3, #1
    f9bc:	67d3      	str	r3, [r2, #124]	; 0x7c
    f9be:	e010      	b.n	f9e2 <ble_ll_scan_req_backoff+0x52>
    } else {
        scansm->scan_rsp_cons_ok = 0;
        ++scansm->scan_rsp_cons_fails;
    f9c0:	79e3      	ldrb	r3, [r4, #7]
                scansm->upper_limit >>= 1;
            }
        }
        STATS_INC(ble_ll_stats, scan_req_txg);
    } else {
        scansm->scan_rsp_cons_ok = 0;
    f9c2:	7221      	strb	r1, [r4, #8]
        ++scansm->scan_rsp_cons_fails;
    f9c4:	3301      	adds	r3, #1
    f9c6:	b2db      	uxtb	r3, r3
        if (scansm->scan_rsp_cons_fails == 2) {
    f9c8:	2b02      	cmp	r3, #2
    f9ca:	d001      	beq.n	f9d0 <ble_ll_scan_req_backoff+0x40>
            }
        }
        STATS_INC(ble_ll_stats, scan_req_txg);
    } else {
        scansm->scan_rsp_cons_ok = 0;
        ++scansm->scan_rsp_cons_fails;
    f9cc:	71e3      	strb	r3, [r4, #7]
    f9ce:	e005      	b.n	f9dc <ble_ll_scan_req_backoff+0x4c>
        if (scansm->scan_rsp_cons_fails == 2) {
            scansm->scan_rsp_cons_fails = 0;
            if (scansm->upper_limit < 256) {
    f9d0:	8a23      	ldrh	r3, [r4, #16]
        STATS_INC(ble_ll_stats, scan_req_txg);
    } else {
        scansm->scan_rsp_cons_ok = 0;
        ++scansm->scan_rsp_cons_fails;
        if (scansm->scan_rsp_cons_fails == 2) {
            scansm->scan_rsp_cons_fails = 0;
    f9d2:	71e1      	strb	r1, [r4, #7]
            if (scansm->upper_limit < 256) {
    f9d4:	2bff      	cmp	r3, #255	; 0xff
                scansm->upper_limit <<= 1;
    f9d6:	bf9c      	itt	ls
    f9d8:	005b      	lslls	r3, r3, #1
    f9da:	8223      	strhls	r3, [r4, #16]
            }
        }
        STATS_INC(ble_ll_stats, scan_req_txf);
    f9dc:	6f93      	ldr	r3, [r2, #120]	; 0x78
    f9de:	3301      	adds	r3, #1
    f9e0:	6793      	str	r3, [r2, #120]	; 0x78
    f9e2:	f7f9 faf5 	bl	8fd0 <lrand48>
    }

    scansm->backoff_count = rand() & (scansm->upper_limit - 1);
    f9e6:	8a23      	ldrh	r3, [r4, #16]
    f9e8:	3b01      	subs	r3, #1
    f9ea:	4018      	ands	r0, r3
    ++scansm->backoff_count;
    f9ec:	3001      	adds	r0, #1
    f9ee:	b280      	uxth	r0, r0
    assert(scansm->backoff_count <= 256);
    f9f0:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
        }
        STATS_INC(ble_ll_stats, scan_req_txf);
    }

    scansm->backoff_count = rand() & (scansm->upper_limit - 1);
    ++scansm->backoff_count;
    f9f4:	8260      	strh	r0, [r4, #18]
    assert(scansm->backoff_count <= 256);
    f9f6:	d905      	bls.n	fa04 <ble_ll_scan_req_backoff+0x74>
    f9f8:	2200      	movs	r2, #0
    f9fa:	4804      	ldr	r0, [pc, #16]	; (fa0c <ble_ll_scan_req_backoff+0x7c>)
    f9fc:	2175      	movs	r1, #117	; 0x75
    f9fe:	4613      	mov	r3, r2
    fa00:	f7fa f966 	bl	9cd0 <__assert_func>
    fa04:	bd10      	pop	{r4, pc}
    fa06:	bf00      	nop
    fa08:	200030ac 	.word	0x200030ac
    fa0c:	0001f2e3 	.word	0x0001f2e3

0000fa10 <ble_ll_scan_start>:
 *
 * @return int
 */
static void
ble_ll_scan_start(struct ble_ll_scan_sm *scansm, uint8_t chan)
{
    fa10:	b510      	push	{r4, lr}
    fa12:	4604      	mov	r4, r0
    int rc;

    /* Set channel */
    rc = ble_phy_setchan(chan, 0, 0);
    fa14:	4608      	mov	r0, r1
    fa16:	2100      	movs	r1, #0
    fa18:	460a      	mov	r2, r1
    fa1a:	f001 fbab 	bl	11174 <ble_phy_setchan>
    assert(rc == 0);
    fa1e:	4601      	mov	r1, r0
    fa20:	b130      	cbz	r0, fa30 <ble_ll_scan_start+0x20>
    fa22:	2200      	movs	r2, #0
    fa24:	4816      	ldr	r0, [pc, #88]	; (fa80 <ble_ll_scan_start+0x70>)
    fa26:	f240 2133 	movw	r1, #563	; 0x233
    fa2a:	4613      	mov	r3, r2
    fa2c:	f7fa f950 	bl	9cd0 <__assert_func>

    /*
     * Set transmit end callback to NULL in case we transmit a scan request.
     * There is a callback for the connect request.
     */
    ble_phy_set_txend_cb(NULL, NULL);
    fa30:	f001 fb7a 	bl	11128 <ble_phy_set_txend_cb>

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    ble_phy_encrypt_disable();
    fa34:	f001 fb62 	bl	110fc <ble_phy_encrypt_disable>
#endif

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_resolv_enabled()) {
    fa38:	f7ff ff3e 	bl	f8b8 <ble_ll_resolv_enabled>
    fa3c:	b110      	cbz	r0, fa44 <ble_ll_scan_start+0x34>
        ble_phy_resolv_list_enable();
    fa3e:	f001 fe35 	bl	116ac <ble_phy_resolv_list_enable>
    fa42:	e001      	b.n	fa48 <ble_ll_scan_start+0x38>
    } else {
        ble_phy_resolv_list_disable();
    fa44:	f001 fe42 	bl	116cc <ble_phy_resolv_list_disable>
    }
#endif

    /* Start receiving */
    rc = ble_phy_rx();
    fa48:	f001 fd34 	bl	114b4 <ble_phy_rx>
    if (!rc) {
    fa4c:	b970      	cbnz	r0, fa6c <ble_ll_scan_start+0x5c>
        /* Enable/disable whitelisting */
        if (scansm->scan_filt_policy & 1) {
    fa4e:	7923      	ldrb	r3, [r4, #4]
    fa50:	07db      	lsls	r3, r3, #31
    fa52:	d502      	bpl.n	fa5a <ble_ll_scan_start+0x4a>
            ble_ll_whitelist_enable();
    fa54:	f001 f868 	bl	10b28 <ble_ll_whitelist_enable>
    fa58:	e001      	b.n	fa5e <ble_ll_scan_start+0x4e>
        } else {
            ble_ll_whitelist_disable();
    fa5a:	f001 f867 	bl	10b2c <ble_ll_whitelist_disable>
        }

        /* Set link layer state to scanning */
        if (scansm->scan_type == BLE_SCAN_TYPE_INITIATE) {
    fa5e:	7863      	ldrb	r3, [r4, #1]
    fa60:	2b02      	cmp	r3, #2
            ble_ll_state_set(BLE_LL_STATE_INITIATING);
    fa62:	bf0c      	ite	eq
    fa64:	2003      	moveq	r0, #3
        } else {
            ble_ll_state_set(BLE_LL_STATE_SCANNING);
    fa66:	2002      	movne	r0, #2
    fa68:	f7fb fb3c 	bl	b0e4 <ble_ll_state_set>
        }
    }

    /* If there is a still a scan response pending, we have failed! */
    if (scansm->scan_rsp_pending) {
    fa6c:	79a3      	ldrb	r3, [r4, #6]
    fa6e:	b12b      	cbz	r3, fa7c <ble_ll_scan_start+0x6c>
        ble_ll_scan_req_backoff(scansm, 0);
    fa70:	4620      	mov	r0, r4
    fa72:	2100      	movs	r1, #0
    }
}
    fa74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        }
    }

    /* If there is a still a scan response pending, we have failed! */
    if (scansm->scan_rsp_pending) {
        ble_ll_scan_req_backoff(scansm, 0);
    fa78:	f7ff bf8a 	b.w	f990 <ble_ll_scan_req_backoff>
    fa7c:	bd10      	pop	{r4, pc}
    fa7e:	bf00      	nop
    fa80:	0001f2e3 	.word	0x0001f2e3

0000fa84 <ble_ll_scan_timer_cb>:
ble_ll_scan_timer_cb(void *arg)
{
    struct ble_ll_scan_sm *scansm;

    scansm = (struct ble_ll_scan_sm *)arg;
    ble_ll_event_send(&scansm->scan_sched_ev);
    fa84:	3020      	adds	r0, #32
    fa86:	f7fb bb39 	b.w	b0fc <ble_ll_event_send>
	...

0000fa8c <ble_ll_scan_sm_start.constprop.3>:
        OS_EXIT_CRITICAL(sr);
    }
}

static int
ble_ll_scan_sm_start(struct ble_ll_scan_sm *scansm)
    fa8c:	b538      	push	{r3, r4, r5, lr}
     * command disallowed error if no random address has been sent by the
     * host. All the parameter errors refer to the command parameter
     * (which in this case is just enable or disable) so that is why I chose
     * command disallowed.
     */
    if (scansm->own_addr_type == BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    fa8e:	4c11      	ldr	r4, [pc, #68]	; (fad4 <ble_ll_scan_sm_start.constprop.3+0x48>)
    fa90:	78a3      	ldrb	r3, [r4, #2]
    fa92:	2b01      	cmp	r3, #1
    fa94:	d017      	beq.n	fac6 <ble_ll_scan_sm_start.constprop.3+0x3a>
            return BLE_ERR_CMD_DISALLOWED;
        }
    }

    /* Count # of times started */
    STATS_INC(ble_ll_stats, scan_starts);
    fa96:	4a10      	ldr	r2, [pc, #64]	; (fad8 <ble_ll_scan_sm_start.constprop.3+0x4c>)
    fa98:	6f13      	ldr	r3, [r2, #112]	; 0x70
    fa9a:	3301      	adds	r3, #1
    fa9c:	6713      	str	r3, [r2, #112]	; 0x70

    /* Set flag telling us that scanning is enabled */
    scansm->scan_enabled = 1;
    fa9e:	2301      	movs	r3, #1
    faa0:	7023      	strb	r3, [r4, #0]

    /* Set first advertising channel */
    scansm->scan_chan = BLE_PHY_ADV_CHAN_START;

    /* Reset scan request backoff parameters to default */
    scansm->upper_limit = 1;
    faa2:	8223      	strh	r3, [r4, #16]
    scansm->backoff_count = 1;
    faa4:	8263      	strh	r3, [r4, #18]
    scansm->scan_rsp_pending = 0;

    /* Forget filtered advertisers from previous scan. */
    g_ble_ll_scan_num_rsp_advs = 0;
    faa6:	4b0d      	ldr	r3, [pc, #52]	; (fadc <ble_ll_scan_sm_start.constprop.3+0x50>)
    scansm->scan_chan = BLE_PHY_ADV_CHAN_START;

    /* Reset scan request backoff parameters to default */
    scansm->upper_limit = 1;
    scansm->backoff_count = 1;
    scansm->scan_rsp_pending = 0;
    faa8:	2500      	movs	r5, #0

    /* Forget filtered advertisers from previous scan. */
    g_ble_ll_scan_num_rsp_advs = 0;
    faaa:	701d      	strb	r5, [r3, #0]
    g_ble_ll_scan_num_dup_advs = 0;
    faac:	4b0c      	ldr	r3, [pc, #48]	; (fae0 <ble_ll_scan_sm_start.constprop.3+0x54>)
    scansm->scan_chan = BLE_PHY_ADV_CHAN_START;

    /* Reset scan request backoff parameters to default */
    scansm->upper_limit = 1;
    scansm->backoff_count = 1;
    scansm->scan_rsp_pending = 0;
    faae:	71a5      	strb	r5, [r4, #6]

    /* Set flag telling us that scanning is enabled */
    scansm->scan_enabled = 1;

    /* Set first advertising channel */
    scansm->scan_chan = BLE_PHY_ADV_CHAN_START;
    fab0:	2225      	movs	r2, #37	; 0x25
    fab2:	70e2      	strb	r2, [r4, #3]
    scansm->backoff_count = 1;
    scansm->scan_rsp_pending = 0;

    /* Forget filtered advertisers from previous scan. */
    g_ble_ll_scan_num_rsp_advs = 0;
    g_ble_ll_scan_num_dup_advs = 0;
    fab4:	701d      	strb	r5, [r3, #0]

    /* XXX: align to current or next slot???. */
    /* Schedule start time now */
    scansm->scan_win_start_time = cputime_get32();
    fab6:	f7f9 fa41 	bl	8f3c <cputime_get32>
    faba:	61a0      	str	r0, [r4, #24]

    /* Post scanning event to start off the scanning process */
    ble_ll_event_send(&scansm->scan_sched_ev);
    fabc:	4809      	ldr	r0, [pc, #36]	; (fae4 <ble_ll_scan_sm_start.constprop.3+0x58>)
    fabe:	f7fb fb1d 	bl	b0fc <ble_ll_event_send>

    return BLE_ERR_SUCCESS;
    fac2:	4628      	mov	r0, r5
    fac4:	bd38      	pop	{r3, r4, r5, pc}
     * host. All the parameter errors refer to the command parameter
     * (which in this case is just enable or disable) so that is why I chose
     * command disallowed.
     */
    if (scansm->own_addr_type == BLE_HCI_ADV_OWN_ADDR_RANDOM) {
        if (!ble_ll_is_valid_random_addr(g_random_addr)) {
    fac6:	4808      	ldr	r0, [pc, #32]	; (fae8 <ble_ll_scan_sm_start.constprop.3+0x5c>)
    fac8:	f7fb f9d0 	bl	ae6c <ble_ll_is_valid_random_addr>
    facc:	2800      	cmp	r0, #0
    face:	d1e2      	bne.n	fa96 <ble_ll_scan_sm_start.constprop.3+0xa>
            return BLE_ERR_CMD_DISALLOWED;
    fad0:	200c      	movs	r0, #12

    /* Post scanning event to start off the scanning process */
    ble_ll_event_send(&scansm->scan_sched_ev);

    return BLE_ERR_SUCCESS;
}
    fad2:	bd38      	pop	{r3, r4, r5, pc}
    fad4:	20003750 	.word	0x20003750
    fad8:	200030ac 	.word	0x200030ac
    fadc:	20001eb0 	.word	0x20001eb0
    fae0:	20001eb1 	.word	0x20001eb1
    fae4:	20003770 	.word	0x20003770
    fae8:	20002810 	.word	0x20002810

0000faec <ble_ll_scan_is_dup_adv>:
 *
 * @return int 0: not a duplicate. 1:duplicate
 */
int
ble_ll_scan_is_dup_adv(uint8_t pdu_type, uint8_t txadd, uint8_t *addr)
{
    faec:	b510      	push	{r4, lr}
    faee:	4604      	mov	r4, r0
    struct ble_ll_scan_advertisers *adv;

    adv = ble_ll_scan_find_dup_adv(addr, txadd);
    faf0:	4610      	mov	r0, r2
    faf2:	f7ff ff05 	bl	f900 <ble_ll_scan_find_dup_adv>
    if (adv) {
    faf6:	b138      	cbz	r0, fb08 <ble_ll_scan_is_dup_adv+0x1c>
        /* Check appropriate flag (based on type of PDU) */
        if (pdu_type == BLE_ADV_PDU_TYPE_ADV_DIRECT_IND) {
    faf8:	2c01      	cmp	r4, #1
    fafa:	8800      	ldrh	r0, [r0, #0]
    fafc:	d102      	bne.n	fb04 <ble_ll_scan_is_dup_adv+0x18>
            if (adv->sc_adv_flags & BLE_LL_SC_ADV_F_DIRECT_RPT_SENT) {
    fafe:	f3c0 0080 	ubfx	r0, r0, #2, #1
    fb02:	bd10      	pop	{r4, pc}
                return 1;
            }
        } else {
            if (adv->sc_adv_flags & BLE_LL_SC_ADV_F_ADV_RPT_SENT) {
    fb04:	f3c0 00c0 	ubfx	r0, r0, #3, #1
            }
        }
    }

    return 0;
}
    fb08:	bd10      	pop	{r4, pc}
	...

0000fb0c <ble_ll_scan_add_dup_adv>:
 * @param Txadd. TxAdd bit (0 public, random otherwise)
 * @param subev  Type of advertising report sent (direct or normal).
 */
void
ble_ll_scan_add_dup_adv(uint8_t *addr, uint8_t txadd, uint8_t subev)
{
    fb0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    fb0e:	4606      	mov	r6, r0
    fb10:	460c      	mov	r4, r1
    fb12:	4617      	mov	r7, r2
    uint8_t num_advs;
    struct ble_ll_scan_advertisers *adv;

    /* Check to see if on list. */
    adv = ble_ll_scan_find_dup_adv(addr, txadd);
    fb14:	f7ff fef4 	bl	f900 <ble_ll_scan_find_dup_adv>
    if (!adv) {
    fb18:	b9a0      	cbnz	r0, fb44 <ble_ll_scan_add_dup_adv+0x38>
        /* XXX: for now, if we dont have room, just leave */
        num_advs = g_ble_ll_scan_num_dup_advs;
    fb1a:	4d0f      	ldr	r5, [pc, #60]	; (fb58 <ble_ll_scan_add_dup_adv+0x4c>)
    fb1c:	782b      	ldrb	r3, [r5, #0]
        if (num_advs == NIMBLE_OPT_LL_NUM_SCAN_DUP_ADVS) {
    fb1e:	2b08      	cmp	r3, #8
    fb20:	d018      	beq.n	fb54 <ble_ll_scan_add_dup_adv+0x48>
            return;
        }

        /* Add the advertiser to the array */
        adv = &g_ble_ll_scan_dup_advs[num_advs];
    fb22:	490e      	ldr	r1, [pc, #56]	; (fb5c <ble_ll_scan_add_dup_adv+0x50>)
        memcpy(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN);
    fb24:	6832      	ldr	r2, [r6, #0]
        if (num_advs == NIMBLE_OPT_LL_NUM_SCAN_DUP_ADVS) {
            return;
        }

        /* Add the advertiser to the array */
        adv = &g_ble_ll_scan_dup_advs[num_advs];
    fb26:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
        memcpy(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN);
    fb2a:	f8c0 2002 	str.w	r2, [r0, #2]
    fb2e:	88b2      	ldrh	r2, [r6, #4]
    fb30:	80c2      	strh	r2, [r0, #6]
        ++g_ble_ll_scan_num_dup_advs;
    fb32:	1c5a      	adds	r2, r3, #1
    fb34:	702a      	strb	r2, [r5, #0]

        adv->sc_adv_flags = 0;
        if (txadd) {
    fb36:	b914      	cbnz	r4, fb3e <ble_ll_scan_add_dup_adv+0x32>
        /* Add the advertiser to the array */
        adv = &g_ble_ll_scan_dup_advs[num_advs];
        memcpy(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN);
        ++g_ble_ll_scan_num_dup_advs;

        adv->sc_adv_flags = 0;
    fb38:	f821 4033 	strh.w	r4, [r1, r3, lsl #3]
    fb3c:	e002      	b.n	fb44 <ble_ll_scan_add_dup_adv+0x38>
        if (txadd) {
            adv->sc_adv_flags |= BLE_LL_SC_ADV_F_RANDOM_ADDR;
    fb3e:	2201      	movs	r2, #1
    fb40:	f821 2033 	strh.w	r2, [r1, r3, lsl #3]
    fb44:	8803      	ldrh	r3, [r0, #0]
        }
    }

    if (subev == BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT) {
    fb46:	2f0b      	cmp	r7, #11
        adv->sc_adv_flags |= BLE_LL_SC_ADV_F_DIRECT_RPT_SENT;
    fb48:	bf0c      	ite	eq
    fb4a:	f043 0304 	orreq.w	r3, r3, #4
    } else {
        adv->sc_adv_flags |= BLE_LL_SC_ADV_F_ADV_RPT_SENT;
    fb4e:	f043 0308 	orrne.w	r3, r3, #8
    fb52:	8003      	strh	r3, [r0, #0]
    fb54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    fb56:	bf00      	nop
    fb58:	20001eb1 	.word	0x20001eb1
    fb5c:	200036d0 	.word	0x200036d0

0000fb60 <ble_ll_scan_sm_stop>:
/**
 * Stop the scanning state machine
 */
void
ble_ll_scan_sm_stop(int chk_disable)
{
    fb60:	b570      	push	{r4, r5, r6, lr}
    uint8_t lls;
    struct ble_ll_scan_sm *scansm;

    /* Stop the scanning timer  */
    scansm = &g_ble_ll_scan_sm;
    cputime_timer_stop(&scansm->scan_timer);
    fb62:	4d10      	ldr	r5, [pc, #64]	; (fba4 <ble_ll_scan_sm_stop+0x44>)
/**
 * Stop the scanning state machine
 */
void
ble_ll_scan_sm_stop(int chk_disable)
{
    fb64:	4606      	mov	r6, r0
    uint8_t lls;
    struct ble_ll_scan_sm *scansm;

    /* Stop the scanning timer  */
    scansm = &g_ble_ll_scan_sm;
    cputime_timer_stop(&scansm->scan_timer);
    fb66:	4628      	mov	r0, r5
    fb68:	f7f9 f92a 	bl	8dc0 <cputime_timer_stop>

    /* Disable scanning state machine */
    scansm->scan_enabled = 0;

    /* Count # of times stopped */
    STATS_INC(ble_ll_stats, scan_stops);
    fb6c:	4a0e      	ldr	r2, [pc, #56]	; (fba8 <ble_ll_scan_sm_stop+0x48>)
    fb6e:	6f53      	ldr	r3, [r2, #116]	; 0x74
    /* Stop the scanning timer  */
    scansm = &g_ble_ll_scan_sm;
    cputime_timer_stop(&scansm->scan_timer);

    /* Disable scanning state machine */
    scansm->scan_enabled = 0;
    fb70:	2400      	movs	r4, #0

    /* Count # of times stopped */
    STATS_INC(ble_ll_stats, scan_stops);
    fb72:	3301      	adds	r3, #1
    /* Stop the scanning timer  */
    scansm = &g_ble_ll_scan_sm;
    cputime_timer_stop(&scansm->scan_timer);

    /* Disable scanning state machine */
    scansm->scan_enabled = 0;
    fb74:	f805 4c2c 	strb.w	r4, [r5, #-44]

    /* Count # of times stopped */
    STATS_INC(ble_ll_stats, scan_stops);
    fb78:	6753      	str	r3, [r2, #116]	; 0x74

    /* Only set state if we are currently in a scan window */
    if (chk_disable) {
    fb7a:	b196      	cbz	r6, fba2 <ble_ll_scan_sm_stop+0x42>
        OS_ENTER_CRITICAL(sr);
    fb7c:	f7f9 fed0 	bl	9920 <os_arch_save_sr>
    fb80:	4605      	mov	r5, r0
        lls = ble_ll_state_get();
    fb82:	f7fb fab5 	bl	b0f0 <ble_ll_state_get>
        if ((lls == BLE_LL_STATE_SCANNING) || (lls == BLE_LL_STATE_INITIATING)) {
    fb86:	3802      	subs	r0, #2
    fb88:	b2c0      	uxtb	r0, r0
    fb8a:	2801      	cmp	r0, #1
    fb8c:	d804      	bhi.n	fb98 <ble_ll_scan_sm_stop+0x38>
            /* Disable phy */
            ble_phy_disable();
    fb8e:	f001 fb45 	bl	1121c <ble_phy_disable>

            /* Set LL state to standby */
            ble_ll_state_set(BLE_LL_STATE_STANDBY);
    fb92:	4620      	mov	r0, r4
    fb94:	f7fb faa6 	bl	b0e4 <ble_ll_state_set>
        }
        OS_EXIT_CRITICAL(sr);
    fb98:	4628      	mov	r0, r5
    }
}
    fb9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ble_phy_disable();

            /* Set LL state to standby */
            ble_ll_state_set(BLE_LL_STATE_STANDBY);
        }
        OS_EXIT_CRITICAL(sr);
    fb9e:	f7f9 bec5 	b.w	992c <os_arch_restore_sr>
    fba2:	bd70      	pop	{r4, r5, r6, pc}
    fba4:	2000377c 	.word	0x2000377c
    fba8:	200030ac 	.word	0x200030ac

0000fbac <ble_ll_scan_event_proc>:
 *
 * @param arg
 */
void
ble_ll_scan_event_proc(void *arg)
{
    fbac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /*
     * Get the scanning state machine. If not enabled (this is possible), just
     * leave and do nothing (just make sure timer is stopped).
     */
    scansm = (struct ble_ll_scan_sm *)arg;
    if (!scansm->scan_enabled) {
    fbae:	7803      	ldrb	r3, [r0, #0]
 *
 * @param arg
 */
void
ble_ll_scan_event_proc(void *arg)
{
    fbb0:	4604      	mov	r4, r0
    /*
     * Get the scanning state machine. If not enabled (this is possible), just
     * leave and do nothing (just make sure timer is stopped).
     */
    scansm = (struct ble_ll_scan_sm *)arg;
    if (!scansm->scan_enabled) {
    fbb2:	b923      	cbnz	r3, fbbe <ble_ll_scan_event_proc+0x12>
        cputime_timer_stop(&scansm->scan_timer);
    fbb4:	302c      	adds	r0, #44	; 0x2c
        ble_ll_scan_start(scansm, scansm->scan_chan);
    }
    OS_EXIT_CRITICAL(sr);

    cputime_timer_start(&scansm->scan_timer, next_event_time);
}
    fbb6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
     * Get the scanning state machine. If not enabled (this is possible), just
     * leave and do nothing (just make sure timer is stopped).
     */
    scansm = (struct ble_ll_scan_sm *)arg;
    if (!scansm->scan_enabled) {
        cputime_timer_stop(&scansm->scan_timer);
    fbba:	f7f9 b901 	b.w	8dc0 <cputime_timer_stop>
        return;
    }

    /* Make sure the scan window start time and channel are up to date. */
    now = cputime_get32();
    fbbe:	f7f9 f9bd 	bl	8f3c <cputime_get32>

    scan_itvl = cputime_usecs_to_ticks(scansm->scan_itvl * BLE_HCI_SCAN_ITVL);
    fbc2:	8aa3      	ldrh	r3, [r4, #20]
        cputime_timer_stop(&scansm->scan_timer);
        return;
    }

    /* Make sure the scan window start time and channel are up to date. */
    now = cputime_get32();
    fbc4:	4605      	mov	r5, r0

    scan_itvl = cputime_usecs_to_ticks(scansm->scan_itvl * BLE_HCI_SCAN_ITVL);
    fbc6:	f240 2071 	movw	r0, #625	; 0x271
    fbca:	4358      	muls	r0, r3
    fbcc:	f7f9 f872 	bl	8cb4 <cputime_usecs_to_ticks>
    chan = scansm->scan_chan;
    win_start = scansm->scan_win_start_time;
    fbd0:	69a7      	ldr	r7, [r4, #24]

    /* Make sure the scan window start time and channel are up to date. */
    now = cputime_get32();

    scan_itvl = cputime_usecs_to_ticks(scansm->scan_itvl * BLE_HCI_SCAN_ITVL);
    chan = scansm->scan_chan;
    fbd2:	78e3      	ldrb	r3, [r4, #3]
    fbd4:	1bed      	subs	r5, r5, r7
    win_start = scansm->scan_win_start_time;
    while ((int32_t)(now - win_start) >= scan_itvl) {
    fbd6:	4285      	cmp	r5, r0
    fbd8:	eb07 0600 	add.w	r6, r7, r0
    fbdc:	d307      	bcc.n	fbee <ble_ll_scan_event_proc+0x42>
        win_start += scan_itvl;
        ++chan;
    fbde:	3301      	adds	r3, #1
    fbe0:	b2db      	uxtb	r3, r3
        if (chan == BLE_PHY_NUM_CHANS) {
            chan = BLE_PHY_ADV_CHAN_START;
    fbe2:	2b28      	cmp	r3, #40	; 0x28

    scan_itvl = cputime_usecs_to_ticks(scansm->scan_itvl * BLE_HCI_SCAN_ITVL);
    chan = scansm->scan_chan;
    win_start = scansm->scan_win_start_time;
    while ((int32_t)(now - win_start) >= scan_itvl) {
        win_start += scan_itvl;
    fbe4:	4637      	mov	r7, r6
        ++chan;
        if (chan == BLE_PHY_NUM_CHANS) {
            chan = BLE_PHY_ADV_CHAN_START;
    fbe6:	bf08      	it	eq
    fbe8:	2325      	moveq	r3, #37	; 0x25
    fbea:	1a2d      	subs	r5, r5, r0
    fbec:	e7f3      	b.n	fbd6 <ble_ll_scan_event_proc+0x2a>
        }
    }

    dt = now - win_start;
    scansm->scan_chan = chan;
    fbee:	70e3      	strb	r3, [r4, #3]
    scansm->scan_win_start_time = win_start;

    /* Determine on/off state based on scan window */
    rxstate = 1;
    next_event_time = win_start + scan_itvl;
    if (scansm->scan_window != scansm->scan_itvl) {
    fbf0:	8aa2      	ldrh	r2, [r4, #20]
    fbf2:	8ae3      	ldrh	r3, [r4, #22]
        }
    }

    dt = now - win_start;
    scansm->scan_chan = chan;
    scansm->scan_win_start_time = win_start;
    fbf4:	61a7      	str	r7, [r4, #24]

    /* Determine on/off state based on scan window */
    rxstate = 1;
    next_event_time = win_start + scan_itvl;
    if (scansm->scan_window != scansm->scan_itvl) {
    fbf6:	429a      	cmp	r2, r3
    fbf8:	d007      	beq.n	fc0a <ble_ll_scan_event_proc+0x5e>
        win = cputime_usecs_to_ticks(scansm->scan_window * BLE_HCI_SCAN_ITVL);
    fbfa:	f240 2071 	movw	r0, #625	; 0x271
    fbfe:	4358      	muls	r0, r3
    fc00:	f7f9 f858 	bl	8cb4 <cputime_usecs_to_ticks>
        if (dt >= win) {
    fc04:	4285      	cmp	r5, r0
    fc06:	d202      	bcs.n	fc0e <ble_ll_scan_event_proc+0x62>
            rxstate = 0;
        } else {
            next_event_time = win_start + win;
    fc08:	19c6      	adds	r6, r0, r7
    dt = now - win_start;
    scansm->scan_chan = chan;
    scansm->scan_win_start_time = win_start;

    /* Determine on/off state based on scan window */
    rxstate = 1;
    fc0a:	2501      	movs	r5, #1
    fc0c:	e000      	b.n	fc10 <ble_ll_scan_event_proc+0x64>
    next_event_time = win_start + scan_itvl;
    if (scansm->scan_window != scansm->scan_itvl) {
        win = cputime_usecs_to_ticks(scansm->scan_window * BLE_HCI_SCAN_ITVL);
        if (dt >= win) {
            rxstate = 0;
    fc0e:	2500      	movs	r5, #0
        } else {
            next_event_time = win_start + win;
        }
    }

    OS_ENTER_CRITICAL(sr);
    fc10:	f7f9 fe86 	bl	9920 <os_arch_save_sr>
    fc14:	4607      	mov	r7, r0
     * If we are not in the standby state it means that the scheduled
     * scanning event was overlapped in the schedule. In this case all we do
     * is post the scan schedule end event.
     */
    start_scan = 1;
    switch (ble_ll_state_get()) {
    fc16:	f7fb fa6b 	bl	b0f0 <ble_ll_state_get>
    fc1a:	2804      	cmp	r0, #4
    fc1c:	d807      	bhi.n	fc2e <ble_ll_scan_event_proc+0x82>
    fc1e:	e8df f000 	tbb	[pc, r0]
    fc22:	120d      	.short	0x120d
    fc24:	0303      	.short	0x0303
    fc26:	12          	.byte	0x12
    fc27:	00          	.byte	0x00
         start_scan = 0;
        break;
    case BLE_LL_STATE_INITIATING:
    case BLE_LL_STATE_SCANNING:
        /* Must disable PHY since we will move to a new channel */
        ble_phy_disable();
    fc28:	f001 faf8 	bl	1121c <ble_phy_disable>
        break;
    fc2c:	e006      	b.n	fc3c <ble_ll_scan_event_proc+0x90>
    case BLE_LL_STATE_STANDBY:
        break;
    default:
        assert(0);
    fc2e:	2200      	movs	r2, #0
    fc30:	480a      	ldr	r0, [pc, #40]	; (fc5c <ble_ll_scan_event_proc+0xb0>)
    fc32:	f240 312e 	movw	r1, #814	; 0x32e
    fc36:	4613      	mov	r3, r2
    fc38:	f7fa f84a 	bl	9cd0 <__assert_func>
        break;
    }
    if (start_scan && rxstate) {
    fc3c:	b11d      	cbz	r5, fc46 <ble_ll_scan_event_proc+0x9a>
        ble_ll_scan_start(scansm, scansm->scan_chan);
    fc3e:	4620      	mov	r0, r4
    fc40:	78e1      	ldrb	r1, [r4, #3]
    fc42:	f7ff fee5 	bl	fa10 <ble_ll_scan_start>
    }
    OS_EXIT_CRITICAL(sr);
    fc46:	4638      	mov	r0, r7
    fc48:	f7f9 fe70 	bl	992c <os_arch_restore_sr>

    cputime_timer_start(&scansm->scan_timer, next_event_time);
    fc4c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    fc50:	4631      	mov	r1, r6
}
    fc52:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (start_scan && rxstate) {
        ble_ll_scan_start(scansm, scansm->scan_chan);
    }
    OS_EXIT_CRITICAL(sr);

    cputime_timer_start(&scansm->scan_timer, next_event_time);
    fc56:	f7f9 b853 	b.w	8d00 <cputime_timer_start>
    fc5a:	bf00      	nop
    fc5c:	0001f2e3 	.word	0x0001f2e3

0000fc60 <ble_ll_scan_rx_isr_start>:
 *  0: we will not attempt to reply to this frame
 *  1: we may send a response to this frame.
 */
int
ble_ll_scan_rx_isr_start(uint8_t pdu_type, struct os_mbuf *rxpdu)
{
    fc60:	b510      	push	{r4, lr}
    struct ble_mbuf_hdr *ble_hdr;

    rc = 0;
    scansm = &g_ble_ll_scan_sm;

    switch (scansm->scan_type) {
    fc62:	4b0d      	ldr	r3, [pc, #52]	; (fc98 <ble_ll_scan_rx_isr_start+0x38>)
    fc64:	785c      	ldrb	r4, [r3, #1]
    fc66:	2c01      	cmp	r4, #1
    fc68:	d113      	bne.n	fc92 <ble_ll_scan_rx_isr_start+0x32>
    case BLE_SCAN_TYPE_ACTIVE:
        /* If adv ind or scan ind, we may send scan request */
        if ((pdu_type == BLE_ADV_PDU_TYPE_ADV_IND) ||
    fc6a:	b110      	cbz	r0, fc72 <ble_ll_scan_rx_isr_start+0x12>
    fc6c:	1f82      	subs	r2, r0, #6
    fc6e:	4254      	negs	r4, r2
    fc70:	4154      	adcs	r4, r2
         * denoted by the scan rsp pending flag), we set a bit in the ble
         * header so the link layer can check to see if the scan request
         * was successful. We do it this way to let the Link Layer do the
         * work for successful scan requests. If failed, we do the work here.
         */
        if (scansm->scan_rsp_pending) {
    fc72:	799b      	ldrb	r3, [r3, #6]
    fc74:	b153      	cbz	r3, fc8c <ble_ll_scan_rx_isr_start+0x2c>
            if (pdu_type == BLE_ADV_PDU_TYPE_SCAN_RSP) {
    fc76:	2804      	cmp	r0, #4
    fc78:	d104      	bne.n	fc84 <ble_ll_scan_rx_isr_start+0x24>
                ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
                ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_SCAN_RSP_CHK;
    fc7a:	7e0b      	ldrb	r3, [r1, #24]
    fc7c:	f043 0308 	orr.w	r3, r3, #8
    fc80:	760b      	strb	r3, [r1, #24]
    fc82:	e003      	b.n	fc8c <ble_ll_scan_rx_isr_start+0x2c>
            } else {
                ble_ll_scan_req_backoff(scansm, 0);
    fc84:	4804      	ldr	r0, [pc, #16]	; (fc98 <ble_ll_scan_rx_isr_start+0x38>)
    fc86:	2100      	movs	r1, #0
    fc88:	f7ff fe82 	bl	f990 <ble_ll_scan_req_backoff>
            }
        }

        /* Disable wfr if running */
        ble_ll_wfr_disable();
    fc8c:	f7fb f94e 	bl	af2c <ble_ll_wfr_disable>
        break;
    fc90:	e000      	b.n	fc94 <ble_ll_scan_rx_isr_start+0x34>
{
    int rc;
    struct ble_ll_scan_sm *scansm;
    struct ble_mbuf_hdr *ble_hdr;

    rc = 0;
    fc92:	2400      	movs	r4, #0
    default:
        break;
    }

    return rc;
}
    fc94:	4620      	mov	r0, r4
    fc96:	bd10      	pop	{r4, pc}
    fc98:	20003750 	.word	0x20003750

0000fc9c <ble_ll_scan_rx_isr_end>:
 *      == 0: Success. Do not disable the PHY.
 *       > 0: Do not disable PHY as that has already been done.
 */
int
ble_ll_scan_rx_isr_end(struct os_mbuf *rxpdu, uint8_t crcok)
{
    fc9c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
     * The reason we do something different here (as opposed to failed CRC) is
     * that the received PDU will not be handed up in this case. So we have
     * to restart scanning and handle a failed scan request. Note that we
     * return 0 in this case because we dont want the phy disabled.
     */
    if (rxpdu == NULL) {
    fca0:	4607      	mov	r7, r0
    fca2:	b960      	cbnz	r0, fcbe <ble_ll_scan_rx_isr_end+0x22>
        if (scansm->scan_rsp_pending) {
    fca4:	4872      	ldr	r0, [pc, #456]	; (fe70 <ble_ll_scan_rx_isr_end+0x1d4>)
    fca6:	7983      	ldrb	r3, [r0, #6]
    fca8:	b113      	cbz	r3, fcb0 <ble_ll_scan_rx_isr_end+0x14>
            ble_ll_scan_req_backoff(scansm, 0);
    fcaa:	4639      	mov	r1, r7
    fcac:	f7ff fe70 	bl	f990 <ble_ll_scan_req_backoff>
        }
        ble_phy_disable();
    fcb0:	f001 fab4 	bl	1121c <ble_phy_disable>
        ble_phy_rx();
        return 0;
    fcb4:	f04f 0800 	mov.w	r8, #0
    if (rxpdu == NULL) {
        if (scansm->scan_rsp_pending) {
            ble_ll_scan_req_backoff(scansm, 0);
        }
        ble_phy_disable();
        ble_phy_rx();
    fcb8:	f001 fbfc 	bl	114b4 <ble_phy_rx>
        return 0;
    fcbc:	e0d3      	b.n	fe66 <ble_ll_scan_rx_isr_end+0x1ca>
    }

    /* Just leave if the CRC is not OK. */
    rc = -1;
    if (!crcok) {
    fcbe:	2900      	cmp	r1, #0
    fcc0:	f000 80ce 	beq.w	fe60 <ble_ll_scan_rx_isr_end+0x1c4>
        goto scan_rx_isr_exit;
    }

    /* Get pdu type, pointer to address and address "type"  */
    rxbuf = rxpdu->om_data;
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    fcc4:	6804      	ldr	r4, [r0, #0]
    fcc6:	4d6a      	ldr	r5, [pc, #424]	; (fe70 <ble_ll_scan_rx_isr_end+0x1d4>)
    fcc8:	f814 3b02 	ldrb.w	r3, [r4], #2
    peer = rxbuf + BLE_LL_PDU_HDR_LEN;
    if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
    fccc:	f3c3 1680 	ubfx	r6, r3, #6, #1
    }
    peer_addr_type = addr_type;

    /* Determine if request may be sent and if whitelist needs to be checked */
    chk_send_req = 0;
    switch (pdu_type) {
    fcd0:	f003 030f 	and.w	r3, r3, #15
    fcd4:	2b06      	cmp	r3, #6
    fcd6:	d805      	bhi.n	fce4 <ble_ll_scan_rx_isr_end+0x48>
    fcd8:	e8df f003 	tbb	[pc, r3]
    fcdc:	04131308 	.word	0x04131308
    fce0:	0404      	.short	0x0404
    fce2:	08          	.byte	0x08
    fce3:	00          	.byte	0x00
    case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
    case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
        chk_wl = 1;
        break;
    default:
        chk_wl = 0;
    fce4:	f04f 0b00 	mov.w	fp, #0
        addr_type = BLE_ADDR_TYPE_PUBLIC;
    }
    peer_addr_type = addr_type;

    /* Determine if request may be sent and if whitelist needs to be checked */
    chk_send_req = 0;
    fce8:	46d8      	mov	r8, fp
    fcea:	e00e      	b.n	fd0a <ble_ll_scan_rx_isr_end+0x6e>
    switch (pdu_type) {
    case BLE_ADV_PDU_TYPE_ADV_IND:
    case BLE_ADV_PDU_TYPE_ADV_SCAN_IND:
        if (scansm->scan_type == BLE_SCAN_TYPE_ACTIVE) {
    fcec:	f895 8001 	ldrb.w	r8, [r5, #1]
    fcf0:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
    fcf4:	f1d1 0800 	rsbs	r8, r1, #0
    fcf8:	eb48 0801 	adc.w	r8, r8, r1
            chk_send_req = 1;
        }
        chk_wl = 1;
    fcfc:	f04f 0b01 	mov.w	fp, #1
    fd00:	e003      	b.n	fd0a <ble_ll_scan_rx_isr_end+0x6e>
        break;
    case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
    case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
        chk_wl = 1;
    fd02:	f04f 0b01 	mov.w	fp, #1
        addr_type = BLE_ADDR_TYPE_PUBLIC;
    }
    peer_addr_type = addr_type;

    /* Determine if request may be sent and if whitelist needs to be checked */
    chk_send_req = 0;
    fd06:	f04f 0800 	mov.w	r8, #0
        chk_wl = 0;
        break;
    }

    ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
    if ((scansm->scan_filt_policy & 1) == 0) {
    fd0a:	792b      	ldrb	r3, [r5, #4]
    }
    resolved = 0;

    index = -1;
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_is_rpa(peer, peer_addr_type) && ble_ll_resolv_enabled()) {
    fd0c:	4620      	mov	r0, r4
        break;
    }

    ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
    if ((scansm->scan_filt_policy & 1) == 0) {
        chk_wl = 0;
    fd0e:	f013 0f01 	tst.w	r3, #1
    }
    resolved = 0;

    index = -1;
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_is_rpa(peer, peer_addr_type) && ble_ll_resolv_enabled()) {
    fd12:	4631      	mov	r1, r6
        break;
    }

    ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
    if ((scansm->scan_filt_policy & 1) == 0) {
        chk_wl = 0;
    fd14:	bf08      	it	eq
    fd16:	f04f 0b00 	moveq.w	fp, #0
    }
    resolved = 0;

    index = -1;
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_is_rpa(peer, peer_addr_type) && ble_ll_resolv_enabled()) {
    fd1a:	f7fb f89b 	bl	ae54 <ble_ll_is_rpa>
    fd1e:	b1e0      	cbz	r0, fd5a <ble_ll_scan_rx_isr_end+0xbe>
    fd20:	f7ff fdca 	bl	f8b8 <ble_ll_resolv_enabled>
    fd24:	b1c8      	cbz	r0, fd5a <ble_ll_scan_rx_isr_end+0xbe>
        index = ble_hw_resolv_list_match();
    fd26:	f001 f869 	bl	10dfc <ble_hw_resolv_list_match>
        if (index >= 0) {
    fd2a:	2800      	cmp	r0, #0
    fd2c:	db0d      	blt.n	fd4a <ble_ll_scan_rx_isr_end+0xae>
            ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_RESOLVED;
    fd2e:	7e3b      	ldrb	r3, [r7, #24]
            peer = g_ble_ll_resolv_list[index].rl_identity_addr;
    fd30:	4a50      	ldr	r2, [pc, #320]	; (fe74 <ble_ll_scan_rx_isr_end+0x1d8>)
    index = -1;
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (ble_ll_is_rpa(peer, peer_addr_type) && ble_ll_resolv_enabled()) {
        index = ble_hw_resolv_list_match();
        if (index >= 0) {
            ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_RESOLVED;
    fd32:	f043 0304 	orr.w	r3, r3, #4
    fd36:	763b      	strb	r3, [r7, #24]
            peer = g_ble_ll_resolv_list[index].rl_identity_addr;
    fd38:	2328      	movs	r3, #40	; 0x28
    fd3a:	fb03 2300 	mla	r3, r3, r0, r2
    fd3e:	f103 0a02 	add.w	sl, r3, #2
            peer_addr_type = g_ble_ll_resolv_list[index].rl_addr_type;
    fd42:	f893 9001 	ldrb.w	r9, [r3, #1]
            resolved = 1;
    fd46:	2201      	movs	r2, #1
    fd48:	e00c      	b.n	fd64 <ble_ll_scan_rx_isr_end+0xc8>
        } else {
            if (chk_wl) {
    fd4a:	f1bb 0f00 	cmp.w	fp, #0
    fd4e:	f040 8087 	bne.w	fe60 <ble_ll_scan_rx_isr_end+0x1c4>
    }

    /* Get pdu type, pointer to address and address "type"  */
    rxbuf = rxpdu->om_data;
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    peer = rxbuf + BLE_LL_PDU_HDR_LEN;
    fd52:	46a2      	mov	sl, r4
    if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
        addr_type = BLE_ADDR_TYPE_RANDOM;
    fd54:	46b1      	mov	r9, r6

    ble_hdr = BLE_MBUF_HDR_PTR(rxpdu);
    if ((scansm->scan_filt_policy & 1) == 0) {
        chk_wl = 0;
    }
    resolved = 0;
    fd56:	465a      	mov	r2, fp
    fd58:	e004      	b.n	fd64 <ble_ll_scan_rx_isr_end+0xc8>
    fd5a:	4602      	mov	r2, r0
    }

    /* Get pdu type, pointer to address and address "type"  */
    rxbuf = rxpdu->om_data;
    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
    peer = rxbuf + BLE_LL_PDU_HDR_LEN;
    fd5c:	46a2      	mov	sl, r4
    if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
        addr_type = BLE_ADDR_TYPE_RANDOM;
    fd5e:	46b1      	mov	r9, r6
    if ((scansm->scan_filt_policy & 1) == 0) {
        chk_wl = 0;
    }
    resolved = 0;

    index = -1;
    fd60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
                goto scan_rx_isr_exit;
            }
        }
    }
#endif
    scansm->scan_rpa_index = index;
    fd64:	7268      	strb	r0, [r5, #9]

    /* If whitelist enabled, check to see if device is in the white list */
    if (chk_wl && !ble_ll_whitelist_match(peer, peer_addr_type, resolved)) {
    fd66:	f1bb 0f00 	cmp.w	fp, #0
    fd6a:	d107      	bne.n	fd7c <ble_ll_scan_rx_isr_end+0xe0>
        return -1;
    }
    ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_DEVMATCH;
    fd6c:	7e3b      	ldrb	r3, [r7, #24]
    fd6e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    fd72:	763b      	strb	r3, [r7, #24]

    /* Should we send a scan request? */
    if (chk_send_req) {
    fd74:	f1b8 0f00 	cmp.w	r8, #0
    fd78:	d109      	bne.n	fd8e <ble_ll_scan_rx_isr_end+0xf2>
    fd7a:	e071      	b.n	fe60 <ble_ll_scan_rx_isr_end+0x1c4>
    }
#endif
    scansm->scan_rpa_index = index;

    /* If whitelist enabled, check to see if device is in the white list */
    if (chk_wl && !ble_ll_whitelist_match(peer, peer_addr_type, resolved)) {
    fd7c:	4650      	mov	r0, sl
    fd7e:	4649      	mov	r1, r9
    fd80:	f000 fe8a 	bl	10a98 <ble_ll_whitelist_match>
    fd84:	2800      	cmp	r0, #0
    fd86:	d1f1      	bne.n	fd6c <ble_ll_scan_rx_isr_end+0xd0>
        return -1;
    fd88:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    fd8c:	e06b      	b.n	fe66 <ble_ll_scan_rx_isr_end+0x1ca>
    ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_DEVMATCH;

    /* Should we send a scan request? */
    if (chk_send_req) {
        /* Dont send scan request if we have sent one to this advertiser */
        if (ble_ll_scan_have_rxd_scan_rsp(peer, peer_addr_type)) {
    fd8e:	4650      	mov	r0, sl
    fd90:	4649      	mov	r1, r9
    fd92:	f7ff fddb 	bl	f94c <ble_ll_scan_have_rxd_scan_rsp>
    fd96:	4680      	mov	r8, r0
    fd98:	2800      	cmp	r0, #0
    fd9a:	d1f5      	bne.n	fd88 <ble_ll_scan_rx_isr_end+0xec>
            return -1;
        }

        /* Better not be a scan response pending */
        assert(scansm->scan_rsp_pending == 0);
    fd9c:	79ab      	ldrb	r3, [r5, #6]
    fd9e:	4a34      	ldr	r2, [pc, #208]	; (fe70 <ble_ll_scan_rx_isr_end+0x1d4>)
    fda0:	b123      	cbz	r3, fdac <ble_ll_scan_rx_isr_end+0x110>
    fda2:	4835      	ldr	r0, [pc, #212]	; (fe78 <ble_ll_scan_rx_isr_end+0x1dc>)
    fda4:	f240 31ed 	movw	r1, #1005	; 0x3ed
    fda8:	4642      	mov	r2, r8
    fdaa:	e013      	b.n	fdd4 <ble_ll_scan_rx_isr_end+0x138>

        /* We want to send a request. See if backoff allows us */
        --scansm->backoff_count;
    fdac:	8a53      	ldrh	r3, [r2, #18]
    fdae:	3b01      	subs	r3, #1
    fdb0:	b29b      	uxth	r3, r3
    fdb2:	8253      	strh	r3, [r2, #18]
        if (scansm->backoff_count == 0) {
    fdb4:	2b00      	cmp	r3, #0
    fdb6:	d153      	bne.n	fe60 <ble_ll_scan_rx_isr_end+0x1c4>
    if (adv_addr_type) {
        pdu_type |= BLE_ADV_PDU_HDR_RXADD_RAND;
    }

    /* Get the advertising PDU */
    m = scansm->scan_req_pdu;
    fdb8:	f8d5 a01c 	ldr.w	sl, [r5, #28]
#endif

    /* Construct first PDU header byte */
    pdu_type = BLE_ADV_PDU_TYPE_SCAN_REQ;
    if (adv_addr_type) {
        pdu_type |= BLE_ADV_PDU_HDR_RXADD_RAND;
    fdbc:	2e00      	cmp	r6, #0
    fdbe:	bf0c      	ite	eq
    fdc0:	f04f 0903 	moveq.w	r9, #3
    fdc4:	f04f 0983 	movne.w	r9, #131	; 0x83
    }

    /* Get the advertising PDU */
    m = scansm->scan_req_pdu;
    assert(m != NULL);
    fdc8:	f1ba 0f00 	cmp.w	sl, #0
    fdcc:	d105      	bne.n	fdda <ble_ll_scan_rx_isr_end+0x13e>
    fdce:	482a      	ldr	r0, [pc, #168]	; (fe78 <ble_ll_scan_rx_isr_end+0x1dc>)
    fdd0:	2197      	movs	r1, #151	; 0x97
    fdd2:	4652      	mov	r2, sl
    fdd4:	4613      	mov	r3, r2
    fdd6:	f7f9 ff7b 	bl	9cd0 <__assert_func>

    /* Get pointer to our device address */
    if ((scansm->own_addr_type & 1) == 0) {
    fdda:	7893      	ldrb	r3, [r2, #2]
    fddc:	07da      	lsls	r2, r3, #31
        scana = g_dev_addr;
    } else {
        pdu_type |= BLE_ADV_PDU_HDR_TXADD_RAND;
    fdde:	bf46      	itte	mi
    fde0:	f049 0940 	orrmi.w	r9, r9, #64	; 0x40
        scana = g_random_addr;
    fde4:	4f25      	ldrmi	r7, [pc, #148]	; (fe7c <ble_ll_scan_rx_isr_end+0x1e0>)
    m = scansm->scan_req_pdu;
    assert(m != NULL);

    /* Get pointer to our device address */
    if ((scansm->own_addr_type & 1) == 0) {
        scana = g_dev_addr;
    fde6:	4f26      	ldrpl	r7, [pc, #152]	; (fe80 <ble_ll_scan_rx_isr_end+0x1e4>)
        pdu_type |= BLE_ADV_PDU_HDR_TXADD_RAND;
        scana = g_random_addr;
    }

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (scansm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
    fde8:	2b01      	cmp	r3, #1
    fdea:	d91c      	bls.n	fe26 <ble_ll_scan_rx_isr_end+0x18a>
        rl = NULL;
        if (ble_ll_is_rpa(adv_addr, adv_addr_type)) {
    fdec:	4620      	mov	r0, r4
    fdee:	4631      	mov	r1, r6
    fdf0:	f7fb f830 	bl	ae54 <ble_ll_is_rpa>
    fdf4:	b140      	cbz	r0, fe08 <ble_ll_scan_rx_isr_end+0x16c>
            if (scansm->scan_rpa_index >= 0) {
    fdf6:	f995 3009 	ldrsb.w	r3, [r5, #9]
    fdfa:	2b00      	cmp	r3, #0
    fdfc:	db13      	blt.n	fe26 <ble_ll_scan_rx_isr_end+0x18a>
                /* Generate a RPA to use for scana */
                rl = &g_ble_ll_resolv_list[scansm->scan_rpa_index];
    fdfe:	4a1d      	ldr	r2, [pc, #116]	; (fe74 <ble_ll_scan_rx_isr_end+0x1d8>)
    fe00:	2028      	movs	r0, #40	; 0x28
    fe02:	fb00 2003 	mla	r0, r0, r3, r2
    fe06:	e007      	b.n	fe18 <ble_ll_scan_rx_isr_end+0x17c>
            }
        } else {
            if (ble_ll_resolv_enabled()) {
    fe08:	f7ff fd56 	bl	f8b8 <ble_ll_resolv_enabled>
    fe0c:	b158      	cbz	r0, fe26 <ble_ll_scan_rx_isr_end+0x18a>
                rl = ble_ll_resolv_list_find(adv_addr, adv_addr_type);
    fe0e:	4620      	mov	r0, r4
    fe10:	4631      	mov	r1, r6
    fe12:	f7ff fc05 	bl	f620 <ble_ll_resolv_list_find>
            }
        }

        if (rl) {
    fe16:	b130      	cbz	r0, fe26 <ble_ll_scan_rx_isr_end+0x18a>
            ble_ll_resolv_gen_priv_addr(rl, 1, rpa);
    fe18:	2101      	movs	r1, #1
    fe1a:	466a      	mov	r2, sp
    fe1c:	f7ff fcc2 	bl	f7a4 <ble_ll_resolv_gen_priv_addr>
            scana = rpa;
            pdu_type |= BLE_ADV_PDU_HDR_TXADD_RAND;
    fe20:	f049 0940 	orr.w	r9, r9, #64	; 0x40
            }
        }

        if (rl) {
            ble_ll_resolv_gen_priv_addr(rl, 1, rpa);
            scana = rpa;
    fe24:	466f      	mov	r7, sp
            pdu_type |= BLE_ADV_PDU_HDR_TXADD_RAND;
        }
    }
#endif

    ble_ll_mbuf_init(m, BLE_SCAN_REQ_LEN, pdu_type);
    fe26:	4650      	mov	r0, sl
    fe28:	210c      	movs	r1, #12
    fe2a:	464a      	mov	r2, r9
    fe2c:	f7fb f978 	bl	b120 <ble_ll_mbuf_init>

    /* Construct the scan request */
    dptr = m->om_data;
    fe30:	f8da 3000 	ldr.w	r3, [sl]
    memcpy(dptr, scana, BLE_DEV_ADDR_LEN);
    fe34:	683a      	ldr	r2, [r7, #0]
    fe36:	601a      	str	r2, [r3, #0]
    fe38:	88ba      	ldrh	r2, [r7, #4]
    fe3a:	809a      	strh	r2, [r3, #4]
    memcpy(dptr + BLE_DEV_ADDR_LEN, adv_addr, BLE_DEV_ADDR_LEN);
    fe3c:	6822      	ldr	r2, [r4, #0]
    fe3e:	f8c3 2006 	str.w	r2, [r3, #6]
    fe42:	88a2      	ldrh	r2, [r4, #4]
    fe44:	815a      	strh	r2, [r3, #10]
        --scansm->backoff_count;
        if (scansm->backoff_count == 0) {
            /* Setup to transmit the scan request */
            adv_addr = rxbuf + BLE_LL_PDU_HDR_LEN;
            ble_ll_scan_req_pdu_make(scansm, adv_addr, addr_type);
            rc = ble_phy_tx(scansm->scan_req_pdu, BLE_PHY_TRANSITION_TX_RX);
    fe46:	69e8      	ldr	r0, [r5, #28]
    fe48:	2102      	movs	r1, #2
    fe4a:	f001 fb8d 	bl	11568 <ble_phy_tx>

            /* Set "waiting for scan response" flag */
            scansm->scan_rsp_pending = 1;
    fe4e:	2301      	movs	r3, #1
    fe50:	71ab      	strb	r3, [r5, #6]
        }
    }

scan_rx_isr_exit:
    if (rc) {
    fe52:	4604      	mov	r4, r0
    fe54:	b138      	cbz	r0, fe66 <ble_ll_scan_rx_isr_end+0x1ca>
        ble_ll_state_set(BLE_LL_STATE_STANDBY);
    fe56:	2000      	movs	r0, #0
    fe58:	f7fb f944 	bl	b0e4 <ble_ll_state_set>
    fe5c:	46a0      	mov	r8, r4
    fe5e:	e002      	b.n	fe66 <ble_ll_scan_rx_isr_end+0x1ca>
            }
        }

        if (rl) {
            ble_ll_resolv_gen_priv_addr(rl, 1, rpa);
            scana = rpa;
    fe60:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    fe64:	e7f7      	b.n	fe56 <ble_ll_scan_rx_isr_end+0x1ba>
scan_rx_isr_exit:
    if (rc) {
        ble_ll_state_set(BLE_LL_STATE_STANDBY);
    }
    return rc;
}
    fe66:	4640      	mov	r0, r8
    fe68:	b003      	add	sp, #12
    fe6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fe6e:	bf00      	nop
    fe70:	20003750 	.word	0x20003750
    fe74:	20003624 	.word	0x20003624
    fe78:	0001f2e3 	.word	0x0001f2e3
    fe7c:	20002810 	.word	0x20002810
    fe80:	200000d8 	.word	0x200000d8

0000fe84 <ble_ll_scan_chk_resume>:
 *
 * Context: Link Layer task
 */
void
ble_ll_scan_chk_resume(void)
{
    fe84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_sr_t sr;
    struct ble_ll_scan_sm *scansm;

    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_enabled) {
    fe86:	4d1a      	ldr	r5, [pc, #104]	; (fef0 <ble_ll_scan_chk_resume+0x6c>)
    fe88:	782b      	ldrb	r3, [r5, #0]
    fe8a:	b37b      	cbz	r3, feec <ble_ll_scan_chk_resume+0x68>
        OS_ENTER_CRITICAL(sr);
    fe8c:	f7f9 fd48 	bl	9920 <os_arch_save_sr>
    fe90:	4607      	mov	r7, r0
        if (ble_ll_state_get() == BLE_LL_STATE_STANDBY) {
    fe92:	f7fb f92d 	bl	b0f0 <ble_ll_state_get>
    fe96:	b9f8      	cbnz	r0, fed8 <ble_ll_scan_chk_resume+0x54>
            ble_ll_scan_window_chk(scansm, cputime_get32());
    fe98:	f7f9 f850 	bl	8f3c <cputime_get32>
    int rc;
    uint8_t chan;
    uint32_t itvl;
    uint32_t win_start;

    itvl = cputime_usecs_to_ticks(scansm->scan_itvl * BLE_HCI_SCAN_ITVL);
    fe9c:	8aab      	ldrh	r3, [r5, #20]

    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_enabled) {
        OS_ENTER_CRITICAL(sr);
        if (ble_ll_state_get() == BLE_LL_STATE_STANDBY) {
            ble_ll_scan_window_chk(scansm, cputime_get32());
    fe9e:	4606      	mov	r6, r0
    int rc;
    uint8_t chan;
    uint32_t itvl;
    uint32_t win_start;

    itvl = cputime_usecs_to_ticks(scansm->scan_itvl * BLE_HCI_SCAN_ITVL);
    fea0:	f240 2071 	movw	r0, #625	; 0x271
    fea4:	4358      	muls	r0, r3
    fea6:	f7f8 ff05 	bl	8cb4 <cputime_usecs_to_ticks>
    feaa:	69ab      	ldr	r3, [r5, #24]
    chan = scansm->scan_chan;
    feac:	78ec      	ldrb	r4, [r5, #3]
    feae:	1af6      	subs	r6, r6, r3
    win_start = scansm->scan_win_start_time;
    while ((int32_t)(cputime - win_start) >= itvl) {
    feb0:	4286      	cmp	r6, r0
    feb2:	d306      	bcc.n	fec2 <ble_ll_scan_chk_resume+0x3e>
        win_start += itvl;
        ++chan;
    feb4:	3401      	adds	r4, #1
    feb6:	b2e4      	uxtb	r4, r4
        if (chan == BLE_PHY_NUM_CHANS) {
            chan = BLE_PHY_ADV_CHAN_START;
    feb8:	2c28      	cmp	r4, #40	; 0x28
    feba:	bf08      	it	eq
    febc:	2425      	moveq	r4, #37	; 0x25
    febe:	1a36      	subs	r6, r6, r0
    fec0:	e7f6      	b.n	feb0 <ble_ll_scan_chk_resume+0x2c>
        }
    }

    rc = 0;
    if (scansm->scan_window != scansm->scan_itvl) {
    fec2:	8aeb      	ldrh	r3, [r5, #22]
    fec4:	8aaa      	ldrh	r2, [r5, #20]
    fec6:	429a      	cmp	r2, r3
    fec8:	d00b      	beq.n	fee2 <ble_ll_scan_chk_resume+0x5e>
        itvl = cputime_usecs_to_ticks(scansm->scan_window * BLE_HCI_SCAN_ITVL);
    feca:	f240 2071 	movw	r0, #625	; 0x271
    fece:	4358      	muls	r0, r3
    fed0:	f7f8 fef0 	bl	8cb4 <cputime_usecs_to_ticks>
        if ((cputime - win_start) >= itvl) {
    fed4:	4286      	cmp	r6, r0
    fed6:	d304      	bcc.n	fee2 <ble_ll_scan_chk_resume+0x5e>
    if (scansm->scan_enabled) {
        OS_ENTER_CRITICAL(sr);
        if (ble_ll_state_get() == BLE_LL_STATE_STANDBY) {
            ble_ll_scan_window_chk(scansm, cputime_get32());
        }
        OS_EXIT_CRITICAL(sr);
    fed8:	4638      	mov	r0, r7
    }
}
    feda:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (scansm->scan_enabled) {
        OS_ENTER_CRITICAL(sr);
        if (ble_ll_state_get() == BLE_LL_STATE_STANDBY) {
            ble_ll_scan_window_chk(scansm, cputime_get32());
        }
        OS_EXIT_CRITICAL(sr);
    fede:	f7f9 bd25 	b.w	992c <os_arch_restore_sr>
        }
    }

    if (!rc) {
        /* Turn on the receiver and set state */
        ble_ll_scan_start(scansm, chan);
    fee2:	4803      	ldr	r0, [pc, #12]	; (fef0 <ble_ll_scan_chk_resume+0x6c>)
    fee4:	4621      	mov	r1, r4
    fee6:	f7ff fd93 	bl	fa10 <ble_ll_scan_start>
    feea:	e7f5      	b.n	fed8 <ble_ll_scan_chk_resume+0x54>
    feec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    feee:	bf00      	nop
    fef0:	20003750 	.word	0x20003750

0000fef4 <ble_ll_scan_wfr_timer_exp>:
 *
 * Context: Interrupt.
 */
void
ble_ll_scan_wfr_timer_exp(void)
{
    fef4:	b508      	push	{r3, lr}
    struct ble_ll_scan_sm *scansm;

    ble_phy_disable();
    fef6:	f001 f991 	bl	1121c <ble_phy_disable>
    /*
     * If we timed out waiting for a response, the scan response pending
     * flag should be set. Deal with scan backoff. Put device back into rx.
     */
    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_rsp_pending) {
    fefa:	4805      	ldr	r0, [pc, #20]	; (ff10 <ble_ll_scan_wfr_timer_exp+0x1c>)
    fefc:	7983      	ldrb	r3, [r0, #6]
    fefe:	b113      	cbz	r3, ff06 <ble_ll_scan_wfr_timer_exp+0x12>
        ble_ll_scan_req_backoff(scansm, 0);
    ff00:	2100      	movs	r1, #0
    ff02:	f7ff fd45 	bl	f990 <ble_ll_scan_req_backoff>
    }
    ble_phy_rx();
}
    ff06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     */
    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_rsp_pending) {
        ble_ll_scan_req_backoff(scansm, 0);
    }
    ble_phy_rx();
    ff0a:	f001 bad3 	b.w	114b4 <ble_phy_rx>
    ff0e:	bf00      	nop
    ff10:	20003750 	.word	0x20003750

0000ff14 <ble_ll_scan_rx_pkt_in>:
 * @param pdu_type
 * @param rxbuf
 */
void
ble_ll_scan_rx_pkt_in(uint8_t ptype, uint8_t *rxbuf, struct ble_mbuf_hdr *hdr)
{
    ff14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t scan_rsp_chk;
    struct ble_ll_scan_sm *scansm;
    struct ble_mbuf_hdr *ble_hdr;

    /* Set scan response check flag */
    scan_rsp_chk = hdr->rxinfo.flags & BLE_MBUF_HDR_F_SCAN_RSP_CHK;
    ff18:	7813      	ldrb	r3, [r2, #0]
    ff1a:	4f9b      	ldr	r7, [pc, #620]	; (10188 <ble_ll_scan_rx_pkt_in+0x274>)
 * @param pdu_type
 * @param rxbuf
 */
void
ble_ll_scan_rx_pkt_in(uint8_t ptype, uint8_t *rxbuf, struct ble_mbuf_hdr *hdr)
{
    ff1c:	b085      	sub	sp, #20
    ff1e:	4693      	mov	fp, r2
    uint8_t scan_rsp_chk;
    struct ble_ll_scan_sm *scansm;
    struct ble_mbuf_hdr *ble_hdr;

    /* Set scan response check flag */
    scan_rsp_chk = hdr->rxinfo.flags & BLE_MBUF_HDR_F_SCAN_RSP_CHK;
    ff20:	f003 0208 	and.w	r2, r3, #8
    ff24:	b2d2      	uxtb	r2, r2

    /* We dont care about scan requests or connect requests */
    if (!BLE_MBUF_HDR_CRC_OK(hdr) || (ptype == BLE_ADV_PDU_TYPE_SCAN_REQ) ||
    ff26:	f013 0f80 	tst.w	r3, #128	; 0x80
 * @param pdu_type
 * @param rxbuf
 */
void
ble_ll_scan_rx_pkt_in(uint8_t ptype, uint8_t *rxbuf, struct ble_mbuf_hdr *hdr)
{
    ff2a:	4604      	mov	r4, r0
    ff2c:	4688      	mov	r8, r1
    uint8_t scan_rsp_chk;
    struct ble_ll_scan_sm *scansm;
    struct ble_mbuf_hdr *ble_hdr;

    /* Set scan response check flag */
    scan_rsp_chk = hdr->rxinfo.flags & BLE_MBUF_HDR_F_SCAN_RSP_CHK;
    ff2e:	9200      	str	r2, [sp, #0]

    /* We dont care about scan requests or connect requests */
    if (!BLE_MBUF_HDR_CRC_OK(hdr) || (ptype == BLE_ADV_PDU_TYPE_SCAN_REQ) ||
    ff30:	d017      	beq.n	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
    ff32:	2803      	cmp	r0, #3
    ff34:	d015      	beq.n	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
    ff36:	2805      	cmp	r0, #5
    ff38:	d013      	beq.n	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
    int chk_inita;

    use_whitelist = 0;
    chk_inita = 0;

    switch (g_ble_ll_scan_sm.scan_filt_policy) {
    ff3a:	793a      	ldrb	r2, [r7, #4]
    ff3c:	2a03      	cmp	r2, #3
    ff3e:	d805      	bhi.n	ff4c <ble_ll_scan_rx_pkt_in+0x38>
    ff40:	e8df f002 	tbb	[pc, r2]
    ff44:	0b020b1c 	.word	0x0b020b1c
        break;
    case BLE_HCI_SCAN_FILT_USE_WL:
        use_whitelist = 1;
        break;
    case BLE_HCI_SCAN_FILT_NO_WL_INITA:
        chk_inita = 1;
    ff48:	2601      	movs	r6, #1
    ff4a:	e018      	b.n	ff7e <ble_ll_scan_rx_pkt_in+0x6a>
    case BLE_HCI_SCAN_FILT_USE_WL_INITA:
        chk_inita = 1;
        use_whitelist = 1;
        break;
    default:
        assert(0);
    ff4c:	2200      	movs	r2, #0
    ff4e:	488f      	ldr	r0, [pc, #572]	; (1018c <ble_ll_scan_rx_pkt_in+0x278>)
    ff50:	f240 2106 	movw	r1, #518	; 0x206
    ff54:	4613      	mov	r3, r2
    ff56:	f7f9 febb 	bl	9cd0 <__assert_func>
        break;
    }

    /* If we are using the whitelist, check that first */
    if (use_whitelist && (pdu_type != BLE_ADV_PDU_TYPE_SCAN_RSP)) {
    ff5a:	2804      	cmp	r0, #4
    ff5c:	d024      	beq.n	ffa8 <ble_ll_scan_rx_pkt_in+0x94>
        /* If there was a devmatch, we will allow the PDU */
        if (flags & BLE_MBUF_HDR_F_DEVMATCH) {
    ff5e:	065b      	lsls	r3, r3, #25
    ff60:	d422      	bmi.n	ffa8 <ble_ll_scan_rx_pkt_in+0x94>
    /*
     * If the scan response check bit is set and we are pending a response,
     * we have failed the scan request (as we would have reset the scan rsp
     * pending flag if we received a valid response
     */
    if (scansm->scan_rsp_pending && scan_rsp_chk) {
    ff62:	79bb      	ldrb	r3, [r7, #6]
    ff64:	b12b      	cbz	r3, ff72 <ble_ll_scan_rx_pkt_in+0x5e>
    ff66:	9b00      	ldr	r3, [sp, #0]
    ff68:	b11b      	cbz	r3, ff72 <ble_ll_scan_rx_pkt_in+0x5e>
        ble_ll_scan_req_backoff(scansm, 0);
    ff6a:	4887      	ldr	r0, [pc, #540]	; (10188 <ble_ll_scan_rx_pkt_in+0x274>)
    ff6c:	2100      	movs	r1, #0
    ff6e:	f7ff fd0f 	bl	f990 <ble_ll_scan_req_backoff>
    }

    ble_ll_scan_chk_resume();
    return;
}
    ff72:	b005      	add	sp, #20
    ff74:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     */
    if (scansm->scan_rsp_pending && scan_rsp_chk) {
        ble_ll_scan_req_backoff(scansm, 0);
    }

    ble_ll_scan_chk_resume();
    ff78:	f7ff bf84 	b.w	fe84 <ble_ll_scan_chk_resume>
    uint8_t addr_type;
    int use_whitelist;
    int chk_inita;

    use_whitelist = 0;
    chk_inita = 0;
    ff7c:	2600      	movs	r6, #0
            return 1;
        }
    }

    /* If this is a directed advertisement, check that it is for us */
    if (pdu_type == BLE_ADV_PDU_TYPE_ADV_DIRECT_IND) {
    ff7e:	2c01      	cmp	r4, #1
    ff80:	d112      	bne.n	ffa8 <ble_ll_scan_rx_pkt_in+0x94>
        /* Is this for us? If not, is it resolvable */
        addr = rxbuf + BLE_LL_PDU_HDR_LEN;
        addr_type = rxbuf[0] & BLE_ADV_PDU_HDR_RXADD_MASK;
    ff82:	4640      	mov	r0, r8
    ff84:	f810 5b08 	ldrb.w	r5, [r0], #8
    ff88:	f025 057f 	bic.w	r5, r5, #127	; 0x7f
    ff8c:	b2ed      	uxtb	r5, r5
        if (!ble_ll_is_our_devaddr(addr + BLE_DEV_ADDR_LEN, addr_type)) {
    ff8e:	4629      	mov	r1, r5
    ff90:	f7fa ffb2 	bl	aef8 <ble_ll_is_our_devaddr>
    ff94:	b940      	cbnz	r0, ffa8 <ble_ll_scan_rx_pkt_in+0x94>
            if (!chk_inita || !ble_ll_is_rpa(addr, addr_type)) {
    ff96:	2e00      	cmp	r6, #0
    ff98:	d0e3      	beq.n	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
    ff9a:	f108 0002 	add.w	r0, r8, #2
    ff9e:	4629      	mov	r1, r5
    ffa0:	f7fa ff58 	bl	ae54 <ble_ll_is_rpa>
    ffa4:	2800      	cmp	r0, #0
    ffa6:	d0dc      	beq.n	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
    if (ble_ll_scan_chk_filter_policy(ptype, rxbuf, hdr->rxinfo.flags)) {
        goto scan_continue;
    }

    /* Get advertisers address type and a pointer to the address */
    txadd = rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK;
    ffa8:	4645      	mov	r5, r8
    ident_addr = adv_addr;
    ident_addr_type = txadd;

    scansm = &g_ble_ll_scan_sm;
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    index = scansm->scan_rpa_index;
    ffaa:	f997 2009 	ldrsb.w	r2, [r7, #9]
    if (ble_ll_scan_chk_filter_policy(ptype, rxbuf, hdr->rxinfo.flags)) {
        goto scan_continue;
    }

    /* Get advertisers address type and a pointer to the address */
    txadd = rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK;
    ffae:	f815 3b02 	ldrb.w	r3, [r5], #2
    ident_addr_type = txadd;

    scansm = &g_ble_ll_scan_sm;
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    index = scansm->scan_rpa_index;
    if (index >= 0) {
    ffb2:	2a00      	cmp	r2, #0
    if (ble_ll_scan_chk_filter_policy(ptype, rxbuf, hdr->rxinfo.flags)) {
        goto scan_continue;
    }

    /* Get advertisers address type and a pointer to the address */
    txadd = rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK;
    ffb4:	f003 0340 	and.w	r3, r3, #64	; 0x40
    ffb8:	b2db      	uxtb	r3, r3
    ident_addr_type = txadd;

    scansm = &g_ble_ll_scan_sm;
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    index = scansm->scan_rpa_index;
    if (index >= 0) {
    ffba:	f2c0 80e2 	blt.w	10182 <ble_ll_scan_rx_pkt_in+0x26e>
        ident_addr = g_ble_ll_resolv_list[index].rl_identity_addr;
    ffbe:	4974      	ldr	r1, [pc, #464]	; (10190 <ble_ll_scan_rx_pkt_in+0x27c>)
    ffc0:	2028      	movs	r0, #40	; 0x28
    ffc2:	fb00 1202 	mla	r2, r0, r2, r1
    ffc6:	1c96      	adds	r6, r2, #2
        ident_addr_type = g_ble_ll_resolv_list[index].rl_addr_type;
    ffc8:	f892 9001 	ldrb.w	r9, [r2, #1]
     * XXX: The BLE spec is a bit unclear here. What if we get a scan
     * response from an advertiser that we did not send a request to?
     * Do we send an advertising report? Do we add it to list of devices
     * that we have heard a scan response from?
     */
    if (ptype == BLE_ADV_PDU_TYPE_SCAN_RSP) {
    ffcc:	2c04      	cmp	r4, #4
    ffce:	d139      	bne.n	10044 <ble_ll_scan_rx_pkt_in+0x130>
        /*
         * If this is a scan response in reply to a request we sent we need
         * to store this advertiser's address so we dont send a request to it.
         */
        if (scansm->scan_rsp_pending && scan_rsp_chk) {
    ffd0:	79ba      	ldrb	r2, [r7, #6]
    ffd2:	2a00      	cmp	r2, #0
    ffd4:	d036      	beq.n	10044 <ble_ll_scan_rx_pkt_in+0x130>
    ffd6:	9a00      	ldr	r2, [sp, #0]
    ffd8:	b3a2      	cbz	r2, 10044 <ble_ll_scan_rx_pkt_in+0x130>
            /*
             * We could also check the timing of the scan reponse; make sure
             * that it is relatively close to the end of the scan request but
             * we wont for now.
             */
            ble_hdr = BLE_MBUF_HDR_PTR(scansm->scan_req_pdu);
    ffda:	4a6b      	ldr	r2, [pc, #428]	; (10188 <ble_ll_scan_rx_pkt_in+0x274>)
    ffdc:	69d1      	ldr	r1, [r2, #28]
            rxadd = ble_hdr->txinfo.hdr_byte & BLE_ADV_PDU_HDR_RXADD_MASK;
    ffde:	7eca      	ldrb	r2, [r1, #27]
            adva = scansm->scan_req_pdu->om_data + BLE_DEV_ADDR_LEN;
    ffe0:	6809      	ldr	r1, [r1, #0]
             * We could also check the timing of the scan reponse; make sure
             * that it is relatively close to the end of the scan request but
             * we wont for now.
             */
            ble_hdr = BLE_MBUF_HDR_PTR(scansm->scan_req_pdu);
            rxadd = ble_hdr->txinfo.hdr_byte & BLE_ADV_PDU_HDR_RXADD_MASK;
    ffe2:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    ffe6:	b2d2      	uxtb	r2, r2
            adva = scansm->scan_req_pdu->om_data + BLE_DEV_ADDR_LEN;
            if (((txadd && rxadd) || ((txadd + rxadd) == 0)) &&
    ffe8:	b103      	cbz	r3, ffec <ble_ll_scan_rx_pkt_in+0xd8>
    ffea:	b90a      	cbnz	r2, fff0 <ble_ll_scan_rx_pkt_in+0xdc>
    ffec:	42d3      	cmn	r3, r2
    ffee:	d129      	bne.n	10044 <ble_ll_scan_rx_pkt_in+0x130>
                !memcmp(adv_addr, adva, BLE_DEV_ADDR_LEN)) {
    fff0:	4628      	mov	r0, r5
    fff2:	3106      	adds	r1, #6
    fff4:	2206      	movs	r2, #6
    fff6:	f7f8 fff3 	bl	8fe0 <memcmp>
             * we wont for now.
             */
            ble_hdr = BLE_MBUF_HDR_PTR(scansm->scan_req_pdu);
            rxadd = ble_hdr->txinfo.hdr_byte & BLE_ADV_PDU_HDR_RXADD_MASK;
            adva = scansm->scan_req_pdu->om_data + BLE_DEV_ADDR_LEN;
            if (((txadd && rxadd) || ((txadd + rxadd) == 0)) &&
    fffa:	bb18      	cbnz	r0, 10044 <ble_ll_scan_rx_pkt_in+0x130>
{
    uint8_t num_advs;
    struct ble_ll_scan_advertisers *adv;

    /* XXX: for now, if we dont have room, just leave */
    num_advs = g_ble_ll_scan_num_rsp_advs;
    fffc:	4a65      	ldr	r2, [pc, #404]	; (10194 <ble_ll_scan_rx_pkt_in+0x280>)
    fffe:	9201      	str	r2, [sp, #4]
   10000:	f892 a000 	ldrb.w	sl, [r2]
    if (num_advs == NIMBLE_OPT_LL_NUM_SCAN_RSP_ADVS) {
   10004:	f1ba 0f08 	cmp.w	sl, #8
   10008:	d018      	beq.n	1003c <ble_ll_scan_rx_pkt_in+0x128>
        return;
    }

    /* Check if address is already on the list */
    if (ble_ll_scan_have_rxd_scan_rsp(addr, txadd)) {
   1000a:	4630      	mov	r0, r6
   1000c:	4649      	mov	r1, r9
   1000e:	f7ff fc9d 	bl	f94c <ble_ll_scan_have_rxd_scan_rsp>
   10012:	9a01      	ldr	r2, [sp, #4]
   10014:	b990      	cbnz	r0, 1003c <ble_ll_scan_rx_pkt_in+0x128>
        return;
    }

    /* Add the advertiser to the array */
    adv = &g_ble_ll_scan_rsp_advs[num_advs];
    memcpy(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN);
   10016:	4b60      	ldr	r3, [pc, #384]	; (10198 <ble_ll_scan_rx_pkt_in+0x284>)
   10018:	6830      	ldr	r0, [r6, #0]
   1001a:	eb03 01ca 	add.w	r1, r3, sl, lsl #3
   1001e:	f8c1 0002 	str.w	r0, [r1, #2]
   10022:	88b0      	ldrh	r0, [r6, #4]
   10024:	80c8      	strh	r0, [r1, #6]
    adv->sc_adv_flags = BLE_LL_SC_ADV_F_SCAN_RSP_RXD;
    if (txadd) {
   10026:	f1b9 0f00 	cmp.w	r9, #0
   1002a:	d101      	bne.n	10030 <ble_ll_scan_rx_pkt_in+0x11c>
    }

    /* Add the advertiser to the array */
    adv = &g_ble_ll_scan_rsp_advs[num_advs];
    memcpy(&adv->adv_addr, addr, BLE_DEV_ADDR_LEN);
    adv->sc_adv_flags = BLE_LL_SC_ADV_F_SCAN_RSP_RXD;
   1002c:	2102      	movs	r1, #2
   1002e:	e000      	b.n	10032 <ble_ll_scan_rx_pkt_in+0x11e>
    if (txadd) {
        adv->sc_adv_flags |= BLE_LL_SC_ADV_F_RANDOM_ADDR;
   10030:	2103      	movs	r1, #3
   10032:	f823 103a 	strh.w	r1, [r3, sl, lsl #3]
    }
    ++g_ble_ll_scan_num_rsp_advs;
   10036:	f10a 0301 	add.w	r3, sl, #1
   1003a:	7013      	strb	r3, [r2, #0]
                !memcmp(adv_addr, adva, BLE_DEV_ADDR_LEN)) {
                /* We have received a scan response. Add to list */
                ble_ll_scan_add_scan_rsp_adv(ident_addr, ident_addr_type);

                /* Perform scan request backoff procedure */
                ble_ll_scan_req_backoff(scansm, 1);
   1003c:	4852      	ldr	r0, [pc, #328]	; (10188 <ble_ll_scan_rx_pkt_in+0x274>)
   1003e:	2101      	movs	r1, #1
   10040:	f7ff fca6 	bl	f990 <ble_ll_scan_req_backoff>
            }
        }
    }

    /* Filter duplicates */
    if (scansm->scan_filt_dups) {
   10044:	797b      	ldrb	r3, [r7, #5]
   10046:	b133      	cbz	r3, 10056 <ble_ll_scan_rx_pkt_in+0x142>
        if (ble_ll_scan_is_dup_adv(ptype, ident_addr_type, ident_addr)) {
   10048:	4620      	mov	r0, r4
   1004a:	4649      	mov	r1, r9
   1004c:	4632      	mov	r2, r6
   1004e:	f7ff fd4d 	bl	faec <ble_ll_scan_is_dup_adv>
   10052:	2800      	cmp	r0, #0
   10054:	d185      	bne.n	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
    uint8_t adv_data_len;
    uint8_t event_len;

    inita = NULL;
    subev = BLE_HCI_LE_SUBEV_ADV_RPT;
    if (pdu_type == BLE_ADV_PDU_TYPE_ADV_DIRECT_IND) {
   10056:	2c01      	cmp	r4, #1
   10058:	d112      	bne.n	10080 <ble_ll_scan_rx_pkt_in+0x16c>
        if (scansm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
   1005a:	78bb      	ldrb	r3, [r7, #2]
   1005c:	2b01      	cmp	r3, #1
   1005e:	d925      	bls.n	100ac <ble_ll_scan_rx_pkt_in+0x198>
            inita = rxbuf + BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN;
            if ((inita[5] & 0x40) == 0x40) {
   10060:	f898 300d 	ldrb.w	r3, [r8, #13]
                subev = BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT;
            }
        }
        evtype = BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
        event_len = BLE_HCI_LE_ADV_DIRECT_RPT_LEN;
   10064:	f013 0f40 	tst.w	r3, #64	; 0x40

    inita = NULL;
    subev = BLE_HCI_LE_SUBEV_ADV_RPT;
    if (pdu_type == BLE_ADV_PDU_TYPE_ADV_DIRECT_IND) {
        if (scansm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
            inita = rxbuf + BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN;
   10068:	f108 0108 	add.w	r1, r8, #8
            if ((inita[5] & 0x40) == 0x40) {
                subev = BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT;
            }
        }
        evtype = BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
        event_len = BLE_HCI_LE_ADV_DIRECT_RPT_LEN;
   1006c:	f04f 0312 	mov.w	r3, #18
   10070:	f04f 0600 	mov.w	r6, #0
   10074:	bf0c      	ite	eq
   10076:	f04f 0a02 	moveq.w	sl, #2
   1007a:	f04f 0a0b 	movne.w	sl, #11
   1007e:	e01a      	b.n	100b6 <ble_ll_scan_rx_pkt_in+0x1a2>
        adv_data_len = 0;
    } else {
        if (pdu_type == BLE_ADV_PDU_TYPE_ADV_IND) {
   10080:	b134      	cbz	r4, 10090 <ble_ll_scan_rx_pkt_in+0x17c>
            evtype = BLE_HCI_ADV_RPT_EVTYPE_ADV_IND;
        } else if (pdu_type == BLE_ADV_PDU_TYPE_ADV_SCAN_IND) {
   10082:	2c06      	cmp	r4, #6
   10084:	d006      	beq.n	10094 <ble_ll_scan_rx_pkt_in+0x180>
            evtype = BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND;
        } else if (pdu_type == BLE_ADV_PDU_TYPE_ADV_NONCONN_IND) {
            evtype = BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND;
        } else {
            evtype = BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP;
   10086:	2c02      	cmp	r4, #2
   10088:	bf0c      	ite	eq
   1008a:	2203      	moveq	r2, #3
   1008c:	2204      	movne	r2, #4
   1008e:	e002      	b.n	10096 <ble_ll_scan_rx_pkt_in+0x182>
        evtype = BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
        event_len = BLE_HCI_LE_ADV_DIRECT_RPT_LEN;
        adv_data_len = 0;
    } else {
        if (pdu_type == BLE_ADV_PDU_TYPE_ADV_IND) {
            evtype = BLE_HCI_ADV_RPT_EVTYPE_ADV_IND;
   10090:	4622      	mov	r2, r4
   10092:	e000      	b.n	10096 <ble_ll_scan_rx_pkt_in+0x182>
        } else if (pdu_type == BLE_ADV_PDU_TYPE_ADV_SCAN_IND) {
            evtype = BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND;
   10094:	2202      	movs	r2, #2
        } else if (pdu_type == BLE_ADV_PDU_TYPE_ADV_NONCONN_IND) {
            evtype = BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND;
        } else {
            evtype = BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP;
        }
        adv_data_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
   10096:	f898 3001 	ldrb.w	r3, [r8, #1]
   1009a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
        adv_data_len -= BLE_DEV_ADDR_LEN;
   1009e:	1f9e      	subs	r6, r3, #6
   100a0:	b2f6      	uxtb	r6, r6
        event_len = BLE_HCI_LE_ADV_RPT_MIN_LEN + adv_data_len;
   100a2:	3306      	adds	r3, #6
    uint8_t *inita;
    uint8_t addr_type;
    uint8_t adv_data_len;
    uint8_t event_len;

    inita = NULL;
   100a4:	2100      	movs	r1, #0
    subev = BLE_HCI_LE_SUBEV_ADV_RPT;
   100a6:	f04f 0a02 	mov.w	sl, #2
   100aa:	e005      	b.n	100b8 <ble_ll_scan_rx_pkt_in+0x1a4>
                subev = BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT;
            }
        }
        evtype = BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
        event_len = BLE_HCI_LE_ADV_DIRECT_RPT_LEN;
        adv_data_len = 0;
   100ac:	2600      	movs	r6, #0
            if ((inita[5] & 0x40) == 0x40) {
                subev = BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT;
            }
        }
        evtype = BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
        event_len = BLE_HCI_LE_ADV_DIRECT_RPT_LEN;
   100ae:	2312      	movs	r3, #18
    uint8_t *inita;
    uint8_t addr_type;
    uint8_t adv_data_len;
    uint8_t event_len;

    inita = NULL;
   100b0:	4631      	mov	r1, r6
    subev = BLE_HCI_LE_SUBEV_ADV_RPT;
   100b2:	f04f 0a02 	mov.w	sl, #2
            inita = rxbuf + BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN;
            if ((inita[5] & 0x40) == 0x40) {
                subev = BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT;
            }
        }
        evtype = BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
   100b6:	4622      	mov	r2, r4
        adv_data_len = rxbuf[1] & BLE_ADV_PDU_HDR_LEN_MASK;
        adv_data_len -= BLE_DEV_ADDR_LEN;
        event_len = BLE_HCI_LE_ADV_RPT_MIN_LEN + adv_data_len;
    }

    if (ble_ll_hci_is_le_event_enabled(subev)) {
   100b8:	4650      	mov	r0, sl
   100ba:	9203      	str	r2, [sp, #12]
   100bc:	9302      	str	r3, [sp, #8]
   100be:	9101      	str	r1, [sp, #4]
   100c0:	f7fe fd6c 	bl	eb9c <ble_ll_hci_is_le_event_enabled>
   100c4:	2800      	cmp	r0, #0
   100c6:	f43f af4c 	beq.w	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
        evbuf = os_memblock_get(&g_hci_evt_pool);
   100ca:	4834      	ldr	r0, [pc, #208]	; (1019c <ble_ll_scan_rx_pkt_in+0x288>)
   100cc:	f7fa f994 	bl	a3f8 <os_memblock_get>
        if (evbuf) {
   100d0:	4604      	mov	r4, r0
   100d2:	2800      	cmp	r0, #0
   100d4:	f43f af45 	beq.w	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
            evbuf[1] = event_len;
   100d8:	9b02      	ldr	r3, [sp, #8]
   100da:	7063      	strb	r3, [r4, #1]
            evbuf[2] = subev;
            evbuf[3] = 1;       /* number of reports */
            evbuf[4] = evtype;
   100dc:	9a03      	ldr	r2, [sp, #12]
    if (ble_ll_hci_is_le_event_enabled(subev)) {
        evbuf = os_memblock_get(&g_hci_evt_pool);
        if (evbuf) {
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
            evbuf[1] = event_len;
            evbuf[2] = subev;
   100de:	f884 a002 	strb.w	sl, [r4, #2]
            evbuf[3] = 1;       /* number of reports */
   100e2:	2301      	movs	r3, #1
    }

    if (ble_ll_hci_is_le_event_enabled(subev)) {
        evbuf = os_memblock_get(&g_hci_evt_pool);
        if (evbuf) {
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
   100e4:	203e      	movs	r0, #62	; 0x3e
            evbuf[1] = event_len;
            evbuf[2] = subev;
            evbuf[3] = 1;       /* number of reports */
   100e6:	70e3      	strb	r3, [r4, #3]
    }

    if (ble_ll_hci_is_le_event_enabled(subev)) {
        evbuf = os_memblock_get(&g_hci_evt_pool);
        if (evbuf) {
            evbuf[0] = BLE_HCI_EVCODE_LE_META;
   100e8:	7020      	strb	r0, [r4, #0]
            evbuf[1] = event_len;
            evbuf[2] = subev;
            evbuf[3] = 1;       /* number of reports */
            evbuf[4] = evtype;
   100ea:	7122      	strb	r2, [r4, #4]
            } else {
                addr_type = BLE_HCI_ADV_OWN_ADDR_PUBLIC;
            }

            rxbuf += BLE_LL_PDU_HDR_LEN;
            if (BLE_MBUF_HDR_RESOLVED(hdr)) {
   100ec:	f89b 2000 	ldrb.w	r2, [fp]
   100f0:	9901      	ldr	r1, [sp, #4]
            evbuf[2] = subev;
            evbuf[3] = 1;       /* number of reports */
            evbuf[4] = evtype;

            if (txadd) {
                addr_type = BLE_HCI_ADV_OWN_ADDR_RANDOM;
   100f2:	f119 0300 	adds.w	r3, r9, #0
   100f6:	bf18      	it	ne
   100f8:	2301      	movne	r3, #1
            } else {
                addr_type = BLE_HCI_ADV_OWN_ADDR_PUBLIC;
            }

            rxbuf += BLE_LL_PDU_HDR_LEN;
            if (BLE_MBUF_HDR_RESOLVED(hdr)) {
   100fa:	f012 0f04 	tst.w	r2, #4
   100fe:	d008      	beq.n	10112 <ble_ll_scan_rx_pkt_in+0x1fe>
                index = scansm->scan_rpa_index;
   10100:	f997 2009 	ldrsb.w	r2, [r7, #9]
                adv_addr = g_ble_ll_resolv_list[index].rl_identity_addr;
   10104:	4822      	ldr	r0, [pc, #136]	; (10190 <ble_ll_scan_rx_pkt_in+0x27c>)
   10106:	2528      	movs	r5, #40	; 0x28
   10108:	fb05 0502 	mla	r5, r5, r2, r0
                /*
                 * NOTE: this looks a bit odd, but the resolved address types
                 * are 2 greater than the unresolved ones in the spec, so
                 * we just add 2 here.
                 */
                addr_type += 2;
   1010c:	3302      	adds	r3, #2
            }

            rxbuf += BLE_LL_PDU_HDR_LEN;
            if (BLE_MBUF_HDR_RESOLVED(hdr)) {
                index = scansm->scan_rpa_index;
                adv_addr = g_ble_ll_resolv_list[index].rl_identity_addr;
   1010e:	3502      	adds	r5, #2
                /*
                 * NOTE: this looks a bit odd, but the resolved address types
                 * are 2 greater than the unresolved ones in the spec, so
                 * we just add 2 here.
                 */
                addr_type += 2;
   10110:	b2db      	uxtb	r3, r3
                adv_addr = rxbuf;
            }

            orig_evbuf = evbuf;
            evbuf += 5;
            if (inita) {
   10112:	b151      	cbz	r1, 1012a <ble_ll_scan_rx_pkt_in+0x216>
                evbuf[0] = BLE_HCI_ADV_OWN_ADDR_RANDOM;
   10114:	2201      	movs	r2, #1
   10116:	7162      	strb	r2, [r4, #5]
                memcpy(evbuf + 1, inita, adv_data_len);
   10118:	1da0      	adds	r0, r4, #6
   1011a:	4632      	mov	r2, r6
   1011c:	9301      	str	r3, [sp, #4]
   1011e:	f7f8 ff6d 	bl	8ffc <memcpy>
                evbuf += BLE_DEV_ADDR_LEN + 1;
   10122:	f104 0c0c 	add.w	ip, r4, #12
   10126:	9b01      	ldr	r3, [sp, #4]
   10128:	e013      	b.n	10152 <ble_ll_scan_rx_pkt_in+0x23e>
            } else{
                adv_addr = rxbuf;
            }

            orig_evbuf = evbuf;
            evbuf += 5;
   1012a:	f104 0c05 	add.w	ip, r4, #5
                evbuf[0] = BLE_HCI_ADV_OWN_ADDR_RANDOM;
                memcpy(evbuf + 1, inita, adv_data_len);
                evbuf += BLE_DEV_ADDR_LEN + 1;
            } else {
                evbuf[7] = adv_data_len;
                memcpy(evbuf + 8, rxbuf + BLE_DEV_ADDR_LEN, adv_data_len);
   1012e:	4632      	mov	r2, r6
            if (inita) {
                evbuf[0] = BLE_HCI_ADV_OWN_ADDR_RANDOM;
                memcpy(evbuf + 1, inita, adv_data_len);
                evbuf += BLE_DEV_ADDR_LEN + 1;
            } else {
                evbuf[7] = adv_data_len;
   10130:	7326      	strb	r6, [r4, #12]
                memcpy(evbuf + 8, rxbuf + BLE_DEV_ADDR_LEN, adv_data_len);
   10132:	f104 000d 	add.w	r0, r4, #13
   10136:	f108 0108 	add.w	r1, r8, #8
   1013a:	9302      	str	r3, [sp, #8]
            } else{
                adv_addr = rxbuf;
            }

            orig_evbuf = evbuf;
            evbuf += 5;
   1013c:	f8cd c004 	str.w	ip, [sp, #4]
                evbuf[0] = BLE_HCI_ADV_OWN_ADDR_RANDOM;
                memcpy(evbuf + 1, inita, adv_data_len);
                evbuf += BLE_DEV_ADDR_LEN + 1;
            } else {
                evbuf[7] = adv_data_len;
                memcpy(evbuf + 8, rxbuf + BLE_DEV_ADDR_LEN, adv_data_len);
   10140:	f7f8 ff5c 	bl	8ffc <memcpy>
                evbuf[8 + adv_data_len] = hdr->rxinfo.rssi;
   10144:	f8dd c004 	ldr.w	ip, [sp, #4]
   10148:	f89b 2003 	ldrb.w	r2, [fp, #3]
   1014c:	9b02      	ldr	r3, [sp, #8]
   1014e:	4466      	add	r6, ip
   10150:	7232      	strb	r2, [r6, #8]
            }

            /* The advertisers address type and address are always in event */
            evbuf[0] = addr_type;
   10152:	4662      	mov	r2, ip
            memcpy(evbuf + 1, adv_addr, BLE_DEV_ADDR_LEN);

            rc = ble_ll_hci_event_send(orig_evbuf);
   10154:	4620      	mov	r0, r4
                memcpy(evbuf + 8, rxbuf + BLE_DEV_ADDR_LEN, adv_data_len);
                evbuf[8 + adv_data_len] = hdr->rxinfo.rssi;
            }

            /* The advertisers address type and address are always in event */
            evbuf[0] = addr_type;
   10156:	f802 3b01 	strb.w	r3, [r2], #1
            memcpy(evbuf + 1, adv_addr, BLE_DEV_ADDR_LEN);
   1015a:	682b      	ldr	r3, [r5, #0]
   1015c:	f8cc 3001 	str.w	r3, [ip, #1]
   10160:	88ab      	ldrh	r3, [r5, #4]
   10162:	8093      	strh	r3, [r2, #4]

            rc = ble_ll_hci_event_send(orig_evbuf);
   10164:	f7fe fcf8 	bl	eb58 <ble_ll_hci_event_send>
            if (!rc) {
   10168:	2800      	cmp	r0, #0
   1016a:	f47f aefa 	bne.w	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
                /* If filtering, add it to list of duplicate addresses */
                if (g_ble_ll_scan_sm.scan_filt_dups) {
   1016e:	797b      	ldrb	r3, [r7, #5]
   10170:	2b00      	cmp	r3, #0
   10172:	f43f aef6 	beq.w	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
                    ble_ll_scan_add_dup_adv(adv_addr, txadd, subev);
   10176:	4628      	mov	r0, r5
   10178:	4649      	mov	r1, r9
   1017a:	4652      	mov	r2, sl
   1017c:	f7ff fcc6 	bl	fb0c <ble_ll_scan_add_dup_adv>
   10180:	e6ef      	b.n	ff62 <ble_ll_scan_rx_pkt_in+0x4e>
    if (ble_ll_scan_chk_filter_policy(ptype, rxbuf, hdr->rxinfo.flags)) {
        goto scan_continue;
    }

    /* Get advertisers address type and a pointer to the address */
    txadd = rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK;
   10182:	4699      	mov	r9, r3
    adv_addr = rxbuf + BLE_LL_PDU_HDR_LEN;
   10184:	462e      	mov	r6, r5
   10186:	e721      	b.n	ffcc <ble_ll_scan_rx_pkt_in+0xb8>
   10188:	20003750 	.word	0x20003750
   1018c:	0001f2e3 	.word	0x0001f2e3
   10190:	20003624 	.word	0x20003624
   10194:	20001eb0 	.word	0x20001eb0
   10198:	20003710 	.word	0x20003710
   1019c:	20003b5c 	.word	0x20003b5c

000101a0 <ble_ll_scan_set_scan_params>:
    return;
}

int
ble_ll_scan_set_scan_params(uint8_t *cmd)
{
   101a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint16_t scan_window;
    struct ble_ll_scan_sm *scansm;

    /* If already enabled, we return an error */
    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_enabled) {
   101a4:	4d17      	ldr	r5, [pc, #92]	; (10204 <ble_ll_scan_set_scan_params+0x64>)
   101a6:	782c      	ldrb	r4, [r5, #0]
    return;
}

int
ble_ll_scan_set_scan_params(uint8_t *cmd)
{
   101a8:	4606      	mov	r6, r0
    uint16_t scan_window;
    struct ble_ll_scan_sm *scansm;

    /* If already enabled, we return an error */
    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_enabled) {
   101aa:	bb2c      	cbnz	r4, 101f8 <ble_ll_scan_set_scan_params+0x58>
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* Get the scan interval and window */
    scan_type = cmd[0];
   101ac:	f810 8b01 	ldrb.w	r8, [r0], #1
    scan_itvl  = le16toh(cmd + 1);
   101b0:	f00c ff6d 	bl	1d08e <le16toh>
   101b4:	4607      	mov	r7, r0
    scan_window = le16toh(cmd + 3);
   101b6:	1cf0      	adds	r0, r6, #3
   101b8:	f00c ff69 	bl	1d08e <le16toh>
    own_addr_type = cmd[5];
    filter_policy = cmd[6];

    /* Check scan type */
    if ((scan_type != BLE_HCI_SCAN_TYPE_PASSIVE) &&
   101bc:	f1b8 0f01 	cmp.w	r8, #1

    /* Get the scan interval and window */
    scan_type = cmd[0];
    scan_itvl  = le16toh(cmd + 1);
    scan_window = le16toh(cmd + 3);
    own_addr_type = cmd[5];
   101c0:	7972      	ldrb	r2, [r6, #5]
    filter_policy = cmd[6];
   101c2:	79b1      	ldrb	r1, [r6, #6]

    /* Check scan type */
    if ((scan_type != BLE_HCI_SCAN_TYPE_PASSIVE) &&
   101c4:	d81b      	bhi.n	101fe <ble_ll_scan_set_scan_params+0x5e>
        (scan_type != BLE_HCI_SCAN_TYPE_ACTIVE)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check interval and window */
    if ((scan_itvl < BLE_HCI_SCAN_ITVL_MIN) ||
   101c6:	1f3b      	subs	r3, r7, #4
   101c8:	b29b      	uxth	r3, r3
   101ca:	f643 76fc 	movw	r6, #16380	; 0x3ffc
   101ce:	42b3      	cmp	r3, r6
   101d0:	d815      	bhi.n	101fe <ble_ll_scan_set_scan_params+0x5e>
        (scan_itvl > BLE_HCI_SCAN_ITVL_MAX) ||
   101d2:	1f03      	subs	r3, r0, #4
   101d4:	b29b      	uxth	r3, r3
   101d6:	42b3      	cmp	r3, r6
   101d8:	d811      	bhi.n	101fe <ble_ll_scan_set_scan_params+0x5e>
        (scan_window < BLE_HCI_SCAN_WINDOW_MIN) ||
        (scan_window > BLE_HCI_SCAN_WINDOW_MAX) ||
   101da:	4287      	cmp	r7, r0
   101dc:	d30f      	bcc.n	101fe <ble_ll_scan_set_scan_params+0x5e>
        (scan_itvl < scan_window)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check own addr type */
    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
   101de:	2a03      	cmp	r2, #3
   101e0:	d80d      	bhi.n	101fe <ble_ll_scan_set_scan_params+0x5e>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Check scanner filter policy */
    if (filter_policy > BLE_HCI_SCAN_FILT_MAX) {
   101e2:	2903      	cmp	r1, #3
   101e4:	d80b      	bhi.n	101fe <ble_ll_scan_set_scan_params+0x5e>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Set state machine parameters */
    scansm->scan_type = scan_type;
   101e6:	f885 8001 	strb.w	r8, [r5, #1]
    scansm->scan_itvl = scan_itvl;
    scansm->scan_window = scan_window;
    scansm->scan_filt_policy = filter_policy;
   101ea:	7129      	strb	r1, [r5, #4]
    scansm->own_addr_type = own_addr_type;
   101ec:	70aa      	strb	r2, [r5, #2]
    }

    /* Set state machine parameters */
    scansm->scan_type = scan_type;
    scansm->scan_itvl = scan_itvl;
    scansm->scan_window = scan_window;
   101ee:	82e8      	strh	r0, [r5, #22]
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    /* Set state machine parameters */
    scansm->scan_type = scan_type;
    scansm->scan_itvl = scan_itvl;
   101f0:	82af      	strh	r7, [r5, #20]
    scansm->scan_window = scan_window;
    scansm->scan_filt_policy = filter_policy;
    scansm->own_addr_type = own_addr_type;

    return 0;
   101f2:	4620      	mov	r0, r4
   101f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    struct ble_ll_scan_sm *scansm;

    /* If already enabled, we return an error */
    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_enabled) {
        return BLE_ERR_CMD_DISALLOWED;
   101f8:	200c      	movs	r0, #12
   101fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    filter_policy = cmd[6];

    /* Check scan type */
    if ((scan_type != BLE_HCI_SCAN_TYPE_PASSIVE) &&
        (scan_type != BLE_HCI_SCAN_TYPE_ACTIVE)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
   101fe:	2012      	movs	r0, #18
    scansm->scan_window = scan_window;
    scansm->scan_filt_policy = filter_policy;
    scansm->own_addr_type = own_addr_type;

    return 0;
}
   10200:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10204:	20003750 	.word	0x20003750

00010208 <ble_ll_scan_set_enable>:
 *
 * @return int BLE error code.
 */
int
ble_ll_scan_set_enable(uint8_t *cmd)
{
   10208:	b510      	push	{r4, lr}
    uint8_t enable;
    struct ble_ll_scan_sm *scansm;

    /* Check for valid parameters */
    enable = cmd[0];
    filter_dups = cmd[1];
   1020a:	7842      	ldrb	r2, [r0, #1]
    uint8_t filter_dups;
    uint8_t enable;
    struct ble_ll_scan_sm *scansm;

    /* Check for valid parameters */
    enable = cmd[0];
   1020c:	7804      	ldrb	r4, [r0, #0]
    filter_dups = cmd[1];
    if ((filter_dups > 1) || (enable > 1)) {
   1020e:	2a01      	cmp	r2, #1
   10210:	d817      	bhi.n	10242 <ble_ll_scan_set_enable+0x3a>
   10212:	2c01      	cmp	r4, #1
   10214:	d815      	bhi.n	10242 <ble_ll_scan_set_enable+0x3a>
   10216:	4b0c      	ldr	r3, [pc, #48]	; (10248 <ble_ll_scan_set_enable+0x40>)
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    rc = BLE_ERR_SUCCESS;
    scansm = &g_ble_ll_scan_sm;
    if (enable) {
   10218:	b164      	cbz	r4, 10234 <ble_ll_scan_set_enable+0x2c>
        /* If already enabled, do nothing */
        if (!scansm->scan_enabled) {
   1021a:	7819      	ldrb	r1, [r3, #0]
   1021c:	b921      	cbnz	r1, 10228 <ble_ll_scan_set_enable+0x20>
            /* Start the scanning state machine */
            scansm->scan_filt_dups = filter_dups;
   1021e:	715a      	strb	r2, [r3, #5]
            ble_ll_scan_sm_stop(1);
        }
    }

    return rc;
}
   10220:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (enable) {
        /* If already enabled, do nothing */
        if (!scansm->scan_enabled) {
            /* Start the scanning state machine */
            scansm->scan_filt_dups = filter_dups;
            rc = ble_ll_scan_sm_start(scansm);
   10224:	f7ff bc32 	b.w	fa8c <ble_ll_scan_sm_start.constprop.3>
        } else {
            /* Controller does not allow initiating and scanning.*/
            if (scansm->scan_type == BLE_SCAN_TYPE_INITIATE) {
   10228:	785b      	ldrb	r3, [r3, #1]
   1022a:	2b02      	cmp	r3, #2
                rc = BLE_ERR_CMD_DISALLOWED;
   1022c:	bf14      	ite	ne
   1022e:	2000      	movne	r0, #0
   10230:	200c      	moveq	r0, #12
   10232:	bd10      	pop	{r4, pc}
            }
        }
    } else {
        if (scansm->scan_enabled) {
   10234:	7818      	ldrb	r0, [r3, #0]
   10236:	b128      	cbz	r0, 10244 <ble_ll_scan_set_enable+0x3c>
            ble_ll_scan_sm_stop(1);
   10238:	2001      	movs	r0, #1
   1023a:	f7ff fc91 	bl	fb60 <ble_ll_scan_sm_stop>
    filter_dups = cmd[1];
    if ((filter_dups > 1) || (enable > 1)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    rc = BLE_ERR_SUCCESS;
   1023e:	4620      	mov	r0, r4
   10240:	bd10      	pop	{r4, pc}

    /* Check for valid parameters */
    enable = cmd[0];
    filter_dups = cmd[1];
    if ((filter_dups > 1) || (enable > 1)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
   10242:	2012      	movs	r0, #18
            ble_ll_scan_sm_stop(1);
        }
    }

    return rc;
}
   10244:	bd10      	pop	{r4, pc}
   10246:	bf00      	nop
   10248:	20003750 	.word	0x20003750

0001024c <ble_ll_scan_can_chg_whitelist>:
{
    int rc;
    struct ble_ll_scan_sm *scansm;

    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_enabled && (scansm->scan_filt_policy & 1)) {
   1024c:	4b05      	ldr	r3, [pc, #20]	; (10264 <ble_ll_scan_can_chg_whitelist+0x18>)
   1024e:	781a      	ldrb	r2, [r3, #0]
   10250:	b12a      	cbz	r2, 1025e <ble_ll_scan_can_chg_whitelist+0x12>
   10252:	7918      	ldrb	r0, [r3, #4]
   10254:	f080 0001 	eor.w	r0, r0, #1
   10258:	f000 0001 	and.w	r0, r0, #1
   1025c:	4770      	bx	lr
        rc = 0;
    } else {
        rc = 1;
   1025e:	2001      	movs	r0, #1
    }

    return rc;
}
   10260:	4770      	bx	lr
   10262:	bf00      	nop
   10264:	20003750 	.word	0x20003750

00010268 <ble_ll_scan_initiator_start>:
ble_ll_scan_initiator_start(struct hci_create_conn *hcc)
{
    struct ble_ll_scan_sm *scansm;

    scansm = &g_ble_ll_scan_sm;
    scansm->scan_type = BLE_SCAN_TYPE_INITIATE;
   10268:	4b06      	ldr	r3, [pc, #24]	; (10284 <ble_ll_scan_initiator_start+0x1c>)
   1026a:	2202      	movs	r2, #2
   1026c:	705a      	strb	r2, [r3, #1]
    scansm->scan_itvl = hcc->scan_itvl;
   1026e:	8802      	ldrh	r2, [r0, #0]
   10270:	829a      	strh	r2, [r3, #20]
    scansm->scan_window = hcc->scan_window;
   10272:	8842      	ldrh	r2, [r0, #2]
   10274:	82da      	strh	r2, [r3, #22]
    scansm->scan_filt_policy = hcc->filter_policy;
   10276:	7902      	ldrb	r2, [r0, #4]
   10278:	711a      	strb	r2, [r3, #4]
    scansm->own_addr_type = hcc->own_addr_type;
   1027a:	7b02      	ldrb	r2, [r0, #12]
   1027c:	709a      	strb	r2, [r3, #2]
    return ble_ll_scan_sm_start(scansm);
   1027e:	f7ff bc05 	b.w	fa8c <ble_ll_scan_sm_start.constprop.3>
   10282:	bf00      	nop
   10284:	20003750 	.word	0x20003750

00010288 <ble_ll_scan_enabled>:
 */
int
ble_ll_scan_enabled(void)
{
    return (int)g_ble_ll_scan_sm.scan_enabled;
}
   10288:	4b01      	ldr	r3, [pc, #4]	; (10290 <ble_ll_scan_enabled+0x8>)
   1028a:	7818      	ldrb	r0, [r3, #0]
   1028c:	4770      	bx	lr
   1028e:	bf00      	nop
   10290:	20003750 	.word	0x20003750

00010294 <ble_ll_scan_get_peer_rpa>:
    struct ble_ll_scan_sm *scansm;

    /* XXX: should this go into IRK list or connection? */
    scansm = &g_ble_ll_scan_sm;
    return scansm->scan_peer_rpa;
}
   10294:	4800      	ldr	r0, [pc, #0]	; (10298 <ble_ll_scan_get_peer_rpa+0x4>)
   10296:	4770      	bx	lr
   10298:	2000375a 	.word	0x2000375a

0001029c <ble_ll_scan_get_local_rpa>:

    /*
     * The RPA we used is in connect request or scan request and is the
     * first address in the packet
     */
    rpa = scansm->scan_req_pdu->om_data;
   1029c:	4b01      	ldr	r3, [pc, #4]	; (102a4 <ble_ll_scan_get_local_rpa+0x8>)
   1029e:	69db      	ldr	r3, [r3, #28]

    return rpa;
}
   102a0:	6818      	ldr	r0, [r3, #0]
   102a2:	4770      	bx	lr
   102a4:	20003750 	.word	0x20003750

000102a8 <ble_ll_scan_set_peer_rpa>:
ble_ll_scan_set_peer_rpa(uint8_t *rpa)
{
    struct ble_ll_scan_sm *scansm;

    scansm = &g_ble_ll_scan_sm;
    memcpy(scansm->scan_peer_rpa, rpa, BLE_DEV_ADDR_LEN);
   102a8:	4b02      	ldr	r3, [pc, #8]	; (102b4 <ble_ll_scan_set_peer_rpa+0xc>)
   102aa:	6802      	ldr	r2, [r0, #0]
   102ac:	601a      	str	r2, [r3, #0]
   102ae:	8882      	ldrh	r2, [r0, #4]
   102b0:	809a      	strh	r2, [r3, #4]
   102b2:	4770      	bx	lr
   102b4:	2000375a 	.word	0x2000375a

000102b8 <ble_ll_scan_get_pdu>:
/* Returns the PDU allocated by the scanner */
struct os_mbuf *
ble_ll_scan_get_pdu(void)
{
    return g_ble_ll_scan_sm.scan_req_pdu;
}
   102b8:	4b01      	ldr	r3, [pc, #4]	; (102c0 <ble_ll_scan_get_pdu+0x8>)
   102ba:	69d8      	ldr	r0, [r3, #28]
   102bc:	4770      	bx	lr
   102be:	bf00      	nop
   102c0:	20003750 	.word	0x20003750

000102c4 <ble_ll_scan_whitelist_enabled>:

/* Returns true if whitelist is enabled for scanning */
int
ble_ll_scan_whitelist_enabled(void)
{
    return g_ble_ll_scan_sm.scan_filt_policy & 1;
   102c4:	4b02      	ldr	r3, [pc, #8]	; (102d0 <ble_ll_scan_whitelist_enabled+0xc>)
   102c6:	7918      	ldrb	r0, [r3, #4]
}
   102c8:	f000 0001 	and.w	r0, r0, #1
   102cc:	4770      	bx	lr
   102ce:	bf00      	nop
   102d0:	20003750 	.word	0x20003750

000102d4 <ble_ll_scan_init>:
 * Initialize a scanner. Must be called before scanning can be started.
 * Expected to be called with a un-initialized or reset scanning state machine.
 */
void
ble_ll_scan_init(void)
{
   102d4:	b510      	push	{r4, lr}
    struct ble_ll_scan_sm *scansm;

    /* Clear state machine in case re-initialized */
    scansm = &g_ble_ll_scan_sm;
    memset(scansm, 0, sizeof(struct ble_ll_scan_sm));
   102d6:	4c11      	ldr	r4, [pc, #68]	; (1031c <ble_ll_scan_init+0x48>)
   102d8:	2100      	movs	r1, #0
   102da:	2240      	movs	r2, #64	; 0x40
   102dc:	4620      	mov	r0, r4
   102de:	f7f8 fe98 	bl	9012 <memset>

    /* Initialize scanning window end event */
    scansm->scan_sched_ev.ev_type = BLE_LL_EVENT_SCAN;
   102e2:	2313      	movs	r3, #19
    /* Set all non-zero default parameters */
    scansm->scan_itvl = BLE_HCI_SCAN_ITVL_DEF;
    scansm->scan_window = BLE_HCI_SCAN_WINDOW_DEF;

    /* Initialize connection supervision timer */
    cputime_timer_init(&scansm->scan_timer, ble_ll_scan_timer_cb, scansm);
   102e4:	4622      	mov	r2, r4
    /* Clear state machine in case re-initialized */
    scansm = &g_ble_ll_scan_sm;
    memset(scansm, 0, sizeof(struct ble_ll_scan_sm));

    /* Initialize scanning window end event */
    scansm->scan_sched_ev.ev_type = BLE_LL_EVENT_SCAN;
   102e6:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    /* Set all non-zero default parameters */
    scansm->scan_itvl = BLE_HCI_SCAN_ITVL_DEF;
    scansm->scan_window = BLE_HCI_SCAN_WINDOW_DEF;

    /* Initialize connection supervision timer */
    cputime_timer_init(&scansm->scan_timer, ble_ll_scan_timer_cb, scansm);
   102ea:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    /* Initialize scanning window end event */
    scansm->scan_sched_ev.ev_type = BLE_LL_EVENT_SCAN;
    scansm->scan_sched_ev.ev_arg = scansm;

    /* Set all non-zero default parameters */
    scansm->scan_itvl = BLE_HCI_SCAN_ITVL_DEF;
   102ee:	2310      	movs	r3, #16
    scansm->scan_window = BLE_HCI_SCAN_WINDOW_DEF;

    /* Initialize connection supervision timer */
    cputime_timer_init(&scansm->scan_timer, ble_ll_scan_timer_cb, scansm);
   102f0:	490b      	ldr	r1, [pc, #44]	; (10320 <ble_ll_scan_init+0x4c>)
    /* Initialize scanning window end event */
    scansm->scan_sched_ev.ev_type = BLE_LL_EVENT_SCAN;
    scansm->scan_sched_ev.ev_arg = scansm;

    /* Set all non-zero default parameters */
    scansm->scan_itvl = BLE_HCI_SCAN_ITVL_DEF;
   102f2:	82a3      	strh	r3, [r4, #20]
    scansm->scan_window = BLE_HCI_SCAN_WINDOW_DEF;
   102f4:	82e3      	strh	r3, [r4, #22]
    scansm = &g_ble_ll_scan_sm;
    memset(scansm, 0, sizeof(struct ble_ll_scan_sm));

    /* Initialize scanning window end event */
    scansm->scan_sched_ev.ev_type = BLE_LL_EVENT_SCAN;
    scansm->scan_sched_ev.ev_arg = scansm;
   102f6:	6264      	str	r4, [r4, #36]	; 0x24
    /* Set all non-zero default parameters */
    scansm->scan_itvl = BLE_HCI_SCAN_ITVL_DEF;
    scansm->scan_window = BLE_HCI_SCAN_WINDOW_DEF;

    /* Initialize connection supervision timer */
    cputime_timer_init(&scansm->scan_timer, ble_ll_scan_timer_cb, scansm);
   102f8:	f7f8 fcec 	bl	8cd4 <cputime_timer_init>

    /* Get a scan request mbuf (packet header) and attach to state machine */
    scansm->scan_req_pdu = os_msys_get_pkthdr(BLE_MBUF_PAYLOAD_SIZE,
   102fc:	f44f 7082 	mov.w	r0, #260	; 0x104
   10300:	2108      	movs	r1, #8
   10302:	f7f9 fe16 	bl	9f32 <os_msys_get_pkthdr>
   10306:	4602      	mov	r2, r0
   10308:	61e0      	str	r0, [r4, #28]
                                              sizeof(struct ble_mbuf_hdr));
    assert(scansm->scan_req_pdu != NULL);
   1030a:	b928      	cbnz	r0, 10318 <ble_ll_scan_init+0x44>
   1030c:	4805      	ldr	r0, [pc, #20]	; (10324 <ble_ll_scan_init+0x50>)
   1030e:	f240 51cb 	movw	r1, #1483	; 0x5cb
   10312:	4613      	mov	r3, r2
   10314:	f7f9 fcdc 	bl	9cd0 <__assert_func>
   10318:	bd10      	pop	{r4, pc}
   1031a:	bf00      	nop
   1031c:	20003750 	.word	0x20003750
   10320:	0000fa85 	.word	0x0000fa85
   10324:	0001f2e3 	.word	0x0001f2e3

00010328 <ble_ll_scan_reset>:
 *
 * @return int
 */
void
ble_ll_scan_reset(void)
{
   10328:	b510      	push	{r4, lr}
    struct ble_ll_scan_sm *scansm;

    /* If enabled, stop it. */
    scansm = &g_ble_ll_scan_sm;
    if (scansm->scan_enabled) {
   1032a:	4b0e      	ldr	r3, [pc, #56]	; (10364 <ble_ll_scan_reset+0x3c>)
   1032c:	781a      	ldrb	r2, [r3, #0]
   1032e:	461c      	mov	r4, r3
   10330:	b112      	cbz	r2, 10338 <ble_ll_scan_reset+0x10>
        ble_ll_scan_sm_stop(0);
   10332:	2000      	movs	r0, #0
   10334:	f7ff fc14 	bl	fb60 <ble_ll_scan_sm_stop>
    }

    /* Free the scan request pdu */
    os_mbuf_free_chain(scansm->scan_req_pdu);
   10338:	69e0      	ldr	r0, [r4, #28]
   1033a:	f7f9 fe10 	bl	9f5e <os_mbuf_free_chain>

    /* Reset duplicate advertisers and those from which we rxd a response */
    g_ble_ll_scan_num_rsp_advs = 0;
   1033e:	2400      	movs	r4, #0
   10340:	4b09      	ldr	r3, [pc, #36]	; (10368 <ble_ll_scan_reset+0x40>)
    memset(&g_ble_ll_scan_rsp_advs[0], 0, sizeof(g_ble_ll_scan_rsp_advs));
   10342:	480a      	ldr	r0, [pc, #40]	; (1036c <ble_ll_scan_reset+0x44>)

    /* Free the scan request pdu */
    os_mbuf_free_chain(scansm->scan_req_pdu);

    /* Reset duplicate advertisers and those from which we rxd a response */
    g_ble_ll_scan_num_rsp_advs = 0;
   10344:	701c      	strb	r4, [r3, #0]
    memset(&g_ble_ll_scan_rsp_advs[0], 0, sizeof(g_ble_ll_scan_rsp_advs));
   10346:	4621      	mov	r1, r4
   10348:	2240      	movs	r2, #64	; 0x40
   1034a:	f7f8 fe62 	bl	9012 <memset>

    g_ble_ll_scan_num_dup_advs = 0;
   1034e:	4b08      	ldr	r3, [pc, #32]	; (10370 <ble_ll_scan_reset+0x48>)
    memset(&g_ble_ll_scan_dup_advs[0], 0, sizeof(g_ble_ll_scan_dup_advs));
   10350:	4808      	ldr	r0, [pc, #32]	; (10374 <ble_ll_scan_reset+0x4c>)

    /* Reset duplicate advertisers and those from which we rxd a response */
    g_ble_ll_scan_num_rsp_advs = 0;
    memset(&g_ble_ll_scan_rsp_advs[0], 0, sizeof(g_ble_ll_scan_rsp_advs));

    g_ble_ll_scan_num_dup_advs = 0;
   10352:	701c      	strb	r4, [r3, #0]
    memset(&g_ble_ll_scan_dup_advs[0], 0, sizeof(g_ble_ll_scan_dup_advs));
   10354:	4621      	mov	r1, r4
   10356:	2240      	movs	r2, #64	; 0x40
   10358:	f7f8 fe5b 	bl	9012 <memset>

    /* Call the init function again */
    ble_ll_scan_init();
}
   1035c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

    g_ble_ll_scan_num_dup_advs = 0;
    memset(&g_ble_ll_scan_dup_advs[0], 0, sizeof(g_ble_ll_scan_dup_advs));

    /* Call the init function again */
    ble_ll_scan_init();
   10360:	f7ff bfb8 	b.w	102d4 <ble_ll_scan_init>
   10364:	20003750 	.word	0x20003750
   10368:	20001eb0 	.word	0x20001eb0
   1036c:	20003710 	.word	0x20003710
   10370:	20001eb1 	.word	0x20001eb1
   10374:	200036d0 	.word	0x200036d0

00010378 <ble_ll_sched_is_overlap>:
                        struct ble_ll_sched_item *s2)
{
    int rc;

    rc = 1;
    if ((int32_t)(s1->start_time - s2->start_time) < 0) {
   10378:	6843      	ldr	r3, [r0, #4]
   1037a:	684a      	ldr	r2, [r1, #4]
 * @return int 0: dont overlap 1:overlap
 */
static int
ble_ll_sched_is_overlap(struct ble_ll_sched_item *s1,
                        struct ble_ll_sched_item *s2)
{
   1037c:	b510      	push	{r4, lr}
    int rc;

    rc = 1;
    if ((int32_t)(s1->start_time - s2->start_time) < 0) {
   1037e:	1a9c      	subs	r4, r3, r2
   10380:	2c00      	cmp	r4, #0
   10382:	da06      	bge.n	10392 <ble_ll_sched_is_overlap+0x1a>
        /* Make sure this event does not overlap current event */
        if ((int32_t)(s1->end_time - s2->start_time) <= 0) {
   10384:	6883      	ldr	r3, [r0, #8]
   10386:	1a98      	subs	r0, r3, r2
   10388:	2800      	cmp	r0, #0
   1038a:	bfd4      	ite	le
   1038c:	2000      	movle	r0, #0
   1038e:	2001      	movgt	r0, #1
   10390:	bd10      	pop	{r4, pc}
            rc = 0;
        }
    } else {
        /* Check for overlap */
        if ((int32_t)(s1->start_time - s2->end_time) >= 0) {
   10392:	6888      	ldr	r0, [r1, #8]
   10394:	1a18      	subs	r0, r3, r0
   10396:	0fc0      	lsrs	r0, r0, #31
            rc = 0;
        }
    }

    return rc;
}
   10398:	bd10      	pop	{r4, pc}
	...

0001039c <ble_ll_sched_conn_overlap>:
    return rc;
}

static int
ble_ll_sched_conn_overlap(struct ble_ll_sched_item *entry)
{
   1039c:	b510      	push	{r4, lr}
    int rc;
    struct ble_ll_conn_sm *connsm;

    /* Should only be advertising or a connection here */
    if (entry->sched_type == BLE_LL_SCHED_TYPE_CONN) {
   1039e:	7803      	ldrb	r3, [r0, #0]
   103a0:	2b03      	cmp	r3, #3
   103a2:	d111      	bne.n	103c8 <ble_ll_sched_conn_overlap+0x2c>
        connsm = (struct ble_ll_conn_sm *)entry->cb_arg;
        entry->enqueued = 0;
   103a4:	2300      	movs	r3, #0
   103a6:	7043      	strb	r3, [r0, #1]
        TAILQ_REMOVE(&g_ble_ll_sched_q, entry, link);
   103a8:	6943      	ldr	r3, [r0, #20]
    int rc;
    struct ble_ll_conn_sm *connsm;

    /* Should only be advertising or a connection here */
    if (entry->sched_type == BLE_LL_SCHED_TYPE_CONN) {
        connsm = (struct ble_ll_conn_sm *)entry->cb_arg;
   103aa:	68c1      	ldr	r1, [r0, #12]
   103ac:	6982      	ldr	r2, [r0, #24]
        entry->enqueued = 0;
        TAILQ_REMOVE(&g_ble_ll_sched_q, entry, link);
   103ae:	b10b      	cbz	r3, 103b4 <ble_ll_sched_conn_overlap+0x18>
   103b0:	619a      	str	r2, [r3, #24]
   103b2:	e001      	b.n	103b8 <ble_ll_sched_conn_overlap+0x1c>
   103b4:	4c06      	ldr	r4, [pc, #24]	; (103d0 <ble_ll_sched_conn_overlap+0x34>)
   103b6:	6062      	str	r2, [r4, #4]
   103b8:	6982      	ldr	r2, [r0, #24]
        ble_ll_event_send(&connsm->conn_ev_end);
   103ba:	f101 00a4 	add.w	r0, r1, #164	; 0xa4

    /* Should only be advertising or a connection here */
    if (entry->sched_type == BLE_LL_SCHED_TYPE_CONN) {
        connsm = (struct ble_ll_conn_sm *)entry->cb_arg;
        entry->enqueued = 0;
        TAILQ_REMOVE(&g_ble_ll_sched_q, entry, link);
   103be:	6013      	str	r3, [r2, #0]
        ble_ll_event_send(&connsm->conn_ev_end);
   103c0:	f7fa fe9c 	bl	b0fc <ble_ll_event_send>
        rc = 0;
   103c4:	2000      	movs	r0, #0
   103c6:	bd10      	pop	{r4, pc}
    } else {
        rc = -1;
   103c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }

    return rc;
}
   103cc:	bd10      	pop	{r4, pc}
   103ce:	bf00      	nop
   103d0:	200037a4 	.word	0x200037a4

000103d4 <ble_ll_sched_run>:
 *
 * @return int
 */
void
ble_ll_sched_run(void *arg)
{
   103d4:	b570      	push	{r4, r5, r6, lr}
    struct ble_ll_sched_item *sch;

    /* Look through schedule queue */
    while ((sch = TAILQ_FIRST(&g_ble_ll_sched_q)) != NULL) {
   103d6:	4d21      	ldr	r5, [pc, #132]	; (1045c <ble_ll_sched_run+0x88>)
   103d8:	682c      	ldr	r4, [r5, #0]
   103da:	2c00      	cmp	r4, #0
   103dc:	d03d      	beq.n	1045a <ble_ll_sched_run+0x86>
        /* Make sure we have passed the start time of the first event */
        if ((int32_t)(cputime_get32() - sch->start_time) >= 0) {
   103de:	f7f8 fdad 	bl	8f3c <cputime_get32>
   103e2:	6861      	ldr	r1, [r4, #4]
   103e4:	1a40      	subs	r0, r0, r1
   103e6:	2800      	cmp	r0, #0
   103e8:	db32      	blt.n	10450 <ble_ll_sched_run+0x7c>
            /* Remove schedule item and execute the callback */
            TAILQ_REMOVE(&g_ble_ll_sched_q, sch, link);
   103ea:	6963      	ldr	r3, [r4, #20]
   103ec:	69a2      	ldr	r2, [r4, #24]
   103ee:	b10b      	cbz	r3, 103f4 <ble_ll_sched_run+0x20>
   103f0:	619a      	str	r2, [r3, #24]
   103f2:	e000      	b.n	103f6 <ble_ll_sched_run+0x22>
   103f4:	606a      	str	r2, [r5, #4]
   103f6:	69a2      	ldr	r2, [r4, #24]
            sch->enqueued = 0;
   103f8:	2600      	movs	r6, #0
    /* Look through schedule queue */
    while ((sch = TAILQ_FIRST(&g_ble_ll_sched_q)) != NULL) {
        /* Make sure we have passed the start time of the first event */
        if ((int32_t)(cputime_get32() - sch->start_time) >= 0) {
            /* Remove schedule item and execute the callback */
            TAILQ_REMOVE(&g_ble_ll_sched_q, sch, link);
   103fa:	6013      	str	r3, [r2, #0]
            sch->enqueued = 0;
   103fc:	7066      	strb	r6, [r4, #1]

    /*
     * This is either an advertising event or connection event start. If
     * we are scanning or initiating just stop it.
     */
    lls = ble_ll_state_get();
   103fe:	f7fa fe77 	bl	b0f0 <ble_ll_state_get>
    if (lls != BLE_LL_STATE_STANDBY) {
   10402:	4605      	mov	r5, r0
   10404:	b1c8      	cbz	r0, 1043a <ble_ll_sched_run+0x66>
        /* We have to disable the PHY no matter what */
        ble_phy_disable();
   10406:	f000 ff09 	bl	1121c <ble_phy_disable>
        ble_ll_wfr_disable();
   1040a:	f7fa fd8f 	bl	af2c <ble_ll_wfr_disable>
        if ((lls == BLE_LL_STATE_SCANNING) ||
   1040e:	1eab      	subs	r3, r5, #2
   10410:	b2db      	uxtb	r3, r3
   10412:	2b01      	cmp	r3, #1
   10414:	d803      	bhi.n	1041e <ble_ll_sched_run+0x4a>
            (lls == BLE_LL_STATE_INITIATING)) {
            ble_ll_state_set(BLE_LL_STATE_STANDBY);
   10416:	4630      	mov	r0, r6
   10418:	f7fa fe64 	bl	b0e4 <ble_ll_state_set>
   1041c:	e00d      	b.n	1043a <ble_ll_sched_run+0x66>
        } else if (lls == BLE_LL_STATE_ADV) {
   1041e:	2d01      	cmp	r5, #1
   10420:	4b0f      	ldr	r3, [pc, #60]	; (10460 <ble_ll_sched_run+0x8c>)
   10422:	d105      	bne.n	10430 <ble_ll_sched_run+0x5c>
            STATS_INC(ble_ll_stats, sched_state_adv_errs);
   10424:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   10426:	3201      	adds	r2, #1
   10428:	66da      	str	r2, [r3, #108]	; 0x6c
            ble_ll_adv_halt();
   1042a:	f7fb f859 	bl	b4e0 <ble_ll_adv_halt>
   1042e:	e004      	b.n	1043a <ble_ll_sched_run+0x66>
        } else {
            STATS_INC(ble_ll_stats, sched_state_conn_errs);
   10430:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   10432:	3201      	adds	r2, #1
   10434:	669a      	str	r2, [r3, #104]	; 0x68
            ble_ll_conn_event_halt();
   10436:	f7fc fa87 	bl	c948 <ble_ll_conn_event_halt>
        }
    }

    assert(sch->sched_cb);
   1043a:	6922      	ldr	r2, [r4, #16]
   1043c:	b92a      	cbnz	r2, 1044a <ble_ll_sched_run+0x76>
   1043e:	4809      	ldr	r0, [pc, #36]	; (10464 <ble_ll_sched_run+0x90>)
   10440:	f240 218b 	movw	r1, #651	; 0x28b
   10444:	4613      	mov	r3, r2
   10446:	f7f9 fc43 	bl	9cd0 <__assert_func>
    rc = sch->sched_cb(sch);
   1044a:	4620      	mov	r0, r4
   1044c:	4790      	blx	r2
   1044e:	e7c2      	b.n	103d6 <ble_ll_sched_run+0x2>
            /* Remove schedule item and execute the callback */
            TAILQ_REMOVE(&g_ble_ll_sched_q, sch, link);
            sch->enqueued = 0;
            ble_ll_sched_execute_item(sch);
        } else {
            cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);
   10450:	4805      	ldr	r0, [pc, #20]	; (10468 <ble_ll_sched_run+0x94>)
            break;
        }
    }
}
   10452:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            /* Remove schedule item and execute the callback */
            TAILQ_REMOVE(&g_ble_ll_sched_q, sch, link);
            sch->enqueued = 0;
            ble_ll_sched_execute_item(sch);
        } else {
            cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);
   10456:	f7f8 bc53 	b.w	8d00 <cputime_timer_start>
            break;
        }
    }
}
   1045a:	bd70      	pop	{r4, r5, r6, pc}
   1045c:	200037a4 	.word	0x200037a4
   10460:	200030ac 	.word	0x200030ac
   10464:	0001f2f1 	.word	0x0001f2f1
   10468:	20003790 	.word	0x20003790

0001046c <ble_ll_sched_overlaps_current>:
 * Determines if the schedule item overlaps the currently running schedule
 * item. We only care about connection schedule items
 */
int
ble_ll_sched_overlaps_current(struct ble_ll_sched_item *sch)
{
   1046c:	b510      	push	{r4, lr}
   1046e:	4604      	mov	r4, r0
    int rc;
    uint32_t ce_end_time;

    rc = 0;
    if (ble_ll_state_get() == BLE_LL_STATE_CONNECTION) {
   10470:	f7fa fe3e 	bl	b0f0 <ble_ll_state_get>
   10474:	2804      	cmp	r0, #4
   10476:	d108      	bne.n	1048a <ble_ll_sched_overlaps_current+0x1e>
        ce_end_time = ble_ll_conn_get_ce_end_time();
   10478:	f7fb fe74 	bl	c164 <ble_ll_conn_get_ce_end_time>
        if ((int32_t)(ce_end_time - sch->start_time) > 0) {
   1047c:	6863      	ldr	r3, [r4, #4]
   1047e:	1ac0      	subs	r0, r0, r3
   10480:	2800      	cmp	r0, #0
   10482:	bfd4      	ite	le
   10484:	2000      	movle	r0, #0
   10486:	2001      	movgt	r0, #1
   10488:	bd10      	pop	{r4, pc}
ble_ll_sched_overlaps_current(struct ble_ll_sched_item *sch)
{
    int rc;
    uint32_t ce_end_time;

    rc = 0;
   1048a:	2000      	movs	r0, #0
        if ((int32_t)(ce_end_time - sch->start_time) > 0) {
            rc = 1;
        }
    }
    return rc;
}
   1048c:	bd10      	pop	{r4, pc}
	...

00010490 <ble_ll_sched_insert_if_empty>:
struct ble_ll_sched_item *
ble_ll_sched_insert_if_empty(struct ble_ll_sched_item *sch)
{
    struct ble_ll_sched_item *entry;

    entry = TAILQ_FIRST(&g_ble_ll_sched_q);
   10490:	4a06      	ldr	r2, [pc, #24]	; (104ac <ble_ll_sched_insert_if_empty+0x1c>)
    return rc;
}

struct ble_ll_sched_item *
ble_ll_sched_insert_if_empty(struct ble_ll_sched_item *sch)
{
   10492:	4603      	mov	r3, r0
    struct ble_ll_sched_item *entry;

    entry = TAILQ_FIRST(&g_ble_ll_sched_q);
   10494:	6810      	ldr	r0, [r2, #0]
    if (!entry) {
   10496:	b938      	cbnz	r0, 104a8 <ble_ll_sched_insert_if_empty+0x18>
        TAILQ_INSERT_HEAD(&g_ble_ll_sched_q, sch, link);
   10498:	4619      	mov	r1, r3
   1049a:	6013      	str	r3, [r2, #0]
   1049c:	f841 0f14 	str.w	r0, [r1, #20]!
   104a0:	619a      	str	r2, [r3, #24]
   104a2:	6051      	str	r1, [r2, #4]
        sch->enqueued = 1;
   104a4:	2201      	movs	r2, #1
   104a6:	705a      	strb	r2, [r3, #1]
    }
    return entry;
}
   104a8:	4770      	bx	lr
   104aa:	bf00      	nop
   104ac:	200037a4 	.word	0x200037a4

000104b0 <ble_ll_sched_conn_reschedule>:

int
ble_ll_sched_conn_reschedule(struct ble_ll_conn_sm *connsm)
{
   104b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    /* Get schedule element from connection */
    sch = &connsm->conn_sch;

    /* Set schedule start and end times */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
   104b4:	79c3      	ldrb	r3, [r0, #7]
   104b6:	2b02      	cmp	r3, #2
    return entry;
}

int
ble_ll_sched_conn_reschedule(struct ble_ll_conn_sm *connsm)
{
   104b8:	4604      	mov	r4, r0
    struct ble_ll_sched_item *end_overlap;
    struct ble_ll_sched_item *entry;
    struct ble_ll_conn_sm *tmp;

    /* Get schedule element from connection */
    sch = &connsm->conn_sch;
   104ba:	f100 09e0 	add.w	r9, r0, #224	; 0xe0

    /* Set schedule start and end times */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
        usecs = XCVR_RX_SCHED_DELAY_USECS;
        usecs += connsm->slave_cur_window_widening;
   104be:	bf08      	it	eq
   104c0:	6f80      	ldreq	r0, [r0, #120]	; 0x78
    } else {
        usecs = XCVR_TX_SCHED_DELAY_USECS;
    }
    sch->start_time = connsm->anchor_point - cputime_usecs_to_ticks(usecs);
   104c2:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    sch = &connsm->conn_sch;

    /* Set schedule start and end times */
    if (connsm->conn_role == BLE_LL_CONN_ROLE_SLAVE) {
        usecs = XCVR_RX_SCHED_DELAY_USECS;
        usecs += connsm->slave_cur_window_widening;
   104c4:	bf0c      	ite	eq
   104c6:	30be      	addeq	r0, #190	; 0xbe
    } else {
        usecs = XCVR_TX_SCHED_DELAY_USECS;
   104c8:	20be      	movne	r0, #190	; 0xbe
    }
    sch->start_time = connsm->anchor_point - cputime_usecs_to_ticks(usecs);
   104ca:	f7f8 fbf3 	bl	8cb4 <cputime_usecs_to_ticks>
    sch->end_time = connsm->ce_end_time;
   104ce:	6d23      	ldr	r3, [r4, #80]	; 0x50
   104d0:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
        usecs = XCVR_RX_SCHED_DELAY_USECS;
        usecs += connsm->slave_cur_window_widening;
    } else {
        usecs = XCVR_TX_SCHED_DELAY_USECS;
    }
    sch->start_time = connsm->anchor_point - cputime_usecs_to_ticks(usecs);
   104d4:	1a2d      	subs	r5, r5, r0
   104d6:	f8c4 50e4 	str.w	r5, [r4, #228]	; 0xe4
    sch->end_time = connsm->ce_end_time;

    /* Better be past current time or we just leave */
    if ((int32_t)(sch->start_time - cputime_get32()) < 0) {
   104da:	f7f8 fd2f 	bl	8f3c <cputime_get32>
   104de:	1a28      	subs	r0, r5, r0
   104e0:	2800      	cmp	r0, #0
   104e2:	db6b      	blt.n	105bc <ble_ll_sched_conn_reschedule+0x10c>
        return -1;
    }

    /* We have to find a place for this schedule */
    OS_ENTER_CRITICAL(sr);
   104e4:	f7f9 fa1c 	bl	9920 <os_arch_save_sr>
   104e8:	4682      	mov	sl, r0

    if (ble_ll_sched_overlaps_current(sch)) {
   104ea:	4648      	mov	r0, r9
   104ec:	f7ff ffbe 	bl	1046c <ble_ll_sched_overlaps_current>
   104f0:	4606      	mov	r6, r0
   104f2:	b118      	cbz	r0, 104fc <ble_ll_sched_conn_reschedule+0x4c>
        OS_EXIT_CRITICAL(sr);
   104f4:	4650      	mov	r0, sl
   104f6:	f7f9 fa19 	bl	992c <os_arch_restore_sr>
   104fa:	e05f      	b.n	105bc <ble_ll_sched_conn_reschedule+0x10c>
    cputime_timer_stop(&g_ble_ll_sched_timer);

    start_overlap = NULL;
    end_overlap = NULL;
    rc = 0;
    TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   104fc:	4f33      	ldr	r7, [pc, #204]	; (105cc <ble_ll_sched_conn_reschedule+0x11c>)
        OS_EXIT_CRITICAL(sr);
        return -1;
    }

    /* Stop timer since we will add an element */
    cputime_timer_stop(&g_ble_ll_sched_timer);
   104fe:	4834      	ldr	r0, [pc, #208]	; (105d0 <ble_ll_sched_conn_reschedule+0x120>)
   10500:	f7f8 fc5e 	bl	8dc0 <cputime_timer_stop>

    start_overlap = NULL;
    end_overlap = NULL;
    rc = 0;
    TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   10504:	683d      	ldr	r5, [r7, #0]

    /* Stop timer since we will add an element */
    cputime_timer_stop(&g_ble_ll_sched_timer);

    start_overlap = NULL;
    end_overlap = NULL;
   10506:	46b0      	mov	r8, r6
    rc = 0;
    TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   10508:	b32d      	cbz	r5, 10556 <ble_ll_sched_conn_reschedule+0xa6>
        if (ble_ll_sched_is_overlap(sch, entry)) {
   1050a:	4648      	mov	r0, r9
   1050c:	4629      	mov	r1, r5
   1050e:	f7ff ff33 	bl	10378 <ble_ll_sched_is_overlap>
   10512:	b168      	cbz	r0, 10530 <ble_ll_sched_conn_reschedule+0x80>
            /* Only insert if this element is older than all that we overlap */
            if ((entry->sched_type == BLE_LL_SCHED_TYPE_ADV) ||
   10514:	782b      	ldrb	r3, [r5, #0]
   10516:	2b01      	cmp	r3, #1
   10518:	d054      	beq.n	105c4 <ble_ll_sched_conn_reschedule+0x114>
                !ble_ll_conn_is_lru((struct ble_ll_conn_sm *)sch->cb_arg,
   1051a:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   1051e:	68e9      	ldr	r1, [r5, #12]
   10520:	f7fb fe1b 	bl	c15a <ble_ll_conn_is_lru>
    end_overlap = NULL;
    rc = 0;
    TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
        if (ble_ll_sched_is_overlap(sch, entry)) {
            /* Only insert if this element is older than all that we overlap */
            if ((entry->sched_type == BLE_LL_SCHED_TYPE_ADV) ||
   10524:	2800      	cmp	r0, #0
   10526:	d04d      	beq.n	105c4 <ble_ll_sched_conn_reschedule+0x114>
   10528:	46a8      	mov	r8, r5
                                    (struct ble_ll_conn_sm *)entry->cb_arg)) {
                start_overlap = NULL;
                rc = -1;
                break;
            }
            if (start_overlap == NULL) {
   1052a:	b996      	cbnz	r6, 10552 <ble_ll_sched_conn_reschedule+0xa2>
   1052c:	462e      	mov	r6, r5
   1052e:	e010      	b.n	10552 <ble_ll_sched_conn_reschedule+0xa2>
                end_overlap = entry;
            } else {
                end_overlap = entry;
            }
        } else {
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   10530:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   10534:	686a      	ldr	r2, [r5, #4]
   10536:	1a9b      	subs	r3, r3, r2
   10538:	2b00      	cmp	r3, #0
   1053a:	da0a      	bge.n	10552 <ble_ll_sched_conn_reschedule+0xa2>
                rc = 0;
                TAILQ_INSERT_BEFORE(entry, sch, link);
   1053c:	69ab      	ldr	r3, [r5, #24]
   1053e:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
   10542:	4623      	mov	r3, r4
   10544:	69aa      	ldr	r2, [r5, #24]
   10546:	f843 5ff4 	str.w	r5, [r3, #244]!
   1054a:	f8c2 9000 	str.w	r9, [r2]
   1054e:	61ab      	str	r3, [r5, #24]
   10550:	e00b      	b.n	1056a <ble_ll_sched_conn_reschedule+0xba>
    cputime_timer_stop(&g_ble_ll_sched_timer);

    start_overlap = NULL;
    end_overlap = NULL;
    rc = 0;
    TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   10552:	696d      	ldr	r5, [r5, #20]
   10554:	e7d8      	b.n	10508 <ble_ll_sched_conn_reschedule+0x58>
        }
    }

    if (!rc) {
        if (!entry) {
            TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
   10556:	687b      	ldr	r3, [r7, #4]
   10558:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
   1055c:	f8c4 50f4 	str.w	r5, [r4, #244]	; 0xf4
   10560:	f8c3 9000 	str.w	r9, [r3]
   10564:	f104 03f4 	add.w	r3, r4, #244	; 0xf4
   10568:	607b      	str	r3, [r7, #4]
        }
        sch->enqueued = 1;
   1056a:	2301      	movs	r3, #1
   1056c:	f884 30e1 	strb.w	r3, [r4, #225]	; 0xe1
   10570:	2400      	movs	r4, #0
   10572:	e013      	b.n	1059c <ble_ll_sched_conn_reschedule+0xec>

    /* Remove first to last scheduled elements */
    entry = start_overlap;
    while (entry) {
        start_overlap = TAILQ_NEXT(entry,link);
        if (entry->sched_type == BLE_LL_SCHED_TYPE_CONN) {
   10574:	7833      	ldrb	r3, [r6, #0]
    }

    /* Remove first to last scheduled elements */
    entry = start_overlap;
    while (entry) {
        start_overlap = TAILQ_NEXT(entry,link);
   10576:	6975      	ldr	r5, [r6, #20]
        if (entry->sched_type == BLE_LL_SCHED_TYPE_CONN) {
   10578:	2b03      	cmp	r3, #3
   1057a:	d103      	bne.n	10584 <ble_ll_sched_conn_reschedule+0xd4>
            tmp = (struct ble_ll_conn_sm *)entry->cb_arg;
            ble_ll_event_send(&tmp->conn_ev_end);
   1057c:	68f0      	ldr	r0, [r6, #12]
   1057e:	30a4      	adds	r0, #164	; 0xa4
   10580:	f7fa fdbc 	bl	b0fc <ble_ll_event_send>
        }

        TAILQ_REMOVE(&g_ble_ll_sched_q, entry, link);
   10584:	6973      	ldr	r3, [r6, #20]
   10586:	69b2      	ldr	r2, [r6, #24]
   10588:	b15b      	cbz	r3, 105a2 <ble_ll_sched_conn_reschedule+0xf2>
   1058a:	619a      	str	r2, [r3, #24]
   1058c:	69b2      	ldr	r2, [r6, #24]
        entry->enqueued = 0;

        if (entry == end_overlap) {
   1058e:	4546      	cmp	r6, r8
        if (entry->sched_type == BLE_LL_SCHED_TYPE_CONN) {
            tmp = (struct ble_ll_conn_sm *)entry->cb_arg;
            ble_ll_event_send(&tmp->conn_ev_end);
        }

        TAILQ_REMOVE(&g_ble_ll_sched_q, entry, link);
   10590:	6013      	str	r3, [r2, #0]
        entry->enqueued = 0;
   10592:	f04f 0300 	mov.w	r3, #0
   10596:	7073      	strb	r3, [r6, #1]

        if (entry == end_overlap) {
   10598:	d005      	beq.n	105a6 <ble_ll_sched_conn_reschedule+0xf6>
            break;
        }
        entry = start_overlap;
   1059a:	462e      	mov	r6, r5
        sch->enqueued = 1;
    }

    /* Remove first to last scheduled elements */
    entry = start_overlap;
    while (entry) {
   1059c:	2e00      	cmp	r6, #0
   1059e:	d1e9      	bne.n	10574 <ble_ll_sched_conn_reschedule+0xc4>
   105a0:	e001      	b.n	105a6 <ble_ll_sched_conn_reschedule+0xf6>
        if (entry->sched_type == BLE_LL_SCHED_TYPE_CONN) {
            tmp = (struct ble_ll_conn_sm *)entry->cb_arg;
            ble_ll_event_send(&tmp->conn_ev_end);
        }

        TAILQ_REMOVE(&g_ble_ll_sched_q, entry, link);
   105a2:	607a      	str	r2, [r7, #4]
   105a4:	e7f2      	b.n	1058c <ble_ll_sched_conn_reschedule+0xdc>
        }
        entry = start_overlap;
    }

    /* Get first on list */
    sch = TAILQ_FIRST(&g_ble_ll_sched_q);
   105a6:	683d      	ldr	r5, [r7, #0]

    OS_EXIT_CRITICAL(sr);
   105a8:	4650      	mov	r0, sl
   105aa:	f7f9 f9bf 	bl	992c <os_arch_restore_sr>

    /* Restart timer */
    cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);
   105ae:	4808      	ldr	r0, [pc, #32]	; (105d0 <ble_ll_sched_conn_reschedule+0x120>)
   105b0:	6869      	ldr	r1, [r5, #4]
   105b2:	f7f8 fba5 	bl	8d00 <cputime_timer_start>

    return rc;
   105b6:	4620      	mov	r0, r4
   105b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sch->start_time = connsm->anchor_point - cputime_usecs_to_ticks(usecs);
    sch->end_time = connsm->ce_end_time;

    /* Better be past current time or we just leave */
    if ((int32_t)(sch->start_time - cputime_get32()) < 0) {
        return -1;
   105bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   105c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    if (!rc) {
        if (!entry) {
            TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
        }
        sch->enqueued = 1;
   105c4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   105c8:	2600      	movs	r6, #0
   105ca:	e7e7      	b.n	1059c <ble_ll_sched_conn_reschedule+0xec>
   105cc:	200037a4 	.word	0x200037a4
   105d0:	20003790 	.word	0x20003790

000105d4 <ble_ll_sched_master_new>:
}

int
ble_ll_sched_master_new(struct ble_ll_conn_sm *connsm, uint32_t adv_rxend,
                        uint8_t req_slots)
{
   105d4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   105d8:	460c      	mov	r4, r1
    uint32_t ce_end_time;
    struct ble_ll_sched_item *entry;
    struct ble_ll_sched_item *sch;

    /* Better have a connsm */
    assert(connsm != NULL);
   105da:	4605      	mov	r5, r0
   105dc:	b930      	cbnz	r0, 105ec <ble_ll_sched_master_new+0x18>
   105de:	4851      	ldr	r0, [pc, #324]	; (10724 <ble_ll_sched_master_new+0x150>)
   105e0:	f44f 7180 	mov.w	r1, #256	; 0x100
   105e4:	462a      	mov	r2, r5
   105e6:	462b      	mov	r3, r5
   105e8:	f7f9 fb72 	bl	9cd0 <__assert_func>
     * The earliest start time is 1.25 msecs from the end of the connect
     * request transmission. Note that adv_rxend is the end of the received
     * advertisement, so we need to add an IFS plus the time it takes to send
     * the connection request
     */
    dur = cputime_usecs_to_ticks(req_slots * BLE_LL_SCHED_USECS_PER_SLOT);
   105ec:	f240 47e2 	movw	r7, #1250	; 0x4e2
    /* Better have a connsm */
    assert(connsm != NULL);

    /* Get schedule element from connection */
    rc = -1;
    sch = &connsm->conn_sch;
   105f0:	f100 08e0 	add.w	r8, r0, #224	; 0xe0
     * The earliest start time is 1.25 msecs from the end of the connect
     * request transmission. Note that adv_rxend is the end of the received
     * advertisement, so we need to add an IFS plus the time it takes to send
     * the connection request
     */
    dur = cputime_usecs_to_ticks(req_slots * BLE_LL_SCHED_USECS_PER_SLOT);
   105f4:	fb07 f002 	mul.w	r0, r7, r2
   105f8:	f7f8 fb5c 	bl	8cb4 <cputime_usecs_to_ticks>
   105fc:	4681      	mov	r9, r0
    earliest_start = adv_rxend +
        cputime_usecs_to_ticks(BLE_LL_IFS + BLE_LL_CONN_REQ_DURATION +
   105fe:	f44f 60db 	mov.w	r0, #1752	; 0x6d8
   10602:	f7f8 fb57 	bl	8cb4 <cputime_usecs_to_ticks>
     * request transmission. Note that adv_rxend is the end of the received
     * advertisement, so we need to add an IFS plus the time it takes to send
     * the connection request
     */
    dur = cputime_usecs_to_ticks(req_slots * BLE_LL_SCHED_USECS_PER_SLOT);
    earliest_start = adv_rxend +
   10606:	4404      	add	r4, r0
        cputime_usecs_to_ticks(BLE_LL_IFS + BLE_LL_CONN_REQ_DURATION +
                               BLE_LL_CONN_INITIAL_OFFSET);
    earliest_end = earliest_start + dur;

    itvl_t = cputime_usecs_to_ticks(connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS);
   10608:	f8b5 0060 	ldrh.w	r0, [r5, #96]	; 0x60
   1060c:	4378      	muls	r0, r7
   1060e:	f7f8 fb51 	bl	8cb4 <cputime_usecs_to_ticks>
   10612:	4683      	mov	fp, r0

    /* We have to find a place for this schedule */
    OS_ENTER_CRITICAL(sr);
   10614:	f7f9 f984 	bl	9920 <os_arch_save_sr>

    /* The schedule item must occur after current running item (if any) */
    sch->start_time = earliest_start;
   10618:	f8c5 40e4 	str.w	r4, [r5, #228]	; 0xe4
    earliest_end = earliest_start + dur;

    itvl_t = cputime_usecs_to_ticks(connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS);

    /* We have to find a place for this schedule */
    OS_ENTER_CRITICAL(sr);
   1061c:	9000      	str	r0, [sp, #0]

    /*
     * If we are currently in a connection, we add one slot time to the
     * earliest start so we can end the connection reasonably.
     */
    if (ble_ll_state_get() == BLE_LL_STATE_CONNECTION) {
   1061e:	f7fa fd67 	bl	b0f0 <ble_ll_state_get>
   10622:	2804      	cmp	r0, #4
     */
    dur = cputime_usecs_to_ticks(req_slots * BLE_LL_SCHED_USECS_PER_SLOT);
    earliest_start = adv_rxend +
        cputime_usecs_to_ticks(BLE_LL_IFS + BLE_LL_CONN_REQ_DURATION +
                               BLE_LL_CONN_INITIAL_OFFSET);
    earliest_end = earliest_start + dur;
   10624:	eb04 0609 	add.w	r6, r4, r9

    /*
     * If we are currently in a connection, we add one slot time to the
     * earliest start so we can end the connection reasonably.
     */
    if (ble_ll_state_get() == BLE_LL_STATE_CONNECTION) {
   10628:	d114      	bne.n	10654 <ble_ll_sched_master_new+0x80>
        tps = cputime_usecs_to_ticks(BLE_LL_SCHED_USECS_PER_SLOT);
   1062a:	4638      	mov	r0, r7
   1062c:	f7f8 fb42 	bl	8cb4 <cputime_usecs_to_ticks>
   10630:	4607      	mov	r7, r0
        ce_end_time = ble_ll_conn_get_ce_end_time();
   10632:	f7fb fd97 	bl	c164 <ble_ll_conn_get_ce_end_time>
   10636:	4606      	mov	r6, r0
        while ((int32_t)(ce_end_time - cputime_get32()) < 0) {
   10638:	f7f8 fc80 	bl	8f3c <cputime_get32>
   1063c:	1a30      	subs	r0, r6, r0
   1063e:	2800      	cmp	r0, #0
   10640:	da01      	bge.n	10646 <ble_ll_sched_master_new+0x72>
            ce_end_time += tps;
   10642:	443e      	add	r6, r7
   10644:	e7f8      	b.n	10638 <ble_ll_sched_master_new+0x64>
   10646:	1b33      	subs	r3, r6, r4
        }

        /* Start at next slot boundary past earliest */
        while ((int32_t)(ce_end_time - earliest_start) < 0) {
   10648:	2b00      	cmp	r3, #0
   1064a:	da01      	bge.n	10650 <ble_ll_sched_master_new+0x7c>
            ce_end_time += tps;
   1064c:	443e      	add	r6, r7
   1064e:	e7fa      	b.n	10646 <ble_ll_sched_master_new+0x72>
   10650:	4634      	mov	r4, r6
        }
        earliest_start = ce_end_time;
        earliest_end = earliest_start + dur;
   10652:	444e      	add	r6, r9
    }
    initial_start = earliest_start;

    if (!ble_ll_sched_insert_if_empty(sch)) {
   10654:	4640      	mov	r0, r8
   10656:	f7ff ff1b 	bl	10490 <ble_ll_sched_insert_if_empty>
   1065a:	4f33      	ldr	r7, [pc, #204]	; (10728 <ble_ll_sched_master_new+0x154>)
   1065c:	b910      	cbnz	r0, 10664 <ble_ll_sched_master_new+0x90>
        /* Nothing in schedule. Schedule as soon as possible */
        rc = 0;
        connsm->tx_win_off = 0;
   1065e:	f8a5 006a 	strh.w	r0, [r5, #106]	; 0x6a
   10662:	e045      	b.n	106f0 <ble_ll_sched_master_new+0x11c>
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
   10664:	4831      	ldr	r0, [pc, #196]	; (1072c <ble_ll_sched_master_new+0x158>)
   10666:	f7f8 fbab 	bl	8dc0 <cputime_timer_stop>
        TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   1066a:	683b      	ldr	r3, [r7, #0]
   1066c:	46a2      	mov	sl, r4
   1066e:	b31b      	cbz	r3, 106b8 <ble_ll_sched_master_new+0xe4>
            /* Set these because overlap function needs them to be set */
            sch->start_time = earliest_start;
   10670:	f8c5 a0e4 	str.w	sl, [r5, #228]	; 0xe4
            sch->end_time = earliest_end;

            /* We can insert if before entry in list */
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   10674:	6859      	ldr	r1, [r3, #4]
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
        TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
            /* Set these because overlap function needs them to be set */
            sch->start_time = earliest_start;
            sch->end_time = earliest_end;
   10676:	f8c5 60e8 	str.w	r6, [r5, #232]	; 0xe8

            /* We can insert if before entry in list */
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   1067a:	1a71      	subs	r1, r6, r1
   1067c:	2900      	cmp	r1, #0
   1067e:	da0e      	bge.n	1069e <ble_ll_sched_master_new+0xca>
                if ((earliest_start - initial_start) <= itvl_t) {
   10680:	ebc4 010a 	rsb	r1, r4, sl
   10684:	4559      	cmp	r1, fp
   10686:	d83f      	bhi.n	10708 <ble_ll_sched_master_new+0x134>
                    rc = 0;
                    TAILQ_INSERT_BEFORE(entry, sch, link);
   10688:	6999      	ldr	r1, [r3, #24]
   1068a:	f8c5 10f8 	str.w	r1, [r5, #248]	; 0xf8
   1068e:	4629      	mov	r1, r5
   10690:	6998      	ldr	r0, [r3, #24]
   10692:	f841 3ff4 	str.w	r3, [r1, #244]!
   10696:	f8c0 8000 	str.w	r8, [r0]
   1069a:	6199      	str	r1, [r3, #24]
   1069c:	e01a      	b.n	106d4 <ble_ll_sched_master_new+0x100>
                }
                break;
            }

            /* Check for overlapping events */
            if (ble_ll_sched_is_overlap(sch, entry)) {
   1069e:	4619      	mov	r1, r3
   106a0:	4640      	mov	r0, r8
   106a2:	9301      	str	r3, [sp, #4]
   106a4:	f7ff fe68 	bl	10378 <ble_ll_sched_is_overlap>
   106a8:	9b01      	ldr	r3, [sp, #4]
   106aa:	b118      	cbz	r0, 106b4 <ble_ll_sched_master_new+0xe0>
                /* Earliest start is end of this event since we overlap */
                earliest_start = entry->end_time;
   106ac:	f8d3 a008 	ldr.w	sl, [r3, #8]
                earliest_end = earliest_start + dur;
   106b0:	eb09 060a 	add.w	r6, r9, sl
        /* Nothing in schedule. Schedule as soon as possible */
        rc = 0;
        connsm->tx_win_off = 0;
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
        TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   106b4:	695b      	ldr	r3, [r3, #20]
   106b6:	e7da      	b.n	1066e <ble_ll_sched_master_new+0x9a>
                earliest_end = earliest_start + dur;
            }
        }

        if (!entry) {
            if ((earliest_start - initial_start) <= itvl_t) {
   106b8:	ebc4 010a 	rsb	r1, r4, sl
   106bc:	4559      	cmp	r1, fp
   106be:	d823      	bhi.n	10708 <ble_ll_sched_master_new+0x134>
                rc = 0;
                TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
   106c0:	f8c5 30f4 	str.w	r3, [r5, #244]	; 0xf4
   106c4:	687b      	ldr	r3, [r7, #4]
   106c6:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8
   106ca:	f8c3 8000 	str.w	r8, [r3]
   106ce:	f105 03f4 	add.w	r3, r5, #244	; 0xf4
   106d2:	607b      	str	r3, [r7, #4]
            }
        }

        if (!rc) {
            /* calculate number of connection intervals before start */
            sch->enqueued = 1;
   106d4:	2301      	movs	r3, #1
   106d6:	f885 30e1 	strb.w	r3, [r5, #225]	; 0xe1
            connsm->tx_win_off = (earliest_start - initial_start) /
                cputime_usecs_to_ticks(BLE_LL_CONN_ITVL_USECS);
   106da:	f240 40e2 	movw	r0, #1250	; 0x4e2
   106de:	f7f8 fae9 	bl	8cb4 <cputime_usecs_to_ticks>
        }

        if (!rc) {
            /* calculate number of connection intervals before start */
            sch->enqueued = 1;
            connsm->tx_win_off = (earliest_start - initial_start) /
   106e2:	ebc4 040a 	rsb	r4, r4, sl
   106e6:	fbb4 f0f0 	udiv	r0, r4, r0
   106ea:	4654      	mov	r4, sl
   106ec:	f8a5 006a 	strh.w	r0, [r5, #106]	; 0x6a
                cputime_usecs_to_ticks(BLE_LL_CONN_ITVL_USECS);
        }
    }

    if (!rc) {
        sch->start_time = earliest_start;
   106f0:	f8c5 40e4 	str.w	r4, [r5, #228]	; 0xe4
        sch->end_time = earliest_end;
   106f4:	f8c5 60e8 	str.w	r6, [r5, #232]	; 0xe8
        connsm->anchor_point = earliest_start +
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
   106f8:	20be      	movs	r0, #190	; 0xbe
   106fa:	f7f8 fadb 	bl	8cb4 <cputime_usecs_to_ticks>
    }

    if (!rc) {
        sch->start_time = earliest_start;
        sch->end_time = earliest_end;
        connsm->anchor_point = earliest_start +
   106fe:	4420      	add	r0, r4
   10700:	66e8      	str	r0, [r5, #108]	; 0x6c
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
        connsm->ce_end_time = earliest_end;
   10702:	652e      	str	r6, [r5, #80]	; 0x50
   10704:	2400      	movs	r4, #0
   10706:	e001      	b.n	1070c <ble_ll_sched_master_new+0x138>
        }

        if (!entry) {
            if ((earliest_start - initial_start) <= itvl_t) {
                rc = 0;
                TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
   10708:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
            cputime_usecs_to_ticks(XCVR_TX_SCHED_DELAY_USECS);
        connsm->ce_end_time = earliest_end;
    }

    /* Get head of list to restart timer */
    sch = TAILQ_FIRST(&g_ble_ll_sched_q);
   1070c:	683d      	ldr	r5, [r7, #0]

    OS_EXIT_CRITICAL(sr);
   1070e:	9800      	ldr	r0, [sp, #0]
   10710:	f7f9 f90c 	bl	992c <os_arch_restore_sr>

    cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);
   10714:	4805      	ldr	r0, [pc, #20]	; (1072c <ble_ll_sched_master_new+0x158>)
   10716:	6869      	ldr	r1, [r5, #4]
   10718:	f7f8 faf2 	bl	8d00 <cputime_timer_start>

    return rc;
}
   1071c:	4620      	mov	r0, r4
   1071e:	b003      	add	sp, #12
   10720:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10724:	0001f2f1 	.word	0x0001f2f1
   10728:	200037a4 	.word	0x200037a4
   1072c:	20003790 	.word	0x20003790

00010730 <ble_ll_sched_slave_new>:

int
ble_ll_sched_slave_new(struct ble_ll_conn_sm *connsm)
{
   10730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10734:	4605      	mov	r5, r0
    /* Get schedule element from connection */
    rc = -1;
    sch = &connsm->conn_sch;

    /* Set schedule start and end times */
    sch->start_time = connsm->anchor_point -
   10736:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    struct ble_ll_sched_item *next_sch;
    struct ble_ll_sched_item *sch;

    /* Get schedule element from connection */
    rc = -1;
    sch = &connsm->conn_sch;
   10738:	f100 06e0 	add.w	r6, r0, #224	; 0xe0

    /* Set schedule start and end times */
    sch->start_time = connsm->anchor_point -
        cputime_usecs_to_ticks(XCVR_RX_SCHED_DELAY_USECS +
   1073c:	6f80      	ldr	r0, [r0, #120]	; 0x78
   1073e:	30be      	adds	r0, #190	; 0xbe
   10740:	f7f8 fab8 	bl	8cb4 <cputime_usecs_to_ticks>
                               connsm->slave_cur_window_widening);
    sch->end_time = connsm->ce_end_time;
   10744:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   10746:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
    /* Get schedule element from connection */
    rc = -1;
    sch = &connsm->conn_sch;

    /* Set schedule start and end times */
    sch->start_time = connsm->anchor_point -
   1074a:	1a20      	subs	r0, r4, r0
   1074c:	f8c5 00e4 	str.w	r0, [r5, #228]	; 0xe4
        cputime_usecs_to_ticks(XCVR_RX_SCHED_DELAY_USECS +
                               connsm->slave_cur_window_widening);
    sch->end_time = connsm->ce_end_time;

    /* We have to find a place for this schedule */
    OS_ENTER_CRITICAL(sr);
   10750:	f7f9 f8e6 	bl	9920 <os_arch_save_sr>
   10754:	4680      	mov	r8, r0

    /* The schedule item must occur after current running item (if any) */
    if (ble_ll_sched_overlaps_current(sch)) {
   10756:	4630      	mov	r0, r6
   10758:	f7ff fe88 	bl	1046c <ble_ll_sched_overlaps_current>
   1075c:	b128      	cbz	r0, 1076a <ble_ll_sched_slave_new+0x3a>
        OS_EXIT_CRITICAL(sr);
   1075e:	4640      	mov	r0, r8
   10760:	f7f9 f8e4 	bl	992c <os_arch_restore_sr>
        return rc;
   10764:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   10768:	e042      	b.n	107f0 <ble_ll_sched_slave_new+0xc0>
    }

    entry = ble_ll_sched_insert_if_empty(sch);
   1076a:	4630      	mov	r0, r6
   1076c:	f7ff fe90 	bl	10490 <ble_ll_sched_insert_if_empty>
    if (!entry) {
   10770:	4604      	mov	r4, r0
   10772:	2800      	cmp	r0, #0
   10774:	d02f      	beq.n	107d6 <ble_ll_sched_slave_new+0xa6>
        /* Nothing in schedule. Schedule as soon as possible */
        rc = 0;
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
   10776:	4820      	ldr	r0, [pc, #128]	; (107f8 <ble_ll_sched_slave_new+0xc8>)
   10778:	f7f8 fb22 	bl	8dc0 <cputime_timer_stop>
        while (1) {
            next_sch = entry->link.tqe_next;
            /* Insert if event ends before next starts */
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   1077c:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
   10780:	6862      	ldr	r2, [r4, #4]
        /* Nothing in schedule. Schedule as soon as possible */
        rc = 0;
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
        while (1) {
            next_sch = entry->link.tqe_next;
   10782:	6967      	ldr	r7, [r4, #20]
            /* Insert if event ends before next starts */
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   10784:	1a9b      	subs	r3, r3, r2
   10786:	2b00      	cmp	r3, #0
   10788:	da09      	bge.n	1079e <ble_ll_sched_slave_new+0x6e>
                rc = 0;
                TAILQ_INSERT_BEFORE(entry, sch, link);
   1078a:	69a3      	ldr	r3, [r4, #24]
   1078c:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8
   10790:	462b      	mov	r3, r5
   10792:	69a2      	ldr	r2, [r4, #24]
   10794:	f843 4ff4 	str.w	r4, [r3, #244]!
   10798:	6016      	str	r6, [r2, #0]
   1079a:	61a3      	str	r3, [r4, #24]
                break;
   1079c:	e023      	b.n	107e6 <ble_ll_sched_slave_new+0xb6>
            }

            if (ble_ll_sched_is_overlap(sch, entry)) {
   1079e:	4630      	mov	r0, r6
   107a0:	4621      	mov	r1, r4
   107a2:	f7ff fde9 	bl	10378 <ble_ll_sched_is_overlap>
   107a6:	b968      	cbnz	r0, 107c4 <ble_ll_sched_slave_new+0x94>
   107a8:	463c      	mov	r4, r7

            /* Move to next entry */
            entry = next_sch;

            /* Insert at tail if none left to check */
            if (!entry) {
   107aa:	2f00      	cmp	r7, #0
   107ac:	d1e6      	bne.n	1077c <ble_ll_sched_slave_new+0x4c>
                rc = 0;
                TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
   107ae:	4b13      	ldr	r3, [pc, #76]	; (107fc <ble_ll_sched_slave_new+0xcc>)
   107b0:	f8c5 70f4 	str.w	r7, [r5, #244]	; 0xf4
   107b4:	685a      	ldr	r2, [r3, #4]
   107b6:	f8c5 20f8 	str.w	r2, [r5, #248]	; 0xf8
   107ba:	6016      	str	r6, [r2, #0]
   107bc:	f105 02f4 	add.w	r2, r5, #244	; 0xf4
   107c0:	605a      	str	r2, [r3, #4]
                break;
   107c2:	e010      	b.n	107e6 <ble_ll_sched_slave_new+0xb6>
                break;
            }

            if (ble_ll_sched_is_overlap(sch, entry)) {
                /* If we overlap with a connection, we re-schedule */
                if (ble_ll_sched_conn_overlap(entry)) {
   107c4:	4620      	mov	r0, r4
   107c6:	f7ff fde9 	bl	1039c <ble_ll_sched_conn_overlap>
   107ca:	2800      	cmp	r0, #0
   107cc:	d0ec      	beq.n	107a8 <ble_ll_sched_slave_new+0x78>
    struct ble_ll_sched_item *entry;
    struct ble_ll_sched_item *next_sch;
    struct ble_ll_sched_item *sch;

    /* Get schedule element from connection */
    rc = -1;
   107ce:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        }

        if (!rc) {
            sch->enqueued = 1;
        }
        sch = TAILQ_FIRST(&g_ble_ll_sched_q);
   107d2:	4b0a      	ldr	r3, [pc, #40]	; (107fc <ble_ll_sched_slave_new+0xcc>)
   107d4:	681e      	ldr	r6, [r3, #0]
    }

    OS_EXIT_CRITICAL(sr);
   107d6:	4640      	mov	r0, r8
   107d8:	f7f9 f8a8 	bl	992c <os_arch_restore_sr>

    cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);
   107dc:	4806      	ldr	r0, [pc, #24]	; (107f8 <ble_ll_sched_slave_new+0xc8>)
   107de:	6871      	ldr	r1, [r6, #4]
   107e0:	f7f8 fa8e 	bl	8d00 <cputime_timer_start>

    return rc;
   107e4:	e004      	b.n	107f0 <ble_ll_sched_slave_new+0xc0>
                break;
            }
        }

        if (!rc) {
            sch->enqueued = 1;
   107e6:	2301      	movs	r3, #1
   107e8:	f885 30e1 	strb.w	r3, [r5, #225]	; 0xe1
   107ec:	2400      	movs	r4, #0
   107ee:	e7f0      	b.n	107d2 <ble_ll_sched_slave_new+0xa2>
    OS_EXIT_CRITICAL(sr);

    cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);

    return rc;
}
   107f0:	4620      	mov	r0, r4
   107f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   107f6:	bf00      	nop
   107f8:	20003790 	.word	0x20003790
   107fc:	200037a4 	.word	0x200037a4

00010800 <ble_ll_sched_adv_new>:

int
ble_ll_sched_adv_new(struct ble_ll_sched_item *sch)
{
   10800:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t adv_start;
    uint32_t duration;
    struct ble_ll_sched_item *entry;

    /* Get length of schedule item */
    duration = sch->end_time - sch->start_time;
   10804:	6843      	ldr	r3, [r0, #4]
   10806:	6887      	ldr	r7, [r0, #8]
    return rc;
}

int
ble_ll_sched_adv_new(struct ble_ll_sched_item *sch)
{
   10808:	4604      	mov	r4, r0
    uint32_t adv_start;
    uint32_t duration;
    struct ble_ll_sched_item *entry;

    /* Get length of schedule item */
    duration = sch->end_time - sch->start_time;
   1080a:	1aff      	subs	r7, r7, r3

    OS_ENTER_CRITICAL(sr);
   1080c:	f7f9 f888 	bl	9920 <os_arch_save_sr>
   10810:	4680      	mov	r8, r0

    /*
     * If we are currently in a connection, we add one slot time to the
     * earliest start so we can end the connection reasonably.
     */
    if (ble_ll_state_get() == BLE_LL_STATE_CONNECTION) {
   10812:	f7fa fc6d 	bl	b0f0 <ble_ll_state_get>
   10816:	2804      	cmp	r0, #4
   10818:	d10e      	bne.n	10838 <ble_ll_sched_adv_new+0x38>
        ticks = (int32_t)cputime_usecs_to_ticks(BLE_LL_SCHED_MAX_TXRX_SLOT);
   1081a:	f241 3088 	movw	r0, #5000	; 0x1388
   1081e:	f7f8 fa49 	bl	8cb4 <cputime_usecs_to_ticks>
   10822:	4605      	mov	r5, r0
        ce_end_time = ble_ll_conn_get_ce_end_time();
   10824:	f7fb fc9e 	bl	c164 <ble_ll_conn_get_ce_end_time>
        if ((int32_t)(ce_end_time - sch->start_time) < ticks) {
   10828:	6863      	ldr	r3, [r4, #4]
   1082a:	1ac3      	subs	r3, r0, r3
   1082c:	42ab      	cmp	r3, r5
            ce_end_time += ticks;
   1082e:	bfb8      	it	lt
   10830:	1940      	addlt	r0, r0, r5
        }
        sch->start_time = ce_end_time;
   10832:	6060      	str	r0, [r4, #4]
        sch->end_time = ce_end_time + duration;
   10834:	4438      	add	r0, r7
   10836:	60a0      	str	r0, [r4, #8]
    }

    entry = ble_ll_sched_insert_if_empty(sch);
   10838:	4620      	mov	r0, r4
   1083a:	f7ff fe29 	bl	10490 <ble_ll_sched_insert_if_empty>
    if (!entry) {
   1083e:	b908      	cbnz	r0, 10844 <ble_ll_sched_adv_new+0x44>
        rc = 0;
        adv_start = sch->start_time;
   10840:	6860      	ldr	r0, [r4, #4]
   10842:	e029      	b.n	10898 <ble_ll_sched_adv_new+0x98>
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
        TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   10844:	4e1a      	ldr	r6, [pc, #104]	; (108b0 <ble_ll_sched_adv_new+0xb0>)
    entry = ble_ll_sched_insert_if_empty(sch);
    if (!entry) {
        rc = 0;
        adv_start = sch->start_time;
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
   10846:	481b      	ldr	r0, [pc, #108]	; (108b4 <ble_ll_sched_adv_new+0xb4>)
   10848:	f7f8 faba 	bl	8dc0 <cputime_timer_stop>
        TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   1084c:	6835      	ldr	r5, [r6, #0]
   1084e:	b1c5      	cbz	r5, 10882 <ble_ll_sched_adv_new+0x82>
            /* We can insert if before entry in list */
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   10850:	68a3      	ldr	r3, [r4, #8]
   10852:	686a      	ldr	r2, [r5, #4]
   10854:	1a9b      	subs	r3, r3, r2
   10856:	2b00      	cmp	r3, #0
   10858:	da08      	bge.n	1086c <ble_ll_sched_adv_new+0x6c>
                rc = 0;
                TAILQ_INSERT_BEFORE(entry, sch, link);
   1085a:	69ab      	ldr	r3, [r5, #24]
   1085c:	61a3      	str	r3, [r4, #24]
   1085e:	69ab      	ldr	r3, [r5, #24]
   10860:	6165      	str	r5, [r4, #20]
   10862:	601c      	str	r4, [r3, #0]
   10864:	f104 0314 	add.w	r3, r4, #20
   10868:	61ab      	str	r3, [r5, #24]
   1086a:	e011      	b.n	10890 <ble_ll_sched_adv_new+0x90>
                break;
            }

            /* Check for overlapping events */
            if (ble_ll_sched_is_overlap(sch, entry)) {
   1086c:	4620      	mov	r0, r4
   1086e:	4629      	mov	r1, r5
   10870:	f7ff fd82 	bl	10378 <ble_ll_sched_is_overlap>
   10874:	b118      	cbz	r0, 1087e <ble_ll_sched_adv_new+0x7e>
                /* Earliest start is end of this event since we overlap */
                sch->start_time = entry->end_time;
   10876:	68ab      	ldr	r3, [r5, #8]
   10878:	6063      	str	r3, [r4, #4]
                sch->end_time = sch->start_time + duration;
   1087a:	443b      	add	r3, r7
   1087c:	60a3      	str	r3, [r4, #8]
    if (!entry) {
        rc = 0;
        adv_start = sch->start_time;
    } else {
        cputime_timer_stop(&g_ble_ll_sched_timer);
        TAILQ_FOREACH(entry, &g_ble_ll_sched_q, link) {
   1087e:	696d      	ldr	r5, [r5, #20]
   10880:	e7e5      	b.n	1084e <ble_ll_sched_adv_new+0x4e>
            }
        }

        if (!entry) {
            rc = 0;
            TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
   10882:	6873      	ldr	r3, [r6, #4]
   10884:	61a3      	str	r3, [r4, #24]
   10886:	6165      	str	r5, [r4, #20]
   10888:	601c      	str	r4, [r3, #0]
   1088a:	f104 0314 	add.w	r3, r4, #20
   1088e:	6073      	str	r3, [r6, #4]
        }
        adv_start = sch->start_time;

        if (!rc) {
            sch->enqueued = 1;
   10890:	2301      	movs	r3, #1
   10892:	7063      	strb	r3, [r4, #1]

        if (!entry) {
            rc = 0;
            TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
        }
        adv_start = sch->start_time;
   10894:	6860      	ldr	r0, [r4, #4]
        if (!rc) {
            sch->enqueued = 1;
        }

        /* Restart with head of list */
        sch = TAILQ_FIRST(&g_ble_ll_sched_q);
   10896:	6834      	ldr	r4, [r6, #0]
    }

    ble_ll_adv_scheduled(adv_start);
   10898:	f7fa fe9e 	bl	b5d8 <ble_ll_adv_scheduled>

    OS_EXIT_CRITICAL(sr);
   1089c:	4640      	mov	r0, r8
   1089e:	f7f9 f845 	bl	992c <os_arch_restore_sr>
       output compare that we actually get the interrupt. */
    /* XXX: I am not sure that if we receive a packet while scanning
     * that we actually go back to scanning. I need to make sure
       we re-enable the receive. Put an event in the log! */

    cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);
   108a2:	4804      	ldr	r0, [pc, #16]	; (108b4 <ble_ll_sched_adv_new+0xb4>)
   108a4:	6861      	ldr	r1, [r4, #4]
   108a6:	f7f8 fa2b 	bl	8d00 <cputime_timer_start>

    return rc;
}
   108aa:	2000      	movs	r0, #0
   108ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   108b0:	200037a4 	.word	0x200037a4
   108b4:	20003790 	.word	0x20003790

000108b8 <ble_ll_sched_adv_reschedule>:

int
ble_ll_sched_adv_reschedule(struct ble_ll_sched_item *sch)
{
   108b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   108bc:	4604      	mov	r4, r0
    os_sr_t sr;
    struct ble_ll_sched_item *entry;
    struct ble_ll_sched_item *next_sch;

    rc = 0;
    OS_ENTER_CRITICAL(sr);
   108be:	f7f9 f82f 	bl	9920 <os_arch_save_sr>
   108c2:	4680      	mov	r8, r0

    /* The schedule item must occur after current running item (if any) */
    if (ble_ll_sched_overlaps_current(sch)) {
   108c4:	4620      	mov	r0, r4
   108c6:	f7ff fdd1 	bl	1046c <ble_ll_sched_overlaps_current>
   108ca:	4606      	mov	r6, r0
   108cc:	b128      	cbz	r0, 108da <ble_ll_sched_adv_reschedule+0x22>
        OS_EXIT_CRITICAL(sr);
   108ce:	4640      	mov	r0, r8
   108d0:	f7f9 f82c 	bl	992c <os_arch_restore_sr>
        return -1;
   108d4:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   108d8:	e03d      	b.n	10956 <ble_ll_sched_adv_reschedule+0x9e>
    }

    entry = ble_ll_sched_insert_if_empty(sch);
   108da:	4620      	mov	r0, r4
   108dc:	f7ff fdd8 	bl	10490 <ble_ll_sched_insert_if_empty>
    if (entry) {
   108e0:	4605      	mov	r5, r0
   108e2:	2800      	cmp	r0, #0
   108e4:	d030      	beq.n	10948 <ble_ll_sched_adv_reschedule+0x90>
        cputime_timer_stop(&g_ble_ll_sched_timer);
   108e6:	481d      	ldr	r0, [pc, #116]	; (1095c <ble_ll_sched_adv_reschedule+0xa4>)
   108e8:	f7f8 fa6a 	bl	8dc0 <cputime_timer_stop>
        while (1) {
            /* Insert before if adv event is before this event */
            next_sch = entry->link.tqe_next;
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   108ec:	68a3      	ldr	r3, [r4, #8]
   108ee:	686a      	ldr	r2, [r5, #4]
    entry = ble_ll_sched_insert_if_empty(sch);
    if (entry) {
        cputime_timer_stop(&g_ble_ll_sched_timer);
        while (1) {
            /* Insert before if adv event is before this event */
            next_sch = entry->link.tqe_next;
   108f0:	696f      	ldr	r7, [r5, #20]
            if ((int32_t)(sch->end_time - entry->start_time) < 0) {
   108f2:	1a9b      	subs	r3, r3, r2
   108f4:	2b00      	cmp	r3, #0
   108f6:	da08      	bge.n	1090a <ble_ll_sched_adv_reschedule+0x52>
                rc = 0;
                TAILQ_INSERT_BEFORE(entry, sch, link);
   108f8:	69ab      	ldr	r3, [r5, #24]
   108fa:	61a3      	str	r3, [r4, #24]
   108fc:	69ab      	ldr	r3, [r5, #24]
   108fe:	6165      	str	r5, [r4, #20]
   10900:	601c      	str	r4, [r3, #0]
   10902:	f104 0314 	add.w	r3, r4, #20
   10906:	61ab      	str	r3, [r5, #24]
                break;
   10908:	e01a      	b.n	10940 <ble_ll_sched_adv_reschedule+0x88>
            }

            if (ble_ll_sched_is_overlap(sch, entry)) {
   1090a:	4620      	mov	r0, r4
   1090c:	4629      	mov	r1, r5
   1090e:	f7ff fd33 	bl	10378 <ble_ll_sched_is_overlap>
   10912:	b150      	cbz	r0, 1092a <ble_ll_sched_adv_reschedule+0x72>
                if (ble_ll_sched_conn_overlap(entry)) {
   10914:	4628      	mov	r0, r5
   10916:	f7ff fd41 	bl	1039c <ble_ll_sched_conn_overlap>
   1091a:	b130      	cbz	r0, 1092a <ble_ll_sched_adv_reschedule+0x72>
                    assert(0);
   1091c:	2200      	movs	r2, #0
   1091e:	4810      	ldr	r0, [pc, #64]	; (10960 <ble_ll_sched_adv_reschedule+0xa8>)
   10920:	f240 2125 	movw	r1, #549	; 0x225
   10924:	4613      	mov	r3, r2
   10926:	f7f9 f9d3 	bl	9cd0 <__assert_func>
   1092a:	463d      	mov	r5, r7

            /* Move to next entry */
            entry = next_sch;

            /* Insert at tail if none left to check */
            if (!entry) {
   1092c:	2f00      	cmp	r7, #0
   1092e:	d1dd      	bne.n	108ec <ble_ll_sched_adv_reschedule+0x34>
                rc = 0;
                TAILQ_INSERT_TAIL(&g_ble_ll_sched_q, sch, link);
   10930:	4b0c      	ldr	r3, [pc, #48]	; (10964 <ble_ll_sched_adv_reschedule+0xac>)
   10932:	6167      	str	r7, [r4, #20]
   10934:	685a      	ldr	r2, [r3, #4]
   10936:	61a2      	str	r2, [r4, #24]
   10938:	6014      	str	r4, [r2, #0]
   1093a:	f104 0214 	add.w	r2, r4, #20
   1093e:	605a      	str	r2, [r3, #4]
                break;
            }
        }

        if (!rc) {
            sch->enqueued = 1;
   10940:	2301      	movs	r3, #1
   10942:	7063      	strb	r3, [r4, #1]
        }

        sch = TAILQ_FIRST(&g_ble_ll_sched_q);
   10944:	4b07      	ldr	r3, [pc, #28]	; (10964 <ble_ll_sched_adv_reschedule+0xac>)
   10946:	681c      	ldr	r4, [r3, #0]
    }

    OS_EXIT_CRITICAL(sr);
   10948:	4640      	mov	r0, r8
   1094a:	f7f8 ffef 	bl	992c <os_arch_restore_sr>

    cputime_timer_start(&g_ble_ll_sched_timer, sch->start_time);
   1094e:	4803      	ldr	r0, [pc, #12]	; (1095c <ble_ll_sched_adv_reschedule+0xa4>)
   10950:	6861      	ldr	r1, [r4, #4]
   10952:	f7f8 f9d5 	bl	8d00 <cputime_timer_start>

    return rc;
}
   10956:	4630      	mov	r0, r6
   10958:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1095c:	20003790 	.word	0x20003790
   10960:	0001f2f1 	.word	0x0001f2f1
   10964:	200037a4 	.word	0x200037a4

00010968 <ble_ll_sched_rmv_elem>:
 *
 * @return int
 */
void
ble_ll_sched_rmv_elem(struct ble_ll_sched_item *sch)
{
   10968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_sr_t sr;
    struct ble_ll_sched_item *first;

    if (!sch) {
   1096a:	4604      	mov	r4, r0
   1096c:	b318      	cbz	r0, 109b6 <ble_ll_sched_rmv_elem+0x4e>
        return;
    }

    OS_ENTER_CRITICAL(sr);
   1096e:	f7f8 ffd7 	bl	9920 <os_arch_save_sr>
    if (sch->enqueued) {
   10972:	7863      	ldrb	r3, [r4, #1]

    if (!sch) {
        return;
    }

    OS_ENTER_CRITICAL(sr);
   10974:	4607      	mov	r7, r0
    if (sch->enqueued) {
   10976:	b1cb      	cbz	r3, 109ac <ble_ll_sched_rmv_elem+0x44>
        first = TAILQ_FIRST(&g_ble_ll_sched_q);
   10978:	4d0f      	ldr	r5, [pc, #60]	; (109b8 <ble_ll_sched_rmv_elem+0x50>)
   1097a:	682e      	ldr	r6, [r5, #0]
        if (first == sch) {
   1097c:	42a6      	cmp	r6, r4
   1097e:	d102      	bne.n	10986 <ble_ll_sched_rmv_elem+0x1e>
            cputime_timer_stop(&g_ble_ll_sched_timer);
   10980:	480e      	ldr	r0, [pc, #56]	; (109bc <ble_ll_sched_rmv_elem+0x54>)
   10982:	f7f8 fa1d 	bl	8dc0 <cputime_timer_stop>
        }

        TAILQ_REMOVE(&g_ble_ll_sched_q, sch, link);
   10986:	6963      	ldr	r3, [r4, #20]
   10988:	69a2      	ldr	r2, [r4, #24]
   1098a:	b10b      	cbz	r3, 10990 <ble_ll_sched_rmv_elem+0x28>
   1098c:	619a      	str	r2, [r3, #24]
   1098e:	e000      	b.n	10992 <ble_ll_sched_rmv_elem+0x2a>
   10990:	606a      	str	r2, [r5, #4]
   10992:	69a2      	ldr	r2, [r4, #24]
        sch->enqueued = 0;

        if (first == sch) {
   10994:	42a6      	cmp	r6, r4
        first = TAILQ_FIRST(&g_ble_ll_sched_q);
        if (first == sch) {
            cputime_timer_stop(&g_ble_ll_sched_timer);
        }

        TAILQ_REMOVE(&g_ble_ll_sched_q, sch, link);
   10996:	6013      	str	r3, [r2, #0]
        sch->enqueued = 0;
   10998:	f04f 0300 	mov.w	r3, #0
   1099c:	7063      	strb	r3, [r4, #1]

        if (first == sch) {
   1099e:	d105      	bne.n	109ac <ble_ll_sched_rmv_elem+0x44>
            first = TAILQ_FIRST(&g_ble_ll_sched_q);
   109a0:	682b      	ldr	r3, [r5, #0]
            if (first) {
   109a2:	b11b      	cbz	r3, 109ac <ble_ll_sched_rmv_elem+0x44>
                cputime_timer_start(&g_ble_ll_sched_timer, first->start_time);
   109a4:	4805      	ldr	r0, [pc, #20]	; (109bc <ble_ll_sched_rmv_elem+0x54>)
   109a6:	6859      	ldr	r1, [r3, #4]
   109a8:	f7f8 f9aa 	bl	8d00 <cputime_timer_start>
            }
        }
    }
    OS_EXIT_CRITICAL(sr);
   109ac:	4638      	mov	r0, r7
}
   109ae:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            if (first) {
                cputime_timer_start(&g_ble_ll_sched_timer, first->start_time);
            }
        }
    }
    OS_EXIT_CRITICAL(sr);
   109b2:	f7f8 bfbb 	b.w	992c <os_arch_restore_sr>
   109b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   109b8:	200037a4 	.word	0x200037a4
   109bc:	20003790 	.word	0x20003790

000109c0 <ble_ll_sched_next_time>:
 *
 * @return int 0: No events are scheduled 1: there is an upcoming event
 */
int
ble_ll_sched_next_time(uint32_t *next_event_time)
{
   109c0:	b510      	push	{r4, lr}
   109c2:	4604      	mov	r4, r0
    int rc;
    os_sr_t sr;
    struct ble_ll_sched_item *first;

    rc = 0;
    OS_ENTER_CRITICAL(sr);
   109c4:	f7f8 ffac 	bl	9920 <os_arch_save_sr>
    first = TAILQ_FIRST(&g_ble_ll_sched_q);
   109c8:	4b05      	ldr	r3, [pc, #20]	; (109e0 <ble_ll_sched_next_time+0x20>)
   109ca:	681b      	ldr	r3, [r3, #0]
    if (first) {
   109cc:	b11b      	cbz	r3, 109d6 <ble_ll_sched_next_time+0x16>
        *next_event_time = first->start_time;
   109ce:	685b      	ldr	r3, [r3, #4]
   109d0:	6023      	str	r3, [r4, #0]
        rc = 1;
   109d2:	2401      	movs	r4, #1
   109d4:	e000      	b.n	109d8 <ble_ll_sched_next_time+0x18>
{
    int rc;
    os_sr_t sr;
    struct ble_ll_sched_item *first;

    rc = 0;
   109d6:	461c      	mov	r4, r3
    first = TAILQ_FIRST(&g_ble_ll_sched_q);
    if (first) {
        *next_event_time = first->start_time;
        rc = 1;
    }
    OS_EXIT_CRITICAL(sr);
   109d8:	f7f8 ffa8 	bl	992c <os_arch_restore_sr>

    return rc;
}
   109dc:	4620      	mov	r0, r4
   109de:	bd10      	pop	{r4, pc}
   109e0:	200037a4 	.word	0x200037a4

000109e4 <ble_ll_sched_stop>:
 * Context: Link Layer task
 */
void
ble_ll_sched_stop(void)
{
    cputime_timer_stop(&g_ble_ll_sched_timer);
   109e4:	4801      	ldr	r0, [pc, #4]	; (109ec <ble_ll_sched_stop+0x8>)
   109e6:	f7f8 b9eb 	b.w	8dc0 <cputime_timer_stop>
   109ea:	bf00      	nop
   109ec:	20003790 	.word	0x20003790

000109f0 <ble_ll_sched_init>:
 *
 * @return int
 */
int
ble_ll_sched_init(void)
{
   109f0:	b508      	push	{r3, lr}
    /* Initialize cputimer for the scheduler */
    cputime_timer_init(&g_ble_ll_sched_timer, ble_ll_sched_run, NULL);
   109f2:	4803      	ldr	r0, [pc, #12]	; (10a00 <ble_ll_sched_init+0x10>)
   109f4:	4903      	ldr	r1, [pc, #12]	; (10a04 <ble_ll_sched_init+0x14>)
   109f6:	2200      	movs	r2, #0
   109f8:	f7f8 f96c 	bl	8cd4 <cputime_timer_init>
    return 0;
}
   109fc:	2000      	movs	r0, #0
   109fe:	bd08      	pop	{r3, pc}
   10a00:	20003790 	.word	0x20003790
   10a04:	000103d5 	.word	0x000103d5

00010a08 <ble_ll_whitelist_search>:
 * is the 'position' of the device in the whitelist (the index of the element
 * plus 1).
 */
static int
ble_ll_whitelist_search(uint8_t *addr, uint8_t addr_type)
{
   10a08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10a0a:	4d0d      	ldr	r5, [pc, #52]	; (10a40 <ble_ll_whitelist_search+0x38>)
   10a0c:	4606      	mov	r6, r0
   10a0e:	460f      	mov	r7, r1
    int i;
    struct ble_ll_whitelist_entry *wl;

    wl = &g_ble_ll_whitelist[0];
    for (i = 0; i < BLE_LL_WHITELIST_SIZE; ++i) {
   10a10:	2000      	movs	r0, #0
        if ((wl->wl_valid) && (wl->wl_addr_type == addr_type) &&
   10a12:	f815 3c02 	ldrb.w	r3, [r5, #-2]
   10a16:	1c44      	adds	r4, r0, #1
   10a18:	b15b      	cbz	r3, 10a32 <ble_ll_whitelist_search+0x2a>
   10a1a:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   10a1e:	42bb      	cmp	r3, r7
   10a20:	d107      	bne.n	10a32 <ble_ll_whitelist_search+0x2a>
            (!memcmp(&wl->wl_dev_addr[0], addr, BLE_DEV_ADDR_LEN))) {
   10a22:	4628      	mov	r0, r5
   10a24:	4631      	mov	r1, r6
   10a26:	2206      	movs	r2, #6
   10a28:	f7f8 fada 	bl	8fe0 <memcmp>
    int i;
    struct ble_ll_whitelist_entry *wl;

    wl = &g_ble_ll_whitelist[0];
    for (i = 0; i < BLE_LL_WHITELIST_SIZE; ++i) {
        if ((wl->wl_valid) && (wl->wl_addr_type == addr_type) &&
   10a2c:	b908      	cbnz	r0, 10a32 <ble_ll_whitelist_search+0x2a>
            (!memcmp(&wl->wl_dev_addr[0], addr, BLE_DEV_ADDR_LEN))) {
            return i + 1;
   10a2e:	4620      	mov	r0, r4
   10a30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
    int i;
    struct ble_ll_whitelist_entry *wl;

    wl = &g_ble_ll_whitelist[0];
    for (i = 0; i < BLE_LL_WHITELIST_SIZE; ++i) {
   10a32:	2c08      	cmp	r4, #8
   10a34:	4620      	mov	r0, r4
   10a36:	f105 0508 	add.w	r5, r5, #8
   10a3a:	d1ea      	bne.n	10a12 <ble_ll_whitelist_search+0xa>
            return i + 1;
        }
        ++wl;
    }

    return 0;
   10a3c:	2000      	movs	r0, #0
}
   10a3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10a40:	200037ae 	.word	0x200037ae

00010a44 <ble_ll_whitelist_chg_allowed>:

struct ble_ll_whitelist_entry g_ble_ll_whitelist[BLE_LL_WHITELIST_SIZE];

static int
ble_ll_whitelist_chg_allowed(void)
{
   10a44:	b508      	push	{r3, lr}
     *  -> scanning uses the whitelist and is enabled.
     *  -> initiating uses whitelist and a LE create connection command is in
     *     progress
     */
    rc = 1;
    if (!ble_ll_adv_can_chg_whitelist() || !ble_ll_scan_can_chg_whitelist()) {
   10a46:	f7fb f855 	bl	baf4 <ble_ll_adv_can_chg_whitelist>
   10a4a:	b120      	cbz	r0, 10a56 <ble_ll_whitelist_chg_allowed+0x12>
   10a4c:	f7ff fbfe 	bl	1024c <ble_ll_scan_can_chg_whitelist>
   10a50:	3000      	adds	r0, #0
   10a52:	bf18      	it	ne
   10a54:	2001      	movne	r0, #1
        rc = 0;
    }
    return rc;
}
   10a56:	bd08      	pop	{r3, pc}

00010a58 <ble_ll_whitelist_clear>:
 *
 * @return int 0: success, BLE error code otherwise
 */
int
ble_ll_whitelist_clear(void)
{
   10a58:	b510      	push	{r4, lr}
    int i;
    struct ble_ll_whitelist_entry *wl;

    /* Check proper state */
    if (!ble_ll_whitelist_chg_allowed()) {
   10a5a:	f7ff fff3 	bl	10a44 <ble_ll_whitelist_chg_allowed>
   10a5e:	b188      	cbz	r0, 10a84 <ble_ll_whitelist_clear+0x2c>
    }

    /* Set the number of entries to 0 */
    wl = &g_ble_ll_whitelist[0];
    for (i = 0; i < BLE_LL_WHITELIST_SIZE; ++i) {
        wl->wl_valid = 0;
   10a60:	4b09      	ldr	r3, [pc, #36]	; (10a88 <ble_ll_whitelist_clear+0x30>)
   10a62:	2400      	movs	r4, #0
   10a64:	701c      	strb	r4, [r3, #0]
   10a66:	721c      	strb	r4, [r3, #8]
   10a68:	741c      	strb	r4, [r3, #16]
   10a6a:	761c      	strb	r4, [r3, #24]
   10a6c:	f883 4020 	strb.w	r4, [r3, #32]
   10a70:	f883 4028 	strb.w	r4, [r3, #40]	; 0x28
   10a74:	f883 4030 	strb.w	r4, [r3, #48]	; 0x30
   10a78:	f883 4038 	strb.w	r4, [r3, #56]	; 0x38
        ++wl;
    }

#if (BLE_USES_HW_WHITELIST == 1)
    ble_hw_whitelist_clear();
   10a7c:	f000 f874 	bl	10b68 <ble_hw_whitelist_clear>
#endif

    return BLE_ERR_SUCCESS;
   10a80:	4620      	mov	r0, r4
   10a82:	bd10      	pop	{r4, pc}
    int i;
    struct ble_ll_whitelist_entry *wl;

    /* Check proper state */
    if (!ble_ll_whitelist_chg_allowed()) {
        return BLE_ERR_CMD_DISALLOWED;
   10a84:	200c      	movs	r0, #12
#if (BLE_USES_HW_WHITELIST == 1)
    ble_hw_whitelist_clear();
#endif

    return BLE_ERR_SUCCESS;
}
   10a86:	bd10      	pop	{r4, pc}
   10a88:	200037ac 	.word	0x200037ac

00010a8c <ble_ll_whitelist_read_size>:
 * @return int 0: success.
 */
int
ble_ll_whitelist_read_size(uint8_t *rspbuf, uint8_t *rsplen)
{
    rspbuf[0] = BLE_LL_WHITELIST_SIZE;
   10a8c:	2308      	movs	r3, #8
   10a8e:	7003      	strb	r3, [r0, #0]
    *rsplen = 1;
   10a90:	2301      	movs	r3, #1
   10a92:	700b      	strb	r3, [r1, #0]
    return BLE_ERR_SUCCESS;
}
   10a94:	2000      	movs	r0, #0
   10a96:	4770      	bx	lr

00010a98 <ble_ll_whitelist_match>:
    /*
     * XXX: This should be changed. This is HW specific: some HW may be able
     * to both resolve a private address and perform a whitelist check. The
     * current BLE hw cannot support this.
     */
    if (is_ident) {
   10a98:	b10a      	cbz	r2, 10a9e <ble_ll_whitelist_match+0x6>
        rc = ble_ll_whitelist_search(addr, addr_type);
   10a9a:	f7ff bfb5 	b.w	10a08 <ble_ll_whitelist_search>
    } else {
        rc = ble_hw_whitelist_match();
   10a9e:	f000 b901 	b.w	10ca4 <ble_hw_whitelist_match>
	...

00010aa4 <ble_ll_whitelist_add>:
 *
 * @return int
 */
int
ble_ll_whitelist_add(uint8_t *addr, uint8_t addr_type)
{
   10aa4:	b538      	push	{r3, r4, r5, lr}
   10aa6:	4604      	mov	r4, r0
   10aa8:	460d      	mov	r5, r1
    int i;
    int rc;
    struct ble_ll_whitelist_entry *wl;

    /* Must be in proper state */
    if (!ble_ll_whitelist_chg_allowed()) {
   10aaa:	f7ff ffcb 	bl	10a44 <ble_ll_whitelist_chg_allowed>
   10aae:	b1d8      	cbz	r0, 10ae8 <ble_ll_whitelist_add+0x44>
        return BLE_ERR_CMD_DISALLOWED;
    }

    /* Check if we have any open entries */
    rc = BLE_ERR_SUCCESS;
    if (!ble_ll_whitelist_search(addr, addr_type)) {
   10ab0:	4620      	mov	r0, r4
   10ab2:	4629      	mov	r1, r5
   10ab4:	f7ff ffa8 	bl	10a08 <ble_ll_whitelist_search>
   10ab8:	b9c0      	cbnz	r0, 10aec <ble_ll_whitelist_add+0x48>
   10aba:	4a0d      	ldr	r2, [pc, #52]	; (10af0 <ble_ll_whitelist_add+0x4c>)
   10abc:	1883      	adds	r3, r0, r2
        wl = &g_ble_ll_whitelist[0];
        for (i = 0; i < BLE_LL_WHITELIST_SIZE; ++i) {
            if (wl->wl_valid == 0) {
   10abe:	5c82      	ldrb	r2, [r0, r2]
   10ac0:	b96a      	cbnz	r2, 10ade <ble_ll_whitelist_add+0x3a>
                memcpy(&wl->wl_dev_addr[0], addr, BLE_DEV_ADDR_LEN);
   10ac2:	6822      	ldr	r2, [r4, #0]
   10ac4:	f8c3 2002 	str.w	r2, [r3, #2]
   10ac8:	88a2      	ldrh	r2, [r4, #4]
   10aca:	80da      	strh	r2, [r3, #6]
                wl->wl_addr_type = addr_type;
                wl->wl_valid = 1;
   10acc:	2201      	movs	r2, #1
    if (!ble_ll_whitelist_search(addr, addr_type)) {
        wl = &g_ble_ll_whitelist[0];
        for (i = 0; i < BLE_LL_WHITELIST_SIZE; ++i) {
            if (wl->wl_valid == 0) {
                memcpy(&wl->wl_dev_addr[0], addr, BLE_DEV_ADDR_LEN);
                wl->wl_addr_type = addr_type;
   10ace:	705d      	strb	r5, [r3, #1]
                wl->wl_valid = 1;
   10ad0:	701a      	strb	r2, [r3, #0]

        if (i == BLE_LL_WHITELIST_SIZE) {
            rc = BLE_ERR_MEM_CAPACITY;
        } else {
#if (BLE_USES_HW_WHITELIST == 1)
            rc = ble_hw_whitelist_add(addr, addr_type);
   10ad2:	4620      	mov	r0, r4
   10ad4:	4629      	mov	r1, r5
#endif
        }
    }

    return rc;
}
   10ad6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

        if (i == BLE_LL_WHITELIST_SIZE) {
            rc = BLE_ERR_MEM_CAPACITY;
        } else {
#if (BLE_USES_HW_WHITELIST == 1)
            rc = ble_hw_whitelist_add(addr, addr_type);
   10ada:	f000 b851 	b.w	10b80 <ble_hw_whitelist_add>
   10ade:	3008      	adds	r0, #8

    /* Check if we have any open entries */
    rc = BLE_ERR_SUCCESS;
    if (!ble_ll_whitelist_search(addr, addr_type)) {
        wl = &g_ble_ll_whitelist[0];
        for (i = 0; i < BLE_LL_WHITELIST_SIZE; ++i) {
   10ae0:	2840      	cmp	r0, #64	; 0x40
   10ae2:	d1ea      	bne.n	10aba <ble_ll_whitelist_add+0x16>
            }
            ++wl;
        }

        if (i == BLE_LL_WHITELIST_SIZE) {
            rc = BLE_ERR_MEM_CAPACITY;
   10ae4:	2007      	movs	r0, #7
   10ae6:	bd38      	pop	{r3, r4, r5, pc}
    int rc;
    struct ble_ll_whitelist_entry *wl;

    /* Must be in proper state */
    if (!ble_ll_whitelist_chg_allowed()) {
        return BLE_ERR_CMD_DISALLOWED;
   10ae8:	200c      	movs	r0, #12
   10aea:	bd38      	pop	{r3, r4, r5, pc}
    }

    /* Check if we have any open entries */
    rc = BLE_ERR_SUCCESS;
   10aec:	2000      	movs	r0, #0
#endif
        }
    }

    return rc;
}
   10aee:	bd38      	pop	{r3, r4, r5, pc}
   10af0:	200037ac 	.word	0x200037ac

00010af4 <ble_ll_whitelist_rmv>:
 *
 * @return int 0: success, BLE error code otherwise
 */
int
ble_ll_whitelist_rmv(uint8_t *addr, uint8_t addr_type)
{
   10af4:	b538      	push	{r3, r4, r5, lr}
   10af6:	4605      	mov	r5, r0
   10af8:	460c      	mov	r4, r1
    int position;

    /* Must be in proper state */
    if (!ble_ll_whitelist_chg_allowed()) {
   10afa:	f7ff ffa3 	bl	10a44 <ble_ll_whitelist_chg_allowed>
   10afe:	b178      	cbz	r0, 10b20 <ble_ll_whitelist_rmv+0x2c>
        return BLE_ERR_CMD_DISALLOWED;
    }

    position = ble_ll_whitelist_search(addr, addr_type);
   10b00:	4628      	mov	r0, r5
   10b02:	4621      	mov	r1, r4
   10b04:	f7ff ff80 	bl	10a08 <ble_ll_whitelist_search>
    if (position) {
   10b08:	b120      	cbz	r0, 10b14 <ble_ll_whitelist_rmv+0x20>
        g_ble_ll_whitelist[position - 1].wl_valid = 0;
   10b0a:	3801      	subs	r0, #1
   10b0c:	4b05      	ldr	r3, [pc, #20]	; (10b24 <ble_ll_whitelist_rmv+0x30>)
   10b0e:	2200      	movs	r2, #0
   10b10:	f803 2030 	strb.w	r2, [r3, r0, lsl #3]
    }

#if (BLE_USES_HW_WHITELIST == 1)
    ble_hw_whitelist_rmv(addr, addr_type);
   10b14:	4628      	mov	r0, r5
   10b16:	4621      	mov	r1, r4
   10b18:	f000 f868 	bl	10bec <ble_hw_whitelist_rmv>
#endif

    return BLE_ERR_SUCCESS;
   10b1c:	2000      	movs	r0, #0
   10b1e:	bd38      	pop	{r3, r4, r5, pc}
{
    int position;

    /* Must be in proper state */
    if (!ble_ll_whitelist_chg_allowed()) {
        return BLE_ERR_CMD_DISALLOWED;
   10b20:	200c      	movs	r0, #12
#if (BLE_USES_HW_WHITELIST == 1)
    ble_hw_whitelist_rmv(addr, addr_type);
#endif

    return BLE_ERR_SUCCESS;
}
   10b22:	bd38      	pop	{r3, r4, r5, pc}
   10b24:	200037ac 	.word	0x200037ac

00010b28 <ble_ll_whitelist_enable>:
 */
void
ble_ll_whitelist_enable(void)
{
#if (BLE_USES_HW_WHITELIST == 1)
    ble_hw_whitelist_enable();
   10b28:	f000 b8a4 	b.w	10c74 <ble_hw_whitelist_enable>

00010b2c <ble_ll_whitelist_disable>:
 */
void
ble_ll_whitelist_disable(void)
{
#if (BLE_USES_HW_WHITELIST == 1)
    ble_hw_whitelist_disable();
   10b2c:	f000 b8b0 	b.w	10c90 <ble_hw_whitelist_disable>

00010b30 <ble_rng_isr>:
ble_rng_isr(void)
{
    uint8_t rnum;

    /* No callback? Clear and disable interrupts */
    if (g_ble_rng_isr_cb == NULL) {
   10b30:	4b0b      	ldr	r3, [pc, #44]	; (10b60 <ble_rng_isr+0x30>)
   10b32:	681a      	ldr	r2, [r3, #0]
   10b34:	4b0b      	ldr	r3, [pc, #44]	; (10b64 <ble_rng_isr+0x34>)
   10b36:	b93a      	cbnz	r2, 10b48 <ble_rng_isr+0x18>
        NRF_RNG->INTENCLR = 1;
   10b38:	2101      	movs	r1, #1
   10b3a:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
        NRF_RNG->EVENTS_VALRDY = 0;
   10b3e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
        (void)NRF_RNG->SHORTS;
   10b42:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   10b46:	4770      	bx	lr
        return;
    }

    /* If there is a value ready grab it */
    if (NRF_RNG->EVENTS_VALRDY) {
   10b48:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
   10b4c:	b131      	cbz	r1, 10b5c <ble_rng_isr+0x2c>
        NRF_RNG->EVENTS_VALRDY = 0;
   10b4e:	2100      	movs	r1, #0
   10b50:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
        rnum = (uint8_t)NRF_RNG->VALUE;
   10b54:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
        (*g_ble_rng_isr_cb)(rnum);
   10b58:	b2c0      	uxtb	r0, r0
   10b5a:	4710      	bx	r2
   10b5c:	4770      	bx	lr
   10b5e:	bf00      	nop
   10b60:	20003830 	.word	0x20003830
   10b64:	4000d000 	.word	0x4000d000

00010b68 <ble_hw_whitelist_clear>:
 * @return int
 */
void
ble_hw_whitelist_clear(void)
{
    NRF_RADIO->DACNF = 0;
   10b68:	4a03      	ldr	r2, [pc, #12]	; (10b78 <ble_hw_whitelist_clear+0x10>)
   10b6a:	2300      	movs	r3, #0
   10b6c:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
    g_ble_hw_whitelist_mask = 0;
   10b70:	4a02      	ldr	r2, [pc, #8]	; (10b7c <ble_hw_whitelist_clear+0x14>)
   10b72:	7013      	strb	r3, [r2, #0]
   10b74:	4770      	bx	lr
   10b76:	bf00      	nop
   10b78:	40001000 	.word	0x40001000
   10b7c:	20001eb2 	.word	0x20001eb2

00010b80 <ble_hw_whitelist_add>:
 *
 * @return int 0: success, BLE error code otherwise
 */
int
ble_hw_whitelist_add(uint8_t *addr, uint8_t addr_type)
{
   10b80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t mask;

    /* Find first ununsed device address match element */
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
        if ((mask & g_ble_hw_whitelist_mask) == 0) {
   10b84:	4e17      	ldr	r6, [pc, #92]	; (10be4 <ble_hw_whitelist_add+0x64>)
   10b86:	7833      	ldrb	r3, [r6, #0]
 *
 * @return int 0: success, BLE error code otherwise
 */
int
ble_hw_whitelist_add(uint8_t *addr, uint8_t addr_type)
{
   10b88:	4607      	mov	r7, r0
   10b8a:	4688      	mov	r8, r1
    int i;
    uint32_t mask;

    /* Find first ununsed device address match element */
    mask = 0x01;
   10b8c:	2501      	movs	r5, #1
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
   10b8e:	2400      	movs	r4, #0
        if ((mask & g_ble_hw_whitelist_mask) == 0) {
   10b90:	421d      	tst	r5, r3
   10b92:	d11f      	bne.n	10bd4 <ble_hw_whitelist_add+0x54>
            NRF_RADIO->DAB[i] = le32toh(addr);
   10b94:	4638      	mov	r0, r7
   10b96:	00a4      	lsls	r4, r4, #2
   10b98:	f00c fa7e 	bl	1d098 <le32toh>
   10b9c:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   10ba0:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
   10ba4:	f8c4 0600 	str.w	r0, [r4, #1536]	; 0x600
            NRF_RADIO->DAP[i] = le16toh(addr + 4);
   10ba8:	1d38      	adds	r0, r7, #4
   10baa:	f00c fa70 	bl	1d08e <le16toh>
            if (addr_type == BLE_ADDR_TYPE_RANDOM) {
   10bae:	f1b8 0f01 	cmp.w	r8, #1
                NRF_RADIO->DACNF |= (mask << 8);
   10bb2:	bf08      	it	eq
   10bb4:	4a0c      	ldreq	r2, [pc, #48]	; (10be8 <ble_hw_whitelist_add+0x68>)
    /* Find first ununsed device address match element */
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
        if ((mask & g_ble_hw_whitelist_mask) == 0) {
            NRF_RADIO->DAB[i] = le32toh(addr);
            NRF_RADIO->DAP[i] = le16toh(addr + 4);
   10bb6:	f8c4 0620 	str.w	r0, [r4, #1568]	; 0x620
            if (addr_type == BLE_ADDR_TYPE_RANDOM) {
                NRF_RADIO->DACNF |= (mask << 8);
   10bba:	bf02      	ittt	eq
   10bbc:	f8d2 3640 	ldreq.w	r3, [r2, #1600]	; 0x640
   10bc0:	ea43 2305 	orreq.w	r3, r3, r5, lsl #8
   10bc4:	f8c2 3640 	streq.w	r3, [r2, #1600]	; 0x640
            }
            g_ble_hw_whitelist_mask |= mask;
   10bc8:	7833      	ldrb	r3, [r6, #0]
   10bca:	431d      	orrs	r5, r3
   10bcc:	7035      	strb	r5, [r6, #0]
            return BLE_ERR_SUCCESS;
   10bce:	2000      	movs	r0, #0
   10bd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    int i;
    uint32_t mask;

    /* Find first ununsed device address match element */
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
   10bd4:	3401      	adds	r4, #1
   10bd6:	2c08      	cmp	r4, #8
                NRF_RADIO->DACNF |= (mask << 8);
            }
            g_ble_hw_whitelist_mask |= mask;
            return BLE_ERR_SUCCESS;
        }
        mask <<= 1;
   10bd8:	ea4f 0545 	mov.w	r5, r5, lsl #1
    int i;
    uint32_t mask;

    /* Find first ununsed device address match element */
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
   10bdc:	d1d8      	bne.n	10b90 <ble_hw_whitelist_add+0x10>
            return BLE_ERR_SUCCESS;
        }
        mask <<= 1;
    }

    return BLE_ERR_MEM_CAPACITY;
   10bde:	2007      	movs	r0, #7
}
   10be0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10be4:	20001eb2 	.word	0x20001eb2
   10be8:	40001000 	.word	0x40001000

00010bec <ble_hw_whitelist_rmv>:
 * @param addr_type
 *
 */
void
ble_hw_whitelist_rmv(uint8_t *addr, uint8_t addr_type)
{
   10bec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10bf0:	4604      	mov	r4, r0
   10bf2:	4689      	mov	r9, r1
    uint16_t txadd;
    uint32_t dab;
    uint32_t mask;

    /* Find first ununsed device address match element */
    dab = le32toh(addr);
   10bf4:	f00c fa50 	bl	1d098 <le32toh>
   10bf8:	4680      	mov	r8, r0
    dap = le16toh(addr + 4);
   10bfa:	1d20      	adds	r0, r4, #4
   10bfc:	f00c fa47 	bl	1d08e <le16toh>
    txadd = NRF_RADIO->DACNF >> 8;
   10c00:	4b1a      	ldr	r3, [pc, #104]	; (10c6c <ble_hw_whitelist_rmv+0x80>)
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
        if (mask & g_ble_hw_whitelist_mask) {
   10c02:	4c1b      	ldr	r4, [pc, #108]	; (10c70 <ble_hw_whitelist_rmv+0x84>)
    uint32_t mask;

    /* Find first ununsed device address match element */
    dab = le32toh(addr);
    dap = le16toh(addr + 4);
    txadd = NRF_RADIO->DACNF >> 8;
   10c04:	f8d3 3640 	ldr.w	r3, [r3, #1600]	; 0x640
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
        if (mask & g_ble_hw_whitelist_mask) {
   10c08:	7826      	ldrb	r6, [r4, #0]
    uint32_t mask;

    /* Find first ununsed device address match element */
    dab = le32toh(addr);
    dap = le16toh(addr + 4);
    txadd = NRF_RADIO->DACNF >> 8;
   10c0a:	ea4f 2e13 	mov.w	lr, r3, lsr #8
    mask = 0x01;
   10c0e:	2201      	movs	r2, #1
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
   10c10:	2700      	movs	r7, #0
   10c12:	4625      	mov	r5, r4
        if (mask & g_ble_hw_whitelist_mask) {
   10c14:	4232      	tst	r2, r6
   10c16:	d015      	beq.n	10c44 <ble_hw_whitelist_rmv+0x58>
   10c18:	00bb      	lsls	r3, r7, #2
   10c1a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   10c1e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
            if ((dab == NRF_RADIO->DAB[i]) && (dap == NRF_RADIO->DAP[i])) {
   10c22:	f8d3 1600 	ldr.w	r1, [r3, #1536]	; 0x600
   10c26:	4588      	cmp	r8, r1
   10c28:	d10c      	bne.n	10c44 <ble_hw_whitelist_rmv+0x58>
   10c2a:	f8d3 3620 	ldr.w	r3, [r3, #1568]	; 0x620
   10c2e:	4298      	cmp	r0, r3
   10c30:	d108      	bne.n	10c44 <ble_hw_whitelist_rmv+0x58>
                cfg_addr = txadd & mask;
   10c32:	b2d3      	uxtb	r3, r2
                if (addr_type == BLE_ADDR_TYPE_RANDOM) {
   10c34:	f1b9 0f01 	cmp.w	r9, #1
    txadd = NRF_RADIO->DACNF >> 8;
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
        if (mask & g_ble_hw_whitelist_mask) {
            if ((dab == NRF_RADIO->DAB[i]) && (dap == NRF_RADIO->DAP[i])) {
                cfg_addr = txadd & mask;
   10c38:	ea03 040e 	and.w	r4, r3, lr
                if (addr_type == BLE_ADDR_TYPE_RANDOM) {
   10c3c:	d101      	bne.n	10c42 <ble_hw_whitelist_rmv+0x56>
                    if (cfg_addr != 0) {
   10c3e:	b10c      	cbz	r4, 10c44 <ble_hw_whitelist_rmv+0x58>
   10c40:	e007      	b.n	10c52 <ble_hw_whitelist_rmv+0x66>
                        break;
                    }
                } else {
                    if (cfg_addr == 0) {
   10c42:	b134      	cbz	r4, 10c52 <ble_hw_whitelist_rmv+0x66>
    /* Find first ununsed device address match element */
    dab = le32toh(addr);
    dap = le16toh(addr + 4);
    txadd = NRF_RADIO->DACNF >> 8;
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
   10c44:	3701      	adds	r7, #1
   10c46:	2f08      	cmp	r7, #8
                        break;
                    }
                }
            }
        }
        mask <<= 1;
   10c48:	ea4f 0242 	mov.w	r2, r2, lsl #1
    /* Find first ununsed device address match element */
    dab = le32toh(addr);
    dap = le16toh(addr + 4);
    txadd = NRF_RADIO->DACNF >> 8;
    mask = 0x01;
    for (i = 0; i < BLE_HW_WHITE_LIST_SIZE; ++i) {
   10c4c:	d1e2      	bne.n	10c14 <ble_hw_whitelist_rmv+0x28>
   10c4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        }
        mask <<= 1;
    }

    if (i < BLE_HW_WHITE_LIST_SIZE) {
        g_ble_hw_whitelist_mask &= ~mask;
   10c52:	ea26 0303 	bic.w	r3, r6, r3
        NRF_RADIO->DACNF &= ~mask;
   10c56:	4905      	ldr	r1, [pc, #20]	; (10c6c <ble_hw_whitelist_rmv+0x80>)
        }
        mask <<= 1;
    }

    if (i < BLE_HW_WHITE_LIST_SIZE) {
        g_ble_hw_whitelist_mask &= ~mask;
   10c58:	702b      	strb	r3, [r5, #0]
        NRF_RADIO->DACNF &= ~mask;
   10c5a:	f8d1 3640 	ldr.w	r3, [r1, #1600]	; 0x640
   10c5e:	ea23 0202 	bic.w	r2, r3, r2
   10c62:	f8c1 2640 	str.w	r2, [r1, #1600]	; 0x640
   10c66:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10c6a:	bf00      	nop
   10c6c:	40001000 	.word	0x40001000
   10c70:	20001eb2 	.word	0x20001eb2

00010c74 <ble_hw_whitelist_enable>:
 */
void
ble_hw_whitelist_enable(void)
{
    /* Enable the configured device addresses */
    NRF_RADIO->DACNF |= g_ble_hw_whitelist_mask;
   10c74:	4a04      	ldr	r2, [pc, #16]	; (10c88 <ble_hw_whitelist_enable+0x14>)
   10c76:	4905      	ldr	r1, [pc, #20]	; (10c8c <ble_hw_whitelist_enable+0x18>)
   10c78:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   10c7c:	7809      	ldrb	r1, [r1, #0]
   10c7e:	430b      	orrs	r3, r1
   10c80:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
   10c84:	4770      	bx	lr
   10c86:	bf00      	nop
   10c88:	40001000 	.word	0x40001000
   10c8c:	20001eb2 	.word	0x20001eb2

00010c90 <ble_hw_whitelist_disable>:
 */
void
ble_hw_whitelist_disable(void)
{
    /* Disable all whitelist devices */
    NRF_RADIO->DACNF &= 0x0000ff00;
   10c90:	4a03      	ldr	r2, [pc, #12]	; (10ca0 <ble_hw_whitelist_disable+0x10>)
   10c92:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   10c96:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   10c9a:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
   10c9e:	4770      	bx	lr
   10ca0:	40001000 	.word	0x40001000

00010ca4 <ble_hw_whitelist_match>:
 * @return int
 */
int
ble_hw_whitelist_match(void)
{
    return (int)NRF_RADIO->EVENTS_DEVMATCH;
   10ca4:	4b01      	ldr	r3, [pc, #4]	; (10cac <ble_hw_whitelist_match+0x8>)
   10ca6:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   10caa:	4770      	bx	lr
   10cac:	40001000 	.word	0x40001000

00010cb0 <ble_hw_encrypt_block>:
    int rc;
    uint32_t end;
    uint32_t err;

    /* Stop ECB */
    NRF_ECB->TASKS_STOPECB = 1;
   10cb0:	4b0c      	ldr	r3, [pc, #48]	; (10ce4 <ble_hw_encrypt_block+0x34>)
   10cb2:	2201      	movs	r2, #1
    /* XXX: does task stop clear these counters? Anyway to do this quicker? */
    NRF_ECB->EVENTS_ENDECB = 0;
   10cb4:	2100      	movs	r1, #0
    int rc;
    uint32_t end;
    uint32_t err;

    /* Stop ECB */
    NRF_ECB->TASKS_STOPECB = 1;
   10cb6:	605a      	str	r2, [r3, #4]
    /* XXX: does task stop clear these counters? Anyway to do this quicker? */
    NRF_ECB->EVENTS_ENDECB = 0;
   10cb8:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    NRF_ECB->EVENTS_ERRORECB = 0;
   10cbc:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
   10cc0:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504

    /* Start ECB */
    NRF_ECB->TASKS_STARTECB = 1;
   10cc4:	601a      	str	r2, [r3, #0]

    /* Wait till error or done */
    rc = 0;
    while (1) {
        end = NRF_ECB->EVENTS_ENDECB;
   10cc6:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
        err = NRF_ECB->EVENTS_ERRORECB;
   10cca:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
        if (end || err) {
   10cce:	b922      	cbnz	r2, 10cda <ble_hw_encrypt_block+0x2a>
   10cd0:	2800      	cmp	r0, #0
   10cd2:	d0f8      	beq.n	10cc6 <ble_hw_encrypt_block+0x16>
            if (err) {
                rc = -1;
   10cd4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
            break;
        }
    }

    return rc;
}
   10cd8:	4770      	bx	lr
    rc = 0;
    while (1) {
        end = NRF_ECB->EVENTS_ENDECB;
        err = NRF_ECB->EVENTS_ERRORECB;
        if (end || err) {
            if (err) {
   10cda:	3000      	adds	r0, #0
   10cdc:	bf18      	it	ne
   10cde:	2001      	movne	r0, #1
   10ce0:	4240      	negs	r0, r0
   10ce2:	4770      	bx	lr
   10ce4:	4000e000 	.word	0x4000e000

00010ce8 <ble_hw_rng_init>:
 *
 * @return int
 */
int
ble_hw_rng_init(ble_rng_isr_cb_t cb, int bias)
{
   10ce8:	b538      	push	{r3, r4, r5, lr}
   10cea:	4604      	mov	r4, r0
   10cec:	4b0b      	ldr	r3, [pc, #44]	; (10d1c <ble_hw_rng_init+0x34>)
    /* Set bias */
    if (bias) {
   10cee:	b119      	cbz	r1, 10cf8 <ble_hw_rng_init+0x10>
        NRF_RNG->CONFIG = 1;
   10cf0:	2201      	movs	r2, #1
   10cf2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
   10cf6:	e001      	b.n	10cfc <ble_hw_rng_init+0x14>
    } else {
        NRF_RNG->CONFIG = 0;
   10cf8:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
    }

    /* If we were passed a function pointer we need to enable the interrupt */
    if (cb != NULL) {
   10cfc:	b164      	cbz	r4, 10d18 <ble_hw_rng_init+0x30>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   10cfe:	4d08      	ldr	r5, [pc, #32]	; (10d20 <ble_hw_rng_init+0x38>)
        NVIC_SetPriority(RNG_IRQn, (1 << __NVIC_PRIO_BITS) - 1);
        NVIC_SetVector(RNG_IRQn, (uint32_t)ble_rng_isr);
   10d00:	4908      	ldr	r1, [pc, #32]	; (10d24 <ble_hw_rng_init+0x3c>)
   10d02:	23e0      	movs	r3, #224	; 0xe0
   10d04:	f885 330d 	strb.w	r3, [r5, #781]	; 0x30d
   10d08:	200d      	movs	r0, #13
   10d0a:	f7f8 fc09 	bl	9520 <NVIC_SetVector>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
   10d0e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   10d12:	602b      	str	r3, [r5, #0]
        NVIC_EnableIRQ(RNG_IRQn);
        g_ble_rng_isr_cb = cb;
   10d14:	4b04      	ldr	r3, [pc, #16]	; (10d28 <ble_hw_rng_init+0x40>)
   10d16:	601c      	str	r4, [r3, #0]
    }

    return 0;
}
   10d18:	2000      	movs	r0, #0
   10d1a:	bd38      	pop	{r3, r4, r5, pc}
   10d1c:	4000d000 	.word	0x4000d000
   10d20:	e000e100 	.word	0xe000e100
   10d24:	00010b31 	.word	0x00010b31
   10d28:	20003830 	.word	0x20003830

00010d2c <ble_hw_rng_start>:
 *
 * @return int
 */
int
ble_hw_rng_start(void)
{
   10d2c:	b508      	push	{r3, lr}
    os_sr_t sr;

    /* No need for interrupt if there is no callback */
    OS_ENTER_CRITICAL(sr);
   10d2e:	f7f8 fdf7 	bl	9920 <os_arch_save_sr>
    if (NRF_RNG->TASKS_START == 0) {
   10d32:	4b08      	ldr	r3, [pc, #32]	; (10d54 <ble_hw_rng_start+0x28>)
   10d34:	681a      	ldr	r2, [r3, #0]
   10d36:	b942      	cbnz	r2, 10d4a <ble_hw_rng_start+0x1e>
        NRF_RNG->EVENTS_VALRDY = 0;
   10d38:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
        if (g_ble_rng_isr_cb) {
   10d3c:	4a06      	ldr	r2, [pc, #24]	; (10d58 <ble_hw_rng_start+0x2c>)
   10d3e:	6811      	ldr	r1, [r2, #0]
   10d40:	2201      	movs	r2, #1
   10d42:	b109      	cbz	r1, 10d48 <ble_hw_rng_start+0x1c>
            NRF_RNG->INTENSET = 1;
   10d44:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
        }
        NRF_RNG->TASKS_START = 1;
   10d48:	601a      	str	r2, [r3, #0]
    }
    OS_EXIT_CRITICAL(sr);
   10d4a:	f7f8 fdef 	bl	992c <os_arch_restore_sr>

    return 0;
}
   10d4e:	2000      	movs	r0, #0
   10d50:	bd08      	pop	{r3, pc}
   10d52:	bf00      	nop
   10d54:	4000d000 	.word	0x4000d000
   10d58:	20003830 	.word	0x20003830

00010d5c <ble_hw_rng_stop>:
 *
 * @return int
 */
int
ble_hw_rng_stop(void)
{
   10d5c:	b510      	push	{r4, lr}
    os_sr_t sr;

    /* No need for interrupt if there is no callback */
    OS_ENTER_CRITICAL(sr);
   10d5e:	f7f8 fddf 	bl	9920 <os_arch_save_sr>
    NRF_RNG->INTENCLR = 1;
   10d62:	4b06      	ldr	r3, [pc, #24]	; (10d7c <ble_hw_rng_stop+0x20>)
   10d64:	2201      	movs	r2, #1
    NRF_RNG->TASKS_STOP = 1;
    NRF_RNG->EVENTS_VALRDY = 0;
   10d66:	2400      	movs	r4, #0
{
    os_sr_t sr;

    /* No need for interrupt if there is no callback */
    OS_ENTER_CRITICAL(sr);
    NRF_RNG->INTENCLR = 1;
   10d68:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    NRF_RNG->TASKS_STOP = 1;
   10d6c:	605a      	str	r2, [r3, #4]
    NRF_RNG->EVENTS_VALRDY = 0;
   10d6e:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
    OS_EXIT_CRITICAL(sr);
   10d72:	f7f8 fddb 	bl	992c <os_arch_restore_sr>

    return 0;
}
   10d76:	4620      	mov	r0, r4
   10d78:	bd10      	pop	{r4, pc}
   10d7a:	bf00      	nop
   10d7c:	4000d000 	.word	0x4000d000

00010d80 <ble_hw_resolv_list_clear>:
 * @return int
 */
void
ble_hw_resolv_list_clear(void)
{
    g_nrf_num_irks = 0;
   10d80:	4b01      	ldr	r3, [pc, #4]	; (10d88 <ble_hw_resolv_list_clear+0x8>)
   10d82:	2200      	movs	r2, #0
   10d84:	701a      	strb	r2, [r3, #0]
   10d86:	4770      	bx	lr
   10d88:	200037ec 	.word	0x200037ec

00010d8c <ble_hw_resolv_list_add>:
 *
 * @return int 0: success, BLE error code otherwise
 */
int
ble_hw_resolv_list_add(uint8_t *irk)
{
   10d8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t *nrf_entry;

    /* Find first ununsed device address match element */
    if (g_nrf_num_irks == NRF_IRK_LIST_ENTRIES) {
   10d8e:	4b0c      	ldr	r3, [pc, #48]	; (10dc0 <ble_hw_resolv_list_add+0x34>)
   10d90:	781a      	ldrb	r2, [r3, #0]
   10d92:	2a04      	cmp	r2, #4
   10d94:	461d      	mov	r5, r3
   10d96:	d011      	beq.n	10dbc <ble_hw_resolv_list_add+0x30>
        return BLE_ERR_MEM_CAPACITY;
    }

    /* Copy into irk list */
    nrf_entry = &g_nrf_irk_list[4 * g_nrf_num_irks];
    memcpy(nrf_entry, irk, 16);
   10d98:	4c0a      	ldr	r4, [pc, #40]	; (10dc4 <ble_hw_resolv_list_add+0x38>)
   10d9a:	4603      	mov	r3, r0
   10d9c:	eb04 1402 	add.w	r4, r4, r2, lsl #4
   10da0:	f100 0710 	add.w	r7, r0, #16
   10da4:	6818      	ldr	r0, [r3, #0]
   10da6:	6859      	ldr	r1, [r3, #4]
   10da8:	4626      	mov	r6, r4
   10daa:	c603      	stmia	r6!, {r0, r1}
   10dac:	3308      	adds	r3, #8
   10dae:	42bb      	cmp	r3, r7
   10db0:	4634      	mov	r4, r6
   10db2:	d1f7      	bne.n	10da4 <ble_hw_resolv_list_add+0x18>

    /* Add to total */
    ++g_nrf_num_irks;
   10db4:	3201      	adds	r2, #1
   10db6:	702a      	strb	r2, [r5, #0]
    return BLE_ERR_SUCCESS;
   10db8:	2000      	movs	r0, #0
   10dba:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
    uint32_t *nrf_entry;

    /* Find first ununsed device address match element */
    if (g_nrf_num_irks == NRF_IRK_LIST_ENTRIES) {
        return BLE_ERR_MEM_CAPACITY;
   10dbc:	2007      	movs	r0, #7
    memcpy(nrf_entry, irk, 16);

    /* Add to total */
    ++g_nrf_num_irks;
    return BLE_ERR_SUCCESS;
}
   10dbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10dc0:	200037ec 	.word	0x200037ec
   10dc4:	200037f0 	.word	0x200037f0

00010dc8 <ble_hw_resolv_list_rmv>:
void
ble_hw_resolv_list_rmv(int index)
{
    uint32_t *irk_entry;

    if (index < g_nrf_num_irks) {
   10dc8:	4909      	ldr	r1, [pc, #36]	; (10df0 <ble_hw_resolv_list_rmv+0x28>)
   10dca:	780b      	ldrb	r3, [r1, #0]
   10dcc:	4298      	cmp	r0, r3
 *
 * @param index Index of IRK to remove
 */
void
ble_hw_resolv_list_rmv(int index)
{
   10dce:	4602      	mov	r2, r0
    uint32_t *irk_entry;

    if (index < g_nrf_num_irks) {
   10dd0:	da0c      	bge.n	10dec <ble_hw_resolv_list_rmv+0x24>
        --g_nrf_num_irks;
   10dd2:	3b01      	subs	r3, #1
   10dd4:	b2db      	uxtb	r3, r3
        irk_entry = &g_nrf_irk_list[index];
        if (g_nrf_num_irks > index) {
   10dd6:	4283      	cmp	r3, r0
ble_hw_resolv_list_rmv(int index)
{
    uint32_t *irk_entry;

    if (index < g_nrf_num_irks) {
        --g_nrf_num_irks;
   10dd8:	700b      	strb	r3, [r1, #0]
        irk_entry = &g_nrf_irk_list[index];
        if (g_nrf_num_irks > index) {
   10dda:	dd07      	ble.n	10dec <ble_hw_resolv_list_rmv+0x24>
{
    uint32_t *irk_entry;

    if (index < g_nrf_num_irks) {
        --g_nrf_num_irks;
        irk_entry = &g_nrf_irk_list[index];
   10ddc:	4805      	ldr	r0, [pc, #20]	; (10df4 <ble_hw_resolv_list_rmv+0x2c>)
   10dde:	eb00 0082 	add.w	r0, r0, r2, lsl #2
        if (g_nrf_num_irks > index) {
            memmove(irk_entry, irk_entry + 4, g_nrf_num_irks - index);
   10de2:	f100 0110 	add.w	r1, r0, #16
   10de6:	1a9a      	subs	r2, r3, r2
   10de8:	f00c be74 	b.w	1dad4 <memmove>
   10dec:	4770      	bx	lr
   10dee:	bf00      	nop
   10df0:	200037ec 	.word	0x200037ec
   10df4:	200037f0 	.word	0x200037f0

00010df8 <ble_hw_resolv_list_size>:
 */
uint8_t
ble_hw_resolv_list_size(void)
{
    return BLE_HW_RESOLV_LIST_SIZE;
}
   10df8:	2010      	movs	r0, #16
   10dfa:	4770      	bx	lr

00010dfc <ble_hw_resolv_list_match>:
int
ble_hw_resolv_list_match(void)
{
    uint32_t index;

    if (NRF_AAR->EVENTS_END) {
   10dfc:	4b06      	ldr	r3, [pc, #24]	; (10e18 <ble_hw_resolv_list_match+0x1c>)
   10dfe:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   10e02:	b12a      	cbz	r2, 10e10 <ble_hw_resolv_list_match+0x14>
        if (NRF_AAR->EVENTS_RESOLVED) {
   10e04:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   10e08:	b112      	cbz	r2, 10e10 <ble_hw_resolv_list_match+0x14>
            index = NRF_AAR->STATUS;
   10e0a:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
            return (int)index;
   10e0e:	4770      	bx	lr
        }
    }

    return -1;
   10e10:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   10e14:	4770      	bx	lr
   10e16:	bf00      	nop
   10e18:	4000f000 	.word	0x4000f000

00010e1c <nrf_wait_disabled>:
static void
nrf_wait_disabled(void)
{
    uint32_t state;

    state = NRF_RADIO->STATE;
   10e1c:	4b06      	ldr	r3, [pc, #24]	; (10e38 <nrf_wait_disabled+0x1c>)
   10e1e:	f8d3 2550 	ldr.w	r2, [r3, #1360]	; 0x550
    if (state != RADIO_STATE_STATE_Disabled) {
   10e22:	b13a      	cbz	r2, 10e34 <nrf_wait_disabled+0x18>
        if ((state == RADIO_STATE_STATE_RxDisable) ||
   10e24:	f022 0108 	bic.w	r1, r2, #8
   10e28:	2904      	cmp	r1, #4
   10e2a:	d103      	bne.n	10e34 <nrf_wait_disabled+0x18>
            (state == RADIO_STATE_STATE_TxDisable)) {
            /* This will end within a short time (6 usecs). Just poll */
            while (NRF_RADIO->STATE == state) {
   10e2c:	f8d3 1550 	ldr.w	r1, [r3, #1360]	; 0x550
   10e30:	4291      	cmp	r1, r2
   10e32:	e7fa      	b.n	10e2a <nrf_wait_disabled+0xe>
   10e34:	4770      	bx	lr
   10e36:	bf00      	nop
   10e38:	40001000 	.word	0x40001000

00010e3c <ble_phy_rx_xcvr_setup>:
 */
static void
ble_phy_rx_xcvr_setup(void)
{
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (g_ble_phy_data.phy_encrypted) {
   10e3c:	4b31      	ldr	r3, [pc, #196]	; (10f04 <ble_phy_rx_xcvr_setup+0xc8>)
   10e3e:	4a32      	ldr	r2, [pc, #200]	; (10f08 <ble_phy_rx_xcvr_setup+0xcc>)
   10e40:	7999      	ldrb	r1, [r3, #6]
   10e42:	b1f9      	cbz	r1, 10e84 <ble_phy_rx_xcvr_setup+0x48>
        NRF_RADIO->PACKETPTR = (uint32_t)&g_ble_phy_enc_buf[0];
   10e44:	4931      	ldr	r1, [pc, #196]	; (10f0c <ble_phy_rx_xcvr_setup+0xd0>)
   10e46:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
        NRF_CCM->INPTR = (uint32_t)&g_ble_phy_enc_buf[0];
   10e4a:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
   10e4e:	f8c2 150c 	str.w	r1, [r2, #1292]	; 0x50c
        NRF_CCM->OUTPTR = (uint32_t)g_ble_phy_data.rxpdu->om_data;
   10e52:	6959      	ldr	r1, [r3, #20]
   10e54:	6809      	ldr	r1, [r1, #0]
   10e56:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
        NRF_CCM->SCRATCHPTR = (uint32_t)&g_nrf_encrypt_scratchpad[0];
   10e5a:	492d      	ldr	r1, [pc, #180]	; (10f10 <ble_phy_rx_xcvr_setup+0xd4>)
   10e5c:	f8c2 1514 	str.w	r1, [r2, #1300]	; 0x514
        NRF_CCM->MODE = CCM_MODE_LENGTH_Msk | CCM_MODE_MODE_Decryption;
   10e60:	492c      	ldr	r1, [pc, #176]	; (10f14 <ble_phy_rx_xcvr_setup+0xd8>)
   10e62:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
        NRF_CCM->CNFPTR = (uint32_t)&g_nrf_ccm_data;
   10e66:	492c      	ldr	r1, [pc, #176]	; (10f18 <ble_phy_rx_xcvr_setup+0xdc>)
   10e68:	f8c2 1508 	str.w	r1, [r2, #1288]	; 0x508
        NRF_CCM->SHORTS = 0;
   10e6c:	2100      	movs	r1, #0
   10e6e:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
        NRF_CCM->EVENTS_ERROR = 0;
   10e72:	f8c2 1108 	str.w	r1, [r2, #264]	; 0x108
        NRF_CCM->EVENTS_ENDCRYPT = 0;
   10e76:	f8c2 1104 	str.w	r1, [r2, #260]	; 0x104
        NRF_PPI->CHENSET = PPI_CHEN_CH24_Msk | PPI_CHEN_CH25_Msk;
   10e7a:	f04f 7140 	mov.w	r1, #50331648	; 0x3000000
   10e7e:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
   10e82:	e001      	b.n	10e88 <ble_phy_rx_xcvr_setup+0x4c>
    } else {
        NRF_RADIO->PACKETPTR = (uint32_t)g_ble_phy_data.rxpdu->om_data;
   10e84:	6959      	ldr	r1, [r3, #20]
   10e86:	6809      	ldr	r1, [r1, #0]
   10e88:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
#else
    NRF_RADIO->PACKETPTR = (uint32_t)g_ble_phy_data.rxpdu->om_data;
#endif

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (g_ble_phy_data.phy_privacy) {
   10e8c:	79da      	ldrb	r2, [r3, #7]
   10e8e:	491d      	ldr	r1, [pc, #116]	; (10f04 <ble_phy_rx_xcvr_setup+0xc8>)
   10e90:	b1aa      	cbz	r2, 10ebe <ble_phy_rx_xcvr_setup+0x82>
        NRF_AAR->ENABLE = AAR_ENABLE_ENABLE_Enabled;
   10e92:	4a22      	ldr	r2, [pc, #136]	; (10f1c <ble_phy_rx_xcvr_setup+0xe0>)
   10e94:	2003      	movs	r0, #3
   10e96:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
        NRF_AAR->IRKPTR = (uint32_t)&g_nrf_irk_list[0];
   10e9a:	4821      	ldr	r0, [pc, #132]	; (10f20 <ble_phy_rx_xcvr_setup+0xe4>)
   10e9c:	f8c2 0508 	str.w	r0, [r2, #1288]	; 0x508
        NRF_AAR->ADDRPTR = (uint32_t)g_ble_phy_data.rxpdu->om_data;
   10ea0:	6948      	ldr	r0, [r1, #20]
        NRF_AAR->SCRATCHPTR = (uint32_t)&g_ble_phy_data.phy_aar_scratch;
   10ea2:	310c      	adds	r1, #12

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    if (g_ble_phy_data.phy_privacy) {
        NRF_AAR->ENABLE = AAR_ENABLE_ENABLE_Enabled;
        NRF_AAR->IRKPTR = (uint32_t)&g_nrf_irk_list[0];
        NRF_AAR->ADDRPTR = (uint32_t)g_ble_phy_data.rxpdu->om_data;
   10ea4:	6800      	ldr	r0, [r0, #0]
   10ea6:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        NRF_AAR->SCRATCHPTR = (uint32_t)&g_ble_phy_data.phy_aar_scratch;
   10eaa:	f8c2 1514 	str.w	r1, [r2, #1300]	; 0x514
        NRF_AAR->EVENTS_END = 0;
   10eae:	2100      	movs	r1, #0
   10eb0:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
        NRF_AAR->EVENTS_RESOLVED = 0;
   10eb4:	f8c2 1104 	str.w	r1, [r2, #260]	; 0x104
        NRF_AAR->EVENTS_NOTRESOLVED = 0;
   10eb8:	f8c2 1108 	str.w	r1, [r2, #264]	; 0x108
   10ebc:	e004      	b.n	10ec8 <ble_phy_rx_xcvr_setup+0x8c>
    } else {
        if (g_ble_phy_data.phy_encrypted == 0) {
   10ebe:	798a      	ldrb	r2, [r1, #6]
   10ec0:	b912      	cbnz	r2, 10ec8 <ble_phy_rx_xcvr_setup+0x8c>
            NRF_AAR->ENABLE = AAR_ENABLE_ENABLE_Disabled;
   10ec2:	4916      	ldr	r1, [pc, #88]	; (10f1c <ble_phy_rx_xcvr_setup+0xe0>)
   10ec4:	f8c1 2500 	str.w	r2, [r1, #1280]	; 0x500
        }
    }
#endif

    /* Turn off trigger TXEN on output compare match and AAR on bcmatch */
    NRF_PPI->CHENCLR = PPI_CHEN_CH20_Msk | PPI_CHEN_CH23_Msk;
   10ec8:	4a16      	ldr	r2, [pc, #88]	; (10f24 <ble_phy_rx_xcvr_setup+0xe8>)
   10eca:	f44f 0110 	mov.w	r1, #9437184	; 0x900000
   10ece:	f8c2 1508 	str.w	r1, [r2, #1288]	; 0x508

    /* Reset the rx started flag. Used for the wait for response */
    g_ble_phy_data.phy_rx_started = 0;
   10ed2:	2200      	movs	r2, #0
    g_ble_phy_data.phy_state = BLE_PHY_STATE_RX;
   10ed4:	2101      	movs	r1, #1

    /* Turn off trigger TXEN on output compare match and AAR on bcmatch */
    NRF_PPI->CHENCLR = PPI_CHEN_CH20_Msk | PPI_CHEN_CH23_Msk;

    /* Reset the rx started flag. Used for the wait for response */
    g_ble_phy_data.phy_rx_started = 0;
   10ed6:	715a      	strb	r2, [r3, #5]
    g_ble_phy_data.phy_state = BLE_PHY_STATE_RX;
   10ed8:	70d9      	strb	r1, [r3, #3]

    /* I want to know when 1st byte received (after address) */
    NRF_RADIO->BCC = 8; /* in bits */
   10eda:	4b0b      	ldr	r3, [pc, #44]	; (10f08 <ble_phy_rx_xcvr_setup+0xcc>)
   10edc:	2108      	movs	r1, #8
   10ede:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
    NRF_RADIO->EVENTS_ADDRESS = 0;
   10ee2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    NRF_RADIO->EVENTS_DEVMATCH = 0;
   10ee6:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    NRF_RADIO->EVENTS_BCMATCH = 0;
   10eea:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    NRF_RADIO->EVENTS_RSSIEND = 0;
   10eee:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    NRF_RADIO->SHORTS = RADIO_SHORTS_END_DISABLE_Msk |
   10ef2:	f240 1257 	movw	r2, #343	; 0x157
   10ef6:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                        RADIO_SHORTS_DISABLED_TXEN_Msk |
                        RADIO_SHORTS_ADDRESS_BCSTART_Msk |
                        RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
                        RADIO_SHORTS_DISABLED_RSSISTOP_Msk;

    NRF_RADIO->INTENSET = RADIO_INTENSET_ADDRESS_Msk;
   10efa:	2202      	movs	r2, #2
   10efc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
   10f00:	4770      	bx	lr
   10f02:	bf00      	nop
   10f04:	20003834 	.word	0x20003834
   10f08:	40001000 	.word	0x40001000
   10f0c:	20001eb4 	.word	0x20001eb4
   10f10:	20003854 	.word	0x20003854
   10f14:	01000001 	.word	0x01000001
   10f18:	200039a4 	.word	0x200039a4
   10f1c:	4000f000 	.word	0x4000f000
   10f20:	200037f0 	.word	0x200037f0
   10f24:	4001f000 	.word	0x4001f000

00010f28 <ble_phy_rxpdu_get.part.0>:
 * Gets a mbuf for PDU reception.
 *
 * @return struct os_mbuf* Pointer to retrieved mbuf or NULL if none available
 */
static struct os_mbuf *
ble_phy_rxpdu_get(void)
   10f28:	b508      	push	{r3, lr}
{
    struct os_mbuf *m;

    m = g_ble_phy_data.rxpdu;
    if (m == NULL) {
        m = os_msys_get_pkthdr(BLE_MBUF_PAYLOAD_SIZE, sizeof(struct ble_mbuf_hdr));
   10f2a:	f44f 7082 	mov.w	r0, #260	; 0x104
   10f2e:	2108      	movs	r1, #8
   10f30:	f7f8 ffff 	bl	9f32 <os_msys_get_pkthdr>
        if (!m) {
   10f34:	b920      	cbnz	r0, 10f40 <ble_phy_rxpdu_get.part.0+0x18>
            STATS_INC(ble_phy_stats, no_bufs);
   10f36:	4a05      	ldr	r2, [pc, #20]	; (10f4c <ble_phy_rxpdu_get.part.0+0x24>)
   10f38:	6b53      	ldr	r3, [r2, #52]	; 0x34
   10f3a:	3301      	adds	r3, #1
   10f3c:	6353      	str	r3, [r2, #52]	; 0x34
   10f3e:	bd08      	pop	{r3, pc}
        } else {
            /*
             * NOTE: we add two bytes to the data pointer as we will prepend
             * two bytes if we hand this received pdu up to host.
             */
            m->om_data += 2;
   10f40:	6803      	ldr	r3, [r0, #0]
   10f42:	3302      	adds	r3, #2
   10f44:	6003      	str	r3, [r0, #0]
            g_ble_phy_data.rxpdu = m;
   10f46:	4b02      	ldr	r3, [pc, #8]	; (10f50 <ble_phy_rxpdu_get.part.0+0x28>)
   10f48:	6158      	str	r0, [r3, #20]
        }
    }

    return m;
}
   10f4a:	bd08      	pop	{r3, pc}
   10f4c:	20003960 	.word	0x20003960
   10f50:	20003834 	.word	0x20003834

00010f54 <ble_phy_init>:
{
    int rc;
    uint32_t os_tmo;

    /* Make sure HFXO is started */
    NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
   10f54:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   10f58:	2200      	movs	r2, #0
 *
 * @return int 0: success; PHY error code otherwise
 */
int
ble_phy_init(void)
{
   10f5a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    int rc;
    uint32_t os_tmo;

    /* Make sure HFXO is started */
    NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
   10f5e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    NRF_CLOCK->TASKS_HFCLKSTART = 1;
   10f62:	2201      	movs	r2, #1
   10f64:	601a      	str	r2, [r3, #0]
    os_tmo = os_time_get() + (5 * (1000 / OS_TICKS_PER_SEC));
   10f66:	f7f9 fc2b 	bl	a7c0 <os_time_get>
   10f6a:	f100 0423 	add.w	r4, r0, #35	; 0x23
    while (1) {
        if (NRF_CLOCK->EVENTS_HFCLKSTARTED) {
   10f6e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   10f72:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   10f76:	b933      	cbnz	r3, 10f86 <ble_phy_init+0x32>
            break;
        }
        if ((int32_t)(os_time_get() - os_tmo) > 0) {
   10f78:	f7f9 fc22 	bl	a7c0 <os_time_get>
   10f7c:	1b00      	subs	r0, r0, r4
   10f7e:	2800      	cmp	r0, #0
   10f80:	ddf5      	ble.n	10f6e <ble_phy_init+0x1a>
            return BLE_PHY_ERR_INIT;
   10f82:	2002      	movs	r0, #2
   10f84:	e068      	b.n	11058 <ble_phy_init+0x104>
        }
    }

    /* Set phy channel to an invalid channel so first set channel works */
    g_ble_phy_data.phy_chan = BLE_PHY_NUM_CHANS;
   10f86:	4e36      	ldr	r6, [pc, #216]	; (11060 <ble_phy_init+0x10c>)

    /* Captures tx/rx start in timer0 capture 1 */
    NRF_PPI->CHENSET = PPI_CHEN_CH26_Msk;

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    NRF_CCM->INTENCLR = 0xffffffff;
   10f88:	4d36      	ldr	r5, [pc, #216]	; (11064 <ble_phy_init+0x110>)
    NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
    NRF_CCM->EVENTS_ERROR = 0;
    memset(g_nrf_encrypt_scratchpad, 0, sizeof(g_nrf_encrypt_scratchpad));
   10f8a:	4837      	ldr	r0, [pc, #220]	; (11068 <ble_phy_init+0x114>)
            return BLE_PHY_ERR_INIT;
        }
    }

    /* Set phy channel to an invalid channel so first set channel works */
    g_ble_phy_data.phy_chan = BLE_PHY_NUM_CHANS;
   10f8c:	2328      	movs	r3, #40	; 0x28
   10f8e:	70b3      	strb	r3, [r6, #2]

    /* Toggle peripheral power to reset (just in case) */
    NRF_RADIO->POWER = 0;
   10f90:	4b36      	ldr	r3, [pc, #216]	; (1106c <ble_phy_init+0x118>)
   10f92:	2400      	movs	r4, #0
    NRF_RADIO->POWER = 1;
   10f94:	2701      	movs	r7, #1

    /* Disable all interrupts */
    NRF_RADIO->INTENCLR = NRF_RADIO_IRQ_MASK_ALL;
   10f96:	f243 42ff 	movw	r2, #13567	; 0x34ff

    /* Set phy channel to an invalid channel so first set channel works */
    g_ble_phy_data.phy_chan = BLE_PHY_NUM_CHANS;

    /* Toggle peripheral power to reset (just in case) */
    NRF_RADIO->POWER = 0;
   10f9a:	f8c3 4ffc 	str.w	r4, [r3, #4092]	; 0xffc
    NRF_RADIO->POWER = 1;
   10f9e:	f8c3 7ffc 	str.w	r7, [r3, #4092]	; 0xffc

    /* Disable all interrupts */
    NRF_RADIO->INTENCLR = NRF_RADIO_IRQ_MASK_ALL;
   10fa2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

    /* Set configuration registers */
    NRF_RADIO->MODE = RADIO_MODE_MODE_Ble_1Mbit;
   10fa6:	2203      	movs	r2, #3
   10fa8:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    NRF_RADIO->PCNF0 = (NRF_LFLEN_BITS << RADIO_PCNF0_LFLEN_Pos)    |
   10fac:	4a30      	ldr	r2, [pc, #192]	; (11070 <ble_phy_init+0x11c>)
   10fae:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
                       RADIO_PCNF0_S1INCL_Msk                       |
                       (NRF_S0_LEN << RADIO_PCNF0_S0LEN_Pos)        |
                       (RADIO_PCNF0_PLEN_8bit << RADIO_PCNF0_PLEN_Pos);
    /* XXX: should maxlen be 251 for encryption? */
    NRF_RADIO->PCNF1 = NRF_MAXLEN |
   10fb2:	4a30      	ldr	r2, [pc, #192]	; (11074 <ble_phy_init+0x120>)
   10fb4:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
                       (RADIO_PCNF1_ENDIAN_Little <<  RADIO_PCNF1_ENDIAN_Pos) |
                       (NRF_BALEN << RADIO_PCNF1_BALEN_Pos) |
                       RADIO_PCNF1_WHITEEN_Msk;

    /* Set base0 with the advertising access address */
    NRF_RADIO->BASE0 = (BLE_ACCESS_ADDR_ADV << 8) & 0xFFFFFF00;
   10fb8:	4a2f      	ldr	r2, [pc, #188]	; (11078 <ble_phy_init+0x124>)
   10fba:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    NRF_RADIO->PREFIX0 = (BLE_ACCESS_ADDR_ADV >> 24) & 0xFF;
   10fbe:	228e      	movs	r2, #142	; 0x8e
   10fc0:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524

    /* Configure the CRC registers */
    NRF_RADIO->CRCCNF = RADIO_CRCCNF_SKIPADDR_Msk | RADIO_CRCCNF_LEN_Three;
   10fc4:	f240 1203 	movw	r2, #259	; 0x103
   10fc8:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534

    /* Configure BLE poly */
    NRF_RADIO->CRCPOLY = 0x0100065B;
   10fcc:	4a2b      	ldr	r2, [pc, #172]	; (1107c <ble_phy_init+0x128>)
   10fce:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538

    /* Configure IFS */
    NRF_RADIO->TIFS = BLE_LL_IFS;
   10fd2:	2296      	movs	r2, #150	; 0x96
   10fd4:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544

    /* Captures tx/rx start in timer0 capture 1 */
    NRF_PPI->CHENSET = PPI_CHEN_CH26_Msk;
   10fd8:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
   10fdc:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    NRF_CCM->INTENCLR = 0xffffffff;
   10fe0:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff

    /* Configure IFS */
    NRF_RADIO->TIFS = BLE_LL_IFS;

    /* Captures tx/rx start in timer0 capture 1 */
    NRF_PPI->CHENSET = PPI_CHEN_CH26_Msk;
   10fe4:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    NRF_CCM->INTENCLR = 0xffffffff;
    NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
    NRF_CCM->EVENTS_ERROR = 0;
    memset(g_nrf_encrypt_scratchpad, 0, sizeof(g_nrf_encrypt_scratchpad));
   10fe8:	4621      	mov	r1, r4

    /* Captures tx/rx start in timer0 capture 1 */
    NRF_PPI->CHENSET = PPI_CHEN_CH26_Msk;

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    NRF_CCM->INTENCLR = 0xffffffff;
   10fea:	f8c5 8308 	str.w	r8, [r5, #776]	; 0x308
    NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
    NRF_CCM->EVENTS_ERROR = 0;
    memset(g_nrf_encrypt_scratchpad, 0, sizeof(g_nrf_encrypt_scratchpad));
   10fee:	f44f 7286 	mov.w	r2, #268	; 0x10c
    /* Captures tx/rx start in timer0 capture 1 */
    NRF_PPI->CHENSET = PPI_CHEN_CH26_Msk;

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    NRF_CCM->INTENCLR = 0xffffffff;
    NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
   10ff2:	f8c5 7200 	str.w	r7, [r5, #512]	; 0x200
    NRF_CCM->EVENTS_ERROR = 0;
   10ff6:	f8c5 4108 	str.w	r4, [r5, #264]	; 0x108
    memset(g_nrf_encrypt_scratchpad, 0, sizeof(g_nrf_encrypt_scratchpad));
   10ffa:	f7f8 f80a 	bl	9012 <memset>
#endif

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    g_ble_phy_data.phy_aar_scratch = 0;
    NRF_AAR->IRKPTR = (uint32_t)&g_nrf_irk_list[0];
   10ffe:	4b20      	ldr	r3, [pc, #128]	; (11080 <ble_phy_init+0x12c>)
    NRF_CCM->EVENTS_ERROR = 0;
    memset(g_nrf_encrypt_scratchpad, 0, sizeof(g_nrf_encrypt_scratchpad));
#endif

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
    g_ble_phy_data.phy_aar_scratch = 0;
   11000:	60f4      	str	r4, [r6, #12]
    NRF_AAR->IRKPTR = (uint32_t)&g_nrf_irk_list[0];
   11002:	f8c5 3508 	str.w	r3, [r5, #1288]	; 0x508
    NRF_AAR->INTENCLR = 0xffffffff;
   11006:	f8c5 8308 	str.w	r8, [r5, #776]	; 0x308
    NRF_AAR->EVENTS_END = 0;
   1100a:	f8c5 4100 	str.w	r4, [r5, #256]	; 0x100
    NRF_AAR->EVENTS_RESOLVED = 0;
   1100e:	f8c5 4104 	str.w	r4, [r5, #260]	; 0x104
    NRF_AAR->EVENTS_NOTRESOLVED = 0;
   11012:	f8c5 4108 	str.w	r4, [r5, #264]	; 0x108
    NRF_AAR->NIRK = 0;
   11016:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   1101a:	4d1a      	ldr	r5, [pc, #104]	; (11084 <ble_phy_init+0x130>)
#endif

    /* Set isr in vector table and enable interrupt */
    NVIC_SetPriority(RADIO_IRQn, 0);
    NVIC_SetVector(RADIO_IRQn, (uint32_t)ble_phy_isr);
   1101c:	491a      	ldr	r1, [pc, #104]	; (11088 <ble_phy_init+0x134>)
   1101e:	f885 4301 	strb.w	r4, [r5, #769]	; 0x301
   11022:	4638      	mov	r0, r7
   11024:	f7f8 fa7c 	bl	9520 <NVIC_SetVector>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
   11028:	2302      	movs	r3, #2
   1102a:	602b      	str	r3, [r5, #0]
    NVIC_EnableIRQ(RADIO_IRQn);

    /* Register phy statistics */
    if (!g_ble_phy_data.phy_stats_initialized) {
   1102c:	7835      	ldrb	r5, [r6, #0]
   1102e:	b995      	cbnz	r5, 11056 <ble_phy_init+0x102>
        rc = stats_init_and_reg(STATS_HDR(ble_phy_stats),
   11030:	4b16      	ldr	r3, [pc, #88]	; (1108c <ble_phy_init+0x138>)
   11032:	9301      	str	r3, [sp, #4]
   11034:	9500      	str	r5, [sp, #0]
   11036:	4816      	ldr	r0, [pc, #88]	; (11090 <ble_phy_init+0x13c>)
   11038:	2104      	movs	r1, #4
   1103a:	220e      	movs	r2, #14
   1103c:	462b      	mov	r3, r5
   1103e:	f00c f985 	bl	1d34c <stats_init_and_reg>
                                STATS_SIZE_INIT_PARMS(ble_phy_stats,
                                                      STATS_SIZE_32),
                                STATS_NAME_INIT_PARMS(ble_phy_stats),
                                "ble_phy");
        assert(rc == 0);
   11042:	b130      	cbz	r0, 11052 <ble_phy_init+0xfe>
   11044:	4813      	ldr	r0, [pc, #76]	; (11094 <ble_phy_init+0x140>)
   11046:	f240 2183 	movw	r1, #643	; 0x283
   1104a:	462a      	mov	r2, r5
   1104c:	462b      	mov	r3, r5
   1104e:	f7f8 fe3f 	bl	9cd0 <__assert_func>

        g_ble_phy_data.phy_stats_initialized  = 1;
   11052:	7037      	strb	r7, [r6, #0]
   11054:	e000      	b.n	11058 <ble_phy_init+0x104>
    }

    return 0;
   11056:	4620      	mov	r0, r4
}
   11058:	b002      	add	sp, #8
   1105a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1105e:	bf00      	nop
   11060:	20003834 	.word	0x20003834
   11064:	4000f000 	.word	0x4000f000
   11068:	20003854 	.word	0x20003854
   1106c:	40001000 	.word	0x40001000
   11070:	00100108 	.word	0x00100108
   11074:	020300ff 	.word	0x020300ff
   11078:	89bed600 	.word	0x89bed600
   1107c:	0100065b 	.word	0x0100065b
   11080:	200037f0 	.word	0x200037f0
   11084:	e000e100 	.word	0xe000e100
   11088:	00011259 	.word	0x00011259
   1108c:	0001f324 	.word	0x0001f324
   11090:	20003960 	.word	0x20003960
   11094:	0001f32c 	.word	0x0001f32c

00011098 <ble_phy_encrypt_enable>:
 * @param is_master
 */
void
ble_phy_encrypt_enable(uint64_t pkt_counter, uint8_t *iv, uint8_t *key,
                       uint8_t is_master)
{
   11098:	b5f0      	push	{r4, r5, r6, r7, lr}
    memcpy(g_nrf_ccm_data.key, key, 16);
   1109a:	4d10      	ldr	r5, [pc, #64]	; (110dc <ble_phy_encrypt_enable+0x44>)
   1109c:	f103 0610 	add.w	r6, r3, #16
   110a0:	462c      	mov	r4, r5
   110a2:	f853 7b04 	ldr.w	r7, [r3], #4
   110a6:	f845 7b04 	str.w	r7, [r5], #4
   110aa:	42b3      	cmp	r3, r6
   110ac:	d1f9      	bne.n	110a2 <ble_phy_encrypt_enable+0xa>
    g_nrf_ccm_data.pkt_counter = pkt_counter;
   110ae:	6120      	str	r0, [r4, #16]
   110b0:	6161      	str	r1, [r4, #20]
    memcpy(g_nrf_ccm_data.iv, iv, 8);
   110b2:	6813      	ldr	r3, [r2, #0]
   110b4:	f8c4 3019 	str.w	r3, [r4, #25]
   110b8:	6853      	ldr	r3, [r2, #4]
   110ba:	4a09      	ldr	r2, [pc, #36]	; (110e0 <ble_phy_encrypt_enable+0x48>)
   110bc:	6053      	str	r3, [r2, #4]
    g_nrf_ccm_data.dir_bit = is_master;
   110be:	f89d 3014 	ldrb.w	r3, [sp, #20]
   110c2:	7623      	strb	r3, [r4, #24]
    g_ble_phy_data.phy_encrypted = 1;
   110c4:	4b07      	ldr	r3, [pc, #28]	; (110e4 <ble_phy_encrypt_enable+0x4c>)
   110c6:	2201      	movs	r2, #1
   110c8:	719a      	strb	r2, [r3, #6]
    /* Enable the module (AAR cannot be on while CCM on) */
    NRF_AAR->ENABLE = AAR_ENABLE_ENABLE_Disabled;
   110ca:	4b07      	ldr	r3, [pc, #28]	; (110e8 <ble_phy_encrypt_enable+0x50>)
   110cc:	2200      	movs	r2, #0
   110ce:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   110d2:	2202      	movs	r2, #2
   110d4:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
   110d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   110da:	bf00      	nop
   110dc:	200039a4 	.word	0x200039a4
   110e0:	200039bd 	.word	0x200039bd
   110e4:	20003834 	.word	0x20003834
   110e8:	4000f000 	.word	0x4000f000

000110ec <ble_phy_encrypt_set_pkt_cntr>:
}

void
ble_phy_encrypt_set_pkt_cntr(uint64_t pkt_counter, int dir)
{
    g_nrf_ccm_data.pkt_counter = pkt_counter;
   110ec:	4b02      	ldr	r3, [pc, #8]	; (110f8 <ble_phy_encrypt_set_pkt_cntr+0xc>)
   110ee:	6118      	str	r0, [r3, #16]
   110f0:	6159      	str	r1, [r3, #20]
    g_nrf_ccm_data.dir_bit = dir;
   110f2:	761a      	strb	r2, [r3, #24]
   110f4:	4770      	bx	lr
   110f6:	bf00      	nop
   110f8:	200039a4 	.word	0x200039a4

000110fc <ble_phy_encrypt_disable>:
}

void
ble_phy_encrypt_disable(void)
{
    NRF_PPI->CHENCLR = (PPI_CHEN_CH24_Msk | PPI_CHEN_CH25_Msk);
   110fc:	4b07      	ldr	r3, [pc, #28]	; (1111c <ble_phy_encrypt_disable+0x20>)
   110fe:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
   11102:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    NRF_CCM->TASKS_STOP = 1;
   11106:	4a06      	ldr	r2, [pc, #24]	; (11120 <ble_phy_encrypt_disable+0x24>)
   11108:	2301      	movs	r3, #1
   1110a:	6093      	str	r3, [r2, #8]
    NRF_CCM->EVENTS_ERROR = 0;
   1110c:	2300      	movs	r3, #0
   1110e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   11112:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500

    g_ble_phy_data.phy_encrypted = 0;
   11116:	4a03      	ldr	r2, [pc, #12]	; (11124 <ble_phy_encrypt_disable+0x28>)
   11118:	7193      	strb	r3, [r2, #6]
   1111a:	4770      	bx	lr
   1111c:	4001f000 	.word	0x4001f000
   11120:	4000f000 	.word	0x4000f000
   11124:	20003834 	.word	0x20003834

00011128 <ble_phy_set_txend_cb>:

void
ble_phy_set_txend_cb(ble_phy_tx_end_func txend_cb, void *arg)
{
    /* Set transmit end callback and arg */
    g_ble_phy_data.txend_cb = txend_cb;
   11128:	4b01      	ldr	r3, [pc, #4]	; (11130 <ble_phy_set_txend_cb+0x8>)
   1112a:	61d8      	str	r0, [r3, #28]
    g_ble_phy_data.txend_arg = arg;
   1112c:	6199      	str	r1, [r3, #24]
   1112e:	4770      	bx	lr
   11130:	20003834 	.word	0x20003834

00011134 <ble_phy_txpwr_set>:
 */
int
ble_phy_txpwr_set(int dbm)
{
    /* Check valid range */
    assert(dbm <= BLE_PHY_MAX_PWR_DBM);
   11134:	280a      	cmp	r0, #10
 *
 * @return int 0: success; anything else is an error
 */
int
ble_phy_txpwr_set(int dbm)
{
   11136:	b508      	push	{r3, lr}
    /* Check valid range */
    assert(dbm <= BLE_PHY_MAX_PWR_DBM);
   11138:	dd06      	ble.n	11148 <ble_phy_txpwr_set+0x14>
   1113a:	2200      	movs	r2, #0
   1113c:	480a      	ldr	r0, [pc, #40]	; (11168 <ble_phy_txpwr_set+0x34>)
   1113e:	f240 3199 	movw	r1, #921	; 0x399
   11142:	4613      	mov	r3, r2
   11144:	f7f8 fdc4 	bl	9cd0 <__assert_func>
   11148:	f06f 0327 	mvn.w	r3, #39	; 0x27
   1114c:	4298      	cmp	r0, r3
   1114e:	bfb8      	it	lt
   11150:	4618      	movlt	r0, r3
   11152:	2804      	cmp	r0, #4
        if (dbm < NRF_TX_PWR_MIN_DBM) {
            dbm = NRF_TX_PWR_MIN_DBM;
        }
    }

    NRF_RADIO->TXPOWER = dbm;
   11154:	4b05      	ldr	r3, [pc, #20]	; (1116c <ble_phy_txpwr_set+0x38>)
   11156:	bfa8      	it	ge
   11158:	2004      	movge	r0, #4
   1115a:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    g_ble_phy_data.phy_txpwr_dbm = dbm;
   1115e:	4b04      	ldr	r3, [pc, #16]	; (11170 <ble_phy_txpwr_set+0x3c>)
   11160:	7058      	strb	r0, [r3, #1]

    return 0;
}
   11162:	2000      	movs	r0, #0
   11164:	bd08      	pop	{r3, pc}
   11166:	bf00      	nop
   11168:	0001f32c 	.word	0x0001f32c
   1116c:	40001000 	.word	0x40001000
   11170:	20003834 	.word	0x20003834

00011174 <ble_phy_setchan>:
ble_phy_setchan(uint8_t chan, uint32_t access_addr, uint32_t crcinit)
{
    uint8_t freq;
    uint32_t prefix;

    assert(chan < BLE_PHY_NUM_CHANS);
   11174:	2827      	cmp	r0, #39	; 0x27
 *
 * @return int 0: success; PHY error code otherwise
 */
int
ble_phy_setchan(uint8_t chan, uint32_t access_addr, uint32_t crcinit)
{
   11176:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t freq;
    uint32_t prefix;

    assert(chan < BLE_PHY_NUM_CHANS);
   11178:	d906      	bls.n	11188 <ble_phy_setchan+0x14>
   1117a:	2200      	movs	r2, #0
   1117c:	4822      	ldr	r0, [pc, #136]	; (11208 <ble_phy_setchan+0x94>)
   1117e:	f240 31cb 	movw	r1, #971	; 0x3cb
   11182:	4613      	mov	r3, r2
   11184:	f7f8 fda4 	bl	9cd0 <__assert_func>
    if (chan >= BLE_PHY_NUM_CHANS) {
        return BLE_PHY_ERR_INV_PARAM;
    }

    /* Get correct frequency */
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
   11188:	2824      	cmp	r0, #36	; 0x24
   1118a:	4e20      	ldr	r6, [pc, #128]	; (1120c <ble_phy_setchan+0x98>)
   1118c:	4d20      	ldr	r5, [pc, #128]	; (11210 <ble_phy_setchan+0x9c>)
   1118e:	d81f      	bhi.n	111d0 <ble_phy_setchan+0x5c>
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
                   (BLE_PHY_CHAN_SPACING_MHZ * (chan + 1));
        }

        /* Set current access address */
        g_ble_phy_data.phy_access_address = access_addr;
   11190:	6131      	str	r1, [r6, #16]

        /* Configure logical address 1 and crcinit */
        prefix = NRF_RADIO->PREFIX0;
   11192:	f8d5 4524 	ldr.w	r4, [r5, #1316]	; 0x524
        return BLE_PHY_ERR_INV_PARAM;
    }

    /* Get correct frequency */
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
        if (chan < 11) {
   11196:	280a      	cmp	r0, #10
        g_ble_phy_data.phy_access_address = access_addr;

        /* Configure logical address 1 and crcinit */
        prefix = NRF_RADIO->PREFIX0;
        prefix &= 0xffff00ff;
        prefix |= ((access_addr >> 24) & 0xFF) << 8;
   11198:	ea4f 6711 	mov.w	r7, r1, lsr #24
        /* Set current access address */
        g_ble_phy_data.phy_access_address = access_addr;

        /* Configure logical address 1 and crcinit */
        prefix = NRF_RADIO->PREFIX0;
        prefix &= 0xffff00ff;
   1119c:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
        prefix |= ((access_addr >> 24) & 0xFF) << 8;
        NRF_RADIO->BASE1 = (access_addr << 8) & 0xFFFFFF00;
   111a0:	ea4f 2101 	mov.w	r1, r1, lsl #8
   111a4:	f8c5 1520 	str.w	r1, [r5, #1312]	; 0x520

    /* Get correct frequency */
    if (chan < BLE_PHY_NUM_DATA_CHANS) {
        if (chan < 11) {
            /* Data channel 0 starts at 2404. 0 - 10 are contiguous */
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
   111a8:	bf98      	it	ls
   111aa:	1c83      	addls	r3, r0, #2
        prefix = NRF_RADIO->PREFIX0;
        prefix &= 0xffff00ff;
        prefix |= ((access_addr >> 24) & 0xFF) << 8;
        NRF_RADIO->BASE1 = (access_addr << 8) & 0xFFFFFF00;
        NRF_RADIO->PREFIX0 = prefix;
        NRF_RADIO->TXADDRESS = 1;
   111ac:	f04f 0101 	mov.w	r1, #1
            /* Data channel 0 starts at 2404. 0 - 10 are contiguous */
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
                   (BLE_PHY_CHAN_SPACING_MHZ * chan);
        } else {
            /* Data channel 11 starts at 2428. 0 - 10 are contiguous */
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
   111b0:	bf88      	it	hi
   111b2:	1cc3      	addhi	r3, r0, #3
        g_ble_phy_data.phy_access_address = access_addr;

        /* Configure logical address 1 and crcinit */
        prefix = NRF_RADIO->PREFIX0;
        prefix &= 0xffff00ff;
        prefix |= ((access_addr >> 24) & 0xFF) << 8;
   111b4:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
        NRF_RADIO->BASE1 = (access_addr << 8) & 0xFFFFFF00;
        NRF_RADIO->PREFIX0 = prefix;
   111b8:	f8c5 4524 	str.w	r4, [r5, #1316]	; 0x524
            /* Data channel 0 starts at 2404. 0 - 10 are contiguous */
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
                   (BLE_PHY_CHAN_SPACING_MHZ * chan);
        } else {
            /* Data channel 11 starts at 2428. 0 - 10 are contiguous */
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
   111bc:	005b      	lsls	r3, r3, #1
        prefix = NRF_RADIO->PREFIX0;
        prefix &= 0xffff00ff;
        prefix |= ((access_addr >> 24) & 0xFF) << 8;
        NRF_RADIO->BASE1 = (access_addr << 8) & 0xFFFFFF00;
        NRF_RADIO->PREFIX0 = prefix;
        NRF_RADIO->TXADDRESS = 1;
   111be:	f8c5 152c 	str.w	r1, [r5, #1324]	; 0x52c
        NRF_RADIO->RXADDRESSES = (1 << 1);
   111c2:	2102      	movs	r1, #2
   111c4:	f8c5 1530 	str.w	r1, [r5, #1328]	; 0x530
            /* Data channel 0 starts at 2404. 0 - 10 are contiguous */
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
                   (BLE_PHY_CHAN_SPACING_MHZ * chan);
        } else {
            /* Data channel 11 starts at 2428. 0 - 10 are contiguous */
            freq = (BLE_PHY_DATA_CHAN0_FREQ_MHZ - 2400) +
   111c8:	b2db      	uxtb	r3, r3
        prefix |= ((access_addr >> 24) & 0xFF) << 8;
        NRF_RADIO->BASE1 = (access_addr << 8) & 0xFFFFFF00;
        NRF_RADIO->PREFIX0 = prefix;
        NRF_RADIO->TXADDRESS = 1;
        NRF_RADIO->RXADDRESSES = (1 << 1);
        NRF_RADIO->CRCINIT = crcinit;
   111ca:	f8c5 253c 	str.w	r2, [r5, #1340]	; 0x53c
   111ce:	e012      	b.n	111f6 <ble_phy_setchan+0x82>
    } else {
        if (chan == 37) {
   111d0:	2825      	cmp	r0, #37	; 0x25
   111d2:	d004      	beq.n	111de <ble_phy_setchan+0x6a>
        } else if (chan == 38) {
            /* This advertising channel is at 2426 MHz */
            freq = BLE_PHY_CHAN_SPACING_MHZ * 13;
        } else {
            /* This advertising channel is at 2480 MHz */
            freq = BLE_PHY_CHAN_SPACING_MHZ * 40;
   111d4:	2826      	cmp	r0, #38	; 0x26
   111d6:	bf0c      	ite	eq
   111d8:	231a      	moveq	r3, #26
   111da:	2350      	movne	r3, #80	; 0x50
   111dc:	e000      	b.n	111e0 <ble_phy_setchan+0x6c>
        NRF_RADIO->TXADDRESS = 1;
        NRF_RADIO->RXADDRESSES = (1 << 1);
        NRF_RADIO->CRCINIT = crcinit;
    } else {
        if (chan == 37) {
            freq = BLE_PHY_CHAN_SPACING_MHZ;
   111de:	2302      	movs	r3, #2
            /* This advertising channel is at 2480 MHz */
            freq = BLE_PHY_CHAN_SPACING_MHZ * 40;
        }

        /* Logical adddress 0 preconfigured */
        NRF_RADIO->TXADDRESS = 0;
   111e0:	2200      	movs	r2, #0
   111e2:	f8c5 252c 	str.w	r2, [r5, #1324]	; 0x52c
        NRF_RADIO->RXADDRESSES = (1 << 0);
   111e6:	2201      	movs	r2, #1
   111e8:	f8c5 2530 	str.w	r2, [r5, #1328]	; 0x530
        NRF_RADIO->CRCINIT = BLE_LL_CRCINIT_ADV;
   111ec:	4a09      	ldr	r2, [pc, #36]	; (11214 <ble_phy_setchan+0xa0>)
   111ee:	f8c5 253c 	str.w	r2, [r5, #1340]	; 0x53c

        /* Set current access address */
        g_ble_phy_data.phy_access_address = BLE_ACCESS_ADDR_ADV;
   111f2:	4a09      	ldr	r2, [pc, #36]	; (11218 <ble_phy_setchan+0xa4>)
   111f4:	6132      	str	r2, [r6, #16]
    }

    /* Set the frequency and the data whitening initial value */
    g_ble_phy_data.phy_chan = chan;
    NRF_RADIO->FREQUENCY = freq;
   111f6:	4a06      	ldr	r2, [pc, #24]	; (11210 <ble_phy_setchan+0x9c>)
        /* Set current access address */
        g_ble_phy_data.phy_access_address = BLE_ACCESS_ADDR_ADV;
    }

    /* Set the frequency and the data whitening initial value */
    g_ble_phy_data.phy_chan = chan;
   111f8:	70b0      	strb	r0, [r6, #2]
    NRF_RADIO->FREQUENCY = freq;
   111fa:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    NRF_RADIO->DATAWHITEIV = chan;
   111fe:	f8c2 0554 	str.w	r0, [r2, #1364]	; 0x554

    ble_ll_log(BLE_LL_LOG_ID_PHY_SETCHAN, chan, freq, access_addr);

    return 0;
}
   11202:	2000      	movs	r0, #0
   11204:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   11206:	bf00      	nop
   11208:	0001f32c 	.word	0x0001f32c
   1120c:	20003834 	.word	0x20003834
   11210:	40001000 	.word	0x40001000
   11214:	00555555 	.word	0x00555555
   11218:	8e89bed6 	.word	0x8e89bed6

0001121c <ble_phy_disable>:
void
ble_phy_disable(void)
{
    ble_ll_log(BLE_LL_LOG_ID_PHY_DISABLE, g_ble_phy_data.phy_state, 0, 0);

    NRF_RADIO->INTENCLR = NRF_RADIO_IRQ_MASK_ALL;
   1121c:	4b0b      	ldr	r3, [pc, #44]	; (1124c <ble_phy_disable+0x30>)
   1121e:	f243 42ff 	movw	r2, #13567	; 0x34ff
   11222:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    NRF_RADIO->SHORTS = 0;
    NRF_RADIO->TASKS_DISABLE = 1;
   11226:	2101      	movs	r1, #1
ble_phy_disable(void)
{
    ble_ll_log(BLE_LL_LOG_ID_PHY_DISABLE, g_ble_phy_data.phy_state, 0, 0);

    NRF_RADIO->INTENCLR = NRF_RADIO_IRQ_MASK_ALL;
    NRF_RADIO->SHORTS = 0;
   11228:	2200      	movs	r2, #0
   1122a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    NRF_RADIO->TASKS_DISABLE = 1;
   1122e:	6119      	str	r1, [r3, #16]
    NRF_PPI->CHENCLR = PPI_CHEN_CH23_Msk | PPI_CHEN_CH21_Msk | PPI_CHEN_CH20_Msk;
   11230:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
   11234:	f44f 0130 	mov.w	r1, #11534336	; 0xb00000
   11238:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
   1123c:	4b04      	ldr	r3, [pc, #16]	; (11250 <ble_phy_disable+0x34>)
   1123e:	2102      	movs	r1, #2
   11240:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    NVIC_ClearPendingIRQ(RADIO_IRQn);
    g_ble_phy_data.phy_state = BLE_PHY_STATE_IDLE;
   11244:	4b03      	ldr	r3, [pc, #12]	; (11254 <ble_phy_disable+0x38>)
   11246:	70da      	strb	r2, [r3, #3]
   11248:	4770      	bx	lr
   1124a:	bf00      	nop
   1124c:	40001000 	.word	0x40001000
   11250:	e000e100 	.word	0xe000e100
   11254:	20003834 	.word	0x20003834

00011258 <ble_phy_isr>:
    STATS_INC(ble_phy_stats, rx_starts);
}

static void
ble_phy_isr(void)
{
   11258:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint32_t irq_en;

    /* Read irq register to determine which interrupts are enabled */
    irq_en = NRF_RADIO->INTENCLR;
   1125c:	4b8e      	ldr	r3, [pc, #568]	; (11498 <ble_phy_isr+0x240>)
   1125e:	f8d3 6308 	ldr.w	r6, [r3, #776]	; 0x308

    /* Check for disabled event. This only happens for transmits now */
    if ((irq_en & RADIO_INTENCLR_DISABLED_Msk) && NRF_RADIO->EVENTS_DISABLED) {
   11262:	06f2      	lsls	r2, r6, #27
   11264:	d557      	bpl.n	11316 <ble_phy_isr+0xbe>
   11266:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
   1126a:	2a00      	cmp	r2, #0
   1126c:	d053      	beq.n	11316 <ble_phy_isr+0xbe>
    uint8_t transition;
    uint8_t txlen;
    uint32_t wfr_time;

    /* Better be in TX state! */
    assert(g_ble_phy_data.phy_state == BLE_PHY_STATE_TX);
   1126e:	4d8b      	ldr	r5, [pc, #556]	; (1149c <ble_phy_isr+0x244>)
   11270:	78ea      	ldrb	r2, [r5, #3]
   11272:	2a02      	cmp	r2, #2
   11274:	d003      	beq.n	1127e <ble_phy_isr+0x26>
   11276:	488a      	ldr	r0, [pc, #552]	; (114a0 <ble_phy_isr+0x248>)
   11278:	f44f 719e 	mov.w	r1, #316	; 0x13c
   1127c:	e042      	b.n	11304 <ble_phy_isr+0xac>
    /* Log the event */
    ble_ll_log(BLE_LL_LOG_ID_PHY_TXEND, (g_ble_phy_txrx_buf[0] >> 8) & 0xFF,
               g_ble_phy_data.phy_encrypted, NRF_TIMER0->CC[1]);

    /* Clear events and clear interrupt on disabled event */
    NRF_RADIO->EVENTS_DISABLED = 0;
   1127e:	2200      	movs	r2, #0
    NRF_RADIO->INTENCLR = RADIO_INTENCLR_DISABLED_Msk;
   11280:	2110      	movs	r1, #16
    /* Log the event */
    ble_ll_log(BLE_LL_LOG_ID_PHY_TXEND, (g_ble_phy_txrx_buf[0] >> 8) & 0xFF,
               g_ble_phy_data.phy_encrypted, NRF_TIMER0->CC[1]);

    /* Clear events and clear interrupt on disabled event */
    NRF_RADIO->EVENTS_DISABLED = 0;
   11282:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    NRF_RADIO->INTENCLR = RADIO_INTENCLR_DISABLED_Msk;
   11286:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    NRF_RADIO->EVENTS_END = 0;
   1128a:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    wfr_time = NRF_RADIO->SHORTS;
   1128e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    /*
     * XXX: not sure what to do. We had a HW error during transmission.
     * For now I just count a stat but continue on like all is good.
     */
    if (g_ble_phy_data.phy_encrypted) {
   11292:	79ab      	ldrb	r3, [r5, #6]
   11294:	b14b      	cbz	r3, 112aa <ble_phy_isr+0x52>
        if (NRF_CCM->EVENTS_ERROR) {
   11296:	4983      	ldr	r1, [pc, #524]	; (114a4 <ble_phy_isr+0x24c>)
   11298:	f8d1 3108 	ldr.w	r3, [r1, #264]	; 0x108
   1129c:	b12b      	cbz	r3, 112aa <ble_phy_isr+0x52>
            STATS_INC(ble_phy_stats, tx_hw_err);
   1129e:	4882      	ldr	r0, [pc, #520]	; (114a8 <ble_phy_isr+0x250>)
   112a0:	6c03      	ldr	r3, [r0, #64]	; 0x40
   112a2:	3301      	adds	r3, #1
   112a4:	6403      	str	r3, [r0, #64]	; 0x40
            NRF_CCM->EVENTS_ERROR = 0;
   112a6:	f8c1 2108 	str.w	r2, [r1, #264]	; 0x108
        }
    }
#endif

    transition = g_ble_phy_data.phy_transition;
   112aa:	792b      	ldrb	r3, [r5, #4]
    if (transition == BLE_PHY_TRANSITION_TX_RX) {
   112ac:	2b02      	cmp	r3, #2
   112ae:	d120      	bne.n	112f2 <ble_phy_isr+0x9a>
        /* Packet pointer needs to be reset. */
        if (g_ble_phy_data.rxpdu != NULL) {
   112b0:	4b7a      	ldr	r3, [pc, #488]	; (1149c <ble_phy_isr+0x244>)
   112b2:	695b      	ldr	r3, [r3, #20]
   112b4:	b113      	cbz	r3, 112bc <ble_phy_isr+0x64>
            ble_phy_rx_xcvr_setup();
   112b6:	f7ff fdc1 	bl	10e3c <ble_phy_rx_xcvr_setup>
   112ba:	e005      	b.n	112c8 <ble_phy_isr+0x70>
        } else {
            /* Disable the phy */
            STATS_INC(ble_phy_stats, no_bufs);
   112bc:	4a7a      	ldr	r2, [pc, #488]	; (114a8 <ble_phy_isr+0x250>)
   112be:	6b53      	ldr	r3, [r2, #52]	; 0x34
   112c0:	3301      	adds	r3, #1
   112c2:	6353      	str	r3, [r2, #52]	; 0x34
            ble_phy_disable();
   112c4:	f7ff ffaa 	bl	1121c <ble_phy_disable>

        /*
         * Enable the wait for response timer. Note that cc #1 on
         * timer 0 contains the transmit start time
         */
        txlen = g_ble_phy_data.phy_tx_pyld_len;
   112c8:	7a2c      	ldrb	r4, [r5, #8]
        if (txlen && g_ble_phy_data.phy_encrypted) {
   112ca:	b124      	cbz	r4, 112d6 <ble_phy_isr+0x7e>
   112cc:	4b73      	ldr	r3, [pc, #460]	; (1149c <ble_phy_isr+0x244>)
   112ce:	799b      	ldrb	r3, [r3, #6]
   112d0:	b10b      	cbz	r3, 112d6 <ble_phy_isr+0x7e>
            txlen += BLE_LL_DATA_MIC_LEN;
   112d2:	3404      	adds	r4, #4
   112d4:	b2e4      	uxtb	r4, r4
        }
        wfr_time = NRF_TIMER0->CC[1] - BLE_TX_LEN_USECS_M(NRF_RX_START_OFFSET);
   112d6:	4b75      	ldr	r3, [pc, #468]	; (114ac <ble_phy_isr+0x254>)
        wfr_time += BLE_TX_DUR_USECS_M(txlen);
        wfr_time += cputime_usecs_to_ticks(BLE_LL_WFR_USECS);
   112d8:	20de      	movs	r0, #222	; 0xde
         */
        txlen = g_ble_phy_data.phy_tx_pyld_len;
        if (txlen && g_ble_phy_data.phy_encrypted) {
            txlen += BLE_LL_DATA_MIC_LEN;
        }
        wfr_time = NRF_TIMER0->CC[1] - BLE_TX_LEN_USECS_M(NRF_RX_START_OFFSET);
   112da:	f8d3 7544 	ldr.w	r7, [r3, #1348]	; 0x544
        wfr_time += BLE_TX_DUR_USECS_M(txlen);
        wfr_time += cputime_usecs_to_ticks(BLE_LL_WFR_USECS);
   112de:	f7f7 fce9 	bl	8cb4 <cputime_usecs_to_ticks>
         */
        txlen = g_ble_phy_data.phy_tx_pyld_len;
        if (txlen && g_ble_phy_data.phy_encrypted) {
            txlen += BLE_LL_DATA_MIC_LEN;
        }
        wfr_time = NRF_TIMER0->CC[1] - BLE_TX_LEN_USECS_M(NRF_RX_START_OFFSET);
   112e2:	3f28      	subs	r7, #40	; 0x28
   112e4:	4438      	add	r0, r7
        wfr_time += BLE_TX_DUR_USECS_M(txlen);
   112e6:	340a      	adds	r4, #10
        wfr_time += cputime_usecs_to_ticks(BLE_LL_WFR_USECS);
        ble_ll_wfr_enable(wfr_time);
   112e8:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
   112ec:	f7f9 fe18 	bl	af20 <ble_ll_wfr_enable>
   112f0:	e00c      	b.n	1130c <ble_phy_isr+0xb4>
    } else {
        /* Disable automatic TXEN */
        NRF_PPI->CHENCLR = PPI_CHEN_CH20_Msk;
   112f2:	4a6f      	ldr	r2, [pc, #444]	; (114b0 <ble_phy_isr+0x258>)
   112f4:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
   112f8:	f8c2 1508 	str.w	r1, [r2, #1288]	; 0x508
        assert(transition == BLE_PHY_TRANSITION_NONE);
   112fc:	b133      	cbz	r3, 1130c <ble_phy_isr+0xb4>
   112fe:	4868      	ldr	r0, [pc, #416]	; (114a0 <ble_phy_isr+0x248>)
   11300:	f240 116f 	movw	r1, #367	; 0x16f
   11304:	2200      	movs	r2, #0
   11306:	4613      	mov	r3, r2
   11308:	f7f8 fce2 	bl	9cd0 <__assert_func>
    }

    /* Call transmit end callback */
    if (g_ble_phy_data.txend_cb) {
   1130c:	69eb      	ldr	r3, [r5, #28]
   1130e:	b113      	cbz	r3, 11316 <ble_phy_isr+0xbe>
        g_ble_phy_data.txend_cb(g_ble_phy_data.txend_arg);
   11310:	4a62      	ldr	r2, [pc, #392]	; (1149c <ble_phy_isr+0x244>)
   11312:	6990      	ldr	r0, [r2, #24]
   11314:	4798      	blx	r3
    if ((irq_en & RADIO_INTENCLR_DISABLED_Msk) && NRF_RADIO->EVENTS_DISABLED) {
        ble_phy_tx_end_isr();
    }

    /* We get this if we have started to receive a frame */
    if ((irq_en & RADIO_INTENCLR_ADDRESS_Msk) && NRF_RADIO->EVENTS_ADDRESS) {
   11316:	07b3      	lsls	r3, r6, #30
   11318:	d553      	bpl.n	113c2 <ble_phy_isr+0x16a>
   1131a:	4b5f      	ldr	r3, [pc, #380]	; (11498 <ble_phy_isr+0x240>)
   1131c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   11320:	2a00      	cmp	r2, #0
   11322:	d04e      	beq.n	113c2 <ble_phy_isr+0x16a>

    /* Clear events and clear interrupt */
    NRF_RADIO->EVENTS_ADDRESS = 0;
    NRF_RADIO->INTENCLR = RADIO_INTENCLR_ADDRESS_Msk;

    assert(g_ble_phy_data.rxpdu != NULL);
   11324:	4f5d      	ldr	r7, [pc, #372]	; (1149c <ble_phy_isr+0x244>)
    int rc;
    uint32_t state;
    struct ble_mbuf_hdr *ble_hdr;

    /* Clear events and clear interrupt */
    NRF_RADIO->EVENTS_ADDRESS = 0;
   11326:	2200      	movs	r2, #0
    NRF_RADIO->INTENCLR = RADIO_INTENCLR_ADDRESS_Msk;

    assert(g_ble_phy_data.rxpdu != NULL);
   11328:	697d      	ldr	r5, [r7, #20]
    int rc;
    uint32_t state;
    struct ble_mbuf_hdr *ble_hdr;

    /* Clear events and clear interrupt */
    NRF_RADIO->EVENTS_ADDRESS = 0;
   1132a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    NRF_RADIO->INTENCLR = RADIO_INTENCLR_ADDRESS_Msk;
   1132e:	2202      	movs	r2, #2
   11330:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

    assert(g_ble_phy_data.rxpdu != NULL);
   11334:	b925      	cbnz	r5, 11340 <ble_phy_isr+0xe8>
   11336:	485a      	ldr	r0, [pc, #360]	; (114a0 <ble_phy_isr+0x248>)
   11338:	f240 11d3 	movw	r1, #467	; 0x1d3
   1133c:	462a      	mov	r2, r5
   1133e:	e7e2      	b.n	11306 <ble_phy_isr+0xae>

    /* Wait to get 1st byte of frame */
    while (1) {
        state = NRF_RADIO->STATE;
   11340:	4c55      	ldr	r4, [pc, #340]	; (11498 <ble_phy_isr+0x240>)
   11342:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
        if (NRF_RADIO->EVENTS_BCMATCH != 0) {
   11346:	f8d4 2128 	ldr.w	r2, [r4, #296]	; 0x128
   1134a:	b942      	cbnz	r2, 1135e <ble_phy_isr+0x106>

        /*
         * If state is disabled, we should have the BCMATCH. If not,
         * something is wrong!
         */
        if (state == RADIO_STATE_STATE_Disabled) {
   1134c:	2b00      	cmp	r3, #0
   1134e:	d1f7      	bne.n	11340 <ble_phy_isr+0xe8>
            NRF_RADIO->INTENCLR = NRF_RADIO_IRQ_MASK_ALL;
   11350:	f243 42ff 	movw	r2, #13567	; 0x34ff
   11354:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
            NRF_RADIO->SHORTS = 0;
   11358:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
   1135c:	e031      	b.n	113c2 <ble_phy_isr+0x16a>
        }
    }

    /* Initialize flags, channel and state in ble header at rx start */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
    ble_hdr->rxinfo.flags = ble_ll_state_get();
   1135e:	f7f9 fec7 	bl	b0f0 <ble_ll_state_get>
    ble_hdr->rxinfo.channel = g_ble_phy_data.phy_chan;
    ble_hdr->rxinfo.handle = 0;
   11362:	f04f 0800 	mov.w	r8, #0
    }

    /* Initialize flags, channel and state in ble header at rx start */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
    ble_hdr->rxinfo.flags = ble_ll_state_get();
    ble_hdr->rxinfo.channel = g_ble_phy_data.phy_chan;
   11366:	78b9      	ldrb	r1, [r7, #2]
    ble_hdr->rxinfo.handle = 0;
    ble_hdr->beg_cputime = NRF_TIMER0->CC[1] -
   11368:	4b50      	ldr	r3, [pc, #320]	; (114ac <ble_phy_isr+0x254>)
        }
    }

    /* Initialize flags, channel and state in ble header at rx start */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
    ble_hdr->rxinfo.flags = ble_ll_state_get();
   1136a:	7628      	strb	r0, [r5, #24]
    ble_hdr->rxinfo.channel = g_ble_phy_data.phy_chan;
   1136c:	7669      	strb	r1, [r5, #25]
    ble_hdr->rxinfo.handle = 0;
   1136e:	f885 801a 	strb.w	r8, [r5, #26]
    ble_hdr->beg_cputime = NRF_TIMER0->CC[1] -
   11372:	f8d3 3544 	ldr.w	r3, [r3, #1348]	; 0x544
        BLE_TX_LEN_USECS_M(NRF_RX_START_OFFSET);

    /* Call Link Layer receive start function */
    rc = ble_ll_rx_start(g_ble_phy_data.rxpdu, g_ble_phy_data.phy_chan);
   11376:	6978      	ldr	r0, [r7, #20]
    }

    /* Initialize flags, channel and state in ble header at rx start */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
    ble_hdr->rxinfo.flags = ble_ll_state_get();
    ble_hdr->rxinfo.channel = g_ble_phy_data.phy_chan;
   11378:	f8df 9120 	ldr.w	r9, [pc, #288]	; 1149c <ble_phy_isr+0x244>
    ble_hdr->rxinfo.handle = 0;
    ble_hdr->beg_cputime = NRF_TIMER0->CC[1] -
   1137c:	3b28      	subs	r3, #40	; 0x28
   1137e:	61eb      	str	r3, [r5, #28]
        BLE_TX_LEN_USECS_M(NRF_RX_START_OFFSET);

    /* Call Link Layer receive start function */
    rc = ble_ll_rx_start(g_ble_phy_data.rxpdu, g_ble_phy_data.phy_chan);
   11380:	f7f9 fe04 	bl	af8c <ble_ll_rx_start>
    if (rc >= 0) {
   11384:	4540      	cmp	r0, r8
   11386:	4d48      	ldr	r5, [pc, #288]	; (114a8 <ble_phy_isr+0x250>)
   11388:	db13      	blt.n	113b2 <ble_phy_isr+0x15a>
        /* Set rx started flag and enable rx end ISR */
        g_ble_phy_data.phy_rx_started = 1;
   1138a:	2301      	movs	r3, #1
   1138c:	f889 3005 	strb.w	r3, [r9, #5]
        NRF_RADIO->INTENSET = RADIO_INTENSET_END_Msk;
   11390:	2308      	movs	r3, #8
   11392:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
        /* Must start aar if we need to  */
        if (g_ble_phy_data.phy_privacy) {
   11396:	f899 3007 	ldrb.w	r3, [r9, #7]
   1139a:	b17b      	cbz	r3, 113bc <ble_phy_isr+0x164>
            NRF_RADIO->EVENTS_BCMATCH = 0;
            NRF_PPI->CHENSET = PPI_CHEN_CH23_Msk;
   1139c:	4b44      	ldr	r3, [pc, #272]	; (114b0 <ble_phy_isr+0x258>)
        NRF_RADIO->INTENSET = RADIO_INTENSET_END_Msk;

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
        /* Must start aar if we need to  */
        if (g_ble_phy_data.phy_privacy) {
            NRF_RADIO->EVENTS_BCMATCH = 0;
   1139e:	f8c4 8128 	str.w	r8, [r4, #296]	; 0x128
            NRF_PPI->CHENSET = PPI_CHEN_CH23_Msk;
   113a2:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   113a6:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            NRF_RADIO->BCC = (BLE_DEV_ADDR_LEN + BLE_LL_PDU_HDR_LEN) * 8;
   113aa:	2340      	movs	r3, #64	; 0x40
   113ac:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
   113b0:	e004      	b.n	113bc <ble_phy_isr+0x164>
        }
#endif
    } else {
        /* Disable PHY */
        ble_phy_disable();
   113b2:	f7ff ff33 	bl	1121c <ble_phy_disable>
        STATS_INC(ble_phy_stats, rx_aborts);
   113b6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   113b8:	3301      	adds	r3, #1
   113ba:	626b      	str	r3, [r5, #36]	; 0x24
    }

    /* Count rx starts */
    STATS_INC(ble_phy_stats, rx_starts);
   113bc:	6a2b      	ldr	r3, [r5, #32]
   113be:	3301      	adds	r3, #1
   113c0:	622b      	str	r3, [r5, #32]
    if ((irq_en & RADIO_INTENCLR_ADDRESS_Msk) && NRF_RADIO->EVENTS_ADDRESS) {
        ble_phy_rx_start_isr();
    }

    /* Receive packet end (we dont enable this for transmit) */
    if ((irq_en & RADIO_INTENCLR_END_Msk) && NRF_RADIO->EVENTS_END) {
   113c2:	f016 0f08 	tst.w	r6, #8
   113c6:	4c38      	ldr	r4, [pc, #224]	; (114a8 <ble_phy_isr+0x250>)
   113c8:	d05e      	beq.n	11488 <ble_phy_isr+0x230>
   113ca:	4b33      	ldr	r3, [pc, #204]	; (11498 <ble_phy_isr+0x240>)
   113cc:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
   113d0:	2a00      	cmp	r2, #0
   113d2:	d059      	beq.n	11488 <ble_phy_isr+0x230>
    uint8_t crcok;
    struct os_mbuf *rxpdu;
    struct ble_mbuf_hdr *ble_hdr;

    /* Clear events and clear interrupt */
    NRF_RADIO->EVENTS_END = 0;
   113d4:	2200      	movs	r2, #0
   113d6:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    NRF_RADIO->INTENCLR = RADIO_INTENCLR_END_Msk;
   113da:	2208      	movs	r2, #8
   113dc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

    /* Disable automatic RXEN */
    NRF_PPI->CHENCLR = PPI_CHEN_CH21_Msk;
   113e0:	4a33      	ldr	r2, [pc, #204]	; (114b0 <ble_phy_isr+0x258>)

    /* Set RSSI and CRC status flag in header */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
   113e2:	4d2e      	ldr	r5, [pc, #184]	; (1149c <ble_phy_isr+0x244>)
    /* Clear events and clear interrupt */
    NRF_RADIO->EVENTS_END = 0;
    NRF_RADIO->INTENCLR = RADIO_INTENCLR_END_Msk;

    /* Disable automatic RXEN */
    NRF_PPI->CHENCLR = PPI_CHEN_CH21_Msk;
   113e4:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
   113e8:	f8c2 1508 	str.w	r1, [r2, #1288]	; 0x508

    /* Set RSSI and CRC status flag in header */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
   113ec:	6968      	ldr	r0, [r5, #20]
    assert(NRF_RADIO->EVENTS_RSSIEND != 0);
   113ee:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c

    /* Disable automatic RXEN */
    NRF_PPI->CHENCLR = PPI_CHEN_CH21_Msk;

    /* Set RSSI and CRC status flag in header */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
   113f2:	f100 0118 	add.w	r1, r0, #24
    assert(NRF_RADIO->EVENTS_RSSIEND != 0);
   113f6:	b91a      	cbnz	r2, 11400 <ble_phy_isr+0x1a8>
   113f8:	4829      	ldr	r0, [pc, #164]	; (114a0 <ble_phy_isr+0x248>)
   113fa:	f44f 71c5 	mov.w	r1, #394	; 0x18a
   113fe:	e782      	b.n	11306 <ble_phy_isr+0xae>
    ble_hdr->rxinfo.rssi = -1 * NRF_RADIO->RSSISAMPLE;
   11400:	f8d3 2548 	ldr.w	r2, [r3, #1352]	; 0x548
   11404:	4252      	negs	r2, r2
   11406:	76c2      	strb	r2, [r0, #27]

    dptr = g_ble_phy_data.rxpdu->om_data;

    /* Count PHY crc errors and valid packets */
    crcok = (uint8_t)NRF_RADIO->CRCSTATUS;
   11408:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    /* Set RSSI and CRC status flag in header */
    ble_hdr = BLE_MBUF_HDR_PTR(g_ble_phy_data.rxpdu);
    assert(NRF_RADIO->EVENTS_RSSIEND != 0);
    ble_hdr->rxinfo.rssi = -1 * NRF_RADIO->RSSISAMPLE;

    dptr = g_ble_phy_data.rxpdu->om_data;
   1140c:	6802      	ldr	r2, [r0, #0]

    /* Count PHY crc errors and valid packets */
    crcok = (uint8_t)NRF_RADIO->CRCSTATUS;
    if (!crcok) {
   1140e:	f013 0fff 	tst.w	r3, #255	; 0xff
   11412:	d103      	bne.n	1141c <ble_phy_isr+0x1c4>
        STATS_INC(ble_phy_stats, rx_crc_err);
   11414:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   11416:	3301      	adds	r3, #1
   11418:	62e3      	str	r3, [r4, #44]	; 0x2c
   1141a:	e026      	b.n	1146a <ble_phy_isr+0x212>
    } else {
        STATS_INC(ble_phy_stats, rx_valid);
   1141c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1141e:	3301      	adds	r3, #1
   11420:	62a3      	str	r3, [r4, #40]	; 0x28
        ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_CRC_OK;
   11422:	7e03      	ldrb	r3, [r0, #24]
   11424:	f063 067f 	orn	r6, r3, #127	; 0x7f
   11428:	7606      	strb	r6, [r0, #24]
#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
        if (g_ble_phy_data.phy_encrypted) {
   1142a:	79ae      	ldrb	r6, [r5, #6]
   1142c:	b1ee      	cbz	r6, 1146a <ble_phy_isr+0x212>
            /* Only set MIC failure flag if frame is not zero length */
            if ((dptr[1] != 0) && (NRF_CCM->MICSTATUS == 0)) {
   1142e:	7857      	ldrb	r7, [r2, #1]
   11430:	4e1c      	ldr	r6, [pc, #112]	; (114a4 <ble_phy_isr+0x24c>)
   11432:	b12f      	cbz	r7, 11440 <ble_phy_isr+0x1e8>
   11434:	f8d6 7400 	ldr.w	r7, [r6, #1024]	; 0x400
   11438:	b917      	cbnz	r7, 11440 <ble_phy_isr+0x1e8>
                ble_hdr->rxinfo.flags |= BLE_MBUF_HDR_F_MIC_FAILURE;
   1143a:	f063 035f 	orn	r3, r3, #95	; 0x5f
   1143e:	7603      	strb	r3, [r0, #24]
             * XXX: not sure how to deal with this. This should not
             * be a MIC failure but we should not hand it up. I guess
             * this is just some form of rx error and that is how we
             * handle it? For now, just set CRC error flags
             */
            if (NRF_CCM->EVENTS_ERROR) {
   11440:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
   11444:	b133      	cbz	r3, 11454 <ble_phy_isr+0x1fc>
                STATS_INC(ble_phy_stats, rx_hw_err);
   11446:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   11448:	3301      	adds	r3, #1
   1144a:	63e3      	str	r3, [r4, #60]	; 0x3c
                ble_hdr->rxinfo.flags &= ~BLE_MBUF_HDR_F_CRC_OK;
   1144c:	7e03      	ldrb	r3, [r0, #24]
   1144e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   11452:	7603      	strb	r3, [r0, #24]
            /*
             * XXX: This is a total hack work-around for now but I dont
             * know what else to do. If ENDCRYPT is not set and we are
             * encrypted we need to not trust this frame and drop it.
             */
            if (NRF_CCM->EVENTS_ENDCRYPT == 0) {
   11454:	4b13      	ldr	r3, [pc, #76]	; (114a4 <ble_phy_isr+0x24c>)
   11456:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   1145a:	b933      	cbnz	r3, 1146a <ble_phy_isr+0x212>
                STATS_INC(ble_phy_stats, rx_hw_err);
   1145c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1145e:	3301      	adds	r3, #1
   11460:	63e3      	str	r3, [r4, #60]	; 0x3c
                ble_hdr->rxinfo.flags &= ~BLE_MBUF_HDR_F_CRC_OK;
   11462:	7e03      	ldrb	r3, [r0, #24]
   11464:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   11468:	7603      	strb	r3, [r0, #24]
#endif
    }

    /* Call Link Layer receive payload function */
    rxpdu = g_ble_phy_data.rxpdu;
    g_ble_phy_data.rxpdu = NULL;
   1146a:	2300      	movs	r3, #0
   1146c:	616b      	str	r3, [r5, #20]
    /*
     * XXX: This is a horrible ugly hack to deal with the RAM S1 byte
     * that is not sent over the air but is present here. Simply move the
     * data pointer to deal with it. Fix this later.
     */
    dptr[2] = dptr[1];
   1146e:	7853      	ldrb	r3, [r2, #1]
   11470:	7093      	strb	r3, [r2, #2]
    dptr[1] = dptr[0];
   11472:	7813      	ldrb	r3, [r2, #0]
   11474:	7053      	strb	r3, [r2, #1]
    rxpdu->om_data += 1;
   11476:	6803      	ldr	r3, [r0, #0]
   11478:	3301      	adds	r3, #1
   1147a:	6003      	str	r3, [r0, #0]

    rc = ble_ll_rx_end(rxpdu, ble_hdr);
   1147c:	f7f9 fdcc 	bl	b018 <ble_ll_rx_end>
    if (rc < 0) {
   11480:	2800      	cmp	r0, #0
   11482:	da01      	bge.n	11488 <ble_phy_isr+0x230>
        ble_phy_disable();
   11484:	f7ff feca 	bl	1121c <ble_phy_disable>
    if ((irq_en & RADIO_INTENCLR_END_Msk) && NRF_RADIO->EVENTS_END) {
        ble_phy_rx_end_isr();
    }

    /* Ensures IRQ is cleared */
    irq_en = NRF_RADIO->SHORTS;
   11488:	4b03      	ldr	r3, [pc, #12]	; (11498 <ble_phy_isr+0x240>)
   1148a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200

    /* Count # of interrupts */
    STATS_INC(ble_phy_stats, phy_isrs);
   1148e:	68e3      	ldr	r3, [r4, #12]
   11490:	3301      	adds	r3, #1
   11492:	60e3      	str	r3, [r4, #12]
   11494:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11498:	40001000 	.word	0x40001000
   1149c:	20003834 	.word	0x20003834
   114a0:	0001f32c 	.word	0x0001f32c
   114a4:	4000f000 	.word	0x4000f000
   114a8:	20003960 	.word	0x20003960
   114ac:	40008000 	.word	0x40008000
   114b0:	4001f000 	.word	0x4001f000

000114b4 <ble_phy_rx>:
 *
 * @return int 0: success; BLE Phy error code otherwise
 */
int
ble_phy_rx(void)
{
   114b4:	b538      	push	{r3, r4, r5, lr}
    /* Check radio state */
    nrf_wait_disabled();
    if (NRF_RADIO->STATE != RADIO_STATE_STATE_Disabled) {
   114b6:	4c17      	ldr	r4, [pc, #92]	; (11514 <ble_phy_rx+0x60>)
 */
int
ble_phy_rx(void)
{
    /* Check radio state */
    nrf_wait_disabled();
   114b8:	f7ff fcb0 	bl	10e1c <nrf_wait_disabled>
    if (NRF_RADIO->STATE != RADIO_STATE_STATE_Disabled) {
   114bc:	f8d4 3550 	ldr.w	r3, [r4, #1360]	; 0x550
   114c0:	b13b      	cbz	r3, 114d2 <ble_phy_rx+0x1e>
        ble_phy_disable();
   114c2:	f7ff feab 	bl	1121c <ble_phy_disable>
        STATS_INC(ble_phy_stats, radio_state_errs);
   114c6:	4a14      	ldr	r2, [pc, #80]	; (11518 <ble_phy_rx+0x64>)
   114c8:	6b93      	ldr	r3, [r2, #56]	; 0x38
   114ca:	3301      	adds	r3, #1
   114cc:	6393      	str	r3, [r2, #56]	; 0x38
        return BLE_PHY_ERR_RADIO_STATE;
   114ce:	2001      	movs	r0, #1
   114d0:	bd38      	pop	{r3, r4, r5, pc}
static struct os_mbuf *
ble_phy_rxpdu_get(void)
{
    struct os_mbuf *m;

    m = g_ble_phy_data.rxpdu;
   114d2:	4b12      	ldr	r3, [pc, #72]	; (1151c <ble_phy_rx+0x68>)
    if (m == NULL) {
   114d4:	695b      	ldr	r3, [r3, #20]
   114d6:	b193      	cbz	r3, 114fe <ble_phy_rx+0x4a>
    if (ble_phy_rxpdu_get() == NULL) {
        return BLE_PHY_ERR_NO_BUFS;
    }

    /* Make sure all interrupts are disabled */
    NRF_RADIO->INTENCLR = NRF_RADIO_IRQ_MASK_ALL;
   114d8:	f243 43ff 	movw	r3, #13567	; 0x34ff

    /* Clear events prior to enabling receive */
    NRF_RADIO->EVENTS_END = 0;
   114dc:	2500      	movs	r5, #0
    if (ble_phy_rxpdu_get() == NULL) {
        return BLE_PHY_ERR_NO_BUFS;
    }

    /* Make sure all interrupts are disabled */
    NRF_RADIO->INTENCLR = NRF_RADIO_IRQ_MASK_ALL;
   114de:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308

    /* Clear events prior to enabling receive */
    NRF_RADIO->EVENTS_END = 0;
   114e2:	f8c4 510c 	str.w	r5, [r4, #268]	; 0x10c
    NRF_RADIO->EVENTS_DISABLED = 0;
   114e6:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110

    /* Setup for rx */
    ble_phy_rx_xcvr_setup();
   114ea:	f7ff fca7 	bl	10e3c <ble_phy_rx_xcvr_setup>

    /* Start the receive task in the radio if not automatically going to rx */
    if ((NRF_PPI->CHEN & PPI_CHEN_CH21_Msk) == 0) {
   114ee:	4b0c      	ldr	r3, [pc, #48]	; (11520 <ble_phy_rx+0x6c>)
   114f0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	; 0x500
   114f4:	f413 1300 	ands.w	r3, r3, #2097152	; 0x200000
   114f8:	d007      	beq.n	1150a <ble_phy_rx+0x56>
        NRF_RADIO->TASKS_RXEN = 1;
    }

    ble_ll_log(BLE_LL_LOG_ID_PHY_RX, g_ble_phy_data.phy_encrypted, 0, 0);

    return 0;
   114fa:	4628      	mov	r0, r5
   114fc:	bd38      	pop	{r3, r4, r5, pc}
   114fe:	f7ff fd13 	bl	10f28 <ble_phy_rxpdu_get.part.0>
        STATS_INC(ble_phy_stats, radio_state_errs);
        return BLE_PHY_ERR_RADIO_STATE;
    }

    /* If no pdu, get one */
    if (ble_phy_rxpdu_get() == NULL) {
   11502:	2800      	cmp	r0, #0
   11504:	d1e8      	bne.n	114d8 <ble_phy_rx+0x24>
        return BLE_PHY_ERR_NO_BUFS;
   11506:	2004      	movs	r0, #4
    }

    ble_ll_log(BLE_LL_LOG_ID_PHY_RX, g_ble_phy_data.phy_encrypted, 0, 0);

    return 0;
}
   11508:	bd38      	pop	{r3, r4, r5, pc}
    /* Setup for rx */
    ble_phy_rx_xcvr_setup();

    /* Start the receive task in the radio if not automatically going to rx */
    if ((NRF_PPI->CHEN & PPI_CHEN_CH21_Msk) == 0) {
        NRF_RADIO->TASKS_RXEN = 1;
   1150a:	4a02      	ldr	r2, [pc, #8]	; (11514 <ble_phy_rx+0x60>)
   1150c:	2101      	movs	r1, #1
   1150e:	6051      	str	r1, [r2, #4]
    }

    ble_ll_log(BLE_LL_LOG_ID_PHY_RX, g_ble_phy_data.phy_encrypted, 0, 0);

    return 0;
   11510:	4618      	mov	r0, r3
   11512:	bd38      	pop	{r3, r4, r5, pc}
   11514:	40001000 	.word	0x40001000
   11518:	20003960 	.word	0x20003960
   1151c:	20003834 	.word	0x20003834
   11520:	4001f000 	.word	0x4001f000

00011524 <ble_phy_tx_set_start_time>:
int
ble_phy_tx_set_start_time(uint32_t cputime)
{
    int rc;

    NRF_TIMER0->CC[0] = cputime;
   11524:	4b0e      	ldr	r3, [pc, #56]	; (11560 <ble_phy_tx_set_start_time+0x3c>)
 *
 * @return int
 */
int
ble_phy_tx_set_start_time(uint32_t cputime)
{
   11526:	b510      	push	{r4, lr}
    int rc;

    NRF_TIMER0->CC[0] = cputime;
   11528:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    NRF_PPI->CHENSET = PPI_CHEN_CH20_Msk;
   1152c:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
   11530:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
   11534:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    NRF_PPI->CHENCLR = PPI_CHEN_CH21_Msk;
   11538:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   1153c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
 *
 * @return int
 */
int
ble_phy_tx_set_start_time(uint32_t cputime)
{
   11540:	4604      	mov	r4, r0
    int rc;

    NRF_TIMER0->CC[0] = cputime;
    NRF_PPI->CHENSET = PPI_CHEN_CH20_Msk;
    NRF_PPI->CHENCLR = PPI_CHEN_CH21_Msk;
    if ((int32_t)(cputime_get32() - cputime) >= 0) {
   11542:	f7f7 fcfb 	bl	8f3c <cputime_get32>
   11546:	1b00      	subs	r0, r0, r4
   11548:	2800      	cmp	r0, #0
   1154a:	db07      	blt.n	1155c <ble_phy_tx_set_start_time+0x38>
        STATS_INC(ble_phy_stats, tx_late);
   1154c:	4a05      	ldr	r2, [pc, #20]	; (11564 <ble_phy_tx_set_start_time+0x40>)
   1154e:	6993      	ldr	r3, [r2, #24]
   11550:	3301      	adds	r3, #1
   11552:	6193      	str	r3, [r2, #24]
        ble_phy_disable();
   11554:	f7ff fe62 	bl	1121c <ble_phy_disable>
        rc =  BLE_PHY_ERR_TX_LATE;
   11558:	2005      	movs	r0, #5
   1155a:	bd10      	pop	{r4, pc}
    } else {
        rc = 0;
   1155c:	2000      	movs	r0, #0
    }
    return rc;
}
   1155e:	bd10      	pop	{r4, pc}
   11560:	40008000 	.word	0x40008000
   11564:	20003960 	.word	0x20003960

00011568 <ble_phy_tx>:
    return rc;
}

int
ble_phy_tx(struct os_mbuf *txpdu, uint8_t end_trans)
{
   11568:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1156c:	4688      	mov	r8, r1
    uint32_t state;
    uint32_t shortcuts;
    struct ble_mbuf_hdr *ble_hdr;

    /* Better have a pdu! */
    assert(txpdu != NULL);
   1156e:	4607      	mov	r7, r0
   11570:	b930      	cbnz	r0, 11580 <ble_phy_tx+0x18>
   11572:	483c      	ldr	r0, [pc, #240]	; (11664 <ble_phy_tx+0xfc>)
   11574:	f240 3132 	movw	r1, #818	; 0x332
   11578:	463a      	mov	r2, r7
   1157a:	463b      	mov	r3, r7
   1157c:	f7f8 fba8 	bl	9cd0 <__assert_func>

    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
    payload_len = ble_hdr->txinfo.pyld_len;

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (g_ble_phy_data.phy_encrypted) {
   11580:	4d39      	ldr	r5, [pc, #228]	; (11668 <ble_phy_tx+0x100>)

    /*
     * This check is to make sure that the radio is not in a state where
     * it is moving to disabled state. If so, let it get there.
     */
    nrf_wait_disabled();
   11582:	f7ff fc4b 	bl	10e1c <nrf_wait_disabled>

    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
    payload_len = ble_hdr->txinfo.pyld_len;

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (g_ble_phy_data.phy_encrypted) {
   11586:	79ab      	ldrb	r3, [r5, #6]
     * it is moving to disabled state. If so, let it get there.
     */
    nrf_wait_disabled();

    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
    payload_len = ble_hdr->txinfo.pyld_len;
   11588:	7ebe      	ldrb	r6, [r7, #26]
   1158a:	4938      	ldr	r1, [pc, #224]	; (1166c <ble_phy_tx+0x104>)
   1158c:	4838      	ldr	r0, [pc, #224]	; (11670 <ble_phy_tx+0x108>)

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (g_ble_phy_data.phy_encrypted) {
   1158e:	b1e3      	cbz	r3, 115ca <ble_phy_tx+0x62>
        dptr = (uint8_t *)&g_ble_phy_enc_buf[0];
        NRF_CCM->SHORTS = 1;
   11590:	2301      	movs	r3, #1
   11592:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
        NRF_CCM->INPTR = (uint32_t)&g_ble_phy_enc_buf[0];
   11596:	4c37      	ldr	r4, [pc, #220]	; (11674 <ble_phy_tx+0x10c>)
        NRF_CCM->OUTPTR = (uint32_t)&g_ble_phy_txrx_buf[0];
        NRF_CCM->SCRATCHPTR = (uint32_t)&g_nrf_encrypt_scratchpad[0];
   11598:	4b37      	ldr	r3, [pc, #220]	; (11678 <ble_phy_tx+0x110>)

#if (BLE_LL_CFG_FEAT_LE_ENCRYPTION == 1)
    if (g_ble_phy_data.phy_encrypted) {
        dptr = (uint8_t *)&g_ble_phy_enc_buf[0];
        NRF_CCM->SHORTS = 1;
        NRF_CCM->INPTR = (uint32_t)&g_ble_phy_enc_buf[0];
   1159a:	f8c1 450c 	str.w	r4, [r1, #1292]	; 0x50c
        NRF_CCM->OUTPTR = (uint32_t)&g_ble_phy_txrx_buf[0];
   1159e:	f8c1 0510 	str.w	r0, [r1, #1296]	; 0x510
        NRF_CCM->SCRATCHPTR = (uint32_t)&g_nrf_encrypt_scratchpad[0];
   115a2:	f8c1 3514 	str.w	r3, [r1, #1300]	; 0x514
        NRF_CCM->EVENTS_ERROR = 0;
   115a6:	2300      	movs	r3, #0
   115a8:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
        NRF_CCM->MODE = CCM_MODE_LENGTH_Msk;
   115ac:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
        NRF_CCM->CNFPTR = (uint32_t)&g_nrf_ccm_data;
   115b0:	4b32      	ldr	r3, [pc, #200]	; (1167c <ble_phy_tx+0x114>)
        NRF_CCM->SHORTS = 1;
        NRF_CCM->INPTR = (uint32_t)&g_ble_phy_enc_buf[0];
        NRF_CCM->OUTPTR = (uint32_t)&g_ble_phy_txrx_buf[0];
        NRF_CCM->SCRATCHPTR = (uint32_t)&g_nrf_encrypt_scratchpad[0];
        NRF_CCM->EVENTS_ERROR = 0;
        NRF_CCM->MODE = CCM_MODE_LENGTH_Msk;
   115b2:	f8c1 2504 	str.w	r2, [r1, #1284]	; 0x504
        NRF_CCM->CNFPTR = (uint32_t)&g_nrf_ccm_data;
   115b6:	f8c1 3508 	str.w	r3, [r1, #1288]	; 0x508
        NRF_PPI->CHENCLR = PPI_CHEN_CH25_Msk | PPI_CHEN_CH23_Msk;
   115ba:	4b31      	ldr	r3, [pc, #196]	; (11680 <ble_phy_tx+0x118>)
   115bc:	f04f 7120 	mov.w	r1, #41943040	; 0x2800000
   115c0:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
        NRF_PPI->CHENSET = PPI_CHEN_CH24_Msk;
   115c4:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
   115c8:	e008      	b.n	115dc <ble_phy_tx+0x74>
    } else {
#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
        NRF_PPI->CHENCLR = PPI_CHEN_CH23_Msk;
   115ca:	4b2d      	ldr	r3, [pc, #180]	; (11680 <ble_phy_tx+0x118>)
   115cc:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   115d0:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
        NRF_AAR->IRKPTR = (uint32_t)&g_nrf_irk_list[0];
   115d4:	4b2b      	ldr	r3, [pc, #172]	; (11684 <ble_phy_tx+0x11c>)
   115d6:	f8c1 3508 	str.w	r3, [r1, #1288]	; 0x508
#endif
        dptr = (uint8_t *)&g_ble_phy_txrx_buf[0];
   115da:	4604      	mov	r4, r0
#endif
    dptr = (uint8_t *)&g_ble_phy_txrx_buf[0];
#endif

    /* RAM representation has S0, LENGTH and S1 fields. (3 bytes) */
    dptr[0] = ble_hdr->txinfo.hdr_byte;
   115dc:	7efb      	ldrb	r3, [r7, #27]
   115de:	7023      	strb	r3, [r4, #0]
    dptr[1] = payload_len;
    dptr[2] = 0;
    dptr += 3;
    NRF_RADIO->PACKETPTR = (uint32_t)&g_ble_phy_txrx_buf[0];
   115e0:	4b29      	ldr	r3, [pc, #164]	; (11688 <ble_phy_tx+0x120>)
    dptr = (uint8_t *)&g_ble_phy_txrx_buf[0];
#endif

    /* RAM representation has S0, LENGTH and S1 fields. (3 bytes) */
    dptr[0] = ble_hdr->txinfo.hdr_byte;
    dptr[1] = payload_len;
   115e2:	7066      	strb	r6, [r4, #1]
    dptr[2] = 0;
   115e4:	2200      	movs	r2, #0
    NRF_RADIO->EVENTS_END = 0;
    NRF_RADIO->EVENTS_DISABLED = 0;

    /* Enable shortcuts for transmit start/end. */
    shortcuts = RADIO_SHORTS_END_DISABLE_Msk | RADIO_SHORTS_READY_START_Msk;
    if (end_trans == BLE_PHY_TRANSITION_TX_RX) {
   115e6:	f1b8 0f02 	cmp.w	r8, #2
#endif

    /* RAM representation has S0, LENGTH and S1 fields. (3 bytes) */
    dptr[0] = ble_hdr->txinfo.hdr_byte;
    dptr[1] = payload_len;
    dptr[2] = 0;
   115ea:	70a2      	strb	r2, [r4, #2]
    dptr += 3;
    NRF_RADIO->PACKETPTR = (uint32_t)&g_ble_phy_txrx_buf[0];
   115ec:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504

    /* Clear the ready, end and disabled events */
    NRF_RADIO->EVENTS_READY = 0;
   115f0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    NRF_RADIO->EVENTS_END = 0;
   115f4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    NRF_RADIO->EVENTS_DISABLED = 0;
   115f8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110

    /* Enable shortcuts for transmit start/end. */
    shortcuts = RADIO_SHORTS_END_DISABLE_Msk | RADIO_SHORTS_READY_START_Msk;
    if (end_trans == BLE_PHY_TRANSITION_TX_RX) {
   115fc:	d001      	beq.n	11602 <ble_phy_tx+0x9a>
    NRF_RADIO->EVENTS_READY = 0;
    NRF_RADIO->EVENTS_END = 0;
    NRF_RADIO->EVENTS_DISABLED = 0;

    /* Enable shortcuts for transmit start/end. */
    shortcuts = RADIO_SHORTS_END_DISABLE_Msk | RADIO_SHORTS_READY_START_Msk;
   115fe:	2203      	movs	r2, #3
   11600:	e006      	b.n	11610 <ble_phy_tx+0xa8>
ble_phy_rxpdu_get(void)
{
    struct os_mbuf *m;

    m = g_ble_phy_data.rxpdu;
    if (m == NULL) {
   11602:	696b      	ldr	r3, [r5, #20]
   11604:	b91b      	cbnz	r3, 1160e <ble_phy_tx+0xa6>
   11606:	f7ff fc8f 	bl	10f28 <ble_phy_rxpdu_get.part.0>

    /* Enable shortcuts for transmit start/end. */
    shortcuts = RADIO_SHORTS_END_DISABLE_Msk | RADIO_SHORTS_READY_START_Msk;
    if (end_trans == BLE_PHY_TRANSITION_TX_RX) {
        /* If we are going into receive after this, try to get a buffer. */
        if (ble_phy_rxpdu_get()) {
   1160a:	2800      	cmp	r0, #0
   1160c:	d0f7      	beq.n	115fe <ble_phy_tx+0x96>
            shortcuts |= RADIO_SHORTS_DISABLED_RXEN_Msk;
   1160e:	220b      	movs	r2, #11
        }
    }
    NRF_RADIO->INTENSET = RADIO_INTENSET_DISABLED_Msk;
   11610:	4b1d      	ldr	r3, [pc, #116]	; (11688 <ble_phy_tx+0x120>)
   11612:	2110      	movs	r1, #16
   11614:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
    NRF_RADIO->SHORTS = shortcuts;
   11618:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

    /* Set transmitted payload length */
    g_ble_phy_data.phy_tx_pyld_len = payload_len;
   1161c:	722e      	strb	r6, [r5, #8]

    /* Set the PHY transition */
    g_ble_phy_data.phy_transition = end_trans;
   1161e:	f885 8004 	strb.w	r8, [r5, #4]

    /* If we already started transmitting, abort it! */
    state = NRF_RADIO->STATE;
   11622:	f8d3 3550 	ldr.w	r3, [r3, #1360]	; 0x550
   11626:	4d19      	ldr	r5, [pc, #100]	; (1168c <ble_phy_tx+0x124>)
    if (state != RADIO_STATE_STATE_Tx) {
   11628:	2b0b      	cmp	r3, #11
   1162a:	d012      	beq.n	11652 <ble_phy_tx+0xea>
        /* Copy data from mbuf into transmit buffer */
        os_mbuf_copydata(txpdu, ble_hdr->txinfo.offset, payload_len, dptr);
   1162c:	4632      	mov	r2, r6
   1162e:	1ce3      	adds	r3, r4, #3
   11630:	4638      	mov	r0, r7
   11632:	7e79      	ldrb	r1, [r7, #25]
   11634:	f7f8 fd1c 	bl	a070 <os_mbuf_copydata>

        /* Set phy state to transmitting and count packet statistics */
        g_ble_phy_data.phy_state = BLE_PHY_STATE_TX;
   11638:	4b0b      	ldr	r3, [pc, #44]	; (11668 <ble_phy_tx+0x100>)
   1163a:	2202      	movs	r2, #2
   1163c:	70da      	strb	r2, [r3, #3]
        STATS_INC(ble_phy_stats, tx_good);
   1163e:	692b      	ldr	r3, [r5, #16]
   11640:	3301      	adds	r3, #1
   11642:	612b      	str	r3, [r5, #16]
   11644:	69eb      	ldr	r3, [r5, #28]
   11646:	4413      	add	r3, r2
        STATS_INCN(ble_phy_stats, tx_bytes, payload_len + BLE_LL_PDU_HDR_LEN);
   11648:	441e      	add	r6, r3
   1164a:	61ee      	str	r6, [r5, #28]
        rc = BLE_ERR_SUCCESS;
   1164c:	2000      	movs	r0, #0
   1164e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
        ble_phy_disable();
   11652:	f7ff fde3 	bl	1121c <ble_phy_disable>
        STATS_INC(ble_phy_stats, tx_late);
   11656:	69ab      	ldr	r3, [r5, #24]
   11658:	3301      	adds	r3, #1
   1165a:	61ab      	str	r3, [r5, #24]
        rc = BLE_PHY_ERR_RADIO_STATE;
   1165c:	2001      	movs	r0, #1
    }

    return rc;
}
   1165e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11662:	bf00      	nop
   11664:	0001f32c 	.word	0x0001f32c
   11668:	20003834 	.word	0x20003834
   1166c:	4000f000 	.word	0x4000f000
   11670:	20001fb8 	.word	0x20001fb8
   11674:	20001eb4 	.word	0x20001eb4
   11678:	20003854 	.word	0x20003854
   1167c:	200039a4 	.word	0x200039a4
   11680:	4001f000 	.word	0x4001f000
   11684:	200037f0 	.word	0x200037f0
   11688:	40001000 	.word	0x40001000
   1168c:	20003960 	.word	0x20003960

00011690 <ble_phy_access_addr_get>:

/* Gets the current access address */
uint32_t ble_phy_access_addr_get(void)
{
    return g_ble_phy_data.phy_access_address;
}
   11690:	4b01      	ldr	r3, [pc, #4]	; (11698 <ble_phy_access_addr_get+0x8>)
   11692:	6918      	ldr	r0, [r3, #16]
   11694:	4770      	bx	lr
   11696:	bf00      	nop
   11698:	20003834 	.word	0x20003834

0001169c <ble_phy_rx_started>:
 */
int
ble_phy_rx_started(void)
{
    return g_ble_phy_data.phy_rx_started;
}
   1169c:	4b01      	ldr	r3, [pc, #4]	; (116a4 <ble_phy_rx_started+0x8>)
   1169e:	7958      	ldrb	r0, [r3, #5]
   116a0:	4770      	bx	lr
   116a2:	bf00      	nop
   116a4:	20003834 	.word	0x20003834

000116a8 <ble_phy_max_data_pdu_pyld>:
 */
uint8_t
ble_phy_max_data_pdu_pyld(void)
{
    return BLE_LL_DATA_PDU_MAX_PYLD;
}
   116a8:	20fb      	movs	r0, #251	; 0xfb
   116aa:	4770      	bx	lr

000116ac <ble_phy_resolv_list_enable>:

#if (BLE_LL_CFG_FEAT_LL_PRIVACY == 1)
void
ble_phy_resolv_list_enable(void)
{
    NRF_AAR->NIRK = (uint32_t)g_nrf_num_irks;
   116ac:	4b04      	ldr	r3, [pc, #16]	; (116c0 <ble_phy_resolv_list_enable+0x14>)
   116ae:	781a      	ldrb	r2, [r3, #0]
   116b0:	4b04      	ldr	r3, [pc, #16]	; (116c4 <ble_phy_resolv_list_enable+0x18>)
   116b2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    g_ble_phy_data.phy_privacy = 1;
   116b6:	4b04      	ldr	r3, [pc, #16]	; (116c8 <ble_phy_resolv_list_enable+0x1c>)
   116b8:	2201      	movs	r2, #1
   116ba:	71da      	strb	r2, [r3, #7]
   116bc:	4770      	bx	lr
   116be:	bf00      	nop
   116c0:	200037ec 	.word	0x200037ec
   116c4:	4000f000 	.word	0x4000f000
   116c8:	20003834 	.word	0x20003834

000116cc <ble_phy_resolv_list_disable>:
}

void
ble_phy_resolv_list_disable(void)
{
    g_ble_phy_data.phy_privacy = 0;
   116cc:	4b01      	ldr	r3, [pc, #4]	; (116d4 <ble_phy_resolv_list_disable+0x8>)
   116ce:	2200      	movs	r2, #0
   116d0:	71da      	strb	r2, [r3, #7]
   116d2:	4770      	bx	lr
   116d4:	20003834 	.word	0x20003834

000116d8 <ble_gap_fill_conn_desc>:
 *****************************************************************************/

static void
ble_gap_fill_conn_desc(struct ble_hs_conn *conn,
                       struct ble_gap_conn_desc *desc)
{
   116d8:	b530      	push	{r4, r5, lr}
   116da:	b087      	sub	sp, #28
   116dc:	460c      	mov	r4, r1
    struct ble_hs_conn_addrs addrs;

    ble_hs_conn_addrs(conn, &addrs);
   116de:	a901      	add	r1, sp, #4
 *****************************************************************************/

static void
ble_gap_fill_conn_desc(struct ble_hs_conn *conn,
                       struct ble_gap_conn_desc *desc)
{
   116e0:	4605      	mov	r5, r0
    struct ble_hs_conn_addrs addrs;

    ble_hs_conn_addrs(conn, &addrs);
   116e2:	f003 fe19 	bl	15318 <ble_hs_conn_addrs>

    desc->our_ota_addr_type = addrs.our_ota_addr_type;
   116e6:	f89d 3004 	ldrb.w	r3, [sp, #4]
   116ea:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
    memcpy(desc->our_ota_addr, addrs.our_ota_addr, 6);
   116ee:	9b02      	ldr	r3, [sp, #8]
   116f0:	681a      	ldr	r2, [r3, #0]
   116f2:	f8c4 2016 	str.w	r2, [r4, #22]
   116f6:	889b      	ldrh	r3, [r3, #4]
   116f8:	8363      	strh	r3, [r4, #26]
    desc->our_id_addr_type = addrs.our_id_addr_type;
   116fa:	f89d 3005 	ldrb.w	r3, [sp, #5]
   116fe:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
    memcpy(desc->our_id_addr, addrs.our_id_addr, 6);
   11702:	9b03      	ldr	r3, [sp, #12]
   11704:	681a      	ldr	r2, [r3, #0]
   11706:	6122      	str	r2, [r4, #16]
   11708:	889b      	ldrh	r3, [r3, #4]
   1170a:	82a3      	strh	r3, [r4, #20]
    desc->peer_ota_addr_type = addrs.peer_ota_addr_type;
   1170c:	f89d 3006 	ldrb.w	r3, [sp, #6]
   11710:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    memcpy(desc->peer_ota_addr, addrs.peer_ota_addr, 6);
   11714:	9b04      	ldr	r3, [sp, #16]
   11716:	681a      	ldr	r2, [r3, #0]
   11718:	6062      	str	r2, [r4, #4]
   1171a:	889b      	ldrh	r3, [r3, #4]
   1171c:	8123      	strh	r3, [r4, #8]
    desc->peer_id_addr_type = addrs.peer_id_addr_type;
   1171e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11722:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
    memcpy(desc->peer_id_addr, addrs.peer_id_addr, 6);
   11726:	9b05      	ldr	r3, [sp, #20]
   11728:	681a      	ldr	r2, [r3, #0]
   1172a:	f8c4 200a 	str.w	r2, [r4, #10]
   1172e:	889b      	ldrh	r3, [r3, #4]
   11730:	81e3      	strh	r3, [r4, #14]

    desc->conn_handle = conn->bhc_handle;
   11732:	88ab      	ldrh	r3, [r5, #4]
   11734:	83a3      	strh	r3, [r4, #28]
    desc->conn_itvl = conn->bhc_itvl;
   11736:	8b6b      	ldrh	r3, [r5, #26]
   11738:	83e3      	strh	r3, [r4, #30]
    desc->conn_latency = conn->bhc_latency;
   1173a:	8bab      	ldrh	r3, [r5, #28]
   1173c:	8423      	strh	r3, [r4, #32]
    desc->supervision_timeout = conn->bhc_supervision_timeout;
   1173e:	8beb      	ldrh	r3, [r5, #30]
   11740:	8463      	strh	r3, [r4, #34]	; 0x22
    desc->master_clock_accuracy = conn->bhc_master_clock_accuracy;
   11742:	f895 3020 	ldrb.w	r3, [r5, #32]
   11746:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
    desc->sec_state = conn->bhc_sec_state;
   1174a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
   1174c:	6023      	str	r3, [r4, #0]

    if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
   1174e:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
   11752:	07db      	lsls	r3, r3, #31
        desc->role = BLE_GAP_ROLE_MASTER;
   11754:	bf4c      	ite	mi
   11756:	2300      	movmi	r3, #0
    } else {
        desc->role = BLE_GAP_ROLE_SLAVE;
   11758:	2301      	movpl	r3, #1
   1175a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    }
}
   1175e:	b007      	add	sp, #28
   11760:	bd30      	pop	{r4, r5, pc}

00011762 <ble_gap_conn_cancel_tx>:
 * $cancel                                                                   *
 *****************************************************************************/

static int
ble_gap_conn_cancel_tx(void)
{
   11762:	b507      	push	{r0, r1, r2, lr}
    uint8_t buf[BLE_HCI_CMD_HDR_LEN];
    int rc;

    host_hci_cmd_build_le_create_conn_cancel(buf, sizeof buf);
   11764:	2103      	movs	r1, #3
   11766:	a801      	add	r0, sp, #4
   11768:	f008 f810 	bl	1978c <host_hci_cmd_build_le_create_conn_cancel>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   1176c:	a801      	add	r0, sp, #4
   1176e:	f002 ff5b 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   11772:	b003      	add	sp, #12
   11774:	f85d fb04 	ldr.w	pc, [sp], #4

00011778 <ble_gap_disc_enable_tx>:
 * $discovery procedures                                                     *
 *****************************************************************************/

static int
ble_gap_disc_enable_tx(int enable, int filter_duplicates)
{
   11778:	b507      	push	{r0, r1, r2, lr}
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_SET_SCAN_ENABLE_LEN];
    int rc;

    host_hci_cmd_build_le_set_scan_enable(!!enable, !!filter_duplicates,
   1177a:	3000      	adds	r0, #0
   1177c:	bf18      	it	ne
   1177e:	2001      	movne	r0, #1
   11780:	3100      	adds	r1, #0
   11782:	bf18      	it	ne
   11784:	2101      	movne	r1, #1
   11786:	466a      	mov	r2, sp
   11788:	2305      	movs	r3, #5
   1178a:	f007 ffdf 	bl	1974c <host_hci_cmd_build_le_set_scan_enable>
                                          buf, sizeof buf);
    rc = ble_hci_cmd_tx_empty_ack(buf);
   1178e:	4668      	mov	r0, sp
   11790:	f002 ff4a 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   11794:	b003      	add	sp, #12
   11796:	f85d fb04 	ldr.w	pc, [sp], #4

0001179a <ble_gap_adv_enable_tx>:
 * $stop advertise                                                           *
 *****************************************************************************/

static int
ble_gap_adv_enable_tx(int enable)
{
   1179a:	b507      	push	{r0, r1, r2, lr}
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_SET_ADV_ENABLE_LEN];
    int rc;

    host_hci_cmd_build_le_set_adv_enable(!!enable, buf, sizeof buf);
   1179c:	3000      	adds	r0, #0
   1179e:	bf18      	it	ne
   117a0:	2001      	movne	r0, #1
   117a2:	a901      	add	r1, sp, #4
   117a4:	2204      	movs	r2, #4
   117a6:	f007 ffc5 	bl	19734 <host_hci_cmd_build_le_set_adv_enable>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   117aa:	a801      	add	r0, sp, #4
   117ac:	f002 ff3c 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   117b0:	b003      	add	sp, #12
   117b2:	f85d fb04 	ldr.w	pc, [sp], #4

000117b6 <ble_gap_call_conn_event_cb>:
}


static int
ble_gap_call_conn_event_cb(struct ble_gap_event *event, uint16_t conn_handle)
{
   117b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   117b8:	460c      	mov	r4, r1
   117ba:	4605      	mov	r5, r0
{
    const struct ble_hs_conn *conn;

    BLE_HS_DBG_ASSERT(conn_handle != 0);

    ble_hs_lock();
   117bc:	f002 ffc2 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   117c0:	4620      	mov	r0, r4
   117c2:	f003 fd67 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   117c6:	4604      	mov	r4, r0
   117c8:	b110      	cbz	r0, 117d0 <ble_gap_call_conn_event_cb+0x1a>
        *out_cb = conn->bhc_cb;
   117ca:	6c86      	ldr	r6, [r0, #72]	; 0x48
        *out_cb_arg = conn->bhc_cb_arg;
   117cc:	6cc7      	ldr	r7, [r0, #76]	; 0x4c
   117ce:	e001      	b.n	117d4 <ble_gap_call_conn_event_cb+0x1e>
    } else {
        *out_cb = NULL;
        *out_cb_arg = NULL;
   117d0:	4607      	mov	r7, r0
    conn = ble_hs_conn_find(conn_handle);
    if (conn != NULL) {
        *out_cb = conn->bhc_cb;
        *out_cb_arg = conn->bhc_cb_arg;
    } else {
        *out_cb = NULL;
   117d2:	4606      	mov	r6, r0
        *out_cb_arg = NULL;
    }

    ble_hs_unlock();
   117d4:	f002 ffbe 	bl	14754 <ble_hs_unlock>

    if (conn == NULL) {
   117d8:	b90c      	cbnz	r4, 117de <ble_gap_call_conn_event_cb+0x28>
        return BLE_HS_ENOTCONN;
   117da:	2007      	movs	r0, #7
   117dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (cb != NULL) {
   117de:	b126      	cbz	r6, 117ea <ble_gap_call_conn_event_cb+0x34>
        rc = cb(event, cb_arg);
   117e0:	4628      	mov	r0, r5
   117e2:	4639      	mov	r1, r7
   117e4:	47b0      	blx	r6
    if (rc != 0) {
        return rc;
    }

    rc = ble_gap_call_event_cb(event, cb, cb_arg);
    if (rc != 0) {
   117e6:	b968      	cbnz	r0, 11804 <ble_gap_call_conn_event_cb+0x4e>
   117e8:	e00a      	b.n	11800 <ble_gap_call_conn_event_cb+0x4a>
    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (cb != NULL) {
        rc = cb(event, cb_arg);
    } else {
        if (event->type == BLE_GAP_EVENT_CONN_UPDATE_REQ) {
   117ea:	782b      	ldrb	r3, [r5, #0]
   117ec:	2b04      	cmp	r3, #4
   117ee:	d107      	bne.n	11800 <ble_gap_call_conn_event_cb+0x4a>
            /* Just copy peer parameters back into the reply. */
            *event->conn_update_req.self_params =
                *event->conn_update_req.peer_params;
   117f0:	6869      	ldr	r1, [r5, #4]
    if (cb != NULL) {
        rc = cb(event, cb_arg);
    } else {
        if (event->type == BLE_GAP_EVENT_CONN_UPDATE_REQ) {
            /* Just copy peer parameters back into the reply. */
            *event->conn_update_req.self_params =
   117f2:	68aa      	ldr	r2, [r5, #8]
   117f4:	680b      	ldr	r3, [r1, #0]
   117f6:	6013      	str	r3, [r2, #0]
   117f8:	684b      	ldr	r3, [r1, #4]
   117fa:	6053      	str	r3, [r2, #4]
   117fc:	688b      	ldr	r3, [r1, #8]
   117fe:	6093      	str	r3, [r2, #8]
    rc = ble_gap_call_event_cb(event, cb, cb_arg);
    if (rc != 0) {
        return rc;
    }

    return 0;
   11800:	2000      	movs	r0, #0
   11802:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
}
   11804:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00011808 <ble_gap_master_ticks_until_exp>:
    ble_gap_call_conn_event_cb(&event, conn_handle);
}

static uint32_t
ble_gap_master_ticks_until_exp(void)
{
   11808:	b510      	push	{r4, lr}
    int32_t ticks;

    if (ble_gap_master.op == BLE_GAP_OP_NULL || !ble_gap_master.exp_set) {
   1180a:	4b08      	ldr	r3, [pc, #32]	; (1182c <ble_gap_master_ticks_until_exp+0x24>)
   1180c:	781a      	ldrb	r2, [r3, #0]
   1180e:	b14a      	cbz	r2, 11824 <ble_gap_master_ticks_until_exp+0x1c>
   11810:	785a      	ldrb	r2, [r3, #1]
   11812:	07d2      	lsls	r2, r2, #31
   11814:	d506      	bpl.n	11824 <ble_gap_master_ticks_until_exp+0x1c>
        /* Timer not set; infinity ticks until next event. */
        return BLE_HS_FOREVER;
    }

    ticks = ble_gap_master.exp_os_ticks - os_time_get();
   11816:	685c      	ldr	r4, [r3, #4]
   11818:	f7f8 ffd2 	bl	a7c0 <os_time_get>
   1181c:	1a20      	subs	r0, r4, r0
        /* Timer not expired yet. */
        return ticks;
    }

    /* Timer just expired. */
    return 0;
   1181e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   11822:	bd10      	pop	{r4, pc}
{
    int32_t ticks;

    if (ble_gap_master.op == BLE_GAP_OP_NULL || !ble_gap_master.exp_set) {
        /* Timer not set; infinity ticks until next event. */
        return BLE_HS_FOREVER;
   11824:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
        return ticks;
    }

    /* Timer just expired. */
    return 0;
}
   11828:	bd10      	pop	{r4, pc}
   1182a:	bf00      	nop
   1182c:	20000d94 	.word	0x20000d94

00011830 <ble_gap_slave_ticks_until_exp>:

static uint32_t
ble_gap_slave_ticks_until_exp(void)
{
   11830:	b510      	push	{r4, lr}
    int32_t ticks;

    if (ble_gap_slave.op == BLE_GAP_OP_NULL || !ble_gap_slave.exp_set) {
   11832:	4b08      	ldr	r3, [pc, #32]	; (11854 <ble_gap_slave_ticks_until_exp+0x24>)
   11834:	7d1a      	ldrb	r2, [r3, #20]
   11836:	b14a      	cbz	r2, 1184c <ble_gap_slave_ticks_until_exp+0x1c>
   11838:	7d5a      	ldrb	r2, [r3, #21]
   1183a:	07d2      	lsls	r2, r2, #31
   1183c:	d506      	bpl.n	1184c <ble_gap_slave_ticks_until_exp+0x1c>
        /* Timer not set; infinity ticks until next event. */
        return BLE_HS_FOREVER;
    }

    ticks = ble_gap_slave.exp_os_ticks - os_time_get();
   1183e:	699c      	ldr	r4, [r3, #24]
   11840:	f7f8 ffbe 	bl	a7c0 <os_time_get>
   11844:	1a20      	subs	r0, r4, r0
        /* Timer not expired yet. */
        return ticks;
    }

    /* Timer just expired. */
    return 0;
   11846:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   1184a:	bd10      	pop	{r4, pc}
{
    int32_t ticks;

    if (ble_gap_slave.op == BLE_GAP_OP_NULL || !ble_gap_slave.exp_set) {
        /* Timer not set; infinity ticks until next event. */
        return BLE_HS_FOREVER;
   1184c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
        return ticks;
    }

    /* Timer just expired. */
    return 0;
}
   11850:	bd10      	pop	{r4, pc}
   11852:	bf00      	nop
   11854:	20000d94 	.word	0x20000d94

00011858 <ble_gap_heartbeat_sched>:

static void
ble_gap_heartbeat_sched(void)
{
   11858:	b510      	push	{r4, lr}
    int32_t mst_ticks;
    int32_t slv_ticks;
    int32_t ticks;

    mst_ticks = ble_gap_master_ticks_until_exp();
   1185a:	f7ff ffd5 	bl	11808 <ble_gap_master_ticks_until_exp>
   1185e:	4604      	mov	r4, r0
    slv_ticks = ble_gap_slave_ticks_until_exp();
   11860:	f7ff ffe6 	bl	11830 <ble_gap_slave_ticks_until_exp>
    ticks = min(mst_ticks, slv_ticks);

    ble_hs_heartbeat_sched(ticks);
   11864:	42a0      	cmp	r0, r4
   11866:	bfa8      	it	ge
   11868:	4620      	movge	r0, r4
}
   1186a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

    mst_ticks = ble_gap_master_ticks_until_exp();
    slv_ticks = ble_gap_slave_ticks_until_exp();
    ticks = min(mst_ticks, slv_ticks);

    ble_hs_heartbeat_sched(ticks);
   1186e:	f002 bfcb 	b.w	14808 <ble_hs_heartbeat_sched>
	...

00011874 <ble_gap_adv_finished>:
    ble_hs_unlock();
}

static void
ble_gap_adv_finished(void)
{
   11874:	b570      	push	{r4, r5, r6, lr}
   11876:	b08e      	sub	sp, #56	; 0x38
}

static void
ble_gap_slave_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg)
{
    ble_hs_lock();
   11878:	f002 ff64 	bl	14744 <ble_hs_lock>

    *out_cb = ble_gap_slave.cb;
   1187c:	4b0c      	ldr	r3, [pc, #48]	; (118b0 <ble_gap_adv_finished+0x3c>)

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
    ble_gap_slave.exp_set = 0;
   1187e:	7d5a      	ldrb	r2, [r3, #21]
static void
ble_gap_slave_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg)
{
    ble_hs_lock();

    *out_cb = ble_gap_slave.cb;
   11880:	6a1d      	ldr	r5, [r3, #32]
    *out_cb_arg = ble_gap_slave.cb_arg;
   11882:	6a5e      	ldr	r6, [r3, #36]	; 0x24
}

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
   11884:	2400      	movs	r4, #0
    ble_gap_slave.exp_set = 0;
   11886:	f364 0200 	bfi	r2, r4, #0, #1
}

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
   1188a:	751c      	strb	r4, [r3, #20]
    ble_gap_slave.exp_set = 0;
   1188c:	755a      	strb	r2, [r3, #21]

    *out_cb = ble_gap_slave.cb;
    *out_cb_arg = ble_gap_slave.cb_arg;
    ble_gap_slave_reset_state();

    ble_hs_unlock();
   1188e:	f002 ff61 	bl	14754 <ble_hs_unlock>
    struct ble_gap_event event;
    ble_gap_event_fn *cb;
    void *cb_arg;

    ble_gap_slave_extract_cb(&cb, &cb_arg);
    if (cb != NULL) {
   11892:	b155      	cbz	r5, 118aa <ble_gap_adv_finished+0x36>
        memset(&event, 0, sizeof event);
   11894:	4621      	mov	r1, r4
   11896:	a801      	add	r0, sp, #4
   11898:	2234      	movs	r2, #52	; 0x34
   1189a:	f7f7 fbba 	bl	9012 <memset>
        event.type = BLE_GAP_EVENT_ADV_COMPLETE;
   1189e:	2309      	movs	r3, #9
   118a0:	f88d 3004 	strb.w	r3, [sp, #4]

        cb(&event, cb_arg);
   118a4:	a801      	add	r0, sp, #4
   118a6:	4631      	mov	r1, r6
   118a8:	47a8      	blx	r5
    }
}
   118aa:	b00e      	add	sp, #56	; 0x38
   118ac:	bd70      	pop	{r4, r5, r6, pc}
   118ae:	bf00      	nop
   118b0:	20000d94 	.word	0x20000d94

000118b4 <ble_gap_master_failed>:
 * Called when an error is encountered while the master-connection-fsm is
 * active.
 */
static void
ble_gap_master_failed(int status)
{
   118b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    switch (ble_gap_master.op) {
   118b8:	4c11      	ldr	r4, [pc, #68]	; (11900 <ble_gap_master_failed+0x4c>)
   118ba:	7823      	ldrb	r3, [r4, #0]
   118bc:	2b02      	cmp	r3, #2
 * Called when an error is encountered while the master-connection-fsm is
 * active.
 */
static void
ble_gap_master_failed(int status)
{
   118be:	b08e      	sub	sp, #56	; 0x38
   118c0:	4607      	mov	r7, r0
    switch (ble_gap_master.op) {
   118c2:	d11a      	bne.n	118fa <ble_gap_master_failed+0x46>
    case BLE_GAP_OP_M_CONN:
        STATS_INC(ble_gap_stats, initiate_fail);
   118c4:	4a0f      	ldr	r2, [pc, #60]	; (11904 <ble_gap_master_failed+0x50>)
   118c6:	6c13      	ldr	r3, [r2, #64]	; 0x40
   118c8:	3301      	adds	r3, #1
   118ca:	6413      	str	r3, [r2, #64]	; 0x40

static void
ble_gap_master_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg,
                          int reset_state)
{
    ble_hs_lock();
   118cc:	f002 ff3a 	bl	14744 <ble_hs_lock>

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
    ble_gap_master.exp_set = 0;
   118d0:	7863      	ldrb	r3, [r4, #1]
ble_gap_master_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg,
                          int reset_state)
{
    ble_hs_lock();

    *out_cb = ble_gap_master.cb;
   118d2:	68a6      	ldr	r6, [r4, #8]
    *out_cb_arg = ble_gap_master.cb_arg;
   118d4:	f8d4 800c 	ldr.w	r8, [r4, #12]
}

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
   118d8:	2500      	movs	r5, #0
    ble_gap_master.exp_set = 0;
   118da:	f365 0300 	bfi	r3, r5, #0, #1
}

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
   118de:	7025      	strb	r5, [r4, #0]
    ble_gap_master.exp_set = 0;
   118e0:	7063      	strb	r3, [r4, #1]

    if (reset_state) {
        ble_gap_master_reset_state();
    }

    ble_hs_unlock();
   118e2:	f002 ff37 	bl	14754 <ble_hs_unlock>
    ble_gap_event_fn *cb;
    void *cb_arg;
    int rc;

    ble_gap_master_extract_cb(&cb, &cb_arg, 1);
    if (cb != NULL) {
   118e6:	b146      	cbz	r6, 118fa <ble_gap_master_failed+0x46>
        memset(&event, 0, sizeof event);
   118e8:	4629      	mov	r1, r5
   118ea:	a801      	add	r0, sp, #4
   118ec:	2234      	movs	r2, #52	; 0x34
   118ee:	f7f7 fb90 	bl	9012 <memset>
        event.type = BLE_GAP_EVENT_CONNECT;
        event.connect.status = status;
   118f2:	9702      	str	r7, [sp, #8]

        rc = cb(&event, cb_arg);
   118f4:	a801      	add	r0, sp, #4
   118f6:	4641      	mov	r1, r8
   118f8:	47b0      	blx	r6

    default:
        BLE_HS_DBG_ASSERT(0);
        break;
    }
}
   118fa:	b00e      	add	sp, #56	; 0x38
   118fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11900:	20000d94 	.word	0x20000d94
   11904:	200039c8 	.word	0x200039c8

00011908 <ble_gap_conn_broken>:
    ble_gap_update_notify(conn_handle, status);
}

static void
ble_gap_conn_broken(uint16_t conn_handle, int reason)
{
   11908:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1190c:	b08e      	sub	sp, #56	; 0x38
    struct ble_gap_snapshot snap;
    struct ble_gap_event event;
    int rc;

    memset(&event, 0, sizeof event);
   1190e:	2234      	movs	r2, #52	; 0x34
    ble_gap_update_notify(conn_handle, status);
}

static void
ble_gap_conn_broken(uint16_t conn_handle, int reason)
{
   11910:	4604      	mov	r4, r0
   11912:	460f      	mov	r7, r1
    struct ble_gap_snapshot snap;
    struct ble_gap_event event;
    int rc;

    memset(&event, 0, sizeof event);
   11914:	a801      	add	r0, sp, #4
   11916:	2100      	movs	r1, #0
   11918:	f7f7 fb7b 	bl	9012 <memset>
static int
ble_gap_find_snapshot(uint16_t handle, struct ble_gap_snapshot *snap)
{
    struct ble_hs_conn *conn;

    ble_hs_lock();
   1191c:	f002 ff12 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(handle);
   11920:	4620      	mov	r0, r4
   11922:	f003 fcb7 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   11926:	4605      	mov	r5, r0
   11928:	b128      	cbz	r0, 11936 <ble_gap_conn_broken+0x2e>

static void
ble_gap_conn_to_snapshot(struct ble_hs_conn *conn,
                         struct ble_gap_snapshot *snap)
{
    ble_gap_fill_conn_desc(conn, snap->desc);
   1192a:	a903      	add	r1, sp, #12
   1192c:	f7ff fed4 	bl	116d8 <ble_gap_fill_conn_desc>
    snap->cb = conn->bhc_cb;
   11930:	6cae      	ldr	r6, [r5, #72]	; 0x48
    snap->cb_arg = conn->bhc_cb_arg;
   11932:	f8d5 804c 	ldr.w	r8, [r5, #76]	; 0x4c
    conn = ble_hs_conn_find(handle);
    if (conn != NULL) {
        ble_gap_conn_to_snapshot(conn, snap);
    }

    ble_hs_unlock();
   11936:	f002 ff0d 	bl	14754 <ble_hs_unlock>

    if (conn == NULL) {
   1193a:	b1bd      	cbz	r5, 1196c <ble_gap_conn_broken+0x64>

    /* Indicate the connection termination to each module.  The order matters
     * here: gatts must come before gattc to ensure the application does not
     * get informed of spurious notify-tx events.
     */
    ble_sm_connection_broken(conn_handle);
   1193c:	4620      	mov	r0, r4
   1193e:	f005 fddb 	bl	174f8 <ble_sm_connection_broken>
    ble_gatts_connection_broken(conn_handle);
   11942:	4620      	mov	r0, r4
   11944:	f002 fabe 	bl	13ec4 <ble_gatts_connection_broken>
    ble_gattc_connection_broken(conn_handle);
   11948:	4620      	mov	r0, r4
   1194a:	f001 ff21 	bl	13790 <ble_gattc_connection_broken>

    ble_hs_atomic_conn_delete(conn_handle);
   1194e:	4620      	mov	r0, r4
   11950:	f003 fb8f 	bl	15072 <ble_hs_atomic_conn_delete>

    event.type = BLE_GAP_EVENT_DISCONNECT;
   11954:	2301      	movs	r3, #1
   11956:	f88d 3004 	strb.w	r3, [sp, #4]
    event.disconnect.reason = reason;
   1195a:	9702      	str	r7, [sp, #8]
{
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (cb != NULL) {
   1195c:	b116      	cbz	r6, 11964 <ble_gap_conn_broken+0x5c>
        rc = cb(event, cb_arg);
   1195e:	a801      	add	r0, sp, #4
   11960:	4641      	mov	r1, r8
   11962:	47b0      	blx	r6

    event.type = BLE_GAP_EVENT_DISCONNECT;
    event.disconnect.reason = reason;
    ble_gap_call_event_cb(&event, snap.cb, snap.cb_arg);

    STATS_INC(ble_gap_stats, disconnect);
   11964:	4a03      	ldr	r2, [pc, #12]	; (11974 <ble_gap_conn_broken+0x6c>)
   11966:	6e53      	ldr	r3, [r2, #100]	; 0x64
   11968:	3301      	adds	r3, #1
   1196a:	6653      	str	r3, [r2, #100]	; 0x64
}
   1196c:	b00e      	add	sp, #56	; 0x38
   1196e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11972:	bf00      	nop
   11974:	200039c8 	.word	0x200039c8

00011978 <ble_gap_conn_find>:
 * @return                      0 on success; BLE_HS_ENOTCONN if no matching
 *                                  connection was found.
 */
int
ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
{
   11978:	b538      	push	{r3, r4, r5, lr}
   1197a:	4605      	mov	r5, r0
   1197c:	460c      	mov	r4, r1
    struct ble_hs_conn *conn;

    ble_hs_lock();
   1197e:	f002 fee1 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(handle);
   11982:	4628      	mov	r0, r5
   11984:	f003 fc86 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL && out_desc != NULL) {
   11988:	4605      	mov	r5, r0
   1198a:	b118      	cbz	r0, 11994 <ble_gap_conn_find+0x1c>
   1198c:	b114      	cbz	r4, 11994 <ble_gap_conn_find+0x1c>
        ble_gap_fill_conn_desc(conn, out_desc);
   1198e:	4621      	mov	r1, r4
   11990:	f7ff fea2 	bl	116d8 <ble_gap_fill_conn_desc>
    }

    ble_hs_unlock();
   11994:	f002 fede 	bl	14754 <ble_hs_unlock>

    if (conn == NULL) {
        return BLE_HS_ENOTCONN;
    } else {
        return 0;
   11998:	2d00      	cmp	r5, #0
    }
}
   1199a:	bf0c      	ite	eq
   1199c:	2007      	moveq	r0, #7
   1199e:	2000      	movne	r0, #0
   119a0:	bd38      	pop	{r3, r4, r5, pc}
	...

000119a4 <ble_gap_rx_disconn_complete>:
    return;
#endif

    struct ble_gap_event event;

    STATS_INC(ble_gap_stats, rx_disconnect);
   119a4:	4a11      	ldr	r2, [pc, #68]	; (119ec <ble_gap_rx_disconn_complete+0x48>)
    STATS_INC(ble_gap_stats, disconnect);
}

void
ble_gap_rx_disconn_complete(struct hci_disconn_complete *evt)
{
   119a6:	b530      	push	{r4, r5, lr}
    return;
#endif

    struct ble_gap_event event;

    STATS_INC(ble_gap_stats, rx_disconnect);
   119a8:	6e93      	ldr	r3, [r2, #104]	; 0x68
   119aa:	3301      	adds	r3, #1
   119ac:	6693      	str	r3, [r2, #104]	; 0x68

    if (evt->status == 0) {
   119ae:	7884      	ldrb	r4, [r0, #2]
    STATS_INC(ble_gap_stats, disconnect);
}

void
ble_gap_rx_disconn_complete(struct hci_disconn_complete *evt)
{
   119b0:	b08f      	sub	sp, #60	; 0x3c
   119b2:	4605      	mov	r5, r0

    struct ble_gap_event event;

    STATS_INC(ble_gap_stats, rx_disconnect);

    if (evt->status == 0) {
   119b4:	b93c      	cbnz	r4, 119c6 <ble_gap_rx_disconn_complete+0x22>
        ble_gap_conn_broken(evt->connection_handle,
                            BLE_HS_HCI_ERR(evt->reason));
   119b6:	78e9      	ldrb	r1, [r5, #3]
    struct ble_gap_event event;

    STATS_INC(ble_gap_stats, rx_disconnect);

    if (evt->status == 0) {
        ble_gap_conn_broken(evt->connection_handle,
   119b8:	8800      	ldrh	r0, [r0, #0]
   119ba:	b109      	cbz	r1, 119c0 <ble_gap_rx_disconn_complete+0x1c>
   119bc:	f501 7100 	add.w	r1, r1, #512	; 0x200
   119c0:	f7ff ffa2 	bl	11908 <ble_gap_conn_broken>
   119c4:	e010      	b.n	119e8 <ble_gap_rx_disconn_complete+0x44>
                            BLE_HS_HCI_ERR(evt->reason));
    } else {
        memset(&event, 0, sizeof event);
   119c6:	2100      	movs	r1, #0
   119c8:	a801      	add	r0, sp, #4
   119ca:	2234      	movs	r2, #52	; 0x34
   119cc:	f7f7 fb21 	bl	9012 <memset>
        event.type = BLE_GAP_EVENT_TERM_FAILURE;
        event.term_failure.conn_handle = evt->connection_handle;
        event.term_failure.status = BLE_HS_HCI_ERR(evt->status);
   119d0:	f504 7400 	add.w	r4, r4, #512	; 0x200
    if (evt->status == 0) {
        ble_gap_conn_broken(evt->connection_handle,
                            BLE_HS_HCI_ERR(evt->reason));
    } else {
        memset(&event, 0, sizeof event);
        event.type = BLE_GAP_EVENT_TERM_FAILURE;
   119d4:	2306      	movs	r3, #6
        event.term_failure.conn_handle = evt->connection_handle;
   119d6:	8829      	ldrh	r1, [r5, #0]
    if (evt->status == 0) {
        ble_gap_conn_broken(evt->connection_handle,
                            BLE_HS_HCI_ERR(evt->reason));
    } else {
        memset(&event, 0, sizeof event);
        event.type = BLE_GAP_EVENT_TERM_FAILURE;
   119d8:	f88d 3004 	strb.w	r3, [sp, #4]
        event.term_failure.conn_handle = evt->connection_handle;
        event.term_failure.status = BLE_HS_HCI_ERR(evt->status);
        ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   119dc:	a801      	add	r0, sp, #4
        ble_gap_conn_broken(evt->connection_handle,
                            BLE_HS_HCI_ERR(evt->reason));
    } else {
        memset(&event, 0, sizeof event);
        event.type = BLE_GAP_EVENT_TERM_FAILURE;
        event.term_failure.conn_handle = evt->connection_handle;
   119de:	f8ad 100c 	strh.w	r1, [sp, #12]
        event.term_failure.status = BLE_HS_HCI_ERR(evt->status);
   119e2:	9402      	str	r4, [sp, #8]
        ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   119e4:	f7ff fee7 	bl	117b6 <ble_gap_call_conn_event_cb>
    }
}
   119e8:	b00f      	add	sp, #60	; 0x3c
   119ea:	bd30      	pop	{r4, r5, pc}
   119ec:	200039c8 	.word	0x200039c8

000119f0 <ble_gap_rx_update_complete>:

void
ble_gap_rx_update_complete(struct hci_le_conn_upd_complete *evt)
{
   119f0:	b510      	push	{r4, lr}
#endif

    struct ble_gap_event event;
    struct ble_hs_conn *conn;

    STATS_INC(ble_gap_stats, rx_update_complete);
   119f2:	4a18      	ldr	r2, [pc, #96]	; (11a54 <ble_gap_rx_update_complete+0x64>)
   119f4:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
    }
}

void
ble_gap_rx_update_complete(struct hci_le_conn_upd_complete *evt)
{
   119f6:	b08e      	sub	sp, #56	; 0x38
#endif

    struct ble_gap_event event;
    struct ble_hs_conn *conn;

    STATS_INC(ble_gap_stats, rx_update_complete);
   119f8:	3301      	adds	r3, #1
    }
}

void
ble_gap_rx_update_complete(struct hci_le_conn_upd_complete *evt)
{
   119fa:	4604      	mov	r4, r0
#endif

    struct ble_gap_event event;
    struct ble_hs_conn *conn;

    STATS_INC(ble_gap_stats, rx_update_complete);
   119fc:	66d3      	str	r3, [r2, #108]	; 0x6c

    memset(&event, 0, sizeof event);
   119fe:	2100      	movs	r1, #0
   11a00:	2234      	movs	r2, #52	; 0x34
   11a02:	a801      	add	r0, sp, #4
   11a04:	f7f7 fb05 	bl	9012 <memset>

    ble_hs_lock();
   11a08:	f002 fe9c 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(evt->connection_handle);
   11a0c:	8860      	ldrh	r0, [r4, #2]
   11a0e:	f003 fc41 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   11a12:	b138      	cbz	r0, 11a24 <ble_gap_rx_update_complete+0x34>
        if (evt->status == 0) {
   11a14:	7863      	ldrb	r3, [r4, #1]
   11a16:	b92b      	cbnz	r3, 11a24 <ble_gap_rx_update_complete+0x34>
            conn->bhc_itvl = evt->conn_itvl;
   11a18:	88a3      	ldrh	r3, [r4, #4]
   11a1a:	8343      	strh	r3, [r0, #26]
            conn->bhc_latency = evt->conn_latency;
   11a1c:	88e3      	ldrh	r3, [r4, #6]
   11a1e:	8383      	strh	r3, [r0, #28]
            conn->bhc_supervision_timeout = evt->supervision_timeout;
   11a20:	8923      	ldrh	r3, [r4, #8]
   11a22:	83c3      	strh	r3, [r0, #30]
        }
    }

    conn->bhc_flags &= ~BLE_HS_CONN_F_UPDATE;
   11a24:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
   11a28:	f023 0302 	bic.w	r3, r3, #2
   11a2c:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

    ble_hs_unlock();
   11a30:	f002 fe90 	bl	14754 <ble_hs_unlock>

    event.type = BLE_GAP_EVENT_CONN_UPDATE;
   11a34:	2303      	movs	r3, #3
   11a36:	f88d 3004 	strb.w	r3, [sp, #4]
    event.conn_update.conn_handle = evt->connection_handle;
    event.conn_update.status = BLE_HS_HCI_ERR(evt->status);
   11a3a:	7863      	ldrb	r3, [r4, #1]
    conn->bhc_flags &= ~BLE_HS_CONN_F_UPDATE;

    ble_hs_unlock();

    event.type = BLE_GAP_EVENT_CONN_UPDATE;
    event.conn_update.conn_handle = evt->connection_handle;
   11a3c:	8861      	ldrh	r1, [r4, #2]
   11a3e:	f8ad 100c 	strh.w	r1, [sp, #12]
    event.conn_update.status = BLE_HS_HCI_ERR(evt->status);
   11a42:	b10b      	cbz	r3, 11a48 <ble_gap_rx_update_complete+0x58>
   11a44:	f503 7300 	add.w	r3, r3, #512	; 0x200
    ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   11a48:	a801      	add	r0, sp, #4

    ble_hs_unlock();

    event.type = BLE_GAP_EVENT_CONN_UPDATE;
    event.conn_update.conn_handle = evt->connection_handle;
    event.conn_update.status = BLE_HS_HCI_ERR(evt->status);
   11a4a:	9302      	str	r3, [sp, #8]
    ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   11a4c:	f7ff feb3 	bl	117b6 <ble_gap_call_conn_event_cb>
}
   11a50:	b00e      	add	sp, #56	; 0x38
   11a52:	bd10      	pop	{r4, pc}
   11a54:	200039c8 	.word	0x200039c8

00011a58 <ble_gap_rx_adv_report>:
    return rc;
}

void
ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
{
   11a58:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif

    struct ble_hs_adv_fields fields;
    int rc;

    STATS_INC(ble_gap_stats, rx_adv_report);
   11a5a:	4a1a      	ldr	r2, [pc, #104]	; (11ac4 <ble_gap_rx_adv_report+0x6c>)

    if (ble_gap_master.op != BLE_GAP_OP_M_DISC) {
   11a5c:	4d1a      	ldr	r5, [pc, #104]	; (11ac8 <ble_gap_rx_adv_report+0x70>)
#endif

    struct ble_hs_adv_fields fields;
    int rc;

    STATS_INC(ble_gap_stats, rx_adv_report);
   11a5e:	6f13      	ldr	r3, [r2, #112]	; 0x70
   11a60:	3301      	adds	r3, #1
   11a62:	6713      	str	r3, [r2, #112]	; 0x70

    if (ble_gap_master.op != BLE_GAP_OP_M_DISC) {
   11a64:	782b      	ldrb	r3, [r5, #0]
   11a66:	2b01      	cmp	r3, #1
    return rc;
}

void
ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
{
   11a68:	b0a9      	sub	sp, #164	; 0xa4
   11a6a:	4604      	mov	r4, r0
    struct ble_hs_adv_fields fields;
    int rc;

    STATS_INC(ble_gap_stats, rx_adv_report);

    if (ble_gap_master.op != BLE_GAP_OP_M_DISC) {
   11a6c:	d127      	bne.n	11abe <ble_gap_rx_adv_report+0x66>
        return;
    }

    rc = ble_hs_adv_parse_fields(&fields, desc->data, desc->length_data);
   11a6e:	ae0d      	add	r6, sp, #52	; 0x34
   11a70:	4630      	mov	r0, r6
   11a72:	68e1      	ldr	r1, [r4, #12]
   11a74:	78a2      	ldrb	r2, [r4, #2]
   11a76:	f003 f9e3 	bl	14e40 <ble_hs_adv_parse_fields>
    if (rc != 0) {
   11a7a:	bb00      	cbnz	r0, 11abe <ble_gap_rx_adv_report+0x66>
    }

    /* If a limited discovery procedure is active, discard non-limited
     * advertisements.
     */
    if (ble_gap_master.disc.limited &&
   11a7c:	7c2b      	ldrb	r3, [r5, #16]
   11a7e:	07da      	lsls	r2, r3, #31
   11a80:	d503      	bpl.n	11a8a <ble_gap_rx_adv_report+0x32>
        !(fields.flags & BLE_HS_ADV_F_DISC_LTD)) {
   11a82:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
    }

    /* If a limited discovery procedure is active, discard non-limited
     * advertisements.
     */
    if (ble_gap_master.disc.limited &&
   11a86:	07db      	lsls	r3, r3, #31
   11a88:	d519      	bpl.n	11abe <ble_gap_rx_adv_report+0x66>
        !(fields.flags & BLE_HS_ADV_F_DISC_LTD)) {

        return;
    }

    desc->fields = &fields;
   11a8a:	6126      	str	r6, [r4, #16]

static void
ble_gap_master_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg,
                          int reset_state)
{
    ble_hs_lock();
   11a8c:	f002 fe5a 	bl	14744 <ble_hs_lock>

    *out_cb = ble_gap_master.cb;
   11a90:	68ae      	ldr	r6, [r5, #8]
    *out_cb_arg = ble_gap_master.cb_arg;
   11a92:	68ef      	ldr	r7, [r5, #12]

    if (reset_state) {
        ble_gap_master_reset_state();
    }

    ble_hs_unlock();
   11a94:	f002 fe5e 	bl	14754 <ble_hs_unlock>
    ble_gap_event_fn *cb;
    void *cb_arg;

    ble_gap_master_extract_cb(&cb, &cb_arg, 0);

    if (cb != NULL) {
   11a98:	b18e      	cbz	r6, 11abe <ble_gap_rx_adv_report+0x66>
        memset(&event, 0, sizeof event);
   11a9a:	2100      	movs	r1, #0
   11a9c:	2234      	movs	r2, #52	; 0x34
   11a9e:	4668      	mov	r0, sp
   11aa0:	f7f7 fab7 	bl	9012 <memset>
        event.type = BLE_GAP_EVENT_DISC;
   11aa4:	2307      	movs	r3, #7
   11aa6:	f88d 3000 	strb.w	r3, [sp]
        event.disc = *desc;
   11aaa:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   11aac:	ad01      	add	r5, sp, #4
   11aae:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   11ab0:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   11ab4:	e885 0007 	stmia.w	r5, {r0, r1, r2}

        cb(&event, cb_arg);
   11ab8:	4668      	mov	r0, sp
   11aba:	4639      	mov	r1, r7
   11abc:	47b0      	blx	r6
        return;
    }

    desc->fields = &fields;
    ble_gap_disc_report(desc);
}
   11abe:	b029      	add	sp, #164	; 0xa4
   11ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11ac2:	bf00      	nop
   11ac4:	200039c8 	.word	0x200039c8
   11ac8:	20000d94 	.word	0x20000d94

00011acc <ble_gap_rx_conn_complete>:
/**
 * Processes an incoming connection-complete HCI event.
 */
int
ble_gap_rx_conn_complete(struct hci_le_conn_complete *evt)
{
   11acc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    struct ble_gap_event event;
    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gap_stats, rx_conn_complete);
   11ad0:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 11c8c <ble_gap_rx_conn_complete+0x1c0>
   11ad4:	f8d8 3074 	ldr.w	r3, [r8, #116]	; 0x74
/**
 * Processes an incoming connection-complete HCI event.
 */
int
ble_gap_rx_conn_complete(struct hci_le_conn_complete *evt)
{
   11ad8:	4606      	mov	r6, r0

    struct ble_gap_event event;
    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gap_stats, rx_conn_complete);
   11ada:	3301      	adds	r3, #1
/**
 * Processes an incoming connection-complete HCI event.
 */
int
ble_gap_rx_conn_complete(struct hci_le_conn_complete *evt)
{
   11adc:	b08e      	sub	sp, #56	; 0x38
    int rc;

    STATS_INC(ble_gap_stats, rx_conn_complete);

    /* Apply the event to the existing connection if it exists. */
    if (ble_hs_atomic_conn_flags(evt->connection_handle, NULL) == 0) {
   11ade:	8840      	ldrh	r0, [r0, #2]

    struct ble_gap_event event;
    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gap_stats, rx_conn_complete);
   11ae0:	f8c8 3074 	str.w	r3, [r8, #116]	; 0x74

    /* Apply the event to the existing connection if it exists. */
    if (ble_hs_atomic_conn_flags(evt->connection_handle, NULL) == 0) {
   11ae4:	2100      	movs	r1, #0
   11ae6:	f003 fad9 	bl	1509c <ble_hs_atomic_conn_flags>
   11aea:	7877      	ldrb	r7, [r6, #1]
   11aec:	4604      	mov	r4, r0
   11aee:	b940      	cbnz	r0, 11b02 <ble_gap_rx_conn_complete+0x36>
        /* XXX: Does this ever happen? */

        if (evt->status != 0) {
   11af0:	2f00      	cmp	r7, #0
   11af2:	f000 80c5 	beq.w	11c80 <ble_gap_rx_conn_complete+0x1b4>
            ble_gap_conn_broken(evt->connection_handle,
   11af6:	8870      	ldrh	r0, [r6, #2]
   11af8:	f507 7100 	add.w	r1, r7, #512	; 0x200
   11afc:	f7ff ff04 	bl	11908 <ble_gap_conn_broken>
   11b00:	e0be      	b.n	11c80 <ble_gap_rx_conn_complete+0x1b4>
   11b02:	4d61      	ldr	r5, [pc, #388]	; (11c88 <ble_gap_rx_conn_complete+0x1bc>)
        return 0;
    }

    /* This event refers to a new connection. */

    if (evt->status != BLE_ERR_SUCCESS) {
   11b04:	b37f      	cbz	r7, 11b66 <ble_gap_rx_conn_complete+0x9a>
        /* Determine the role from the status code. */
        switch (evt->status) {
   11b06:	2f3c      	cmp	r7, #60	; 0x3c
   11b08:	d106      	bne.n	11b18 <ble_gap_rx_conn_complete+0x4c>
        case BLE_ERR_DIR_ADV_TMO:
            if (ble_gap_adv_active()) {
   11b0a:	7d2b      	ldrb	r3, [r5, #20]
   11b0c:	2b01      	cmp	r3, #1
   11b0e:	f040 80ad 	bne.w	11c6c <ble_gap_rx_conn_complete+0x1a0>
                ble_gap_adv_finished();
   11b12:	f7ff feaf 	bl	11874 <ble_gap_adv_finished>
   11b16:	e0a9      	b.n	11c6c <ble_gap_rx_conn_complete+0x1a0>
            }
            break;

        default:
            if (ble_gap_master_in_progress()) {
   11b18:	782c      	ldrb	r4, [r5, #0]
   11b1a:	2c00      	cmp	r4, #0
   11b1c:	f000 80b0 	beq.w	11c80 <ble_gap_rx_conn_complete+0x1b4>
                if (evt->status == BLE_ERR_UNK_CONN_ID) {
   11b20:	2f02      	cmp	r7, #2
   11b22:	f04f 0400 	mov.w	r4, #0
   11b26:	d119      	bne.n	11b5c <ble_gap_rx_conn_complete+0x90>

static void
ble_gap_master_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg,
                          int reset_state)
{
    ble_hs_lock();
   11b28:	f002 fe0c 	bl	14744 <ble_hs_lock>

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
    ble_gap_master.exp_set = 0;
   11b2c:	786b      	ldrb	r3, [r5, #1]
ble_gap_master_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg,
                          int reset_state)
{
    ble_hs_lock();

    *out_cb = ble_gap_master.cb;
   11b2e:	68ae      	ldr	r6, [r5, #8]
    *out_cb_arg = ble_gap_master.cb_arg;
   11b30:	f8d5 800c 	ldr.w	r8, [r5, #12]
}

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
   11b34:	702c      	strb	r4, [r5, #0]
    ble_gap_master.exp_set = 0;
   11b36:	f364 0300 	bfi	r3, r4, #0, #1
   11b3a:	706b      	strb	r3, [r5, #1]

    if (reset_state) {
        ble_gap_master_reset_state();
    }

    ble_hs_unlock();
   11b3c:	f002 fe0a 	bl	14754 <ble_hs_unlock>
    ble_gap_event_fn *cb;
    void *cb_arg;
    int rc;

    ble_gap_master_extract_cb(&cb, &cb_arg, 1);
    if (cb != NULL) {
   11b40:	2e00      	cmp	r6, #0
   11b42:	f000 8093 	beq.w	11c6c <ble_gap_rx_conn_complete+0x1a0>
        memset(&event, 0, sizeof event);
   11b46:	4621      	mov	r1, r4
   11b48:	a801      	add	r0, sp, #4
   11b4a:	2234      	movs	r2, #52	; 0x34
   11b4c:	f7f7 fa61 	bl	9012 <memset>
        event.type = BLE_GAP_EVENT_CONN_CANCEL;
   11b50:	f88d 7004 	strb.w	r7, [sp, #4]
        rc = cb(&event, cb_arg);
   11b54:	a801      	add	r0, sp, #4
   11b56:	4641      	mov	r1, r8
   11b58:	47b0      	blx	r6
   11b5a:	e087      	b.n	11c6c <ble_gap_rx_conn_complete+0x1a0>
            if (ble_gap_master_in_progress()) {
                if (evt->status == BLE_ERR_UNK_CONN_ID) {
                    /* Connect procedure successfully cancelled. */
                    ble_gap_master_connect_cancel();
                } else {
                    ble_gap_master_failed(BLE_HS_HCI_ERR(evt->status));
   11b5c:	f507 7000 	add.w	r0, r7, #512	; 0x200
   11b60:	f7ff fea8 	bl	118b4 <ble_gap_master_failed>
   11b64:	e08c      	b.n	11c80 <ble_gap_rx_conn_complete+0x1b4>
        }

        return 0;
    }

    switch (evt->role) {
   11b66:	7933      	ldrb	r3, [r6, #4]
   11b68:	b113      	cbz	r3, 11b70 <ble_gap_rx_conn_complete+0xa4>
   11b6a:	2b01      	cmp	r3, #1
   11b6c:	d004      	beq.n	11b78 <ble_gap_rx_conn_complete+0xac>
   11b6e:	e010      	b.n	11b92 <ble_gap_rx_conn_complete+0xc6>
static int
ble_gap_accept_master_conn(uint8_t addr_type, uint8_t *addr)
{
    int rc;

    switch (ble_gap_master.op) {
   11b70:	782b      	ldrb	r3, [r5, #0]
   11b72:	2b02      	cmp	r3, #2
   11b74:	d008      	beq.n	11b88 <ble_gap_rx_conn_complete+0xbc>
   11b76:	e07b      	b.n	11c70 <ble_gap_rx_conn_complete+0x1a4>
static int
ble_gap_accept_slave_conn(uint8_t addr_type, uint8_t *addr)
{
    int rc;

    if (!ble_gap_adv_active()) {
   11b78:	7d2b      	ldrb	r3, [r5, #20]
   11b7a:	2b01      	cmp	r3, #1
   11b7c:	d178      	bne.n	11c70 <ble_gap_rx_conn_complete+0x1a4>
        rc = BLE_HS_ENOENT;
    } else {
        switch (ble_gap_slave.conn_mode) {
   11b7e:	7f2b      	ldrb	r3, [r5, #28]
   11b80:	3b01      	subs	r3, #1
   11b82:	2b01      	cmp	r3, #1
   11b84:	d874      	bhi.n	11c70 <ble_gap_rx_conn_complete+0x1a4>
   11b86:	e075      	b.n	11c74 <ble_gap_rx_conn_complete+0x1a8>
        rc = BLE_HS_ENOENT;
        break;
    }

    if (rc == 0) {
        STATS_INC(ble_gap_stats, connect_mst);
   11b88:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
   11b8c:	3301      	adds	r3, #1
   11b8e:	f8c8 305c 	str.w	r3, [r8, #92]	; 0x5c
        BLE_HS_DBG_ASSERT(0);
        break;
    }

    /* We verified that there is a free connection when the procedure began. */
    conn = ble_hs_conn_alloc();
   11b92:	f003 fb35 	bl	15200 <ble_hs_conn_alloc>
    BLE_HS_DBG_ASSERT(conn != NULL);

    conn->bhc_handle = evt->connection_handle;
   11b96:	8873      	ldrh	r3, [r6, #2]
   11b98:	8083      	strh	r3, [r0, #4]
    memcpy(conn->bhc_peer_addr, evt->peer_addr, sizeof conn->bhc_peer_addr);
   11b9a:	4633      	mov	r3, r6
    conn->bhc_peer_addr_type = evt->peer_addr_type;
    memcpy(conn->bhc_our_rpa_addr, evt->local_rpa,
   11b9c:	f100 0e0e 	add.w	lr, r0, #14
    /* We verified that there is a free connection when the procedure began. */
    conn = ble_hs_conn_alloc();
    BLE_HS_DBG_ASSERT(conn != NULL);

    conn->bhc_handle = evt->connection_handle;
    memcpy(conn->bhc_peer_addr, evt->peer_addr, sizeof conn->bhc_peer_addr);
   11ba0:	f853 2f06 	ldr.w	r2, [r3, #6]!
   11ba4:	6082      	str	r2, [r0, #8]
   11ba6:	889b      	ldrh	r3, [r3, #4]
   11ba8:	8183      	strh	r3, [r0, #12]
    conn->bhc_peer_addr_type = evt->peer_addr_type;
   11baa:	7973      	ldrb	r3, [r6, #5]
   11bac:	7183      	strb	r3, [r0, #6]
    memcpy(conn->bhc_our_rpa_addr, evt->local_rpa,
   11bae:	4632      	mov	r2, r6
           sizeof conn->bhc_our_rpa_addr);
    memcpy(conn->bhc_peer_rpa_addr, evt->peer_rpa,
   11bb0:	f100 0714 	add.w	r7, r0, #20
    BLE_HS_DBG_ASSERT(conn != NULL);

    conn->bhc_handle = evt->connection_handle;
    memcpy(conn->bhc_peer_addr, evt->peer_addr, sizeof conn->bhc_peer_addr);
    conn->bhc_peer_addr_type = evt->peer_addr_type;
    memcpy(conn->bhc_our_rpa_addr, evt->local_rpa,
   11bb4:	f852 3f13 	ldr.w	r3, [r2, #19]!
   11bb8:	f8c0 300e 	str.w	r3, [r0, #14]
   11bbc:	8893      	ldrh	r3, [r2, #4]
   11bbe:	f8ae 3004 	strh.w	r3, [lr, #4]
           sizeof conn->bhc_our_rpa_addr);
    memcpy(conn->bhc_peer_rpa_addr, evt->peer_rpa,
   11bc2:	4633      	mov	r3, r6
        BLE_HS_DBG_ASSERT(0);
        break;
    }

    /* We verified that there is a free connection when the procedure began. */
    conn = ble_hs_conn_alloc();
   11bc4:	4604      	mov	r4, r0
    conn->bhc_handle = evt->connection_handle;
    memcpy(conn->bhc_peer_addr, evt->peer_addr, sizeof conn->bhc_peer_addr);
    conn->bhc_peer_addr_type = evt->peer_addr_type;
    memcpy(conn->bhc_our_rpa_addr, evt->local_rpa,
           sizeof conn->bhc_our_rpa_addr);
    memcpy(conn->bhc_peer_rpa_addr, evt->peer_rpa,
   11bc6:	f853 1f19 	ldr.w	r1, [r3, #25]!
   11bca:	6141      	str	r1, [r0, #20]
   11bcc:	8899      	ldrh	r1, [r3, #4]
   11bce:	80b9      	strh	r1, [r7, #4]
           sizeof conn->bhc_peer_rpa_addr);
    conn->bhc_itvl = evt->conn_itvl;
   11bd0:	89b1      	ldrh	r1, [r6, #12]
   11bd2:	8341      	strh	r1, [r0, #26]
    conn->bhc_latency = evt->conn_latency;
   11bd4:	89f1      	ldrh	r1, [r6, #14]
   11bd6:	8381      	strh	r1, [r0, #28]
    conn->bhc_supervision_timeout = evt->supervision_timeout;
   11bd8:	8a31      	ldrh	r1, [r6, #16]
   11bda:	83c1      	strh	r1, [r0, #30]
    conn->bhc_master_clock_accuracy = evt->master_clk_acc;
   11bdc:	7cb1      	ldrb	r1, [r6, #18]
   11bde:	f880 1020 	strb.w	r1, [r0, #32]
    if (evt->role == BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER) {
   11be2:	7931      	ldrb	r1, [r6, #4]
   11be4:	b999      	cbnz	r1, 11c0e <ble_gap_rx_conn_complete+0x142>
        conn->bhc_cb = ble_gap_master.cb;
   11be6:	68a8      	ldr	r0, [r5, #8]
   11be8:	64a0      	str	r0, [r4, #72]	; 0x48
        conn->bhc_cb_arg = ble_gap_master.cb_arg;
   11bea:	68e8      	ldr	r0, [r5, #12]
   11bec:	64e0      	str	r0, [r4, #76]	; 0x4c
        conn->bhc_flags |= BLE_HS_CONN_F_MASTER;
   11bee:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
}

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
   11bf2:	7029      	strb	r1, [r5, #0]
    conn->bhc_supervision_timeout = evt->supervision_timeout;
    conn->bhc_master_clock_accuracy = evt->master_clk_acc;
    if (evt->role == BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER) {
        conn->bhc_cb = ble_gap_master.cb;
        conn->bhc_cb_arg = ble_gap_master.cb_arg;
        conn->bhc_flags |= BLE_HS_CONN_F_MASTER;
   11bf4:	f040 0001 	orr.w	r0, r0, #1
   11bf8:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
        conn->bhc_our_addr_type = ble_gap_master.conn.our_addr_type;
   11bfc:	7c28      	ldrb	r0, [r5, #16]
   11bfe:	f3c0 0041 	ubfx	r0, r0, #1, #2
   11c02:	71e0      	strb	r0, [r4, #7]

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
    ble_gap_master.exp_set = 0;
   11c04:	7868      	ldrb	r0, [r5, #1]
   11c06:	f361 0000 	bfi	r0, r1, #0, #1
   11c0a:	7068      	strb	r0, [r5, #1]
   11c0c:	e00d      	b.n	11c2a <ble_gap_rx_conn_complete+0x15e>
        conn->bhc_cb_arg = ble_gap_master.cb_arg;
        conn->bhc_flags |= BLE_HS_CONN_F_MASTER;
        conn->bhc_our_addr_type = ble_gap_master.conn.our_addr_type;
        ble_gap_master_reset_state();
    } else {
        conn->bhc_cb = ble_gap_slave.cb;
   11c0e:	6a29      	ldr	r1, [r5, #32]
   11c10:	6481      	str	r1, [r0, #72]	; 0x48
        conn->bhc_cb_arg = ble_gap_slave.cb_arg;
   11c12:	6a69      	ldr	r1, [r5, #36]	; 0x24
   11c14:	64c1      	str	r1, [r0, #76]	; 0x4c
        conn->bhc_our_addr_type = ble_gap_slave.our_addr_type;
   11c16:	7fa9      	ldrb	r1, [r5, #30]
   11c18:	f3c1 0101 	ubfx	r1, r1, #0, #2
   11c1c:	71c1      	strb	r1, [r0, #7]

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
    ble_gap_slave.exp_set = 0;
   11c1e:	7d69      	ldrb	r1, [r5, #21]
}

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
   11c20:	2000      	movs	r0, #0
    ble_gap_slave.exp_set = 0;
   11c22:	f360 0100 	bfi	r1, r0, #0, #1
}

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
   11c26:	7528      	strb	r0, [r5, #20]
    ble_gap_slave.exp_set = 0;
   11c28:	7569      	strb	r1, [r5, #21]
        conn->bhc_cb_arg = ble_gap_slave.cb_arg;
        conn->bhc_our_addr_type = ble_gap_slave.our_addr_type;
        ble_gap_slave_reset_state();
    }

    memcpy(conn->bhc_our_rpa_addr, evt->local_rpa, 6);
   11c2a:	6811      	ldr	r1, [r2, #0]
   11c2c:	f8c4 100e 	str.w	r1, [r4, #14]
   11c30:	8892      	ldrh	r2, [r2, #4]
   11c32:	f8ae 2004 	strh.w	r2, [lr, #4]
    memcpy(conn->bhc_peer_rpa_addr, evt->peer_rpa, 6);
   11c36:	681a      	ldr	r2, [r3, #0]
   11c38:	6162      	str	r2, [r4, #20]
   11c3a:	889b      	ldrh	r3, [r3, #4]
   11c3c:	80bb      	strh	r3, [r7, #4]

    ble_hs_lock();
   11c3e:	f002 fd81 	bl	14744 <ble_hs_lock>

    memset(&event, 0, sizeof event);
   11c42:	2100      	movs	r1, #0
   11c44:	2234      	movs	r2, #52	; 0x34
   11c46:	a801      	add	r0, sp, #4
   11c48:	f7f7 f9e3 	bl	9012 <memset>
    ble_hs_conn_insert(conn);
   11c4c:	4620      	mov	r0, r4
   11c4e:	f003 fb2b 	bl	152a8 <ble_hs_conn_insert>

    ble_hs_unlock();

    event.type = BLE_GAP_EVENT_CONNECT;
   11c52:	2400      	movs	r4, #0
    ble_hs_lock();

    memset(&event, 0, sizeof event);
    ble_hs_conn_insert(conn);

    ble_hs_unlock();
   11c54:	f002 fd7e 	bl	14754 <ble_hs_unlock>

    event.type = BLE_GAP_EVENT_CONNECT;
    event.connect.conn_handle = evt->connection_handle;
   11c58:	8871      	ldrh	r1, [r6, #2]
    memset(&event, 0, sizeof event);
    ble_hs_conn_insert(conn);

    ble_hs_unlock();

    event.type = BLE_GAP_EVENT_CONNECT;
   11c5a:	f88d 4004 	strb.w	r4, [sp, #4]
    event.connect.conn_handle = evt->connection_handle;
    event.connect.status = 0;
    ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   11c5e:	a801      	add	r0, sp, #4
    ble_hs_conn_insert(conn);

    ble_hs_unlock();

    event.type = BLE_GAP_EVENT_CONNECT;
    event.connect.conn_handle = evt->connection_handle;
   11c60:	f8ad 100c 	strh.w	r1, [sp, #12]
    event.connect.status = 0;
   11c64:	9402      	str	r4, [sp, #8]
    ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   11c66:	f7ff fda6 	bl	117b6 <ble_gap_call_conn_event_cb>

    return 0;
   11c6a:	e009      	b.n	11c80 <ble_gap_rx_conn_complete+0x1b4>

        if (evt->status != 0) {
            ble_gap_conn_broken(evt->connection_handle,
                                BLE_HS_HCI_ERR(evt->status));
        }
        return 0;
   11c6c:	2400      	movs	r4, #0
   11c6e:	e007      	b.n	11c80 <ble_gap_rx_conn_complete+0x1b4>
    int rc;

    if (!ble_gap_adv_active()) {
        rc = BLE_HS_ENOENT;
    } else {
        switch (ble_gap_slave.conn_mode) {
   11c70:	2405      	movs	r4, #5
   11c72:	e005      	b.n	11c80 <ble_gap_rx_conn_complete+0x1b4>
            break;
        }
    }

    if (rc == 0) {
        STATS_INC(ble_gap_stats, connect_slv);
   11c74:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
   11c78:	3301      	adds	r3, #1
   11c7a:	f8c8 3060 	str.w	r3, [r8, #96]	; 0x60
   11c7e:	e788      	b.n	11b92 <ble_gap_rx_conn_complete+0xc6>
    event.connect.conn_handle = evt->connection_handle;
    event.connect.status = 0;
    ble_gap_call_conn_event_cb(&event, evt->connection_handle);

    return 0;
}
   11c80:	4620      	mov	r0, r4
   11c82:	b00e      	add	sp, #56	; 0x38
   11c84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11c88:	20000d94 	.word	0x20000d94
   11c8c:	200039c8 	.word	0x200039c8

00011c90 <ble_gap_rx_l2cap_update_req>:

int
ble_gap_rx_l2cap_update_req(uint16_t conn_handle,
                            struct ble_gap_upd_params *params)
{
   11c90:	b530      	push	{r4, r5, lr}
   11c92:	b08f      	sub	sp, #60	; 0x3c
   11c94:	4604      	mov	r4, r0
   11c96:	460d      	mov	r5, r1
    struct ble_gap_event event;
    int rc;

    memset(&event, 0, sizeof event);
   11c98:	2234      	movs	r2, #52	; 0x34
   11c9a:	a801      	add	r0, sp, #4
   11c9c:	2100      	movs	r1, #0
   11c9e:	f7f7 f9b8 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_L2CAP_UPDATE_REQ;
   11ca2:	2305      	movs	r3, #5
    event.conn_update_req.conn_handle = conn_handle;
    event.conn_update_req.peer_params = params;

    rc = ble_gap_call_conn_event_cb(&event, conn_handle);
   11ca4:	a801      	add	r0, sp, #4
   11ca6:	4621      	mov	r1, r4
{
    struct ble_gap_event event;
    int rc;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_L2CAP_UPDATE_REQ;
   11ca8:	f88d 3004 	strb.w	r3, [sp, #4]
    event.conn_update_req.conn_handle = conn_handle;
   11cac:	f8ad 4010 	strh.w	r4, [sp, #16]
    event.conn_update_req.peer_params = params;
   11cb0:	9502      	str	r5, [sp, #8]

    rc = ble_gap_call_conn_event_cb(&event, conn_handle);
   11cb2:	f7ff fd80 	bl	117b6 <ble_gap_call_conn_event_cb>
    return rc;
}
   11cb6:	b00f      	add	sp, #60	; 0x3c
   11cb8:	bd30      	pop	{r4, r5, pc}
	...

00011cbc <ble_gap_heartbeat>:
 * @return                      The number of ticks until this function should
 *                                  be called again.
 */
int32_t
ble_gap_heartbeat(void)
{
   11cbc:	b5f0      	push	{r4, r5, r6, r7, lr}
   11cbe:	b08f      	sub	sp, #60	; 0x3c
ble_gap_master_heartbeat(void)
{
    uint32_t ticks_until_exp;
    int rc;

    ticks_until_exp = ble_gap_master_ticks_until_exp();
   11cc0:	f7ff fda2 	bl	11808 <ble_gap_master_ticks_until_exp>
    if (ticks_until_exp != 0) {
   11cc4:	4601      	mov	r1, r0
   11cc6:	b108      	cbz	r0, 11ccc <ble_gap_heartbeat+0x10>
        /* Timer not expired yet. */
        return ticks_until_exp;
   11cc8:	4604      	mov	r4, r0
   11cca:	e02c      	b.n	11d26 <ble_gap_heartbeat+0x6a>
    }

    /*** Timer expired; process event. */

    switch (ble_gap_master.op) {
   11ccc:	4c21      	ldr	r4, [pc, #132]	; (11d54 <ble_gap_heartbeat+0x98>)
   11cce:	7823      	ldrb	r3, [r4, #0]
   11cd0:	2b01      	cmp	r3, #1
   11cd2:	d00a      	beq.n	11cea <ble_gap_heartbeat+0x2e>
   11cd4:	2b02      	cmp	r3, #2
   11cd6:	d124      	bne.n	11d22 <ble_gap_heartbeat+0x66>
    case BLE_GAP_OP_M_CONN:
        rc = ble_gap_conn_cancel_tx();
   11cd8:	f7ff fd43 	bl	11762 <ble_gap_conn_cancel_tx>
        if (rc != 0) {
   11cdc:	b108      	cbz	r0, 11ce2 <ble_gap_heartbeat+0x26>
            /* Failed to stop connecting; try again in 100 ms. */
            return BLE_GAP_CANCEL_RETRY_RATE;
   11cde:	2464      	movs	r4, #100	; 0x64
   11ce0:	e021      	b.n	11d26 <ble_gap_heartbeat+0x6a>
        }

        ble_gap_master_failed(BLE_HS_ETIMEOUT);
   11ce2:	200d      	movs	r0, #13
   11ce4:	f7ff fde6 	bl	118b4 <ble_gap_master_failed>
   11ce8:	e01b      	b.n	11d22 <ble_gap_heartbeat+0x66>
        break;

    case BLE_GAP_OP_M_DISC:
        /* When a discovery procedure times out, it is not a failure. */
        rc = ble_gap_disc_enable_tx(0, 0);
   11cea:	f7ff fd45 	bl	11778 <ble_gap_disc_enable_tx>
        if (rc != 0) {
   11cee:	4605      	mov	r5, r0
   11cf0:	2800      	cmp	r0, #0
   11cf2:	d1f4      	bne.n	11cde <ble_gap_heartbeat+0x22>

static void
ble_gap_master_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg,
                          int reset_state)
{
    ble_hs_lock();
   11cf4:	f002 fd26 	bl	14744 <ble_hs_lock>

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
    ble_gap_master.exp_set = 0;
   11cf8:	7863      	ldrb	r3, [r4, #1]
ble_gap_master_extract_cb(ble_gap_event_fn **out_cb, void **out_cb_arg,
                          int reset_state)
{
    ble_hs_lock();

    *out_cb = ble_gap_master.cb;
   11cfa:	68a6      	ldr	r6, [r4, #8]
    *out_cb_arg = ble_gap_master.cb_arg;
   11cfc:	68e7      	ldr	r7, [r4, #12]
}

static void
ble_gap_master_reset_state(void)
{
    ble_gap_master.op = BLE_GAP_OP_NULL;
   11cfe:	7025      	strb	r5, [r4, #0]
    ble_gap_master.exp_set = 0;
   11d00:	f365 0300 	bfi	r3, r5, #0, #1
   11d04:	7063      	strb	r3, [r4, #1]

    if (reset_state) {
        ble_gap_master_reset_state();
    }

    ble_hs_unlock();
   11d06:	f002 fd25 	bl	14754 <ble_hs_unlock>
    ble_gap_event_fn *cb;
    void *cb_arg;

    ble_gap_master_extract_cb(&cb, &cb_arg, 1);

    if (cb != NULL) {
   11d0a:	b156      	cbz	r6, 11d22 <ble_gap_heartbeat+0x66>
        memset(&event, 0, sizeof event);
   11d0c:	4629      	mov	r1, r5
   11d0e:	a801      	add	r0, sp, #4
   11d10:	2234      	movs	r2, #52	; 0x34
   11d12:	f7f7 f97e 	bl	9012 <memset>
        event.type = BLE_GAP_EVENT_DISC_COMPLETE;
   11d16:	2308      	movs	r3, #8
   11d18:	f88d 3004 	strb.w	r3, [sp, #4]
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (cb != NULL) {
        rc = cb(event, cb_arg);
   11d1c:	a801      	add	r0, sp, #4
   11d1e:	4639      	mov	r1, r7
   11d20:	47b0      	blx	r6
    default:
        BLE_HS_DBG_ASSERT(0);
        break;
    }

    return BLE_HS_FOREVER;
   11d22:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
ble_gap_slave_heartbeat(void)
{
    uint32_t ticks_until_exp;
    int rc;

    ticks_until_exp = ble_gap_slave_ticks_until_exp();
   11d26:	f7ff fd83 	bl	11830 <ble_gap_slave_ticks_until_exp>
    if (ticks_until_exp != 0) {
   11d2a:	b970      	cbnz	r0, 11d4a <ble_gap_heartbeat+0x8e>
    }

    /*** Timer expired; process event. */

    /* Stop advertising. */
    rc = ble_gap_adv_enable_tx(0);
   11d2c:	f7ff fd35 	bl	1179a <ble_gap_adv_enable_tx>
    if (rc != 0) {
   11d30:	b950      	cbnz	r0, 11d48 <ble_gap_heartbeat+0x8c>
}

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
   11d32:	4b08      	ldr	r3, [pc, #32]	; (11d54 <ble_gap_heartbeat+0x98>)
    ble_gap_slave.exp_set = 0;
   11d34:	7d5a      	ldrb	r2, [r3, #21]
}

static void
ble_gap_slave_reset_state(void)
{
    ble_gap_slave.op = BLE_GAP_OP_NULL;
   11d36:	7518      	strb	r0, [r3, #20]
    ble_gap_slave.exp_set = 0;
   11d38:	f360 0200 	bfi	r2, r0, #0, #1
   11d3c:	755a      	strb	r2, [r3, #21]

    /* Clear the timer and cancel the current procedure. */
    ble_gap_slave_reset_state();

    /* Indicate to application that advertising has stopped. */
    ble_gap_adv_finished();
   11d3e:	f7ff fd99 	bl	11874 <ble_gap_adv_finished>

    return BLE_HS_FOREVER;
   11d42:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   11d46:	e000      	b.n	11d4a <ble_gap_heartbeat+0x8e>

    /* Stop advertising. */
    rc = ble_gap_adv_enable_tx(0);
    if (rc != 0) {
        /* Failed to stop advertising; try again in 100 ms. */
        return 100;
   11d48:	2064      	movs	r0, #100	; 0x64

    master_ticks = ble_gap_master_heartbeat();
    slave_ticks = ble_gap_slave_heartbeat();

    return min(master_ticks, slave_ticks);
}
   11d4a:	42a0      	cmp	r0, r4
   11d4c:	bfa8      	it	ge
   11d4e:	4620      	movge	r0, r4
   11d50:	b00f      	add	sp, #60	; 0x3c
   11d52:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11d54:	20000d94 	.word	0x20000d94

00011d58 <ble_gap_adv_start>:
int
ble_gap_adv_start(uint8_t own_addr_type, uint8_t peer_addr_type,
                  const uint8_t *peer_addr, int32_t duration_ms,
                  const struct ble_gap_adv_params *adv_params,
                  ble_gap_event_fn *cb, void *cb_arg)
{
   11d58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#endif

    uint32_t duration_ticks;
    int rc;

    STATS_INC(ble_gap_stats, adv_start);
   11d5c:	4fa9      	ldr	r7, [pc, #676]	; (12004 <ble_gap_adv_start+0x2ac>)
int
ble_gap_adv_start(uint8_t own_addr_type, uint8_t peer_addr_type,
                  const uint8_t *peer_addr, int32_t duration_ms,
                  const struct ble_gap_adv_params *adv_params,
                  ble_gap_event_fn *cb, void *cb_arg)
{
   11d5e:	b094      	sub	sp, #80	; 0x50
   11d60:	4699      	mov	r9, r3
#endif

    uint32_t duration_ticks;
    int rc;

    STATS_INC(ble_gap_stats, adv_start);
   11d62:	69fb      	ldr	r3, [r7, #28]
int
ble_gap_adv_start(uint8_t own_addr_type, uint8_t peer_addr_type,
                  const uint8_t *peer_addr, int32_t duration_ms,
                  const struct ble_gap_adv_params *adv_params,
                  ble_gap_event_fn *cb, void *cb_arg)
{
   11d64:	9d1c      	ldr	r5, [sp, #112]	; 0x70
#endif

    uint32_t duration_ticks;
    int rc;

    STATS_INC(ble_gap_stats, adv_start);
   11d66:	3301      	adds	r3, #1
int
ble_gap_adv_start(uint8_t own_addr_type, uint8_t peer_addr_type,
                  const uint8_t *peer_addr, int32_t duration_ms,
                  const struct ble_gap_adv_params *adv_params,
                  ble_gap_event_fn *cb, void *cb_arg)
{
   11d68:	4680      	mov	r8, r0
   11d6a:	468a      	mov	sl, r1
   11d6c:	4614      	mov	r4, r2
#endif

    uint32_t duration_ticks;
    int rc;

    STATS_INC(ble_gap_stats, adv_start);
   11d6e:	61fb      	str	r3, [r7, #28]

    ble_hs_lock();
   11d70:	f002 fce8 	bl	14744 <ble_hs_lock>
static int
ble_gap_adv_validate(uint8_t own_addr_type, uint8_t peer_addr_type,
                     const uint8_t *peer_addr,
                     const struct ble_gap_adv_params *adv_params)
{
    if (adv_params == NULL) {
   11d74:	b355      	cbz	r5, 11dcc <ble_gap_adv_start+0x74>
        return BLE_HS_EINVAL;
    }

    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
   11d76:	f1b8 0f03 	cmp.w	r8, #3
   11d7a:	d827      	bhi.n	11dcc <ble_gap_adv_start+0x74>
        return BLE_HS_EINVAL;
    }

    if (adv_params->disc_mode >= BLE_GAP_DISC_MODE_MAX) {
   11d7c:	786b      	ldrb	r3, [r5, #1]
   11d7e:	2b02      	cmp	r3, #2
   11d80:	d824      	bhi.n	11dcc <ble_gap_adv_start+0x74>
        return BLE_HS_EINVAL;
    }

    if (ble_gap_slave.op != BLE_GAP_OP_NULL) {
   11d82:	4ea1      	ldr	r6, [pc, #644]	; (12008 <ble_gap_adv_start+0x2b0>)
   11d84:	7d33      	ldrb	r3, [r6, #20]
   11d86:	bb53      	cbnz	r3, 11dde <ble_gap_adv_start+0x86>
        return BLE_HS_EALREADY;
    }

    switch (adv_params->conn_mode) {
   11d88:	782b      	ldrb	r3, [r5, #0]
   11d8a:	2b01      	cmp	r3, #1
   11d8c:	d00f      	beq.n	11dae <ble_gap_adv_start+0x56>
   11d8e:	d302      	bcc.n	11d96 <ble_gap_adv_start+0x3e>
   11d90:	2b02      	cmp	r3, #2
   11d92:	d004      	beq.n	11d9e <ble_gap_adv_start+0x46>
   11d94:	e01a      	b.n	11dcc <ble_gap_adv_start+0x74>
    case BLE_GAP_CONN_MODE_NON:
        /* High duty cycle only allowed for directed advertising. */
        if (adv_params->high_duty_cycle) {
   11d96:	7a2b      	ldrb	r3, [r5, #8]
   11d98:	07d9      	lsls	r1, r3, #31
   11d9a:	d417      	bmi.n	11dcc <ble_gap_adv_start+0x74>
   11d9c:	e00d      	b.n	11dba <ble_gap_adv_start+0x62>
        }
        break;

    case BLE_GAP_CONN_MODE_UND:
        /* High duty cycle only allowed for directed advertising. */
        if (adv_params->high_duty_cycle) {
   11d9e:	7a2b      	ldrb	r3, [r5, #8]
   11da0:	07da      	lsls	r2, r3, #31
   11da2:	d413      	bmi.n	11dcc <ble_gap_adv_start+0x74>
        }

        /* Don't allow connectable advertising if we won't be able to allocate
         * a new connection.
         */
        if (!ble_hs_conn_can_alloc()) {
   11da4:	f003 f9d2 	bl	1514c <ble_hs_conn_can_alloc>
   11da8:	b938      	cbnz	r0, 11dba <ble_gap_adv_start+0x62>
            return BLE_HS_ENOMEM;
   11daa:	2406      	movs	r4, #6
   11dac:	e00f      	b.n	11dce <ble_gap_adv_start+0x76>
        }
        break;

    case BLE_GAP_CONN_MODE_DIR:
        if (peer_addr_type != BLE_ADDR_TYPE_PUBLIC &&
   11dae:	f1ba 0f03 	cmp.w	sl, #3
   11db2:	d80b      	bhi.n	11dcc <ble_gap_adv_start+0x74>
            peer_addr_type != BLE_ADDR_TYPE_RPA_PUB_DEFAULT &&
            peer_addr_type != BLE_ADDR_TYPE_RPA_RND_DEFAULT) {

            return BLE_HS_EINVAL;
        }
        if (peer_addr == NULL) {
   11db4:	2c00      	cmp	r4, #0
   11db6:	d1f5      	bne.n	11da4 <ble_gap_adv_start+0x4c>
   11db8:	e008      	b.n	11dcc <ble_gap_adv_start+0x74>
                              adv_params);
    if (rc != 0) {
        goto done;
    }

    if (duration_ms != BLE_HS_FOREVER) {
   11dba:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   11dbe:	4599      	cmp	r9, r3
   11dc0:	d00f      	beq.n	11de2 <ble_gap_adv_start+0x8a>
        rc = os_time_ms_to_ticks(duration_ms, &duration_ticks);
   11dc2:	4648      	mov	r0, r9
   11dc4:	a906      	add	r1, sp, #24
   11dc6:	f7f8 fd99 	bl	a8fc <os_time_ms_to_ticks>
        if (rc != 0) {
   11dca:	b150      	cbz	r0, 11de2 <ble_gap_adv_start+0x8a>
            /* Duration too great. */
            rc = BLE_HS_EINVAL;
   11dcc:	2403      	movs	r4, #3

    ble_gap_slave.op = BLE_GAP_OP_S_ADV;
    rc = 0;

done:
    ble_hs_unlock();
   11dce:	f002 fcc1 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   11dd2:	b114      	cbz	r4, 11dda <ble_gap_adv_start+0x82>
        STATS_INC(ble_gap_stats, adv_start_fail);
   11dd4:	6a3b      	ldr	r3, [r7, #32]
   11dd6:	3301      	adds	r3, #1
   11dd8:	623b      	str	r3, [r7, #32]
   11dda:	4620      	mov	r0, r4
   11ddc:	e10e      	b.n	11ffc <ble_gap_adv_start+0x2a4>
    if (adv_params->disc_mode >= BLE_GAP_DISC_MODE_MAX) {
        return BLE_HS_EINVAL;
    }

    if (ble_gap_slave.op != BLE_GAP_OP_NULL) {
        return BLE_HS_EALREADY;
   11dde:	2402      	movs	r4, #2
   11de0:	e7f5      	b.n	11dce <ble_gap_adv_start+0x76>
            rc = BLE_HS_EINVAL;
            goto done;
        }
    }

    rc = ble_hs_id_use_addr(own_addr_type);
   11de2:	4640      	mov	r0, r8
   11de4:	f003 fb40 	bl	15468 <ble_hs_id_use_addr>
    if (rc != 0) {
   11de8:	2800      	cmp	r0, #0
   11dea:	f040 8107 	bne.w	11ffc <ble_gap_adv_start+0x2a4>
        return rc;
    }

    BLE_HS_LOG(INFO, "GAP procedure initiated: advertise; ");
   11dee:	4887      	ldr	r0, [pc, #540]	; (1200c <ble_gap_adv_start+0x2b4>)
   11df0:	4b87      	ldr	r3, [pc, #540]	; (12010 <ble_gap_adv_start+0x2b8>)
   11df2:	2104      	movs	r1, #4
   11df4:	2201      	movs	r2, #1
   11df6:	f00b fa17 	bl	1d228 <log_printf>
static void
ble_gap_log_adv(uint8_t own_addr_type, uint8_t peer_addr_type,
                const uint8_t *peer_addr,
                const struct ble_gap_adv_params *adv_params)
{
    BLE_HS_LOG(INFO, "disc_mode=%d peer_addr_type=%d peer_addr=",
   11dfa:	7f73      	ldrb	r3, [r6, #29]
   11dfc:	4883      	ldr	r0, [pc, #524]	; (1200c <ble_gap_adv_start+0x2b4>)
   11dfe:	e88d 0408 	stmia.w	sp, {r3, sl}
   11e02:	2104      	movs	r1, #4
   11e04:	2201      	movs	r2, #1
   11e06:	4b83      	ldr	r3, [pc, #524]	; (12014 <ble_gap_adv_start+0x2bc>)
   11e08:	f00b fa0e 	bl	1d228 <log_printf>
               ble_gap_slave.disc_mode, peer_addr_type);
    if(peer_addr) {
   11e0c:	b194      	cbz	r4, 11e34 <ble_gap_adv_start+0xdc>
        BLE_HS_LOG_ADDR(INFO, peer_addr);
   11e0e:	7963      	ldrb	r3, [r4, #5]
   11e10:	9300      	str	r3, [sp, #0]
   11e12:	7923      	ldrb	r3, [r4, #4]
   11e14:	9301      	str	r3, [sp, #4]
   11e16:	78e3      	ldrb	r3, [r4, #3]
   11e18:	9302      	str	r3, [sp, #8]
   11e1a:	78a3      	ldrb	r3, [r4, #2]
   11e1c:	9303      	str	r3, [sp, #12]
   11e1e:	7863      	ldrb	r3, [r4, #1]
   11e20:	9304      	str	r3, [sp, #16]
   11e22:	7823      	ldrb	r3, [r4, #0]
   11e24:	9305      	str	r3, [sp, #20]
   11e26:	4879      	ldr	r0, [pc, #484]	; (1200c <ble_gap_adv_start+0x2b4>)
   11e28:	4b7b      	ldr	r3, [pc, #492]	; (12018 <ble_gap_adv_start+0x2c0>)
   11e2a:	2104      	movs	r1, #4
   11e2c:	2201      	movs	r2, #1
   11e2e:	f00b f9fb 	bl	1d228 <log_printf>
   11e32:	e005      	b.n	11e40 <ble_gap_adv_start+0xe8>
    } else {
        BLE_HS_LOG(INFO, "none");
   11e34:	4875      	ldr	r0, [pc, #468]	; (1200c <ble_gap_adv_start+0x2b4>)
   11e36:	4b79      	ldr	r3, [pc, #484]	; (1201c <ble_gap_adv_start+0x2c4>)
   11e38:	2104      	movs	r1, #4
   11e3a:	2201      	movs	r2, #1
   11e3c:	f00b f9f4 	bl	1d228 <log_printf>
    }
    BLE_HS_LOG(INFO, " adv_channel_map=%d own_addr_type=%d "
   11e40:	79ab      	ldrb	r3, [r5, #6]
   11e42:	4872      	ldr	r0, [pc, #456]	; (1200c <ble_gap_adv_start+0x2b4>)
   11e44:	e88d 0108 	stmia.w	sp, {r3, r8}
   11e48:	79eb      	ldrb	r3, [r5, #7]
   11e4a:	9302      	str	r3, [sp, #8]
   11e4c:	886b      	ldrh	r3, [r5, #2]
   11e4e:	9303      	str	r3, [sp, #12]
   11e50:	88ab      	ldrh	r3, [r5, #4]
   11e52:	9304      	str	r3, [sp, #16]
   11e54:	f896 3066 	ldrb.w	r3, [r6, #102]	; 0x66
   11e58:	9305      	str	r3, [sp, #20]
   11e5a:	2104      	movs	r1, #4
   11e5c:	2201      	movs	r2, #1
   11e5e:	4b70      	ldr	r3, [pc, #448]	; (12020 <ble_gap_adv_start+0x2c8>)
   11e60:	f00b f9e2 	bl	1d228 <log_printf>
        return rc;
    }

    BLE_HS_LOG(INFO, "GAP procedure initiated: advertise; ");
    ble_gap_log_adv(own_addr_type, peer_addr_type, peer_addr, adv_params);
    BLE_HS_LOG(INFO, "\n");
   11e64:	2201      	movs	r2, #1
   11e66:	4b6f      	ldr	r3, [pc, #444]	; (12024 <ble_gap_adv_start+0x2cc>)
   11e68:	4868      	ldr	r0, [pc, #416]	; (1200c <ble_gap_adv_start+0x2b4>)
   11e6a:	2104      	movs	r1, #4
   11e6c:	f00b f9dc 	bl	1d228 <log_printf>

    ble_gap_slave.cb = cb;
   11e70:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   11e72:	6233      	str	r3, [r6, #32]
    ble_gap_slave.cb_arg = cb_arg;
   11e74:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   11e76:	6273      	str	r3, [r6, #36]	; 0x24
    ble_gap_slave.conn_mode = adv_params->conn_mode;
   11e78:	782b      	ldrb	r3, [r5, #0]
   11e7a:	7733      	strb	r3, [r6, #28]
    ble_gap_slave.disc_mode = adv_params->disc_mode;
   11e7c:	786b      	ldrb	r3, [r5, #1]
   11e7e:	7773      	strb	r3, [r6, #29]
    ble_gap_slave.our_addr_type = own_addr_type;
   11e80:	7fb3      	ldrb	r3, [r6, #30]

    if (peer_addr == NULL) {
        peer_addr = ble_hs_misc_null_addr;
    }

    hci_adv_params.own_addr_type = own_addr_type;
   11e82:	f88d 801e 	strb.w	r8, [sp, #30]

    ble_gap_slave.cb = cb;
    ble_gap_slave.cb_arg = cb_arg;
    ble_gap_slave.conn_mode = adv_params->conn_mode;
    ble_gap_slave.disc_mode = adv_params->disc_mode;
    ble_gap_slave.our_addr_type = own_addr_type;
   11e86:	f368 0301 	bfi	r3, r8, #0, #2
   11e8a:	77b3      	strb	r3, [r6, #30]
    struct hci_adv_params hci_adv_params;
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_SET_ADV_PARAM_LEN];
    int rc;

    if (peer_addr == NULL) {
        peer_addr = ble_hs_misc_null_addr;
   11e8c:	4b66      	ldr	r3, [pc, #408]	; (12028 <ble_gap_adv_start+0x2d0>)
    hci_adv_params.peer_addr_type = peer_addr_type;
    memcpy(hci_adv_params.peer_addr, peer_addr,
           sizeof hci_adv_params.peer_addr);

    /* Fill optional fields if application did not specify them. */
    if (adv_params->itvl_min == 0 && adv_params->itvl_max == 0) {
   11e8e:	886a      	ldrh	r2, [r5, #2]
    if (peer_addr == NULL) {
        peer_addr = ble_hs_misc_null_addr;
    }

    hci_adv_params.own_addr_type = own_addr_type;
    hci_adv_params.peer_addr_type = peer_addr_type;
   11e90:	f88d a01f 	strb.w	sl, [sp, #31]
    struct hci_adv_params hci_adv_params;
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_SET_ADV_PARAM_LEN];
    int rc;

    if (peer_addr == NULL) {
        peer_addr = ble_hs_misc_null_addr;
   11e94:	2c00      	cmp	r4, #0
   11e96:	bf08      	it	eq
   11e98:	461c      	moveq	r4, r3
    }

    hci_adv_params.own_addr_type = own_addr_type;
    hci_adv_params.peer_addr_type = peer_addr_type;
    memcpy(hci_adv_params.peer_addr, peer_addr,
   11e9a:	6823      	ldr	r3, [r4, #0]
   11e9c:	f8cd 3026 	str.w	r3, [sp, #38]	; 0x26
   11ea0:	88a3      	ldrh	r3, [r4, #4]
   11ea2:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
   11ea6:	782b      	ldrb	r3, [r5, #0]
           sizeof hci_adv_params.peer_addr);

    /* Fill optional fields if application did not specify them. */
    if (adv_params->itvl_min == 0 && adv_params->itvl_max == 0) {
   11ea8:	b98a      	cbnz	r2, 11ece <ble_gap_adv_start+0x176>
   11eaa:	88a9      	ldrh	r1, [r5, #4]
   11eac:	b979      	cbnz	r1, 11ece <ble_gap_adv_start+0x176>

static void
ble_gap_adv_dflt_itvls(uint8_t conn_mode,
                       uint16_t *out_itvl_min, uint16_t *out_itvl_max)
{
    switch (conn_mode) {
   11eae:	2b01      	cmp	r3, #1
   11eb0:	d008      	beq.n	11ec4 <ble_gap_adv_start+0x16c>
   11eb2:	d302      	bcc.n	11eba <ble_gap_adv_start+0x162>
   11eb4:	2b02      	cmp	r3, #2
   11eb6:	d005      	beq.n	11ec4 <ble_gap_adv_start+0x16c>
   11eb8:	e00e      	b.n	11ed8 <ble_gap_adv_start+0x180>
    case BLE_GAP_CONN_MODE_NON:
        *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL2_MIN;
   11eba:	22a0      	movs	r2, #160	; 0xa0
   11ebc:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
        *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL2_MAX;
   11ec0:	22f0      	movs	r2, #240	; 0xf0
   11ec2:	e007      	b.n	11ed4 <ble_gap_adv_start+0x17c>
        *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
        *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
        break;

    case BLE_GAP_CONN_MODE_DIR:
        *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
   11ec4:	2230      	movs	r2, #48	; 0x30
   11ec6:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
        *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
   11eca:	2260      	movs	r2, #96	; 0x60
   11ecc:	e002      	b.n	11ed4 <ble_gap_adv_start+0x17c>
    if (adv_params->itvl_min == 0 && adv_params->itvl_max == 0) {
        ble_gap_adv_dflt_itvls(adv_params->conn_mode,
                               &hci_adv_params.adv_itvl_min,
                               &hci_adv_params.adv_itvl_max);
    } else {
        hci_adv_params.adv_itvl_min = adv_params->itvl_min;
   11ece:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
        hci_adv_params.adv_itvl_max = adv_params->itvl_max;
   11ed2:	88aa      	ldrh	r2, [r5, #4]
   11ed4:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
    }
    if (adv_params->channel_map == 0) {
   11ed8:	79aa      	ldrb	r2, [r5, #6]
   11eda:	b902      	cbnz	r2, 11ede <ble_gap_adv_start+0x186>
        hci_adv_params.adv_channel_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
   11edc:	2207      	movs	r2, #7
    } else {
        hci_adv_params.adv_channel_map = adv_params->channel_map;
   11ede:	f88d 201d 	strb.w	r2, [sp, #29]
    }

    /* Zero is the default value for filter policy and high duty cycle */
    hci_adv_params.adv_filter_policy = adv_params->filter_policy;
   11ee2:	79ea      	ldrb	r2, [r5, #7]
   11ee4:	f88d 2020 	strb.w	r2, [sp, #32]
}

static int
ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
{
    switch (adv_params->conn_mode) {
   11ee8:	b143      	cbz	r3, 11efc <ble_gap_adv_start+0x1a4>
   11eea:	2b01      	cmp	r3, #1
   11eec:	d10c      	bne.n	11f08 <ble_gap_adv_start+0x1b0>

    case BLE_GAP_CONN_MODE_UND:
        return BLE_HCI_ADV_TYPE_ADV_IND;

    case BLE_GAP_CONN_MODE_DIR:
        if (adv_params->high_duty_cycle) {
   11eee:	7a2b      	ldrb	r3, [r5, #8]
            return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD;
        } else {
            return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD;
   11ef0:	f013 0f01 	tst.w	r3, #1
   11ef4:	bf14      	ite	ne
   11ef6:	2301      	movne	r3, #1
   11ef8:	2304      	moveq	r3, #4
   11efa:	e006      	b.n	11f0a <ble_gap_adv_start+0x1b2>
static int
ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
{
    switch (adv_params->conn_mode) {
    case BLE_GAP_CONN_MODE_NON:
        if (adv_params->disc_mode == BLE_GAP_DISC_MODE_NON) {
   11efc:	786b      	ldrb	r3, [r5, #1]
            return BLE_HCI_ADV_TYPE_ADV_NONCONN_IND;
        } else {
            return BLE_HCI_ADV_TYPE_ADV_SCAN_IND;
   11efe:	2b00      	cmp	r3, #0
   11f00:	bf0c      	ite	eq
   11f02:	2303      	moveq	r3, #3
   11f04:	2302      	movne	r3, #2
   11f06:	e000      	b.n	11f0a <ble_gap_adv_start+0x1b2>
        }

    case BLE_GAP_CONN_MODE_UND:
        return BLE_HCI_ADV_TYPE_ADV_IND;
   11f08:	2300      	movs	r3, #0
    }

    /* Zero is the default value for filter policy and high duty cycle */
    hci_adv_params.adv_filter_policy = adv_params->filter_policy;

    hci_adv_params.adv_type = ble_gap_adv_type(adv_params);
   11f0a:	a814      	add	r0, sp, #80	; 0x50
    rc = host_hci_cmd_build_le_set_adv_params(&hci_adv_params,
   11f0c:	a90b      	add	r1, sp, #44	; 0x2c
    }

    /* Zero is the default value for filter policy and high duty cycle */
    hci_adv_params.adv_filter_policy = adv_params->filter_policy;

    hci_adv_params.adv_type = ble_gap_adv_type(adv_params);
   11f0e:	f800 3d34 	strb.w	r3, [r0, #-52]!
    rc = host_hci_cmd_build_le_set_adv_params(&hci_adv_params,
   11f12:	2212      	movs	r2, #18
   11f14:	f007 fb2e 	bl	19574 <host_hci_cmd_build_le_set_adv_params>
                                              buf, sizeof buf);
    if (rc != 0) {
   11f18:	2800      	cmp	r0, #0
   11f1a:	f47f af57 	bne.w	11dcc <ble_gap_adv_start+0x74>
        return BLE_HS_EINVAL;
    }

    rc = ble_hci_cmd_tx_empty_ack(buf);
   11f1e:	a80b      	add	r0, sp, #44	; 0x2c
   11f20:	f002 fb82 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    ble_gap_slave.disc_mode = adv_params->disc_mode;
    ble_gap_slave.our_addr_type = own_addr_type;

    rc = ble_gap_adv_params_tx(own_addr_type, peer_addr_type, peer_addr,
                               adv_params);
    if (rc != 0) {
   11f24:	4604      	mov	r4, r0
   11f26:	2800      	cmp	r0, #0
   11f28:	f47f af51 	bne.w	11dce <ble_gap_adv_start+0x76>
        goto done;
    }

    if (adv_params->conn_mode != BLE_GAP_CONN_MODE_DIR) {
   11f2c:	782b      	ldrb	r3, [r5, #0]
   11f2e:	2b01      	cmp	r3, #1
   11f30:	d107      	bne.n	11f42 <ble_gap_adv_start+0x1ea>
        if (rc != 0) {
            goto done;
        }
    }

    rc = ble_gap_adv_enable_tx(1);
   11f32:	2001      	movs	r0, #1
   11f34:	f7ff fc31 	bl	1179a <ble_gap_adv_enable_tx>
    if (rc != 0) {
   11f38:	4604      	mov	r4, r0
   11f3a:	2800      	cmp	r0, #0
   11f3c:	f47f af47 	bne.w	11dce <ble_gap_adv_start+0x76>
   11f40:	e04a      	b.n	11fd8 <ble_gap_adv_start+0x280>

    /* Calculate the flags AD field if requested by application.  Clear the
     * auto flag after encoding the flags so that we don't get repeated flags
     * fields on subsequent advertising procedures.
     */
    if (ble_gap_slave.adv_auto_flags) {
   11f42:	f896 3068 	ldrb.w	r3, [r6, #104]	; 0x68
   11f46:	07db      	lsls	r3, r3, #31
   11f48:	d51f      	bpl.n	11f8a <ble_gap_adv_start+0x232>
    uint8_t flags;
    int rc;

    /* Calculate the value of the flags field from the discoverable mode. */
    flags = 0;
    switch (ble_gap_slave.disc_mode) {
   11f4a:	4b2f      	ldr	r3, [pc, #188]	; (12008 <ble_gap_adv_start+0x2b0>)
{
    uint8_t flags;
    int rc;

    /* Calculate the value of the flags field from the discoverable mode. */
    flags = 0;
   11f4c:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
    switch (ble_gap_slave.disc_mode) {
   11f50:	7f5b      	ldrb	r3, [r3, #29]
   11f52:	2b01      	cmp	r3, #1
   11f54:	d001      	beq.n	11f5a <ble_gap_adv_start+0x202>
   11f56:	2b02      	cmp	r3, #2
   11f58:	d101      	bne.n	11f5e <ble_gap_adv_start+0x206>
    case BLE_GAP_DISC_MODE_LTD:
        flags |= BLE_HS_ADV_F_DISC_LTD;
        break;

    case BLE_GAP_DISC_MODE_GEN:
        flags |= BLE_HS_ADV_F_DISC_GEN;
   11f5a:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    default:
        BLE_HS_DBG_ASSERT(0);
        break;
    }

    flags |= BLE_HS_ADV_F_BREDR_UNSUP;
   11f5e:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   11f62:	f043 0304 	orr.w	r3, r3, #4
   11f66:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c

    if (flags != 0) {
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_FLAGS, 1, &flags,
   11f6a:	4b30      	ldr	r3, [pc, #192]	; (1202c <ble_gap_adv_start+0x2d4>)
   11f6c:	9300      	str	r3, [sp, #0]
   11f6e:	221f      	movs	r2, #31
   11f70:	2001      	movs	r0, #1
   11f72:	9201      	str	r2, [sp, #4]
   11f74:	3b3e      	subs	r3, #62	; 0x3e
   11f76:	4601      	mov	r1, r0
   11f78:	aa0b      	add	r2, sp, #44	; 0x2c
   11f7a:	f002 fdfe 	bl	14b7a <ble_hs_adv_set_flat>
     * auto flag after encoding the flags so that we don't get repeated flags
     * fields on subsequent advertising procedures.
     */
    if (ble_gap_slave.adv_auto_flags) {
        ble_gap_adv_data_set_flags();
        ble_gap_slave.adv_auto_flags = 0;
   11f7e:	f896 3068 	ldrb.w	r3, [r6, #104]	; 0x68
   11f82:	f36f 0300 	bfc	r3, #0, #1
   11f86:	f886 3068 	strb.w	r3, [r6, #104]	; 0x68
    }

    rc = host_hci_cmd_build_le_set_adv_data(ble_gap_slave.adv_data,
   11f8a:	4d1f      	ldr	r5, [pc, #124]	; (12008 <ble_gap_adv_start+0x2b0>)
   11f8c:	f896 1066 	ldrb.w	r1, [r6, #102]	; 0x66
   11f90:	f105 0028 	add.w	r0, r5, #40	; 0x28
   11f94:	aa0b      	add	r2, sp, #44	; 0x2c
   11f96:	2323      	movs	r3, #35	; 0x23
   11f98:	f007 fb35 	bl	19606 <host_hci_cmd_build_le_set_adv_data>
                                            ble_gap_slave.adv_data_len,
                                            buf, sizeof buf);
    if (rc != 0) {
   11f9c:	4604      	mov	r4, r0
   11f9e:	2800      	cmp	r0, #0
   11fa0:	f47f af15 	bne.w	11dce <ble_gap_adv_start+0x76>
        return rc;
    }

    rc = ble_hci_cmd_tx_empty_ack(buf);
   11fa4:	a80b      	add	r0, sp, #44	; 0x2c
   11fa6:	f002 fb3f 	bl	14628 <ble_hci_cmd_tx_empty_ack>
        goto done;
    }

    if (adv_params->conn_mode != BLE_GAP_CONN_MODE_DIR) {
        rc = ble_gap_adv_data_tx();
        if (rc != 0) {
   11faa:	4604      	mov	r4, r0
   11fac:	2800      	cmp	r0, #0
   11fae:	f47f af0e 	bne.w	11dce <ble_gap_adv_start+0x76>
ble_gap_adv_rsp_data_tx(void)
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_SET_SCAN_RSP_DATA_LEN];
    int rc;

    rc = host_hci_cmd_build_le_set_scan_rsp_data(ble_gap_slave.rsp_data,
   11fb2:	f105 0047 	add.w	r0, r5, #71	; 0x47
   11fb6:	f895 1067 	ldrb.w	r1, [r5, #103]	; 0x67
   11fba:	aa0b      	add	r2, sp, #44	; 0x2c
   11fbc:	2323      	movs	r3, #35	; 0x23
   11fbe:	f007 fb41 	bl	19644 <host_hci_cmd_build_le_set_scan_rsp_data>
                                                 ble_gap_slave.rsp_data_len,
                                                 buf, sizeof buf);
    if (rc != 0) {
   11fc2:	4604      	mov	r4, r0
   11fc4:	2800      	cmp	r0, #0
   11fc6:	f47f af02 	bne.w	11dce <ble_gap_adv_start+0x76>
        return rc;
    }

    rc = ble_hci_cmd_tx_empty_ack(buf);
   11fca:	a80b      	add	r0, sp, #44	; 0x2c
   11fcc:	f002 fb2c 	bl	14628 <ble_hci_cmd_tx_empty_ack>
        if (rc != 0) {
            goto done;
        }

        rc = ble_gap_adv_rsp_data_tx();
        if (rc != 0) {
   11fd0:	4604      	mov	r4, r0
   11fd2:	2800      	cmp	r0, #0
   11fd4:	d0ad      	beq.n	11f32 <ble_gap_adv_start+0x1da>
   11fd6:	e6fa      	b.n	11dce <ble_gap_adv_start+0x76>
    rc = ble_gap_adv_enable_tx(1);
    if (rc != 0) {
        goto done;
    }

    if (duration_ms != BLE_HS_FOREVER) {
   11fd8:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   11fdc:	4599      	cmp	r9, r3
   11fde:	d00a      	beq.n	11ff6 <ble_gap_adv_start+0x29e>
        ble_gap_slave_set_timer(duration_ticks);
   11fe0:	9d06      	ldr	r5, [sp, #24]
}

static void
ble_gap_slave_set_timer(uint32_t ticks_from_now)
{
    ble_gap_slave.exp_os_ticks = os_time_get() + ticks_from_now;
   11fe2:	f7f8 fbed 	bl	a7c0 <os_time_get>
    ble_gap_slave.exp_set = 1;
   11fe6:	7d73      	ldrb	r3, [r6, #21]
}

static void
ble_gap_slave_set_timer(uint32_t ticks_from_now)
{
    ble_gap_slave.exp_os_ticks = os_time_get() + ticks_from_now;
   11fe8:	4428      	add	r0, r5
    ble_gap_slave.exp_set = 1;
   11fea:	f043 0301 	orr.w	r3, r3, #1
}

static void
ble_gap_slave_set_timer(uint32_t ticks_from_now)
{
    ble_gap_slave.exp_os_ticks = os_time_get() + ticks_from_now;
   11fee:	61b0      	str	r0, [r6, #24]
    ble_gap_slave.exp_set = 1;
   11ff0:	7573      	strb	r3, [r6, #21]

    ble_gap_heartbeat_sched();
   11ff2:	f7ff fc31 	bl	11858 <ble_gap_heartbeat_sched>

    if (duration_ms != BLE_HS_FOREVER) {
        ble_gap_slave_set_timer(duration_ticks);
    }

    ble_gap_slave.op = BLE_GAP_OP_S_ADV;
   11ff6:	2301      	movs	r3, #1
   11ff8:	7533      	strb	r3, [r6, #20]
   11ffa:	e6e8      	b.n	11dce <ble_gap_adv_start+0x76>

    if (rc != 0) {
        STATS_INC(ble_gap_stats, adv_start_fail);
    }
    return rc;
}
   11ffc:	b014      	add	sp, #80	; 0x50
   11ffe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12002:	bf00      	nop
   12004:	200039c8 	.word	0x200039c8
   12008:	20000d94 	.word	0x20000d94
   1200c:	20003b9c 	.word	0x20003b9c
   12010:	0001f3b5 	.word	0x0001f3b5
   12014:	0001f3da 	.word	0x0001f3da
   12018:	0001ee7f 	.word	0x0001ee7f
   1201c:	0001f404 	.word	0x0001f404
   12020:	0001f409 	.word	0x0001f409
   12024:	0001fdec 	.word	0x0001fdec
   12028:	20003ba8 	.word	0x20003ba8
   1202c:	20000dfa 	.word	0x20000dfa

00012030 <ble_gap_adv_set_fields>:
 *                                  large to fit in an advertisement;
 *                              Other nonzero on failure.
 */
int
ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
{
   12030:	b538      	push	{r3, r4, r5, lr}
#endif

    int max_sz;
    int rc;

    STATS_INC(ble_gap_stats, adv_set_fields);
   12032:	4c17      	ldr	r4, [pc, #92]	; (12090 <ble_gap_adv_set_fields+0x60>)
   12034:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12036:	3301      	adds	r3, #1
 *                                  large to fit in an advertisement;
 *                              Other nonzero on failure.
 */
int
ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
{
   12038:	4605      	mov	r5, r0
#endif

    int max_sz;
    int rc;

    STATS_INC(ble_gap_stats, adv_set_fields);
   1203a:	6263      	str	r3, [r4, #36]	; 0x24

    ble_hs_lock();
   1203c:	f002 fb82 	bl	14744 <ble_hs_lock>

    /* Don't allow advertising fields to be set while advertising is active. */
    if (ble_gap_slave.op != BLE_GAP_OP_NULL) {
   12040:	4a14      	ldr	r2, [pc, #80]	; (12094 <ble_gap_adv_set_fields+0x64>)
   12042:	7d11      	ldrb	r1, [r2, #20]
   12044:	b9d9      	cbnz	r1, 1207e <ble_gap_adv_set_fields+0x4e>
    }

    /* If application has requested the stack to calculate the flags field
     * automatically (flags == 0), there is less room for user data.
     */
    if (adv_fields->flags_is_present && adv_fields->flags == 0) {
   12046:	882b      	ldrh	r3, [r5, #0]
   12048:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1204c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   12050:	f892 3068 	ldrb.w	r3, [r2, #104]	; 0x68
        max_sz = BLE_GAP_ADV_DATA_LIMIT_FLAGS;
        ble_gap_slave.adv_auto_flags = 1;
    } else {
        max_sz = BLE_GAP_ADV_DATA_LIMIT_NO_FLAGS;
        ble_gap_slave.adv_auto_flags = 0;
   12054:	bf18      	it	ne
   12056:	f361 0300 	bfine	r3, r1, #0, #1
    }

    rc = ble_hs_adv_set_fields(adv_fields, ble_gap_slave.adv_data,
   1205a:	490f      	ldr	r1, [pc, #60]	; (12098 <ble_gap_adv_set_fields+0x68>)
    if (adv_fields->flags_is_present && adv_fields->flags == 0) {
        max_sz = BLE_GAP_ADV_DATA_LIMIT_FLAGS;
        ble_gap_slave.adv_auto_flags = 1;
    } else {
        max_sz = BLE_GAP_ADV_DATA_LIMIT_NO_FLAGS;
        ble_gap_slave.adv_auto_flags = 0;
   1205c:	bf12      	itee	ne
   1205e:	f882 3068 	strbne.w	r3, [r2, #104]	; 0x68
    /* If application has requested the stack to calculate the flags field
     * automatically (flags == 0), there is less room for user data.
     */
    if (adv_fields->flags_is_present && adv_fields->flags == 0) {
        max_sz = BLE_GAP_ADV_DATA_LIMIT_FLAGS;
        ble_gap_slave.adv_auto_flags = 1;
   12062:	f043 0301 	orreq.w	r3, r3, #1
   12066:	f882 3068 	strbeq.w	r3, [r2, #104]	; 0x68
    } else {
        max_sz = BLE_GAP_ADV_DATA_LIMIT_NO_FLAGS;
        ble_gap_slave.adv_auto_flags = 0;
    }

    rc = ble_hs_adv_set_fields(adv_fields, ble_gap_slave.adv_data,
   1206a:	4628      	mov	r0, r5

    /* If application has requested the stack to calculate the flags field
     * automatically (flags == 0), there is less room for user data.
     */
    if (adv_fields->flags_is_present && adv_fields->flags == 0) {
        max_sz = BLE_GAP_ADV_DATA_LIMIT_FLAGS;
   1206c:	bf0c      	ite	eq
   1206e:	231c      	moveq	r3, #28
        ble_gap_slave.adv_auto_flags = 1;
    } else {
        max_sz = BLE_GAP_ADV_DATA_LIMIT_NO_FLAGS;
   12070:	231f      	movne	r3, #31
        ble_gap_slave.adv_auto_flags = 0;
    }

    rc = ble_hs_adv_set_fields(adv_fields, ble_gap_slave.adv_data,
   12072:	f101 023e 	add.w	r2, r1, #62	; 0x3e
   12076:	f002 fda0 	bl	14bba <ble_hs_adv_set_fields>
   1207a:	4605      	mov	r5, r0
   1207c:	e000      	b.n	12080 <ble_gap_adv_set_fields+0x50>

    ble_hs_lock();

    /* Don't allow advertising fields to be set while advertising is active. */
    if (ble_gap_slave.op != BLE_GAP_OP_NULL) {
        rc = BLE_HS_EBUSY;
   1207e:	250f      	movs	r5, #15
    if (rc != 0) {
        goto done;
    }

done:
    ble_hs_unlock();
   12080:	f002 fb68 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   12084:	b115      	cbz	r5, 1208c <ble_gap_adv_set_fields+0x5c>
        STATS_INC(ble_gap_stats, adv_set_fields_fail);
   12086:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   12088:	3301      	adds	r3, #1
   1208a:	62a3      	str	r3, [r4, #40]	; 0x28
    }
    return rc;
}
   1208c:	4628      	mov	r0, r5
   1208e:	bd38      	pop	{r3, r4, r5, pc}
   12090:	200039c8 	.word	0x200039c8
   12094:	20000d94 	.word	0x20000d94
   12098:	20000dbc 	.word	0x20000dbc

0001209c <ble_gap_terminate>:
 *                                  the specified handle;
 *                              Other nonzero on failure.
 */
int
ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
{
   1209c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_DISCONNECT_CMD_LEN];
    int rc;

    STATS_INC(ble_gap_stats, terminate);
   1209e:	4c14      	ldr	r4, [pc, #80]	; (120f0 <ble_gap_terminate+0x54>)
   120a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 *                                  the specified handle;
 *                              Other nonzero on failure.
 */
int
ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
{
   120a2:	4605      	mov	r5, r0
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_DISCONNECT_CMD_LEN];
    int rc;

    STATS_INC(ble_gap_stats, terminate);
   120a4:	3301      	adds	r3, #1
 *                                  the specified handle;
 *                              Other nonzero on failure.
 */
int
ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
{
   120a6:	460e      	mov	r6, r1
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_DISCONNECT_CMD_LEN];
    int rc;

    STATS_INC(ble_gap_stats, terminate);
   120a8:	6463      	str	r3, [r4, #68]	; 0x44

    ble_hs_lock();
   120aa:	f002 fb4b 	bl	14744 <ble_hs_lock>

    if (!ble_hs_conn_exists(conn_handle)) {
   120ae:	4628      	mov	r0, r5
   120b0:	f003 f92a 	bl	15308 <ble_hs_conn_exists>
   120b4:	b190      	cbz	r0, 120dc <ble_gap_terminate+0x40>
        rc = BLE_HS_ENOTCONN;
        goto done;
    }

    BLE_HS_LOG(INFO, "GAP procedure initiated: terminate connection; "
   120b6:	e88d 0060 	stmia.w	sp, {r5, r6}
   120ba:	480e      	ldr	r0, [pc, #56]	; (120f4 <ble_gap_terminate+0x58>)
   120bc:	4b0e      	ldr	r3, [pc, #56]	; (120f8 <ble_gap_terminate+0x5c>)
   120be:	2104      	movs	r1, #4
   120c0:	2201      	movs	r2, #1
   120c2:	f00b f8b1 	bl	1d228 <log_printf>
                     "conn_handle=%d hci_reason=%d\n",
               conn_handle, hci_reason);

    host_hci_cmd_build_disconnect(conn_handle, hci_reason,
   120c6:	4628      	mov	r0, r5
   120c8:	4631      	mov	r1, r6
   120ca:	aa02      	add	r2, sp, #8
   120cc:	2306      	movs	r3, #6
   120ce:	f007 fafc 	bl	196ca <host_hci_cmd_build_disconnect>
                                  buf, sizeof buf);
    rc = ble_hci_cmd_tx_empty_ack(buf);
   120d2:	a802      	add	r0, sp, #8
   120d4:	f002 faa8 	bl	14628 <ble_hci_cmd_tx_empty_ack>
   120d8:	4605      	mov	r5, r0
   120da:	e000      	b.n	120de <ble_gap_terminate+0x42>
    STATS_INC(ble_gap_stats, terminate);

    ble_hs_lock();

    if (!ble_hs_conn_exists(conn_handle)) {
        rc = BLE_HS_ENOTCONN;
   120dc:	2507      	movs	r5, #7
    }

    rc = 0;

done:
    ble_hs_unlock();
   120de:	f002 fb39 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   120e2:	b115      	cbz	r5, 120ea <ble_gap_terminate+0x4e>
        STATS_INC(ble_gap_stats, terminate_fail);
   120e4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   120e6:	3301      	adds	r3, #1
   120e8:	64a3      	str	r3, [r4, #72]	; 0x48
    }
    return rc;
}
   120ea:	4628      	mov	r0, r5
   120ec:	b004      	add	sp, #16
   120ee:	bd70      	pop	{r4, r5, r6, pc}
   120f0:	200039c8 	.word	0x200039c8
   120f4:	20003b9c 	.word	0x20003b9c
   120f8:	0001f5b0 	.word	0x0001f5b0

000120fc <ble_gap_rx_param_req>:
    return 0;
}

void
ble_gap_rx_param_req(struct hci_le_conn_param_req *evt)
{
   120fc:	b570      	push	{r4, r5, r6, lr}
   120fe:	4604      	mov	r4, r0
   12100:	b0a4      	sub	sp, #144	; 0x90
    uint8_t reject_reason;
    int rc;

    reject_reason = 0; /* Silence warning. */

    memset(&event, 0, sizeof event);
   12102:	2100      	movs	r1, #0
   12104:	2234      	movs	r2, #52	; 0x34
   12106:	a80a      	add	r0, sp, #40	; 0x28
   12108:	f7f6 ff83 	bl	9012 <memset>

    peer_params.itvl_min = evt->itvl_min;
   1210c:	88a3      	ldrh	r3, [r4, #4]
   1210e:	f8ad 3000 	strh.w	r3, [sp]
    peer_params.itvl_max = evt->itvl_max;
   12112:	88e3      	ldrh	r3, [r4, #6]
   12114:	f8ad 3002 	strh.w	r3, [sp, #2]
    peer_params.latency = evt->latency;
   12118:	8923      	ldrh	r3, [r4, #8]
   1211a:	f8ad 3004 	strh.w	r3, [sp, #4]
    peer_params.supervision_timeout = evt->timeout;
   1211e:	8963      	ldrh	r3, [r4, #10]
   12120:	f8ad 3006 	strh.w	r3, [sp, #6]
    peer_params.min_ce_len = 0;
   12124:	2300      	movs	r3, #0
   12126:	f8ad 3008 	strh.w	r3, [sp, #8]
    peer_params.max_ce_len = 0;
   1212a:	f8ad 300a 	strh.w	r3, [sp, #10]

    /* Copy the peer params into the self params to make it easy on the
     * application.  The application callback will change only the fields which
     * it finds unsuitable.
     */
    self_params = peer_params;
   1212e:	e89d 0007 	ldmia.w	sp, {r0, r1, r2}
   12132:	ae03      	add	r6, sp, #12
   12134:	e886 0007 	stmia.w	r6, {r0, r1, r2}

    memset(&event, 0, sizeof event);
   12138:	4619      	mov	r1, r3
   1213a:	2234      	movs	r2, #52	; 0x34
   1213c:	a80a      	add	r0, sp, #40	; 0x28
   1213e:	f7f6 ff68 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_CONN_UPDATE_REQ;
   12142:	2304      	movs	r3, #4
    event.conn_update_req.conn_handle = evt->connection_handle;
   12144:	8861      	ldrh	r1, [r4, #2]
     * it finds unsuitable.
     */
    self_params = peer_params;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_CONN_UPDATE_REQ;
   12146:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
    event.conn_update_req.conn_handle = evt->connection_handle;
    event.conn_update_req.self_params = &self_params;
    event.conn_update_req.peer_params = &peer_params;
    rc = ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   1214a:	a80a      	add	r0, sp, #40	; 0x28
     */
    self_params = peer_params;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_CONN_UPDATE_REQ;
    event.conn_update_req.conn_handle = evt->connection_handle;
   1214c:	f8ad 1034 	strh.w	r1, [sp, #52]	; 0x34
    event.conn_update_req.self_params = &self_params;
   12150:	960c      	str	r6, [sp, #48]	; 0x30
    event.conn_update_req.peer_params = &peer_params;
   12152:	f8cd d02c 	str.w	sp, [sp, #44]	; 0x2c
    rc = ble_gap_call_conn_event_cb(&event, evt->connection_handle);
   12156:	f7ff fb2e 	bl	117b6 <ble_gap_call_conn_event_cb>
   1215a:	8863      	ldrh	r3, [r4, #2]
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_CONN_PARAM_NEG_REPLY_LEN];
    struct hci_conn_param_neg_reply neg_reply;
    int rc;

    neg_reply.handle = conn_handle;
   1215c:	f8ad 3018 	strh.w	r3, [sp, #24]
    event.type = BLE_GAP_EVENT_CONN_UPDATE_REQ;
    event.conn_update_req.conn_handle = evt->connection_handle;
    event.conn_update_req.self_params = &self_params;
    event.conn_update_req.peer_params = &peer_params;
    rc = ble_gap_call_conn_event_cb(&event, evt->connection_handle);
    if (rc != 0) {
   12160:	4605      	mov	r5, r0
   12162:	b150      	cbz	r0, 1217a <ble_gap_rx_param_req+0x7e>
        reject_reason = rc;
   12164:	f88d 001a 	strb.w	r0, [sp, #26]
    int rc;

    neg_reply.handle = conn_handle;
    neg_reply.reason = reject_reason;

    host_hci_cmd_build_le_conn_param_neg_reply(&neg_reply, buf, sizeof buf);
   12168:	a917      	add	r1, sp, #92	; 0x5c
   1216a:	a806      	add	r0, sp, #24
   1216c:	2206      	movs	r2, #6
   1216e:	f007 fb7b 	bl	19868 <host_hci_cmd_build_le_conn_param_neg_reply>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   12172:	a817      	add	r0, sp, #92	; 0x5c
   12174:	f002 fa58 	bl	14628 <ble_hci_cmd_tx_empty_ack>
   12178:	e040      	b.n	121fc <ble_gap_rx_param_req+0x100>
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_CONN_PARAM_REPLY_LEN];
    struct hci_conn_param_reply pos_reply;
    int rc;

    pos_reply.handle = conn_handle;
    pos_reply.conn_itvl_min = params->itvl_min;
   1217a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1217e:	f8ad 301a 	strh.w	r3, [sp, #26]
    pos_reply.conn_itvl_max = params->itvl_max;
   12182:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   12186:	f8ad 301c 	strh.w	r3, [sp, #28]
    pos_reply.conn_latency = params->latency;
   1218a:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1218e:	f8ad 301e 	strh.w	r3, [sp, #30]
    pos_reply.supervision_timeout = params->supervision_timeout;
   12192:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   12196:	f8ad 3020 	strh.w	r3, [sp, #32]
    pos_reply.min_ce_len = params->min_ce_len;
   1219a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1219e:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
    pos_reply.max_ce_len = params->max_ce_len;

    host_hci_cmd_build_le_conn_param_reply(&pos_reply, buf, sizeof buf);
   121a2:	a806      	add	r0, sp, #24
    pos_reply.conn_itvl_min = params->itvl_min;
    pos_reply.conn_itvl_max = params->itvl_max;
    pos_reply.conn_latency = params->latency;
    pos_reply.supervision_timeout = params->supervision_timeout;
    pos_reply.min_ce_len = params->min_ce_len;
    pos_reply.max_ce_len = params->max_ce_len;
   121a4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   121a8:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24

    host_hci_cmd_build_le_conn_param_reply(&pos_reply, buf, sizeof buf);
   121ac:	a917      	add	r1, sp, #92	; 0x5c
   121ae:	2211      	movs	r2, #17
   121b0:	f007 fb2e 	bl	19810 <host_hci_cmd_build_le_conn_param_reply>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   121b4:	a817      	add	r0, sp, #92	; 0x5c
   121b6:	f002 fa37 	bl	14628 <ble_hci_cmd_tx_empty_ack>
   121ba:	8864      	ldrh	r4, [r4, #2]
        reject_reason = rc;
    }

    if (rc == 0) {
        rc = ble_gap_tx_param_pos_reply(evt->connection_handle, &self_params);
        if (rc != 0) {
   121bc:	4606      	mov	r6, r0
   121be:	b1c0      	cbz	r0, 121f2 <ble_gap_rx_param_req+0xf6>
}

static void
ble_gap_update_failed(uint16_t conn_handle, int status)
{
    STATS_INC(ble_gap_stats, update_fail);
   121c0:	4a0f      	ldr	r2, [pc, #60]	; (12200 <ble_gap_rx_param_req+0x104>)
   121c2:	6d93      	ldr	r3, [r2, #88]	; 0x58
   121c4:	3301      	adds	r3, #1
   121c6:	6593      	str	r3, [r2, #88]	; 0x58
    ble_hs_atomic_conn_set_flags(conn_handle, BLE_HS_CONN_F_UPDATE, 0);
   121c8:	4620      	mov	r0, r4
   121ca:	462a      	mov	r2, r5
   121cc:	2102      	movs	r1, #2
   121ce:	f002 ff79 	bl	150c4 <ble_hs_atomic_conn_set_flags>
static void
ble_gap_update_notify(uint16_t conn_handle, int status)
{
    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
   121d2:	4629      	mov	r1, r5
   121d4:	a817      	add	r0, sp, #92	; 0x5c
   121d6:	2234      	movs	r2, #52	; 0x34
   121d8:	f7f6 ff1b 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_CONN_UPDATE;
   121dc:	2303      	movs	r3, #3
    event.conn_update.conn_handle = conn_handle;
    event.conn_update.status = status;

    ble_gap_call_conn_event_cb(&event, conn_handle);
   121de:	a817      	add	r0, sp, #92	; 0x5c
   121e0:	4621      	mov	r1, r4
ble_gap_update_notify(uint16_t conn_handle, int status)
{
    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_CONN_UPDATE;
   121e2:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
    event.conn_update.conn_handle = conn_handle;
   121e6:	f8ad 4064 	strh.w	r4, [sp, #100]	; 0x64
    event.conn_update.status = status;
   121ea:	9618      	str	r6, [sp, #96]	; 0x60

    ble_gap_call_conn_event_cb(&event, conn_handle);
   121ec:	f7ff fae3 	bl	117b6 <ble_gap_call_conn_event_cb>
   121f0:	e004      	b.n	121fc <ble_gap_rx_param_req+0x100>
    if (rc == 0) {
        rc = ble_gap_tx_param_pos_reply(evt->connection_handle, &self_params);
        if (rc != 0) {
            ble_gap_update_failed(evt->connection_handle, rc);
        } else {
            ble_hs_atomic_conn_set_flags(evt->connection_handle,
   121f2:	4620      	mov	r0, r4
   121f4:	2102      	movs	r1, #2
   121f6:	2201      	movs	r2, #1
   121f8:	f002 ff64 	bl	150c4 <ble_hs_atomic_conn_set_flags>
                                         BLE_HS_CONN_F_UPDATE, 1);
        }
    } else {
        ble_gap_tx_param_neg_reply(evt->connection_handle, reject_reason);
    }
}
   121fc:	b024      	add	sp, #144	; 0x90
   121fe:	bd70      	pop	{r4, r5, r6, pc}
   12200:	200039c8 	.word	0x200039c8

00012204 <ble_gap_update_params>:
 *                              Other nonzero on error.
 */
int
ble_gap_update_params(uint16_t conn_handle,
                      const struct ble_gap_upd_params *params)
{
   12204:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif

    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gap_stats, update);
   12206:	4d32      	ldr	r5, [pc, #200]	; (122d0 <ble_gap_update_params+0xcc>)
   12208:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 *                              Other nonzero on error.
 */
int
ble_gap_update_params(uint16_t conn_handle,
                      const struct ble_gap_upd_params *params)
{
   1220a:	b093      	sub	sp, #76	; 0x4c
#endif

    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gap_stats, update);
   1220c:	3301      	adds	r3, #1
 *                              Other nonzero on error.
 */
int
ble_gap_update_params(uint16_t conn_handle,
                      const struct ble_gap_upd_params *params)
{
   1220e:	4607      	mov	r7, r0
   12210:	460c      	mov	r4, r1
#endif

    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gap_stats, update);
   12212:	656b      	str	r3, [r5, #84]	; 0x54

    ble_hs_lock();
   12214:	f002 fa96 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   12218:	4638      	mov	r0, r7
   1221a:	f003 f83b 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   1221e:	4606      	mov	r6, r0
   12220:	2800      	cmp	r0, #0
   12222:	d049      	beq.n	122b8 <ble_gap_update_params+0xb4>
        rc = BLE_HS_ENOTCONN;
        goto done;
    }

    if (conn->bhc_flags & BLE_HS_CONN_F_UPDATE) {
   12224:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
   12228:	079b      	lsls	r3, r3, #30
   1222a:	d447      	bmi.n	122bc <ble_gap_update_params+0xb8>
        rc = BLE_HS_EALREADY;
        goto done;
    }

    BLE_HS_LOG(INFO, "GAP procedure initiated: ");
   1222c:	4829      	ldr	r0, [pc, #164]	; (122d4 <ble_gap_update_params+0xd0>)
   1222e:	4b2a      	ldr	r3, [pc, #168]	; (122d8 <ble_gap_update_params+0xd4>)
   12230:	2104      	movs	r1, #4
   12232:	2201      	movs	r2, #1
   12234:	f00a fff8 	bl	1d228 <log_printf>

static void
ble_gap_log_update(uint16_t conn_handle,
                   const struct ble_gap_upd_params *params)
{
    BLE_HS_LOG(INFO, "connection parameter update; "
   12238:	9700      	str	r7, [sp, #0]
   1223a:	8823      	ldrh	r3, [r4, #0]
   1223c:	9301      	str	r3, [sp, #4]
   1223e:	8863      	ldrh	r3, [r4, #2]
   12240:	9302      	str	r3, [sp, #8]
   12242:	88a3      	ldrh	r3, [r4, #4]
   12244:	9303      	str	r3, [sp, #12]
   12246:	88e3      	ldrh	r3, [r4, #6]
   12248:	9304      	str	r3, [sp, #16]
   1224a:	8923      	ldrh	r3, [r4, #8]
   1224c:	9305      	str	r3, [sp, #20]
   1224e:	8963      	ldrh	r3, [r4, #10]
   12250:	9306      	str	r3, [sp, #24]
   12252:	4820      	ldr	r0, [pc, #128]	; (122d4 <ble_gap_update_params+0xd0>)
   12254:	4b21      	ldr	r3, [pc, #132]	; (122dc <ble_gap_update_params+0xd8>)
   12256:	2104      	movs	r1, #4
   12258:	2201      	movs	r2, #1
   1225a:	f00a ffe5 	bl	1d228 <log_printf>
        goto done;
    }

    BLE_HS_LOG(INFO, "GAP procedure initiated: ");
    ble_gap_log_update(conn_handle, params);
    BLE_HS_LOG(INFO, "\n");
   1225e:	481d      	ldr	r0, [pc, #116]	; (122d4 <ble_gap_update_params+0xd0>)
   12260:	4b1f      	ldr	r3, [pc, #124]	; (122e0 <ble_gap_update_params+0xdc>)
   12262:	2104      	movs	r1, #4
   12264:	2201      	movs	r2, #1
   12266:	f00a ffdf 	bl	1d228 <log_printf>
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_CONN_UPDATE_LEN];
    struct hci_conn_update cmd;
    int rc;

    cmd.handle = conn_handle;
    cmd.conn_itvl_min = params->itvl_min;
   1226a:	8823      	ldrh	r3, [r4, #0]
   1226c:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
    cmd.conn_itvl_max = params->itvl_max;
   12270:	8863      	ldrh	r3, [r4, #2]
   12272:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    cmd.conn_latency = params->latency;
   12276:	88a3      	ldrh	r3, [r4, #4]
   12278:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
    cmd.supervision_timeout = params->supervision_timeout;
   1227c:	88e3      	ldrh	r3, [r4, #6]
   1227e:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    cmd.min_ce_len = params->min_ce_len;
   12282:	8923      	ldrh	r3, [r4, #8]
   12284:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
    cmd.max_ce_len = params->max_ce_len;

    rc = host_hci_cmd_build_le_conn_update(&cmd, buf, sizeof buf);
   12288:	a809      	add	r0, sp, #36	; 0x24
    cmd.conn_itvl_min = params->itvl_min;
    cmd.conn_itvl_max = params->itvl_max;
    cmd.conn_latency = params->latency;
    cmd.supervision_timeout = params->supervision_timeout;
    cmd.min_ce_len = params->min_ce_len;
    cmd.max_ce_len = params->max_ce_len;
   1228a:	8963      	ldrh	r3, [r4, #10]
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_CONN_UPDATE_LEN];
    struct hci_conn_update cmd;
    int rc;

    cmd.handle = conn_handle;
   1228c:	f8ad 7024 	strh.w	r7, [sp, #36]	; 0x24
    cmd.conn_latency = params->latency;
    cmd.supervision_timeout = params->supervision_timeout;
    cmd.min_ce_len = params->min_ce_len;
    cmd.max_ce_len = params->max_ce_len;

    rc = host_hci_cmd_build_le_conn_update(&cmd, buf, sizeof buf);
   12290:	a90d      	add	r1, sp, #52	; 0x34
   12292:	2211      	movs	r2, #17
    cmd.conn_itvl_min = params->itvl_min;
    cmd.conn_itvl_max = params->itvl_max;
    cmd.conn_latency = params->latency;
    cmd.supervision_timeout = params->supervision_timeout;
    cmd.min_ce_len = params->min_ce_len;
    cmd.max_ce_len = params->max_ce_len;
   12294:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30

    rc = host_hci_cmd_build_le_conn_update(&cmd, buf, sizeof buf);
   12298:	f007 fa81 	bl	1979e <host_hci_cmd_build_le_conn_update>
    if (rc != 0) {
   1229c:	4604      	mov	r4, r0
   1229e:	b970      	cbnz	r0, 122be <ble_gap_update_params+0xba>
        return rc;
    }

    rc = ble_hci_cmd_tx_empty_ack(buf);
   122a0:	a80d      	add	r0, sp, #52	; 0x34
   122a2:	f002 f9c1 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    BLE_HS_LOG(INFO, "GAP procedure initiated: ");
    ble_gap_log_update(conn_handle, params);
    BLE_HS_LOG(INFO, "\n");

    rc = ble_gap_update_tx(conn_handle, params);
    if (rc != 0) {
   122a6:	4604      	mov	r4, r0
   122a8:	b948      	cbnz	r0, 122be <ble_gap_update_params+0xba>
        goto done;
    }

    conn->bhc_flags |= BLE_HS_CONN_F_UPDATE;
   122aa:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   122ae:	f043 0302 	orr.w	r3, r3, #2
   122b2:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
   122b6:	e002      	b.n	122be <ble_gap_update_params+0xba>

    ble_hs_lock();

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
   122b8:	2407      	movs	r4, #7
   122ba:	e000      	b.n	122be <ble_gap_update_params+0xba>
        goto done;
    }

    if (conn->bhc_flags & BLE_HS_CONN_F_UPDATE) {
        rc = BLE_HS_EALREADY;
   122bc:	2402      	movs	r4, #2
    }

    conn->bhc_flags |= BLE_HS_CONN_F_UPDATE;

done:
    ble_hs_unlock();
   122be:	f002 fa49 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   122c2:	b114      	cbz	r4, 122ca <ble_gap_update_params+0xc6>
        STATS_INC(ble_gap_stats, update_fail);
   122c4:	6dab      	ldr	r3, [r5, #88]	; 0x58
   122c6:	3301      	adds	r3, #1
   122c8:	65ab      	str	r3, [r5, #88]	; 0x58
    }
    return rc;
}
   122ca:	4620      	mov	r0, r4
   122cc:	b013      	add	sp, #76	; 0x4c
   122ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   122d0:	200039c8 	.word	0x200039c8
   122d4:	20003b9c 	.word	0x20003b9c
   122d8:	0001f629 	.word	0x0001f629
   122dc:	0001f643 	.word	0x0001f643
   122e0:	0001fdec 	.word	0x0001fdec

000122e4 <ble_gap_passkey_event>:
}

void
ble_gap_passkey_event(uint16_t conn_handle,
                      struct ble_gap_passkey_params *passkey_params)
{
   122e4:	b530      	push	{r4, r5, lr}
   122e6:	b091      	sub	sp, #68	; 0x44
    return;
#endif

    struct ble_gap_event event;

    BLE_HS_LOG(DEBUG, "send passkey action request %d\n",
   122e8:	780b      	ldrb	r3, [r1, #0]
   122ea:	9300      	str	r3, [sp, #0]
}

void
ble_gap_passkey_event(uint16_t conn_handle,
                      struct ble_gap_passkey_params *passkey_params)
{
   122ec:	4605      	mov	r5, r0
   122ee:	460c      	mov	r4, r1
    return;
#endif

    struct ble_gap_event event;

    BLE_HS_LOG(DEBUG, "send passkey action request %d\n",
   122f0:	4b0d      	ldr	r3, [pc, #52]	; (12328 <ble_gap_passkey_event+0x44>)
   122f2:	480e      	ldr	r0, [pc, #56]	; (1232c <ble_gap_passkey_event+0x48>)
   122f4:	2104      	movs	r1, #4
   122f6:	2200      	movs	r2, #0
   122f8:	f00a ff96 	bl	1d228 <log_printf>
               passkey_params->action);

    memset(&event, 0, sizeof event);
   122fc:	2234      	movs	r2, #52	; 0x34
   122fe:	a803      	add	r0, sp, #12
   12300:	2100      	movs	r1, #0
   12302:	f7f6 fe86 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_PASSKEY_ACTION;
    event.passkey.conn_handle = conn_handle;
    event.passkey.params = *passkey_params;
   12306:	e894 0003 	ldmia.w	r4, {r0, r1}

    BLE_HS_LOG(DEBUG, "send passkey action request %d\n",
               passkey_params->action);

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_PASSKEY_ACTION;
   1230a:	230b      	movs	r3, #11
   1230c:	f88d 300c 	strb.w	r3, [sp, #12]
    event.passkey.conn_handle = conn_handle;
    event.passkey.params = *passkey_params;
   12310:	ab04      	add	r3, sp, #16
   12312:	e883 0003 	stmia.w	r3, {r0, r1}
    ble_gap_call_conn_event_cb(&event, conn_handle);
   12316:	a803      	add	r0, sp, #12
   12318:	4629      	mov	r1, r5
    BLE_HS_LOG(DEBUG, "send passkey action request %d\n",
               passkey_params->action);

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_PASSKEY_ACTION;
    event.passkey.conn_handle = conn_handle;
   1231a:	f8ad 5018 	strh.w	r5, [sp, #24]
    event.passkey.params = *passkey_params;
    ble_gap_call_conn_event_cb(&event, conn_handle);
   1231e:	f7ff fa4a 	bl	117b6 <ble_gap_call_conn_event_cb>
}
   12322:	b011      	add	sp, #68	; 0x44
   12324:	bd30      	pop	{r4, r5, pc}
   12326:	bf00      	nop
   12328:	0001f6c5 	.word	0x0001f6c5
   1232c:	20003b9c 	.word	0x20003b9c

00012330 <ble_gap_enc_event>:

void
ble_gap_enc_event(uint16_t conn_handle, int status, int security_restored)
{
   12330:	b570      	push	{r4, r5, r6, lr}
   12332:	b08e      	sub	sp, #56	; 0x38
   12334:	4604      	mov	r4, r0
   12336:	460d      	mov	r5, r1
   12338:	4616      	mov	r6, r2
    return;
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
   1233a:	2100      	movs	r1, #0
   1233c:	a801      	add	r0, sp, #4
   1233e:	2234      	movs	r2, #52	; 0x34
   12340:	f7f6 fe67 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_ENC_CHANGE;
   12344:	230a      	movs	r3, #10
    event.enc_change.conn_handle = conn_handle;
    event.enc_change.status = status;
    ble_gap_call_conn_event_cb(&event, conn_handle);
   12346:	a801      	add	r0, sp, #4
   12348:	4621      	mov	r1, r4
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_ENC_CHANGE;
   1234a:	f88d 3004 	strb.w	r3, [sp, #4]
    event.enc_change.conn_handle = conn_handle;
   1234e:	f8ad 400c 	strh.w	r4, [sp, #12]
    event.enc_change.status = status;
   12352:	9502      	str	r5, [sp, #8]
    ble_gap_call_conn_event_cb(&event, conn_handle);
   12354:	f7ff fa2f 	bl	117b6 <ble_gap_call_conn_event_cb>

    if (status == 0 && security_restored) {
   12358:	b91d      	cbnz	r5, 12362 <ble_gap_enc_event+0x32>
   1235a:	b116      	cbz	r6, 12362 <ble_gap_enc_event+0x32>
        ble_gatts_bonding_restored(conn_handle);
   1235c:	4620      	mov	r0, r4
   1235e:	f001 ffab 	bl	142b8 <ble_gatts_bonding_restored>
    }
}
   12362:	b00e      	add	sp, #56	; 0x38
   12364:	bd70      	pop	{r4, r5, r6, pc}

00012366 <ble_gap_notify_rx_event>:
 *****************************************************************************/

void
ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
                        void *attr_data, uint16_t attr_len, int is_indication)
{
   12366:	b5f0      	push	{r4, r5, r6, r7, lr}
   12368:	b08f      	sub	sp, #60	; 0x3c
   1236a:	4604      	mov	r4, r0
   1236c:	460f      	mov	r7, r1
   1236e:	4616      	mov	r6, r2
    return;
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
   12370:	a801      	add	r0, sp, #4
   12372:	2100      	movs	r1, #0
   12374:	2234      	movs	r2, #52	; 0x34
 *****************************************************************************/

void
ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
                        void *attr_data, uint16_t attr_len, int is_indication)
{
   12376:	461d      	mov	r5, r3
    return;
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
   12378:	f7f6 fe4b 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_NOTIFY_RX;
    event.notify_rx.conn_handle = conn_handle;
    event.notify_rx.attr_handle = attr_handle;
    event.notify_rx.attr_data = attr_data;
    event.notify_rx.attr_len = attr_len;
    event.notify_rx.indication = is_indication;
   1237c:	9a14      	ldr	r2, [sp, #80]	; 0x50

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_NOTIFY_RX;
    event.notify_rx.conn_handle = conn_handle;
   1237e:	f8ad 4010 	strh.w	r4, [sp, #16]
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_NOTIFY_RX;
   12382:	230c      	movs	r3, #12
   12384:	f88d 3004 	strb.w	r3, [sp, #4]
    event.notify_rx.conn_handle = conn_handle;
    event.notify_rx.attr_handle = attr_handle;
    event.notify_rx.attr_data = attr_data;
    event.notify_rx.attr_len = attr_len;
    event.notify_rx.indication = is_indication;
   12388:	f04f 0300 	mov.w	r3, #0
   1238c:	f362 0300 	bfi	r3, r2, #0, #1
    ble_gap_call_conn_event_cb(&event, conn_handle);
   12390:	a801      	add	r0, sp, #4
   12392:	4621      	mov	r1, r4
    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_NOTIFY_RX;
    event.notify_rx.conn_handle = conn_handle;
    event.notify_rx.attr_handle = attr_handle;
   12394:	f8ad 700c 	strh.w	r7, [sp, #12]
    event.notify_rx.attr_data = attr_data;
   12398:	9602      	str	r6, [sp, #8]
    event.notify_rx.attr_len = attr_len;
   1239a:	f8ad 500e 	strh.w	r5, [sp, #14]
    event.notify_rx.indication = is_indication;
   1239e:	f88d 3012 	strb.w	r3, [sp, #18]
    ble_gap_call_conn_event_cb(&event, conn_handle);
   123a2:	f7ff fa08 	bl	117b6 <ble_gap_call_conn_event_cb>
}
   123a6:	b00f      	add	sp, #60	; 0x3c
   123a8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000123aa <ble_gap_notify_tx_event>:

void
ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
                        int is_indication)
{
   123aa:	b5f0      	push	{r4, r5, r6, r7, lr}
   123ac:	b08f      	sub	sp, #60	; 0x3c
   123ae:	460c      	mov	r4, r1
   123b0:	4607      	mov	r7, r0
   123b2:	4616      	mov	r6, r2
    return;
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
   123b4:	a801      	add	r0, sp, #4
   123b6:	2100      	movs	r1, #0
   123b8:	2234      	movs	r2, #52	; 0x34
}

void
ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
                        int is_indication)
{
   123ba:	461d      	mov	r5, r3
    return;
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
   123bc:	f7f6 fe29 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_NOTIFY_TX;
    event.notify_tx.conn_handle = conn_handle;
    event.notify_tx.status = status;
    event.notify_tx.attr_handle = attr_handle;
    event.notify_tx.indication = is_indication;
   123c0:	f04f 0200 	mov.w	r2, #0
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_NOTIFY_TX;
   123c4:	230d      	movs	r3, #13
    event.notify_tx.conn_handle = conn_handle;
    event.notify_tx.status = status;
    event.notify_tx.attr_handle = attr_handle;
    event.notify_tx.indication = is_indication;
   123c6:	f365 0200 	bfi	r2, r5, #0, #1
    ble_gap_call_conn_event_cb(&event, conn_handle);
   123ca:	a801      	add	r0, sp, #4
   123cc:	4621      	mov	r1, r4
#endif

    struct ble_gap_event event;

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_NOTIFY_TX;
   123ce:	f88d 3004 	strb.w	r3, [sp, #4]
    event.notify_tx.conn_handle = conn_handle;
   123d2:	f8ad 400c 	strh.w	r4, [sp, #12]
    event.notify_tx.status = status;
   123d6:	9702      	str	r7, [sp, #8]
    event.notify_tx.attr_handle = attr_handle;
   123d8:	f8ad 600e 	strh.w	r6, [sp, #14]
    event.notify_tx.indication = is_indication;
   123dc:	f88d 2010 	strb.w	r2, [sp, #16]
    ble_gap_call_conn_event_cb(&event, conn_handle);
   123e0:	f7ff f9e9 	bl	117b6 <ble_gap_call_conn_event_cb>
}
   123e4:	b00f      	add	sp, #60	; 0x3c
   123e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000123e8 <ble_gap_subscribe_event>:
void
ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
                        uint8_t reason,
                        uint8_t prev_notify, uint8_t cur_notify,
                        uint8_t prev_indicate, uint8_t cur_indicate)
{
   123e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   123ea:	b08f      	sub	sp, #60	; 0x3c
   123ec:	4605      	mov	r5, r0
   123ee:	460f      	mov	r7, r1
   123f0:	4616      	mov	r6, r2
                      prev_indicate != cur_indicate);
    BLE_HS_DBG_ASSERT(reason == BLE_GAP_SUBSCRIBE_REASON_WRITE ||
                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM  ||
                      reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);

    memset(&event, 0, sizeof event);
   123f2:	a801      	add	r0, sp, #4
   123f4:	2100      	movs	r1, #0
   123f6:	2234      	movs	r2, #52	; 0x34
void
ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
                        uint8_t reason,
                        uint8_t prev_notify, uint8_t cur_notify,
                        uint8_t prev_indicate, uint8_t cur_indicate)
{
   123f8:	461c      	mov	r4, r3
                      prev_indicate != cur_indicate);
    BLE_HS_DBG_ASSERT(reason == BLE_GAP_SUBSCRIBE_REASON_WRITE ||
                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM  ||
                      reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);

    memset(&event, 0, sizeof event);
   123fa:	f7f6 fe0a 	bl	9012 <memset>
    event.type = BLE_GAP_EVENT_SUBSCRIBE;
   123fe:	230e      	movs	r3, #14
   12400:	f88d 3004 	strb.w	r3, [sp, #4]
    event.subscribe.conn_handle = conn_handle;
    event.subscribe.attr_handle = attr_handle;
    event.subscribe.reason = reason;
    event.subscribe.prev_notify = !!prev_notify;
    event.subscribe.cur_notify = !!cur_notify;
   12404:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
    event.subscribe.prev_indicate = !!prev_indicate;
   12408:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM  ||
                      reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_SUBSCRIBE;
    event.subscribe.conn_handle = conn_handle;
   1240c:	f8ad 5008 	strh.w	r5, [sp, #8]
    event.subscribe.attr_handle = attr_handle;
    event.subscribe.reason = reason;
    event.subscribe.prev_notify = !!prev_notify;
    event.subscribe.cur_notify = !!cur_notify;
   12410:	3300      	adds	r3, #0
   12412:	bf18      	it	ne
   12414:	2301      	movne	r3, #1
   12416:	3400      	adds	r4, #0
   12418:	bf18      	it	ne
   1241a:	2401      	movne	r4, #1
    event.subscribe.prev_indicate = !!prev_indicate;
   1241c:	3200      	adds	r2, #0
   1241e:	bf18      	it	ne
   12420:	2201      	movne	r2, #1
   12422:	ea44 0343 	orr.w	r3, r4, r3, lsl #1
   12426:	f362 0382 	bfi	r3, r2, #2, #1
    event.subscribe.cur_indicate = !!cur_indicate;
   1242a:	f89d 2058 	ldrb.w	r2, [sp, #88]	; 0x58
                      reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_SUBSCRIBE;
    event.subscribe.conn_handle = conn_handle;
    event.subscribe.attr_handle = attr_handle;
   1242e:	f8ad 700a 	strh.w	r7, [sp, #10]
    event.subscribe.reason = reason;
    event.subscribe.prev_notify = !!prev_notify;
    event.subscribe.cur_notify = !!cur_notify;
    event.subscribe.prev_indicate = !!prev_indicate;
    event.subscribe.cur_indicate = !!cur_indicate;
   12432:	3200      	adds	r2, #0
   12434:	bf18      	it	ne
   12436:	2201      	movne	r2, #1
   12438:	f362 03c3 	bfi	r3, r2, #3, #1
    ble_gap_call_conn_event_cb(&event, conn_handle);
   1243c:	a801      	add	r0, sp, #4
   1243e:	4629      	mov	r1, r5

    memset(&event, 0, sizeof event);
    event.type = BLE_GAP_EVENT_SUBSCRIBE;
    event.subscribe.conn_handle = conn_handle;
    event.subscribe.attr_handle = attr_handle;
    event.subscribe.reason = reason;
   12440:	f88d 600c 	strb.w	r6, [sp, #12]
    event.subscribe.prev_notify = !!prev_notify;
    event.subscribe.cur_notify = !!cur_notify;
    event.subscribe.prev_indicate = !!prev_indicate;
    event.subscribe.cur_indicate = !!cur_indicate;
   12444:	f88d 300d 	strb.w	r3, [sp, #13]
    ble_gap_call_conn_event_cb(&event, conn_handle);
   12448:	f7ff f9b5 	bl	117b6 <ble_gap_call_conn_event_cb>
}
   1244c:	b00f      	add	sp, #60	; 0x3c
   1244e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012450 <ble_gap_init>:
 * $init                                                                     *
 *****************************************************************************/

int
ble_gap_init(void)
{
   12450:	b507      	push	{r0, r1, r2, lr}
    int rc;

    memset(&ble_gap_master, 0, sizeof ble_gap_master);
   12452:	2100      	movs	r1, #0
   12454:	2214      	movs	r2, #20
   12456:	480c      	ldr	r0, [pc, #48]	; (12488 <ble_gap_init+0x38>)
   12458:	f7f6 fddb 	bl	9012 <memset>
    memset(&ble_gap_slave, 0, sizeof ble_gap_slave);
   1245c:	2100      	movs	r1, #0
   1245e:	2258      	movs	r2, #88	; 0x58
   12460:	480a      	ldr	r0, [pc, #40]	; (1248c <ble_gap_init+0x3c>)
   12462:	f7f6 fdd6 	bl	9012 <memset>

    rc = stats_init_and_reg(
   12466:	2300      	movs	r3, #0
   12468:	4a09      	ldr	r2, [pc, #36]	; (12490 <ble_gap_init+0x40>)
   1246a:	9201      	str	r2, [sp, #4]
   1246c:	9300      	str	r3, [sp, #0]
   1246e:	2104      	movs	r1, #4
   12470:	221f      	movs	r2, #31
   12472:	4808      	ldr	r0, [pc, #32]	; (12494 <ble_gap_init+0x44>)
   12474:	f00a ff6a 	bl	1d34c <stats_init_and_reg>
        STATS_HDR(ble_gap_stats), STATS_SIZE_INIT_PARMS(ble_gap_stats,
        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_gap_stats), "ble_gap");
    if (rc != 0) {
   12478:	2800      	cmp	r0, #0
        return BLE_HS_EOS;
    }

    return 0;
}
   1247a:	bf14      	ite	ne
   1247c:	200b      	movne	r0, #11
   1247e:	2000      	moveq	r0, #0
   12480:	b003      	add	sp, #12
   12482:	f85d fb04 	ldr.w	pc, [sp], #4
   12486:	bf00      	nop
   12488:	20000d94 	.word	0x20000d94
   1248c:	20000da8 	.word	0x20000da8
   12490:	0001f6e5 	.word	0x0001f6e5
   12494:	200039c8 	.word	0x200039c8

00012498 <ble_gattc_error>:
ble_gattc_error(int status, uint16_t att_handle)
{
    static struct ble_gatt_error error;

    /* For consistency, always indicate a handle of 0 on success. */
    if (status == 0 || status == BLE_HS_EDONE) {
   12498:	4603      	mov	r3, r0
   1249a:	b118      	cbz	r0, 124a4 <ble_gattc_error+0xc>
        att_handle = 0;
   1249c:	280e      	cmp	r0, #14
   1249e:	bf08      	it	eq
   124a0:	2100      	moveq	r1, #0
   124a2:	e000      	b.n	124a6 <ble_gattc_error+0xe>
   124a4:	4601      	mov	r1, r0
    }

    error.status = status;
   124a6:	4802      	ldr	r0, [pc, #8]	; (124b0 <ble_gattc_error+0x18>)
   124a8:	8003      	strh	r3, [r0, #0]
    error.att_handle = att_handle;
   124aa:	8041      	strh	r1, [r0, #2]
    return &error;
}
   124ac:	4770      	bx	lr
   124ae:	bf00      	nop
   124b0:	200020c0 	.word	0x200020c0

000124b4 <ble_gattc_mtu_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_mtu_cb(struct ble_gattc_proc *proc, int status, uint16_t att_handle,
                 uint16_t mtu)
{
   124b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   124b8:	4605      	mov	r5, r0
   124ba:	461e      	mov	r6, r3
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   124bc:	b129      	cbz	r1, 124ca <ble_gattc_mtu_cb+0x16>
   124be:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, mtu_fail);
   124c0:	bf1f      	itttt	ne
   124c2:	4c0b      	ldrne	r4, [pc, #44]	; (124f0 <ble_gattc_mtu_cb+0x3c>)
   124c4:	6920      	ldrne	r0, [r4, #16]
   124c6:	3001      	addne	r0, #1
   124c8:	6120      	strne	r0, [r4, #16]
    }

    if (proc->mtu.cb == NULL) {
   124ca:	68ec      	ldr	r4, [r5, #12]
   124cc:	b164      	cbz	r4, 124e8 <ble_gattc_mtu_cb+0x34>
        rc = 0;
    } else {
        rc = proc->mtu.cb(proc->conn_handle,
                          ble_gattc_error(status, att_handle),
   124ce:	4608      	mov	r0, r1
   124d0:	4611      	mov	r1, r2
    }

    if (proc->mtu.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->mtu.cb(proc->conn_handle,
   124d2:	892f      	ldrh	r7, [r5, #8]
                          ble_gattc_error(status, att_handle),
   124d4:	f7ff ffe0 	bl	12498 <ble_gattc_error>
    }

    if (proc->mtu.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->mtu.cb(proc->conn_handle,
   124d8:	4632      	mov	r2, r6
                          ble_gattc_error(status, att_handle),
   124da:	4601      	mov	r1, r0
    }

    if (proc->mtu.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->mtu.cb(proc->conn_handle,
   124dc:	692b      	ldr	r3, [r5, #16]
   124de:	4638      	mov	r0, r7
   124e0:	46a4      	mov	ip, r4
                          ble_gattc_error(status, att_handle),
                          mtu, proc->mtu.cb_arg);
    }

    return rc;
}
   124e2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->mtu.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->mtu.cb(proc->conn_handle,
   124e6:	4760      	bx	ip
                          ble_gattc_error(status, att_handle),
                          mtu, proc->mtu.cb_arg);
    }

    return rc;
}
   124e8:	4620      	mov	r0, r4
   124ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   124ee:	bf00      	nop
   124f0:	20003a50 	.word	0x20003a50

000124f4 <ble_gattc_mtu_err>:
 */
static void
ble_gattc_mtu_err(struct ble_gattc_proc *proc, int status, uint16_t att_handle)
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_mtu_cb(proc, status, att_handle, 0);
   124f4:	2300      	movs	r3, #0
   124f6:	f7ff bfdd 	b.w	124b4 <ble_gattc_mtu_cb>
	...

000124fc <ble_gattc_disc_all_svcs_cb>:
 */
static int
ble_gattc_disc_all_svcs_cb(struct ble_gattc_proc *proc,
                           uint16_t status, uint16_t att_handle,
                           struct ble_gatt_svc *service)
{
   124fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12500:	4605      	mov	r5, r0
   12502:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(service != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   12504:	b129      	cbz	r1, 12512 <ble_gattc_disc_all_svcs_cb+0x16>
   12506:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, disc_all_svcs_fail);
   12508:	bf1f      	itttt	ne
   1250a:	4c0b      	ldrne	r4, [pc, #44]	; (12538 <ble_gattc_disc_all_svcs_cb+0x3c>)
   1250c:	69a0      	ldrne	r0, [r4, #24]
   1250e:	3001      	addne	r0, #1
   12510:	61a0      	strne	r0, [r4, #24]
    }

    if (proc->disc_all_svcs.cb == NULL) {
   12512:	692c      	ldr	r4, [r5, #16]
   12514:	b164      	cbz	r4, 12530 <ble_gattc_disc_all_svcs_cb+0x34>
        rc = 0;
    } else {
        rc = proc->disc_all_svcs.cb(proc->conn_handle,
                                    ble_gattc_error(status, att_handle),
   12516:	4608      	mov	r0, r1
   12518:	4611      	mov	r1, r2
    }

    if (proc->disc_all_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_svcs.cb(proc->conn_handle,
   1251a:	892f      	ldrh	r7, [r5, #8]
                                    ble_gattc_error(status, att_handle),
   1251c:	f7ff ffbc 	bl	12498 <ble_gattc_error>
    }

    if (proc->disc_all_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_svcs.cb(proc->conn_handle,
   12520:	4632      	mov	r2, r6
                                    ble_gattc_error(status, att_handle),
   12522:	4601      	mov	r1, r0
    }

    if (proc->disc_all_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_svcs.cb(proc->conn_handle,
   12524:	696b      	ldr	r3, [r5, #20]
   12526:	4638      	mov	r0, r7
   12528:	46a4      	mov	ip, r4
                                    ble_gattc_error(status, att_handle),
                                    service, proc->disc_all_svcs.cb_arg);
    }

    return rc;
}
   1252a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->disc_all_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_svcs.cb(proc->conn_handle,
   1252e:	4760      	bx	ip
                                    ble_gattc_error(status, att_handle),
                                    service, proc->disc_all_svcs.cb_arg);
    }

    return rc;
}
   12530:	4620      	mov	r0, r4
   12532:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12536:	bf00      	nop
   12538:	20003a50 	.word	0x20003a50

0001253c <ble_gattc_disc_all_svcs_err>:
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status == BLE_HS_ATT_ERR(BLE_ATT_ERR_ATTR_NOT_FOUND)) {
        /* Discovery is complete. */
        status = BLE_HS_EDONE;
   1253c:	f5b1 7f85 	cmp.w	r1, #266	; 0x10a
   12540:	bf08      	it	eq
   12542:	210e      	moveq	r1, #14
    }

    ble_gattc_disc_all_svcs_cb(proc, status, att_handle, NULL);
   12544:	b289      	uxth	r1, r1
   12546:	2300      	movs	r3, #0
   12548:	f7ff bfd8 	b.w	124fc <ble_gattc_disc_all_svcs_cb>

0001254c <ble_gattc_disc_svc_uuid_cb>:
 */
static int
ble_gattc_disc_svc_uuid_cb(struct ble_gattc_proc *proc, int status,
                           uint16_t att_handle,
                           struct ble_gatt_svc *service)
{
   1254c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12550:	4605      	mov	r5, r0
   12552:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(service != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   12554:	b129      	cbz	r1, 12562 <ble_gattc_disc_svc_uuid_cb+0x16>
   12556:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, disc_svc_uuid_fail);
   12558:	bf1f      	itttt	ne
   1255a:	4c0b      	ldrne	r4, [pc, #44]	; (12588 <ble_gattc_disc_svc_uuid_cb+0x3c>)
   1255c:	6a20      	ldrne	r0, [r4, #32]
   1255e:	3001      	addne	r0, #1
   12560:	6220      	strne	r0, [r4, #32]
    }

    if (proc->disc_svc_uuid.cb == NULL) {
   12562:	6a2c      	ldr	r4, [r5, #32]
   12564:	b164      	cbz	r4, 12580 <ble_gattc_disc_svc_uuid_cb+0x34>
        rc = 0;
    } else {
        rc = proc->disc_svc_uuid.cb(proc->conn_handle,
                                    ble_gattc_error(status, att_handle),
   12566:	4608      	mov	r0, r1
   12568:	4611      	mov	r1, r2
    }

    if (proc->disc_svc_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_svc_uuid.cb(proc->conn_handle,
   1256a:	892f      	ldrh	r7, [r5, #8]
                                    ble_gattc_error(status, att_handle),
   1256c:	f7ff ff94 	bl	12498 <ble_gattc_error>
    }

    if (proc->disc_svc_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_svc_uuid.cb(proc->conn_handle,
   12570:	4632      	mov	r2, r6
                                    ble_gattc_error(status, att_handle),
   12572:	4601      	mov	r1, r0
    }

    if (proc->disc_svc_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_svc_uuid.cb(proc->conn_handle,
   12574:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   12576:	4638      	mov	r0, r7
   12578:	46a4      	mov	ip, r4
                                    ble_gattc_error(status, att_handle),
                                    service, proc->disc_svc_uuid.cb_arg);
    }

    return rc;
}
   1257a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->disc_svc_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_svc_uuid.cb(proc->conn_handle,
   1257e:	4760      	bx	ip
                                    ble_gattc_error(status, att_handle),
                                    service, proc->disc_svc_uuid.cb_arg);
    }

    return rc;
}
   12580:	4620      	mov	r0, r4
   12582:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12586:	bf00      	nop
   12588:	20003a50 	.word	0x20003a50

0001258c <ble_gattc_disc_svc_uuid_err>:
    if (status == BLE_HS_ATT_ERR(BLE_ATT_ERR_ATTR_NOT_FOUND)) {
        /* Discovery is complete. */
        status = BLE_HS_EDONE;
    }

    ble_gattc_disc_svc_uuid_cb(proc, status, att_handle, NULL);
   1258c:	f5b1 7f85 	cmp.w	r1, #266	; 0x10a
   12590:	bf08      	it	eq
   12592:	210e      	moveq	r1, #14
   12594:	2300      	movs	r3, #0
   12596:	f7ff bfd9 	b.w	1254c <ble_gattc_disc_svc_uuid_cb>
	...

0001259c <ble_gattc_find_inc_svcs_cb>:
 */
static int
ble_gattc_find_inc_svcs_cb(struct ble_gattc_proc *proc, int status,
                           uint16_t att_handle,
                           struct ble_gatt_svc *service)
{
   1259c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   125a0:	4605      	mov	r5, r0
   125a2:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(service != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   125a4:	b129      	cbz	r1, 125b2 <ble_gattc_find_inc_svcs_cb+0x16>
   125a6:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, find_inc_svcs_fail);
   125a8:	bf1f      	itttt	ne
   125aa:	4c0b      	ldrne	r4, [pc, #44]	; (125d8 <ble_gattc_find_inc_svcs_cb+0x3c>)
   125ac:	6aa0      	ldrne	r0, [r4, #40]	; 0x28
   125ae:	3001      	addne	r0, #1
   125b0:	62a0      	strne	r0, [r4, #40]	; 0x28
    }

    if (proc->find_inc_svcs.cb == NULL) {
   125b2:	696c      	ldr	r4, [r5, #20]
   125b4:	b164      	cbz	r4, 125d0 <ble_gattc_find_inc_svcs_cb+0x34>
        rc = 0;
    } else {
        rc = proc->find_inc_svcs.cb(proc->conn_handle,
                                    ble_gattc_error(status, att_handle),
   125b6:	4608      	mov	r0, r1
   125b8:	4611      	mov	r1, r2
    }

    if (proc->find_inc_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->find_inc_svcs.cb(proc->conn_handle,
   125ba:	892f      	ldrh	r7, [r5, #8]
                                    ble_gattc_error(status, att_handle),
   125bc:	f7ff ff6c 	bl	12498 <ble_gattc_error>
    }

    if (proc->find_inc_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->find_inc_svcs.cb(proc->conn_handle,
   125c0:	4632      	mov	r2, r6
                                    ble_gattc_error(status, att_handle),
   125c2:	4601      	mov	r1, r0
    }

    if (proc->find_inc_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->find_inc_svcs.cb(proc->conn_handle,
   125c4:	69ab      	ldr	r3, [r5, #24]
   125c6:	4638      	mov	r0, r7
   125c8:	46a4      	mov	ip, r4
                                    ble_gattc_error(status, att_handle),
                                    service, proc->find_inc_svcs.cb_arg);
    }

    return rc;
}
   125ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->find_inc_svcs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->find_inc_svcs.cb(proc->conn_handle,
   125ce:	4760      	bx	ip
                                    ble_gattc_error(status, att_handle),
                                    service, proc->find_inc_svcs.cb_arg);
    }

    return rc;
}
   125d0:	4620      	mov	r0, r4
   125d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   125d6:	bf00      	nop
   125d8:	20003a50 	.word	0x20003a50

000125dc <ble_gattc_find_inc_svcs_err>:
ble_gattc_find_inc_svcs_err(struct ble_gattc_proc *proc, int status,
                            uint16_t att_handle)
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start == 0 &&
   125dc:	8a03      	ldrh	r3, [r0, #16]
   125de:	b91b      	cbnz	r3, 125e8 <ble_gattc_find_inc_svcs_err+0xc>
   125e0:	f5b1 7f85 	cmp.w	r1, #266	; 0x10a
        status == BLE_HS_ATT_ERR(BLE_ATT_ERR_ATTR_NOT_FOUND)) {

        /* Discovery is complete. */
        status = BLE_HS_EDONE;
   125e4:	bf08      	it	eq
   125e6:	210e      	moveq	r1, #14
    }

    ble_gattc_find_inc_svcs_cb(proc, status, att_handle, NULL);
   125e8:	2300      	movs	r3, #0
   125ea:	f7ff bfd7 	b.w	1259c <ble_gattc_find_inc_svcs_cb>
	...

000125f0 <ble_gattc_disc_all_chrs_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_disc_all_chrs_cb(struct ble_gattc_proc *proc, int status,
                           uint16_t att_handle, struct ble_gatt_chr *chr)
{
   125f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   125f4:	4605      	mov	r5, r0
   125f6:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(chr != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   125f8:	b129      	cbz	r1, 12606 <ble_gattc_disc_all_chrs_cb+0x16>
   125fa:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, disc_all_chrs_fail);
   125fc:	bf1f      	itttt	ne
   125fe:	4c0b      	ldrne	r4, [pc, #44]	; (1262c <ble_gattc_disc_all_chrs_cb+0x3c>)
   12600:	6b20      	ldrne	r0, [r4, #48]	; 0x30
   12602:	3001      	addne	r0, #1
   12604:	6320      	strne	r0, [r4, #48]	; 0x30
    }

    if (proc->disc_all_chrs.cb == NULL) {
   12606:	692c      	ldr	r4, [r5, #16]
   12608:	b164      	cbz	r4, 12624 <ble_gattc_disc_all_chrs_cb+0x34>
        rc = 0;
    } else {
        rc = proc->disc_all_chrs.cb(proc->conn_handle,
                                    ble_gattc_error(status, att_handle), chr,
   1260a:	4608      	mov	r0, r1
   1260c:	4611      	mov	r1, r2
    }

    if (proc->disc_all_chrs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_chrs.cb(proc->conn_handle,
   1260e:	892f      	ldrh	r7, [r5, #8]
                                    ble_gattc_error(status, att_handle), chr,
   12610:	f7ff ff42 	bl	12498 <ble_gattc_error>
    }

    if (proc->disc_all_chrs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_chrs.cb(proc->conn_handle,
   12614:	4632      	mov	r2, r6
                                    ble_gattc_error(status, att_handle), chr,
   12616:	4601      	mov	r1, r0
    }

    if (proc->disc_all_chrs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_chrs.cb(proc->conn_handle,
   12618:	696b      	ldr	r3, [r5, #20]
   1261a:	4638      	mov	r0, r7
   1261c:	46a4      	mov	ip, r4
                                    ble_gattc_error(status, att_handle), chr,
                                    proc->disc_all_chrs.cb_arg);
    }

    return rc;
}
   1261e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->disc_all_chrs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_chrs.cb(proc->conn_handle,
   12622:	4760      	bx	ip
                                    ble_gattc_error(status, att_handle), chr,
                                    proc->disc_all_chrs.cb_arg);
    }

    return rc;
}
   12624:	4620      	mov	r0, r4
   12626:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1262a:	bf00      	nop
   1262c:	20003a50 	.word	0x20003a50

00012630 <ble_gattc_disc_all_chrs_err>:
    if (status == BLE_HS_ATT_ERR(BLE_ATT_ERR_ATTR_NOT_FOUND)) {
        /* Discovery is complete. */
        status = BLE_HS_EDONE;
    }

    ble_gattc_disc_all_chrs_cb(proc, status, att_handle, NULL);
   12630:	f5b1 7f85 	cmp.w	r1, #266	; 0x10a
   12634:	bf08      	it	eq
   12636:	210e      	moveq	r1, #14
   12638:	2300      	movs	r3, #0
   1263a:	f7ff bfd9 	b.w	125f0 <ble_gattc_disc_all_chrs_cb>
	...

00012640 <ble_gattc_disc_chr_uuid_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_disc_chr_uuid_cb(struct ble_gattc_proc *proc, int status,
                           uint16_t att_handle, struct ble_gatt_chr *chr)
{
   12640:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12644:	4605      	mov	r5, r0
   12646:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(chr != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   12648:	b129      	cbz	r1, 12656 <ble_gattc_disc_chr_uuid_cb+0x16>
   1264a:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, disc_chrs_uuid_fail);
   1264c:	bf1f      	itttt	ne
   1264e:	4c0b      	ldrne	r4, [pc, #44]	; (1267c <ble_gattc_disc_chr_uuid_cb+0x3c>)
   12650:	6ba0      	ldrne	r0, [r4, #56]	; 0x38
   12652:	3001      	addne	r0, #1
   12654:	63a0      	strne	r0, [r4, #56]	; 0x38
    }

    if (proc->disc_chr_uuid.cb == NULL) {
   12656:	6a2c      	ldr	r4, [r5, #32]
   12658:	b164      	cbz	r4, 12674 <ble_gattc_disc_chr_uuid_cb+0x34>
        rc = 0;
    } else {
        rc = proc->disc_chr_uuid.cb(proc->conn_handle,
                                    ble_gattc_error(status, att_handle), chr,
   1265a:	4608      	mov	r0, r1
   1265c:	4611      	mov	r1, r2
    }

    if (proc->disc_chr_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_chr_uuid.cb(proc->conn_handle,
   1265e:	892f      	ldrh	r7, [r5, #8]
                                    ble_gattc_error(status, att_handle), chr,
   12660:	f7ff ff1a 	bl	12498 <ble_gattc_error>
    }

    if (proc->disc_chr_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_chr_uuid.cb(proc->conn_handle,
   12664:	4632      	mov	r2, r6
                                    ble_gattc_error(status, att_handle), chr,
   12666:	4601      	mov	r1, r0
    }

    if (proc->disc_chr_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_chr_uuid.cb(proc->conn_handle,
   12668:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1266a:	4638      	mov	r0, r7
   1266c:	46a4      	mov	ip, r4
                                    ble_gattc_error(status, att_handle), chr,
                                    proc->disc_chr_uuid.cb_arg);
    }

    return rc;
}
   1266e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->disc_chr_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_chr_uuid.cb(proc->conn_handle,
   12672:	4760      	bx	ip
                                    ble_gattc_error(status, att_handle), chr,
                                    proc->disc_chr_uuid.cb_arg);
    }

    return rc;
}
   12674:	4620      	mov	r0, r4
   12676:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1267a:	bf00      	nop
   1267c:	20003a50 	.word	0x20003a50

00012680 <ble_gattc_disc_chr_uuid_err>:
    if (status == BLE_HS_ATT_ERR(BLE_ATT_ERR_ATTR_NOT_FOUND)) {
        /* Discovery is complete. */
        status = BLE_HS_EDONE;
    }

    ble_gattc_disc_chr_uuid_cb(proc, status, att_handle, NULL);
   12680:	f5b1 7f85 	cmp.w	r1, #266	; 0x10a
   12684:	bf08      	it	eq
   12686:	210e      	moveq	r1, #14
   12688:	2300      	movs	r3, #0
   1268a:	f7ff bfd9 	b.w	12640 <ble_gattc_disc_chr_uuid_cb>
	...

00012690 <ble_gattc_disc_all_dscs_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_disc_all_dscs_cb(struct ble_gattc_proc *proc, int status,
                           uint16_t att_handle, struct ble_gatt_dsc *dsc)
{
   12690:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12692:	4605      	mov	r5, r0
   12694:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(dsc != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   12696:	b129      	cbz	r1, 126a4 <ble_gattc_disc_all_dscs_cb+0x14>
   12698:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, disc_all_dscs_fail);
   1269a:	bf1f      	itttt	ne
   1269c:	4c0a      	ldrne	r4, [pc, #40]	; (126c8 <ble_gattc_disc_all_dscs_cb+0x38>)
   1269e:	6c20      	ldrne	r0, [r4, #64]	; 0x40
   126a0:	3001      	addne	r0, #1
   126a2:	6420      	strne	r0, [r4, #64]	; 0x40
    }

    if (proc->disc_all_dscs.cb == NULL) {
   126a4:	696c      	ldr	r4, [r5, #20]
   126a6:	b164      	cbz	r4, 126c2 <ble_gattc_disc_all_dscs_cb+0x32>
        rc = 0;
    } else {
        rc = proc->disc_all_dscs.cb(proc->conn_handle,
                                    ble_gattc_error(status, att_handle),
   126a8:	4608      	mov	r0, r1
   126aa:	4611      	mov	r1, r2
    }

    if (proc->disc_all_dscs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_dscs.cb(proc->conn_handle,
   126ac:	892f      	ldrh	r7, [r5, #8]
                                    ble_gattc_error(status, att_handle),
   126ae:	f7ff fef3 	bl	12498 <ble_gattc_error>
    }

    if (proc->disc_all_dscs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_dscs.cb(proc->conn_handle,
   126b2:	69ab      	ldr	r3, [r5, #24]
   126b4:	9300      	str	r3, [sp, #0]
                                    ble_gattc_error(status, att_handle),
   126b6:	4601      	mov	r1, r0
    }

    if (proc->disc_all_dscs.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->disc_all_dscs.cb(proc->conn_handle,
   126b8:	89aa      	ldrh	r2, [r5, #12]
   126ba:	4638      	mov	r0, r7
   126bc:	4633      	mov	r3, r6
   126be:	47a0      	blx	r4
   126c0:	e000      	b.n	126c4 <ble_gattc_disc_all_dscs_cb+0x34>
    if (status != 0 && status != BLE_HS_EDONE) {
        STATS_INC(ble_gattc_stats, disc_all_dscs_fail);
    }

    if (proc->disc_all_dscs.cb == NULL) {
        rc = 0;
   126c2:	4620      	mov	r0, r4
                                    proc->disc_all_dscs.chr_val_handle,
                                    dsc, proc->disc_all_dscs.cb_arg);
    }

    return rc;
}
   126c4:	b003      	add	sp, #12
   126c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   126c8:	20003a50 	.word	0x20003a50

000126cc <ble_gattc_disc_all_dscs_err>:
    if (status == BLE_HS_ATT_ERR(BLE_ATT_ERR_ATTR_NOT_FOUND)) {
        /* Discovery is complete. */
        status = BLE_HS_EDONE;
    }

    ble_gattc_disc_all_dscs_cb(proc, status, att_handle, NULL);
   126cc:	f5b1 7f85 	cmp.w	r1, #266	; 0x10a
   126d0:	bf08      	it	eq
   126d2:	210e      	moveq	r1, #14
   126d4:	2300      	movs	r3, #0
   126d6:	f7ff bfdb 	b.w	12690 <ble_gattc_disc_all_dscs_cb>
	...

000126dc <ble_gattc_read_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_read_cb(struct ble_gattc_proc *proc, int status,
                  uint16_t att_handle, struct ble_gatt_attr *attr)
{
   126dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   126e0:	4605      	mov	r5, r0
   126e2:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(attr != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   126e4:	b129      	cbz	r1, 126f2 <ble_gattc_read_cb+0x16>
   126e6:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, read_fail);
   126e8:	bf1f      	itttt	ne
   126ea:	4c0b      	ldrne	r4, [pc, #44]	; (12718 <ble_gattc_read_cb+0x3c>)
   126ec:	6ca0      	ldrne	r0, [r4, #72]	; 0x48
   126ee:	3001      	addne	r0, #1
   126f0:	64a0      	strne	r0, [r4, #72]	; 0x48
    }

    if (proc->read.cb == NULL) {
   126f2:	692c      	ldr	r4, [r5, #16]
   126f4:	b164      	cbz	r4, 12710 <ble_gattc_read_cb+0x34>
        rc = 0;
    } else {
        rc = proc->read.cb(proc->conn_handle,
                           ble_gattc_error(status, att_handle), attr,
   126f6:	4608      	mov	r0, r1
   126f8:	4611      	mov	r1, r2
    }

    if (proc->read.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read.cb(proc->conn_handle,
   126fa:	892f      	ldrh	r7, [r5, #8]
                           ble_gattc_error(status, att_handle), attr,
   126fc:	f7ff fecc 	bl	12498 <ble_gattc_error>
    }

    if (proc->read.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read.cb(proc->conn_handle,
   12700:	4632      	mov	r2, r6
                           ble_gattc_error(status, att_handle), attr,
   12702:	4601      	mov	r1, r0
    }

    if (proc->read.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read.cb(proc->conn_handle,
   12704:	696b      	ldr	r3, [r5, #20]
   12706:	4638      	mov	r0, r7
   12708:	46a4      	mov	ip, r4
                           ble_gattc_error(status, att_handle), attr,
                           proc->read.cb_arg);
    }

    return rc;
}
   1270a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->read.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read.cb(proc->conn_handle,
   1270e:	4760      	bx	ip
                           ble_gattc_error(status, att_handle), attr,
                           proc->read.cb_arg);
    }

    return rc;
}
   12710:	4620      	mov	r0, r4
   12712:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12716:	bf00      	nop
   12718:	20003a50 	.word	0x20003a50

0001271c <ble_gattc_read_err>:
static void
ble_gattc_read_err(struct ble_gattc_proc *proc, int status,
                   uint16_t att_handle)
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_read_cb(proc, status, att_handle, NULL);
   1271c:	2300      	movs	r3, #0
   1271e:	f7ff bfdd 	b.w	126dc <ble_gattc_read_cb>

00012722 <ble_gattc_read_rx_read_rsp>:
 * read-characteristic-value proc.
 */
static int
ble_gattc_read_rx_read_rsp(struct ble_gattc_proc *proc, int status,
                           void *value, int value_len)
{
   12722:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    struct ble_gatt_attr attr;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr.handle = proc->read.handle;
   12724:	8984      	ldrh	r4, [r0, #12]
   12726:	f8ad 4004 	strh.w	r4, [sp, #4]
    attr.offset = 0;
   1272a:	2400      	movs	r4, #0
    attr.value_len = value_len;
   1272c:	f8ad 3008 	strh.w	r3, [sp, #8]
    attr.value = value;
   12730:	9203      	str	r2, [sp, #12]

    ble_gattc_read_cb(proc, status, 0, &attr);
   12732:	ab01      	add	r3, sp, #4
   12734:	4622      	mov	r2, r4
    struct ble_gatt_attr attr;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr.handle = proc->read.handle;
    attr.offset = 0;
   12736:	f8ad 4006 	strh.w	r4, [sp, #6]
    attr.value_len = value_len;
    attr.value = value;

    ble_gattc_read_cb(proc, status, 0, &attr);
   1273a:	f7ff ffcf 	bl	126dc <ble_gattc_read_cb>

    /* The read operation only has a single request / response exchange. */
    return BLE_HS_EDONE;
}
   1273e:	200e      	movs	r0, #14
   12740:	b004      	add	sp, #16
   12742:	bd10      	pop	{r4, pc}

00012744 <ble_gattc_read_uuid_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_read_uuid_cb(struct ble_gattc_proc *proc, int status,
                       uint16_t att_handle, struct ble_gatt_attr *attr)
{
   12744:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12748:	4605      	mov	r5, r0
   1274a:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(attr != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   1274c:	b129      	cbz	r1, 1275a <ble_gattc_read_uuid_cb+0x16>
   1274e:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, read_uuid_fail);
   12750:	bf1f      	itttt	ne
   12752:	4c0b      	ldrne	r4, [pc, #44]	; (12780 <ble_gattc_read_uuid_cb+0x3c>)
   12754:	6d20      	ldrne	r0, [r4, #80]	; 0x50
   12756:	3001      	addne	r0, #1
   12758:	6520      	strne	r0, [r4, #80]	; 0x50
    }

    if (proc->read_uuid.cb == NULL) {
   1275a:	68ec      	ldr	r4, [r5, #12]
   1275c:	b164      	cbz	r4, 12778 <ble_gattc_read_uuid_cb+0x34>
        rc = 0;
    } else {
        rc = proc->read_uuid.cb(proc->conn_handle,
                                ble_gattc_error(status, att_handle), attr,
   1275e:	4608      	mov	r0, r1
   12760:	4611      	mov	r1, r2
    }

    if (proc->read_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_uuid.cb(proc->conn_handle,
   12762:	892f      	ldrh	r7, [r5, #8]
                                ble_gattc_error(status, att_handle), attr,
   12764:	f7ff fe98 	bl	12498 <ble_gattc_error>
    }

    if (proc->read_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_uuid.cb(proc->conn_handle,
   12768:	4632      	mov	r2, r6
                                ble_gattc_error(status, att_handle), attr,
   1276a:	4601      	mov	r1, r0
    }

    if (proc->read_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_uuid.cb(proc->conn_handle,
   1276c:	692b      	ldr	r3, [r5, #16]
   1276e:	4638      	mov	r0, r7
   12770:	46a4      	mov	ip, r4
                                ble_gattc_error(status, att_handle), attr,
                                proc->read_uuid.cb_arg);
    }

    return rc;
}
   12772:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->read_uuid.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_uuid.cb(proc->conn_handle,
   12776:	4760      	bx	ip
                                ble_gattc_error(status, att_handle), attr,
                                proc->read_uuid.cb_arg);
    }

    return rc;
}
   12778:	4620      	mov	r0, r4
   1277a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1277e:	bf00      	nop
   12780:	20003a50 	.word	0x20003a50

00012784 <ble_gattc_read_uuid_err>:

    if (status == BLE_HS_ATT_ERR(BLE_ATT_ERR_ATTR_NOT_FOUND)) {
        /* Read is complete. */
        status = 0;
    }
    ble_gattc_read_uuid_cb(proc, status, att_handle, NULL);
   12784:	f5b1 7f85 	cmp.w	r1, #266	; 0x10a
   12788:	bf08      	it	eq
   1278a:	2100      	moveq	r1, #0
   1278c:	2300      	movs	r3, #0
   1278e:	f7ff bfd9 	b.w	12744 <ble_gattc_read_uuid_cb>

00012792 <ble_gattc_read_uuid_rx_adata>:
 * the specified read-using-characteristic-uuid proc.
 */
static int
ble_gattc_read_uuid_rx_adata(struct ble_gattc_proc *proc,
                             struct ble_att_read_type_adata *adata)
{
   12792:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   12794:	460b      	mov	r3, r1
    struct ble_gatt_attr attr;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr.handle = adata->att_handle;
   12796:	880a      	ldrh	r2, [r1, #0]
   12798:	f8ad 2004 	strh.w	r2, [sp, #4]
    attr.offset = 0;
   1279c:	2100      	movs	r1, #0
    attr.value_len = adata->value_len;
   1279e:	685a      	ldr	r2, [r3, #4]
    attr.value = adata->value;
   127a0:	689b      	ldr	r3, [r3, #8]

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr.handle = adata->att_handle;
    attr.offset = 0;
    attr.value_len = adata->value_len;
   127a2:	f8ad 2008 	strh.w	r2, [sp, #8]
    attr.value = adata->value;
   127a6:	9303      	str	r3, [sp, #12]

    rc = ble_gattc_read_uuid_cb(proc, 0, 0, &attr);
   127a8:	460a      	mov	r2, r1
   127aa:	ab01      	add	r3, sp, #4
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr.handle = adata->att_handle;
    attr.offset = 0;
   127ac:	f8ad 1006 	strh.w	r1, [sp, #6]
    attr.value_len = adata->value_len;
    attr.value = adata->value;

    rc = ble_gattc_read_uuid_cb(proc, 0, 0, &attr);
   127b0:	f7ff ffc8 	bl	12744 <ble_gattc_read_uuid_cb>
    if (rc != 0) {
   127b4:	2800      	cmp	r0, #0
        return BLE_HS_EDONE;
    }

    return 0;
}
   127b6:	bf14      	ite	ne
   127b8:	200e      	movne	r0, #14
   127ba:	2000      	moveq	r0, #0
   127bc:	b005      	add	sp, #20
   127be:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000127c4 <ble_gattc_read_long_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_read_long_cb(struct ble_gattc_proc *proc, int status,
                       uint16_t att_handle, struct ble_gatt_attr *attr)
{
   127c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   127c8:	4605      	mov	r5, r0
   127ca:	461e      	mov	r6, r3

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(attr != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   127cc:	b129      	cbz	r1, 127da <ble_gattc_read_long_cb+0x16>
   127ce:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, read_long_fail);
   127d0:	bf1f      	itttt	ne
   127d2:	4c0b      	ldrne	r4, [pc, #44]	; (12800 <ble_gattc_read_long_cb+0x3c>)
   127d4:	6da0      	ldrne	r0, [r4, #88]	; 0x58
   127d6:	3001      	addne	r0, #1
   127d8:	65a0      	strne	r0, [r4, #88]	; 0x58
    }

    if (proc->read_long.cb == NULL) {
   127da:	692c      	ldr	r4, [r5, #16]
   127dc:	b164      	cbz	r4, 127f8 <ble_gattc_read_long_cb+0x34>
        rc = 0;
    } else {
        rc = proc->read_long.cb(proc->conn_handle,
                                ble_gattc_error(status, att_handle), attr,
   127de:	4608      	mov	r0, r1
   127e0:	4611      	mov	r1, r2
    }

    if (proc->read_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_long.cb(proc->conn_handle,
   127e2:	892f      	ldrh	r7, [r5, #8]
                                ble_gattc_error(status, att_handle), attr,
   127e4:	f7ff fe58 	bl	12498 <ble_gattc_error>
    }

    if (proc->read_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_long.cb(proc->conn_handle,
   127e8:	4632      	mov	r2, r6
                                ble_gattc_error(status, att_handle), attr,
   127ea:	4601      	mov	r1, r0
    }

    if (proc->read_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_long.cb(proc->conn_handle,
   127ec:	696b      	ldr	r3, [r5, #20]
   127ee:	4638      	mov	r0, r7
   127f0:	46a4      	mov	ip, r4
                                ble_gattc_error(status, att_handle), attr,
                                proc->read_long.cb_arg);
    }

    return rc;
}
   127f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }

    if (proc->read_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->read_long.cb(proc->conn_handle,
   127f6:	4760      	bx	ip
                                ble_gattc_error(status, att_handle), attr,
                                proc->read_long.cb_arg);
    }

    return rc;
}
   127f8:	4620      	mov	r0, r4
   127fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   127fe:	bf00      	nop
   12800:	20003a50 	.word	0x20003a50

00012804 <ble_gattc_read_long_err>:
static void
ble_gattc_read_long_err(struct ble_gattc_proc *proc, int status,
                        uint16_t att_handle)
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_read_long_cb(proc, status, att_handle, NULL);
   12804:	2300      	movs	r3, #0
   12806:	f7ff bfdd 	b.w	127c4 <ble_gattc_read_long_cb>
	...

0001280c <ble_gattc_read_mult_cb>:
 */
static int
ble_gattc_read_mult_cb(struct ble_gattc_proc *proc, int status,
                       uint16_t att_handle, uint8_t *attr_data,
                       uint16_t attr_data_len)
{
   1280c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1280e:	4605      	mov	r5, r0
   12810:	b085      	sub	sp, #20

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    BLE_HS_DBG_ASSERT(attr_data != NULL || status != 0);
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   12812:	b129      	cbz	r1, 12820 <ble_gattc_read_mult_cb+0x14>
   12814:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, read_mult_fail);
   12816:	bf1f      	itttt	ne
   12818:	4c10      	ldrne	r4, [pc, #64]	; (1285c <ble_gattc_read_mult_cb+0x50>)
   1281a:	6e20      	ldrne	r0, [r4, #96]	; 0x60
   1281c:	3001      	addne	r0, #1
   1281e:	6620      	strne	r0, [r4, #96]	; 0x60
    }

    if (proc->read_mult.cb == NULL) {
   12820:	68ec      	ldr	r4, [r5, #12]
   12822:	b1bc      	cbz	r4, 12854 <ble_gattc_read_mult_cb+0x48>
        rc = 0;
    } else {
        if (status != 0) {
   12824:	b951      	cbnz	r1, 1283c <ble_gattc_read_mult_cb+0x30>
            attrp = NULL;
        } else {
            attrp = &attr;
            attr.handle = 0;
            attr.offset = 0;
            attr.value_len = attr_data_len;
   12826:	f8bd 0028 	ldrh.w	r0, [sp, #40]	; 0x28
    } else {
        if (status != 0) {
            attrp = NULL;
        } else {
            attrp = &attr;
            attr.handle = 0;
   1282a:	f8ad 1004 	strh.w	r1, [sp, #4]
            attr.offset = 0;
   1282e:	f8ad 1006 	strh.w	r1, [sp, #6]
            attr.value_len = attr_data_len;
   12832:	f8ad 0008 	strh.w	r0, [sp, #8]
            attr.value = attr_data;
   12836:	9303      	str	r3, [sp, #12]
        rc = 0;
    } else {
        if (status != 0) {
            attrp = NULL;
        } else {
            attrp = &attr;
   12838:	ae01      	add	r6, sp, #4
   1283a:	e000      	b.n	1283e <ble_gattc_read_mult_cb+0x32>

    if (proc->read_mult.cb == NULL) {
        rc = 0;
    } else {
        if (status != 0) {
            attrp = NULL;
   1283c:	2600      	movs	r6, #0
            attr.value_len = attr_data_len;
            attr.value = attr_data;
        }

        rc = proc->read_mult.cb(proc->conn_handle,
                                ble_gattc_error(status, att_handle), attrp,
   1283e:	4608      	mov	r0, r1
   12840:	4611      	mov	r1, r2
            attr.offset = 0;
            attr.value_len = attr_data_len;
            attr.value = attr_data;
        }

        rc = proc->read_mult.cb(proc->conn_handle,
   12842:	892f      	ldrh	r7, [r5, #8]
                                ble_gattc_error(status, att_handle), attrp,
   12844:	f7ff fe28 	bl	12498 <ble_gattc_error>
            attr.offset = 0;
            attr.value_len = attr_data_len;
            attr.value = attr_data;
        }

        rc = proc->read_mult.cb(proc->conn_handle,
   12848:	4632      	mov	r2, r6
                                ble_gattc_error(status, att_handle), attrp,
   1284a:	4601      	mov	r1, r0
            attr.offset = 0;
            attr.value_len = attr_data_len;
            attr.value = attr_data;
        }

        rc = proc->read_mult.cb(proc->conn_handle,
   1284c:	692b      	ldr	r3, [r5, #16]
   1284e:	4638      	mov	r0, r7
   12850:	47a0      	blx	r4
   12852:	e000      	b.n	12856 <ble_gattc_read_mult_cb+0x4a>
    if (status != 0 && status != BLE_HS_EDONE) {
        STATS_INC(ble_gattc_stats, read_mult_fail);
    }

    if (proc->read_mult.cb == NULL) {
        rc = 0;
   12854:	4620      	mov	r0, r4
                                ble_gattc_error(status, att_handle), attrp,
                                proc->read_mult.cb_arg);
    }

    return rc;
}
   12856:	b005      	add	sp, #20
   12858:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1285a:	bf00      	nop
   1285c:	20003a50 	.word	0x20003a50

00012860 <ble_gattc_read_mult_err>:
 * read-multiple-characteristics proc.
 */
static void
ble_gattc_read_mult_err(struct ble_gattc_proc *proc, int status,
                        uint16_t att_handle)
{
   12860:	b507      	push	{r0, r1, r2, lr}
    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_read_mult_cb(proc, status, att_handle, NULL, 0);
   12862:	2300      	movs	r3, #0
   12864:	9300      	str	r3, [sp, #0]
   12866:	f7ff ffd1 	bl	1280c <ble_gattc_read_mult_cb>
}
   1286a:	b003      	add	sp, #12
   1286c:	f85d fb04 	ldr.w	pc, [sp], #4

00012870 <ble_gattc_write_long_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_write_long_cb(struct ble_gattc_proc *proc, int status,
                        uint16_t att_handle)
{
   12870:	b570      	push	{r4, r5, r6, lr}
   12872:	4604      	mov	r4, r0
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   12874:	b129      	cbz	r1, 12882 <ble_gattc_write_long_cb+0x12>
   12876:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, write_long_fail);
   12878:	bf1f      	itttt	ne
   1287a:	480b      	ldrne	r0, [pc, #44]	; (128a8 <ble_gattc_write_long_cb+0x38>)
   1287c:	6f83      	ldrne	r3, [r0, #120]	; 0x78
   1287e:	3301      	addne	r3, #1
   12880:	6783      	strne	r3, [r0, #120]	; 0x78
    }

    if (proc->write_long.cb == NULL) {
   12882:	69e5      	ldr	r5, [r4, #28]
   12884:	b16d      	cbz	r5, 128a2 <ble_gattc_write_long_cb+0x32>
        rc = 0;
    } else {
        rc = proc->write_long.cb(proc->conn_handle,
                                 ble_gattc_error(status, att_handle),
   12886:	4608      	mov	r0, r1
   12888:	4611      	mov	r1, r2
    }

    if (proc->write_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->write_long.cb(proc->conn_handle,
   1288a:	8926      	ldrh	r6, [r4, #8]
                                 ble_gattc_error(status, att_handle),
   1288c:	f7ff fe04 	bl	12498 <ble_gattc_error>
    }

    if (proc->write_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->write_long.cb(proc->conn_handle,
   12890:	f104 020c 	add.w	r2, r4, #12
                                 ble_gattc_error(status, att_handle),
   12894:	4601      	mov	r1, r0
    }

    if (proc->write_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->write_long.cb(proc->conn_handle,
   12896:	6a23      	ldr	r3, [r4, #32]
   12898:	4630      	mov	r0, r6
   1289a:	46ac      	mov	ip, r5
                                 &proc->write_long.attr,
                                 proc->write_long.cb_arg);
    }

    return rc;
}
   1289c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    }

    if (proc->write_long.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->write_long.cb(proc->conn_handle,
   128a0:	4760      	bx	ip
                                 &proc->write_long.attr,
                                 proc->write_long.cb_arg);
    }

    return rc;
}
   128a2:	4628      	mov	r0, r5
   128a4:	bd70      	pop	{r4, r5, r6, pc}
   128a6:	bf00      	nop
   128a8:	20003a50 	.word	0x20003a50

000128ac <ble_gattc_write_long_rx_exec>:
 * Handles an incoming execute-write-response for the specified
 * write-long-characteristic-values proc.
 */
static int
ble_gattc_write_long_rx_exec(struct ble_gattc_proc *proc, int status)
{
   128ac:	b508      	push	{r3, lr}
    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_write_long_cb(proc, status, 0);
   128ae:	2200      	movs	r2, #0
   128b0:	f7ff ffde 	bl	12870 <ble_gattc_write_long_cb>
    return BLE_HS_EDONE;
}
   128b4:	200e      	movs	r0, #14
   128b6:	bd08      	pop	{r3, pc}

000128b8 <ble_gattc_write_reliable_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_write_reliable_cb(struct ble_gattc_proc *proc, int status,
                            uint16_t att_handle)
{
   128b8:	b573      	push	{r0, r1, r4, r5, r6, lr}
   128ba:	4605      	mov	r5, r0
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   128bc:	b139      	cbz	r1, 128ce <ble_gattc_write_reliable_cb+0x16>
   128be:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, write_reliable_fail);
   128c0:	bf1f      	itttt	ne
   128c2:	480c      	ldrne	r0, [pc, #48]	; (128f4 <ble_gattc_write_reliable_cb+0x3c>)
   128c4:	f8d0 3080 	ldrne.w	r3, [r0, #128]	; 0x80
   128c8:	3301      	addne	r3, #1
   128ca:	f8c0 3080 	strne.w	r3, [r0, #128]	; 0x80
    }

    if (proc->write_reliable.cb == NULL) {
   128ce:	69ac      	ldr	r4, [r5, #24]
   128d0:	b164      	cbz	r4, 128ec <ble_gattc_write_reliable_cb+0x34>
        rc = 0;
    } else {
        rc = proc->write_reliable.cb(proc->conn_handle,
                                     ble_gattc_error(status, att_handle),
   128d2:	4608      	mov	r0, r1
   128d4:	4611      	mov	r1, r2
    }

    if (proc->write_reliable.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->write_reliable.cb(proc->conn_handle,
   128d6:	892e      	ldrh	r6, [r5, #8]
                                     ble_gattc_error(status, att_handle),
   128d8:	f7ff fdde 	bl	12498 <ble_gattc_error>
    }

    if (proc->write_reliable.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->write_reliable.cb(proc->conn_handle,
   128dc:	69ea      	ldr	r2, [r5, #28]
   128de:	9200      	str	r2, [sp, #0]
                                     ble_gattc_error(status, att_handle),
   128e0:	4601      	mov	r1, r0
    }

    if (proc->write_reliable.cb == NULL) {
        rc = 0;
    } else {
        rc = proc->write_reliable.cb(proc->conn_handle,
   128e2:	7c2b      	ldrb	r3, [r5, #16]
   128e4:	68ea      	ldr	r2, [r5, #12]
   128e6:	4630      	mov	r0, r6
   128e8:	47a0      	blx	r4
   128ea:	e000      	b.n	128ee <ble_gattc_write_reliable_cb+0x36>
    if (status != 0 && status != BLE_HS_EDONE) {
        STATS_INC(ble_gattc_stats, write_reliable_fail);
    }

    if (proc->write_reliable.cb == NULL) {
        rc = 0;
   128ec:	4620      	mov	r0, r4
                                     proc->write_reliable.num_attrs,
                                     proc->write_reliable.cb_arg);
    }

    return rc;
}
   128ee:	b002      	add	sp, #8
   128f0:	bd70      	pop	{r4, r5, r6, pc}
   128f2:	bf00      	nop
   128f4:	20003a50 	.word	0x20003a50

000128f8 <ble_gattc_write_reliable_rx_exec>:
 * Handles an incoming execute-write-response for the specified
 * write-reliable-characteristic-values proc.
 */
static int
ble_gattc_write_reliable_rx_exec(struct ble_gattc_proc *proc, int status)
{
   128f8:	b508      	push	{r3, lr}
    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_write_reliable_cb(proc, status, 0);
   128fa:	2200      	movs	r2, #0
   128fc:	f7ff ffdc 	bl	128b8 <ble_gattc_write_reliable_cb>
    return BLE_HS_EDONE;
}
   12900:	200e      	movs	r0, #14
   12902:	bd08      	pop	{r3, pc}

00012904 <ble_gattc_extract>:
    return 1;
}

static struct ble_gattc_proc *
ble_gattc_extract(uint16_t conn_handle, uint8_t op)
{
   12904:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12906:	4607      	mov	r7, r0
   12908:	460e      	mov	r6, r1
    struct ble_gattc_proc *prev;

    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    ble_hs_lock();
   1290a:	f001 ff1b 	bl	14744 <ble_hs_lock>

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
   1290e:	4b10      	ldr	r3, [pc, #64]	; (12950 <ble_gattc_extract+0x4c>)
   12910:	681d      	ldr	r5, [r3, #0]
    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    ble_hs_lock();

    prev = NULL;
   12912:	2200      	movs	r2, #0
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
   12914:	462c      	mov	r4, r5
   12916:	b1b4      	cbz	r4, 12946 <ble_gattc_extract+0x42>
 */
static int
ble_gattc_proc_matches(struct ble_gattc_proc *proc, uint16_t conn_handle,
                       uint8_t op)
{
    if (conn_handle != proc->conn_handle) {
   12918:	8921      	ldrh	r1, [r4, #8]
   1291a:	42b9      	cmp	r1, r7
   1291c:	d104      	bne.n	12928 <ble_gattc_extract+0x24>
        return 0;
    }

    if (op != proc->op && op != BLE_GATT_OP_NONE) {
   1291e:	7aa1      	ldrb	r1, [r4, #10]
   12920:	42b1      	cmp	r1, r6
   12922:	d004      	beq.n	1292e <ble_gattc_extract+0x2a>
   12924:	2eff      	cmp	r6, #255	; 0xff
   12926:	d002      	beq.n	1292e <ble_gattc_extract+0x2a>
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    ble_hs_lock();

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
   12928:	4622      	mov	r2, r4
   1292a:	6824      	ldr	r4, [r4, #0]
   1292c:	e7f3      	b.n	12916 <ble_gattc_extract+0x12>
        if (ble_gattc_proc_matches(proc, conn_handle, op)) {
            if (prev == NULL) {
   1292e:	b92a      	cbnz	r2, 1293c <ble_gattc_extract+0x38>
                STAILQ_REMOVE_HEAD(&ble_gattc_procs, next);
   12930:	6829      	ldr	r1, [r5, #0]
   12932:	4a07      	ldr	r2, [pc, #28]	; (12950 <ble_gattc_extract+0x4c>)
   12934:	6019      	str	r1, [r3, #0]
   12936:	b931      	cbnz	r1, 12946 <ble_gattc_extract+0x42>
   12938:	6052      	str	r2, [r2, #4]
   1293a:	e004      	b.n	12946 <ble_gattc_extract+0x42>
            } else {
                STAILQ_REMOVE_AFTER(&ble_gattc_procs, prev, next);
   1293c:	6811      	ldr	r1, [r2, #0]
   1293e:	6809      	ldr	r1, [r1, #0]
   12940:	6011      	str	r1, [r2, #0]
   12942:	b901      	cbnz	r1, 12946 <ble_gattc_extract+0x42>
   12944:	605a      	str	r2, [r3, #4]
            break;
        }
        prev = proc;
    }

    ble_hs_unlock();
   12946:	f001 ff05 	bl	14754 <ble_hs_unlock>

    return proc;
}
   1294a:	4620      	mov	r0, r4
   1294c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1294e:	bf00      	nop
   12950:	200020c4 	.word	0x200020c4

00012954 <ble_gattc_extract_with_rx_entry>:

static struct ble_gattc_proc *
ble_gattc_extract_with_rx_entry(uint16_t conn_handle,
                                const void *rx_entries, int num_entries,
                                const void **out_rx_entry)
{
   12954:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    ble_hs_lock();

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
   12958:	4e18      	ldr	r6, [pc, #96]	; (129bc <ble_gattc_extract_with_rx_entry+0x68>)

static struct ble_gattc_proc *
ble_gattc_extract_with_rx_entry(uint16_t conn_handle,
                                const void *rx_entries, int num_entries,
                                const void **out_rx_entry)
{
   1295a:	4681      	mov	r9, r0
   1295c:	4688      	mov	r8, r1
   1295e:	4692      	mov	sl, r2
   12960:	469b      	mov	fp, r3
    const void *rx_entry;

    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    ble_hs_lock();
   12962:	f001 feef 	bl	14744 <ble_hs_lock>

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
   12966:	6830      	ldr	r0, [r6, #0]
    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    ble_hs_lock();

    prev = NULL;
   12968:	2500      	movs	r5, #0
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
   1296a:	4604      	mov	r4, r0
   1296c:	b30c      	cbz	r4, 129b2 <ble_gattc_extract_with_rx_entry+0x5e>
        if (proc->conn_handle == conn_handle) {
   1296e:	8923      	ldrh	r3, [r4, #8]
   12970:	454b      	cmp	r3, r9
   12972:	d11b      	bne.n	129ac <ble_gattc_extract_with_rx_entry+0x58>
            rx_entry = ble_gattc_rx_entry_find(proc->op, rx_entries,
   12974:	7aa2      	ldrb	r2, [r4, #10]

    const struct gen_entry *entries;
    int i;

    entries = rx_entries;
    for (i = 0; i < num_entries; i++) {
   12976:	2700      	movs	r7, #0
   12978:	4557      	cmp	r7, sl
   1297a:	da17      	bge.n	129ac <ble_gattc_extract_with_rx_entry+0x58>
        if (entries[i].op == op) {
   1297c:	f818 1037 	ldrb.w	r1, [r8, r7, lsl #3]
   12980:	4291      	cmp	r1, r2
   12982:	eb08 03c7 	add.w	r3, r8, r7, lsl #3
   12986:	d101      	bne.n	1298c <ble_gattc_extract_with_rx_entry+0x38>
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
        if (proc->conn_handle == conn_handle) {
            rx_entry = ble_gattc_rx_entry_find(proc->op, rx_entries,
                                               num_entries);
            if (rx_entry != NULL) {
                if (prev == NULL) {
   12988:	b945      	cbnz	r5, 1299c <ble_gattc_extract_with_rx_entry+0x48>
   1298a:	e001      	b.n	12990 <ble_gattc_extract_with_rx_entry+0x3c>

    const struct gen_entry *entries;
    int i;

    entries = rx_entries;
    for (i = 0; i < num_entries; i++) {
   1298c:	3701      	adds	r7, #1
   1298e:	e7f3      	b.n	12978 <ble_gattc_extract_with_rx_entry+0x24>
        if (proc->conn_handle == conn_handle) {
            rx_entry = ble_gattc_rx_entry_find(proc->op, rx_entries,
                                               num_entries);
            if (rx_entry != NULL) {
                if (prev == NULL) {
                    STAILQ_REMOVE_HEAD(&ble_gattc_procs, next);
   12990:	6801      	ldr	r1, [r0, #0]
   12992:	4a0a      	ldr	r2, [pc, #40]	; (129bc <ble_gattc_extract_with_rx_entry+0x68>)
   12994:	6031      	str	r1, [r6, #0]
   12996:	b931      	cbnz	r1, 129a6 <ble_gattc_extract_with_rx_entry+0x52>
   12998:	6052      	str	r2, [r2, #4]
   1299a:	e004      	b.n	129a6 <ble_gattc_extract_with_rx_entry+0x52>
                } else {
                    STAILQ_REMOVE_AFTER(&ble_gattc_procs, prev, next);
   1299c:	682a      	ldr	r2, [r5, #0]
   1299e:	6812      	ldr	r2, [r2, #0]
   129a0:	602a      	str	r2, [r5, #0]
   129a2:	b902      	cbnz	r2, 129a6 <ble_gattc_extract_with_rx_entry+0x52>
   129a4:	6075      	str	r5, [r6, #4]
                }

                *out_rx_entry = rx_entry;
   129a6:	f8cb 3000 	str.w	r3, [fp]
                break;
   129aa:	e002      	b.n	129b2 <ble_gattc_extract_with_rx_entry+0x5e>
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    ble_hs_lock();

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_gattc_procs, next) {
   129ac:	4625      	mov	r5, r4
   129ae:	6824      	ldr	r4, [r4, #0]
   129b0:	e7dc      	b.n	1296c <ble_gattc_extract_with_rx_entry+0x18>
        }

        prev = proc;
    }

    ble_hs_unlock();
   129b2:	f001 fecf 	bl	14754 <ble_hs_unlock>

    return proc;
}
   129b6:	4620      	mov	r0, r4
   129b8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   129bc:	200020c4 	.word	0x200020c4

000129c0 <ble_gattc_proc_free>:
static void
ble_gattc_proc_free(struct ble_gattc_proc *proc)
{
    int rc;

    if (proc != NULL) {
   129c0:	4601      	mov	r1, r0
   129c2:	b110      	cbz	r0, 129ca <ble_gattc_proc_free+0xa>
        ble_gattc_dbg_assert_proc_not_inserted(proc);

        rc = os_memblock_put(&ble_gattc_proc_pool, proc);
   129c4:	4801      	ldr	r0, [pc, #4]	; (129cc <ble_gattc_proc_free+0xc>)
   129c6:	f7f7 bd2b 	b.w	a420 <os_memblock_put>
   129ca:	4770      	bx	lr
   129cc:	200020cc 	.word	0x200020cc

000129d0 <ble_gattc_proc_alloc>:
 *
 * @return                      An entry on success; null on failure.
 */
static struct ble_gattc_proc *
ble_gattc_proc_alloc(void)
{
   129d0:	b510      	push	{r4, lr}
    struct ble_gattc_proc *proc;

    proc = os_memblock_get(&ble_gattc_proc_pool);
   129d2:	4805      	ldr	r0, [pc, #20]	; (129e8 <ble_gattc_proc_alloc+0x18>)
   129d4:	f7f7 fd10 	bl	a3f8 <os_memblock_get>
    if (proc != NULL) {
   129d8:	4604      	mov	r4, r0
   129da:	b118      	cbz	r0, 129e4 <ble_gattc_proc_alloc+0x14>
        memset(proc, 0, sizeof *proc);
   129dc:	2100      	movs	r1, #0
   129de:	2228      	movs	r2, #40	; 0x28
   129e0:	f7f6 fb17 	bl	9012 <memset>
    }

    return proc;
}
   129e4:	4620      	mov	r0, r4
   129e6:	bd10      	pop	{r4, pc}
   129e8:	200020cc 	.word	0x200020cc

000129ec <ble_gattc_write_cb>:
 *                                  is no callback).
 */
static int
ble_gattc_write_cb(struct ble_gattc_proc *proc, int status,
                   uint16_t att_handle)
{
   129ec:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   129f0:	4605      	mov	r5, r0
   129f2:	4690      	mov	r8, r2
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0 && status != BLE_HS_EDONE) {
   129f4:	460e      	mov	r6, r1
   129f6:	b129      	cbz	r1, 12a04 <ble_gattc_write_cb+0x18>
   129f8:	290e      	cmp	r1, #14
        STATS_INC(ble_gattc_stats, write_fail);
   129fa:	bf1f      	itttt	ne
   129fc:	4a0e      	ldrne	r2, [pc, #56]	; (12a38 <ble_gattc_write_cb+0x4c>)
   129fe:	6f13      	ldrne	r3, [r2, #112]	; 0x70
   12a00:	3301      	addne	r3, #1
   12a02:	6713      	strne	r3, [r2, #112]	; 0x70
    }

    if (proc->write.cb == NULL) {
   12a04:	692c      	ldr	r4, [r5, #16]
   12a06:	b194      	cbz	r4, 12a2e <ble_gattc_write_cb+0x42>
        rc = 0;
    } else {
        memset(&attr, 0, sizeof attr);
   12a08:	220c      	movs	r2, #12
   12a0a:	a801      	add	r0, sp, #4
   12a0c:	2100      	movs	r1, #0
   12a0e:	f7f6 fb00 	bl	9012 <memset>
        attr.handle = proc->write.att_handle;
   12a12:	89ab      	ldrh	r3, [r5, #12]
   12a14:	f8ad 3004 	strh.w	r3, [sp, #4]
        rc = proc->write.cb(proc->conn_handle,
                            ble_gattc_error(status, att_handle),
   12a18:	4641      	mov	r1, r8
   12a1a:	4630      	mov	r0, r6
    if (proc->write.cb == NULL) {
        rc = 0;
    } else {
        memset(&attr, 0, sizeof attr);
        attr.handle = proc->write.att_handle;
        rc = proc->write.cb(proc->conn_handle,
   12a1c:	892f      	ldrh	r7, [r5, #8]
                            ble_gattc_error(status, att_handle),
   12a1e:	f7ff fd3b 	bl	12498 <ble_gattc_error>
    if (proc->write.cb == NULL) {
        rc = 0;
    } else {
        memset(&attr, 0, sizeof attr);
        attr.handle = proc->write.att_handle;
        rc = proc->write.cb(proc->conn_handle,
   12a22:	aa01      	add	r2, sp, #4
                            ble_gattc_error(status, att_handle),
   12a24:	4601      	mov	r1, r0
    if (proc->write.cb == NULL) {
        rc = 0;
    } else {
        memset(&attr, 0, sizeof attr);
        attr.handle = proc->write.att_handle;
        rc = proc->write.cb(proc->conn_handle,
   12a26:	696b      	ldr	r3, [r5, #20]
   12a28:	4638      	mov	r0, r7
   12a2a:	47a0      	blx	r4
   12a2c:	e000      	b.n	12a30 <ble_gattc_write_cb+0x44>
    if (status != 0 && status != BLE_HS_EDONE) {
        STATS_INC(ble_gattc_stats, write_fail);
    }

    if (proc->write.cb == NULL) {
        rc = 0;
   12a2e:	4620      	mov	r0, r4
                            ble_gattc_error(status, att_handle),
                            &attr, proc->write.cb_arg);
    }

    return rc;
}
   12a30:	b004      	add	sp, #16
   12a32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12a36:	bf00      	nop
   12a38:	20003a50 	.word	0x20003a50

00012a3c <ble_gattc_write_err>:
static void
ble_gattc_write_err(struct ble_gattc_proc *proc, int status,
                    uint16_t att_handle)
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_write_cb(proc, status, att_handle);
   12a3c:	f7ff bfd6 	b.w	129ec <ble_gattc_write_cb>

00012a40 <ble_gattc_log_proc_init>:
 * $log                                                                      *
 *****************************************************************************/

static void
ble_gattc_log_proc_init(char *name)
{
   12a40:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(INFO, "GATT procedure initiated: %s", name);
   12a42:	4b05      	ldr	r3, [pc, #20]	; (12a58 <ble_gattc_log_proc_init+0x18>)
   12a44:	9000      	str	r0, [sp, #0]
   12a46:	2104      	movs	r1, #4
   12a48:	4804      	ldr	r0, [pc, #16]	; (12a5c <ble_gattc_log_proc_init+0x1c>)
   12a4a:	2201      	movs	r2, #1
   12a4c:	f00a fbec 	bl	1d228 <log_printf>
}
   12a50:	b003      	add	sp, #12
   12a52:	f85d fb04 	ldr.w	pc, [sp], #4
   12a56:	bf00      	nop
   12a58:	0001f738 	.word	0x0001f738
   12a5c:	20003b9c 	.word	0x20003b9c

00012a60 <ble_gattc_disc_all_chrs_go>:
 * Triggers a pending transmit for the specified discover-all-characteristics
 * proc.
 */
static int
ble_gattc_disc_all_chrs_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12a60:	b570      	push	{r4, r5, r6, lr}
   12a62:	4604      	mov	r4, r0
   12a64:	b086      	sub	sp, #24
   12a66:	460e      	mov	r6, r1
    uint8_t uuid128[16];
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_CHARACTERISTIC, uuid128);
   12a68:	f642 0003 	movw	r0, #10243	; 0x2803
   12a6c:	a902      	add	r1, sp, #8
   12a6e:	f005 fd29 	bl	184c4 <ble_uuid_16_to_128>
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.batq_start_handle = proc->disc_all_chrs.prev_handle + 1;
   12a72:	89a3      	ldrh	r3, [r4, #12]
    req.batq_end_handle = proc->disc_all_chrs.end_handle;

    rc = ble_att_clt_tx_read_type(proc->conn_handle, &req, uuid128);
   12a74:	8920      	ldrh	r0, [r4, #8]
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_CHARACTERISTIC, uuid128);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.batq_start_handle = proc->disc_all_chrs.prev_handle + 1;
   12a76:	3301      	adds	r3, #1
   12a78:	f8ad 3004 	strh.w	r3, [sp, #4]
    req.batq_end_handle = proc->disc_all_chrs.end_handle;

    rc = ble_att_clt_tx_read_type(proc->conn_handle, &req, uuid128);
   12a7c:	a901      	add	r1, sp, #4

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_CHARACTERISTIC, uuid128);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.batq_start_handle = proc->disc_all_chrs.prev_handle + 1;
    req.batq_end_handle = proc->disc_all_chrs.end_handle;
   12a7e:	89e3      	ldrh	r3, [r4, #14]
   12a80:	f8ad 3006 	strh.w	r3, [sp, #6]

    rc = ble_att_clt_tx_read_type(proc->conn_handle, &req, uuid128);
   12a84:	aa02      	add	r2, sp, #8
   12a86:	f007 fc2f 	bl	1a2e8 <ble_att_clt_tx_read_type>

    if (rc != 0) {
   12a8a:	4605      	mov	r5, r0
   12a8c:	b130      	cbz	r0, 12a9c <ble_gattc_disc_all_chrs_go+0x3c>
        if (cb_on_err) {
   12a8e:	b12e      	cbz	r6, 12a9c <ble_gattc_disc_all_chrs_go+0x3c>
            ble_gattc_disc_all_chrs_cb(proc, rc, 0, NULL);
   12a90:	2200      	movs	r2, #0
   12a92:	4620      	mov	r0, r4
   12a94:	4629      	mov	r1, r5
   12a96:	4613      	mov	r3, r2
   12a98:	f7ff fdaa 	bl	125f0 <ble_gattc_disc_all_chrs_cb>
        }
        return rc;
    }

    return 0;
}
   12a9c:	4628      	mov	r0, r5
   12a9e:	b006      	add	sp, #24
   12aa0:	bd70      	pop	{r4, r5, r6, pc}

00012aa2 <ble_gattc_disc_chr_uuid_go>:
 * Triggers a pending transmit for the specified
 * discover-characteristic-by-uuid proc.
 */
static int
ble_gattc_disc_chr_uuid_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12aa2:	b570      	push	{r4, r5, r6, lr}
   12aa4:	4604      	mov	r4, r0
   12aa6:	b086      	sub	sp, #24
   12aa8:	460e      	mov	r6, r1
    uint8_t uuid128[16];
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_CHARACTERISTIC, uuid128);
   12aaa:	f642 0003 	movw	r0, #10243	; 0x2803
   12aae:	a902      	add	r1, sp, #8
   12ab0:	f005 fd08 	bl	184c4 <ble_uuid_16_to_128>
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.batq_start_handle = proc->disc_chr_uuid.prev_handle + 1;
   12ab4:	8ba3      	ldrh	r3, [r4, #28]
    req.batq_end_handle = proc->disc_chr_uuid.end_handle;

    rc = ble_att_clt_tx_read_type(proc->conn_handle, &req, uuid128);
   12ab6:	8920      	ldrh	r0, [r4, #8]
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_CHARACTERISTIC, uuid128);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.batq_start_handle = proc->disc_chr_uuid.prev_handle + 1;
   12ab8:	3301      	adds	r3, #1
   12aba:	f8ad 3004 	strh.w	r3, [sp, #4]
    req.batq_end_handle = proc->disc_chr_uuid.end_handle;

    rc = ble_att_clt_tx_read_type(proc->conn_handle, &req, uuid128);
   12abe:	a901      	add	r1, sp, #4

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_CHARACTERISTIC, uuid128);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.batq_start_handle = proc->disc_chr_uuid.prev_handle + 1;
    req.batq_end_handle = proc->disc_chr_uuid.end_handle;
   12ac0:	8be3      	ldrh	r3, [r4, #30]
   12ac2:	f8ad 3006 	strh.w	r3, [sp, #6]

    rc = ble_att_clt_tx_read_type(proc->conn_handle, &req, uuid128);
   12ac6:	aa02      	add	r2, sp, #8
   12ac8:	f007 fc0e 	bl	1a2e8 <ble_att_clt_tx_read_type>

    if (rc != 0) {
   12acc:	4605      	mov	r5, r0
   12ace:	b130      	cbz	r0, 12ade <ble_gattc_disc_chr_uuid_go+0x3c>
        if (cb_on_err) {
   12ad0:	b12e      	cbz	r6, 12ade <ble_gattc_disc_chr_uuid_go+0x3c>
            ble_gattc_disc_chr_uuid_cb(proc, rc, 0, NULL);
   12ad2:	2200      	movs	r2, #0
   12ad4:	4620      	mov	r0, r4
   12ad6:	4629      	mov	r1, r5
   12ad8:	4613      	mov	r3, r2
   12ada:	f7ff fdb1 	bl	12640 <ble_gattc_disc_chr_uuid_cb>
        }
        return rc;
    }

    return 0;
}
   12ade:	4628      	mov	r0, r5
   12ae0:	b006      	add	sp, #24
   12ae2:	bd70      	pop	{r4, r5, r6, pc}

00012ae4 <ble_gattc_find_inc_svcs_go>:
/**
 * Triggers a pending transmit for the specified find-included-services proc.
 */
static int
ble_gattc_find_inc_svcs_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12ae4:	b570      	push	{r4, r5, r6, lr}
    uint8_t uuid128[16];
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start == 0) {
   12ae6:	8a03      	ldrh	r3, [r0, #16]
/**
 * Triggers a pending transmit for the specified find-included-services proc.
 */
static int
ble_gattc_find_inc_svcs_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12ae8:	b086      	sub	sp, #24
   12aea:	4604      	mov	r4, r0
   12aec:	460e      	mov	r6, r1
    uint8_t uuid128[16];
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start == 0) {
   12aee:	b98b      	cbnz	r3, 12b14 <ble_gattc_find_inc_svcs_go+0x30>
        /* Find the next included service. */
        read_type_req.batq_start_handle =
   12af0:	8983      	ldrh	r3, [r0, #12]
   12af2:	3301      	adds	r3, #1
   12af4:	f8ad 3004 	strh.w	r3, [sp, #4]
            proc->find_inc_svcs.prev_handle + 1;
        read_type_req.batq_end_handle = proc->find_inc_svcs.end_handle;

        rc = ble_uuid_16_to_128(BLE_ATT_UUID_INCLUDE, uuid128);
   12af8:	a902      	add	r1, sp, #8

    if (proc->find_inc_svcs.cur_start == 0) {
        /* Find the next included service. */
        read_type_req.batq_start_handle =
            proc->find_inc_svcs.prev_handle + 1;
        read_type_req.batq_end_handle = proc->find_inc_svcs.end_handle;
   12afa:	89c3      	ldrh	r3, [r0, #14]
   12afc:	f8ad 3006 	strh.w	r3, [sp, #6]

        rc = ble_uuid_16_to_128(BLE_ATT_UUID_INCLUDE, uuid128);
   12b00:	f642 0002 	movw	r0, #10242	; 0x2802
   12b04:	f005 fcde 	bl	184c4 <ble_uuid_16_to_128>
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);

        rc = ble_att_clt_tx_read_type(proc->conn_handle,
   12b08:	8920      	ldrh	r0, [r4, #8]
   12b0a:	a901      	add	r1, sp, #4
   12b0c:	aa02      	add	r2, sp, #8
   12b0e:	f007 fbeb 	bl	1a2e8 <ble_att_clt_tx_read_type>
   12b12:	e005      	b.n	12b20 <ble_gattc_find_inc_svcs_go+0x3c>
                                      &read_type_req, uuid128);
    } else {
        /* Read the UUID of the previously found service. */
        read_req.barq_handle = proc->find_inc_svcs.cur_start;
   12b14:	a906      	add	r1, sp, #24
        rc = ble_att_clt_tx_read(proc->conn_handle, &read_req);
   12b16:	8900      	ldrh	r0, [r0, #8]

        rc = ble_att_clt_tx_read_type(proc->conn_handle,
                                      &read_type_req, uuid128);
    } else {
        /* Read the UUID of the previously found service. */
        read_req.barq_handle = proc->find_inc_svcs.cur_start;
   12b18:	f821 3d18 	strh.w	r3, [r1, #-24]!
        rc = ble_att_clt_tx_read(proc->conn_handle, &read_req);
   12b1c:	f007 fc96 	bl	1a44c <ble_att_clt_tx_read>
   12b20:	4605      	mov	r5, r0
    }

    if (rc != 0) {
   12b22:	b130      	cbz	r0, 12b32 <ble_gattc_find_inc_svcs_go+0x4e>
        if (cb_on_err) {
   12b24:	b12e      	cbz	r6, 12b32 <ble_gattc_find_inc_svcs_go+0x4e>
            ble_gattc_find_inc_svcs_cb(proc, rc, 0, NULL);
   12b26:	2200      	movs	r2, #0
   12b28:	4620      	mov	r0, r4
   12b2a:	4629      	mov	r1, r5
   12b2c:	4613      	mov	r3, r2
   12b2e:	f7ff fd35 	bl	1259c <ble_gattc_find_inc_svcs_cb>
        }
        return rc;
    }

    return 0;
}
   12b32:	4628      	mov	r0, r5
   12b34:	b006      	add	sp, #24
   12b36:	bd70      	pop	{r4, r5, r6, pc}

00012b38 <ble_gattc_find_inc_svcs_rx_read_rsp>:
 * proc.
 */
static int
ble_gattc_find_inc_svcs_rx_read_rsp(struct ble_gattc_proc *proc, int status,
                                    void *value, int value_len)
{
   12b38:	b570      	push	{r4, r5, r6, lr}
   12b3a:	4604      	mov	r4, r0
    struct ble_gatt_svc service;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start == 0) {
   12b3c:	8a00      	ldrh	r0, [r0, #16]
 * proc.
 */
static int
ble_gattc_find_inc_svcs_rx_read_rsp(struct ble_gattc_proc *proc, int status,
                                    void *value, int value_len)
{
   12b3e:	b086      	sub	sp, #24
    struct ble_gatt_svc service;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start == 0) {
   12b40:	b310      	cbz	r0, 12b88 <ble_gattc_find_inc_svcs_rx_read_rsp+0x50>
        /* Unexpected read response; terminate procedure. */
        rc = BLE_HS_EBADDATA;
        goto err;
    }

    if (status != 0) {
   12b42:	bb11      	cbnz	r1, 12b8a <ble_gattc_find_inc_svcs_rx_read_rsp+0x52>
        rc = status;
        goto err;
    }

    if (value_len != 16) {
   12b44:	2b10      	cmp	r3, #16
   12b46:	d11f      	bne.n	12b88 <ble_gattc_find_inc_svcs_rx_read_rsp+0x50>
        goto err;
    }

    /* Report discovered service to application. */
    service.start_handle = proc->find_inc_svcs.cur_start;
    service.end_handle = proc->find_inc_svcs.cur_end;
   12b48:	8a63      	ldrh	r3, [r4, #18]
        rc = BLE_HS_EBADDATA;
        goto err;
    }

    /* Report discovered service to application. */
    service.start_handle = proc->find_inc_svcs.cur_start;
   12b4a:	f8ad 0004 	strh.w	r0, [sp, #4]
    service.end_handle = proc->find_inc_svcs.cur_end;
   12b4e:	f8ad 3006 	strh.w	r3, [sp, #6]
    memcpy(service.uuid128, value, 16);
   12b52:	ad02      	add	r5, sp, #8
   12b54:	f102 0610 	add.w	r6, r2, #16
   12b58:	6810      	ldr	r0, [r2, #0]
   12b5a:	6851      	ldr	r1, [r2, #4]
   12b5c:	462b      	mov	r3, r5
   12b5e:	c303      	stmia	r3!, {r0, r1}
   12b60:	3208      	adds	r2, #8
   12b62:	42b2      	cmp	r2, r6
   12b64:	461d      	mov	r5, r3
   12b66:	d1f7      	bne.n	12b58 <ble_gattc_find_inc_svcs_rx_read_rsp+0x20>
    rc = ble_gattc_find_inc_svcs_cb(proc, 0, 0, &service);
   12b68:	2100      	movs	r1, #0
   12b6a:	4620      	mov	r0, r4
   12b6c:	460a      	mov	r2, r1
   12b6e:	ab01      	add	r3, sp, #4
   12b70:	f7ff fd14 	bl	1259c <ble_gattc_find_inc_svcs_cb>
    if (rc != 0) {
   12b74:	b970      	cbnz	r0, 12b94 <ble_gattc_find_inc_svcs_rx_read_rsp+0x5c>
        /* Application has indicated that the procedure should be aborted. */
        return BLE_HS_EDONE;
    }

    /* Proceed to the next service. */
    proc->find_inc_svcs.cur_start = 0;
   12b76:	8220      	strh	r0, [r4, #16]
    proc->find_inc_svcs.cur_end = 0;
   12b78:	8260      	strh	r0, [r4, #18]
    rc = ble_gattc_find_inc_svcs_go(proc, 1);
   12b7a:	2101      	movs	r1, #1
   12b7c:	4620      	mov	r0, r4
   12b7e:	f7ff ffb1 	bl	12ae4 <ble_gattc_find_inc_svcs_go>
    if (rc != 0) {
   12b82:	4601      	mov	r1, r0
   12b84:	b908      	cbnz	r0, 12b8a <ble_gattc_find_inc_svcs_rx_read_rsp+0x52>
   12b86:	e007      	b.n	12b98 <ble_gattc_find_inc_svcs_rx_read_rsp+0x60>

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start == 0) {
        /* Unexpected read response; terminate procedure. */
        rc = BLE_HS_EBADDATA;
   12b88:	210a      	movs	r1, #10
    }

    return 0;

err:
    ble_gattc_find_inc_svcs_cb(proc, rc, 0, NULL);
   12b8a:	2200      	movs	r2, #0
   12b8c:	4620      	mov	r0, r4
   12b8e:	4613      	mov	r3, r2
   12b90:	f7ff fd04 	bl	1259c <ble_gattc_find_inc_svcs_cb>
    service.end_handle = proc->find_inc_svcs.cur_end;
    memcpy(service.uuid128, value, 16);
    rc = ble_gattc_find_inc_svcs_cb(proc, 0, 0, &service);
    if (rc != 0) {
        /* Application has indicated that the procedure should be aborted. */
        return BLE_HS_EDONE;
   12b94:	200e      	movs	r0, #14
   12b96:	e7ff      	b.n	12b98 <ble_gattc_find_inc_svcs_rx_read_rsp+0x60>
    return 0;

err:
    ble_gattc_find_inc_svcs_cb(proc, rc, 0, NULL);
    return BLE_HS_EDONE;
}
   12b98:	b006      	add	sp, #24
   12b9a:	bd70      	pop	{r4, r5, r6, pc}

00012b9c <ble_gattc_read_long_go>:
/**
 * Triggers a pending transmit for the specified read-long-characteristic proc.
 */
static int
ble_gattc_read_long_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12b9c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    struct ble_att_read_req read_req;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->read_long.offset == 0) {
   12b9e:	89c3      	ldrh	r3, [r0, #14]
   12ba0:	8982      	ldrh	r2, [r0, #12]
/**
 * Triggers a pending transmit for the specified read-long-characteristic proc.
 */
static int
ble_gattc_read_long_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12ba2:	4605      	mov	r5, r0
   12ba4:	460e      	mov	r6, r1
   12ba6:	8900      	ldrh	r0, [r0, #8]
    struct ble_att_read_req read_req;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->read_long.offset == 0) {
   12ba8:	b92b      	cbnz	r3, 12bb6 <ble_gattc_read_long_go+0x1a>
        read_req.barq_handle = proc->read_long.handle;
   12baa:	a902      	add	r1, sp, #8
   12bac:	f821 2d08 	strh.w	r2, [r1, #-8]!
        rc = ble_att_clt_tx_read(proc->conn_handle, &read_req);
   12bb0:	f007 fc4c 	bl	1a44c <ble_att_clt_tx_read>
   12bb4:	e006      	b.n	12bc4 <ble_gattc_read_long_go+0x28>
    } else {
        blob_req.babq_handle = proc->read_long.handle;
        blob_req.babq_offset = proc->read_long.offset;
        rc = ble_att_clt_tx_read_blob(proc->conn_handle, &blob_req);
   12bb6:	a901      	add	r1, sp, #4

    if (proc->read_long.offset == 0) {
        read_req.barq_handle = proc->read_long.handle;
        rc = ble_att_clt_tx_read(proc->conn_handle, &read_req);
    } else {
        blob_req.babq_handle = proc->read_long.handle;
   12bb8:	f8ad 2004 	strh.w	r2, [sp, #4]
        blob_req.babq_offset = proc->read_long.offset;
   12bbc:	f8ad 3006 	strh.w	r3, [sp, #6]
        rc = ble_att_clt_tx_read_blob(proc->conn_handle, &blob_req);
   12bc0:	f007 fcc6 	bl	1a550 <ble_att_clt_tx_read_blob>
   12bc4:	4604      	mov	r4, r0
    }

    if (rc != 0) {
   12bc6:	b130      	cbz	r0, 12bd6 <ble_gattc_read_long_go+0x3a>
        if (cb_on_err) {
   12bc8:	b12e      	cbz	r6, 12bd6 <ble_gattc_read_long_go+0x3a>
            ble_gattc_read_long_cb(proc, rc, 0, NULL);
   12bca:	2200      	movs	r2, #0
   12bcc:	4628      	mov	r0, r5
   12bce:	4621      	mov	r1, r4
   12bd0:	4613      	mov	r3, r2
   12bd2:	f7ff fdf7 	bl	127c4 <ble_gattc_read_long_cb>
        }
        return rc;
    }

    return 0;
}
   12bd6:	4620      	mov	r0, r4
   12bd8:	b002      	add	sp, #8
   12bda:	bd70      	pop	{r4, r5, r6, pc}

00012bdc <ble_gattc_write_long_go>:
 * Triggers a pending transmit for the specified
 * write-long-characteristic-value proc.
 */
static int
ble_gattc_write_long_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12bdc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    int max_sz;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->write_long.attr.offset < proc->write_long.attr.value_len) {
   12bde:	89c2      	ldrh	r2, [r0, #14]
   12be0:	8a03      	ldrh	r3, [r0, #16]
   12be2:	429a      	cmp	r2, r3
 * Triggers a pending transmit for the specified
 * write-long-characteristic-value proc.
 */
static int
ble_gattc_write_long_go(struct ble_gattc_proc *proc, int cb_on_err)
{
   12be4:	4604      	mov	r4, r0
   12be6:	460e      	mov	r6, r1
   12be8:	8900      	ldrh	r0, [r0, #8]
    int max_sz;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->write_long.attr.offset < proc->write_long.attr.value_len) {
   12bea:	d219      	bcs.n	12c20 <ble_gattc_write_long_go+0x44>
        max_sz = ble_att_mtu(proc->conn_handle) -
   12bec:	f007 f902 	bl	19df4 <ble_att_mtu>
                 BLE_ATT_PREP_WRITE_CMD_BASE_SZ;
        if (max_sz == 0) {
   12bf0:	3805      	subs	r0, #5
   12bf2:	d01e      	beq.n	12c32 <ble_gattc_write_long_go+0x56>
            /* Not connected. */
            rc = BLE_HS_ENOTCONN;
        } else {
            if (proc->write_long.attr.offset + max_sz >
   12bf4:	89e3      	ldrh	r3, [r4, #14]
                proc->write_long.attr.value_len) {
   12bf6:	8a22      	ldrh	r2, [r4, #16]
            } else {
                proc->write_long.length = max_sz;
            }

            prep_req.bapc_handle = proc->write_long.attr.handle;
            prep_req.bapc_offset = proc->write_long.attr.offset;
   12bf8:	f8ad 3006 	strh.w	r3, [sp, #6]
                 BLE_ATT_PREP_WRITE_CMD_BASE_SZ;
        if (max_sz == 0) {
            /* Not connected. */
            rc = BLE_HS_ENOTCONN;
        } else {
            if (proc->write_long.attr.offset + max_sz >
   12bfc:	1819      	adds	r1, r3, r0
   12bfe:	4291      	cmp	r1, r2
                proc->write_long.attr.value_len) {

                proc->write_long.length = proc->write_long.attr.value_len -
   12c00:	bfc4      	itt	gt
   12c02:	1ad2      	subgt	r2, r2, r3
   12c04:	8322      	strhgt	r2, [r4, #24]
                                          proc->write_long.attr.offset;
            } else {
                proc->write_long.length = max_sz;
            }

            prep_req.bapc_handle = proc->write_long.attr.handle;
   12c06:	89a2      	ldrh	r2, [r4, #12]
   12c08:	f8ad 2004 	strh.w	r2, [sp, #4]
            prep_req.bapc_offset = proc->write_long.attr.offset;
            value = proc->write_long.attr.value + proc->write_long.attr.offset;
   12c0c:	6962      	ldr	r2, [r4, #20]
                proc->write_long.attr.value_len) {

                proc->write_long.length = proc->write_long.attr.value_len -
                                          proc->write_long.attr.offset;
            } else {
                proc->write_long.length = max_sz;
   12c0e:	bfd8      	it	le
   12c10:	8320      	strhle	r0, [r4, #24]
            }

            prep_req.bapc_handle = proc->write_long.attr.handle;
            prep_req.bapc_offset = proc->write_long.attr.offset;
            value = proc->write_long.attr.value + proc->write_long.attr.offset;
            rc = ble_att_clt_tx_prep_write(proc->conn_handle,
   12c12:	441a      	add	r2, r3
   12c14:	8920      	ldrh	r0, [r4, #8]
   12c16:	8b23      	ldrh	r3, [r4, #24]
   12c18:	a901      	add	r1, sp, #4
   12c1a:	f007 fe39 	bl	1a890 <ble_att_clt_tx_prep_write>
   12c1e:	e005      	b.n	12c2c <ble_gattc_write_long_go+0x50>
                                           &prep_req, value,
                                           proc->write_long.length);
        }
    } else {
        exec_req.baeq_flags = BLE_ATT_EXEC_WRITE_F_CONFIRM;
   12c20:	a902      	add	r1, sp, #8
   12c22:	2301      	movs	r3, #1
   12c24:	f801 3d08 	strb.w	r3, [r1, #-8]!
        rc = ble_att_clt_tx_exec_write(proc->conn_handle, &exec_req);
   12c28:	f007 fede 	bl	1a9e8 <ble_att_clt_tx_exec_write>
   12c2c:	4605      	mov	r5, r0
    }

    if (rc != 0) {
   12c2e:	b138      	cbz	r0, 12c40 <ble_gattc_write_long_go+0x64>
   12c30:	e000      	b.n	12c34 <ble_gattc_write_long_go+0x58>
    if (proc->write_long.attr.offset < proc->write_long.attr.value_len) {
        max_sz = ble_att_mtu(proc->conn_handle) -
                 BLE_ATT_PREP_WRITE_CMD_BASE_SZ;
        if (max_sz == 0) {
            /* Not connected. */
            rc = BLE_HS_ENOTCONN;
   12c32:	2507      	movs	r5, #7
        exec_req.baeq_flags = BLE_ATT_EXEC_WRITE_F_CONFIRM;
        rc = ble_att_clt_tx_exec_write(proc->conn_handle, &exec_req);
    }

    if (rc != 0) {
        if (cb_on_err) {
   12c34:	b126      	cbz	r6, 12c40 <ble_gattc_write_long_go+0x64>
            ble_gattc_write_long_cb(proc, rc, 0);
   12c36:	4620      	mov	r0, r4
   12c38:	4629      	mov	r1, r5
   12c3a:	2200      	movs	r2, #0
   12c3c:	f7ff fe18 	bl	12870 <ble_gattc_write_long_cb>
        }
        return rc;
    }

    return 0;
}
   12c40:	4628      	mov	r0, r5
   12c42:	b002      	add	sp, #8
   12c44:	bd70      	pop	{r4, r5, r6, pc}

00012c46 <ble_gattc_write_long_err>:
 * write-long-characteristic-value proc.
 */
static void
ble_gattc_write_long_err(struct ble_gattc_proc *proc, int status,
                         uint16_t att_handle)
{
   12c46:	b573      	push	{r0, r1, r4, r5, r6, lr}
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    /* If we have successfully queued any data, and the failure occurred before
     * we could send the execute write command, then erase all queued data.
     */
    if (proc->write_long.attr.offset > 0 &&
   12c48:	89c3      	ldrh	r3, [r0, #14]
 * write-long-characteristic-value proc.
 */
static void
ble_gattc_write_long_err(struct ble_gattc_proc *proc, int status,
                         uint16_t att_handle)
{
   12c4a:	4604      	mov	r4, r0
   12c4c:	460e      	mov	r6, r1
   12c4e:	4615      	mov	r5, r2
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    /* If we have successfully queued any data, and the failure occurred before
     * we could send the execute write command, then erase all queued data.
     */
    if (proc->write_long.attr.offset > 0 &&
   12c50:	b14b      	cbz	r3, 12c66 <ble_gattc_write_long_err+0x20>
   12c52:	8a02      	ldrh	r2, [r0, #16]
   12c54:	429a      	cmp	r2, r3
   12c56:	d906      	bls.n	12c66 <ble_gattc_write_long_err+0x20>
        proc->write_long.attr.offset < proc->write_long.attr.value_len) {

        exec_req.baeq_flags = 0;
   12c58:	a902      	add	r1, sp, #8
   12c5a:	2300      	movs	r3, #0
   12c5c:	f801 3d04 	strb.w	r3, [r1, #-4]!
        ble_att_clt_tx_exec_write(proc->conn_handle, &exec_req);
   12c60:	8900      	ldrh	r0, [r0, #8]
   12c62:	f007 fec1 	bl	1a9e8 <ble_att_clt_tx_exec_write>
    }

    /* Report failure. */
    ble_gattc_write_long_cb(proc, status, att_handle);
   12c66:	4620      	mov	r0, r4
   12c68:	4631      	mov	r1, r6
   12c6a:	462a      	mov	r2, r5
   12c6c:	f7ff fe00 	bl	12870 <ble_gattc_write_long_cb>
}
   12c70:	b002      	add	sp, #8
   12c72:	bd70      	pop	{r4, r5, r6, pc}

00012c74 <ble_gattc_indicate_err>:
{
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != BLE_HS_ENOTCONN) {
   12c74:	2907      	cmp	r1, #7
 * error status to the application.
 */
static void
ble_gattc_indicate_err(struct ble_gattc_proc *proc, int status,
                       uint16_t att_handle)
{
   12c76:	b538      	push	{r3, r4, r5, lr}
   12c78:	4604      	mov	r4, r0
   12c7a:	460d      	mov	r5, r1
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != BLE_HS_ENOTCONN) {
   12c7c:	d10a      	bne.n	12c94 <ble_gattc_indicate_err+0x20>
            return;
        }
    }

    /* Tell the application about the received acknowledgment. */
    ble_gap_notify_tx_event(status, proc->conn_handle,
   12c7e:	4628      	mov	r0, r5
   12c80:	8921      	ldrh	r1, [r4, #8]
   12c82:	89a2      	ldrh	r2, [r4, #12]
   12c84:	2301      	movs	r3, #1
   12c86:	f7ff fb90 	bl	123aa <ble_gap_notify_tx_event>
                            proc->indicate.chr_val_handle, 1);

    /* Send the next indication if one is pending. */
    ble_gatts_send_next_indicate(proc->conn_handle);
   12c8a:	8920      	ldrh	r0, [r4, #8]
}
   12c8c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    /* Tell the application about the received acknowledgment. */
    ble_gap_notify_tx_event(status, proc->conn_handle,
                            proc->indicate.chr_val_handle, 1);

    /* Send the next indication if one is pending. */
    ble_gatts_send_next_indicate(proc->conn_handle);
   12c90:	f001 b9ce 	b.w	14030 <ble_gatts_send_next_indicate>
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != BLE_HS_ENOTCONN) {
        rc = ble_gatts_rx_indicate_ack(proc->conn_handle,
   12c94:	8900      	ldrh	r0, [r0, #8]
   12c96:	89a1      	ldrh	r1, [r4, #12]
   12c98:	f001 f9f6 	bl	14088 <ble_gatts_rx_indicate_ack>
                                       proc->indicate.chr_val_handle);
        if (rc != 0) {
   12c9c:	2800      	cmp	r0, #0
   12c9e:	d0ee      	beq.n	12c7e <ble_gattc_indicate_err+0xa>
    ble_gap_notify_tx_event(status, proc->conn_handle,
                            proc->indicate.chr_val_handle, 1);

    /* Send the next indication if one is pending. */
    ble_gatts_send_next_indicate(proc->conn_handle);
}
   12ca0:	bd38      	pop	{r3, r4, r5, pc}

00012ca2 <ble_gattc_disc_all_chrs_rx_adata>:
 * the specified discover-all-characteristics proc.
 */
static int
ble_gattc_disc_all_chrs_rx_adata(struct ble_gattc_proc *proc,
                                 struct ble_att_read_type_adata *adata)
{
   12ca2:	b530      	push	{r4, r5, lr}
   12ca4:	460c      	mov	r4, r1
   12ca6:	b087      	sub	sp, #28
   12ca8:	4605      	mov	r5, r0
    int cbrc;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    memset(&chr, 0, sizeof chr);
   12caa:	2100      	movs	r1, #0
   12cac:	4668      	mov	r0, sp
   12cae:	2216      	movs	r2, #22
   12cb0:	f7f6 f9af 	bl	9012 <memset>
    chr.def_handle = adata->att_handle;
   12cb4:	8823      	ldrh	r3, [r4, #0]
   12cb6:	f8ad 3000 	strh.w	r3, [sp]

    switch (adata->value_len) {
   12cba:	6863      	ldr	r3, [r4, #4]
   12cbc:	2b05      	cmp	r3, #5
   12cbe:	d007      	beq.n	12cd0 <ble_gattc_disc_all_chrs_rx_adata+0x2e>
   12cc0:	2b13      	cmp	r3, #19
   12cc2:	d125      	bne.n	12d10 <ble_gattc_disc_all_chrs_rx_adata+0x6e>
            goto done;
        }
        break;

    case BLE_GATT_CHR_DECL_SZ_128:
        memcpy(chr.uuid128, adata->value + 3, 16);
   12cc4:	68a3      	ldr	r3, [r4, #8]
   12cc6:	f10d 0105 	add.w	r1, sp, #5
   12cca:	1cda      	adds	r2, r3, #3
   12ccc:	3313      	adds	r3, #19
   12cce:	e009      	b.n	12ce4 <ble_gattc_disc_all_chrs_rx_adata+0x42>
    memset(&chr, 0, sizeof chr);
    chr.def_handle = adata->att_handle;

    switch (adata->value_len) {
    case BLE_GATT_CHR_DECL_SZ_16:
        uuid16 = le16toh(adata->value + 3);
   12cd0:	68a0      	ldr	r0, [r4, #8]
   12cd2:	3003      	adds	r0, #3
   12cd4:	f00a f9db 	bl	1d08e <le16toh>
        rc = ble_uuid_16_to_128(uuid16, chr.uuid128);
   12cd8:	f10d 0105 	add.w	r1, sp, #5
   12cdc:	f005 fbf2 	bl	184c4 <ble_uuid_16_to_128>
        if (rc != 0) {
   12ce0:	b130      	cbz	r0, 12cf0 <ble_gattc_disc_all_chrs_rx_adata+0x4e>
   12ce2:	e015      	b.n	12d10 <ble_gattc_disc_all_chrs_rx_adata+0x6e>
            goto done;
        }
        break;

    case BLE_GATT_CHR_DECL_SZ_128:
        memcpy(chr.uuid128, adata->value + 3, 16);
   12ce4:	f852 0b04 	ldr.w	r0, [r2], #4
   12ce8:	f841 0b04 	str.w	r0, [r1], #4
   12cec:	429a      	cmp	r2, r3
   12cee:	d1f9      	bne.n	12ce4 <ble_gattc_disc_all_chrs_rx_adata+0x42>
    default:
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    chr.properties = adata->value[0];
   12cf0:	68a0      	ldr	r0, [r4, #8]
   12cf2:	f810 3b01 	ldrb.w	r3, [r0], #1
   12cf6:	f88d 3004 	strb.w	r3, [sp, #4]
    chr.val_handle = le16toh(adata->value + 1);
   12cfa:	f00a f9c8 	bl	1d08e <le16toh>

    if (adata->att_handle <= proc->disc_all_chrs.prev_handle) {
   12cfe:	8823      	ldrh	r3, [r4, #0]
   12d00:	89aa      	ldrh	r2, [r5, #12]
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    chr.properties = adata->value[0];
    chr.val_handle = le16toh(adata->value + 1);
   12d02:	f8ad 0002 	strh.w	r0, [sp, #2]

    if (adata->att_handle <= proc->disc_all_chrs.prev_handle) {
   12d06:	429a      	cmp	r2, r3
   12d08:	d202      	bcs.n	12d10 <ble_gattc_disc_all_chrs_rx_adata+0x6e>
        /* Peer sent characteristics out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
        goto done;
    }
    proc->disc_all_chrs.prev_handle = adata->att_handle;
   12d0a:	81ab      	strh	r3, [r5, #12]

    rc = 0;
   12d0c:	2400      	movs	r4, #0
   12d0e:	e000      	b.n	12d12 <ble_gattc_disc_all_chrs_rx_adata+0x70>
    case BLE_GATT_CHR_DECL_SZ_128:
        memcpy(chr.uuid128, adata->value + 3, 16);
        break;

    default:
        rc = BLE_HS_EBADDATA;
   12d10:	240a      	movs	r4, #10
    proc->disc_all_chrs.prev_handle = adata->att_handle;

    rc = 0;

done:
    cbrc = ble_gattc_disc_all_chrs_cb(proc, rc, 0, &chr);
   12d12:	4628      	mov	r0, r5
   12d14:	4621      	mov	r1, r4
   12d16:	2200      	movs	r2, #0
   12d18:	466b      	mov	r3, sp
   12d1a:	f7ff fc69 	bl	125f0 <ble_gattc_disc_all_chrs_cb>
    if (rc != 0 || cbrc != 0) {
   12d1e:	b924      	cbnz	r4, 12d2a <ble_gattc_disc_all_chrs_rx_adata+0x88>
        return BLE_HS_EDONE;
    } else {
        return 0;
   12d20:	2800      	cmp	r0, #0
   12d22:	bf14      	ite	ne
   12d24:	200e      	movne	r0, #14
   12d26:	2000      	moveq	r0, #0
   12d28:	e000      	b.n	12d2c <ble_gattc_disc_all_chrs_rx_adata+0x8a>
    rc = 0;

done:
    cbrc = ble_gattc_disc_all_chrs_cb(proc, rc, 0, &chr);
    if (rc != 0 || cbrc != 0) {
        return BLE_HS_EDONE;
   12d2a:	200e      	movs	r0, #14
    } else {
        return 0;
    }
}
   12d2c:	b007      	add	sp, #28
   12d2e:	bd30      	pop	{r4, r5, pc}

00012d30 <ble_gattc_disc_chr_uuid_rx_adata>:
 * the specified discover-characteristics-by-uuid proc.
 */
static int
ble_gattc_disc_chr_uuid_rx_adata(struct ble_gattc_proc *proc,
                                 struct ble_att_read_type_adata *adata)
{
   12d30:	b530      	push	{r4, r5, lr}
   12d32:	460c      	mov	r4, r1
   12d34:	b087      	sub	sp, #28
   12d36:	4605      	mov	r5, r0
    int cbrc;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    memset(&chr, 0, sizeof chr);
   12d38:	2100      	movs	r1, #0
   12d3a:	4668      	mov	r0, sp
   12d3c:	2216      	movs	r2, #22
   12d3e:	f7f6 f968 	bl	9012 <memset>
    chr.def_handle = adata->att_handle;
   12d42:	8823      	ldrh	r3, [r4, #0]
   12d44:	f8ad 3000 	strh.w	r3, [sp]

    switch (adata->value_len) {
   12d48:	6863      	ldr	r3, [r4, #4]
   12d4a:	2b05      	cmp	r3, #5
   12d4c:	d007      	beq.n	12d5e <ble_gattc_disc_chr_uuid_rx_adata+0x2e>
   12d4e:	2b13      	cmp	r3, #19
   12d50:	d138      	bne.n	12dc4 <ble_gattc_disc_chr_uuid_rx_adata+0x94>
            goto done;
        }
        break;

    case BLE_GATT_CHR_DECL_SZ_128:
        memcpy(chr.uuid128, adata->value + 3, 16);
   12d52:	68a3      	ldr	r3, [r4, #8]
   12d54:	f10d 0105 	add.w	r1, sp, #5
   12d58:	1cda      	adds	r2, r3, #3
   12d5a:	3313      	adds	r3, #19
   12d5c:	e009      	b.n	12d72 <ble_gattc_disc_chr_uuid_rx_adata+0x42>
    memset(&chr, 0, sizeof chr);
    chr.def_handle = adata->att_handle;

    switch (adata->value_len) {
    case BLE_GATT_CHR_DECL_SZ_16:
        uuid16 = le16toh(adata->value + 3);
   12d5e:	68a0      	ldr	r0, [r4, #8]
   12d60:	3003      	adds	r0, #3
   12d62:	f00a f994 	bl	1d08e <le16toh>
        rc = ble_uuid_16_to_128(uuid16, chr.uuid128);
   12d66:	f10d 0105 	add.w	r1, sp, #5
   12d6a:	f005 fbab 	bl	184c4 <ble_uuid_16_to_128>
        if (rc != 0) {
   12d6e:	b130      	cbz	r0, 12d7e <ble_gattc_disc_chr_uuid_rx_adata+0x4e>
   12d70:	e028      	b.n	12dc4 <ble_gattc_disc_chr_uuid_rx_adata+0x94>
            goto done;
        }
        break;

    case BLE_GATT_CHR_DECL_SZ_128:
        memcpy(chr.uuid128, adata->value + 3, 16);
   12d72:	f852 0b04 	ldr.w	r0, [r2], #4
   12d76:	f841 0b04 	str.w	r0, [r1], #4
   12d7a:	429a      	cmp	r2, r3
   12d7c:	d1f9      	bne.n	12d72 <ble_gattc_disc_chr_uuid_rx_adata+0x42>
    default:
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    chr.properties = adata->value[0];
   12d7e:	68a0      	ldr	r0, [r4, #8]
   12d80:	f810 3b01 	ldrb.w	r3, [r0], #1
   12d84:	f88d 3004 	strb.w	r3, [sp, #4]
    chr.val_handle = le16toh(adata->value + 1);
   12d88:	f00a f981 	bl	1d08e <le16toh>

    if (adata->att_handle <= proc->disc_chr_uuid.prev_handle) {
   12d8c:	8823      	ldrh	r3, [r4, #0]
   12d8e:	8baa      	ldrh	r2, [r5, #28]
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    chr.properties = adata->value[0];
    chr.val_handle = le16toh(adata->value + 1);
   12d90:	f8ad 0002 	strh.w	r0, [sp, #2]

    if (adata->att_handle <= proc->disc_chr_uuid.prev_handle) {
   12d94:	429a      	cmp	r2, r3
   12d96:	d215      	bcs.n	12dc4 <ble_gattc_disc_chr_uuid_rx_adata+0x94>
        /* Peer sent characteristics out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    proc->disc_chr_uuid.prev_handle = adata->att_handle;
   12d98:	83ab      	strh	r3, [r5, #28]

done:
    if (rc != 0) {
        /* Failure. */
        cbrc = ble_gattc_disc_chr_uuid_cb(proc, rc, 0, NULL);
    } else if (memcmp(chr.uuid128, proc->disc_chr_uuid.chr_uuid, 16) == 0) {
   12d9a:	f10d 0005 	add.w	r0, sp, #5
   12d9e:	f105 010c 	add.w	r1, r5, #12
   12da2:	2210      	movs	r2, #16
   12da4:	f7f6 f91c 	bl	8fe0 <memcmp>
   12da8:	4604      	mov	r4, r0
   12daa:	b948      	cbnz	r0, 12dc0 <ble_gattc_disc_chr_uuid_rx_adata+0x90>
        /* Requested characteristic discovered. */
        cbrc = ble_gattc_disc_chr_uuid_cb(proc, 0, 0, &chr);
   12dac:	4621      	mov	r1, r4
   12dae:	4622      	mov	r2, r4
   12db0:	4628      	mov	r0, r5
   12db2:	466b      	mov	r3, sp
   12db4:	f7ff fc44 	bl	12640 <ble_gattc_disc_chr_uuid_cb>
        /* Uninteresting characteristic; ignore. */
        cbrc = 0;
    }

    if (rc != 0 || cbrc != 0) {
        return BLE_HS_EDONE;
   12db8:	2800      	cmp	r0, #0
   12dba:	bf18      	it	ne
   12dbc:	240e      	movne	r4, #14
   12dbe:	e008      	b.n	12dd2 <ble_gattc_disc_chr_uuid_rx_adata+0xa2>
    } else {
        return 0;
   12dc0:	2400      	movs	r4, #0
   12dc2:	e006      	b.n	12dd2 <ble_gattc_disc_chr_uuid_rx_adata+0xa2>
    rc = 0;

done:
    if (rc != 0) {
        /* Failure. */
        cbrc = ble_gattc_disc_chr_uuid_cb(proc, rc, 0, NULL);
   12dc4:	2200      	movs	r2, #0
   12dc6:	4628      	mov	r0, r5
   12dc8:	210a      	movs	r1, #10
   12dca:	4613      	mov	r3, r2
   12dcc:	f7ff fc38 	bl	12640 <ble_gattc_disc_chr_uuid_cb>
        /* Uninteresting characteristic; ignore. */
        cbrc = 0;
    }

    if (rc != 0 || cbrc != 0) {
        return BLE_HS_EDONE;
   12dd0:	240e      	movs	r4, #14
    } else {
        return 0;
    }
}
   12dd2:	4620      	mov	r0, r4
   12dd4:	b007      	add	sp, #28
   12dd6:	bd30      	pop	{r4, r5, pc}

00012dd8 <ble_gattc_write_long_rx_prep>:
 */
static int
ble_gattc_write_long_rx_prep(struct ble_gattc_proc *proc,
                             int status, struct ble_att_prep_write_cmd *rsp,
                             void *attr_data, uint16_t attr_len)
{
   12dd8:	b570      	push	{r4, r5, r6, lr}
   12dda:	4604      	mov	r4, r0
   12ddc:	f8bd 5010 	ldrh.w	r5, [sp, #16]
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   12de0:	b9f1      	cbnz	r1, 12e20 <ble_gattc_write_long_rx_prep+0x48>
        rc = status;
        goto err;
    }

    /* Verify the response. */
    if (rsp->bapc_handle != proc->write_long.attr.handle) {
   12de2:	8810      	ldrh	r0, [r2, #0]
   12de4:	89a1      	ldrh	r1, [r4, #12]
   12de6:	4288      	cmp	r0, r1
   12de8:	d119      	bne.n	12e1e <ble_gattc_write_long_rx_prep+0x46>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    if (rsp->bapc_offset != proc->write_long.attr.offset) {
   12dea:	8852      	ldrh	r2, [r2, #2]
   12dec:	89e1      	ldrh	r1, [r4, #14]
   12dee:	4291      	cmp	r1, r2
   12df0:	d115      	bne.n	12e1e <ble_gattc_write_long_rx_prep+0x46>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    if (rsp->bapc_offset + attr_len > proc->write_long.attr.value_len) {
   12df2:	8a22      	ldrh	r2, [r4, #16]
   12df4:	194e      	adds	r6, r1, r5
   12df6:	4296      	cmp	r6, r2
   12df8:	dc11      	bgt.n	12e1e <ble_gattc_write_long_rx_prep+0x46>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    if (attr_len != proc->write_long.length) {
   12dfa:	8b22      	ldrh	r2, [r4, #24]
   12dfc:	42aa      	cmp	r2, r5
   12dfe:	d10e      	bne.n	12e1e <ble_gattc_write_long_rx_prep+0x46>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    if (memcmp(attr_data, proc->write_long.attr.value + rsp->bapc_offset,
   12e00:	6965      	ldr	r5, [r4, #20]
   12e02:	4618      	mov	r0, r3
   12e04:	4429      	add	r1, r5
   12e06:	f7f6 f8eb 	bl	8fe0 <memcmp>
   12e0a:	4605      	mov	r5, r0
   12e0c:	b938      	cbnz	r0, 12e1e <ble_gattc_write_long_rx_prep+0x46>
        goto err;
    }

    /* Send follow-up request. */
    proc->write_long.attr.offset += attr_len;
    rc = ble_gattc_write_long_go(proc, 1);
   12e0e:	2101      	movs	r1, #1
        rc = BLE_HS_EBADDATA;
        goto err;
    }

    /* Send follow-up request. */
    proc->write_long.attr.offset += attr_len;
   12e10:	81e6      	strh	r6, [r4, #14]
    rc = ble_gattc_write_long_go(proc, 1);
   12e12:	4620      	mov	r0, r4
   12e14:	f7ff fee2 	bl	12bdc <ble_gattc_write_long_go>
    if (rc != 0) {
   12e18:	4601      	mov	r1, r0
   12e1a:	b908      	cbnz	r0, 12e20 <ble_gattc_write_long_rx_prep+0x48>
   12e1c:	e005      	b.n	12e2a <ble_gattc_write_long_rx_prep+0x52>
        goto err;
    }

    /* Verify the response. */
    if (rsp->bapc_handle != proc->write_long.attr.handle) {
        rc = BLE_HS_EBADDATA;
   12e1e:	210a      	movs	r1, #10

    return 0;

err:
    /* XXX: Might need to cancel pending writes. */
    ble_gattc_write_long_cb(proc, rc, 0);
   12e20:	4620      	mov	r0, r4
   12e22:	2200      	movs	r2, #0
   12e24:	f7ff fd24 	bl	12870 <ble_gattc_write_long_cb>
    return BLE_HS_EDONE;
   12e28:	250e      	movs	r5, #14
}
   12e2a:	4628      	mov	r0, r5
   12e2c:	bd70      	pop	{r4, r5, r6, pc}

00012e2e <ble_gattc_read_uuid_rx_complete>:
 * Handles a notification that a read-by-type response has been fully
 * processed for the specified read-using-characteristic-uuid proc.
 */
static int
ble_gattc_read_uuid_rx_complete(struct ble_gattc_proc *proc, int status)
{
   12e2e:	b508      	push	{r3, lr}
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   12e30:	460a      	mov	r2, r1
   12e32:	b109      	cbz	r1, 12e38 <ble_gattc_read_uuid_rx_complete+0xa>
        ble_gattc_read_uuid_cb(proc, status, 0, NULL);
   12e34:	2200      	movs	r2, #0
   12e36:	e000      	b.n	12e3a <ble_gattc_read_uuid_rx_complete+0xc>
    }

    /* XXX: We may need to send a follow-up request to address the possibility
     * of multiple characteristics with identical UUIDs.
     */
    ble_gattc_read_uuid_cb(proc, BLE_HS_EDONE, 0, NULL);
   12e38:	210e      	movs	r1, #14
   12e3a:	4613      	mov	r3, r2
   12e3c:	f7ff fc82 	bl	12744 <ble_gattc_read_uuid_cb>
    return BLE_HS_EDONE;
}
   12e40:	200e      	movs	r0, #14
   12e42:	bd08      	pop	{r3, pc}

00012e44 <ble_gattc_process_status>:
    proc->exp_os_ticks = os_time_get() + BLE_GATT_UNRESPONSIVE_TIMEOUT;
}

static void
ble_gattc_process_status(struct ble_gattc_proc *proc, int status)
{
   12e44:	b538      	push	{r3, r4, r5, lr}
   12e46:	4604      	mov	r4, r0
    if (status == 0) {
   12e48:	460d      	mov	r5, r1
   12e4a:	b979      	cbnz	r1, 12e6c <ble_gattc_process_status+0x28>
}

static void
ble_gattc_proc_set_timer(struct ble_gattc_proc *proc)
{
    proc->exp_os_ticks = os_time_get() + BLE_GATT_UNRESPONSIVE_TIMEOUT;
   12e4c:	f7f7 fcb8 	bl	a7c0 <os_time_get>
   12e50:	f500 6070 	add.w	r0, r0, #3840	; 0xf00
   12e54:	6060      	str	r0, [r4, #4]
static void
ble_gattc_proc_insert(struct ble_gattc_proc *proc)
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    ble_hs_lock();
   12e56:	f001 fc75 	bl	14744 <ble_hs_lock>
    STAILQ_INSERT_TAIL(&ble_gattc_procs, proc, next);
   12e5a:	4b06      	ldr	r3, [pc, #24]	; (12e74 <ble_gattc_process_status+0x30>)
   12e5c:	6025      	str	r5, [r4, #0]
   12e5e:	685a      	ldr	r2, [r3, #4]
   12e60:	6014      	str	r4, [r2, #0]
   12e62:	605c      	str	r4, [r3, #4]
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
    }
}
   12e64:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
{
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    ble_hs_lock();
    STAILQ_INSERT_TAIL(&ble_gattc_procs, proc, next);
    ble_hs_unlock();
   12e68:	f001 bc74 	b.w	14754 <ble_hs_unlock>
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
    }
}
   12e6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   12e70:	f7ff bda6 	b.w	129c0 <ble_gattc_proc_free>
   12e74:	200020c4 	.word	0x200020c4

00012e78 <ble_gattc_disc_all_chrs_rx_complete>:
 * Handles a notification that a read-by-type response has been fully
 * processed for the specified discover-all-characteristics proc.
 */
static int
ble_gattc_disc_all_chrs_rx_complete(struct ble_gattc_proc *proc, int status)
{
   12e78:	b508      	push	{r3, lr}
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   12e7a:	460a      	mov	r2, r1
   12e7c:	b109      	cbz	r1, 12e82 <ble_gattc_disc_all_chrs_rx_complete+0xa>
        ble_gattc_disc_all_chrs_cb(proc, status, 0, NULL);
   12e7e:	2200      	movs	r2, #0
   12e80:	e004      	b.n	12e8c <ble_gattc_disc_all_chrs_rx_complete+0x14>
        return BLE_HS_EDONE;
    }

    if (proc->disc_all_chrs.prev_handle == proc->disc_all_chrs.end_handle) {
   12e82:	8981      	ldrh	r1, [r0, #12]
   12e84:	89c3      	ldrh	r3, [r0, #14]
   12e86:	4299      	cmp	r1, r3
   12e88:	d105      	bne.n	12e96 <ble_gattc_disc_all_chrs_rx_complete+0x1e>
        /* Characteristic discovery complete. */
        ble_gattc_disc_all_chrs_cb(proc, BLE_HS_EDONE, 0, NULL);
   12e8a:	210e      	movs	r1, #14
   12e8c:	4613      	mov	r3, r2
   12e8e:	f7ff fbaf 	bl	125f0 <ble_gattc_disc_all_chrs_cb>
   12e92:	200e      	movs	r0, #14
   12e94:	bd08      	pop	{r3, pc}
        return BLE_HS_EDONE;
    }

    /* Send follow-up request. */
    rc = ble_gattc_disc_all_chrs_go(proc, 1);
   12e96:	2101      	movs	r1, #1
   12e98:	f7ff fde2 	bl	12a60 <ble_gattc_disc_all_chrs_go>
    if (rc != 0) {
        return BLE_HS_EDONE;
    }
    return 0;
   12e9c:	2800      	cmp	r0, #0
   12e9e:	bf14      	ite	ne
   12ea0:	200e      	movne	r0, #14
   12ea2:	2000      	moveq	r0, #0
}
   12ea4:	bd08      	pop	{r3, pc}

00012ea6 <ble_gattc_disc_chr_uuid_rx_complete>:
 * Handles a notification that a read-by-type response has been fully
 * processed for the specified discover-characteristics-by-uuid proc.
 */
static int
ble_gattc_disc_chr_uuid_rx_complete(struct ble_gattc_proc *proc, int status)
{
   12ea6:	b508      	push	{r3, lr}
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   12ea8:	460a      	mov	r2, r1
   12eaa:	b109      	cbz	r1, 12eb0 <ble_gattc_disc_chr_uuid_rx_complete+0xa>
        ble_gattc_disc_chr_uuid_cb(proc, status, 0, NULL);
   12eac:	2200      	movs	r2, #0
   12eae:	e004      	b.n	12eba <ble_gattc_disc_chr_uuid_rx_complete+0x14>
        return BLE_HS_EDONE;
    }

    if (proc->disc_chr_uuid.prev_handle == proc->disc_chr_uuid.end_handle) {
   12eb0:	8b81      	ldrh	r1, [r0, #28]
   12eb2:	8bc3      	ldrh	r3, [r0, #30]
   12eb4:	4299      	cmp	r1, r3
   12eb6:	d105      	bne.n	12ec4 <ble_gattc_disc_chr_uuid_rx_complete+0x1e>
        /* Characteristic discovery complete. */
        ble_gattc_disc_chr_uuid_cb(proc, BLE_HS_EDONE, 0, NULL);
   12eb8:	210e      	movs	r1, #14
   12eba:	4613      	mov	r3, r2
   12ebc:	f7ff fbc0 	bl	12640 <ble_gattc_disc_chr_uuid_cb>
   12ec0:	200e      	movs	r0, #14
   12ec2:	bd08      	pop	{r3, pc}
        return BLE_HS_EDONE;
    }

    /* Send follow-up request. */
    rc = ble_gattc_disc_chr_uuid_go(proc, 1);
   12ec4:	2101      	movs	r1, #1
   12ec6:	f7ff fdec 	bl	12aa2 <ble_gattc_disc_chr_uuid_go>
    if (rc != 0) {
        return BLE_HS_EDONE;
    }
    return 0;
   12eca:	2800      	cmp	r0, #0
   12ecc:	bf14      	ite	ne
   12ece:	200e      	movne	r0, #14
   12ed0:	2000      	moveq	r0, #0
}
   12ed2:	bd08      	pop	{r3, pc}

00012ed4 <ble_gattc_find_inc_svcs_rx_complete>:
 * Handles a notification that a read-by-type response has been fully
 * processed for the specified find-included-services proc.
 */
static int
ble_gattc_find_inc_svcs_rx_complete(struct ble_gattc_proc *proc, int status)
{
   12ed4:	b508      	push	{r3, lr}
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   12ed6:	460a      	mov	r2, r1
   12ed8:	b109      	cbz	r1, 12ede <ble_gattc_find_inc_svcs_rx_complete+0xa>
        ble_gattc_find_inc_svcs_cb(proc, status, 0, NULL);
   12eda:	2200      	movs	r2, #0
   12edc:	e005      	b.n	12eea <ble_gattc_find_inc_svcs_rx_complete+0x16>
        return BLE_HS_EDONE;
    }

    if (proc->find_inc_svcs.prev_handle == 0xffff) {
   12ede:	8981      	ldrh	r1, [r0, #12]
   12ee0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   12ee4:	4299      	cmp	r1, r3
   12ee6:	d105      	bne.n	12ef4 <ble_gattc_find_inc_svcs_rx_complete+0x20>
        /* Procedure complete. */
        ble_gattc_find_inc_svcs_cb(proc, BLE_HS_EDONE, 0, NULL);
   12ee8:	210e      	movs	r1, #14
   12eea:	4613      	mov	r3, r2
   12eec:	f7ff fb56 	bl	1259c <ble_gattc_find_inc_svcs_cb>
   12ef0:	200e      	movs	r0, #14
   12ef2:	bd08      	pop	{r3, pc}
        return BLE_HS_EDONE;
    }

    /* Send follow-up request. */
    rc = ble_gattc_find_inc_svcs_go(proc, 1);
   12ef4:	2101      	movs	r1, #1
   12ef6:	f7ff fdf5 	bl	12ae4 <ble_gattc_find_inc_svcs_go>
    if (rc != 0) {
        return BLE_HS_EDONE;
    }
    return 0;
   12efa:	2800      	cmp	r0, #0
   12efc:	bf14      	ite	ne
   12efe:	200e      	movne	r0, #14
   12f00:	2000      	moveq	r0, #0
}
   12f02:	bd08      	pop	{r3, pc}

00012f04 <ble_gattc_read_long_rx_read_rsp>:
 * read-long-characteristic-values proc.
 */
static int
ble_gattc_read_long_rx_read_rsp(struct ble_gattc_proc *proc, int status,
                                void *value, int value_len)
{
   12f04:	b5f0      	push	{r4, r5, r6, r7, lr}
   12f06:	b085      	sub	sp, #20
   12f08:	461f      	mov	r7, r3
    uint16_t mtu;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr.handle = proc->read_long.handle;
   12f0a:	8983      	ldrh	r3, [r0, #12]
   12f0c:	f8ad 3004 	strh.w	r3, [sp, #4]
    attr.offset = proc->read_long.offset;
   12f10:	89c3      	ldrh	r3, [r0, #14]
   12f12:	f8ad 3006 	strh.w	r3, [sp, #6]
    attr.value_len = value_len;
   12f16:	b2bd      	uxth	r5, r7
    attr.value = value;
   12f18:	9203      	str	r2, [sp, #12]

    /* Report partial payload to application. */
    rc = ble_gattc_read_long_cb(proc, status, 0, &attr);
   12f1a:	ab01      	add	r3, sp, #4
   12f1c:	2200      	movs	r2, #0
 * read-long-characteristic-values proc.
 */
static int
ble_gattc_read_long_rx_read_rsp(struct ble_gattc_proc *proc, int status,
                                void *value, int value_len)
{
   12f1e:	4604      	mov	r4, r0
   12f20:	460e      	mov	r6, r1

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr.handle = proc->read_long.handle;
    attr.offset = proc->read_long.offset;
    attr.value_len = value_len;
   12f22:	f8ad 5008 	strh.w	r5, [sp, #8]
    attr.value = value;

    /* Report partial payload to application. */
    rc = ble_gattc_read_long_cb(proc, status, 0, &attr);
   12f26:	f7ff fc4d 	bl	127c4 <ble_gattc_read_long_cb>
    if (rc != 0 || status != 0) {
   12f2a:	b968      	cbnz	r0, 12f48 <ble_gattc_read_long_rx_read_rsp+0x44>
   12f2c:	b966      	cbnz	r6, 12f48 <ble_gattc_read_long_rx_read_rsp+0x44>
        return BLE_HS_EDONE;
    }

    /* Determine if this is the end of the attribute value. */
    mtu = ble_att_mtu(proc->conn_handle);
   12f2e:	8920      	ldrh	r0, [r4, #8]
   12f30:	f006 ff60 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   12f34:	b140      	cbz	r0, 12f48 <ble_gattc_read_long_rx_read_rsp+0x44>
        /* No longer connected. */
        return BLE_HS_EDONE;
    }

    if (value_len < mtu - 1) {
   12f36:	3801      	subs	r0, #1
   12f38:	4287      	cmp	r7, r0
   12f3a:	da07      	bge.n	12f4c <ble_gattc_read_long_rx_read_rsp+0x48>
        /* Response shorter than maximum allowed; read complete. */
        ble_gattc_read_long_cb(proc, BLE_HS_EDONE, 0, NULL);
   12f3c:	4620      	mov	r0, r4
   12f3e:	210e      	movs	r1, #14
   12f40:	4632      	mov	r2, r6
   12f42:	4633      	mov	r3, r6
   12f44:	f7ff fc3e 	bl	127c4 <ble_gattc_read_long_cb>
   12f48:	200e      	movs	r0, #14
   12f4a:	e008      	b.n	12f5e <ble_gattc_read_long_rx_read_rsp+0x5a>
        return BLE_HS_EDONE;
    }

    /* Send follow-up request. */
    proc->read_long.offset += value_len;
   12f4c:	89e3      	ldrh	r3, [r4, #14]
   12f4e:	442b      	add	r3, r5
   12f50:	81e3      	strh	r3, [r4, #14]
    rc = ble_gattc_read_long_go(proc, 1);
   12f52:	4620      	mov	r0, r4
   12f54:	2101      	movs	r1, #1
   12f56:	f7ff fe21 	bl	12b9c <ble_gattc_read_long_go>
    if (rc != 0) {
   12f5a:	2800      	cmp	r0, #0
   12f5c:	d1f4      	bne.n	12f48 <ble_gattc_read_long_rx_read_rsp+0x44>
        return BLE_HS_EDONE;
    }

    return 0;
}
   12f5e:	b005      	add	sp, #20
   12f60:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012f62 <ble_gattc_write_reliable_err>:
 * write-reliable-characteristic-value proc.
 */
static void
ble_gattc_write_reliable_err(struct ble_gattc_proc *proc, int status,
                             uint16_t att_handle)
{
   12f62:	b513      	push	{r0, r1, r4, lr}
   12f64:	4604      	mov	r4, r0
    struct ble_att_exec_write_req exec_req;

    ble_gattc_dbg_assert_proc_not_inserted(proc);
    ble_gattc_write_reliable_cb(proc, status, att_handle);
   12f66:	f7ff fca7 	bl	128b8 <ble_gattc_write_reliable_cb>

    /* If we have successfully queued any data, and the failure occurred before
     * we could send the execute write command, then erase all queued data.
     */
    if (proc->write_reliable.cur_attr > 0 &&
   12f6a:	6963      	ldr	r3, [r4, #20]
   12f6c:	2b00      	cmp	r3, #0
   12f6e:	dd09      	ble.n	12f84 <ble_gattc_write_reliable_err+0x22>
   12f70:	6922      	ldr	r2, [r4, #16]
   12f72:	4293      	cmp	r3, r2
   12f74:	da06      	bge.n	12f84 <ble_gattc_write_reliable_err+0x22>
        proc->write_reliable.cur_attr < proc->write_reliable.num_attrs) {

        exec_req.baeq_flags = 0;
   12f76:	a902      	add	r1, sp, #8
   12f78:	2300      	movs	r3, #0
   12f7a:	f801 3d04 	strb.w	r3, [r1, #-4]!
        ble_att_clt_tx_exec_write(proc->conn_handle, &exec_req);
   12f7e:	8920      	ldrh	r0, [r4, #8]
   12f80:	f007 fd32 	bl	1a9e8 <ble_att_clt_tx_exec_write>
    }
}
   12f84:	b002      	add	sp, #8
   12f86:	bd10      	pop	{r4, pc}

00012f88 <ble_gattc_find_inc_svcs_rx_adata>:
 * the specified find-included-services proc.
 */
static int
ble_gattc_find_inc_svcs_rx_adata(struct ble_gattc_proc *proc,
                                 struct ble_att_read_type_adata *adata)
{
   12f88:	b530      	push	{r4, r5, lr}
    int cbrc;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start != 0) {
   12f8a:	8a03      	ldrh	r3, [r0, #16]
 * the specified find-included-services proc.
 */
static int
ble_gattc_find_inc_svcs_rx_adata(struct ble_gattc_proc *proc,
                                 struct ble_att_read_type_adata *adata)
{
   12f8c:	b087      	sub	sp, #28
   12f8e:	4605      	mov	r5, r0
   12f90:	460c      	mov	r4, r1
    int cbrc;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (proc->find_inc_svcs.cur_start != 0) {
   12f92:	bb2b      	cbnz	r3, 12fe0 <ble_gattc_find_inc_svcs_rx_adata+0x58>
        return 0;
    }

    call_cb = 1;

    if (adata->att_handle <= proc->find_inc_svcs.prev_handle) {
   12f94:	880b      	ldrh	r3, [r1, #0]
   12f96:	8982      	ldrh	r2, [r0, #12]
   12f98:	429a      	cmp	r2, r3
   12f9a:	d223      	bcs.n	12fe4 <ble_gattc_find_inc_svcs_rx_adata+0x5c>
        /* Peer sent services out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    proc->find_inc_svcs.prev_handle = adata->att_handle;
   12f9c:	8183      	strh	r3, [r0, #12]

    switch (adata->value_len) {
   12f9e:	684b      	ldr	r3, [r1, #4]
   12fa0:	2b04      	cmp	r3, #4
   12fa2:	d014      	beq.n	12fce <ble_gattc_find_inc_svcs_rx_adata+0x46>
   12fa4:	2b06      	cmp	r3, #6
   12fa6:	d11d      	bne.n	12fe4 <ble_gattc_find_inc_svcs_rx_adata+0x5c>
        proc->find_inc_svcs.cur_end = le16toh(adata->value + 2);
        call_cb = 0;
        break;

    case BLE_GATTS_INC_SVC_LEN_UUID:
        service.start_handle = le16toh(adata->value + 0);
   12fa8:	6888      	ldr	r0, [r1, #8]
   12faa:	f00a f870 	bl	1d08e <le16toh>
   12fae:	f8ad 0004 	strh.w	r0, [sp, #4]
        service.end_handle = le16toh(adata->value + 2);
   12fb2:	68a0      	ldr	r0, [r4, #8]
   12fb4:	3002      	adds	r0, #2
   12fb6:	f00a f86a 	bl	1d08e <le16toh>
   12fba:	f8ad 0006 	strh.w	r0, [sp, #6]
        uuid16 = le16toh(adata->value + 4);
   12fbe:	68a0      	ldr	r0, [r4, #8]
   12fc0:	3004      	adds	r0, #4
   12fc2:	f00a f864 	bl	1d08e <le16toh>
        rc = ble_uuid_16_to_128(uuid16, service.uuid128);
   12fc6:	a902      	add	r1, sp, #8
   12fc8:	f005 fa7c 	bl	184c4 <ble_uuid_16_to_128>
   12fcc:	e00a      	b.n	12fe4 <ble_gattc_find_inc_svcs_rx_adata+0x5c>

    proc->find_inc_svcs.prev_handle = adata->att_handle;

    switch (adata->value_len) {
    case BLE_GATTS_INC_SVC_LEN_NO_UUID:
        proc->find_inc_svcs.cur_start = le16toh(adata->value + 0);
   12fce:	6888      	ldr	r0, [r1, #8]
   12fd0:	f00a f85d 	bl	1d08e <le16toh>
   12fd4:	8228      	strh	r0, [r5, #16]
        proc->find_inc_svcs.cur_end = le16toh(adata->value + 2);
   12fd6:	68a0      	ldr	r0, [r4, #8]
   12fd8:	3002      	adds	r0, #2
   12fda:	f00a f858 	bl	1d08e <le16toh>
   12fde:	8268      	strh	r0, [r5, #18]

    if (proc->find_inc_svcs.cur_start != 0) {
        /* We only read one 128-bit UUID service at a time.  Ignore the
         * additional services in the response.
         */
        return 0;
   12fe0:	2000      	movs	r0, #0
   12fe2:	e008      	b.n	12ff6 <ble_gattc_find_inc_svcs_rx_adata+0x6e>

    rc = 0;

done:
    if (call_cb) {
        cbrc = ble_gattc_find_inc_svcs_cb(proc, 0, 0, &service);
   12fe4:	2100      	movs	r1, #0
   12fe6:	4628      	mov	r0, r5
   12fe8:	460a      	mov	r2, r1
   12fea:	ab01      	add	r3, sp, #4
   12fec:	f7ff fad6 	bl	1259c <ble_gattc_find_inc_svcs_cb>
        }
    } else {
        cbrc = 0;
    }

    if (rc != 0 || cbrc != 0) {
   12ff0:	2800      	cmp	r0, #0
   12ff2:	d0f5      	beq.n	12fe0 <ble_gattc_find_inc_svcs_rx_adata+0x58>
        return BLE_HS_EDONE;
   12ff4:	200e      	movs	r0, #14
    } else {
        return 0;
    }
}
   12ff6:	b007      	add	sp, #28
   12ff8:	bd30      	pop	{r4, r5, pc}

00012ffa <ble_gattc_write_reliable_go.constprop.12>:
/**
 * Triggers a pending transmit for the specified
 * write-reliable-characteristic-value proc.
 */
static int
ble_gattc_write_reliable_go(struct ble_gattc_proc *proc, int cb_on_err)
   12ffa:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int attr_idx;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr_idx = proc->write_reliable.cur_attr;
   12ffc:	6942      	ldr	r2, [r0, #20]
    if (attr_idx < proc->write_reliable.num_attrs) {
   12ffe:	6903      	ldr	r3, [r0, #16]
   13000:	429a      	cmp	r2, r3
/**
 * Triggers a pending transmit for the specified
 * write-reliable-characteristic-value proc.
 */
static int
ble_gattc_write_reliable_go(struct ble_gattc_proc *proc, int cb_on_err)
   13002:	4604      	mov	r4, r0
   13004:	8900      	ldrh	r0, [r0, #8]
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    attr_idx = proc->write_reliable.cur_attr;
    if (attr_idx < proc->write_reliable.num_attrs) {
   13006:	da0f      	bge.n	13028 <ble_gattc_write_reliable_go.constprop.12+0x2e>
        attr = proc->write_reliable.attrs + attr_idx;
   13008:	230c      	movs	r3, #12
   1300a:	4353      	muls	r3, r2
   1300c:	68e2      	ldr	r2, [r4, #12]
   1300e:	18d5      	adds	r5, r2, r3
        prep_req.bapc_handle = attr->handle;
   13010:	5ad3      	ldrh	r3, [r2, r3]
   13012:	f8ad 3004 	strh.w	r3, [sp, #4]
        prep_req.bapc_offset = 0;
   13016:	2300      	movs	r3, #0
   13018:	f8ad 3006 	strh.w	r3, [sp, #6]
        rc = ble_att_clt_tx_prep_write(proc->conn_handle, &prep_req,
   1301c:	a901      	add	r1, sp, #4
   1301e:	68aa      	ldr	r2, [r5, #8]
   13020:	88ab      	ldrh	r3, [r5, #4]
   13022:	f007 fc35 	bl	1a890 <ble_att_clt_tx_prep_write>
   13026:	e005      	b.n	13034 <ble_gattc_write_reliable_go.constprop.12+0x3a>
                                       attr->value, attr->value_len);
    } else {
        exec_req.baeq_flags = BLE_ATT_EXEC_WRITE_F_CONFIRM;
   13028:	a902      	add	r1, sp, #8
   1302a:	2301      	movs	r3, #1
   1302c:	f801 3d08 	strb.w	r3, [r1, #-8]!
        rc = ble_att_clt_tx_exec_write(proc->conn_handle, &exec_req);
   13030:	f007 fcda 	bl	1a9e8 <ble_att_clt_tx_exec_write>
   13034:	4605      	mov	r5, r0
    }

    if (rc != 0) {
   13036:	b120      	cbz	r0, 13042 <ble_gattc_write_reliable_go.constprop.12+0x48>
        if (cb_on_err) {
            ble_gattc_write_reliable_cb(proc, rc, 0);
   13038:	4620      	mov	r0, r4
   1303a:	4629      	mov	r1, r5
   1303c:	2200      	movs	r2, #0
   1303e:	f7ff fc3b 	bl	128b8 <ble_gattc_write_reliable_cb>
        }
        return rc;
    }

    return 0;
}
   13042:	4628      	mov	r0, r5
   13044:	b003      	add	sp, #12
   13046:	bd30      	pop	{r4, r5, pc}

00013048 <ble_gattc_write_reliable_rx_prep>:
static int
ble_gattc_write_reliable_rx_prep(struct ble_gattc_proc *proc,
                                 int status,
                                 struct ble_att_prep_write_cmd *rsp,
                                 void *attr_data, uint16_t attr_len)
{
   13048:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1304a:	4604      	mov	r4, r0
    const struct ble_gatt_attr *attr;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   1304c:	bb09      	cbnz	r1, 13092 <ble_gattc_write_reliable_rx_prep+0x4a>
        rc = status;
        goto err;
    }

    if (proc->write_reliable.cur_attr >= proc->write_reliable.num_attrs) {
   1304e:	6945      	ldr	r5, [r0, #20]
   13050:	6901      	ldr	r1, [r0, #16]
   13052:	428d      	cmp	r5, r1
   13054:	da1c      	bge.n	13090 <ble_gattc_write_reliable_rx_prep+0x48>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    attr = proc->write_reliable.attrs + proc->write_reliable.cur_attr;
   13056:	210c      	movs	r1, #12
   13058:	68c7      	ldr	r7, [r0, #12]

    /* Verify the response. */
    if (rsp->bapc_handle != attr->handle) {
   1305a:	8810      	ldrh	r0, [r2, #0]

    if (proc->write_reliable.cur_attr >= proc->write_reliable.num_attrs) {
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    attr = proc->write_reliable.attrs + proc->write_reliable.cur_attr;
   1305c:	4369      	muls	r1, r5
   1305e:	187e      	adds	r6, r7, r1

    /* Verify the response. */
    if (rsp->bapc_handle != attr->handle) {
   13060:	5a79      	ldrh	r1, [r7, r1]
   13062:	4288      	cmp	r0, r1
   13064:	d114      	bne.n	13090 <ble_gattc_write_reliable_rx_prep+0x48>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    if (rsp->bapc_offset != 0) {
   13066:	8852      	ldrh	r2, [r2, #2]
   13068:	b992      	cbnz	r2, 13090 <ble_gattc_write_reliable_rx_prep+0x48>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    if (attr_len != attr->value_len) {
   1306a:	88b2      	ldrh	r2, [r6, #4]
   1306c:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   13070:	428a      	cmp	r2, r1
   13072:	d10d      	bne.n	13090 <ble_gattc_write_reliable_rx_prep+0x48>
        rc = BLE_HS_EBADDATA;
        goto err;
    }
    if (memcmp(attr_data, attr->value, attr_len) != 0) {
   13074:	68b1      	ldr	r1, [r6, #8]
   13076:	4618      	mov	r0, r3
   13078:	f7f5 ffb2 	bl	8fe0 <memcmp>
   1307c:	4606      	mov	r6, r0
   1307e:	b938      	cbnz	r0, 13090 <ble_gattc_write_reliable_rx_prep+0x48>
        rc = BLE_HS_EBADDATA;
        goto err;
    }

    /* Send follow-up request. */
    proc->write_reliable.cur_attr++;
   13080:	3501      	adds	r5, #1
   13082:	6165      	str	r5, [r4, #20]
    rc = ble_gattc_write_reliable_go(proc, 1);
   13084:	4620      	mov	r0, r4
   13086:	f7ff ffb8 	bl	12ffa <ble_gattc_write_reliable_go.constprop.12>
    if (rc != 0) {
   1308a:	4601      	mov	r1, r0
   1308c:	b908      	cbnz	r0, 13092 <ble_gattc_write_reliable_rx_prep+0x4a>
   1308e:	e005      	b.n	1309c <ble_gattc_write_reliable_rx_prep+0x54>
        rc = status;
        goto err;
    }

    if (proc->write_reliable.cur_attr >= proc->write_reliable.num_attrs) {
        rc = BLE_HS_EBADDATA;
   13090:	210a      	movs	r1, #10

    return 0;

err:
    /* XXX: Might need to cancel pending writes. */
    ble_gattc_write_reliable_cb(proc, rc, 0);
   13092:	4620      	mov	r0, r4
   13094:	2200      	movs	r2, #0
   13096:	f7ff fc0f 	bl	128b8 <ble_gattc_write_reliable_cb>
    return BLE_HS_EDONE;
   1309a:	260e      	movs	r6, #14
}
   1309c:	4630      	mov	r0, r6
   1309e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000130a0 <ble_gattc_fail_procs.constprop.13>:
/**
 * Causes all GATT procedures matching the specified criteria to fail with the
 * specified status code.
 */
static void
ble_gattc_fail_procs(uint16_t conn_handle, uint8_t op, int status)
   130a0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    struct ble_gattc_proc *next;

    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    STAILQ_INIT(dst_list);
   130a4:	ad02      	add	r5, sp, #8
   130a6:	2600      	movs	r6, #0
   130a8:	f845 6d08 	str.w	r6, [r5, #-8]!

    ble_hs_lock();

    prev = NULL;
    proc = STAILQ_FIRST(&ble_gattc_procs);
   130ac:	4c22      	ldr	r4, [pc, #136]	; (13138 <ble_gattc_fail_procs.constprop.13+0x98>)
    struct ble_gattc_proc *next;

    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    STAILQ_INIT(dst_list);
   130ae:	9501      	str	r5, [sp, #4]
/**
 * Causes all GATT procedures matching the specified criteria to fail with the
 * specified status code.
 */
static void
ble_gattc_fail_procs(uint16_t conn_handle, uint8_t op, int status)
   130b0:	4680      	mov	r8, r0
   130b2:	4689      	mov	r9, r1
    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    STAILQ_INIT(dst_list);

    ble_hs_lock();
   130b4:	f001 fb46 	bl	14744 <ble_hs_lock>

    prev = NULL;
    proc = STAILQ_FIRST(&ble_gattc_procs);
   130b8:	6823      	ldr	r3, [r4, #0]

    STAILQ_INIT(dst_list);

    ble_hs_lock();

    prev = NULL;
   130ba:	4632      	mov	r2, r6
    proc = STAILQ_FIRST(&ble_gattc_procs);
    while (proc != NULL) {
   130bc:	b1eb      	cbz	r3, 130fa <ble_gattc_fail_procs.constprop.13+0x5a>

static int
ble_gattc_conn_op_matches(struct ble_gattc_proc *proc, uint16_t conn_handle,
                          uint8_t op)
{
    if (conn_handle != BLE_HS_CONN_HANDLE_NONE &&
   130be:	f64f 71ff 	movw	r1, #65535	; 0xffff
   130c2:	4588      	cmp	r8, r1
    ble_hs_lock();

    prev = NULL;
    proc = STAILQ_FIRST(&ble_gattc_procs);
    while (proc != NULL) {
        next = STAILQ_NEXT(proc, next);
   130c4:	6818      	ldr	r0, [r3, #0]

static int
ble_gattc_conn_op_matches(struct ble_gattc_proc *proc, uint16_t conn_handle,
                          uint8_t op)
{
    if (conn_handle != BLE_HS_CONN_HANDLE_NONE &&
   130c6:	d002      	beq.n	130ce <ble_gattc_fail_procs.constprop.13+0x2e>
   130c8:	8919      	ldrh	r1, [r3, #8]
   130ca:	4541      	cmp	r1, r8
   130cc:	d112      	bne.n	130f4 <ble_gattc_fail_procs.constprop.13+0x54>
        conn_handle != proc->conn_handle) {

        return 0;
    }

    if (op != BLE_GATT_OP_NONE && op != proc->op) {
   130ce:	f1b9 0fff 	cmp.w	r9, #255	; 0xff
   130d2:	d002      	beq.n	130da <ble_gattc_fail_procs.constprop.13+0x3a>
   130d4:	7a99      	ldrb	r1, [r3, #10]
   130d6:	4549      	cmp	r1, r9
   130d8:	d10c      	bne.n	130f4 <ble_gattc_fail_procs.constprop.13+0x54>
    proc = STAILQ_FIRST(&ble_gattc_procs);
    while (proc != NULL) {
        next = STAILQ_NEXT(proc, next);

        if (ble_gattc_conn_op_matches(proc, conn_handle, op)) {
            if (prev == NULL) {
   130da:	bb1a      	cbnz	r2, 13124 <ble_gattc_fail_procs.constprop.13+0x84>
                STAILQ_REMOVE_HEAD(&ble_gattc_procs, next);
   130dc:	6821      	ldr	r1, [r4, #0]
   130de:	4e16      	ldr	r6, [pc, #88]	; (13138 <ble_gattc_fail_procs.constprop.13+0x98>)
   130e0:	680f      	ldr	r7, [r1, #0]
   130e2:	6027      	str	r7, [r4, #0]
   130e4:	b907      	cbnz	r7, 130e8 <ble_gattc_fail_procs.constprop.13+0x48>
   130e6:	6076      	str	r6, [r6, #4]
            } else {
                STAILQ_REMOVE_AFTER(&ble_gattc_procs, prev, next);
            }
            STAILQ_INSERT_TAIL(dst_list, proc, next);
   130e8:	2100      	movs	r1, #0
   130ea:	6019      	str	r1, [r3, #0]
   130ec:	9901      	ldr	r1, [sp, #4]
   130ee:	600b      	str	r3, [r1, #0]
   130f0:	9301      	str	r3, [sp, #4]
   130f2:	4613      	mov	r3, r2
   130f4:	461a      	mov	r2, r3
   130f6:	4603      	mov	r3, r0
   130f8:	e7e0      	b.n	130bc <ble_gattc_fail_procs.constprop.13+0x1c>
        }

        proc = next;
    }

    ble_hs_unlock();
   130fa:	f001 fb2b 	bl	14754 <ble_hs_unlock>
    ble_gattc_extract_by_conn_op(conn_handle, op, &temp_list);

    /* Notify application of failed procedures and free the corresponding proc
     * entries.
     */
    while ((proc = STAILQ_FIRST(&temp_list)) != NULL) {
   130fe:	9c00      	ldr	r4, [sp, #0]
   13100:	b1bc      	cbz	r4, 13132 <ble_gattc_fail_procs.constprop.13+0x92>
 */
static ble_gattc_err_fn *
ble_gattc_err_dispatch_get(uint8_t op)
{
    BLE_HS_DBG_ASSERT(op < BLE_GATT_OP_MAX);
    return ble_gattc_err_dispatch[op];
   13102:	7aa2      	ldrb	r2, [r4, #10]
    /* Notify application of failed procedures and free the corresponding proc
     * entries.
     */
    while ((proc = STAILQ_FIRST(&temp_list)) != NULL) {
        err_cb = ble_gattc_err_dispatch_get(proc->op);
        err_cb(proc, status, 0);
   13104:	4b0d      	ldr	r3, [pc, #52]	; (1313c <ble_gattc_fail_procs.constprop.13+0x9c>)
   13106:	4620      	mov	r0, r4
   13108:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1310c:	2107      	movs	r1, #7
   1310e:	2200      	movs	r2, #0
   13110:	4798      	blx	r3

        STAILQ_REMOVE_HEAD(&temp_list, next);
   13112:	9b00      	ldr	r3, [sp, #0]
   13114:	681b      	ldr	r3, [r3, #0]
   13116:	9300      	str	r3, [sp, #0]
   13118:	b903      	cbnz	r3, 1311c <ble_gattc_fail_procs.constprop.13+0x7c>
   1311a:	9501      	str	r5, [sp, #4]
        ble_gattc_proc_free(proc);
   1311c:	4620      	mov	r0, r4
   1311e:	f7ff fc4f 	bl	129c0 <ble_gattc_proc_free>
   13122:	e7ec      	b.n	130fe <ble_gattc_fail_procs.constprop.13+0x5e>

        if (ble_gattc_conn_op_matches(proc, conn_handle, op)) {
            if (prev == NULL) {
                STAILQ_REMOVE_HEAD(&ble_gattc_procs, next);
            } else {
                STAILQ_REMOVE_AFTER(&ble_gattc_procs, prev, next);
   13124:	6811      	ldr	r1, [r2, #0]
   13126:	680e      	ldr	r6, [r1, #0]
   13128:	6016      	str	r6, [r2, #0]
   1312a:	2e00      	cmp	r6, #0
   1312c:	d1dc      	bne.n	130e8 <ble_gattc_fail_procs.constprop.13+0x48>
   1312e:	6062      	str	r2, [r4, #4]
   13130:	e7da      	b.n	130e8 <ble_gattc_fail_procs.constprop.13+0x48>
        err_cb(proc, status, 0);

        STAILQ_REMOVE_HEAD(&temp_list, next);
        ble_gattc_proc_free(proc);
    }
}
   13132:	b003      	add	sp, #12
   13134:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13138:	200020c4 	.word	0x200020c4
   1313c:	0001f9bc 	.word	0x0001f9bc

00013140 <ble_gattc_heartbeat>:
 *                                  be called again; currently always
 *                                  UINT32_MAX.
 */
int32_t
ble_gattc_heartbeat(void)
{
   13140:	b573      	push	{r0, r1, r4, r5, r6, lr}

    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    now = os_time_get();
    STAILQ_INIT(dst_list);
   13142:	ad02      	add	r5, sp, #8
    int32_t time_diff;

    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    now = os_time_get();
   13144:	f7f7 fb3c 	bl	a7c0 <os_time_get>
    STAILQ_INIT(dst_list);
   13148:	2400      	movs	r4, #0
   1314a:	f845 4d08 	str.w	r4, [r5, #-8]!
    int32_t time_diff;

    /* Only the parent task is allowed to remove entries from the list. */
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());

    now = os_time_get();
   1314e:	4606      	mov	r6, r0
    STAILQ_INIT(dst_list);
   13150:	9501      	str	r5, [sp, #4]

    ble_hs_lock();
   13152:	f001 faf7 	bl	14744 <ble_hs_lock>

    prev = NULL;
    proc = STAILQ_FIRST(&ble_gattc_procs);
   13156:	491c      	ldr	r1, [pc, #112]	; (131c8 <ble_gattc_heartbeat+0x88>)
   13158:	680b      	ldr	r3, [r1, #0]
    now = os_time_get();
    STAILQ_INIT(dst_list);

    ble_hs_lock();

    prev = NULL;
   1315a:	4622      	mov	r2, r4
    proc = STAILQ_FIRST(&ble_gattc_procs);
    while (proc != NULL) {
   1315c:	b1cb      	cbz	r3, 13192 <ble_gattc_heartbeat+0x52>
        next = STAILQ_NEXT(proc, next);

        time_diff = now - proc->exp_os_ticks;
   1315e:	e893 0011 	ldmia.w	r3, {r0, r4}
   13162:	1b34      	subs	r4, r6, r4
        if (time_diff >= 0) {
   13164:	2c00      	cmp	r4, #0
   13166:	db11      	blt.n	1318c <ble_gattc_heartbeat+0x4c>
            if (prev == NULL) {
   13168:	b932      	cbnz	r2, 13178 <ble_gattc_heartbeat+0x38>
                STAILQ_REMOVE_HEAD(&ble_gattc_procs, next);
   1316a:	680c      	ldr	r4, [r1, #0]
   1316c:	4a16      	ldr	r2, [pc, #88]	; (131c8 <ble_gattc_heartbeat+0x88>)
   1316e:	6824      	ldr	r4, [r4, #0]
   13170:	600c      	str	r4, [r1, #0]
   13172:	b934      	cbnz	r4, 13182 <ble_gattc_heartbeat+0x42>
   13174:	6052      	str	r2, [r2, #4]
   13176:	e004      	b.n	13182 <ble_gattc_heartbeat+0x42>
            } else {
                STAILQ_REMOVE_AFTER(&ble_gattc_procs, prev, next);
   13178:	6814      	ldr	r4, [r2, #0]
   1317a:	6824      	ldr	r4, [r4, #0]
   1317c:	6014      	str	r4, [r2, #0]
   1317e:	b904      	cbnz	r4, 13182 <ble_gattc_heartbeat+0x42>
   13180:	604a      	str	r2, [r1, #4]
            }
            STAILQ_INSERT_TAIL(dst_list, proc, next);
   13182:	2200      	movs	r2, #0
   13184:	601a      	str	r2, [r3, #0]
   13186:	9a01      	ldr	r2, [sp, #4]
   13188:	6013      	str	r3, [r2, #0]
   1318a:	9301      	str	r3, [sp, #4]
 *                                  be called again; currently always
 *                                  UINT32_MAX.
 */
int32_t
ble_gattc_heartbeat(void)
{
   1318c:	461a      	mov	r2, r3
   1318e:	4603      	mov	r3, r0
   13190:	e7e4      	b.n	1315c <ble_gattc_heartbeat+0x1c>

        prev = proc;
        proc = next;
    }

    ble_hs_unlock();
   13192:	f001 fadf 	bl	14754 <ble_hs_unlock>
     * they can be retried.
     */
    ble_gattc_extract_expired(&exp_list);

    /* Terminate the connection associated with each timed-out procedure. */
    while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
   13196:	9c00      	ldr	r4, [sp, #0]
   13198:	b194      	cbz	r4, 131c0 <ble_gattc_heartbeat+0x80>
        STATS_INC(ble_gattc_stats, proc_timeout);
   1319a:	4a0c      	ldr	r2, [pc, #48]	; (131cc <ble_gattc_heartbeat+0x8c>)
        ble_gap_terminate(proc->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
   1319c:	8920      	ldrh	r0, [r4, #8]
     */
    ble_gattc_extract_expired(&exp_list);

    /* Terminate the connection associated with each timed-out procedure. */
    while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
        STATS_INC(ble_gattc_stats, proc_timeout);
   1319e:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
        ble_gap_terminate(proc->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
   131a2:	2113      	movs	r1, #19
     */
    ble_gattc_extract_expired(&exp_list);

    /* Terminate the connection associated with each timed-out procedure. */
    while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
        STATS_INC(ble_gattc_stats, proc_timeout);
   131a4:	3301      	adds	r3, #1
   131a6:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
        ble_gap_terminate(proc->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
   131aa:	f7fe ff77 	bl	1209c <ble_gap_terminate>

        STAILQ_REMOVE_HEAD(&exp_list, next);
   131ae:	9b00      	ldr	r3, [sp, #0]
   131b0:	681b      	ldr	r3, [r3, #0]
   131b2:	9300      	str	r3, [sp, #0]
   131b4:	b903      	cbnz	r3, 131b8 <ble_gattc_heartbeat+0x78>
   131b6:	9501      	str	r5, [sp, #4]
        ble_gattc_proc_free(proc);
   131b8:	4620      	mov	r0, r4
   131ba:	f7ff fc01 	bl	129c0 <ble_gattc_proc_free>
   131be:	e7ea      	b.n	13196 <ble_gattc_heartbeat+0x56>
    }

    return BLE_HS_FOREVER;
}
   131c0:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   131c4:	b002      	add	sp, #8
   131c6:	bd70      	pop	{r4, r5, r6, pc}
   131c8:	200020c4 	.word	0x200020c4
   131cc:	20003a50 	.word	0x20003a50

000131d0 <ble_gattc_notify_custom>:
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_notify_custom(uint16_t conn_handle, uint16_t chr_val_handle,
                        const void *attr_data, uint16_t attr_data_len)
{
   131d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    struct ble_att_svr_access_ctxt ctxt;
    struct ble_att_notify_req req;
    int rc;

    STATS_INC(ble_gattc_stats, notify);
   131d4:	4c19      	ldr	r4, [pc, #100]	; (1323c <ble_gattc_notify_custom+0x6c>)
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_notify_custom(uint16_t conn_handle, uint16_t chr_val_handle,
                        const void *attr_data, uint16_t attr_data_len)
{
   131d6:	4698      	mov	r8, r3

    struct ble_att_svr_access_ctxt ctxt;
    struct ble_att_notify_req req;
    int rc;

    STATS_INC(ble_gattc_stats, notify);
   131d8:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_notify_custom(uint16_t conn_handle, uint16_t chr_val_handle,
                        const void *attr_data, uint16_t attr_data_len)
{
   131dc:	b088      	sub	sp, #32
   131de:	460e      	mov	r6, r1

    struct ble_att_svr_access_ctxt ctxt;
    struct ble_att_notify_req req;
    int rc;

    STATS_INC(ble_gattc_stats, notify);
   131e0:	3301      	adds	r3, #1
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_notify_custom(uint16_t conn_handle, uint16_t chr_val_handle,
                        const void *attr_data, uint16_t attr_data_len)
{
   131e2:	4607      	mov	r7, r0
}

static void
ble_gattc_log_notify(uint16_t att_handle)
{
    ble_gattc_log_proc_init("notify; ");
   131e4:	4816      	ldr	r0, [pc, #88]	; (13240 <ble_gattc_notify_custom+0x70>)

    struct ble_att_svr_access_ctxt ctxt;
    struct ble_att_notify_req req;
    int rc;

    STATS_INC(ble_gattc_stats, notify);
   131e6:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_notify_custom(uint16_t conn_handle, uint16_t chr_val_handle,
                        const void *attr_data, uint16_t attr_data_len)
{
   131ea:	4615      	mov	r5, r2
}

static void
ble_gattc_log_notify(uint16_t att_handle)
{
    ble_gattc_log_proc_init("notify; ");
   131ec:	f7ff fc28 	bl	12a40 <ble_gattc_log_proc_init>
    BLE_HS_LOG(INFO, "att_handle=%d\n", att_handle);
   131f0:	9600      	str	r6, [sp, #0]
   131f2:	4814      	ldr	r0, [pc, #80]	; (13244 <ble_gattc_notify_custom+0x74>)
   131f4:	4b14      	ldr	r3, [pc, #80]	; (13248 <ble_gattc_notify_custom+0x78>)
   131f6:	2104      	movs	r1, #4
   131f8:	2201      	movs	r2, #1
   131fa:	f00a f815 	bl	1d228 <log_printf>

    STATS_INC(ble_gattc_stats, notify);

    ble_gattc_log_notify(chr_val_handle);

    if (attr_data == NULL) {
   131fe:	b955      	cbnz	r5, 13216 <ble_gattc_notify_custom+0x46>
        /* No custom attribute data; read the value from the specified
         * attribute.
         */
        rc = ble_att_svr_read_handle(BLE_HS_CONN_HANDLE_NONE,
   13200:	f64f 70ff 	movw	r0, #65535	; 0xffff
   13204:	4631      	mov	r1, r6
   13206:	aa04      	add	r2, sp, #16
   13208:	462b      	mov	r3, r5
   1320a:	f008 f95f 	bl	1b4cc <ble_att_svr_read_handle>
                                     chr_val_handle, &ctxt, NULL);
        if (rc != 0) {
   1320e:	b960      	cbnz	r0, 1322a <ble_gattc_notify_custom+0x5a>
            /* Fatal error; application disallowed attribute read. */
            rc = BLE_HS_EAPP;
            goto done;
        }

        attr_data = ctxt.read.data;
   13210:	9d06      	ldr	r5, [sp, #24]
        attr_data_len = ctxt.read.len;
   13212:	f8bd 801c 	ldrh.w	r8, [sp, #28]
    }

    req.banq_handle = chr_val_handle;
   13216:	a908      	add	r1, sp, #32
    rc = ble_att_clt_tx_notify(conn_handle, &req, attr_data, attr_data_len);
   13218:	4638      	mov	r0, r7

        attr_data = ctxt.read.data;
        attr_data_len = ctxt.read.len;
    }

    req.banq_handle = chr_val_handle;
   1321a:	f821 6d14 	strh.w	r6, [r1, #-20]!
    rc = ble_att_clt_tx_notify(conn_handle, &req, attr_data, attr_data_len);
   1321e:	462a      	mov	r2, r5
   13220:	4643      	mov	r3, r8
   13222:	f007 fc5f 	bl	1aae4 <ble_att_clt_tx_notify>
    if (rc != 0) {
   13226:	b908      	cbnz	r0, 1322c <ble_gattc_notify_custom+0x5c>
   13228:	e005      	b.n	13236 <ble_gattc_notify_custom+0x66>
         */
        rc = ble_att_svr_read_handle(BLE_HS_CONN_HANDLE_NONE,
                                     chr_val_handle, &ctxt, NULL);
        if (rc != 0) {
            /* Fatal error; application disallowed attribute read. */
            rc = BLE_HS_EAPP;
   1322a:	2009      	movs	r0, #9

    rc = 0;

done:
    if (rc != 0) {
        STATS_INC(ble_gattc_stats, notify_fail);
   1322c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   13230:	3301      	adds	r3, #1
   13232:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    }

    return rc;
}
   13236:	b008      	add	sp, #32
   13238:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1323c:	20003a50 	.word	0x20003a50
   13240:	0001f958 	.word	0x0001f958
   13244:	20003b9c 	.word	0x20003b9c
   13248:	0001f8bf 	.word	0x0001f8bf

0001324c <ble_gattc_notify>:
    return BLE_HS_ENOTSUP;
#endif

    int rc;

    rc = ble_gattc_notify_custom(conn_handle, chr_val_handle, NULL, 0);
   1324c:	2200      	movs	r2, #0
 *
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_notify(uint16_t conn_handle, uint16_t chr_val_handle)
{
   1324e:	b570      	push	{r4, r5, r6, lr}
    return BLE_HS_ENOTSUP;
#endif

    int rc;

    rc = ble_gattc_notify_custom(conn_handle, chr_val_handle, NULL, 0);
   13250:	4613      	mov	r3, r2
 *
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_notify(uint16_t conn_handle, uint16_t chr_val_handle)
{
   13252:	460d      	mov	r5, r1
   13254:	4606      	mov	r6, r0
    return BLE_HS_ENOTSUP;
#endif

    int rc;

    rc = ble_gattc_notify_custom(conn_handle, chr_val_handle, NULL, 0);
   13256:	f7ff ffbb 	bl	131d0 <ble_gattc_notify_custom>

    /* Tell the application that a notification transmission was attempted. */
    ble_gap_notify_tx_event(rc, conn_handle, chr_val_handle, 0);
   1325a:	4631      	mov	r1, r6
    return BLE_HS_ENOTSUP;
#endif

    int rc;

    rc = ble_gattc_notify_custom(conn_handle, chr_val_handle, NULL, 0);
   1325c:	4604      	mov	r4, r0

    /* Tell the application that a notification transmission was attempted. */
    ble_gap_notify_tx_event(rc, conn_handle, chr_val_handle, 0);
   1325e:	462a      	mov	r2, r5
   13260:	2300      	movs	r3, #0
   13262:	f7ff f8a2 	bl	123aa <ble_gap_notify_tx_event>

    return rc;
}
   13266:	4620      	mov	r0, r4
   13268:	bd70      	pop	{r4, r5, r6, pc}

0001326a <ble_gatts_indicate_fail_notconn>:
 * fail with a status code of BLE_HS_ENOTCONN;
 */
void
ble_gatts_indicate_fail_notconn(uint16_t conn_handle)
{
    ble_gattc_fail_procs(conn_handle, BLE_GATT_OP_INDICATE, BLE_HS_ENOTCONN);
   1326a:	210e      	movs	r1, #14
   1326c:	f7ff bf18 	b.w	130a0 <ble_gattc_fail_procs.constprop.13>

00013270 <ble_gattc_indicate>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_indicate(uint16_t conn_handle, uint16_t chr_val_handle)
{
   13270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    struct ble_att_indicate_req req;
    struct ble_gattc_proc *proc;
    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gattc_stats, indicate);
   13274:	4c28      	ldr	r4, [pc, #160]	; (13318 <ble_gattc_indicate+0xa8>)
   13276:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 *
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_indicate(uint16_t conn_handle, uint16_t chr_val_handle)
{
   1327a:	b088      	sub	sp, #32
    struct ble_att_indicate_req req;
    struct ble_gattc_proc *proc;
    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gattc_stats, indicate);
   1327c:	3301      	adds	r3, #1
 *
 * @return                      0 on success; nonzero on failure.
 */
int
ble_gattc_indicate(uint16_t conn_handle, uint16_t chr_val_handle)
{
   1327e:	4680      	mov	r8, r0
   13280:	460e      	mov	r6, r1
    struct ble_att_indicate_req req;
    struct ble_gattc_proc *proc;
    struct ble_hs_conn *conn;
    int rc;

    STATS_INC(ble_gattc_stats, indicate);
   13282:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c

    proc = ble_gattc_proc_alloc();
   13286:	f7ff fba3 	bl	129d0 <ble_gattc_proc_alloc>
   1328a:	4625      	mov	r5, r4
    if (proc == NULL) {
   1328c:	4607      	mov	r7, r0
   1328e:	b360      	cbz	r0, 132ea <ble_gattc_indicate+0x7a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    proc->op = BLE_GATT_OP_INDICATE;
   13290:	230e      	movs	r3, #14
   13292:	7283      	strb	r3, [r0, #10]
    proc->conn_handle = conn_handle;
   13294:	f8a0 8008 	strh.w	r8, [r0, #8]
    proc->indicate.chr_val_handle = chr_val_handle;
   13298:	8186      	strh	r6, [r0, #12]
}

static void
ble_gattc_log_indicate(uint16_t att_handle)
{
    ble_gattc_log_proc_init("indicate; ");
   1329a:	4820      	ldr	r0, [pc, #128]	; (1331c <ble_gattc_indicate+0xac>)
   1329c:	f7ff fbd0 	bl	12a40 <ble_gattc_log_proc_init>
    BLE_HS_LOG(INFO, "att_handle=%d\n", att_handle);
   132a0:	481f      	ldr	r0, [pc, #124]	; (13320 <ble_gattc_indicate+0xb0>)
   132a2:	4b20      	ldr	r3, [pc, #128]	; (13324 <ble_gattc_indicate+0xb4>)
   132a4:	9600      	str	r6, [sp, #0]
   132a6:	2104      	movs	r1, #4
   132a8:	2201      	movs	r2, #1
   132aa:	f009 ffbd 	bl	1d228 <log_printf>
    proc->conn_handle = conn_handle;
    proc->indicate.chr_val_handle = chr_val_handle;

    ble_gattc_log_indicate(chr_val_handle);

    rc = ble_att_svr_read_handle(BLE_HS_CONN_HANDLE_NONE, chr_val_handle,
   132ae:	f64f 70ff 	movw	r0, #65535	; 0xffff
   132b2:	4631      	mov	r1, r6
   132b4:	aa04      	add	r2, sp, #16
   132b6:	2300      	movs	r3, #0
   132b8:	f008 f908 	bl	1b4cc <ble_att_svr_read_handle>
                                 &ctxt, NULL);
    if (rc != 0) {
   132bc:	b9b8      	cbnz	r0, 132ee <ble_gattc_indicate+0x7e>
        BLE_HS_DBG_ASSERT(0);
        rc = BLE_HS_EAPP;
        goto done;
    }

    req.baiq_handle = chr_val_handle;
   132be:	a908      	add	r1, sp, #32
    rc = ble_att_clt_tx_indicate(conn_handle, &req,
   132c0:	4640      	mov	r0, r8
        BLE_HS_DBG_ASSERT(0);
        rc = BLE_HS_EAPP;
        goto done;
    }

    req.baiq_handle = chr_val_handle;
   132c2:	f821 6d14 	strh.w	r6, [r1, #-20]!
    rc = ble_att_clt_tx_indicate(conn_handle, &req,
   132c6:	9a06      	ldr	r2, [sp, #24]
   132c8:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   132cc:	f007 fc5c 	bl	1ab88 <ble_att_clt_tx_indicate>
                                 ctxt.read.data, ctxt.read.len);

    if (rc != 0) {
   132d0:	4604      	mov	r4, r0
   132d2:	b968      	cbnz	r0, 132f0 <ble_gattc_indicate+0x80>
        goto done;
    }

    ble_hs_lock();
   132d4:	f001 fa36 	bl	14744 <ble_hs_lock>
    conn = ble_hs_conn_find(conn_handle);
   132d8:	4640      	mov	r0, r8
   132da:	f001 ffdb 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   132de:	b108      	cbz	r0, 132e4 <ble_gattc_indicate+0x74>
        BLE_HS_DBG_ASSERT(conn->bhc_gatt_svr.indicate_val_handle == 0);
        conn->bhc_gatt_svr.indicate_val_handle = chr_val_handle;
   132e0:	f8a0 6040 	strh.w	r6, [r0, #64]	; 0x40
    }
    ble_hs_unlock();
   132e4:	f001 fa36 	bl	14754 <ble_hs_unlock>
   132e8:	e007      	b.n	132fa <ble_gattc_indicate+0x8a>

    STATS_INC(ble_gattc_stats, indicate);

    proc = ble_gattc_proc_alloc();
    if (proc == NULL) {
        rc = BLE_HS_ENOMEM;
   132ea:	2406      	movs	r4, #6
   132ec:	e000      	b.n	132f0 <ble_gattc_indicate+0x80>
    rc = ble_att_svr_read_handle(BLE_HS_CONN_HANDLE_NONE, chr_val_handle,
                                 &ctxt, NULL);
    if (rc != 0) {
        /* Fatal error; application disallowed attribute read. */
        BLE_HS_DBG_ASSERT(0);
        rc = BLE_HS_EAPP;
   132ee:	2409      	movs	r4, #9
    ble_hs_unlock();


done:
    if (rc != 0) {
        STATS_INC(ble_gattc_stats, indicate_fail);
   132f0:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   132f4:	3301      	adds	r3, #1
   132f6:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
    }

    /* Tell the application that an indication transmission was attempted. */
    ble_gap_notify_tx_event(rc, conn_handle, chr_val_handle, 1);
   132fa:	4620      	mov	r0, r4
   132fc:	4641      	mov	r1, r8
   132fe:	4632      	mov	r2, r6
   13300:	2301      	movs	r3, #1
   13302:	f7ff f852 	bl	123aa <ble_gap_notify_tx_event>

    ble_gattc_process_status(proc, rc);
   13306:	4638      	mov	r0, r7
   13308:	4621      	mov	r1, r4
   1330a:	f7ff fd9b 	bl	12e44 <ble_gattc_process_status>
    return rc;
}
   1330e:	4620      	mov	r0, r4
   13310:	b008      	add	sp, #32
   13312:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13316:	bf00      	nop
   13318:	20003a50 	.word	0x20003a50
   1331c:	0001f961 	.word	0x0001f961
   13320:	20003b9c 	.word	0x20003b9c
   13324:	0001f8bf 	.word	0x0001f8bf

00013328 <ble_gattc_rx_err>:
 * Dispatches an incoming ATT error-response to the appropriate active GATT
 * procedure.
 */
void
ble_gattc_rx_err(uint16_t conn_handle, struct ble_att_error_rsp *rsp)
{
   13328:	b538      	push	{r3, r4, r5, lr}
   1332a:	460d      	mov	r5, r1
    struct ble_gattc_proc *proc;
    ble_gattc_err_fn *err_cb;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_NONE);
   1332c:	21ff      	movs	r1, #255	; 0xff
   1332e:	f7ff fae9 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   13332:	4604      	mov	r4, r0
   13334:	b178      	cbz	r0, 13356 <ble_gattc_rx_err+0x2e>
 */
static ble_gattc_err_fn *
ble_gattc_err_dispatch_get(uint8_t op)
{
    BLE_HS_DBG_ASSERT(op < BLE_GATT_OP_MAX);
    return ble_gattc_err_dispatch[op];
   13336:	7a82      	ldrb	r2, [r0, #10]
   13338:	4b07      	ldr	r3, [pc, #28]	; (13358 <ble_gattc_rx_err+0x30>)
   1333a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    ble_gattc_err_fn *err_cb;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_NONE);
    if (proc != NULL) {
        err_cb = ble_gattc_err_dispatch_get(proc->op);
        if (err_cb != NULL) {
   1333e:	b12b      	cbz	r3, 1334c <ble_gattc_rx_err+0x24>
            err_cb(proc, BLE_HS_ERR_ATT_BASE + rsp->baep_error_code,
   13340:	78e9      	ldrb	r1, [r5, #3]
   13342:	f8b5 2001 	ldrh.w	r2, [r5, #1]
   13346:	f501 7180 	add.w	r1, r1, #256	; 0x100
   1334a:	4798      	blx	r3
                   rsp->baep_handle);
        }
        ble_gattc_proc_free(proc);
   1334c:	4620      	mov	r0, r4
    }
}
   1334e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        err_cb = ble_gattc_err_dispatch_get(proc->op);
        if (err_cb != NULL) {
            err_cb(proc, BLE_HS_ERR_ATT_BASE + rsp->baep_error_code,
                   rsp->baep_handle);
        }
        ble_gattc_proc_free(proc);
   13352:	f7ff bb35 	b.w	129c0 <ble_gattc_proc_free>
   13356:	bd38      	pop	{r3, r4, r5, pc}
   13358:	0001f9bc 	.word	0x0001f9bc

0001335c <ble_gattc_rx_mtu>:
 * Dispatches an incoming ATT exchange-mtu-response to the appropriate active
 * GATT procedure.
 */
void
ble_gattc_rx_mtu(uint16_t conn_handle, int status, uint16_t chan_mtu)
{
   1335c:	b570      	push	{r4, r5, r6, lr}
   1335e:	460e      	mov	r6, r1
    struct ble_gattc_proc *proc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_MTU);
   13360:	2100      	movs	r1, #0
 * Dispatches an incoming ATT exchange-mtu-response to the appropriate active
 * GATT procedure.
 */
void
ble_gattc_rx_mtu(uint16_t conn_handle, int status, uint16_t chan_mtu)
{
   13362:	4615      	mov	r5, r2
    struct ble_gattc_proc *proc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_MTU);
   13364:	f7ff face 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   13368:	4604      	mov	r4, r0
   1336a:	b148      	cbz	r0, 13380 <ble_gattc_rx_mtu+0x24>
        ble_gattc_mtu_cb(proc, status, 0, chan_mtu);
   1336c:	4631      	mov	r1, r6
   1336e:	462b      	mov	r3, r5
   13370:	2200      	movs	r2, #0
   13372:	f7ff f89f 	bl	124b4 <ble_gattc_mtu_cb>
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   13376:	4620      	mov	r0, r4
    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_MTU);
    if (proc != NULL) {
        ble_gattc_mtu_cb(proc, status, 0, chan_mtu);
        ble_gattc_process_status(proc, BLE_HS_EDONE);
    }
}
   13378:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   1337c:	f7ff bb20 	b.w	129c0 <ble_gattc_proc_free>
   13380:	bd70      	pop	{r4, r5, r6, pc}

00013382 <ble_gattc_rx_find_info_idata>:
 * find-information-response to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_find_info_idata(uint16_t conn_handle,
                             struct ble_att_find_info_idata *idata)
{
   13382:	b570      	push	{r4, r5, r6, lr}
   13384:	460d      	mov	r5, r1
   13386:	b086      	sub	sp, #24
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_DSCS);
   13388:	2106      	movs	r1, #6
   1338a:	f7ff fabb 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   1338e:	4604      	mov	r4, r0
   13390:	b330      	cbz	r0, 133e0 <ble_gattc_rx_find_info_idata+0x5e>
    int cbrc;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (idata->attr_handle <= proc->disc_all_dscs.prev_handle) {
   13392:	882b      	ldrh	r3, [r5, #0]
   13394:	89c2      	ldrh	r2, [r0, #14]
   13396:	429a      	cmp	r2, r3
        /* Peer sent descriptors out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
        goto done;
    }
    proc->disc_all_dscs.prev_handle = idata->attr_handle;
   13398:	bf38      	it	cc
   1339a:	81c3      	strhcc	r3, [r0, #14]

    rc = 0;

done:
    dsc.handle = idata->attr_handle;
   1339c:	462b      	mov	r3, r5
        rc = BLE_HS_EBADDATA;
        goto done;
    }
    proc->disc_all_dscs.prev_handle = idata->attr_handle;

    rc = 0;
   1339e:	bf38      	it	cc
   133a0:	2600      	movcc	r6, #0

done:
    dsc.handle = idata->attr_handle;
   133a2:	f833 2b02 	ldrh.w	r2, [r3], #2
   133a6:	f8ad 2004 	strh.w	r2, [sp, #4]

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (idata->attr_handle <= proc->disc_all_dscs.prev_handle) {
        /* Peer sent descriptors out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
   133aa:	bf28      	it	cs
   133ac:	260a      	movcs	r6, #10

    rc = 0;

done:
    dsc.handle = idata->attr_handle;
    memcpy(dsc.uuid128, idata->uuid128, 16);
   133ae:	f10d 0206 	add.w	r2, sp, #6
   133b2:	3512      	adds	r5, #18
   133b4:	f853 1b04 	ldr.w	r1, [r3], #4
   133b8:	f842 1b04 	str.w	r1, [r2], #4
   133bc:	42ab      	cmp	r3, r5
   133be:	d1f9      	bne.n	133b4 <ble_gattc_rx_find_info_idata+0x32>

    cbrc = ble_gattc_disc_all_dscs_cb(proc, rc, 0, &dsc);
   133c0:	4620      	mov	r0, r4
   133c2:	4631      	mov	r1, r6
   133c4:	2200      	movs	r2, #0
   133c6:	ab01      	add	r3, sp, #4
   133c8:	f7ff f962 	bl	12690 <ble_gattc_disc_all_dscs_cb>
    if (rc != 0 || cbrc != 0) {
   133cc:	b926      	cbnz	r6, 133d8 <ble_gattc_rx_find_info_idata+0x56>
        return BLE_HS_EDONE;
    } else {
        return 0;
   133ce:	2800      	cmp	r0, #0
   133d0:	bf14      	ite	ne
   133d2:	210e      	movne	r1, #14
   133d4:	2100      	moveq	r1, #0
   133d6:	e000      	b.n	133da <ble_gattc_rx_find_info_idata+0x58>
    dsc.handle = idata->attr_handle;
    memcpy(dsc.uuid128, idata->uuid128, 16);

    cbrc = ble_gattc_disc_all_dscs_cb(proc, rc, 0, &dsc);
    if (rc != 0 || cbrc != 0) {
        return BLE_HS_EDONE;
   133d8:	210e      	movs	r1, #14
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_DSCS);
    if (proc != NULL) {
        rc = ble_gattc_disc_all_dscs_rx_idata(proc, idata);
        ble_gattc_process_status(proc, rc);
   133da:	4620      	mov	r0, r4
   133dc:	f7ff fd32 	bl	12e44 <ble_gattc_process_status>
    }
}
   133e0:	b006      	add	sp, #24
   133e2:	bd70      	pop	{r4, r5, r6, pc}

000133e4 <ble_gattc_rx_find_info_complete>:
 * Dispatches an incoming notification of the end of a
 * find-information-response to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_find_info_complete(uint16_t conn_handle, int status)
{
   133e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   133e6:	460d      	mov	r5, r1
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_DSCS);
   133e8:	2106      	movs	r1, #6
   133ea:	f7ff fa8b 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   133ee:	4604      	mov	r4, r0
   133f0:	b1e8      	cbz	r0, 1342e <ble_gattc_rx_find_info_complete+0x4a>
{
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   133f2:	b115      	cbz	r5, 133fa <ble_gattc_rx_find_info_complete+0x16>
        ble_gattc_disc_all_dscs_cb(proc, status, 0, NULL);
   133f4:	4629      	mov	r1, r5
   133f6:	2200      	movs	r2, #0
   133f8:	e012      	b.n	13420 <ble_gattc_rx_find_info_complete+0x3c>
        return BLE_HS_EDONE;
    }

    if (proc->disc_all_dscs.prev_handle == proc->disc_all_dscs.end_handle) {
   133fa:	89c3      	ldrh	r3, [r0, #14]
   133fc:	8a02      	ldrh	r2, [r0, #16]
   133fe:	4293      	cmp	r3, r2
   13400:	d101      	bne.n	13406 <ble_gattc_rx_find_info_complete+0x22>
        /* All descriptors discovered. */
        ble_gattc_disc_all_dscs_cb(proc, BLE_HS_EDONE, 0, NULL);
   13402:	210e      	movs	r1, #14
   13404:	e00b      	b.n	1341e <ble_gattc_rx_find_info_complete+0x3a>
    struct ble_att_find_info_req req;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    req.bafq_start_handle = proc->disc_all_dscs.prev_handle + 1;
   13406:	3301      	adds	r3, #1
    req.bafq_end_handle = proc->disc_all_dscs.end_handle;

    rc = ble_att_clt_tx_find_info(proc->conn_handle, &req);
   13408:	a901      	add	r1, sp, #4
   1340a:	8900      	ldrh	r0, [r0, #8]
    struct ble_att_find_info_req req;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    req.bafq_start_handle = proc->disc_all_dscs.prev_handle + 1;
   1340c:	f8ad 3004 	strh.w	r3, [sp, #4]
    req.bafq_end_handle = proc->disc_all_dscs.end_handle;
   13410:	f8ad 2006 	strh.w	r2, [sp, #6]

    rc = ble_att_clt_tx_find_info(proc->conn_handle, &req);
   13414:	f006 fe26 	bl	1a064 <ble_att_clt_tx_find_info>
    if (rc != 0) {
   13418:	4601      	mov	r1, r0
   1341a:	b128      	cbz	r0, 13428 <ble_gattc_rx_find_info_complete+0x44>
        if (cb_on_err) {
            ble_gattc_disc_all_dscs_cb(proc, rc, 0, NULL);
   1341c:	4620      	mov	r0, r4
   1341e:	462a      	mov	r2, r5
   13420:	4613      	mov	r3, r2
   13422:	f7ff f935 	bl	12690 <ble_gattc_disc_all_dscs_cb>
    }

    /* Send follow-up request. */
    rc = ble_gattc_disc_all_dscs_go(proc, 1);
    if (rc != 0) {
        return BLE_HS_EDONE;
   13426:	210e      	movs	r1, #14
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_DSCS);
    if (proc != NULL) {
        rc = ble_gattc_disc_all_dscs_rx_complete(proc, status);
        ble_gattc_process_status(proc, rc);
   13428:	4620      	mov	r0, r4
   1342a:	f7ff fd0b 	bl	12e44 <ble_gattc_process_status>
    }
}
   1342e:	b003      	add	sp, #12
   13430:	bd30      	pop	{r4, r5, pc}

00013432 <ble_gattc_rx_find_type_value_hinfo>:
 * find-by-type-value-response to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_find_type_value_hinfo(uint16_t conn_handle,
                                   struct ble_att_find_type_value_hinfo *hinfo)
{
   13432:	b570      	push	{r4, r5, r6, lr}
   13434:	460d      	mov	r5, r1
   13436:	b086      	sub	sp, #24
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_SVC_UUID);
   13438:	2102      	movs	r1, #2
   1343a:	f7ff fa63 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   1343e:	4604      	mov	r4, r0
   13440:	b350      	cbz	r0, 13498 <ble_gattc_rx_find_type_value_hinfo+0x66>
    int cbrc;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (hinfo->group_end_handle <= proc->disc_svc_uuid.prev_handle) {
   13442:	886b      	ldrh	r3, [r5, #2]
   13444:	8b82      	ldrh	r2, [r0, #28]
   13446:	429a      	cmp	r2, r3
   13448:	d215      	bcs.n	13476 <ble_gattc_rx_find_type_value_hinfo+0x44>
        /* Peer sent services out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    proc->disc_svc_uuid.prev_handle = hinfo->group_end_handle;
   1344a:	8383      	strh	r3, [r0, #28]

    service.start_handle = hinfo->attr_handle;
   1344c:	882b      	ldrh	r3, [r5, #0]
   1344e:	f8ad 3004 	strh.w	r3, [sp, #4]
    service.end_handle = hinfo->group_end_handle;
   13452:	886b      	ldrh	r3, [r5, #2]
   13454:	f8ad 3006 	strh.w	r3, [sp, #6]
    memcpy(service.uuid128, proc->disc_svc_uuid.service_uuid, 16);
   13458:	ad02      	add	r5, sp, #8
   1345a:	f100 030c 	add.w	r3, r0, #12
   1345e:	f100 061c 	add.w	r6, r0, #28
   13462:	6818      	ldr	r0, [r3, #0]
   13464:	6859      	ldr	r1, [r3, #4]
   13466:	462a      	mov	r2, r5
   13468:	c203      	stmia	r2!, {r0, r1}
   1346a:	3308      	adds	r3, #8
   1346c:	42b3      	cmp	r3, r6
   1346e:	4615      	mov	r5, r2
   13470:	d1f7      	bne.n	13462 <ble_gattc_rx_find_type_value_hinfo+0x30>

    rc = 0;
   13472:	2500      	movs	r5, #0
   13474:	e000      	b.n	13478 <ble_gattc_rx_find_type_value_hinfo+0x46>

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (hinfo->group_end_handle <= proc->disc_svc_uuid.prev_handle) {
        /* Peer sent services out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
   13476:	250a      	movs	r5, #10
    memcpy(service.uuid128, proc->disc_svc_uuid.service_uuid, 16);

    rc = 0;

done:
    cbrc = ble_gattc_disc_svc_uuid_cb(proc, rc, 0, &service);
   13478:	4620      	mov	r0, r4
   1347a:	4629      	mov	r1, r5
   1347c:	2200      	movs	r2, #0
   1347e:	ab01      	add	r3, sp, #4
   13480:	f7ff f864 	bl	1254c <ble_gattc_disc_svc_uuid_cb>
    if (rc != 0 || cbrc != 0) {
   13484:	b925      	cbnz	r5, 13490 <ble_gattc_rx_find_type_value_hinfo+0x5e>
        return BLE_HS_EDONE;
    } else {
        return 0;
   13486:	2800      	cmp	r0, #0
   13488:	bf14      	ite	ne
   1348a:	210e      	movne	r1, #14
   1348c:	2100      	moveq	r1, #0
   1348e:	e000      	b.n	13492 <ble_gattc_rx_find_type_value_hinfo+0x60>
    rc = 0;

done:
    cbrc = ble_gattc_disc_svc_uuid_cb(proc, rc, 0, &service);
    if (rc != 0 || cbrc != 0) {
        return BLE_HS_EDONE;
   13490:	210e      	movs	r1, #14
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_SVC_UUID);
    if (proc != NULL) {
        rc = ble_gattc_disc_svc_uuid_rx_hinfo(proc, hinfo);
        ble_gattc_process_status(proc, rc);
   13492:	4620      	mov	r0, r4
   13494:	f7ff fcd6 	bl	12e44 <ble_gattc_process_status>
    }
}
   13498:	b006      	add	sp, #24
   1349a:	bd70      	pop	{r4, r5, r6, pc}

0001349c <ble_gattc_rx_find_type_value_complete>:
 * Dispatches an incoming notification of the end of a
 * find-by-type-value-response to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_find_type_value_complete(uint16_t conn_handle, int status)
{
   1349c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1349e:	460d      	mov	r5, r1
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_SVC_UUID);
   134a0:	2102      	movs	r1, #2
   134a2:	f7ff fa2f 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   134a6:	4604      	mov	r4, r0
   134a8:	b328      	cbz	r0, 134f6 <ble_gattc_rx_find_type_value_complete+0x5a>
{
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   134aa:	b115      	cbz	r5, 134b2 <ble_gattc_rx_find_type_value_complete+0x16>
        ble_gattc_disc_svc_uuid_cb(proc, status, 0, NULL);
   134ac:	4629      	mov	r1, r5
   134ae:	2200      	movs	r2, #0
   134b0:	e01a      	b.n	134e8 <ble_gattc_rx_find_type_value_complete+0x4c>
        return BLE_HS_EDONE;
    }

    if (proc->disc_svc_uuid.prev_handle == 0xffff) {
   134b2:	8b83      	ldrh	r3, [r0, #28]
   134b4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   134b8:	4293      	cmp	r3, r2
   134ba:	d101      	bne.n	134c0 <ble_gattc_rx_find_type_value_complete+0x24>
        /* Service discovery complete. */
        ble_gattc_disc_svc_uuid_cb(proc, BLE_HS_EDONE, 0, NULL);
   134bc:	210e      	movs	r1, #14
   134be:	e012      	b.n	134e6 <ble_gattc_rx_find_type_value_complete+0x4a>
    struct ble_att_find_type_value_req req;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    req.bavq_start_handle = proc->disc_svc_uuid.prev_handle + 1;
   134c0:	3301      	adds	r3, #1
   134c2:	f8ad 3000 	strh.w	r3, [sp]
    req.bavq_end_handle = 0xffff;
    req.bavq_attr_type = BLE_ATT_UUID_PRIMARY_SERVICE;
   134c6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    req.bavq_start_handle = proc->disc_svc_uuid.prev_handle + 1;
    req.bavq_end_handle = 0xffff;
   134ca:	f8ad 2002 	strh.w	r2, [sp, #2]
    req.bavq_attr_type = BLE_ATT_UUID_PRIMARY_SERVICE;
   134ce:	f8ad 3004 	strh.w	r3, [sp, #4]

    rc = ble_att_clt_tx_find_type_value(proc->conn_handle, &req,
   134d2:	4669      	mov	r1, sp
   134d4:	8900      	ldrh	r0, [r0, #8]
   134d6:	f104 020c 	add.w	r2, r4, #12
   134da:	2310      	movs	r3, #16
   134dc:	f006 fe7a 	bl	1a1d4 <ble_att_clt_tx_find_type_value>
                                        proc->disc_svc_uuid.service_uuid, 16);
    if (rc != 0) {
   134e0:	4601      	mov	r1, r0
   134e2:	b128      	cbz	r0, 134f0 <ble_gattc_rx_find_type_value_complete+0x54>
        if (cb_on_err) {
            ble_gattc_disc_svc_uuid_cb(proc, rc, 0, NULL);
   134e4:	4620      	mov	r0, r4
   134e6:	462a      	mov	r2, r5
   134e8:	4613      	mov	r3, r2
   134ea:	f7ff f82f 	bl	1254c <ble_gattc_disc_svc_uuid_cb>
    }

    /* Send follow-up request. */
    rc = ble_gattc_disc_svc_uuid_go(proc, 1);
    if (rc != 0) {
        return BLE_HS_EDONE;
   134ee:	210e      	movs	r1, #14
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_SVC_UUID);
    if (proc != NULL) {
        rc = ble_gattc_disc_svc_uuid_rx_complete(proc, status);
        ble_gattc_process_status(proc, rc);
   134f0:	4620      	mov	r0, r4
   134f2:	f7ff fca7 	bl	12e44 <ble_gattc_process_status>
    }
}
   134f6:	b003      	add	sp, #12
   134f8:	bd30      	pop	{r4, r5, pc}
	...

000134fc <ble_gattc_rx_read_type_adata>:
 * to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_read_type_adata(uint16_t conn_handle,
                             struct ble_att_read_type_adata *adata)
{
   134fc:	b537      	push	{r0, r1, r2, r4, r5, lr}

    const struct ble_gattc_rx_adata_entry *rx_entry;
    struct ble_gattc_proc *proc;
    int rc;

    proc = BLE_GATTC_RX_EXTRACT_RX_ENTRY(conn_handle,
   134fe:	2204      	movs	r2, #4
 * to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_read_type_adata(uint16_t conn_handle,
                             struct ble_att_read_type_adata *adata)
{
   13500:	460d      	mov	r5, r1

    const struct ble_gattc_rx_adata_entry *rx_entry;
    struct ble_gattc_proc *proc;
    int rc;

    proc = BLE_GATTC_RX_EXTRACT_RX_ENTRY(conn_handle,
   13502:	eb0d 0302 	add.w	r3, sp, r2
   13506:	4907      	ldr	r1, [pc, #28]	; (13524 <ble_gattc_rx_read_type_adata+0x28>)
   13508:	f7ff fa24 	bl	12954 <ble_gattc_extract_with_rx_entry>
                                         ble_gattc_rx_read_type_elem_entries,
                                         &rx_entry);
    if (proc != NULL) {
   1350c:	4604      	mov	r4, r0
   1350e:	b138      	cbz	r0, 13520 <ble_gattc_rx_read_type_adata+0x24>
        rc = rx_entry->cb(proc, adata);
   13510:	9b01      	ldr	r3, [sp, #4]
   13512:	4629      	mov	r1, r5
   13514:	685b      	ldr	r3, [r3, #4]
   13516:	4798      	blx	r3
   13518:	4601      	mov	r1, r0
        ble_gattc_process_status(proc, rc);
   1351a:	4620      	mov	r0, r4
   1351c:	f7ff fc92 	bl	12e44 <ble_gattc_process_status>
    }
}
   13520:	b003      	add	sp, #12
   13522:	bd30      	pop	{r4, r5, pc}
   13524:	0001f708 	.word	0x0001f708

00013528 <ble_gattc_rx_read_type_complete>:
 * Dispatches an incoming notification of the end of a read-by-type-response to
 * the appropriate active GATT procedure.
 */
void
ble_gattc_rx_read_type_complete(uint16_t conn_handle, int status)
{
   13528:	b537      	push	{r0, r1, r2, r4, r5, lr}

    const struct ble_gattc_rx_complete_entry *rx_entry;
    struct ble_gattc_proc *proc;
    int rc;

    proc = BLE_GATTC_RX_EXTRACT_RX_ENTRY(
   1352a:	2204      	movs	r2, #4
 * Dispatches an incoming notification of the end of a read-by-type-response to
 * the appropriate active GATT procedure.
 */
void
ble_gattc_rx_read_type_complete(uint16_t conn_handle, int status)
{
   1352c:	460d      	mov	r5, r1

    const struct ble_gattc_rx_complete_entry *rx_entry;
    struct ble_gattc_proc *proc;
    int rc;

    proc = BLE_GATTC_RX_EXTRACT_RX_ENTRY(
   1352e:	eb0d 0302 	add.w	r3, sp, r2
   13532:	4907      	ldr	r1, [pc, #28]	; (13550 <ble_gattc_rx_read_type_complete+0x28>)
   13534:	f7ff fa0e 	bl	12954 <ble_gattc_extract_with_rx_entry>
        conn_handle, ble_gattc_rx_read_type_complete_entries,
        &rx_entry);
    if (proc != NULL) {
   13538:	4604      	mov	r4, r0
   1353a:	b138      	cbz	r0, 1354c <ble_gattc_rx_read_type_complete+0x24>
        rc = rx_entry->cb(proc, status);
   1353c:	9b01      	ldr	r3, [sp, #4]
   1353e:	4629      	mov	r1, r5
   13540:	685b      	ldr	r3, [r3, #4]
   13542:	4798      	blx	r3
   13544:	4601      	mov	r1, r0
        ble_gattc_process_status(proc, rc);
   13546:	4620      	mov	r0, r4
   13548:	f7ff fc7c 	bl	12e44 <ble_gattc_process_status>
    }
}
   1354c:	b003      	add	sp, #12
   1354e:	bd30      	pop	{r4, r5, pc}
   13550:	0001f98c 	.word	0x0001f98c

00013554 <ble_gattc_rx_read_group_type_adata>:
 * read-by-group-type-response to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_read_group_type_adata(uint16_t conn_handle,
                                   struct ble_att_read_group_type_adata *adata)
{
   13554:	b5f0      	push	{r4, r5, r6, r7, lr}
   13556:	460d      	mov	r5, r1
   13558:	b087      	sub	sp, #28
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_SVCS);
   1355a:	2101      	movs	r1, #1
   1355c:	f7ff f9d2 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   13560:	4606      	mov	r6, r0
   13562:	2800      	cmp	r0, #0
   13564:	d038      	beq.n	135d8 <ble_gattc_rx_read_group_type_adata+0x84>
    int cbrc;
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    switch (adata->value_len) {
   13566:	686b      	ldr	r3, [r5, #4]
   13568:	2b02      	cmp	r3, #2
   1356a:	d006      	beq.n	1357a <ble_gattc_rx_read_group_type_adata+0x26>
   1356c:	2b10      	cmp	r3, #16
   1356e:	d122      	bne.n	135b6 <ble_gattc_rx_read_group_type_adata+0x62>
            goto done;
        }
        break;

    case 16:
        memcpy(service.uuid128, adata->value, 16);
   13570:	68ab      	ldr	r3, [r5, #8]
   13572:	ac02      	add	r4, sp, #8
   13574:	f103 0710 	add.w	r7, r3, #16
   13578:	e008      	b.n	1358c <ble_gattc_rx_read_group_type_adata+0x38>

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    switch (adata->value_len) {
    case 2:
        uuid16 = le16toh(adata->value);
   1357a:	68a8      	ldr	r0, [r5, #8]
   1357c:	f009 fd87 	bl	1d08e <le16toh>
        rc = ble_uuid_16_to_128(uuid16, service.uuid128);
   13580:	a902      	add	r1, sp, #8
   13582:	f004 ff9f 	bl	184c4 <ble_uuid_16_to_128>
        if (rc != 0) {
   13586:	4604      	mov	r4, r0
   13588:	b9b0      	cbnz	r0, 135b8 <ble_gattc_rx_read_group_type_adata+0x64>
   1358a:	e007      	b.n	1359c <ble_gattc_rx_read_group_type_adata+0x48>
            goto done;
        }
        break;

    case 16:
        memcpy(service.uuid128, adata->value, 16);
   1358c:	6818      	ldr	r0, [r3, #0]
   1358e:	6859      	ldr	r1, [r3, #4]
   13590:	4622      	mov	r2, r4
   13592:	c203      	stmia	r2!, {r0, r1}
   13594:	3308      	adds	r3, #8
   13596:	42bb      	cmp	r3, r7
   13598:	4614      	mov	r4, r2
   1359a:	d1f7      	bne.n	1358c <ble_gattc_rx_read_group_type_adata+0x38>
    default:
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    if (adata->end_group_handle <= proc->disc_all_svcs.prev_handle) {
   1359c:	886b      	ldrh	r3, [r5, #2]
   1359e:	89b2      	ldrh	r2, [r6, #12]
   135a0:	429a      	cmp	r2, r3
   135a2:	d208      	bcs.n	135b6 <ble_gattc_rx_read_group_type_adata+0x62>
        /* Peer sent services out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    proc->disc_all_svcs.prev_handle = adata->end_group_handle;
   135a4:	81b3      	strh	r3, [r6, #12]

    service.start_handle = adata->att_handle;
   135a6:	882b      	ldrh	r3, [r5, #0]
   135a8:	f8ad 3004 	strh.w	r3, [sp, #4]
    service.end_handle = adata->end_group_handle;
   135ac:	886b      	ldrh	r3, [r5, #2]
   135ae:	f8ad 3006 	strh.w	r3, [sp, #6]

    rc = 0;
   135b2:	2400      	movs	r4, #0
   135b4:	e000      	b.n	135b8 <ble_gattc_rx_read_group_type_adata+0x64>
        goto done;
    }

    if (adata->end_group_handle <= proc->disc_all_svcs.prev_handle) {
        /* Peer sent services out of order; terminate procedure. */
        rc = BLE_HS_EBADDATA;
   135b6:	240a      	movs	r4, #10
    service.end_handle = adata->end_group_handle;

    rc = 0;

done:
    cbrc = ble_gattc_disc_all_svcs_cb(proc, rc, 0, &service);
   135b8:	4630      	mov	r0, r6
   135ba:	b2a1      	uxth	r1, r4
   135bc:	2200      	movs	r2, #0
   135be:	ab01      	add	r3, sp, #4
   135c0:	f7fe ff9c 	bl	124fc <ble_gattc_disc_all_svcs_cb>
    if (rc != 0 || cbrc != 0) {
   135c4:	b924      	cbnz	r4, 135d0 <ble_gattc_rx_read_group_type_adata+0x7c>
        return BLE_HS_EDONE;
    } else {
        return 0;
   135c6:	2800      	cmp	r0, #0
   135c8:	bf14      	ite	ne
   135ca:	210e      	movne	r1, #14
   135cc:	2100      	moveq	r1, #0
   135ce:	e000      	b.n	135d2 <ble_gattc_rx_read_group_type_adata+0x7e>
    rc = 0;

done:
    cbrc = ble_gattc_disc_all_svcs_cb(proc, rc, 0, &service);
    if (rc != 0 || cbrc != 0) {
        return BLE_HS_EDONE;
   135d0:	210e      	movs	r1, #14
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_SVCS);
    if (proc != NULL) {
        rc = ble_gattc_disc_all_svcs_rx_adata(proc, adata);
        ble_gattc_process_status(proc, rc);
   135d2:	4630      	mov	r0, r6
   135d4:	f7ff fc36 	bl	12e44 <ble_gattc_process_status>
    }
}
   135d8:	b007      	add	sp, #28
   135da:	bdf0      	pop	{r4, r5, r6, r7, pc}

000135dc <ble_gattc_rx_read_group_type_complete>:
 * Dispatches an incoming notification of the end of a
 * read-by-group-type-response to the appropriate active GATT procedure.
 */
void
ble_gattc_rx_read_group_type_complete(uint16_t conn_handle, int status)
{
   135dc:	b570      	push	{r4, r5, r6, lr}
   135de:	460d      	mov	r5, r1
   135e0:	b086      	sub	sp, #24
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_SVCS);
   135e2:	2101      	movs	r1, #1
   135e4:	f7ff f98e 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   135e8:	4604      	mov	r4, r0
   135ea:	b330      	cbz	r0, 1363a <ble_gattc_rx_read_group_type_complete+0x5e>
{
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    if (status != 0) {
   135ec:	b115      	cbz	r5, 135f4 <ble_gattc_rx_read_group_type_complete+0x18>
        ble_gattc_disc_all_svcs_cb(proc, status, 0, NULL);
   135ee:	b2a9      	uxth	r1, r5
   135f0:	2200      	movs	r2, #0
   135f2:	e01b      	b.n	1362c <ble_gattc_rx_read_group_type_complete+0x50>
        return BLE_HS_EDONE;
    }

    if (proc->disc_all_svcs.prev_handle == 0xffff) {
   135f4:	8983      	ldrh	r3, [r0, #12]
   135f6:	f64f 76ff 	movw	r6, #65535	; 0xffff
   135fa:	42b3      	cmp	r3, r6
   135fc:	d101      	bne.n	13602 <ble_gattc_rx_read_group_type_complete+0x26>
        /* Service discovery complete. */
        ble_gattc_disc_all_svcs_cb(proc, BLE_HS_EDONE, 0, NULL);
   135fe:	210e      	movs	r1, #14
   13600:	e013      	b.n	1362a <ble_gattc_rx_read_group_type_complete+0x4e>
    uint8_t uuid128[16];
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_PRIMARY_SERVICE, uuid128);
   13602:	a902      	add	r1, sp, #8
   13604:	f44f 5020 	mov.w	r0, #10240	; 0x2800
   13608:	f004 ff5c 	bl	184c4 <ble_uuid_16_to_128>
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.bagq_start_handle = proc->disc_all_svcs.prev_handle + 1;
   1360c:	89a3      	ldrh	r3, [r4, #12]
    req.bagq_end_handle = 0xffff;
    rc = ble_att_clt_tx_read_group_type(proc->conn_handle, &req, uuid128);
   1360e:	8920      	ldrh	r0, [r4, #8]

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_PRIMARY_SERVICE, uuid128);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.bagq_start_handle = proc->disc_all_svcs.prev_handle + 1;
    req.bagq_end_handle = 0xffff;
   13610:	f8ad 6006 	strh.w	r6, [sp, #6]
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_PRIMARY_SERVICE, uuid128);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.bagq_start_handle = proc->disc_all_svcs.prev_handle + 1;
   13614:	3301      	adds	r3, #1
    req.bagq_end_handle = 0xffff;
    rc = ble_att_clt_tx_read_group_type(proc->conn_handle, &req, uuid128);
   13616:	a901      	add	r1, sp, #4
   13618:	aa02      	add	r2, sp, #8
    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_uuid_16_to_128(BLE_ATT_UUID_PRIMARY_SERVICE, uuid128);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    req.bagq_start_handle = proc->disc_all_svcs.prev_handle + 1;
   1361a:	f8ad 3004 	strh.w	r3, [sp, #4]
    req.bagq_end_handle = 0xffff;
    rc = ble_att_clt_tx_read_group_type(proc->conn_handle, &req, uuid128);
   1361e:	f007 f853 	bl	1a6c8 <ble_att_clt_tx_read_group_type>

    if (rc != 0) {
   13622:	4601      	mov	r1, r0
   13624:	b130      	cbz	r0, 13634 <ble_gattc_rx_read_group_type_complete+0x58>
        if (cb_on_err) {
            ble_gattc_disc_all_svcs_cb(proc, rc, 0, NULL);
   13626:	4620      	mov	r0, r4
   13628:	b289      	uxth	r1, r1
   1362a:	462a      	mov	r2, r5
   1362c:	4613      	mov	r3, r2
   1362e:	f7fe ff65 	bl	124fc <ble_gattc_disc_all_svcs_cb>
    }

    /* Send follow-up request. */
    rc = ble_gattc_disc_all_svcs_go(proc, 1);
    if (rc != 0) {
        return BLE_HS_EDONE;
   13632:	210e      	movs	r1, #14
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_DISC_ALL_SVCS);
    if (proc != NULL) {
        rc = ble_gattc_disc_all_svcs_rx_complete(proc, status);
        ble_gattc_process_status(proc, rc);
   13634:	4620      	mov	r0, r4
   13636:	f7ff fc05 	bl	12e44 <ble_gattc_process_status>
    }
}
   1363a:	b006      	add	sp, #24
   1363c:	bd70      	pop	{r4, r5, r6, pc}
	...

00013640 <ble_gattc_rx_read_rsp>:
 * procedure.
 */
void
ble_gattc_rx_read_rsp(uint16_t conn_handle, int status, void *value,
                      int value_len)
{
   13640:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   13644:	4688      	mov	r8, r1
   13646:	4617      	mov	r7, r2
   13648:	461e      	mov	r6, r3

    const struct ble_gattc_rx_attr_entry *rx_entry;
    struct ble_gattc_proc *proc;
    int rc;

    proc = BLE_GATTC_RX_EXTRACT_RX_ENTRY(conn_handle,
   1364a:	490a      	ldr	r1, [pc, #40]	; (13674 <ble_gattc_rx_read_rsp+0x34>)
   1364c:	2203      	movs	r2, #3
   1364e:	ab01      	add	r3, sp, #4
   13650:	f7ff f980 	bl	12954 <ble_gattc_extract_with_rx_entry>
                                         ble_gattc_rx_read_rsp_entries,
                                         &rx_entry);
    if (proc != NULL) {
   13654:	4604      	mov	r4, r0
   13656:	b148      	cbz	r0, 1366c <ble_gattc_rx_read_rsp+0x2c>
        rc = rx_entry->cb(proc, status, value, value_len);
   13658:	9b01      	ldr	r3, [sp, #4]
   1365a:	4641      	mov	r1, r8
   1365c:	685d      	ldr	r5, [r3, #4]
   1365e:	463a      	mov	r2, r7
   13660:	4633      	mov	r3, r6
   13662:	47a8      	blx	r5
   13664:	4601      	mov	r1, r0
        ble_gattc_process_status(proc, rc);
   13666:	4620      	mov	r0, r4
   13668:	f7ff fbec 	bl	12e44 <ble_gattc_process_status>
    }
}
   1366c:	b002      	add	sp, #8
   1366e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13672:	bf00      	nop
   13674:	0001f6f0 	.word	0x0001f6f0

00013678 <ble_gattc_rx_read_blob_rsp>:
 * procedure.
 */
void
ble_gattc_rx_read_blob_rsp(uint16_t conn_handle, int status,
                           void *value, int value_len)
{
   13678:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1367a:	460f      	mov	r7, r1
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_READ_LONG);
   1367c:	2109      	movs	r1, #9
 * procedure.
 */
void
ble_gattc_rx_read_blob_rsp(uint16_t conn_handle, int status,
                           void *value, int value_len)
{
   1367e:	4616      	mov	r6, r2
   13680:	461d      	mov	r5, r3
#endif

    struct ble_gattc_proc *proc;
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_READ_LONG);
   13682:	f7ff f93f 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   13686:	4604      	mov	r4, r0
   13688:	b150      	cbz	r0, 136a0 <ble_gattc_rx_read_blob_rsp+0x28>
        rc = ble_gattc_read_long_rx_read_rsp(proc, status, value, value_len);
   1368a:	4639      	mov	r1, r7
   1368c:	4632      	mov	r2, r6
   1368e:	462b      	mov	r3, r5
   13690:	f7ff fc38 	bl	12f04 <ble_gattc_read_long_rx_read_rsp>
   13694:	4601      	mov	r1, r0
        ble_gattc_process_status(proc, rc);
   13696:	4620      	mov	r0, r4
    }
}
   13698:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    int rc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_READ_LONG);
    if (proc != NULL) {
        rc = ble_gattc_read_long_rx_read_rsp(proc, status, value, value_len);
        ble_gattc_process_status(proc, rc);
   1369c:	f7ff bbd2 	b.w	12e44 <ble_gattc_process_status>
   136a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000136a2 <ble_gattc_rx_read_mult_rsp>:
 * GATT procedure.
 */
void
ble_gattc_rx_read_mult_rsp(uint16_t conn_handle, int status,
                           void *value, int value_len)
{
   136a2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   136a4:	460f      	mov	r7, r1
    return;
#endif

    struct ble_gattc_proc *proc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_READ_MULT);
   136a6:	210a      	movs	r1, #10
 * GATT procedure.
 */
void
ble_gattc_rx_read_mult_rsp(uint16_t conn_handle, int status,
                           void *value, int value_len)
{
   136a8:	4616      	mov	r6, r2
   136aa:	461c      	mov	r4, r3
    return;
#endif

    struct ble_gattc_proc *proc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_READ_MULT);
   136ac:	f7ff f92a 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   136b0:	4605      	mov	r5, r0
   136b2:	b160      	cbz	r0, 136ce <ble_gattc_rx_read_mult_rsp+0x2c>
        ble_gattc_read_mult_cb(proc, status, 0, value, value_len);
   136b4:	b2a4      	uxth	r4, r4
   136b6:	9400      	str	r4, [sp, #0]
   136b8:	4639      	mov	r1, r7
   136ba:	2200      	movs	r2, #0
   136bc:	4633      	mov	r3, r6
   136be:	f7ff f8a5 	bl	1280c <ble_gattc_read_mult_cb>
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   136c2:	4628      	mov	r0, r5
    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_READ_MULT);
    if (proc != NULL) {
        ble_gattc_read_mult_cb(proc, status, 0, value, value_len);
        ble_gattc_process_status(proc, BLE_HS_EDONE);
    }
}
   136c4:	b003      	add	sp, #12
   136c6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   136ca:	f7ff b979 	b.w	129c0 <ble_gattc_proc_free>
    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_READ_MULT);
    if (proc != NULL) {
        ble_gattc_read_mult_cb(proc, status, 0, value, value_len);
        ble_gattc_process_status(proc, BLE_HS_EDONE);
    }
}
   136ce:	b003      	add	sp, #12
   136d0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000136d2 <ble_gattc_rx_write_rsp>:
 * Dispatches an incoming ATT write-response to the appropriate active GATT
 * procedure.
 */
void
ble_gattc_rx_write_rsp(uint16_t conn_handle)
{
   136d2:	b510      	push	{r4, lr}
    return;
#endif

    struct ble_gattc_proc *proc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_WRITE);
   136d4:	210b      	movs	r1, #11
   136d6:	f7ff f915 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   136da:	4604      	mov	r4, r0
   136dc:	b140      	cbz	r0, 136f0 <ble_gattc_rx_write_rsp+0x1e>
        ble_gattc_write_cb(proc, 0, 0);
   136de:	2100      	movs	r1, #0
   136e0:	460a      	mov	r2, r1
   136e2:	f7ff f983 	bl	129ec <ble_gattc_write_cb>
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   136e6:	4620      	mov	r0, r4
    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_WRITE);
    if (proc != NULL) {
        ble_gattc_write_cb(proc, 0, 0);
        ble_gattc_process_status(proc, BLE_HS_EDONE);
    }
}
   136e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   136ec:	f7ff b968 	b.w	129c0 <ble_gattc_proc_free>
   136f0:	bd10      	pop	{r4, pc}
	...

000136f4 <ble_gattc_rx_prep_write_rsp>:
 */
void
ble_gattc_rx_prep_write_rsp(uint16_t conn_handle, int status,
                            struct ble_att_prep_write_cmd *rsp,
                            void *attr_data, uint16_t attr_data_len)
{
   136f4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   136f8:	4688      	mov	r8, r1
   136fa:	4617      	mov	r7, r2
   136fc:	461e      	mov	r6, r3

    const struct ble_gattc_rx_prep_entry *rx_entry;
    struct ble_gattc_proc *proc;
    int rc;

    proc = BLE_GATTC_RX_EXTRACT_RX_ENTRY(conn_handle,
   136fe:	490b      	ldr	r1, [pc, #44]	; (1372c <ble_gattc_rx_prep_write_rsp+0x38>)
   13700:	2202      	movs	r2, #2
   13702:	ab03      	add	r3, sp, #12
   13704:	f7ff f926 	bl	12954 <ble_gattc_extract_with_rx_entry>
                                         ble_gattc_rx_prep_entries,
                                         &rx_entry);
    if (proc != NULL) {
   13708:	4604      	mov	r4, r0
   1370a:	b160      	cbz	r0, 13726 <ble_gattc_rx_prep_write_rsp+0x32>
        rc = rx_entry->cb(proc, status, rsp, attr_data, attr_data_len);
   1370c:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   13710:	9300      	str	r3, [sp, #0]
   13712:	9b03      	ldr	r3, [sp, #12]
   13714:	4641      	mov	r1, r8
   13716:	685d      	ldr	r5, [r3, #4]
   13718:	463a      	mov	r2, r7
   1371a:	4633      	mov	r3, r6
   1371c:	47a8      	blx	r5
   1371e:	4601      	mov	r1, r0
        ble_gattc_process_status(proc, rc);
   13720:	4620      	mov	r0, r4
   13722:	f7ff fb8f 	bl	12e44 <ble_gattc_process_status>
    }
}
   13726:	b004      	add	sp, #16
   13728:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1372c:	0001f728 	.word	0x0001f728

00013730 <ble_gattc_rx_exec_write_rsp>:
 * Dispatches an incoming ATT execute-write-response to the appropriate active
 * GATT procedure.
 */
void
ble_gattc_rx_exec_write_rsp(uint16_t conn_handle, int status)
{
   13730:	b537      	push	{r0, r1, r2, r4, r5, lr}
   13732:	460d      	mov	r5, r1

    const struct ble_gattc_rx_exec_entry *rx_entry;
    struct ble_gattc_proc *proc;
    int rc;

    proc = BLE_GATTC_RX_EXTRACT_RX_ENTRY(conn_handle,
   13734:	2202      	movs	r2, #2
   13736:	4908      	ldr	r1, [pc, #32]	; (13758 <ble_gattc_rx_exec_write_rsp+0x28>)
   13738:	ab01      	add	r3, sp, #4
   1373a:	f7ff f90b 	bl	12954 <ble_gattc_extract_with_rx_entry>
                                         ble_gattc_rx_exec_entries, &rx_entry);
    if (proc != NULL) {
   1373e:	4604      	mov	r4, r0
   13740:	b138      	cbz	r0, 13752 <ble_gattc_rx_exec_write_rsp+0x22>
        rc = rx_entry->cb(proc, status);
   13742:	9b01      	ldr	r3, [sp, #4]
   13744:	4629      	mov	r1, r5
   13746:	685b      	ldr	r3, [r3, #4]
   13748:	4798      	blx	r3
   1374a:	4601      	mov	r1, r0
        ble_gattc_process_status(proc, rc);
   1374c:	4620      	mov	r0, r4
   1374e:	f7ff fb79 	bl	12e44 <ble_gattc_process_status>
    }
}
   13752:	b003      	add	sp, #12
   13754:	bd30      	pop	{r4, r5, pc}
   13756:	bf00      	nop
   13758:	0001f9ac 	.word	0x0001f9ac

0001375c <ble_gattc_rx_indicate_rsp>:
 * Dispatches an incoming ATT handle-value-confirmation to the appropriate
 * active GATT procedure.
 */
void
ble_gattc_rx_indicate_rsp(uint16_t conn_handle)
{
   1375c:	b510      	push	{r4, lr}
    return;
#endif

    struct ble_gattc_proc *proc;

    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_INDICATE);
   1375e:	210e      	movs	r1, #14
   13760:	f7ff f8d0 	bl	12904 <ble_gattc_extract>
    if (proc != NULL) {
   13764:	4604      	mov	r4, r0
   13766:	b190      	cbz	r0, 1378e <ble_gattc_rx_indicate_rsp+0x32>
{
    int rc;

    ble_gattc_dbg_assert_proc_not_inserted(proc);

    rc = ble_gatts_rx_indicate_ack(proc->conn_handle,
   13768:	8900      	ldrh	r0, [r0, #8]
   1376a:	89a1      	ldrh	r1, [r4, #12]
   1376c:	f000 fc8c 	bl	14088 <ble_gatts_rx_indicate_ack>
                                   proc->indicate.chr_val_handle);
    if (rc != 0) {
   13770:	b940      	cbnz	r0, 13784 <ble_gattc_rx_indicate_rsp+0x28>
        return;
    }

    /* Tell the application about the received acknowledgment. */
    ble_gap_notify_tx_event(BLE_HS_EDONE, proc->conn_handle,
   13772:	200e      	movs	r0, #14
   13774:	8921      	ldrh	r1, [r4, #8]
   13776:	89a2      	ldrh	r2, [r4, #12]
   13778:	2301      	movs	r3, #1
   1377a:	f7fe fe16 	bl	123aa <ble_gap_notify_tx_event>
                            proc->indicate.chr_val_handle, 1);

    /* Send the next indication if one is pending. */
    ble_gatts_send_next_indicate(proc->conn_handle);
   1377e:	8920      	ldrh	r0, [r4, #8]
   13780:	f000 fc56 	bl	14030 <ble_gatts_send_next_indicate>
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   13784:	4620      	mov	r0, r4
    proc = ble_gattc_extract(conn_handle, BLE_GATT_OP_INDICATE);
    if (proc != NULL) {
        ble_gattc_indicate_rx_rsp(proc);
        ble_gattc_process_status(proc, BLE_HS_EDONE);
    }
}
   13786:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
    if (status == 0) {
        ble_gattc_proc_set_timer(proc);
        ble_gattc_proc_insert(proc);
    } else {
        ble_gattc_proc_free(proc);
   1378a:	f7ff b919 	b.w	129c0 <ble_gattc_proc_free>
   1378e:	bd10      	pop	{r4, pc}

00013790 <ble_gattc_connection_broken>:
 *                                  terminated.
 */
void
ble_gattc_connection_broken(uint16_t conn_handle)
{
    ble_gattc_fail_procs(conn_handle, BLE_GATT_OP_NONE, BLE_HS_ENOTCONN);
   13790:	21ff      	movs	r1, #255	; 0xff
   13792:	f7ff bc85 	b.w	130a0 <ble_gattc_fail_procs.constprop.13>
	...

00013798 <ble_gattc_init>:
    return !STAILQ_EMPTY(&ble_gattc_procs);
}

int
ble_gattc_init(void)
{
   13798:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int rc;

    free(ble_gattc_proc_mem);
   1379a:	4d19      	ldr	r5, [pc, #100]	; (13800 <ble_gattc_init+0x68>)
   1379c:	6828      	ldr	r0, [r5, #0]
   1379e:	f00a f983 	bl	1daa8 <free>

    STAILQ_INIT(&ble_gattc_procs);
   137a2:	4b18      	ldr	r3, [pc, #96]	; (13804 <ble_gattc_init+0x6c>)
   137a4:	2200      	movs	r2, #0
   137a6:	e883 000c 	stmia.w	r3, {r2, r3}

    if (ble_hs_cfg.max_gattc_procs > 0) {
   137aa:	4b17      	ldr	r3, [pc, #92]	; (13808 <ble_gattc_init+0x70>)
   137ac:	799c      	ldrb	r4, [r3, #6]
   137ae:	b95c      	cbnz	r4, 137c8 <ble_gattc_init+0x30>
        if (rc != 0) {
            goto err;
        }
    }

    rc = stats_init_and_reg(
   137b0:	4a16      	ldr	r2, [pc, #88]	; (1380c <ble_gattc_init+0x74>)
   137b2:	9201      	str	r2, [sp, #4]
   137b4:	2300      	movs	r3, #0
   137b6:	9300      	str	r3, [sp, #0]
   137b8:	4815      	ldr	r0, [pc, #84]	; (13810 <ble_gattc_init+0x78>)
   137ba:	2104      	movs	r1, #4
   137bc:	2223      	movs	r2, #35	; 0x23
   137be:	f009 fdc5 	bl	1d34c <stats_init_and_reg>
        STATS_HDR(ble_gattc_stats), STATS_SIZE_INIT_PARMS(ble_gattc_stats,
        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_gattc_stats), "ble_gattc");
    if (rc != 0) {
   137c2:	b1d8      	cbz	r0, 137fc <ble_gattc_init+0x64>
        rc = BLE_HS_EOS;
   137c4:	240b      	movs	r4, #11
   137c6:	e013      	b.n	137f0 <ble_gattc_init+0x58>
    free(ble_gattc_proc_mem);

    STAILQ_INIT(&ble_gattc_procs);

    if (ble_hs_cfg.max_gattc_procs > 0) {
        ble_gattc_proc_mem = malloc(
   137c8:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   137cc:	00c0      	lsls	r0, r0, #3
   137ce:	f00a f921 	bl	1da14 <malloc>
   137d2:	4603      	mov	r3, r0
   137d4:	6028      	str	r0, [r5, #0]
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_gattc_procs,
                             sizeof (struct ble_gattc_proc)));
        if (ble_gattc_proc_mem == NULL) {
   137d6:	b150      	cbz	r0, 137ee <ble_gattc_init+0x56>
            rc = BLE_HS_ENOMEM;
            goto err;
        }

        rc = os_mempool_init(&ble_gattc_proc_pool,
   137d8:	4a0e      	ldr	r2, [pc, #56]	; (13814 <ble_gattc_init+0x7c>)
   137da:	9200      	str	r2, [sp, #0]
   137dc:	4621      	mov	r1, r4
   137de:	480e      	ldr	r0, [pc, #56]	; (13818 <ble_gattc_init+0x80>)
   137e0:	2228      	movs	r2, #40	; 0x28
   137e2:	f7f6 fdd5 	bl	a390 <os_mempool_init>
                             ble_hs_cfg.max_gattc_procs,
                             sizeof (struct ble_gattc_proc),
                             ble_gattc_proc_mem,
                             "ble_gattc_proc_pool");
        if (rc != 0) {
   137e6:	4604      	mov	r4, r0
   137e8:	2800      	cmp	r0, #0
   137ea:	d0e1      	beq.n	137b0 <ble_gattc_init+0x18>
   137ec:	e000      	b.n	137f0 <ble_gattc_init+0x58>
    if (ble_hs_cfg.max_gattc_procs > 0) {
        ble_gattc_proc_mem = malloc(
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_gattc_procs,
                             sizeof (struct ble_gattc_proc)));
        if (ble_gattc_proc_mem == NULL) {
            rc = BLE_HS_ENOMEM;
   137ee:	2406      	movs	r4, #6
    }

    return 0;

err:
    free(ble_gattc_proc_mem);
   137f0:	6828      	ldr	r0, [r5, #0]
   137f2:	f00a f959 	bl	1daa8 <free>
    ble_gattc_proc_mem = NULL;
   137f6:	2300      	movs	r3, #0
   137f8:	602b      	str	r3, [r5, #0]

    return rc;
   137fa:	4620      	mov	r0, r4
}
   137fc:	b003      	add	sp, #12
   137fe:	bd30      	pop	{r4, r5, pc}
   13800:	200020bc 	.word	0x200020bc
   13804:	200020c4 	.word	0x200020c4
   13808:	20003b78 	.word	0x20003b78
   1380c:	0001f96c 	.word	0x0001f96c
   13810:	20003a50 	.word	0x20003a50
   13814:	0001f976 	.word	0x0001f976
   13818:	200020cc 	.word	0x200020cc

0001381c <ble_gatts_find_svc_entry_idx>:
static int
ble_gatts_find_svc_entry_idx(const struct ble_gatt_svc_def *svc)
{
    int i;

    for (i = 0; i < ble_gatts_num_svc_entries; i++) {
   1381c:	4b09      	ldr	r3, [pc, #36]	; (13844 <ble_gatts_find_svc_entry_idx+0x28>)
    return 0;
}

static int
ble_gatts_find_svc_entry_idx(const struct ble_gatt_svc_def *svc)
{
   1381e:	b510      	push	{r4, lr}
    int i;

    for (i = 0; i < ble_gatts_num_svc_entries; i++) {
   13820:	881a      	ldrh	r2, [r3, #0]
        if (ble_gatts_svc_entries[i].svc == svc) {
   13822:	4b09      	ldr	r3, [pc, #36]	; (13848 <ble_gatts_find_svc_entry_idx+0x2c>)
   13824:	6819      	ldr	r1, [r3, #0]
static int
ble_gatts_find_svc_entry_idx(const struct ble_gatt_svc_def *svc)
{
    int i;

    for (i = 0; i < ble_gatts_num_svc_entries; i++) {
   13826:	2300      	movs	r3, #0
   13828:	4293      	cmp	r3, r2
   1382a:	da05      	bge.n	13838 <ble_gatts_find_svc_entry_idx+0x1c>
        if (ble_gatts_svc_entries[i].svc == svc) {
   1382c:	f851 4033 	ldr.w	r4, [r1, r3, lsl #3]
   13830:	4284      	cmp	r4, r0
   13832:	d004      	beq.n	1383e <ble_gatts_find_svc_entry_idx+0x22>
static int
ble_gatts_find_svc_entry_idx(const struct ble_gatt_svc_def *svc)
{
    int i;

    for (i = 0; i < ble_gatts_num_svc_entries; i++) {
   13834:	3301      	adds	r3, #1
   13836:	e7f7      	b.n	13828 <ble_gatts_find_svc_entry_idx+0xc>
        if (ble_gatts_svc_entries[i].svc == svc) {
            return i;
        }
    }

    return -1;
   13838:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1383c:	bd10      	pop	{r4, pc}
   1383e:	4618      	mov	r0, r3
}
   13840:	bd10      	pop	{r4, pc}
   13842:	bf00      	nop
   13844:	200020ec 	.word	0x200020ec
   13848:	200020f0 	.word	0x200020f0

0001384c <ble_gatts_clt_cfg_find_idx>:
}

static int
ble_gatts_clt_cfg_find_idx(struct ble_gatts_clt_cfg *cfgs,
                           uint16_t chr_val_handle)
{
   1384c:	b510      	push	{r4, lr}
    struct ble_gatts_clt_cfg *cfg;
    int i;

    for (i = 0; i < ble_gatts_num_cfgable_chrs; i++) {
   1384e:	4b08      	ldr	r3, [pc, #32]	; (13870 <ble_gatts_clt_cfg_find_idx+0x24>)
   13850:	681a      	ldr	r2, [r3, #0]
   13852:	2300      	movs	r3, #0
   13854:	4293      	cmp	r3, r2
   13856:	da05      	bge.n	13864 <ble_gatts_clt_cfg_find_idx+0x18>
        cfg = cfgs + i;
        if (cfg->chr_val_handle == chr_val_handle) {
   13858:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
   1385c:	428c      	cmp	r4, r1
   1385e:	d004      	beq.n	1386a <ble_gatts_clt_cfg_find_idx+0x1e>
                           uint16_t chr_val_handle)
{
    struct ble_gatts_clt_cfg *cfg;
    int i;

    for (i = 0; i < ble_gatts_num_cfgable_chrs; i++) {
   13860:	3301      	adds	r3, #1
   13862:	e7f7      	b.n	13854 <ble_gatts_clt_cfg_find_idx+0x8>
        if (cfg->chr_val_handle == chr_val_handle) {
            return i;
        }
    }

    return -1;
   13864:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13868:	bd10      	pop	{r4, pc}
   1386a:	4618      	mov	r0, r3
}
   1386c:	bd10      	pop	{r4, pc}
   1386e:	bf00      	nop
   13870:	200020e8 	.word	0x200020e8

00013874 <ble_gatts_svc_access>:
                     struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
    const struct ble_gatt_svc_def *svc;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, svc_def_reads);
   13874:	4a0b      	ldr	r2, [pc, #44]	; (138a4 <ble_gatts_svc_access+0x30>)

static int
ble_gatts_svc_access(uint16_t conn_handle, uint16_t attr_handle,
                     uint8_t *uuid128, uint8_t op,
                     struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
   13876:	b538      	push	{r3, r4, r5, lr}
   13878:	9d05      	ldr	r5, [sp, #20]
    const struct ble_gatt_svc_def *svc;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, svc_def_reads);
   1387a:	6993      	ldr	r3, [r2, #24]

    BLE_HS_DBG_ASSERT(op == BLE_ATT_ACCESS_OP_READ);

    svc = arg;

    uuid16 = ble_uuid_128_to_16(svc->uuid128);
   1387c:	6868      	ldr	r0, [r5, #4]

static int
ble_gatts_svc_access(uint16_t conn_handle, uint16_t attr_handle,
                     uint8_t *uuid128, uint8_t op,
                     struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
   1387e:	9c04      	ldr	r4, [sp, #16]
    const struct ble_gatt_svc_def *svc;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, svc_def_reads);
   13880:	3301      	adds	r3, #1
   13882:	6193      	str	r3, [r2, #24]

    BLE_HS_DBG_ASSERT(op == BLE_ATT_ACCESS_OP_READ);

    svc = arg;

    uuid16 = ble_uuid_128_to_16(svc->uuid128);
   13884:	f004 fe08 	bl	18498 <ble_uuid_128_to_16>
    if (uuid16 != 0) {
   13888:	4601      	mov	r1, r0
   1388a:	b120      	cbz	r0, 13896 <ble_gatts_svc_access+0x22>
        htole16(ctxt->read.buf, uuid16);
   1388c:	6860      	ldr	r0, [r4, #4]
   1388e:	f009 fbe3 	bl	1d058 <htole16>
        ctxt->read.len = 2;
   13892:	2302      	movs	r3, #2
   13894:	e002      	b.n	1389c <ble_gatts_svc_access+0x28>
    } else {
        ctxt->read.data = svc->uuid128;
   13896:	686b      	ldr	r3, [r5, #4]
   13898:	60a3      	str	r3, [r4, #8]
        ctxt->read.len = 16;
   1389a:	2310      	movs	r3, #16
   1389c:	81a3      	strh	r3, [r4, #12]
    }

    return 0;
}
   1389e:	2000      	movs	r0, #0
   138a0:	bd38      	pop	{r3, r4, r5, pc}
   138a2:	bf00      	nop
   138a4:	20003ae8 	.word	0x20003ae8

000138a8 <ble_gatts_inc_access>:
                     struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
    const struct ble_gatts_svc_entry *entry;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, svc_inc_reads);
   138a8:	4a0f      	ldr	r2, [pc, #60]	; (138e8 <ble_gatts_inc_access+0x40>)

static int
ble_gatts_inc_access(uint16_t conn_handle, uint16_t attr_handle,
                     uint8_t *uuid128, uint8_t op,
                     struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
   138aa:	b538      	push	{r3, r4, r5, lr}
    const struct ble_gatts_svc_entry *entry;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, svc_inc_reads);
   138ac:	69d3      	ldr	r3, [r2, #28]

static int
ble_gatts_inc_access(uint16_t conn_handle, uint16_t attr_handle,
                     uint8_t *uuid128, uint8_t op,
                     struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
   138ae:	9d05      	ldr	r5, [sp, #20]
   138b0:	9c04      	ldr	r4, [sp, #16]

    BLE_HS_DBG_ASSERT(op == BLE_ATT_ACCESS_OP_READ);

    entry = arg;

    htole16(ctxt->read.buf + 0, entry->handle);
   138b2:	88a9      	ldrh	r1, [r5, #4]
                     struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
    const struct ble_gatts_svc_entry *entry;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, svc_inc_reads);
   138b4:	3301      	adds	r3, #1
   138b6:	61d3      	str	r3, [r2, #28]

    BLE_HS_DBG_ASSERT(op == BLE_ATT_ACCESS_OP_READ);

    entry = arg;

    htole16(ctxt->read.buf + 0, entry->handle);
   138b8:	6860      	ldr	r0, [r4, #4]
   138ba:	f009 fbcd 	bl	1d058 <htole16>
    htole16(ctxt->read.buf + 2, entry->end_group_handle);
   138be:	6860      	ldr	r0, [r4, #4]
   138c0:	88e9      	ldrh	r1, [r5, #6]
   138c2:	3002      	adds	r0, #2
   138c4:	f009 fbc8 	bl	1d058 <htole16>

    /* Only include the service UUID if it has a 16-bit representation. */
    uuid16 = ble_uuid_128_to_16(entry->svc->uuid128);
   138c8:	682b      	ldr	r3, [r5, #0]
   138ca:	6858      	ldr	r0, [r3, #4]
   138cc:	f004 fde4 	bl	18498 <ble_uuid_128_to_16>
    if (uuid16 != 0) {
   138d0:	4601      	mov	r1, r0
   138d2:	b128      	cbz	r0, 138e0 <ble_gatts_inc_access+0x38>
        htole16(ctxt->read.buf + 4, uuid16);
   138d4:	6860      	ldr	r0, [r4, #4]
   138d6:	3004      	adds	r0, #4
   138d8:	f009 fbbe 	bl	1d058 <htole16>
        ctxt->read.len = 6;
   138dc:	2306      	movs	r3, #6
   138de:	e000      	b.n	138e2 <ble_gatts_inc_access+0x3a>
    } else {
        ctxt->read.len = 4;
   138e0:	2304      	movs	r3, #4
   138e2:	81a3      	strh	r3, [r4, #12]
    }

    return 0;
}
   138e4:	2000      	movs	r0, #0
   138e6:	bd38      	pop	{r3, r4, r5, pc}
   138e8:	20003ae8 	.word	0x20003ae8

000138ec <ble_gatts_free_mem>:
    return 0;
}

static void
ble_gatts_free_mem(void)
{
   138ec:	b538      	push	{r3, r4, r5, lr}
    free(ble_gatts_clt_cfg_mem);
   138ee:	4c06      	ldr	r4, [pc, #24]	; (13908 <ble_gatts_free_mem+0x1c>)
    ble_gatts_clt_cfg_mem = NULL;
   138f0:	2500      	movs	r5, #0
}

static void
ble_gatts_free_mem(void)
{
    free(ble_gatts_clt_cfg_mem);
   138f2:	6820      	ldr	r0, [r4, #0]
   138f4:	f00a f8d8 	bl	1daa8 <free>
    ble_gatts_clt_cfg_mem = NULL;
   138f8:	6025      	str	r5, [r4, #0]

    free(ble_gatts_svc_entries);
   138fa:	4c04      	ldr	r4, [pc, #16]	; (1390c <ble_gatts_free_mem+0x20>)
   138fc:	6820      	ldr	r0, [r4, #0]
   138fe:	f00a f8d3 	bl	1daa8 <free>
    ble_gatts_svc_entries = NULL;
   13902:	6025      	str	r5, [r4, #0]
   13904:	bd38      	pop	{r3, r4, r5, pc}
   13906:	bf00      	nop
   13908:	200020fc 	.word	0x200020fc
   1390c:	200020f0 	.word	0x200020f0

00013910 <ble_gatts_chr_clt_cfg_allowed.isra.0>:

    return 0;
}

static uint16_t
ble_gatts_chr_clt_cfg_allowed(const struct ble_gatt_chr_def *chr)
   13910:	4603      	mov	r3, r0

    flags = 0;
    if (chr->flags & BLE_GATT_CHR_F_NOTIFY) {
        flags |= BLE_GATTS_CLT_CFG_F_NOTIFY;
    }
    if (chr->flags & BLE_GATT_CHR_F_INDICATE) {
   13912:	069b      	lsls	r3, r3, #26
static uint16_t
ble_gatts_chr_clt_cfg_allowed(const struct ble_gatt_chr_def *chr)
{
    uint16_t flags;

    flags = 0;
   13914:	f3c0 1000 	ubfx	r0, r0, #4, #1
    if (chr->flags & BLE_GATT_CHR_F_NOTIFY) {
        flags |= BLE_GATTS_CLT_CFG_F_NOTIFY;
    }
    if (chr->flags & BLE_GATT_CHR_F_INDICATE) {
        flags |= BLE_GATTS_CLT_CFG_F_INDICATE;
   13918:	bf44      	itt	mi
   1391a:	f040 0002 	orrmi.w	r0, r0, #2
   1391e:	b280      	uxthmi	r0, r0
    }

    return flags;
}
   13920:	4770      	bx	lr
	...

00013924 <ble_gatts_dsc_inc_stat>:
}

static void
ble_gatts_dsc_inc_stat(uint8_t gatt_op)
{
    switch (gatt_op) {
   13924:	2802      	cmp	r0, #2
   13926:	d002      	beq.n	1392e <ble_gatts_dsc_inc_stat+0xa>
   13928:	2803      	cmp	r0, #3
   1392a:	d005      	beq.n	13938 <ble_gatts_dsc_inc_stat+0x14>
   1392c:	4770      	bx	lr
    case BLE_GATT_ACCESS_OP_READ_DSC:
        STATS_INC(ble_gatts_stats, dsc_reads);
   1392e:	4a05      	ldr	r2, [pc, #20]	; (13944 <ble_gatts_dsc_inc_stat+0x20>)
   13930:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   13932:	3301      	adds	r3, #1
   13934:	62d3      	str	r3, [r2, #44]	; 0x2c
   13936:	4770      	bx	lr
        break;

    case BLE_GATT_ACCESS_OP_WRITE_DSC:
        STATS_INC(ble_gatts_stats, dsc_writes);
   13938:	4a02      	ldr	r2, [pc, #8]	; (13944 <ble_gatts_dsc_inc_stat+0x20>)
   1393a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1393c:	3301      	adds	r3, #1
   1393e:	6313      	str	r3, [r2, #48]	; 0x30
   13940:	4770      	bx	lr
   13942:	bf00      	nop
   13944:	20003ae8 	.word	0x20003ae8

00013948 <ble_gatts_schedule_update.isra.4>:
ble_gatts_schedule_update(struct ble_hs_conn *conn,
                          struct ble_gatts_clt_cfg *clt_cfg)
{
    uint8_t att_op;

    if (!(clt_cfg->flags & BLE_GATTS_CLT_CFG_F_MODIFIED)) {
   13948:	788a      	ldrb	r2, [r1, #2]
   1394a:	0613      	lsls	r3, r2, #24
 *
 * @return                      The att_op of the update to send immediately,
 *                                  if any.  0 if nothing should get sent.
 */
static uint8_t
ble_gatts_schedule_update(struct ble_hs_conn *conn,
   1394c:	b530      	push	{r4, r5, lr}
                          struct ble_gatts_clt_cfg *clt_cfg)
{
    uint8_t att_op;

    if (!(clt_cfg->flags & BLE_GATTS_CLT_CFG_F_MODIFIED)) {
   1394e:	d507      	bpl.n	13960 <ble_gatts_schedule_update.isra.4+0x18>
        /* Characteristic not modified.  Nothing to send. */
        att_op = 0;
    } else if (clt_cfg->flags & BLE_GATTS_CLT_CFG_F_NOTIFY) {
   13950:	f012 0501 	ands.w	r5, r2, #1
   13954:	d106      	bne.n	13964 <ble_gatts_schedule_update.isra.4+0x1c>
        /* Notifications always get sent immediately. */
        att_op = BLE_ATT_OP_NOTIFY_REQ;
    } else if (clt_cfg->flags & BLE_GATTS_CLT_CFG_F_INDICATE) {
   13956:	f002 0402 	and.w	r4, r2, #2
   1395a:	b10c      	cbz	r4, 13960 <ble_gatts_schedule_update.isra.4+0x18>
        /* Only one outstanding indication per peer is allowed.  If we
         * are still awaiting an ack, mark this CCCD as updated so that
         * we know to send the indication upon receiving the expected ack.
         * If there isn't an outstanding indication, send this one now.
         */
        if (conn->bhc_gatt_svr.indicate_val_handle != 0) {
   1395c:	8803      	ldrh	r3, [r0, #0]
   1395e:	b11b      	cbz	r3, 13968 <ble_gatts_schedule_update.isra.4+0x20>
ble_gatts_schedule_update(struct ble_hs_conn *conn,
                          struct ble_gatts_clt_cfg *clt_cfg)
{
    uint8_t att_op;

    if (!(clt_cfg->flags & BLE_GATTS_CLT_CFG_F_MODIFIED)) {
   13960:	2000      	movs	r0, #0
   13962:	bd30      	pop	{r4, r5, pc}
        /* Characteristic not modified.  Nothing to send. */
        att_op = 0;
    } else if (clt_cfg->flags & BLE_GATTS_CLT_CFG_F_NOTIFY) {
        /* Notifications always get sent immediately. */
        att_op = BLE_ATT_OP_NOTIFY_REQ;
   13964:	201b      	movs	r0, #27
   13966:	e000      	b.n	1396a <ble_gatts_schedule_update.isra.4+0x22>
         * If there isn't an outstanding indication, send this one now.
         */
        if (conn->bhc_gatt_svr.indicate_val_handle != 0) {
            att_op = 0;
        } else {
            att_op = BLE_ATT_OP_INDICATE_REQ;
   13968:	201d      	movs	r0, #29

    /* If we will be sending an update, clear the modified flag so that we
     * don't double-send.
     */
    if (att_op != 0) {
        clt_cfg->flags &= ~BLE_GATTS_CLT_CFG_F_MODIFIED;
   1396a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   1396e:	708a      	strb	r2, [r1, #2]
    }

    return att_op;
}
   13970:	bd30      	pop	{r4, r5, pc}
	...

00013974 <ble_gatts_chr_def_access>:
                         struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
    const struct ble_gatt_chr_def *chr;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, chr_def_reads);
   13974:	4a27      	ldr	r2, [pc, #156]	; (13a14 <ble_gatts_chr_def_access+0xa0>)

static int
ble_gatts_chr_def_access(uint16_t conn_handle, uint16_t attr_handle,
                         uint8_t *uuid128, uint8_t op,
                         struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
   13976:	b538      	push	{r3, r4, r5, lr}
    const struct ble_gatt_chr_def *chr;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, chr_def_reads);
   13978:	6a13      	ldr	r3, [r2, #32]

static int
ble_gatts_chr_def_access(uint16_t conn_handle, uint16_t attr_handle,
                         uint8_t *uuid128, uint8_t op,
                         struct ble_att_svr_access_ctxt *ctxt, void *arg)
{
   1397a:	9d05      	ldr	r5, [sp, #20]
   1397c:	9c04      	ldr	r4, [sp, #16]
    const struct ble_gatt_chr_def *chr;
    uint16_t uuid16;

    STATS_INC(ble_gatts_stats, chr_def_reads);
   1397e:	3301      	adds	r3, #1
   13980:	6213      	str	r3, [r2, #32]
   13982:	8a2a      	ldrh	r2, [r5, #16]

    BLE_HS_DBG_ASSERT(op == BLE_ATT_ACCESS_OP_READ);

    chr = arg;

    ctxt->read.buf[0] = ble_gatts_chr_properties(chr);
   13984:	6860      	ldr	r0, [r4, #4]
static uint8_t
ble_gatts_chr_properties(const struct ble_gatt_chr_def *chr)
{
    uint8_t properties;

    properties = 0;
   13986:	f002 0301 	and.w	r3, r2, #1

    if (chr->flags & BLE_GATT_CHR_F_BROADCAST) {
        properties |= BLE_GATT_CHR_PROP_BROADCAST;
    }
    if (chr->flags & BLE_GATT_CHR_F_READ) {
   1398a:	f012 0f02 	tst.w	r2, #2
        properties |= BLE_GATT_CHR_PROP_READ;
   1398e:	bf1c      	itt	ne
   13990:	f043 0302 	orrne.w	r3, r3, #2
   13994:	b2db      	uxtbne	r3, r3
    }
    if (chr->flags & BLE_GATT_CHR_F_WRITE_NO_RSP) {
   13996:	f012 0f04 	tst.w	r2, #4
        properties |= BLE_GATT_CHR_PROP_WRITE_NO_RSP;
   1399a:	bf18      	it	ne
   1399c:	f043 0304 	orrne.w	r3, r3, #4
    }
    if (chr->flags & BLE_GATT_CHR_F_WRITE) {
   139a0:	f012 0f08 	tst.w	r2, #8
        properties |= BLE_GATT_CHR_PROP_WRITE;
   139a4:	bf18      	it	ne
   139a6:	f043 0308 	orrne.w	r3, r3, #8
    }
    if (chr->flags & BLE_GATT_CHR_F_NOTIFY) {
   139aa:	f012 0f10 	tst.w	r2, #16
        properties |= BLE_GATT_CHR_PROP_NOTIFY;
   139ae:	bf18      	it	ne
   139b0:	f043 0310 	orrne.w	r3, r3, #16
    }
    if (chr->flags & BLE_GATT_CHR_F_INDICATE) {
   139b4:	f012 0f20 	tst.w	r2, #32
        properties |= BLE_GATT_CHR_PROP_INDICATE;
   139b8:	bf18      	it	ne
   139ba:	f043 0320 	orrne.w	r3, r3, #32
    }
    if (chr->flags & BLE_GATT_CHR_F_AUTH_SIGN_WRITE) {
   139be:	f012 0f40 	tst.w	r2, #64	; 0x40
        properties |= BLE_GATT_CHR_PROP_AUTH_SIGN_WRITE;
   139c2:	bf18      	it	ne
   139c4:	f043 0340 	orrne.w	r3, r3, #64	; 0x40
    }
    if (chr->flags &
   139c8:	f412 7fc0 	tst.w	r2, #384	; 0x180
        (BLE_GATT_CHR_F_RELIABLE_WRITE | BLE_GATT_CHR_F_AUX_WRITE)) {

        properties |= BLE_GATT_CHR_PROP_EXTENDED;
   139cc:	bf18      	it	ne
   139ce:	f043 0380 	orrne.w	r3, r3, #128	; 0x80

    BLE_HS_DBG_ASSERT(op == BLE_ATT_ACCESS_OP_READ);

    chr = arg;

    ctxt->read.buf[0] = ble_gatts_chr_properties(chr);
   139d2:	7003      	strb	r3, [r0, #0]

    /* The value attribute is always immediately after the declaration. */
    htole16(ctxt->read.buf + 1, attr_handle + 1);
   139d4:	6860      	ldr	r0, [r4, #4]
   139d6:	3101      	adds	r1, #1
   139d8:	b289      	uxth	r1, r1
   139da:	3001      	adds	r0, #1
   139dc:	f009 fb3c 	bl	1d058 <htole16>

    uuid16 = ble_uuid_128_to_16(chr->uuid128);
   139e0:	6828      	ldr	r0, [r5, #0]
   139e2:	f004 fd59 	bl	18498 <ble_uuid_128_to_16>
    if (uuid16 != 0) {
   139e6:	4601      	mov	r1, r0
   139e8:	6860      	ldr	r0, [r4, #4]
   139ea:	b121      	cbz	r1, 139f6 <ble_gatts_chr_def_access+0x82>
        htole16(ctxt->read.buf + 3, uuid16);
   139ec:	3003      	adds	r0, #3
   139ee:	f009 fb33 	bl	1d058 <htole16>
        ctxt->read.len = 5;
   139f2:	2305      	movs	r3, #5
   139f4:	e00a      	b.n	13a0c <ble_gatts_chr_def_access+0x98>
    } else {
        memcpy(ctxt->read.buf + 3, chr->uuid128, 16);
   139f6:	682b      	ldr	r3, [r5, #0]
   139f8:	3003      	adds	r0, #3
   139fa:	f103 0210 	add.w	r2, r3, #16
   139fe:	f853 1b04 	ldr.w	r1, [r3], #4
   13a02:	f840 1b04 	str.w	r1, [r0], #4
   13a06:	4293      	cmp	r3, r2
   13a08:	d1f9      	bne.n	139fe <ble_gatts_chr_def_access+0x8a>
        ctxt->read.len = 19;
   13a0a:	2313      	movs	r3, #19
   13a0c:	81a3      	strh	r3, [r4, #12]
    }

    return 0;
}
   13a0e:	2000      	movs	r0, #0
   13a10:	bd38      	pop	{r3, r4, r5, pc}
   13a12:	bf00      	nop
   13a14:	20003ae8 	.word	0x20003ae8

00013a18 <ble_gatts_dsc_access>:

static int
ble_gatts_dsc_access(uint16_t conn_handle, uint16_t attr_handle,
                     uint8_t *uuid128, uint8_t att_op,
                     struct ble_att_svr_access_ctxt *att_ctxt, void *arg)
{
   13a18:	b5f0      	push	{r4, r5, r6, r7, lr}
   13a1a:	b085      	sub	sp, #20
}

static uint8_t
ble_gatts_dsc_op(uint8_t att_op)
{
    switch (att_op) {
   13a1c:	2b02      	cmp	r3, #2

static int
ble_gatts_dsc_access(uint16_t conn_handle, uint16_t attr_handle,
                     uint8_t *uuid128, uint8_t att_op,
                     struct ble_att_svr_access_ctxt *att_ctxt, void *arg)
{
   13a1e:	4607      	mov	r7, r0
   13a20:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
static uint8_t
ble_gatts_dsc_op(uint8_t att_op)
{
    switch (att_op) {
    case BLE_ATT_ACCESS_OP_READ:
        return BLE_GATT_ACCESS_OP_READ_DSC;
   13a22:	bf0c      	ite	eq
   13a24:	2003      	moveq	r0, #3
   13a26:	2002      	movne	r0, #2

static int
ble_gatts_dsc_access(uint16_t conn_handle, uint16_t attr_handle,
                     uint8_t *uuid128, uint8_t att_op,
                     struct ble_att_svr_access_ctxt *att_ctxt, void *arg)
{
   13a28:	460e      	mov	r6, r1
    int rc;

    dsc_def = arg;
    BLE_HS_DBG_ASSERT(dsc_def != NULL && dsc_def->access_cb != NULL);

    gatt_ctxt.op = ble_gatts_dsc_op(att_op);
   13a2a:	f88d 0004 	strb.w	r0, [sp, #4]
    default:
        BLE_HS_DBG_ASSERT(0);
        return BLE_HS_EUNKNOWN;
    }

    ble_gatts_dsc_inc_stat(gatt_ctxt.op);
   13a2e:	f7ff ff79 	bl	13924 <ble_gatts_dsc_inc_stat>

    gatt_ctxt.dsc = dsc_def;
    gatt_ctxt.att = att_ctxt;
   13a32:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13a34:	9303      	str	r3, [sp, #12]
        return BLE_HS_EUNKNOWN;
    }

    ble_gatts_dsc_inc_stat(gatt_ctxt.op);

    gatt_ctxt.dsc = dsc_def;
   13a36:	9402      	str	r4, [sp, #8]
    gatt_ctxt.att = att_ctxt;
    rc = dsc_def->access_cb(conn_handle, attr_handle, &gatt_ctxt,
   13a38:	68a5      	ldr	r5, [r4, #8]
   13a3a:	68e3      	ldr	r3, [r4, #12]
   13a3c:	4638      	mov	r0, r7
   13a3e:	4631      	mov	r1, r6
   13a40:	aa01      	add	r2, sp, #4
   13a42:	47a8      	blx	r5
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   13a44:	b005      	add	sp, #20
   13a46:	bdf0      	pop	{r4, r5, r6, r7, pc}

00013a48 <ble_gatts_clt_cfg_access>:
static int
ble_gatts_clt_cfg_access(uint16_t conn_handle, uint16_t attr_handle,
                         uint8_t *uuid128, uint8_t op,
                         struct ble_att_svr_access_ctxt *ctxt,
                         void *arg)
{
   13a48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13a4c:	b08f      	sub	sp, #60	; 0x3c
   13a4e:	4688      	mov	r8, r1
   13a50:	9005      	str	r0, [sp, #20]
   13a52:	461d      	mov	r5, r3
   13a54:	9c18      	ldr	r4, [sp, #96]	; 0x60
    uint16_t chr_val_handle;
    uint8_t prev_flags;
    uint8_t cur_flags;
    int rc;

    ble_hs_lock();
   13a56:	f000 fe75 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   13a5a:	9805      	ldr	r0, [sp, #20]
   13a5c:	f001 fc1a 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   13a60:	4683      	mov	fp, r0
   13a62:	b908      	cbnz	r0, 13a68 <ble_gatts_clt_cfg_access+0x20>
        rc = BLE_ATT_ERR_UNLIKELY;
   13a64:	240e      	movs	r4, #14
   13a66:	e06e      	b.n	13b46 <ble_gatts_clt_cfg_access+0xfe>
    out_cccd->chr_val_handle = 0;

    /* We always register the client characteristics descriptor with handle
     * (chr_val + 1).
     */
    chr_val_handle = attr_handle - 1;
   13a68:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
   13a6c:	fa1f f989 	uxth.w	r9, r9
    uint8_t gatt_op;

    static uint8_t buf[2];

    /* Assume nothing needs to be persisted. */
    out_cccd->chr_val_handle = 0;
   13a70:	f04f 0300 	mov.w	r3, #0

    /* We always register the client characteristics descriptor with handle
     * (chr_val + 1).
     */
    chr_val_handle = attr_handle - 1;
    if (chr_val_handle > attr_handle) {
   13a74:	45c1      	cmp	r9, r8
    uint8_t gatt_op;

    static uint8_t buf[2];

    /* Assume nothing needs to be persisted. */
    out_cccd->chr_val_handle = 0;
   13a76:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30

    /* We always register the client characteristics descriptor with handle
     * (chr_val + 1).
     */
    chr_val_handle = attr_handle - 1;
    if (chr_val_handle > attr_handle) {
   13a7a:	d8f3      	bhi.n	13a64 <ble_gatts_clt_cfg_access+0x1c>
        /* Attribute handle wrapped somehow. */
        return BLE_ATT_ERR_UNLIKELY;
    }

    clt_cfg = ble_gatts_clt_cfg_find(conn->bhc_gatt_svr.clt_cfgs,
   13a7c:	f8d0 a038 	ldr.w	sl, [r0, #56]	; 0x38
ble_gatts_clt_cfg_find(struct ble_gatts_clt_cfg *cfgs,
                       uint16_t chr_val_handle)
{
    int idx;

    idx = ble_gatts_clt_cfg_find_idx(cfgs, chr_val_handle);
   13a80:	4649      	mov	r1, r9
   13a82:	4650      	mov	r0, sl
   13a84:	f7ff fee2 	bl	1384c <ble_gatts_clt_cfg_find_idx>
    if (idx == -1) {
   13a88:	1c43      	adds	r3, r0, #1
   13a8a:	d0eb      	beq.n	13a64 <ble_gatts_clt_cfg_access+0x1c>
        return BLE_ATT_ERR_UNLIKELY;
    }

    clt_cfg = ble_gatts_clt_cfg_find(conn->bhc_gatt_svr.clt_cfgs,
                                     chr_val_handle);
    if (clt_cfg == NULL) {
   13a8c:	eb1a 0a80 	adds.w	sl, sl, r0, lsl #2
   13a90:	d0e8      	beq.n	13a64 <ble_gatts_clt_cfg_access+0x1c>
static uint8_t
ble_gatts_dsc_op(uint8_t att_op)
{
    switch (att_op) {
    case BLE_ATT_ACCESS_OP_READ:
        return BLE_GATT_ACCESS_OP_READ_DSC;
   13a92:	2d02      	cmp	r5, #2
   13a94:	bf0c      	ite	eq
   13a96:	2503      	moveq	r5, #3
   13a98:	2502      	movne	r5, #2
    /* Assume no change in flags. */
    *out_prev_clt_cfg_flags = clt_cfg->flags;
    *out_cur_clt_cfg_flags = clt_cfg->flags;

    gatt_op = ble_gatts_dsc_op(att_op);
    ble_gatts_dsc_inc_stat(gatt_op);
   13a9a:	4628      	mov	r0, r5
    if (clt_cfg == NULL) {
        return BLE_ATT_ERR_UNLIKELY;
    }

    /* Assume no change in flags. */
    *out_prev_clt_cfg_flags = clt_cfg->flags;
   13a9c:	f89a 7002 	ldrb.w	r7, [sl, #2]
    *out_cur_clt_cfg_flags = clt_cfg->flags;

    gatt_op = ble_gatts_dsc_op(att_op);
    ble_gatts_dsc_inc_stat(gatt_op);
   13aa0:	f7ff ff40 	bl	13924 <ble_gatts_dsc_inc_stat>

    switch (gatt_op) {
   13aa4:	2d03      	cmp	r5, #3
   13aa6:	483e      	ldr	r0, [pc, #248]	; (13ba0 <ble_gatts_clt_cfg_access+0x158>)
   13aa8:	d010      	beq.n	13acc <ble_gatts_clt_cfg_access+0x84>
    case BLE_GATT_ACCESS_OP_READ_DSC:
        STATS_INC(ble_gatts_stats, dsc_reads);
   13aaa:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
        htole16(buf, clt_cfg->flags & ~BLE_GATTS_CLT_CFG_F_RESERVED);
   13aac:	4d3d      	ldr	r5, [pc, #244]	; (13ba4 <ble_gatts_clt_cfg_access+0x15c>)
    gatt_op = ble_gatts_dsc_op(att_op);
    ble_gatts_dsc_inc_stat(gatt_op);

    switch (gatt_op) {
    case BLE_GATT_ACCESS_OP_READ_DSC:
        STATS_INC(ble_gatts_stats, dsc_reads);
   13aae:	3301      	adds	r3, #1
   13ab0:	62c3      	str	r3, [r0, #44]	; 0x2c
        htole16(buf, clt_cfg->flags & ~BLE_GATTS_CLT_CFG_F_RESERVED);
   13ab2:	f89a 1002 	ldrb.w	r1, [sl, #2]
   13ab6:	4628      	mov	r0, r5
   13ab8:	f001 0103 	and.w	r1, r1, #3
   13abc:	f009 facc 	bl	1d058 <htole16>
        ctxt->read.data = buf;
        ctxt->read.len = sizeof buf;
   13ac0:	2302      	movs	r3, #2

    switch (gatt_op) {
    case BLE_GATT_ACCESS_OP_READ_DSC:
        STATS_INC(ble_gatts_stats, dsc_reads);
        htole16(buf, clt_cfg->flags & ~BLE_GATTS_CLT_CFG_F_RESERVED);
        ctxt->read.data = buf;
   13ac2:	60a5      	str	r5, [r4, #8]
        ctxt->read.len = sizeof buf;
   13ac4:	81a3      	strh	r3, [r4, #12]
        return BLE_ATT_ERR_UNLIKELY;
    }

    /* Assume no change in flags. */
    *out_prev_clt_cfg_flags = clt_cfg->flags;
    *out_cur_clt_cfg_flags = clt_cfg->flags;
   13ac6:	463e      	mov	r6, r7
    default:
        BLE_HS_DBG_ASSERT(0);
        return BLE_ATT_ERR_UNLIKELY;
    }

    return 0;
   13ac8:	2400      	movs	r4, #0
   13aca:	e03c      	b.n	13b46 <ble_gatts_clt_cfg_access+0xfe>
        ctxt->read.data = buf;
        ctxt->read.len = sizeof buf;
        break;

    case BLE_GATT_ACCESS_OP_WRITE_DSC:
        STATS_INC(ble_gatts_stats, dsc_writes);
   13acc:	6b01      	ldr	r1, [r0, #48]	; 0x30
   13ace:	3101      	adds	r1, #1
   13ad0:	6301      	str	r1, [r0, #48]	; 0x30
        if (ctxt->write.len != 2) {
   13ad2:	68a1      	ldr	r1, [r4, #8]
   13ad4:	2902      	cmp	r1, #2
   13ad6:	d12d      	bne.n	13b34 <ble_gatts_clt_cfg_access+0xec>
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
        }

        flags = le16toh(ctxt->write.data);
   13ad8:	6820      	ldr	r0, [r4, #0]
   13ada:	f009 fad8 	bl	1d08e <le16toh>
        if ((flags & ~clt_cfg->allowed) != 0) {
   13ade:	f89a 4003 	ldrb.w	r4, [sl, #3]
   13ae2:	ea30 0404 	bics.w	r4, r0, r4
   13ae6:	d128      	bne.n	13b3a <ble_gatts_clt_cfg_access+0xf2>
            return BLE_ATT_ERR_WRITE_NOT_PERMITTED;
        }

        if (clt_cfg->flags != flags) {
   13ae8:	f89a 1002 	ldrb.w	r1, [sl, #2]
   13aec:	4281      	cmp	r1, r0
   13aee:	d027      	beq.n	13b40 <ble_gatts_clt_cfg_access+0xf8>
            clt_cfg->flags = flags;
   13af0:	b2c6      	uxtb	r6, r0
   13af2:	f88a 6002 	strb.w	r6, [sl, #2]
            *out_cur_clt_cfg_flags = flags;

            /* Successful writes get persisted for bonded connections. */
            if (conn->bhc_sec_state.bonded) {
   13af6:	f89b 1044 	ldrb.w	r1, [fp, #68]	; 0x44
   13afa:	f001 0104 	and.w	r1, r1, #4
   13afe:	f001 00ff 	and.w	r0, r1, #255	; 0xff
   13b02:	b1f9      	cbz	r1, 13b44 <ble_gatts_clt_cfg_access+0xfc>
                out_cccd->peer_addr_type = conn->bhc_peer_addr_type;
                memcpy(out_cccd->peer_addr, conn->bhc_peer_addr, 6);
   13b04:	465b      	mov	r3, fp
            clt_cfg->flags = flags;
            *out_cur_clt_cfg_flags = flags;

            /* Successful writes get persisted for bonded connections. */
            if (conn->bhc_sec_state.bonded) {
                out_cccd->peer_addr_type = conn->bhc_peer_addr_type;
   13b06:	f89b 1006 	ldrb.w	r1, [fp, #6]
                memcpy(out_cccd->peer_addr, conn->bhc_peer_addr, 6);
   13b0a:	f853 0f08 	ldr.w	r0, [r3, #8]!
            clt_cfg->flags = flags;
            *out_cur_clt_cfg_flags = flags;

            /* Successful writes get persisted for bonded connections. */
            if (conn->bhc_sec_state.bonded) {
                out_cccd->peer_addr_type = conn->bhc_peer_addr_type;
   13b0e:	f88d 102e 	strb.w	r1, [sp, #46]	; 0x2e
                memcpy(out_cccd->peer_addr, conn->bhc_peer_addr, 6);
   13b12:	889b      	ldrh	r3, [r3, #4]
   13b14:	900a      	str	r0, [sp, #40]	; 0x28
   13b16:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
                out_cccd->chr_val_handle = chr_val_handle;
   13b1a:	f8ad 9030 	strh.w	r9, [sp, #48]	; 0x30
                out_cccd->flags = clt_cfg->flags;
   13b1e:	f89a 3002 	ldrb.w	r3, [sl, #2]
   13b22:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
                out_cccd->value_changed = 0;
   13b26:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
   13b2a:	f364 0300 	bfi	r3, r4, #0, #1
   13b2e:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
   13b32:	e008      	b.n	13b46 <ble_gatts_clt_cfg_access+0xfe>
        return BLE_ATT_ERR_UNLIKELY;
    }

    /* Assume no change in flags. */
    *out_prev_clt_cfg_flags = clt_cfg->flags;
    *out_cur_clt_cfg_flags = clt_cfg->flags;
   13b34:	463e      	mov	r6, r7
        break;

    case BLE_GATT_ACCESS_OP_WRITE_DSC:
        STATS_INC(ble_gatts_stats, dsc_writes);
        if (ctxt->write.len != 2) {
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
   13b36:	240d      	movs	r4, #13
   13b38:	e005      	b.n	13b46 <ble_gatts_clt_cfg_access+0xfe>
        return BLE_ATT_ERR_UNLIKELY;
    }

    /* Assume no change in flags. */
    *out_prev_clt_cfg_flags = clt_cfg->flags;
    *out_cur_clt_cfg_flags = clt_cfg->flags;
   13b3a:	463e      	mov	r6, r7
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
        }

        flags = le16toh(ctxt->write.data);
        if ((flags & ~clt_cfg->allowed) != 0) {
            return BLE_ATT_ERR_WRITE_NOT_PERMITTED;
   13b3c:	462c      	mov	r4, r5
   13b3e:	e002      	b.n	13b46 <ble_gatts_clt_cfg_access+0xfe>
        return BLE_ATT_ERR_UNLIKELY;
    }

    /* Assume no change in flags. */
    *out_prev_clt_cfg_flags = clt_cfg->flags;
    *out_cur_clt_cfg_flags = clt_cfg->flags;
   13b40:	463e      	mov	r6, r7
   13b42:	e000      	b.n	13b46 <ble_gatts_clt_cfg_access+0xfe>
    default:
        BLE_HS_DBG_ASSERT(0);
        return BLE_ATT_ERR_UNLIKELY;
    }

    return 0;
   13b44:	4604      	mov	r4, r0
                                             &cccd_value,
                                             &prev_flags,
                                             &cur_flags);
    }

    ble_hs_unlock();
   13b46:	f000 fe05 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   13b4a:	bb2c      	cbnz	r4, 13b98 <ble_gatts_clt_cfg_access+0x150>
static void
ble_gatts_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
                          uint8_t reason,
                          uint8_t prev_flags, uint8_t cur_flags)
{
    if (prev_flags != cur_flags) {
   13b4c:	42b7      	cmp	r7, r6
   13b4e:	d011      	beq.n	13b74 <ble_gatts_clt_cfg_access+0x12c>
        ble_gap_subscribe_event(conn_handle,
   13b50:	f006 0301 	and.w	r3, r6, #1
    if (rc != 0) {
        return rc;
    }

    /* The value attribute is always immediately after the declaration. */
    chr_val_handle = attr_handle - 1;
   13b54:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
ble_gatts_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
                          uint8_t reason,
                          uint8_t prev_flags, uint8_t cur_flags)
{
    if (prev_flags != cur_flags) {
        ble_gap_subscribe_event(conn_handle,
   13b58:	9300      	str	r3, [sp, #0]
   13b5a:	f006 0602 	and.w	r6, r6, #2
   13b5e:	f007 0302 	and.w	r3, r7, #2
   13b62:	2201      	movs	r2, #1
   13b64:	9301      	str	r3, [sp, #4]
   13b66:	9602      	str	r6, [sp, #8]
   13b68:	9805      	ldr	r0, [sp, #20]
   13b6a:	b289      	uxth	r1, r1
   13b6c:	ea07 0302 	and.w	r3, r7, r2
   13b70:	f7fe fc3a 	bl	123e8 <ble_gap_subscribe_event>
    ble_gatts_subscribe_event(conn_handle, chr_val_handle,
                              BLE_GAP_SUBSCRIBE_REASON_WRITE,
                              prev_flags, cur_flags);

    /* Persist the CCCD if required. */
    if (cccd_value.chr_val_handle != 0) {
   13b74:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   13b78:	b173      	cbz	r3, 13b98 <ble_gatts_clt_cfg_access+0x150>
        if (cccd_value.flags == 0) {
   13b7a:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
   13b7e:	b93b      	cbnz	r3, 13b90 <ble_gatts_clt_cfg_access+0x148>
            ble_store_key_from_value_cccd(&cccd_key, &cccd_value);
   13b80:	a807      	add	r0, sp, #28
   13b82:	a90a      	add	r1, sp, #40	; 0x28
   13b84:	f004 fc30 	bl	183e8 <ble_store_key_from_value_cccd>
            rc = ble_store_delete_cccd(&cccd_key);
   13b88:	a807      	add	r0, sp, #28
   13b8a:	f004 fc29 	bl	183e0 <ble_store_delete_cccd>
   13b8e:	e002      	b.n	13b96 <ble_gatts_clt_cfg_access+0x14e>
        } else {
            rc = ble_store_write_cccd(&cccd_value);
   13b90:	a80a      	add	r0, sp, #40	; 0x28
   13b92:	f004 fc21 	bl	183d8 <ble_store_write_cccd>
   13b96:	4604      	mov	r4, r0
        }
    }

    return rc;
}
   13b98:	4620      	mov	r0, r4
   13b9a:	b00f      	add	sp, #60	; 0x3c
   13b9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13ba0:	20003ae8 	.word	0x20003ae8
   13ba4:	200020f4 	.word	0x200020f4

00013ba8 <ble_gatts_register_svcs>:
 *                                  contains an invalid element.
 */
int
ble_gatts_register_svcs(const struct ble_gatt_svc_def *svcs,
                        ble_gatt_register_fn *cb, void *cb_arg)
{
   13ba8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13bac:	460f      	mov	r7, r1
    int cur_registered;
    int rc;
    int i;

    for (i = 0; svcs[i].type != BLE_GATT_SVC_TYPE_END; i++) {
        ble_gatts_svc_entries[i].svc = svcs + i;
   13bae:	499a      	ldr	r1, [pc, #616]	; (13e18 <ble_gatts_register_svcs+0x270>)
 *                                  contains an invalid element.
 */
int
ble_gatts_register_svcs(const struct ble_gatt_svc_def *svcs,
                        ble_gatt_register_fn *cb, void *cb_arg)
{
   13bb0:	b099      	sub	sp, #100	; 0x64
   13bb2:	680b      	ldr	r3, [r1, #0]
   13bb4:	9104      	str	r1, [sp, #16]
   13bb6:	4693      	mov	fp, r2
    int total_registered;
    int cur_registered;
    int rc;
    int i;

    for (i = 0; svcs[i].type != BLE_GATT_SVC_TYPE_END; i++) {
   13bb8:	2200      	movs	r2, #0
   13bba:	4604      	mov	r4, r0
   13bbc:	3308      	adds	r3, #8
   13bbe:	7821      	ldrb	r1, [r4, #0]
   13bc0:	3010      	adds	r0, #16
   13bc2:	b151      	cbz	r1, 13bda <ble_gatts_register_svcs+0x32>
        ble_gatts_svc_entries[i].svc = svcs + i;
        ble_gatts_svc_entries[i].handle = 0;
   13bc4:	2100      	movs	r1, #0
   13bc6:	f823 1c04 	strh.w	r1, [r3, #-4]
        ble_gatts_svc_entries[i].end_group_handle = 0xffff;
   13bca:	f64f 71ff 	movw	r1, #65535	; 0xffff
    int cur_registered;
    int rc;
    int i;

    for (i = 0; svcs[i].type != BLE_GATT_SVC_TYPE_END; i++) {
        ble_gatts_svc_entries[i].svc = svcs + i;
   13bce:	f843 4c08 	str.w	r4, [r3, #-8]
        ble_gatts_svc_entries[i].handle = 0;
        ble_gatts_svc_entries[i].end_group_handle = 0xffff;
   13bd2:	f823 1c02 	strh.w	r1, [r3, #-2]
    int total_registered;
    int cur_registered;
    int rc;
    int i;

    for (i = 0; svcs[i].type != BLE_GATT_SVC_TYPE_END; i++) {
   13bd6:	3201      	adds	r2, #1
   13bd8:	e7ef      	b.n	13bba <ble_gatts_register_svcs+0x12>
        ble_gatts_svc_entries[i].svc = svcs + i;
        ble_gatts_svc_entries[i].handle = 0;
        ble_gatts_svc_entries[i].end_group_handle = 0xffff;
    }
    if (i > ble_hs_cfg.max_services) {
   13bda:	4b90      	ldr	r3, [pc, #576]	; (13e1c <ble_gatts_register_svcs+0x274>)
   13bdc:	885b      	ldrh	r3, [r3, #2]
   13bde:	429a      	cmp	r2, r3
   13be0:	dc75      	bgt.n	13cce <ble_gatts_register_svcs+0x126>
        return BLE_HS_ENOMEM;
    }

    ble_gatts_num_svc_entries = i;
   13be2:	4b8f      	ldr	r3, [pc, #572]	; (13e20 <ble_gatts_register_svcs+0x278>)

    total_registered = 0;
   13be4:	9102      	str	r1, [sp, #8]
    }
    if (i > ble_hs_cfg.max_services) {
        return BLE_HS_ENOMEM;
    }

    ble_gatts_num_svc_entries = i;
   13be6:	801a      	strh	r2, [r3, #0]

    total_registered = 0;
    while (total_registered < ble_gatts_num_svc_entries) {
   13be8:	4b8d      	ldr	r3, [pc, #564]	; (13e20 <ble_gatts_register_svcs+0x278>)
   13bea:	9a02      	ldr	r2, [sp, #8]
   13bec:	881b      	ldrh	r3, [r3, #0]
   13bee:	429a      	cmp	r2, r3
   13bf0:	da6b      	bge.n	13cca <ble_gatts_register_svcs+0x122>
   13bf2:	f04f 0900 	mov.w	r9, #0
   13bf6:	46c8      	mov	r8, r9
    uint16_t handle;
    int rc;
    int i;

    *out_num_registered = 0;
    for (i = 0; i < ble_gatts_num_svc_entries; i++) {
   13bf8:	4b89      	ldr	r3, [pc, #548]	; (13e20 <ble_gatts_register_svcs+0x278>)
   13bfa:	881b      	ldrh	r3, [r3, #0]
   13bfc:	4598      	cmp	r8, r3
   13bfe:	da58      	bge.n	13cb2 <ble_gatts_register_svcs+0x10a>
        entry = ble_gatts_svc_entries + i;
   13c00:	4b85      	ldr	r3, [pc, #532]	; (13e18 <ble_gatts_register_svcs+0x270>)
   13c02:	681d      	ldr	r5, [r3, #0]
   13c04:	eb05 03c8 	add.w	r3, r5, r8, lsl #3
   13c08:	9303      	str	r3, [sp, #12]

        if (entry->handle == 0) {
   13c0a:	889b      	ldrh	r3, [r3, #4]
   13c0c:	2b00      	cmp	r3, #0
   13c0e:	d14d      	bne.n	13cac <ble_gatts_register_svcs+0x104>
            rc = ble_gatts_register_svc(entry->svc, &handle, cb, cb_arg);
   13c10:	f855 6038 	ldr.w	r6, [r5, r8, lsl #3]
   13c14:	68b4      	ldr	r4, [r6, #8]
ble_gatts_svc_incs_satisfied(const struct ble_gatt_svc_def *svc)
{
    int idx;
    int i;

    if (svc->includes == NULL) {
   13c16:	b16c      	cbz	r4, 13c34 <ble_gatts_register_svcs+0x8c>
   13c18:	3c04      	subs	r4, #4
        /* No included services. */
        return 1;
    }

    for (i = 0; svc->includes[i] != NULL; i++) {
   13c1a:	f854 0f04 	ldr.w	r0, [r4, #4]!
   13c1e:	b148      	cbz	r0, 13c34 <ble_gatts_register_svcs+0x8c>
        idx = ble_gatts_find_svc_entry_idx(svc->includes[i]);
   13c20:	f7ff fdfc 	bl	1381c <ble_gatts_find_svc_entry_idx>
        if (idx == -1 || ble_gatts_svc_entries[idx].handle == 0) {
   13c24:	1c43      	adds	r3, r0, #1
   13c26:	d041      	beq.n	13cac <ble_gatts_register_svcs+0x104>
   13c28:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
   13c2c:	8883      	ldrh	r3, [r0, #4]
   13c2e:	2b00      	cmp	r3, #0
   13c30:	d1f3      	bne.n	13c1a <ble_gatts_register_svcs+0x72>
   13c32:	e03b      	b.n	13cac <ble_gatts_register_svcs+0x104>
}

static int
ble_gatts_svc_is_sane(const struct ble_gatt_svc_def *svc)
{
    if (svc->type != BLE_GATT_SVC_TYPE_PRIMARY &&
   13c34:	7833      	ldrb	r3, [r6, #0]
   13c36:	1e5a      	subs	r2, r3, #1
   13c38:	2a01      	cmp	r2, #1
   13c3a:	d83d      	bhi.n	13cb8 <ble_gatts_register_svcs+0x110>
        svc->type != BLE_GATT_SVC_TYPE_SECONDARY) {

        return 0;
    }

    if (svc->uuid128 == NULL) {
   13c3c:	6872      	ldr	r2, [r6, #4]
   13c3e:	2a00      	cmp	r2, #0
   13c40:	d03a      	beq.n	13cb8 <ble_gatts_register_svcs+0x110>
static int
ble_gatts_svc_type_to_uuid(uint8_t svc_type, uint16_t *out_uuid16)
{
    switch (svc_type) {
    case BLE_GATT_SVC_TYPE_PRIMARY:
        *out_uuid16 = BLE_ATT_UUID_PRIMARY_SERVICE;
   13c42:	2b02      	cmp	r3, #2
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    /* Register service definition attribute (cast away const on callback
     * arg).
     */
    rc = ble_att_svr_register_uuid16(uuid16, BLE_ATT_F_READ, out_handle,
   13c44:	f642 0001 	movw	r0, #10241	; 0x2801
   13c48:	9600      	str	r6, [sp, #0]
   13c4a:	bf18      	it	ne
   13c4c:	f44f 5020 	movne.w	r0, #10240	; 0x2800
   13c50:	2101      	movs	r1, #1
   13c52:	f10d 021a 	add.w	r2, sp, #26
   13c56:	4b73      	ldr	r3, [pc, #460]	; (13e24 <ble_gatts_register_svcs+0x27c>)
   13c58:	f007 fbe4 	bl	1b424 <ble_att_svr_register_uuid16>
                                     ble_gatts_svc_access, (void *)svc);
    if (rc != 0) {
   13c5c:	bb20      	cbnz	r0, 13ca8 <ble_gatts_register_svcs+0x100>
        return rc;
    }

    if (register_cb != NULL) {
   13c5e:	b157      	cbz	r7, 13c76 <ble_gatts_register_svcs+0xce>
        register_ctxt.op = BLE_GATT_REGISTER_OP_SVC;
   13c60:	2301      	movs	r3, #1
   13c62:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        register_ctxt.svc.handle = *out_handle;
        register_ctxt.svc.svc_def = svc;
        register_cb(&register_ctxt, cb_arg);
   13c66:	a809      	add	r0, sp, #36	; 0x24
        return rc;
    }

    if (register_cb != NULL) {
        register_ctxt.op = BLE_GATT_REGISTER_OP_SVC;
        register_ctxt.svc.handle = *out_handle;
   13c68:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   13c6c:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
        register_ctxt.svc.svc_def = svc;
        register_cb(&register_ctxt, cb_arg);
   13c70:	4659      	mov	r1, fp
    }

    if (register_cb != NULL) {
        register_ctxt.op = BLE_GATT_REGISTER_OP_SVC;
        register_ctxt.svc.handle = *out_handle;
        register_ctxt.svc.svc_def = svc;
   13c72:	960b      	str	r6, [sp, #44]	; 0x2c
        register_cb(&register_ctxt, cb_arg);
   13c74:	47b8      	blx	r7
    }

    /* Register each include. */
    if (svc->includes != NULL) {
   13c76:	68b3      	ldr	r3, [r6, #8]
   13c78:	b35b      	cbz	r3, 13cd2 <ble_gatts_register_svcs+0x12a>
   13c7a:	2500      	movs	r5, #0
        for (i = 0; svc->includes[i] != NULL; i++) {
   13c7c:	68b3      	ldr	r3, [r6, #8]
   13c7e:	5958      	ldr	r0, [r3, r5]
   13c80:	b338      	cbz	r0, 13cd2 <ble_gatts_register_svcs+0x12a>
            idx = ble_gatts_find_svc_entry_idx(svc->includes[i]);
   13c82:	f7ff fdcb 	bl	1381c <ble_gatts_find_svc_entry_idx>
            BLE_HS_DBG_ASSERT_EVAL(idx != -1);

            rc = ble_gatts_register_inc(ble_gatts_svc_entries + idx);
   13c86:	9b04      	ldr	r3, [sp, #16]
   13c88:	681b      	ldr	r3, [r3, #0]
   13c8a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    int rc;

    BLE_HS_DBG_ASSERT(entry->handle != 0);
    BLE_HS_DBG_ASSERT(entry->end_group_handle != 0xffff);

    rc = ble_att_svr_register_uuid16(BLE_ATT_UUID_INCLUDE, BLE_ATT_F_READ,
   13c8e:	9000      	str	r0, [sp, #0]
   13c90:	2101      	movs	r1, #1
   13c92:	f642 0002 	movw	r0, #10242	; 0x2802
   13c96:	aa13      	add	r2, sp, #76	; 0x4c
   13c98:	4b63      	ldr	r3, [pc, #396]	; (13e28 <ble_gatts_register_svcs+0x280>)
   13c9a:	f007 fbc3 	bl	1b424 <ble_att_svr_register_uuid16>
   13c9e:	3504      	adds	r5, #4
        for (i = 0; svc->includes[i] != NULL; i++) {
            idx = ble_gatts_find_svc_entry_idx(svc->includes[i]);
            BLE_HS_DBG_ASSERT_EVAL(idx != -1);

            rc = ble_gatts_register_inc(ble_gatts_svc_entries + idx);
            if (rc != 0) {
   13ca0:	2800      	cmp	r0, #0
   13ca2:	d0eb      	beq.n	13c7c <ble_gatts_register_svcs+0xd4>
    for (i = 0; i < ble_gatts_num_svc_entries; i++) {
        entry = ble_gatts_svc_entries + i;

        if (entry->handle == 0) {
            rc = ble_gatts_register_svc(entry->svc, &handle, cb, cb_arg);
            switch (rc) {
   13ca4:	2800      	cmp	r0, #0
   13ca6:	d044      	beq.n	13d32 <ble_gatts_register_svcs+0x18a>
   13ca8:	2801      	cmp	r0, #1
   13caa:	d107      	bne.n	13cbc <ble_gatts_register_svcs+0x114>
    uint16_t handle;
    int rc;
    int i;

    *out_num_registered = 0;
    for (i = 0; i < ble_gatts_num_svc_entries; i++) {
   13cac:	f108 0801 	add.w	r8, r8, #1
   13cb0:	e7a2      	b.n	13bf8 <ble_gatts_register_svcs+0x50>
                return rc;
            }
        }
    }

    if (*out_num_registered == 0) {
   13cb2:	f1b9 0f00 	cmp.w	r9, #0
   13cb6:	d104      	bne.n	13cc2 <ble_gatts_register_svcs+0x11a>
        /* There is a circular dependency. */
        return BLE_HS_EINVAL;
   13cb8:	2003      	movs	r0, #3
   13cba:	e0fb      	b.n	13eb4 <ble_gatts_register_svcs+0x30c>
    ble_gatts_num_svc_entries = i;

    total_registered = 0;
    while (total_registered < ble_gatts_num_svc_entries) {
        rc = ble_gatts_register_round(&cur_registered, cb, cb_arg);
        if (rc != 0) {
   13cbc:	2800      	cmp	r0, #0
   13cbe:	f040 80f9 	bne.w	13eb4 <ble_gatts_register_svcs+0x30c>
            return rc;
        }
        total_registered += cur_registered;
   13cc2:	9b02      	ldr	r3, [sp, #8]
   13cc4:	444b      	add	r3, r9
   13cc6:	9302      	str	r3, [sp, #8]
   13cc8:	e78e      	b.n	13be8 <ble_gatts_register_svcs+0x40>
    }

    return 0;
   13cca:	2000      	movs	r0, #0
   13ccc:	e0f2      	b.n	13eb4 <ble_gatts_register_svcs+0x30c>
        ble_gatts_svc_entries[i].svc = svcs + i;
        ble_gatts_svc_entries[i].handle = 0;
        ble_gatts_svc_entries[i].end_group_handle = 0xffff;
    }
    if (i > ble_hs_cfg.max_services) {
        return BLE_HS_ENOMEM;
   13cce:	2006      	movs	r0, #6
   13cd0:	e0f0      	b.n	13eb4 <ble_gatts_register_svcs+0x30c>
            }
        }
    }

    /* Register each characteristic. */
    if (svc->characteristics != NULL) {
   13cd2:	68f5      	ldr	r5, [r6, #12]
   13cd4:	b12d      	cbz	r5, 13ce2 <ble_gatts_register_svcs+0x13a>
   13cd6:	3518      	adds	r5, #24
        for (chr = svc->characteristics; chr->uuid128 != NULL; chr++) {
   13cd8:	f855 3c18 	ldr.w	r3, [r5, #-24]
   13cdc:	f1a5 0a18 	sub.w	sl, r5, #24
   13ce0:	b923      	cbnz	r3, 13cec <ble_gatts_register_svcs+0x144>
                return rc;
            }
        }
    }

    STATS_INC(ble_gatts_stats, svcs);
   13ce2:	4a52      	ldr	r2, [pc, #328]	; (13e2c <ble_gatts_register_svcs+0x284>)
   13ce4:	68d3      	ldr	r3, [r2, #12]
   13ce6:	3301      	adds	r3, #1
   13ce8:	60d3      	str	r3, [r2, #12]
   13cea:	e022      	b.n	13d32 <ble_gatts_register_svcs+0x18a>
{
    if (chr->uuid128 == NULL) {
        return 0;
    }

    if (chr->access_cb == NULL) {
   13cec:	f855 3c14 	ldr.w	r3, [r5, #-20]
   13cf0:	b90b      	cbnz	r3, 13cf6 <ble_gatts_register_svcs+0x14e>
    uint16_t dsc_handle;
    uint8_t att_flags;
    int rc;

    if (!ble_gatts_chr_is_sane(chr)) {
        return BLE_HS_EINVAL;
   13cf2:	2403      	movs	r4, #3
   13cf4:	e018      	b.n	13d28 <ble_gatts_register_svcs+0x180>
    }

    if (ble_gatts_chr_clt_cfg_allowed(chr) != 0) {
   13cf6:	f835 0c08 	ldrh.w	r0, [r5, #-8]
   13cfa:	f7ff fe09 	bl	13910 <ble_gatts_chr_clt_cfg_allowed.isra.0>
   13cfe:	b140      	cbz	r0, 13d12 <ble_gatts_register_svcs+0x16a>
        if (ble_gatts_num_cfgable_chrs > ble_hs_cfg.max_client_configs) {
   13d00:	4a4b      	ldr	r2, [pc, #300]	; (13e30 <ble_gatts_register_svcs+0x288>)
   13d02:	4946      	ldr	r1, [pc, #280]	; (13e1c <ble_gatts_register_svcs+0x274>)
   13d04:	6813      	ldr	r3, [r2, #0]
   13d06:	8889      	ldrh	r1, [r1, #4]
   13d08:	428b      	cmp	r3, r1
   13d0a:	f300 80cf 	bgt.w	13eac <ble_gatts_register_svcs+0x304>
            return BLE_HS_ENOMEM;
        }
        ble_gatts_num_cfgable_chrs++;
   13d0e:	3301      	adds	r3, #1
   13d10:	6013      	str	r3, [r2, #0]
    }

    /* Register characteristic definition attribute (cast away const on
     * callback arg).
     */
    rc = ble_att_svr_register_uuid16(BLE_ATT_UUID_CHARACTERISTIC,
   13d12:	f8cd a000 	str.w	sl, [sp]
   13d16:	f642 0003 	movw	r0, #10243	; 0x2803
   13d1a:	2101      	movs	r1, #1
   13d1c:	aa07      	add	r2, sp, #28
   13d1e:	4b45      	ldr	r3, [pc, #276]	; (13e34 <ble_gatts_register_svcs+0x28c>)
   13d20:	f007 fb80 	bl	1b424 <ble_att_svr_register_uuid16>
                                     BLE_ATT_F_READ, &def_handle,
                                     ble_gatts_chr_def_access, (void *)chr);
    if (rc != 0) {
   13d24:	4604      	mov	r4, r0
   13d26:	b178      	cbz	r0, 13d48 <ble_gatts_register_svcs+0x1a0>
   13d28:	3518      	adds	r5, #24

    /* Register each characteristic. */
    if (svc->characteristics != NULL) {
        for (chr = svc->characteristics; chr->uuid128 != NULL; chr++) {
            rc = ble_gatts_register_chr(svc, chr, register_cb, cb_arg);
            if (rc != 0) {
   13d2a:	2c00      	cmp	r4, #0
   13d2c:	d0d4      	beq.n	13cd8 <ble_gatts_register_svcs+0x130>
   13d2e:	4620      	mov	r0, r4
   13d30:	e7b8      	b.n	13ca4 <ble_gatts_register_svcs+0xfc>
        if (entry->handle == 0) {
            rc = ble_gatts_register_svc(entry->svc, &handle, cb, cb_arg);
            switch (rc) {
            case 0:
                /* Service successfully registered. */
                entry->handle = handle;
   13d32:	9a03      	ldr	r2, [sp, #12]
   13d34:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   13d38:	8093      	strh	r3, [r2, #4]
                entry->end_group_handle = ble_att_svr_prev_handle();
   13d3a:	f007 fb87 	bl	1b44c <ble_att_svr_prev_handle>
   13d3e:	9b03      	ldr	r3, [sp, #12]
                (*out_num_registered)++;
   13d40:	f109 0901 	add.w	r9, r9, #1
            rc = ble_gatts_register_svc(entry->svc, &handle, cb, cb_arg);
            switch (rc) {
            case 0:
                /* Service successfully registered. */
                entry->handle = handle;
                entry->end_group_handle = ble_att_svr_prev_handle();
   13d44:	80d8      	strh	r0, [r3, #6]
   13d46:	e7b1      	b.n	13cac <ble_gatts_register_svcs+0x104>
    }

    /* Register characteristic value attribute (cast away const on callback
     * arg).
     */
    att_flags = ble_gatts_att_flags_from_chr_flags(chr->flags);
   13d48:	f835 3c08 	ldrh.w	r3, [r5, #-8]
    rc = ble_att_svr_register(chr->uuid128, att_flags, &val_handle,
   13d4c:	f8cd a000 	str.w	sl, [sp]
static uint8_t
ble_gatts_att_flags_from_chr_flags(ble_gatt_chr_flags chr_flags)
{
    uint8_t att_flags;

    att_flags = 0;
   13d50:	f3c3 0140 	ubfx	r1, r3, #1, #1
    if (chr_flags & BLE_GATT_CHR_F_READ) {
        att_flags |= BLE_ATT_F_READ;
    }
    if (chr_flags & (BLE_GATT_CHR_F_WRITE_NO_RSP | BLE_GATT_CHR_F_WRITE)) {
   13d54:	f013 0f0c 	tst.w	r3, #12
        att_flags |= BLE_ATT_F_WRITE;
   13d58:	bf1c      	itt	ne
   13d5a:	f041 0102 	orrne.w	r1, r1, #2
   13d5e:	b2c9      	uxtbne	r1, r1
    }
    if (chr_flags & BLE_GATT_CHR_F_READ_ENC) {
   13d60:	0598      	lsls	r0, r3, #22
        att_flags |= BLE_ATT_F_READ_ENC;
   13d62:	bf48      	it	mi
   13d64:	f041 0104 	orrmi.w	r1, r1, #4
    }
    if (chr_flags & BLE_GATT_CHR_F_READ_AUTHEN) {
   13d68:	055a      	lsls	r2, r3, #21
        att_flags |= BLE_ATT_F_READ_AUTHEN;
   13d6a:	bf48      	it	mi
   13d6c:	f041 0108 	orrmi.w	r1, r1, #8
    }
    if (chr_flags & BLE_GATT_CHR_F_READ_AUTHOR) {
   13d70:	051c      	lsls	r4, r3, #20
        att_flags |= BLE_ATT_F_READ_AUTHOR;
   13d72:	bf48      	it	mi
   13d74:	f041 0110 	orrmi.w	r1, r1, #16
    }
    if (chr_flags & BLE_GATT_CHR_F_WRITE_ENC) {
   13d78:	04d8      	lsls	r0, r3, #19
        att_flags |= BLE_ATT_F_WRITE_ENC;
   13d7a:	bf48      	it	mi
   13d7c:	f041 0120 	orrmi.w	r1, r1, #32
    }
    if (chr_flags & BLE_GATT_CHR_F_WRITE_AUTHEN) {
   13d80:	049a      	lsls	r2, r3, #18
        att_flags |= BLE_ATT_F_WRITE_AUTHEN;
   13d82:	bf48      	it	mi
   13d84:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
    }
    if (chr_flags & BLE_GATT_CHR_F_WRITE_AUTHOR) {
   13d88:	045b      	lsls	r3, r3, #17
        att_flags |= BLE_ATT_F_WRITE_AUTHOR;
   13d8a:	bf48      	it	mi
   13d8c:	f041 0180 	orrmi.w	r1, r1, #128	; 0x80

    /* Register characteristic value attribute (cast away const on callback
     * arg).
     */
    att_flags = ble_gatts_att_flags_from_chr_flags(chr->flags);
    rc = ble_att_svr_register(chr->uuid128, att_flags, &val_handle,
   13d90:	f855 0c18 	ldr.w	r0, [r5, #-24]
   13d94:	4b28      	ldr	r3, [pc, #160]	; (13e38 <ble_gatts_register_svcs+0x290>)
   13d96:	f10d 021e 	add.w	r2, sp, #30
   13d9a:	f007 fb09 	bl	1b3b0 <ble_att_svr_register>
                              ble_gatts_chr_val_access, (void *)chr);
    if (rc != 0) {
   13d9e:	4604      	mov	r4, r0
   13da0:	2800      	cmp	r0, #0
   13da2:	d1c1      	bne.n	13d28 <ble_gatts_register_svcs+0x180>
        return rc;
    }
    BLE_HS_DBG_ASSERT(val_handle == def_handle + 1);

    if (chr->val_handle != NULL) {
   13da4:	f855 3c04 	ldr.w	r3, [r5, #-4]
   13da8:	b113      	cbz	r3, 13db0 <ble_gatts_register_svcs+0x208>
        *chr->val_handle = val_handle;
   13daa:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   13dae:	801a      	strh	r2, [r3, #0]
    }

    if (register_cb != NULL) {
   13db0:	b187      	cbz	r7, 13dd4 <ble_gatts_register_svcs+0x22c>
        register_ctxt.op = BLE_GATT_REGISTER_OP_CHR;
   13db2:	2302      	movs	r3, #2
   13db4:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        register_ctxt.chr.def_handle = def_handle;
   13db8:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   13dbc:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
        register_ctxt.chr.val_handle = val_handle;
        register_ctxt.chr.svc_def = svc;
        register_ctxt.chr.chr_def = chr;
        register_cb(&register_ctxt, cb_arg);
   13dc0:	a80e      	add	r0, sp, #56	; 0x38
    }

    if (register_cb != NULL) {
        register_ctxt.op = BLE_GATT_REGISTER_OP_CHR;
        register_ctxt.chr.def_handle = def_handle;
        register_ctxt.chr.val_handle = val_handle;
   13dc2:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   13dc6:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
        register_ctxt.chr.svc_def = svc;
        register_ctxt.chr.chr_def = chr;
        register_cb(&register_ctxt, cb_arg);
   13dca:	4659      	mov	r1, fp

    if (register_cb != NULL) {
        register_ctxt.op = BLE_GATT_REGISTER_OP_CHR;
        register_ctxt.chr.def_handle = def_handle;
        register_ctxt.chr.val_handle = val_handle;
        register_ctxt.chr.svc_def = svc;
   13dcc:	9611      	str	r6, [sp, #68]	; 0x44
        register_ctxt.chr.chr_def = chr;
   13dce:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
        register_cb(&register_ctxt, cb_arg);
   13dd2:	47b8      	blx	r7
    }

    if (ble_gatts_chr_clt_cfg_allowed(chr) != 0) {
   13dd4:	f835 0c08 	ldrh.w	r0, [r5, #-8]
   13dd8:	f7ff fd9a 	bl	13910 <ble_gatts_chr_clt_cfg_allowed.isra.0>
   13ddc:	b928      	cbnz	r0, 13dea <ble_gatts_register_svcs+0x242>
        }
        BLE_HS_DBG_ASSERT(dsc_handle == def_handle + 2);
    }

    /* Register each descriptor. */
    if (chr->descriptors != NULL) {
   13dde:	f855 cc0c 	ldr.w	ip, [r5, #-12]
   13de2:	f1bc 0f00 	cmp.w	ip, #0
   13de6:	d153      	bne.n	13e90 <ble_gatts_register_svcs+0x2e8>
   13de8:	e055      	b.n	13e96 <ble_gatts_register_svcs+0x2ee>
ble_gatts_register_clt_cfg_dsc(uint16_t *att_handle)
{
    uint8_t uuid128[16];
    int rc;

    rc = ble_uuid_16_to_128(BLE_GATT_DSC_CLT_CFG_UUID16, uuid128);
   13dea:	f642 1002 	movw	r0, #10498	; 0x2902
   13dee:	a913      	add	r1, sp, #76	; 0x4c
   13df0:	f004 fb68 	bl	184c4 <ble_uuid_16_to_128>
    if (rc != 0) {
   13df4:	b960      	cbnz	r0, 13e10 <ble_gatts_register_svcs+0x268>
        return rc;
    }

    rc = ble_att_svr_register(uuid128, BLE_ATT_F_READ | BLE_ATT_F_WRITE,
   13df6:	9000      	str	r0, [sp, #0]
   13df8:	2103      	movs	r1, #3
   13dfa:	a813      	add	r0, sp, #76	; 0x4c
   13dfc:	aa08      	add	r2, sp, #32
   13dfe:	4b0f      	ldr	r3, [pc, #60]	; (13e3c <ble_gatts_register_svcs+0x294>)
   13e00:	f007 fad6 	bl	1b3b0 <ble_att_svr_register>
                              att_handle, ble_gatts_clt_cfg_access, NULL);
    if (rc != 0) {
   13e04:	b920      	cbnz	r0, 13e10 <ble_gatts_register_svcs+0x268>
        return rc;
    }

    STATS_INC(ble_gatts_stats, dscs);
   13e06:	4a09      	ldr	r2, [pc, #36]	; (13e2c <ble_gatts_register_svcs+0x284>)
   13e08:	6953      	ldr	r3, [r2, #20]
   13e0a:	3301      	adds	r3, #1
   13e0c:	6153      	str	r3, [r2, #20]
   13e0e:	e7e6      	b.n	13dde <ble_gatts_register_svcs+0x236>
        register_cb(&register_ctxt, cb_arg);
    }

    if (ble_gatts_chr_clt_cfg_allowed(chr) != 0) {
        rc = ble_gatts_register_clt_cfg_dsc(&dsc_handle);
        if (rc != 0) {
   13e10:	2800      	cmp	r0, #0
   13e12:	d0e4      	beq.n	13dde <ble_gatts_register_svcs+0x236>
   13e14:	e04c      	b.n	13eb0 <ble_gatts_register_svcs+0x308>
   13e16:	bf00      	nop
   13e18:	200020f0 	.word	0x200020f0
   13e1c:	20003b78 	.word	0x20003b78
   13e20:	200020ec 	.word	0x200020ec
   13e24:	00013875 	.word	0x00013875
   13e28:	000138a9 	.word	0x000138a9
   13e2c:	20003ae8 	.word	0x20003ae8
   13e30:	200020e8 	.word	0x200020e8
   13e34:	00013975 	.word	0x00013975
   13e38:	000141dd 	.word	0x000141dd
   13e3c:	00013a49 	.word	0x00013a49

    if (!ble_gatts_dsc_is_sane(dsc)) {
        return BLE_HS_EINVAL;
    }

    rc = ble_att_svr_register(dsc->uuid128, dsc->att_flags, &dsc_handle,
   13e40:	f89c 1004 	ldrb.w	r1, [ip, #4]
   13e44:	4b1d      	ldr	r3, [pc, #116]	; (13ebc <ble_gatts_register_svcs+0x314>)
   13e46:	f8cd c000 	str.w	ip, [sp]
   13e4a:	f10d 0222 	add.w	r2, sp, #34	; 0x22
   13e4e:	f8cd c014 	str.w	ip, [sp, #20]
   13e52:	f007 faad 	bl	1b3b0 <ble_att_svr_register>
                              ble_gatts_dsc_access, (void *)dsc);
    if (rc != 0) {
   13e56:	f8dd c014 	ldr.w	ip, [sp, #20]
   13e5a:	bb48      	cbnz	r0, 13eb0 <ble_gatts_register_svcs+0x308>
        return rc;
    }

    if (register_cb != NULL) {
   13e5c:	b197      	cbz	r7, 13e84 <ble_gatts_register_svcs+0x2dc>
        register_ctxt.op = BLE_GATT_REGISTER_OP_DSC;
   13e5e:	2303      	movs	r3, #3
   13e60:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
        register_ctxt.dsc.handle = dsc_handle;
        register_ctxt.dsc.svc_def = svc;
        register_ctxt.dsc.chr_def = chr;
        register_ctxt.dsc.dsc_def = dsc;
        register_cb(&register_ctxt, cb_arg);
   13e64:	a813      	add	r0, sp, #76	; 0x4c
        return rc;
    }

    if (register_cb != NULL) {
        register_ctxt.op = BLE_GATT_REGISTER_OP_DSC;
        register_ctxt.dsc.handle = dsc_handle;
   13e66:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
        register_ctxt.dsc.svc_def = svc;
        register_ctxt.dsc.chr_def = chr;
        register_ctxt.dsc.dsc_def = dsc;
   13e6a:	f8cd c054 	str.w	ip, [sp, #84]	; 0x54
        register_cb(&register_ctxt, cb_arg);
   13e6e:	4659      	mov	r1, fp
    if (register_cb != NULL) {
        register_ctxt.op = BLE_GATT_REGISTER_OP_DSC;
        register_ctxt.dsc.handle = dsc_handle;
        register_ctxt.dsc.svc_def = svc;
        register_ctxt.dsc.chr_def = chr;
        register_ctxt.dsc.dsc_def = dsc;
   13e70:	f8cd c014 	str.w	ip, [sp, #20]
        return rc;
    }

    if (register_cb != NULL) {
        register_ctxt.op = BLE_GATT_REGISTER_OP_DSC;
        register_ctxt.dsc.handle = dsc_handle;
   13e74:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        register_ctxt.dsc.svc_def = svc;
   13e78:	9617      	str	r6, [sp, #92]	; 0x5c
        register_ctxt.dsc.chr_def = chr;
   13e7a:	f8cd a058 	str.w	sl, [sp, #88]	; 0x58
        register_ctxt.dsc.dsc_def = dsc;
        register_cb(&register_ctxt, cb_arg);
   13e7e:	47b8      	blx	r7
   13e80:	f8dd c014 	ldr.w	ip, [sp, #20]
    }

    STATS_INC(ble_gatts_stats, dscs);
   13e84:	4a0e      	ldr	r2, [pc, #56]	; (13ec0 <ble_gatts_register_svcs+0x318>)
   13e86:	6953      	ldr	r3, [r2, #20]
   13e88:	3301      	adds	r3, #1
   13e8a:	6153      	str	r3, [r2, #20]
        BLE_HS_DBG_ASSERT(dsc_handle == def_handle + 2);
    }

    /* Register each descriptor. */
    if (chr->descriptors != NULL) {
        for (dsc = chr->descriptors; dsc->uuid128 != NULL; dsc++) {
   13e8c:	f10c 0c10 	add.w	ip, ip, #16
   13e90:	f8dc 0000 	ldr.w	r0, [ip]
   13e94:	b920      	cbnz	r0, 13ea0 <ble_gatts_register_svcs+0x2f8>
                return rc;
            }
        }
    }

    STATS_INC(ble_gatts_stats, chrs);
   13e96:	4a0a      	ldr	r2, [pc, #40]	; (13ec0 <ble_gatts_register_svcs+0x318>)
   13e98:	6913      	ldr	r3, [r2, #16]
   13e9a:	3301      	adds	r3, #1
   13e9c:	6113      	str	r3, [r2, #16]
   13e9e:	e743      	b.n	13d28 <ble_gatts_register_svcs+0x180>
{
    if (dsc->uuid128 == NULL) {
        return 0;
    }

    if (dsc->access_cb == NULL) {
   13ea0:	f8dc 3008 	ldr.w	r3, [ip, #8]
   13ea4:	2b00      	cmp	r3, #0
   13ea6:	d1cb      	bne.n	13e40 <ble_gatts_register_svcs+0x298>
    struct ble_gatt_register_ctxt register_ctxt;
    uint16_t dsc_handle;
    int rc;

    if (!ble_gatts_dsc_is_sane(dsc)) {
        return BLE_HS_EINVAL;
   13ea8:	2003      	movs	r0, #3
   13eaa:	e001      	b.n	13eb0 <ble_gatts_register_svcs+0x308>
        return BLE_HS_EINVAL;
    }

    if (ble_gatts_chr_clt_cfg_allowed(chr) != 0) {
        if (ble_gatts_num_cfgable_chrs > ble_hs_cfg.max_client_configs) {
            return BLE_HS_ENOMEM;
   13eac:	2406      	movs	r4, #6
   13eae:	e73b      	b.n	13d28 <ble_gatts_register_svcs+0x180>
    /* Register each descriptor. */
    if (chr->descriptors != NULL) {
        for (dsc = chr->descriptors; dsc->uuid128 != NULL; dsc++) {
            rc = ble_gatts_register_dsc(svc, chr, dsc, def_handle, register_cb,
                                        cb_arg);
            if (rc != 0) {
   13eb0:	4604      	mov	r4, r0
   13eb2:	e739      	b.n	13d28 <ble_gatts_register_svcs+0x180>
        }
        total_registered += cur_registered;
    }

    return 0;
}
   13eb4:	b019      	add	sp, #100	; 0x64
   13eb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13eba:	bf00      	nop
   13ebc:	00013a19 	.word	0x00013a19
   13ec0:	20003ae8 	.word	0x20003ae8

00013ec4 <ble_gatts_connection_broken>:
 *       characteristic updates.
 *     o Frees GATT server resources consumed by the connection (CCCDs).
 */
void
ble_gatts_connection_broken(uint16_t conn_handle)
{
   13ec4:	b5f0      	push	{r4, r5, r6, r7, lr}
   13ec6:	4606      	mov	r6, r0
   13ec8:	b085      	sub	sp, #20
     *        attempted, as the connection is about to be terminated.  This
     *        avoids a spurious notify-tx GAP event callback to the
     *        application.  By setting the clt_cfg pointer to null, it is
     *        assured that the connection has no pending indications to send.
     */
    ble_hs_lock();
   13eca:	f000 fc3b 	bl	14744 <ble_hs_lock>
    conn = ble_hs_conn_find(conn_handle);
   13ece:	4630      	mov	r0, r6
   13ed0:	f001 f9e0 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   13ed4:	4604      	mov	r4, r0
   13ed6:	b120      	cbz	r0, 13ee2 <ble_gatts_connection_broken+0x1e>
        clt_cfgs = conn->bhc_gatt_svr.clt_cfgs;
        num_clt_cfgs = conn->bhc_gatt_svr.num_clt_cfgs;

        conn->bhc_gatt_svr.clt_cfgs = NULL;
   13ed8:	2300      	movs	r3, #0
     *        assured that the connection has no pending indications to send.
     */
    ble_hs_lock();
    conn = ble_hs_conn_find(conn_handle);
    if (conn != NULL) {
        clt_cfgs = conn->bhc_gatt_svr.clt_cfgs;
   13eda:	6b85      	ldr	r5, [r0, #56]	; 0x38
        num_clt_cfgs = conn->bhc_gatt_svr.num_clt_cfgs;
   13edc:	6bc7      	ldr	r7, [r0, #60]	; 0x3c

        conn->bhc_gatt_svr.clt_cfgs = NULL;
   13ede:	6383      	str	r3, [r0, #56]	; 0x38
        conn->bhc_gatt_svr.num_clt_cfgs = 0;
   13ee0:	63c3      	str	r3, [r0, #60]	; 0x3c
    }
    ble_hs_unlock();
   13ee2:	f000 fc37 	bl	14754 <ble_hs_unlock>

    if (conn == NULL) {
   13ee6:	b30c      	cbz	r4, 13f2c <ble_gatts_connection_broken+0x68>
    }

    /* If there is an indicate procedure in progress for this connection,
     * inform the application that it has failed.
     */
    ble_gatts_indicate_fail_notconn(conn_handle);
   13ee8:	4630      	mov	r0, r6
   13eea:	f7ff f9be 	bl	1326a <ble_gatts_indicate_fail_notconn>

    /* Now that the mutex is unlocked, inform the application that the peer is
     * no longer subscribed to any characteristic updates.
     */
    if (clt_cfgs != NULL) {
   13eee:	b1ed      	cbz	r5, 13f2c <ble_gatts_connection_broken+0x68>
   13ef0:	2400      	movs	r4, #0
        for (i = 0; i < num_clt_cfgs; i++) {
   13ef2:	42bc      	cmp	r4, r7
   13ef4:	da13      	bge.n	13f1e <ble_gatts_connection_broken+0x5a>
   13ef6:	eb05 0384 	add.w	r3, r5, r4, lsl #2
            ble_gatts_subscribe_event(conn_handle, clt_cfgs[i].chr_val_handle,
   13efa:	f835 1024 	ldrh.w	r1, [r5, r4, lsl #2]
   13efe:	789b      	ldrb	r3, [r3, #2]
static void
ble_gatts_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
                          uint8_t reason,
                          uint8_t prev_flags, uint8_t cur_flags)
{
    if (prev_flags != cur_flags) {
   13f00:	b15b      	cbz	r3, 13f1a <ble_gatts_connection_broken+0x56>
        ble_gap_subscribe_event(conn_handle,
   13f02:	2200      	movs	r2, #0
   13f04:	f003 0002 	and.w	r0, r3, #2
   13f08:	9200      	str	r2, [sp, #0]
   13f0a:	9001      	str	r0, [sp, #4]
   13f0c:	9202      	str	r2, [sp, #8]
   13f0e:	4630      	mov	r0, r6
   13f10:	2202      	movs	r2, #2
   13f12:	f003 0301 	and.w	r3, r3, #1
   13f16:	f7fe fa67 	bl	123e8 <ble_gap_subscribe_event>

    /* Now that the mutex is unlocked, inform the application that the peer is
     * no longer subscribed to any characteristic updates.
     */
    if (clt_cfgs != NULL) {
        for (i = 0; i < num_clt_cfgs; i++) {
   13f1a:	3401      	adds	r4, #1
   13f1c:	e7e9      	b.n	13ef2 <ble_gatts_connection_broken+0x2e>
            ble_gatts_subscribe_event(conn_handle, clt_cfgs[i].chr_val_handle,
                                      BLE_GAP_SUBSCRIBE_REASON_TERM,
                                      clt_cfgs[i].flags, 0);
        }

        rc = os_memblock_put(&ble_gatts_clt_cfg_pool, clt_cfgs);
   13f1e:	4804      	ldr	r0, [pc, #16]	; (13f30 <ble_gatts_connection_broken+0x6c>)
   13f20:	4629      	mov	r1, r5
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
    }
}
   13f22:	b005      	add	sp, #20
   13f24:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            ble_gatts_subscribe_event(conn_handle, clt_cfgs[i].chr_val_handle,
                                      BLE_GAP_SUBSCRIBE_REASON_TERM,
                                      clt_cfgs[i].flags, 0);
        }

        rc = os_memblock_put(&ble_gatts_clt_cfg_pool, clt_cfgs);
   13f28:	f7f6 ba7a 	b.w	a420 <os_memblock_put>
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
    }
}
   13f2c:	b005      	add	sp, #20
   13f2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13f30:	20002100 	.word	0x20002100

00013f34 <ble_gatts_start>:

int
ble_gatts_start(void)
{
   13f34:	b570      	push	{r4, r5, r6, lr}
    uint8_t uuid128[16];
    int num_elems;
    int idx;
    int rc;

    if (ble_gatts_num_cfgable_chrs == 0) {
   13f36:	4b20      	ldr	r3, [pc, #128]	; (13fb8 <ble_gatts_start+0x84>)
   13f38:	681a      	ldr	r2, [r3, #0]
    }
}

int
ble_gatts_start(void)
{
   13f3a:	b086      	sub	sp, #24
    uint8_t uuid128[16];
    int num_elems;
    int idx;
    int rc;

    if (ble_gatts_num_cfgable_chrs == 0) {
   13f3c:	b90a      	cbnz	r2, 13f42 <ble_gatts_start+0xe>
        return 0;
   13f3e:	2000      	movs	r0, #0
   13f40:	e037      	b.n	13fb2 <ble_gatts_start+0x7e>
    }

    /* Initialize client-configuration memory pool. */
    num_elems = ble_hs_cfg.max_client_configs / ble_gatts_num_cfgable_chrs;
   13f42:	4b1e      	ldr	r3, [pc, #120]	; (13fbc <ble_gatts_start+0x88>)
    rc = os_mempool_init(&ble_gatts_clt_cfg_pool, num_elems,
   13f44:	481e      	ldr	r0, [pc, #120]	; (13fc0 <ble_gatts_start+0x8c>)
    if (ble_gatts_num_cfgable_chrs == 0) {
        return 0;
    }

    /* Initialize client-configuration memory pool. */
    num_elems = ble_hs_cfg.max_client_configs / ble_gatts_num_cfgable_chrs;
   13f46:	8899      	ldrh	r1, [r3, #4]
    rc = os_mempool_init(&ble_gatts_clt_cfg_pool, num_elems,
   13f48:	4b1e      	ldr	r3, [pc, #120]	; (13fc4 <ble_gatts_start+0x90>)
   13f4a:	9300      	str	r3, [sp, #0]
   13f4c:	4b1e      	ldr	r3, [pc, #120]	; (13fc8 <ble_gatts_start+0x94>)
   13f4e:	fb91 f1f2 	sdiv	r1, r1, r2
   13f52:	681b      	ldr	r3, [r3, #0]
   13f54:	0092      	lsls	r2, r2, #2
   13f56:	f7f6 fa1b 	bl	a390 <os_mempool_init>
                         ble_gatts_clt_cfg_size(), ble_gatts_clt_cfg_mem,
                         "ble_gatts_clt_cfg_pool");
    if (rc != 0) {
   13f5a:	4604      	mov	r4, r0
   13f5c:	bb30      	cbnz	r0, 13fac <ble_gatts_start+0x78>
    }

    /* Allocate the cached array of handles for the configuration
     * characteristics.
     */
    ble_gatts_clt_cfgs = os_memblock_get(&ble_gatts_clt_cfg_pool);
   13f5e:	4818      	ldr	r0, [pc, #96]	; (13fc0 <ble_gatts_start+0x8c>)
   13f60:	4e1a      	ldr	r6, [pc, #104]	; (13fcc <ble_gatts_start+0x98>)
   13f62:	f7f6 fa49 	bl	a3f8 <os_memblock_get>
   13f66:	6030      	str	r0, [r6, #0]
    if (ble_gatts_clt_cfgs == NULL) {
   13f68:	b310      	cbz	r0, 13fb0 <ble_gatts_start+0x7c>
        return BLE_HS_ENOMEM;
    }

    /* Fill the cache. */
    rc = ble_uuid_16_to_128(BLE_ATT_UUID_CHARACTERISTIC, uuid128);
   13f6a:	f642 0003 	movw	r0, #10243	; 0x2803
   13f6e:	a902      	add	r1, sp, #8
   13f70:	f004 faa8 	bl	184c4 <ble_uuid_16_to_128>
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);
    idx = 0;
    ha = NULL;
   13f74:	4625      	mov	r5, r4
    while ((ha = ble_att_svr_find_by_uuid(ha, uuid128, 0xffff)) != NULL) {
   13f76:	4628      	mov	r0, r5
   13f78:	a902      	add	r1, sp, #8
   13f7a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   13f7e:	f007 fa89 	bl	1b494 <ble_att_svr_find_by_uuid>
   13f82:	4605      	mov	r5, r0
   13f84:	2800      	cmp	r0, #0
   13f86:	d0da      	beq.n	13f3e <ble_gatts_start+0xa>
   13f88:	69eb      	ldr	r3, [r5, #28]
        chr = ha->ha_cb_arg;
        allowed_flags = ble_gatts_chr_clt_cfg_allowed(chr);
   13f8a:	8a18      	ldrh	r0, [r3, #16]
   13f8c:	f7ff fcc0 	bl	13910 <ble_gatts_chr_clt_cfg_allowed.isra.0>
        if (allowed_flags != 0) {
   13f90:	2800      	cmp	r0, #0
   13f92:	d0f0      	beq.n	13f76 <ble_gatts_start+0x42>
            BLE_HS_DBG_ASSERT_EVAL(idx < ble_gatts_num_cfgable_chrs);

            ble_gatts_clt_cfgs[idx].chr_val_handle = ha->ha_handle_id + 1;
   13f94:	8aeb      	ldrh	r3, [r5, #22]
   13f96:	6831      	ldr	r1, [r6, #0]
   13f98:	3301      	adds	r3, #1
   13f9a:	eb01 0284 	add.w	r2, r1, r4, lsl #2
   13f9e:	f821 3024 	strh.w	r3, [r1, r4, lsl #2]
            ble_gatts_clt_cfgs[idx].allowed = allowed_flags;
            ble_gatts_clt_cfgs[idx].flags = 0;
   13fa2:	2300      	movs	r3, #0
        allowed_flags = ble_gatts_chr_clt_cfg_allowed(chr);
        if (allowed_flags != 0) {
            BLE_HS_DBG_ASSERT_EVAL(idx < ble_gatts_num_cfgable_chrs);

            ble_gatts_clt_cfgs[idx].chr_val_handle = ha->ha_handle_id + 1;
            ble_gatts_clt_cfgs[idx].allowed = allowed_flags;
   13fa4:	70d0      	strb	r0, [r2, #3]
            ble_gatts_clt_cfgs[idx].flags = 0;
   13fa6:	7093      	strb	r3, [r2, #2]
            idx++;
   13fa8:	3401      	adds	r4, #1
   13faa:	e7e4      	b.n	13f76 <ble_gatts_start+0x42>
    num_elems = ble_hs_cfg.max_client_configs / ble_gatts_num_cfgable_chrs;
    rc = os_mempool_init(&ble_gatts_clt_cfg_pool, num_elems,
                         ble_gatts_clt_cfg_size(), ble_gatts_clt_cfg_mem,
                         "ble_gatts_clt_cfg_pool");
    if (rc != 0) {
        return BLE_HS_EOS;
   13fac:	200b      	movs	r0, #11
   13fae:	e000      	b.n	13fb2 <ble_gatts_start+0x7e>
    /* Allocate the cached array of handles for the configuration
     * characteristics.
     */
    ble_gatts_clt_cfgs = os_memblock_get(&ble_gatts_clt_cfg_pool);
    if (ble_gatts_clt_cfgs == NULL) {
        return BLE_HS_ENOMEM;
   13fb0:	2006      	movs	r0, #6
            idx++;
        }
    }

    return 0;
}
   13fb2:	b006      	add	sp, #24
   13fb4:	bd70      	pop	{r4, r5, r6, pc}
   13fb6:	bf00      	nop
   13fb8:	200020e8 	.word	0x200020e8
   13fbc:	20003b78 	.word	0x20003b78
   13fc0:	20002100 	.word	0x20002100
   13fc4:	0001f9f8 	.word	0x0001f9f8
   13fc8:	200020fc 	.word	0x200020fc
   13fcc:	200020f8 	.word	0x200020f8

00013fd0 <ble_gatts_conn_can_alloc>:

int
ble_gatts_conn_can_alloc(void)
{
    return ble_gatts_num_cfgable_chrs == 0 ||
   13fd0:	4b05      	ldr	r3, [pc, #20]	; (13fe8 <ble_gatts_conn_can_alloc+0x18>)
   13fd2:	681b      	ldr	r3, [r3, #0]
   13fd4:	b133      	cbz	r3, 13fe4 <ble_gatts_conn_can_alloc+0x14>
           ble_gatts_clt_cfg_pool.mp_num_free > 0;
   13fd6:	4b05      	ldr	r3, [pc, #20]	; (13fec <ble_gatts_conn_can_alloc+0x1c>)
}

int
ble_gatts_conn_can_alloc(void)
{
    return ble_gatts_num_cfgable_chrs == 0 ||
   13fd8:	6898      	ldr	r0, [r3, #8]
   13fda:	2800      	cmp	r0, #0
   13fdc:	bfd4      	ite	le
   13fde:	2000      	movle	r0, #0
   13fe0:	2001      	movgt	r0, #1
   13fe2:	4770      	bx	lr
   13fe4:	2001      	movs	r0, #1
           ble_gatts_clt_cfg_pool.mp_num_free > 0;
}
   13fe6:	4770      	bx	lr
   13fe8:	200020e8 	.word	0x200020e8
   13fec:	20002100 	.word	0x20002100

00013ff0 <ble_gatts_conn_init>:

int
ble_gatts_conn_init(struct ble_gatts_conn *gatts_conn)
{
   13ff0:	b538      	push	{r3, r4, r5, lr}
    if (ble_gatts_num_cfgable_chrs > 0) {
   13ff2:	4d0c      	ldr	r5, [pc, #48]	; (14024 <ble_gatts_conn_init+0x34>)
   13ff4:	682b      	ldr	r3, [r5, #0]
   13ff6:	2b00      	cmp	r3, #0
           ble_gatts_clt_cfg_pool.mp_num_free > 0;
}

int
ble_gatts_conn_init(struct ble_gatts_conn *gatts_conn)
{
   13ff8:	4604      	mov	r4, r0
    if (ble_gatts_num_cfgable_chrs > 0) {
   13ffa:	dd0d      	ble.n	14018 <ble_gatts_conn_init+0x28>
        gatts_conn->clt_cfgs = os_memblock_get(&ble_gatts_clt_cfg_pool);
   13ffc:	480a      	ldr	r0, [pc, #40]	; (14028 <ble_gatts_conn_init+0x38>)
   13ffe:	f7f6 f9fb 	bl	a3f8 <os_memblock_get>
   14002:	6020      	str	r0, [r4, #0]
        if (gatts_conn->clt_cfgs == NULL) {
   14004:	b160      	cbz	r0, 14020 <ble_gatts_conn_init+0x30>
}

static int
ble_gatts_clt_cfg_size(void)
{
    return ble_gatts_num_cfgable_chrs * sizeof (struct ble_gatts_clt_cfg);
   14006:	682d      	ldr	r5, [r5, #0]
        if (gatts_conn->clt_cfgs == NULL) {
            return BLE_HS_ENOMEM;
        }

        /* Initialize the client configuration with a copy of the cache. */
        memcpy(gatts_conn->clt_cfgs, ble_gatts_clt_cfgs,
   14008:	4b08      	ldr	r3, [pc, #32]	; (1402c <ble_gatts_conn_init+0x3c>)
   1400a:	00aa      	lsls	r2, r5, #2
   1400c:	6819      	ldr	r1, [r3, #0]
   1400e:	f7f4 fff5 	bl	8ffc <memcpy>
               ble_gatts_clt_cfg_size());
        gatts_conn->num_clt_cfgs = ble_gatts_num_cfgable_chrs;
   14012:	6065      	str	r5, [r4, #4]
    } else {
        gatts_conn->clt_cfgs = NULL;
        gatts_conn->num_clt_cfgs = 0;
    }

    return 0;
   14014:	2000      	movs	r0, #0
   14016:	bd38      	pop	{r3, r4, r5, pc}
        /* Initialize the client configuration with a copy of the cache. */
        memcpy(gatts_conn->clt_cfgs, ble_gatts_clt_cfgs,
               ble_gatts_clt_cfg_size());
        gatts_conn->num_clt_cfgs = ble_gatts_num_cfgable_chrs;
    } else {
        gatts_conn->clt_cfgs = NULL;
   14018:	2000      	movs	r0, #0
   1401a:	6020      	str	r0, [r4, #0]
        gatts_conn->num_clt_cfgs = 0;
   1401c:	6060      	str	r0, [r4, #4]
   1401e:	bd38      	pop	{r3, r4, r5, pc}
ble_gatts_conn_init(struct ble_gatts_conn *gatts_conn)
{
    if (ble_gatts_num_cfgable_chrs > 0) {
        gatts_conn->clt_cfgs = os_memblock_get(&ble_gatts_clt_cfg_pool);
        if (gatts_conn->clt_cfgs == NULL) {
            return BLE_HS_ENOMEM;
   14020:	2006      	movs	r0, #6
        gatts_conn->clt_cfgs = NULL;
        gatts_conn->num_clt_cfgs = 0;
    }

    return 0;
}
   14022:	bd38      	pop	{r3, r4, r5, pc}
   14024:	200020e8 	.word	0x200020e8
   14028:	20002100 	.word	0x20002100
   1402c:	200020f8 	.word	0x200020f8

00014030 <ble_gatts_send_next_indicate>:
    return att_op;
}

int
ble_gatts_send_next_indicate(uint16_t conn_handle)
{
   14030:	b570      	push	{r4, r5, r6, lr}
   14032:	4606      	mov	r6, r0
    int i;

    /* Assume no pending indications. */
    chr_val_handle = 0;

    ble_hs_lock();
   14034:	f000 fb86 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   14038:	4630      	mov	r0, r6
   1403a:	f001 f92b 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   1403e:	4604      	mov	r4, r0
   14040:	b190      	cbz	r0, 14068 <ble_gatts_send_next_indicate+0x38>
        for (i = 0; i < conn->bhc_gatt_svr.num_clt_cfgs; i++) {
   14042:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
   14044:	2200      	movs	r2, #0
   14046:	4282      	cmp	r2, r0
   14048:	da0c      	bge.n	14064 <ble_gatts_send_next_indicate+0x34>
            clt_cfg = conn->bhc_gatt_svr.clt_cfgs + i;
   1404a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1404c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
            if (clt_cfg->flags & BLE_GATTS_CLT_CFG_F_MODIFIED) {
   14050:	7899      	ldrb	r1, [r3, #2]
   14052:	060d      	lsls	r5, r1, #24
   14054:	d504      	bpl.n	14060 <ble_gatts_send_next_indicate+0x30>
                                  BLE_GATTS_CLT_CFG_F_INDICATE);

                chr_val_handle = clt_cfg->chr_val_handle;

                /* Clear pending flag in anticipation of indication tx. */
                clt_cfg->flags &= ~BLE_GATTS_CLT_CFG_F_MODIFIED;
   14056:	f001 017f 	and.w	r1, r1, #127	; 0x7f
            clt_cfg = conn->bhc_gatt_svr.clt_cfgs + i;
            if (clt_cfg->flags & BLE_GATTS_CLT_CFG_F_MODIFIED) {
                BLE_HS_DBG_ASSERT(clt_cfg->flags &
                                  BLE_GATTS_CLT_CFG_F_INDICATE);

                chr_val_handle = clt_cfg->chr_val_handle;
   1405a:	881d      	ldrh	r5, [r3, #0]

                /* Clear pending flag in anticipation of indication tx. */
                clt_cfg->flags &= ~BLE_GATTS_CLT_CFG_F_MODIFIED;
   1405c:	7099      	strb	r1, [r3, #2]
                break;
   1405e:	e004      	b.n	1406a <ble_gatts_send_next_indicate+0x3a>

    ble_hs_lock();

    conn = ble_hs_conn_find(conn_handle);
    if (conn != NULL) {
        for (i = 0; i < conn->bhc_gatt_svr.num_clt_cfgs; i++) {
   14060:	3201      	adds	r2, #1
   14062:	e7f0      	b.n	14046 <ble_gatts_send_next_indicate+0x16>
    uint16_t chr_val_handle;
    int rc;
    int i;

    /* Assume no pending indications. */
    chr_val_handle = 0;
   14064:	2500      	movs	r5, #0
   14066:	e000      	b.n	1406a <ble_gatts_send_next_indicate+0x3a>
   14068:	4605      	mov	r5, r0
                break;
            }
        }
    }

    ble_hs_unlock();
   1406a:	f000 fb73 	bl	14754 <ble_hs_unlock>

    if (conn == NULL) {
   1406e:	b134      	cbz	r4, 1407e <ble_gatts_send_next_indicate+0x4e>
        return BLE_HS_ENOTCONN;
    }

    if (chr_val_handle == 0) {
   14070:	b13d      	cbz	r5, 14082 <ble_gatts_send_next_indicate+0x52>
        return BLE_HS_ENOENT;
    }

    rc = ble_gattc_indicate(conn_handle, chr_val_handle);
   14072:	4630      	mov	r0, r6
   14074:	4629      	mov	r1, r5
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   14076:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

    if (chr_val_handle == 0) {
        return BLE_HS_ENOENT;
    }

    rc = ble_gattc_indicate(conn_handle, chr_val_handle);
   1407a:	f7ff b8f9 	b.w	13270 <ble_gattc_indicate>
    }

    ble_hs_unlock();

    if (conn == NULL) {
        return BLE_HS_ENOTCONN;
   1407e:	2007      	movs	r0, #7
   14080:	bd70      	pop	{r4, r5, r6, pc}
    }

    if (chr_val_handle == 0) {
        return BLE_HS_ENOENT;
   14082:	2005      	movs	r0, #5
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   14084:	bd70      	pop	{r4, r5, r6, pc}
	...

00014088 <ble_gatts_rx_indicate_ack>:

int
ble_gatts_rx_indicate_ack(uint16_t conn_handle, uint16_t chr_val_handle)
{
   14088:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    struct ble_hs_conn *conn;
    int clt_cfg_idx;
    int persist;
    int rc;

    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   1408c:	4b29      	ldr	r3, [pc, #164]	; (14134 <ble_gatts_rx_indicate_ack+0xac>)
   1408e:	681c      	ldr	r4, [r3, #0]
    return 0;
}

int
ble_gatts_rx_indicate_ack(uint16_t conn_handle, uint16_t chr_val_handle)
{
   14090:	4680      	mov	r8, r0
    struct ble_hs_conn *conn;
    int clt_cfg_idx;
    int persist;
    int rc;

    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   14092:	4620      	mov	r0, r4
    return 0;
}

int
ble_gatts_rx_indicate_ack(uint16_t conn_handle, uint16_t chr_val_handle)
{
   14094:	460f      	mov	r7, r1
    struct ble_hs_conn *conn;
    int clt_cfg_idx;
    int persist;
    int rc;

    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   14096:	f7ff fbd9 	bl	1384c <ble_gatts_clt_cfg_find_idx>
                                             chr_val_handle);
    if (clt_cfg_idx == -1) {
   1409a:	1c42      	adds	r2, r0, #1
   1409c:	d02a      	beq.n	140f4 <ble_gatts_rx_indicate_ack+0x6c>
        /* This characteristic does not have a CCCD. */
        return BLE_HS_ENOENT;
    }

    clt_cfg = ble_gatts_clt_cfgs + clt_cfg_idx;
   1409e:	0086      	lsls	r6, r0, #2
    if (!(clt_cfg->allowed & BLE_GATTS_CLT_CFG_F_INDICATE)) {
   140a0:	4434      	add	r4, r6
   140a2:	78e3      	ldrb	r3, [r4, #3]
   140a4:	079b      	lsls	r3, r3, #30
   140a6:	d525      	bpl.n	140f4 <ble_gatts_rx_indicate_ack+0x6c>
        /* This characteristic does not allow indications. */
        return BLE_HS_ENOENT;
    }

    ble_hs_lock();
   140a8:	f000 fb4c 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   140ac:	4640      	mov	r0, r8
   140ae:	f001 f8f1 	bl	15294 <ble_hs_conn_find>
    BLE_HS_DBG_ASSERT(conn != NULL);
    if (conn->bhc_gatt_svr.indicate_val_handle == chr_val_handle) {
   140b2:	f8b0 2040 	ldrh.w	r2, [r0, #64]	; 0x40
   140b6:	42ba      	cmp	r2, r7
   140b8:	d110      	bne.n	140dc <ble_gatts_rx_indicate_ack+0x54>
         */
        BLE_HS_DBG_ASSERT(conn->bhc_gatt_svr.num_clt_cfgs > clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
        BLE_HS_DBG_ASSERT(clt_cfg->chr_val_handle == chr_val_handle);

        persist = conn->bhc_sec_state.bonded &&
   140ba:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
         * for this peer-characteristic pair.  If the characteristic has not
         * been modified since we sent the indication, there is no indication
         * pending.
         */
        BLE_HS_DBG_ASSERT(conn->bhc_gatt_svr.num_clt_cfgs > clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
   140be:	6b85      	ldr	r5, [r0, #56]	; 0x38
    if (conn->bhc_gatt_svr.indicate_val_handle == chr_val_handle) {
        /* This acknowledgement is expected. */
        rc = 0;

        /* Mark that there is no longer an outstanding txed indicate. */
        conn->bhc_gatt_svr.indicate_val_handle = 0;
   140c0:	2400      	movs	r4, #0
         */
        BLE_HS_DBG_ASSERT(conn->bhc_gatt_svr.num_clt_cfgs > clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
        BLE_HS_DBG_ASSERT(clt_cfg->chr_val_handle == chr_val_handle);

        persist = conn->bhc_sec_state.bonded &&
   140c2:	f003 0304 	and.w	r3, r3, #4
    if (conn->bhc_gatt_svr.indicate_val_handle == chr_val_handle) {
        /* This acknowledgement is expected. */
        rc = 0;

        /* Mark that there is no longer an outstanding txed indicate. */
        conn->bhc_gatt_svr.indicate_val_handle = 0;
   140c6:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40
         */
        BLE_HS_DBG_ASSERT(conn->bhc_gatt_svr.num_clt_cfgs > clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
        BLE_HS_DBG_ASSERT(clt_cfg->chr_val_handle == chr_val_handle);

        persist = conn->bhc_sec_state.bonded &&
   140ca:	f003 01ff 	and.w	r1, r3, #255	; 0xff
   140ce:	b13b      	cbz	r3, 140e0 <ble_gatts_rx_indicate_ack+0x58>
         * for this peer-characteristic pair.  If the characteristic has not
         * been modified since we sent the indication, there is no indication
         * pending.
         */
        BLE_HS_DBG_ASSERT(conn->bhc_gatt_svr.num_clt_cfgs > clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
   140d0:	442e      	add	r6, r5
        BLE_HS_DBG_ASSERT(clt_cfg->chr_val_handle == chr_val_handle);

        persist = conn->bhc_sec_state.bonded &&
   140d2:	f996 3002 	ldrsb.w	r3, [r6, #2]
   140d6:	42a3      	cmp	r3, r4
   140d8:	da12      	bge.n	14100 <ble_gatts_rx_indicate_ack+0x78>
   140da:	e002      	b.n	140e2 <ble_gatts_rx_indicate_ack+0x5a>
        }
    } else {
        /* This acknowledgement doesn't correspond to the outstanding
         * indication; ignore it.
         */
        rc = BLE_HS_ENOENT;
   140dc:	2405      	movs	r4, #5
   140de:	e001      	b.n	140e4 <ble_gatts_rx_indicate_ack+0x5c>

    conn = ble_hs_conn_find(conn_handle);
    BLE_HS_DBG_ASSERT(conn != NULL);
    if (conn->bhc_gatt_svr.indicate_val_handle == chr_val_handle) {
        /* This acknowledgement is expected. */
        rc = 0;
   140e0:	460c      	mov	r4, r1
   140e2:	4625      	mov	r5, r4
         * indication; ignore it.
         */
        rc = BLE_HS_ENOENT;
    }

    ble_hs_unlock();
   140e4:	f000 fb36 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   140e8:	b934      	cbnz	r4, 140f8 <ble_gatts_rx_indicate_ack+0x70>
        return rc;
    }

    if (persist) {
   140ea:	b13d      	cbz	r5, 140fc <ble_gatts_rx_indicate_ack+0x74>
        rc = ble_store_write_cccd(&cccd_value);
   140ec:	4668      	mov	r0, sp
   140ee:	f004 f973 	bl	183d8 <ble_store_write_cccd>
   140f2:	e001      	b.n	140f8 <ble_gatts_rx_indicate_ack+0x70>

    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
                                             chr_val_handle);
    if (clt_cfg_idx == -1) {
        /* This characteristic does not have a CCCD. */
        return BLE_HS_ENOENT;
   140f4:	2005      	movs	r0, #5
   140f6:	e01a      	b.n	1412e <ble_gatts_rx_indicate_ack+0xa6>
   140f8:	4620      	mov	r0, r4
   140fa:	e018      	b.n	1412e <ble_gatts_rx_indicate_ack+0xa6>
        if (rc != 0) {
            /* XXX: How should this error get reported? */
        }
    }

    return 0;
   140fc:	4628      	mov	r0, r5
   140fe:	e016      	b.n	1412e <ble_gatts_rx_indicate_ack+0xa6>
        BLE_HS_DBG_ASSERT(clt_cfg->chr_val_handle == chr_val_handle);

        persist = conn->bhc_sec_state.bonded &&
                  !(clt_cfg->flags & BLE_GATTS_CLT_CFG_F_MODIFIED);
        if (persist) {
            cccd_value.peer_addr_type = conn->bhc_peer_addr_type;
   14100:	7983      	ldrb	r3, [r0, #6]
   14102:	f88d 3006 	strb.w	r3, [sp, #6]
            memcpy(cccd_value.peer_addr, conn->bhc_peer_addr, 6);
   14106:	4603      	mov	r3, r0
            cccd_value.chr_val_handle = chr_val_handle;
            cccd_value.flags = clt_cfg->flags;
            cccd_value.value_changed = 0;
   14108:	2501      	movs	r5, #1

        persist = conn->bhc_sec_state.bonded &&
                  !(clt_cfg->flags & BLE_GATTS_CLT_CFG_F_MODIFIED);
        if (persist) {
            cccd_value.peer_addr_type = conn->bhc_peer_addr_type;
            memcpy(cccd_value.peer_addr, conn->bhc_peer_addr, 6);
   1410a:	f853 0f08 	ldr.w	r0, [r3, #8]!
   1410e:	9000      	str	r0, [sp, #0]
   14110:	889b      	ldrh	r3, [r3, #4]
   14112:	f8ad 3004 	strh.w	r3, [sp, #4]
            cccd_value.chr_val_handle = chr_val_handle;
   14116:	f8ad 2008 	strh.w	r2, [sp, #8]
            cccd_value.flags = clt_cfg->flags;
   1411a:	78b3      	ldrb	r3, [r6, #2]
   1411c:	f8ad 300a 	strh.w	r3, [sp, #10]
            cccd_value.value_changed = 0;
   14120:	f89d 300c 	ldrb.w	r3, [sp, #12]
   14124:	f364 0300 	bfi	r3, r4, #0, #1
   14128:	f88d 300c 	strb.w	r3, [sp, #12]
   1412c:	e7da      	b.n	140e4 <ble_gatts_rx_indicate_ack+0x5c>
            /* XXX: How should this error get reported? */
        }
    }

    return 0;
}
   1412e:	b004      	add	sp, #16
   14130:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14134:	200020f8 	.word	0x200020f8

00014138 <ble_gatts_chr_updated>:

void
ble_gatts_chr_updated(uint16_t chr_val_handle)
{
   14138:	b5f0      	push	{r4, r5, r6, r7, lr}
    int i;

    /* Determine if notifications or indications are allowed for this
     * characteristic.  If not, return immediately.
     */
    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   1413a:	4b27      	ldr	r3, [pc, #156]	; (141d8 <ble_gatts_chr_updated+0xa0>)
    return 0;
}

void
ble_gatts_chr_updated(uint16_t chr_val_handle)
{
   1413c:	4607      	mov	r7, r0
    int i;

    /* Determine if notifications or indications are allowed for this
     * characteristic.  If not, return immediately.
     */
    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   1413e:	4639      	mov	r1, r7
    return 0;
}

void
ble_gatts_chr_updated(uint16_t chr_val_handle)
{
   14140:	b089      	sub	sp, #36	; 0x24
    int i;

    /* Determine if notifications or indications are allowed for this
     * characteristic.  If not, return immediately.
     */
    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   14142:	6818      	ldr	r0, [r3, #0]
   14144:	f7ff fb82 	bl	1384c <ble_gatts_clt_cfg_find_idx>
                                             chr_val_handle);
    if (clt_cfg_idx == -1) {
   14148:	1c41      	adds	r1, r0, #1
    int i;

    /* Determine if notifications or indications are allowed for this
     * characteristic.  If not, return immediately.
     */
    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   1414a:	4604      	mov	r4, r0
                                             chr_val_handle);
    if (clt_cfg_idx == -1) {
   1414c:	d042      	beq.n	141d4 <ble_gatts_chr_updated+0x9c>
        return;
    }

    /*** Send notifications and indications to connected devices. */

    ble_hs_lock();
   1414e:	f000 faf9 	bl	14744 <ble_hs_lock>
            break;
        }

        BLE_HS_DBG_ASSERT_EVAL(conn->bhc_gatt_svr.num_clt_cfgs >
                               clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
   14152:	00a4      	lsls	r4, r4, #2
    }

    /*** Send notifications and indications to connected devices. */

    ble_hs_lock();
    for (i = 0; ; i++) {
   14154:	2600      	movs	r6, #0
        /* XXX: This is inefficient when there are a lot of connections.
         * Consider using a "foreach" function to walk the connection list.
         */
        conn = ble_hs_conn_find_by_idx(i);
   14156:	4630      	mov	r0, r6
   14158:	f001 f8c8 	bl	152ec <ble_hs_conn_find_by_idx>
        if (conn == NULL) {
   1415c:	4605      	mov	r5, r0
   1415e:	b138      	cbz	r0, 14170 <ble_gatts_chr_updated+0x38>
            break;
        }

        BLE_HS_DBG_ASSERT_EVAL(conn->bhc_gatt_svr.num_clt_cfgs >
                               clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
   14160:	6b83      	ldr	r3, [r0, #56]	; 0x38
   14162:	4423      	add	r3, r4
    }

    /*** Send notifications and indications to connected devices. */

    ble_hs_lock();
    for (i = 0; ; i++) {
   14164:	3601      	adds	r6, #1
                               clt_cfg_idx);
        clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
        BLE_HS_DBG_ASSERT_EVAL(clt_cfg->chr_val_handle == chr_val_handle);

        /* Mark the CCCD entry as modified. */
        clt_cfg->flags |= BLE_GATTS_CLT_CFG_F_MODIFIED;
   14166:	789a      	ldrb	r2, [r3, #2]
   14168:	f062 027f 	orn	r2, r2, #127	; 0x7f
   1416c:	709a      	strb	r2, [r3, #2]
        new_notifications = 1;
    }
   1416e:	e7f2      	b.n	14156 <ble_gatts_chr_updated+0x1e>
    ble_hs_unlock();
   14170:	f000 faf0 	bl	14754 <ble_hs_unlock>

    if (new_notifications) {
        ble_hs_notifications_sched();
   14174:	f000 fb82 	bl	1487c <ble_hs_notifications_sched>
    }

    /*** Persist updated flag for unconnected and not-yet-bonded devices. */

    /* Retrieve each record corresponding to the modified characteristic. */
    cccd_key.peer_addr_type = BLE_STORE_ADDR_TYPE_NONE,
   14178:	23ff      	movs	r3, #255	; 0xff
   1417a:	f88d 300a 	strb.w	r3, [sp, #10]
    cccd_key.chr_val_handle = chr_val_handle,
   1417e:	f8ad 700c 	strh.w	r7, [sp, #12]
    cccd_key.idx = 0;
   14182:	f88d 500e 	strb.w	r5, [sp, #14]

    while (1) {
        rc = ble_store_read_cccd(&cccd_key, &cccd_value);
   14186:	a801      	add	r0, sp, #4
   14188:	a904      	add	r1, sp, #16
   1418a:	f004 f91f 	bl	183cc <ble_store_read_cccd>
        if (rc != 0) {
   1418e:	bb08      	cbnz	r0, 141d4 <ble_gatts_chr_updated+0x9c>
            /* Read error or no more CCCD records. */
            break;
        }

        /* Determine if this record needs to be rewritten. */
        ble_hs_lock();
   14190:	f000 fad8 	bl	14744 <ble_hs_lock>
        conn = ble_hs_conn_find_by_addr(cccd_value.peer_addr_type,
   14194:	f89d 0016 	ldrb.w	r0, [sp, #22]
   14198:	a904      	add	r1, sp, #16
   1419a:	f001 f891 	bl	152c0 <ble_hs_conn_find_by_addr>
                                        cccd_value.peer_addr);

        if (conn == NULL) {
   1419e:	b120      	cbz	r0, 141aa <ble_gatts_chr_updated+0x72>
            /* Device isn't connected; persist the changed flag so that an
             * update can be sent when the device reconnects and rebonds.
             */
            persist = 1;
        } else if (cccd_value.flags & BLE_GATTS_CLT_CFG_F_INDICATE) {
   141a0:	f8bd 401a 	ldrh.w	r4, [sp, #26]
   141a4:	f3c4 0440 	ubfx	r4, r4, #1, #1
   141a8:	e000      	b.n	141ac <ble_gatts_chr_updated+0x74>

        if (conn == NULL) {
            /* Device isn't connected; persist the changed flag so that an
             * update can be sent when the device reconnects and rebonds.
             */
            persist = 1;
   141aa:	2401      	movs	r4, #1
             * is no need to persist.
             */
            persist = 0;
        }

        ble_hs_unlock();
   141ac:	f000 fad2 	bl	14754 <ble_hs_unlock>

        /* Only persist if the value changed flag wasn't already sent (i.e.,
         * don't overwrite with identical data).
         */
        if (persist && !cccd_value.value_changed) {
   141b0:	b154      	cbz	r4, 141c8 <ble_gatts_chr_updated+0x90>
   141b2:	f89d 301c 	ldrb.w	r3, [sp, #28]
   141b6:	07da      	lsls	r2, r3, #31
   141b8:	d406      	bmi.n	141c8 <ble_gatts_chr_updated+0x90>
            cccd_value.value_changed = 1;
   141ba:	f043 0301 	orr.w	r3, r3, #1
            ble_store_write_cccd(&cccd_value);
   141be:	a804      	add	r0, sp, #16

        /* Only persist if the value changed flag wasn't already sent (i.e.,
         * don't overwrite with identical data).
         */
        if (persist && !cccd_value.value_changed) {
            cccd_value.value_changed = 1;
   141c0:	f88d 301c 	strb.w	r3, [sp, #28]
            ble_store_write_cccd(&cccd_value);
   141c4:	f004 f908 	bl	183d8 <ble_store_write_cccd>
        }

        /* Read the next matching record. */
        cccd_key.idx++;
   141c8:	f89d 300e 	ldrb.w	r3, [sp, #14]
   141cc:	3301      	adds	r3, #1
   141ce:	f88d 300e 	strb.w	r3, [sp, #14]
   141d2:	e7d8      	b.n	14186 <ble_gatts_chr_updated+0x4e>
    }
}
   141d4:	b009      	add	sp, #36	; 0x24
   141d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   141d8:	200020f8 	.word	0x200020f8

000141dc <ble_gatts_chr_val_access>:

static int
ble_gatts_chr_val_access(uint16_t conn_handle, uint16_t attr_handle,
                         uint8_t *uuid128, uint8_t att_op,
                         struct ble_att_svr_access_ctxt *att_ctxt, void *arg)
{
   141dc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
static uint8_t
ble_gatts_chr_op(uint8_t att_op)
{
    switch (att_op) {
    case BLE_ATT_ACCESS_OP_READ:
        return BLE_GATT_ACCESS_OP_READ_CHR;
   141de:	1e9a      	subs	r2, r3, #2
   141e0:	4253      	negs	r3, r2
   141e2:	4153      	adcs	r3, r2

static int
ble_gatts_chr_val_access(uint16_t conn_handle, uint16_t attr_handle,
                         uint8_t *uuid128, uint8_t att_op,
                         struct ble_att_svr_access_ctxt *att_ctxt, void *arg)
{
   141e4:	460d      	mov	r5, r1
   141e6:	9e09      	ldr	r6, [sp, #36]	; 0x24
    int rc;

    chr_def = arg;
    BLE_HS_DBG_ASSERT(chr_def != NULL && chr_def->access_cb != NULL);

    gatt_ctxt.op = ble_gatts_chr_op(att_op);
   141e8:	f88d 3004 	strb.w	r3, [sp, #4]
   141ec:	4a10      	ldr	r2, [pc, #64]	; (14230 <ble_gatts_chr_val_access+0x54>)
}

static void
ble_gatts_chr_inc_val_stat(uint8_t gatt_op)
{
    switch (gatt_op) {
   141ee:	b91b      	cbnz	r3, 141f8 <ble_gatts_chr_val_access+0x1c>
    case BLE_GATT_ACCESS_OP_READ_CHR:
        STATS_INC(ble_gatts_stats, chr_val_reads);
   141f0:	6a53      	ldr	r3, [r2, #36]	; 0x24
   141f2:	3301      	adds	r3, #1
   141f4:	6253      	str	r3, [r2, #36]	; 0x24
   141f6:	e002      	b.n	141fe <ble_gatts_chr_val_access+0x22>
        break;

    case BLE_GATT_ACCESS_OP_WRITE_CHR:
        STATS_INC(ble_gatts_stats, chr_val_writes);
   141f8:	6a93      	ldr	r3, [r2, #40]	; 0x28
   141fa:	3301      	adds	r3, #1
   141fc:	6293      	str	r3, [r2, #40]	; 0x28

    gatt_ctxt.op = ble_gatts_chr_op(att_op);
    ble_gatts_chr_inc_val_stat(gatt_ctxt.op);

    gatt_ctxt.chr = chr_def;
    gatt_ctxt.att = att_ctxt;
   141fe:	9b08      	ldr	r3, [sp, #32]
   14200:	9303      	str	r3, [sp, #12]
    rc = chr_def->access_cb(conn_handle, attr_handle, &gatt_ctxt,
   14202:	6874      	ldr	r4, [r6, #4]
    BLE_HS_DBG_ASSERT(chr_def != NULL && chr_def->access_cb != NULL);

    gatt_ctxt.op = ble_gatts_chr_op(att_op);
    ble_gatts_chr_inc_val_stat(gatt_ctxt.op);

    gatt_ctxt.chr = chr_def;
   14204:	9602      	str	r6, [sp, #8]
    gatt_ctxt.att = att_ctxt;
    rc = chr_def->access_cb(conn_handle, attr_handle, &gatt_ctxt,
   14206:	4629      	mov	r1, r5
   14208:	aa01      	add	r2, sp, #4
   1420a:	68b3      	ldr	r3, [r6, #8]
   1420c:	47a0      	blx	r4
                            chr_def->arg);
    if (rc != 0) {
   1420e:	4604      	mov	r4, r0
   14210:	b958      	cbnz	r0, 1422a <ble_gatts_chr_val_access+0x4e>
        return rc;
    }

    if (gatt_ctxt.op == BLE_GATT_ACCESS_OP_WRITE_CHR &&
   14212:	f89d 3004 	ldrb.w	r3, [sp, #4]
   14216:	2b01      	cmp	r3, #1
   14218:	d107      	bne.n	1422a <ble_gatts_chr_val_access+0x4e>
        ble_gatts_chr_clt_cfg_allowed(chr_def)) {
   1421a:	8a30      	ldrh	r0, [r6, #16]
   1421c:	f7ff fb78 	bl	13910 <ble_gatts_chr_clt_cfg_allowed.isra.0>
                            chr_def->arg);
    if (rc != 0) {
        return rc;
    }

    if (gatt_ctxt.op == BLE_GATT_ACCESS_OP_WRITE_CHR &&
   14220:	b120      	cbz	r0, 1422c <ble_gatts_chr_val_access+0x50>
        ble_gatts_chr_clt_cfg_allowed(chr_def)) {

        ble_gatts_chr_updated(attr_handle - 1);
   14222:	1e68      	subs	r0, r5, #1
   14224:	b280      	uxth	r0, r0
   14226:	f7ff ff87 	bl	14138 <ble_gatts_chr_updated>
    }

    return 0;
   1422a:	4620      	mov	r0, r4
}
   1422c:	b004      	add	sp, #16
   1422e:	bd70      	pop	{r4, r5, r6, pc}
   14230:	20003ae8 	.word	0x20003ae8

00014234 <ble_gatts_tx_notifications>:
 * not allow more than one concurrent indication for a single peer, so this
 * function will hold off on sending such indications.
 */
void
ble_gatts_tx_notifications(void)
{
   14234:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint16_t chr_val_handle;
    int i;

    for (i = 0; i < ble_gatts_num_cfgable_chrs; i++) {
   14238:	2500      	movs	r5, #0
   1423a:	4b1d      	ldr	r3, [pc, #116]	; (142b0 <ble_gatts_tx_notifications+0x7c>)
   1423c:	681b      	ldr	r3, [r3, #0]
   1423e:	429d      	cmp	r5, r3
   14240:	da33      	bge.n	142aa <ble_gatts_tx_notifications+0x76>
        chr_val_handle = ble_gatts_clt_cfgs[i].chr_val_handle;
   14242:	4b1c      	ldr	r3, [pc, #112]	; (142b4 <ble_gatts_tx_notifications+0x80>)
   14244:	6818      	ldr	r0, [r3, #0]
   14246:	f830 8025 	ldrh.w	r8, [r0, r5, lsl #2]
    int i;

    /* Determine if notifications / indications are enabled for this
     * characteristic.
     */
    clt_cfg_idx = ble_gatts_clt_cfg_find_idx(ble_gatts_clt_cfgs,
   1424a:	4641      	mov	r1, r8
   1424c:	f7ff fafe 	bl	1384c <ble_gatts_clt_cfg_find_idx>
                                             chr_val_handle);
    if (clt_cfg_idx == -1) {
   14250:	1c43      	adds	r3, r0, #1
   14252:	d028      	beq.n	142a6 <ble_gatts_tx_notifications+0x72>

        conn = ble_hs_conn_find_by_idx(i);
        if (conn != NULL) {
            BLE_HS_DBG_ASSERT_EVAL(conn->bhc_gatt_svr.num_clt_cfgs >
                                   clt_cfg_idx);
            clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
   14254:	0086      	lsls	r6, r0, #2
   14256:	2700      	movs	r7, #0
    if (clt_cfg_idx == -1) {
        return;
    }

    for (i = 0; ; i++) {
        ble_hs_lock();
   14258:	f000 fa74 	bl	14744 <ble_hs_lock>

        conn = ble_hs_conn_find_by_idx(i);
   1425c:	4638      	mov	r0, r7
   1425e:	f001 f845 	bl	152ec <ble_hs_conn_find_by_idx>
        if (conn != NULL) {
   14262:	4604      	mov	r4, r0
   14264:	b140      	cbz	r0, 14278 <ble_gatts_tx_notifications+0x44>
            BLE_HS_DBG_ASSERT_EVAL(conn->bhc_gatt_svr.num_clt_cfgs >
                                   clt_cfg_idx);
            clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
   14266:	6b81      	ldr	r1, [r0, #56]	; 0x38
            BLE_HS_DBG_ASSERT_EVAL(clt_cfg->chr_val_handle == chr_val_handle);

            /* Determine what type of command should get sent, if any. */
            att_op = ble_gatts_schedule_update(conn, clt_cfg);
   14268:	3040      	adds	r0, #64	; 0x40
   1426a:	4431      	add	r1, r6
   1426c:	f7ff fb6c 	bl	13948 <ble_gatts_schedule_update.isra.4>
            conn_handle = conn->bhc_handle;
   14270:	f8b4 9004 	ldrh.w	r9, [r4, #4]
                                   clt_cfg_idx);
            clt_cfg = conn->bhc_gatt_svr.clt_cfgs + clt_cfg_idx;
            BLE_HS_DBG_ASSERT_EVAL(clt_cfg->chr_val_handle == chr_val_handle);

            /* Determine what type of command should get sent, if any. */
            att_op = ble_gatts_schedule_update(conn, clt_cfg);
   14274:	4682      	mov	sl, r0
   14276:	e002      	b.n	1427e <ble_gatts_tx_notifications+0x4a>
            conn_handle = conn->bhc_handle;
        } else {
            /* Silence some spurious gcc warnings. */
            att_op = 0;
   14278:	4682      	mov	sl, r0
            conn_handle = BLE_HS_CONN_HANDLE_NONE;
   1427a:	f64f 79ff 	movw	r9, #65535	; 0xffff
        }
        ble_hs_unlock();
   1427e:	f000 fa69 	bl	14754 <ble_hs_unlock>

        if (conn == NULL) {
   14282:	b184      	cbz	r4, 142a6 <ble_gatts_tx_notifications+0x72>
            /* No more connected devices. */
            break;
        }

        switch (att_op) {
   14284:	f1ba 0f1b 	cmp.w	sl, #27
   14288:	d007      	beq.n	1429a <ble_gatts_tx_notifications+0x66>
   1428a:	f1ba 0f1d 	cmp.w	sl, #29
   1428e:	d108      	bne.n	142a2 <ble_gatts_tx_notifications+0x6e>
        case BLE_ATT_OP_NOTIFY_REQ:
            ble_gattc_notify(conn_handle, chr_val_handle);
            break;

        case BLE_ATT_OP_INDICATE_REQ:
            ble_gattc_indicate(conn_handle, chr_val_handle);
   14290:	4648      	mov	r0, r9
   14292:	4641      	mov	r1, r8
   14294:	f7fe ffec 	bl	13270 <ble_gattc_indicate>
   14298:	e003      	b.n	142a2 <ble_gatts_tx_notifications+0x6e>
        switch (att_op) {
        case 0:
            break;

        case BLE_ATT_OP_NOTIFY_REQ:
            ble_gattc_notify(conn_handle, chr_val_handle);
   1429a:	4648      	mov	r0, r9
   1429c:	4641      	mov	r1, r8
   1429e:	f7fe ffd5 	bl	1324c <ble_gattc_notify>
                                             chr_val_handle);
    if (clt_cfg_idx == -1) {
        return;
    }

    for (i = 0; ; i++) {
   142a2:	3701      	adds	r7, #1
   142a4:	e7d8      	b.n	14258 <ble_gatts_tx_notifications+0x24>
ble_gatts_tx_notifications(void)
{
    uint16_t chr_val_handle;
    int i;

    for (i = 0; i < ble_gatts_num_cfgable_chrs; i++) {
   142a6:	3501      	adds	r5, #1
   142a8:	e7c7      	b.n	1423a <ble_gatts_tx_notifications+0x6>
        chr_val_handle = ble_gatts_clt_cfgs[i].chr_val_handle;
        ble_gatts_tx_notifications_one_chr(chr_val_handle);
    }
}
   142aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   142ae:	bf00      	nop
   142b0:	200020e8 	.word	0x200020e8
   142b4:	200020f8 	.word	0x200020f8

000142b8 <ble_gatts_bonding_restored>:
 *     o Sends up to one pending indication to the connected peer; schedules
 *       any remaining pending indications.
 */
void
ble_gatts_bonding_restored(uint16_t conn_handle)
{
   142b8:	b570      	push	{r4, r5, r6, lr}
   142ba:	4605      	mov	r5, r0
   142bc:	b08c      	sub	sp, #48	; 0x30
    struct ble_gatts_clt_cfg *clt_cfg;
    struct ble_hs_conn *conn;
    uint8_t att_op;
    int rc;

    ble_hs_lock();
   142be:	f000 fa41 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   142c2:	4628      	mov	r0, r5
   142c4:	f000 ffe6 	bl	15294 <ble_hs_conn_find>
    BLE_HS_DBG_ASSERT(conn != NULL);
    BLE_HS_DBG_ASSERT(conn->bhc_sec_state.bonded);

    cccd_key.peer_addr_type = conn->bhc_peer_addr_type;
   142c8:	7983      	ldrb	r3, [r0, #6]
   142ca:	f88d 301a 	strb.w	r3, [sp, #26]
    memcpy(cccd_key.peer_addr, conn->bhc_peer_addr, 6);
   142ce:	4603      	mov	r3, r0
   142d0:	f853 0f08 	ldr.w	r0, [r3, #8]!
   142d4:	9005      	str	r0, [sp, #20]
   142d6:	889b      	ldrh	r3, [r3, #4]
   142d8:	f8ad 3018 	strh.w	r3, [sp, #24]
    cccd_key.chr_val_handle = 0;
   142dc:	2300      	movs	r3, #0
   142de:	f8ad 301c 	strh.w	r3, [sp, #28]
    cccd_key.idx = 0;
   142e2:	f88d 301e 	strb.w	r3, [sp, #30]

    ble_hs_unlock();
   142e6:	f000 fa35 	bl	14754 <ble_hs_unlock>

    while (1) {
        rc = ble_store_read_cccd(&cccd_key, &cccd_value);
   142ea:	a805      	add	r0, sp, #20
   142ec:	a908      	add	r1, sp, #32
   142ee:	f004 f86d 	bl	183cc <ble_store_read_cccd>
        if (rc != 0) {
   142f2:	2800      	cmp	r0, #0
   142f4:	d153      	bne.n	1439e <ble_gatts_bonding_restored+0xe6>
        }

        /* Assume no notification or indication will get sent. */
        att_op = 0;

        ble_hs_lock();
   142f6:	f000 fa25 	bl	14744 <ble_hs_lock>

        conn = ble_hs_conn_find(conn_handle);
   142fa:	4628      	mov	r0, r5
   142fc:	f000 ffca 	bl	15294 <ble_hs_conn_find>
        BLE_HS_DBG_ASSERT(conn != NULL);

        clt_cfg = ble_gatts_clt_cfg_find(conn->bhc_gatt_svr.clt_cfgs,
   14300:	6b84      	ldr	r4, [r0, #56]	; 0x38
ble_gatts_clt_cfg_find(struct ble_gatts_clt_cfg *cfgs,
                       uint16_t chr_val_handle)
{
    int idx;

    idx = ble_gatts_clt_cfg_find_idx(cfgs, chr_val_handle);
   14302:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
        /* Assume no notification or indication will get sent. */
        att_op = 0;

        ble_hs_lock();

        conn = ble_hs_conn_find(conn_handle);
   14306:	4606      	mov	r6, r0
ble_gatts_clt_cfg_find(struct ble_gatts_clt_cfg *cfgs,
                       uint16_t chr_val_handle)
{
    int idx;

    idx = ble_gatts_clt_cfg_find_idx(cfgs, chr_val_handle);
   14308:	4620      	mov	r0, r4
   1430a:	f7ff fa9f 	bl	1384c <ble_gatts_clt_cfg_find_idx>
    if (idx == -1) {
   1430e:	1c41      	adds	r1, r0, #1
   14310:	d101      	bne.n	14316 <ble_gatts_bonding_restored+0x5e>
        if (rc != 0) {
            break;
        }

        /* Assume no notification or indication will get sent. */
        att_op = 0;
   14312:	2400      	movs	r4, #0
   14314:	e011      	b.n	1433a <ble_gatts_bonding_restored+0x82>
        conn = ble_hs_conn_find(conn_handle);
        BLE_HS_DBG_ASSERT(conn != NULL);

        clt_cfg = ble_gatts_clt_cfg_find(conn->bhc_gatt_svr.clt_cfgs,
                                         cccd_value.chr_val_handle);
        if (clt_cfg != NULL) {
   14316:	eb14 0180 	adds.w	r1, r4, r0, lsl #2
   1431a:	d0fa      	beq.n	14312 <ble_gatts_bonding_restored+0x5a>
            clt_cfg->flags = cccd_value.flags;
   1431c:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   14320:	708b      	strb	r3, [r1, #2]

            if (cccd_value.value_changed) {
   14322:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
   14326:	07d2      	lsls	r2, r2, #31
   14328:	d5f3      	bpl.n	14312 <ble_gatts_bonding_restored+0x5a>
                /* The characteristic's value changed while the device was
                 * disconnected or unbonded.  Schedule the notification or
                 * indication now.
                 */
                clt_cfg->flags |= BLE_GATTS_CLT_CFG_F_MODIFIED;
   1432a:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1432e:	708b      	strb	r3, [r1, #2]
                att_op = ble_gatts_schedule_update(conn, clt_cfg);
   14330:	f106 0040 	add.w	r0, r6, #64	; 0x40
   14334:	f7ff fb08 	bl	13948 <ble_gatts_schedule_update.isra.4>
   14338:	4604      	mov	r4, r0
            }
        }

        ble_hs_unlock();
   1433a:	f000 fa0b 	bl	14754 <ble_hs_unlock>

        /* Tell the application if the peer changed its subscription state
         * when it was restored from persistence.
         */
        ble_gatts_subscribe_event(conn_handle, cccd_value.chr_val_handle,
   1433e:	f89d 202a 	ldrb.w	r2, [sp, #42]	; 0x2a
   14342:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
static void
ble_gatts_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
                          uint8_t reason,
                          uint8_t prev_flags, uint8_t cur_flags)
{
    if (prev_flags != cur_flags) {
   14346:	b15a      	cbz	r2, 14360 <ble_gatts_bonding_restored+0xa8>
        ble_gap_subscribe_event(conn_handle,
   14348:	f002 0301 	and.w	r3, r2, #1
   1434c:	9300      	str	r3, [sp, #0]
   1434e:	f002 0202 	and.w	r2, r2, #2
   14352:	2300      	movs	r3, #0
   14354:	9202      	str	r2, [sp, #8]
   14356:	9301      	str	r3, [sp, #4]
   14358:	4628      	mov	r0, r5
   1435a:	2203      	movs	r2, #3
   1435c:	f7fe f844 	bl	123e8 <ble_gap_subscribe_event>
         */
        ble_gatts_subscribe_event(conn_handle, cccd_value.chr_val_handle,
                                  BLE_GAP_SUBSCRIBE_REASON_RESTORE,
                                  0, cccd_value.flags);

        switch (att_op) {
   14360:	2c1b      	cmp	r4, #27
   14362:	d007      	beq.n	14374 <ble_gatts_bonding_restored+0xbc>
   14364:	2c1d      	cmp	r4, #29
   14366:	d114      	bne.n	14392 <ble_gatts_bonding_restored+0xda>
                ble_store_write_cccd(&cccd_value);
            }
            break;

        case BLE_ATT_OP_INDICATE_REQ:
            ble_gattc_indicate(conn_handle, cccd_value.chr_val_handle);
   14368:	4628      	mov	r0, r5
   1436a:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
   1436e:	f7fe ff7f 	bl	13270 <ble_gattc_indicate>
            break;
   14372:	e00e      	b.n	14392 <ble_gatts_bonding_restored+0xda>
        switch (att_op) {
        case 0:
            break;

        case BLE_ATT_OP_NOTIFY_REQ:
            rc = ble_gattc_notify(conn_handle, cccd_value.chr_val_handle);
   14374:	4628      	mov	r0, r5
   14376:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
   1437a:	f7fe ff67 	bl	1324c <ble_gattc_notify>
            if (rc == 0) {
   1437e:	b940      	cbnz	r0, 14392 <ble_gatts_bonding_restored+0xda>
                cccd_value.value_changed = 0;
   14380:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   14384:	f360 0300 	bfi	r3, r0, #0, #1
                ble_store_write_cccd(&cccd_value);
   14388:	a808      	add	r0, sp, #32
            break;

        case BLE_ATT_OP_NOTIFY_REQ:
            rc = ble_gattc_notify(conn_handle, cccd_value.chr_val_handle);
            if (rc == 0) {
                cccd_value.value_changed = 0;
   1438a:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
                ble_store_write_cccd(&cccd_value);
   1438e:	f004 f823 	bl	183d8 <ble_store_write_cccd>
        default:
            BLE_HS_DBG_ASSERT(0);
            break;
        }

        cccd_key.idx++;
   14392:	f89d 301e 	ldrb.w	r3, [sp, #30]
   14396:	3301      	adds	r3, #1
   14398:	f88d 301e 	strb.w	r3, [sp, #30]
    }
   1439c:	e7a5      	b.n	142ea <ble_gatts_bonding_restored+0x32>
}
   1439e:	b00c      	add	sp, #48	; 0x30
   143a0:	bd70      	pop	{r4, r5, r6, pc}

000143a2 <ble_gatts_count_resources>:
 *                                  invalid resource definition.
 */
int
ble_gatts_count_resources(const struct ble_gatt_svc_def *svcs,
                          struct ble_gatt_resources *res)
{
   143a2:	b510      	push	{r4, lr}
    int s;
    int i;
    int c;
    int d;

    for (s = 0; svcs[s].type != BLE_GATT_SVC_TYPE_END; s++) {
   143a4:	7803      	ldrb	r3, [r0, #0]
   143a6:	b13b      	cbz	r3, 143b8 <ble_gatts_count_resources+0x16>
}

static int
ble_gatts_svc_is_sane(const struct ble_gatt_svc_def *svc)
{
    if (svc->type != BLE_GATT_SVC_TYPE_PRIMARY &&
   143a8:	3b01      	subs	r3, #1
   143aa:	2b01      	cmp	r3, #1
   143ac:	d901      	bls.n	143b2 <ble_gatts_count_resources+0x10>
    for (s = 0; svcs[s].type != BLE_GATT_SVC_TYPE_END; s++) {
        svc = svcs + s;

        if (!ble_gatts_svc_is_sane(svc)) {
            BLE_HS_DBG_ASSERT(0);
            return BLE_HS_EINVAL;
   143ae:	2003      	movs	r0, #3
   143b0:	bd10      	pop	{r4, pc}
        svc->type != BLE_GATT_SVC_TYPE_SECONDARY) {

        return 0;
    }

    if (svc->uuid128 == NULL) {
   143b2:	6843      	ldr	r3, [r0, #4]
   143b4:	b913      	cbnz	r3, 143bc <ble_gatts_count_resources+0x1a>
   143b6:	e7fa      	b.n	143ae <ble_gatts_count_resources+0xc>
                }
            }
        }
    }

    return 0;
   143b8:	4618      	mov	r0, r3
   143ba:	bd10      	pop	{r4, pc}

        /* Each service requires:
         *     o 1 service
         *     o 1 attribute
         */
        res->svcs++;
   143bc:	880b      	ldrh	r3, [r1, #0]
   143be:	3301      	adds	r3, #1
   143c0:	800b      	strh	r3, [r1, #0]
        res->attrs++;
   143c2:	894b      	ldrh	r3, [r1, #10]
   143c4:	3301      	adds	r3, #1
   143c6:	814b      	strh	r3, [r1, #10]

        if (svc->includes != NULL) {
   143c8:	6883      	ldr	r3, [r0, #8]
   143ca:	b943      	cbnz	r3, 143de <ble_gatts_count_resources+0x3c>
                res->incs++;
                res->attrs++;
            }
        }

        if (svc->characteristics != NULL) {
   143cc:	68c3      	ldr	r3, [r0, #12]
   143ce:	b123      	cbz	r3, 143da <ble_gatts_count_resources+0x38>
            for (c = 0; svc->characteristics[c].uuid128 != NULL; c++) {
   143d0:	681a      	ldr	r2, [r3, #0]
   143d2:	b112      	cbz	r2, 143da <ble_gatts_count_resources+0x38>
{
    if (chr->uuid128 == NULL) {
        return 0;
    }

    if (chr->access_cb == NULL) {
   143d4:	685a      	ldr	r2, [r3, #4]
   143d6:	b972      	cbnz	r2, 143f6 <ble_gatts_count_resources+0x54>
   143d8:	e7e9      	b.n	143ae <ble_gatts_count_resources+0xc>
   143da:	3010      	adds	r0, #16
   143dc:	e7e2      	b.n	143a4 <ble_gatts_count_resources+0x2>
   143de:	3b04      	subs	r3, #4
         */
        res->svcs++;
        res->attrs++;

        if (svc->includes != NULL) {
            for (i = 0; svc->includes[i] != NULL; i++) {
   143e0:	f853 2f04 	ldr.w	r2, [r3, #4]!
   143e4:	2a00      	cmp	r2, #0
   143e6:	d0f1      	beq.n	143cc <ble_gatts_count_resources+0x2a>
                /* Each include requires:
                 *     o 1 include
                 *     o 1 attribute
                 */
                res->incs++;
   143e8:	884a      	ldrh	r2, [r1, #2]
   143ea:	3201      	adds	r2, #1
   143ec:	804a      	strh	r2, [r1, #2]
                res->attrs++;
   143ee:	894a      	ldrh	r2, [r1, #10]
   143f0:	3201      	adds	r2, #1
   143f2:	814a      	strh	r2, [r1, #10]
   143f4:	e7f4      	b.n	143e0 <ble_gatts_count_resources+0x3e>

                /* Each characteristic requires:
                 *     o 1 characteristic
                 *     o 2 attributes
                 */
                res->chrs++;
   143f6:	888a      	ldrh	r2, [r1, #4]
   143f8:	3201      	adds	r2, #1
   143fa:	808a      	strh	r2, [r1, #4]
                res->attrs += 2;
   143fc:	894a      	ldrh	r2, [r1, #10]
   143fe:	1c94      	adds	r4, r2, #2
   14400:	814c      	strh	r4, [r1, #10]

                /* If the characteristic permits notifications or indications,
                 * it has a CCCD.
                 */
                if (chr->flags & BLE_GATT_CHR_F_NOTIFY ||
   14402:	8a1c      	ldrh	r4, [r3, #16]
   14404:	f004 0430 	and.w	r4, r4, #48	; 0x30
   14408:	b13c      	cbz	r4, 1441a <ble_gatts_count_resources+0x78>
                    /* Each CCCD requires:
                     *     o 1 descriptor
                     *     o 1 CCCD
                     *     o 1 attribute
                     */
                    res->dscs++;
   1440a:	88cc      	ldrh	r4, [r1, #6]
   1440c:	3401      	adds	r4, #1
   1440e:	80cc      	strh	r4, [r1, #6]
                    res->cccds++;
   14410:	890c      	ldrh	r4, [r1, #8]
                    res->attrs++;
   14412:	3203      	adds	r2, #3
                     *     o 1 descriptor
                     *     o 1 CCCD
                     *     o 1 attribute
                     */
                    res->dscs++;
                    res->cccds++;
   14414:	3401      	adds	r4, #1
   14416:	810c      	strh	r4, [r1, #8]
                    res->attrs++;
   14418:	814a      	strh	r2, [r1, #10]
                }

                if (chr->descriptors != NULL) {
   1441a:	68da      	ldr	r2, [r3, #12]
   1441c:	b16a      	cbz	r2, 1443a <ble_gatts_count_resources+0x98>
                    for (d = 0; chr->descriptors[d].uuid128 != NULL; d++) {
   1441e:	6814      	ldr	r4, [r2, #0]
   14420:	b15c      	cbz	r4, 1443a <ble_gatts_count_resources+0x98>
   14422:	3210      	adds	r2, #16
{
    if (dsc->uuid128 == NULL) {
        return 0;
    }

    if (dsc->access_cb == NULL) {
   14424:	f852 4c08 	ldr.w	r4, [r2, #-8]
   14428:	2c00      	cmp	r4, #0
   1442a:	d0c0      	beq.n	143ae <ble_gatts_count_resources+0xc>

                        /* Each descriptor requires:
                         *     o 1 descriptor
                         *     o 1 attribute
                         */
                        res->dscs++;
   1442c:	88cc      	ldrh	r4, [r1, #6]
   1442e:	3401      	adds	r4, #1
   14430:	80cc      	strh	r4, [r1, #6]
                        res->attrs++;
   14432:	894c      	ldrh	r4, [r1, #10]
   14434:	3401      	adds	r4, #1
   14436:	814c      	strh	r4, [r1, #10]
   14438:	e7f1      	b.n	1441e <ble_gatts_count_resources+0x7c>
   1443a:	3318      	adds	r3, #24
   1443c:	e7c8      	b.n	143d0 <ble_gatts_count_resources+0x2e>

0001443e <ble_gatts_count_cfg>:
}

int
ble_gatts_count_cfg(const struct ble_gatt_svc_def *defs,
                    struct ble_hs_cfg *cfg)
{
   1443e:	b530      	push	{r4, r5, lr}
   14440:	b085      	sub	sp, #20
   14442:	4605      	mov	r5, r0
   14444:	460c      	mov	r4, r1
    struct ble_gatt_resources res = { 0 };
   14446:	a801      	add	r0, sp, #4
   14448:	2100      	movs	r1, #0
   1444a:	220c      	movs	r2, #12
   1444c:	f7f4 fde1 	bl	9012 <memset>
    int rc;

    rc = ble_gatts_count_resources(defs, &res);
   14450:	4628      	mov	r0, r5
   14452:	a901      	add	r1, sp, #4
   14454:	f7ff ffa5 	bl	143a2 <ble_gatts_count_resources>
    if (rc != 0) {
   14458:	b988      	cbnz	r0, 1447e <ble_gatts_count_cfg+0x40>
        return rc;
    }

    cfg->max_services += res.svcs;
   1445a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
   1445e:	8863      	ldrh	r3, [r4, #2]
    cfg->max_attrs += res.attrs;

    /* Reserve an extra CCCD for the cache. */
    cfg->max_client_configs += res.cccds * (cfg->max_connections + 1);
   14460:	f9bd 100c 	ldrsh.w	r1, [sp, #12]
    rc = ble_gatts_count_resources(defs, &res);
    if (rc != 0) {
        return rc;
    }

    cfg->max_services += res.svcs;
   14464:	4413      	add	r3, r2
   14466:	8063      	strh	r3, [r4, #2]
    cfg->max_attrs += res.attrs;
   14468:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   1446c:	8923      	ldrh	r3, [r4, #8]
   1446e:	4413      	add	r3, r2
   14470:	8123      	strh	r3, [r4, #8]

    /* Reserve an extra CCCD for the cache. */
    cfg->max_client_configs += res.cccds * (cfg->max_connections + 1);
   14472:	7863      	ldrb	r3, [r4, #1]
   14474:	1c5a      	adds	r2, r3, #1
   14476:	88a3      	ldrh	r3, [r4, #4]
   14478:	fb01 3302 	mla	r3, r1, r2, r3
   1447c:	80a3      	strh	r3, [r4, #4]

    return 0;
}
   1447e:	b005      	add	sp, #20
   14480:	bd30      	pop	{r4, r5, pc}
	...

00014484 <ble_gatts_init>:
    ble_gatts_svc_entries = NULL;
}

int
ble_gatts_init(void)
{
   14484:	b513      	push	{r0, r1, r4, lr}
    int rc;

    ble_gatts_free_mem();
   14486:	f7ff fa31 	bl	138ec <ble_gatts_free_mem>
    ble_gatts_num_cfgable_chrs = 0;
   1448a:	4a16      	ldr	r2, [pc, #88]	; (144e4 <ble_gatts_init+0x60>)
   1448c:	2300      	movs	r3, #0
   1448e:	6013      	str	r3, [r2, #0]
    ble_gatts_clt_cfgs = NULL;
   14490:	4a15      	ldr	r2, [pc, #84]	; (144e8 <ble_gatts_init+0x64>)
   14492:	6013      	str	r3, [r2, #0]

    if (ble_hs_cfg.max_client_configs > 0) {
   14494:	4b15      	ldr	r3, [pc, #84]	; (144ec <ble_gatts_init+0x68>)
   14496:	8898      	ldrh	r0, [r3, #4]
   14498:	461c      	mov	r4, r3
   1449a:	b910      	cbnz	r0, 144a2 <ble_gatts_init+0x1e>
            rc = BLE_HS_ENOMEM;
            goto err;
        }
    }

    if (ble_hs_cfg.max_services > 0) {
   1449c:	8860      	ldrh	r0, [r4, #2]
   1449e:	b948      	cbnz	r0, 144b4 <ble_gatts_init+0x30>
   144a0:	e00f      	b.n	144c2 <ble_gatts_init+0x3e>
    ble_gatts_free_mem();
    ble_gatts_num_cfgable_chrs = 0;
    ble_gatts_clt_cfgs = NULL;

    if (ble_hs_cfg.max_client_configs > 0) {
        ble_gatts_clt_cfg_mem = malloc(
   144a2:	0080      	lsls	r0, r0, #2
   144a4:	f009 fab6 	bl	1da14 <malloc>
   144a8:	4b11      	ldr	r3, [pc, #68]	; (144f0 <ble_gatts_init+0x6c>)
   144aa:	6018      	str	r0, [r3, #0]
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_client_configs,
                             sizeof (struct ble_gatts_clt_cfg)));
        if (ble_gatts_clt_cfg_mem == NULL) {
   144ac:	2800      	cmp	r0, #0
   144ae:	d1f5      	bne.n	1449c <ble_gatts_init+0x18>
            rc = BLE_HS_ENOMEM;
   144b0:	2406      	movs	r4, #6
   144b2:	e011      	b.n	144d8 <ble_gatts_init+0x54>
        }
    }

    if (ble_hs_cfg.max_services > 0) {
        ble_gatts_svc_entries =
            malloc(ble_hs_cfg.max_services * sizeof *ble_gatts_svc_entries);
   144b4:	00c0      	lsls	r0, r0, #3
   144b6:	f009 faad 	bl	1da14 <malloc>
            goto err;
        }
    }

    if (ble_hs_cfg.max_services > 0) {
        ble_gatts_svc_entries =
   144ba:	4b0e      	ldr	r3, [pc, #56]	; (144f4 <ble_gatts_init+0x70>)
   144bc:	6018      	str	r0, [r3, #0]
            malloc(ble_hs_cfg.max_services * sizeof *ble_gatts_svc_entries);
        if (ble_gatts_svc_entries == NULL) {
   144be:	2800      	cmp	r0, #0
   144c0:	d0f6      	beq.n	144b0 <ble_gatts_init+0x2c>
            rc = BLE_HS_ENOMEM;
            goto err;
        }
    }

    rc = stats_init_and_reg(
   144c2:	4a0d      	ldr	r2, [pc, #52]	; (144f8 <ble_gatts_init+0x74>)
   144c4:	9201      	str	r2, [sp, #4]
   144c6:	2300      	movs	r3, #0
   144c8:	9300      	str	r3, [sp, #0]
   144ca:	480c      	ldr	r0, [pc, #48]	; (144fc <ble_gatts_init+0x78>)
   144cc:	2104      	movs	r1, #4
   144ce:	220a      	movs	r2, #10
   144d0:	f008 ff3c 	bl	1d34c <stats_init_and_reg>
        STATS_HDR(ble_gatts_stats), STATS_SIZE_INIT_PARMS(ble_gatts_stats,
        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_gatts_stats), "ble_gatts");
    if (rc != 0) {
   144d4:	b118      	cbz	r0, 144de <ble_gatts_init+0x5a>
        rc = BLE_HS_EOS;
   144d6:	240b      	movs	r4, #11
    }

    return 0;

err:
    ble_gatts_free_mem();
   144d8:	f7ff fa08 	bl	138ec <ble_gatts_free_mem>
    return rc;
   144dc:	4620      	mov	r0, r4
}
   144de:	b002      	add	sp, #8
   144e0:	bd10      	pop	{r4, pc}
   144e2:	bf00      	nop
   144e4:	200020e8 	.word	0x200020e8
   144e8:	200020f8 	.word	0x200020f8
   144ec:	20003b78 	.word	0x20003b78
   144f0:	200020fc 	.word	0x200020fc
   144f4:	200020f0 	.word	0x200020f0
   144f8:	0001fa0f 	.word	0x0001fa0f
   144fc:	20003ae8 	.word	0x20003ae8

00014500 <ble_hci_cmd_tx>:
}

int
ble_hci_cmd_tx(void *cmd, void *evt_buf, uint8_t evt_buf_len,
               uint8_t *out_evt_buf_len)
{
   14500:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14504:	4604      	mov	r4, r0
   14506:	b085      	sub	sp, #20
   14508:	460e      	mov	r6, r1
static void
ble_hci_cmd_lock(void)
{
    int rc;

    rc = os_mutex_pend(&ble_hci_cmd_mutex, 0xffffffff);
   1450a:	4842      	ldr	r0, [pc, #264]	; (14614 <ble_hci_cmd_tx+0x114>)
   1450c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
}

int
ble_hci_cmd_tx(void *cmd, void *evt_buf, uint8_t evt_buf_len,
               uint8_t *out_evt_buf_len)
{
   14510:	4690      	mov	r8, r2
   14512:	461f      	mov	r7, r3
static void
ble_hci_cmd_lock(void)
{
    int rc;

    rc = os_mutex_pend(&ble_hci_cmd_mutex, 0xffffffff);
   14514:	f7f6 faea 	bl	aaec <os_mutex_pend>
    struct ble_hci_ack ack;
    int rc;

    ble_hci_cmd_lock();

    rc = host_hci_cmd_send_buf(cmd);
   14518:	4620      	mov	r0, r4
   1451a:	f005 f81d 	bl	19558 <host_hci_cmd_send_buf>
    if (rc != 0) {
   1451e:	4604      	mov	r4, r0
   14520:	2800      	cmp	r0, #0
   14522:	d170      	bne.n	14606 <ble_hci_cmd_tx+0x106>
        rc = BLE_HS_ETIMEOUT_HCI;
    } else {
        rc = ble_hci_cmd_phony_ack_cb(host_hci_cmd_buf, 260);
    }
#else
    rc = os_sem_pend(&ble_hci_cmd_sem, BLE_HCI_CMD_TIMEOUT);
   14524:	483c      	ldr	r0, [pc, #240]	; (14618 <ble_hci_cmd_tx+0x118>)
   14526:	2180      	movs	r1, #128	; 0x80
   14528:	f00a f820 	bl	1e56c <os_sem_pend>
    switch (rc) {
   1452c:	b120      	cbz	r0, 14538 <ble_hci_cmd_tx+0x38>
        break;
    case OS_TIMEOUT:
        rc = BLE_HS_ETIMEOUT_HCI;
        break;
    default:
        rc = BLE_HS_EOS;
   1452e:	2806      	cmp	r0, #6
   14530:	bf0c      	ite	eq
   14532:	2413      	moveq	r4, #19
   14534:	240b      	movne	r4, #11
   14536:	e066      	b.n	14606 <ble_hci_cmd_tx+0x106>
     * events.  This function processes the acknowledgement event contained in
     * the command buffer.
     */

    /* Count events received */
    STATS_INC(ble_hs_stats, hci_event);
   14538:	4a38      	ldr	r2, [pc, #224]	; (1461c <ble_hci_cmd_tx+0x11c>)

    /* Display to console */
    host_hci_dbg_event_disp(host_hci_cmd_buf);
   1453a:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 14624 <ble_hci_cmd_tx+0x124>
     * events.  This function processes the acknowledgement event contained in
     * the command buffer.
     */

    /* Count events received */
    STATS_INC(ble_hs_stats, hci_event);
   1453e:	6993      	ldr	r3, [r2, #24]

    /* Display to console */
    host_hci_dbg_event_disp(host_hci_cmd_buf);
   14540:	4648      	mov	r0, r9
     * events.  This function processes the acknowledgement event contained in
     * the command buffer.
     */

    /* Count events received */
    STATS_INC(ble_hs_stats, hci_event);
   14542:	3301      	adds	r3, #1
   14544:	6193      	str	r3, [r2, #24]

    /* Display to console */
    host_hci_dbg_event_disp(host_hci_cmd_buf);
   14546:	f004 f80f 	bl	18568 <host_hci_dbg_event_disp>

    event_code = host_hci_cmd_buf[0];
   1454a:	f899 b000 	ldrb.w	fp, [r9]
    param_len = host_hci_cmd_buf[1];
   1454e:	f899 5001 	ldrb.w	r5, [r9, #1]
    event_len = param_len + 2;

    /* Clear ack fields up front to silence spurious gcc warnings. */
    memset(out_ack, 0, sizeof *out_ack);
   14552:	4668      	mov	r0, sp
   14554:	4621      	mov	r1, r4
   14556:	2210      	movs	r2, #16
    /* Display to console */
    host_hci_dbg_event_disp(host_hci_cmd_buf);

    event_code = host_hci_cmd_buf[0];
    param_len = host_hci_cmd_buf[1];
    event_len = param_len + 2;
   14558:	f105 0a02 	add.w	sl, r5, #2

    /* Clear ack fields up front to silence spurious gcc warnings. */
    memset(out_ack, 0, sizeof *out_ack);
   1455c:	f7f4 fd59 	bl	9012 <memset>

    switch (event_code) {
   14560:	f1bb 0f0e 	cmp.w	fp, #14
    /* Display to console */
    host_hci_dbg_event_disp(host_hci_cmd_buf);

    event_code = host_hci_cmd_buf[0];
    param_len = host_hci_cmd_buf[1];
    event_len = param_len + 2;
   14564:	fa5f fa8a 	uxtb.w	sl, sl

    /* Clear ack fields up front to silence spurious gcc warnings. */
    memset(out_ack, 0, sizeof *out_ack);

    switch (event_code) {
   14568:	d003      	beq.n	14572 <ble_hci_cmd_tx+0x72>
   1456a:	f1bb 0f0f 	cmp.w	fp, #15
   1456e:	d020      	beq.n	145b2 <ble_hci_cmd_tx+0xb2>
   14570:	e046      	b.n	14600 <ble_hci_cmd_tx+0x100>
    uint16_t opcode;
    uint8_t *params;
    uint8_t params_len;
    uint8_t num_pkts;

    if (len < BLE_HCI_EVENT_CMD_COMPLETE_HDR_LEN) {
   14572:	f1ba 0f04 	cmp.w	sl, #4
   14576:	d945      	bls.n	14604 <ble_hci_cmd_tx+0x104>
        /* XXX: Increment stat. */
        return BLE_HS_ECONTROLLER;
    }

    num_pkts = data[2];
    opcode = le16toh(data + 3);
   14578:	f109 0003 	add.w	r0, r9, #3
   1457c:	f008 fd87 	bl	1d08e <le16toh>
    /* XXX: Process num_pkts field. */
    (void)num_pkts;

    out_ack->bha_opcode = opcode;

    params_len = len - BLE_HCI_EVENT_CMD_COMPLETE_HDR_LEN;
   14580:	3d03      	subs	r5, #3
    if (params_len > 0) {
   14582:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
    params = data + 5;

    /* XXX: Process num_pkts field. */
    (void)num_pkts;

    out_ack->bha_opcode = opcode;
   14586:	f8ad 000c 	strh.w	r0, [sp, #12]

    params_len = len - BLE_HCI_EVENT_CMD_COMPLETE_HDR_LEN;
    if (params_len > 0) {
   1458a:	d00e      	beq.n	145aa <ble_hci_cmd_tx+0xaa>
        out_ack->bha_status = BLE_HS_HCI_ERR(params[0]);
   1458c:	f899 3005 	ldrb.w	r3, [r9, #5]
   14590:	b113      	cbz	r3, 14598 <ble_hci_cmd_tx+0x98>
   14592:	f503 7300 	add.w	r3, r3, #512	; 0x200
   14596:	e000      	b.n	1459a <ble_hci_cmd_tx+0x9a>
   14598:	4623      	mov	r3, r4
    } else {
        out_ack->bha_status = BLE_HS_ECONTROLLER;
    }

    /* Don't include the status byte in the parameters blob. */
    if (params_len > 1) {
   1459a:	2d01      	cmp	r5, #1

    out_ack->bha_opcode = opcode;

    params_len = len - BLE_HCI_EVENT_CMD_COMPLETE_HDR_LEN;
    if (params_len > 0) {
        out_ack->bha_status = BLE_HS_HCI_ERR(params[0]);
   1459c:	9300      	str	r3, [sp, #0]
    } else {
        out_ack->bha_status = BLE_HS_ECONTROLLER;
    }

    /* Don't include the status byte in the parameters blob. */
    if (params_len > 1) {
   1459e:	d019      	beq.n	145d4 <ble_hci_cmd_tx+0xd4>
        out_ack->bha_params = params + 1;
   145a0:	4b1f      	ldr	r3, [pc, #124]	; (14620 <ble_hci_cmd_tx+0x120>)
   145a2:	9301      	str	r3, [sp, #4]
        out_ack->bha_params_len = params_len - 1;
   145a4:	3d01      	subs	r5, #1
   145a6:	9502      	str	r5, [sp, #8]
   145a8:	e014      	b.n	145d4 <ble_hci_cmd_tx+0xd4>
    out_ack->bha_opcode = opcode;

    params_len = len - BLE_HCI_EVENT_CMD_COMPLETE_HDR_LEN;
    if (params_len > 0) {
        out_ack->bha_status = BLE_HS_HCI_ERR(params[0]);
    } else if (opcode == BLE_HCI_OPCODE_NOP) {
   145aa:	b198      	cbz	r0, 145d4 <ble_hci_cmd_tx+0xd4>
        out_ack->bha_status = 0;
    } else {
        out_ack->bha_status = BLE_HS_ECONTROLLER;
   145ac:	230c      	movs	r3, #12
   145ae:	9300      	str	r3, [sp, #0]
   145b0:	e010      	b.n	145d4 <ble_hci_cmd_tx+0xd4>
{
    uint16_t opcode;
    uint8_t num_pkts;
    uint8_t status;

    if (len < BLE_HCI_EVENT_CMD_STATUS_LEN) {
   145b2:	f1ba 0f05 	cmp.w	sl, #5
   145b6:	d925      	bls.n	14604 <ble_hci_cmd_tx+0x104>
        return BLE_HS_ECONTROLLER;
    }

    status = data[2];
    num_pkts = data[3];
    opcode = le16toh(data + 4);
   145b8:	f109 0004 	add.w	r0, r9, #4
    if (len < BLE_HCI_EVENT_CMD_STATUS_LEN) {
        /* XXX: Increment stat. */
        return BLE_HS_ECONTROLLER;
    }

    status = data[2];
   145bc:	f899 5002 	ldrb.w	r5, [r9, #2]
    num_pkts = data[3];
    opcode = le16toh(data + 4);
   145c0:	f008 fd65 	bl	1d08e <le16toh>

    /* XXX: Process num_pkts field. */
    (void)num_pkts;

    out_ack->bha_opcode = opcode;
   145c4:	f8ad 000c 	strh.w	r0, [sp, #12]
    out_ack->bha_params = NULL;
    out_ack->bha_params_len = 0;
    out_ack->bha_status = BLE_HS_HCI_ERR(status);
   145c8:	b115      	cbz	r5, 145d0 <ble_hci_cmd_tx+0xd0>
   145ca:	f505 7500 	add.w	r5, r5, #512	; 0x200
   145ce:	e000      	b.n	145d2 <ble_hci_cmd_tx+0xd2>
   145d0:	4625      	mov	r5, r4
   145d2:	9500      	str	r5, [sp, #0]
        rc = BLE_HS_EUNKNOWN;
        break;
    }

    if (rc == 0) {
        if (params_buf == NULL) {
   145d4:	b90e      	cbnz	r6, 145da <ble_hci_cmd_tx+0xda>
            out_ack->bha_params_len = 0;
   145d6:	9602      	str	r6, [sp, #8]
   145d8:	e00b      	b.n	145f2 <ble_hci_cmd_tx+0xf2>
        } else {
            if (out_ack->bha_params_len > params_buf_len) {
   145da:	9b02      	ldr	r3, [sp, #8]
                out_ack->bha_params_len = params_buf_len;
                rc = BLE_HS_ECONTROLLER;
            }
            memcpy(params_buf, out_ack->bha_params, out_ack->bha_params_len);
   145dc:	9901      	ldr	r1, [sp, #4]

    if (rc == 0) {
        if (params_buf == NULL) {
            out_ack->bha_params_len = 0;
        } else {
            if (out_ack->bha_params_len > params_buf_len) {
   145de:	4543      	cmp	r3, r8
                out_ack->bha_params_len = params_buf_len;
   145e0:	bfc8      	it	gt
   145e2:	f8cd 8008 	strgt.w	r8, [sp, #8]
                rc = BLE_HS_ECONTROLLER;
            }
            memcpy(params_buf, out_ack->bha_params, out_ack->bha_params_len);
   145e6:	4630      	mov	r0, r6
   145e8:	9a02      	ldr	r2, [sp, #8]
        if (params_buf == NULL) {
            out_ack->bha_params_len = 0;
        } else {
            if (out_ack->bha_params_len > params_buf_len) {
                out_ack->bha_params_len = params_buf_len;
                rc = BLE_HS_ECONTROLLER;
   145ea:	bfc8      	it	gt
   145ec:	240c      	movgt	r4, #12
            }
            memcpy(params_buf, out_ack->bha_params, out_ack->bha_params_len);
   145ee:	f7f4 fd05 	bl	8ffc <memcpy>
        }
        out_ack->bha_params = params_buf;
   145f2:	9601      	str	r6, [sp, #4]
    if (rc != 0) {
        goto done;
    }

    rc = ble_hci_cmd_process_ack(evt_buf, evt_buf_len, &ack);
    if (rc != 0) {
   145f4:	b93c      	cbnz	r4, 14606 <ble_hci_cmd_tx+0x106>
        goto done;
    }

    if (out_evt_buf_len != NULL) {
   145f6:	b10f      	cbz	r7, 145fc <ble_hci_cmd_tx+0xfc>
        *out_evt_buf_len = ack.bha_params_len;
   145f8:	9b02      	ldr	r3, [sp, #8]
   145fa:	703b      	strb	r3, [r7, #0]
    }

    rc = ack.bha_status;
   145fc:	9c00      	ldr	r4, [sp, #0]
   145fe:	e002      	b.n	14606 <ble_hci_cmd_tx+0x106>
                                       event_len, out_ack);
        break;

    default:
        BLE_HS_DBG_ASSERT(0);
        rc = BLE_HS_EUNKNOWN;
   14600:	2411      	movs	r4, #17
   14602:	e000      	b.n	14606 <ble_hci_cmd_tx+0x106>
    uint8_t params_len;
    uint8_t num_pkts;

    if (len < BLE_HCI_EVENT_CMD_COMPLETE_HDR_LEN) {
        /* XXX: Increment stat. */
        return BLE_HS_ECONTROLLER;
   14604:	240c      	movs	r4, #12
static void
ble_hci_cmd_unlock(void)
{
    int rc;

    rc = os_mutex_release(&ble_hci_cmd_mutex);
   14606:	4803      	ldr	r0, [pc, #12]	; (14614 <ble_hci_cmd_tx+0x114>)
   14608:	f7f6 fa28 	bl	aa5c <os_mutex_release>
    rc = ack.bha_status;

done:
    ble_hci_cmd_unlock();
    return rc;
}
   1460c:	4620      	mov	r0, r4
   1460e:	b005      	add	sp, #20
   14610:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14614:	20002124 	.word	0x20002124
   14618:	2000211c 	.word	0x2000211c
   1461c:	20003b1c 	.word	0x20003b1c
   14620:	20003c16 	.word	0x20003c16
   14624:	20003c10 	.word	0x20003c10

00014628 <ble_hci_cmd_tx_empty_ack>:
int
ble_hci_cmd_tx_empty_ack(void *cmd)
{
    int rc;

    rc = ble_hci_cmd_tx(cmd, NULL, 0, NULL);
   14628:	2100      	movs	r1, #0
   1462a:	460a      	mov	r2, r1
   1462c:	460b      	mov	r3, r1
   1462e:	f7ff bf67 	b.w	14500 <ble_hci_cmd_tx>
	...

00014634 <ble_hci_cmd_rx_ack>:
ble_hci_cmd_rx_ack(uint8_t *ack_ev)
{
    /* The controller should always reuse the command buffer for its acks. */
    BLE_HS_DBG_ASSERT(ack_ev == host_hci_cmd_buf);

    if (ble_hci_cmd_sem.sem_tokens != 0) {
   14634:	4802      	ldr	r0, [pc, #8]	; (14640 <ble_hci_cmd_rx_ack+0xc>)
   14636:	88c3      	ldrh	r3, [r0, #6]
   14638:	b90b      	cbnz	r3, 1463e <ble_hci_cmd_rx_ack+0xa>
    }

    /* Unblock the application now that the HCI command buffer is populated
     * with the acknowledgement.
     */
    os_sem_release(&ble_hci_cmd_sem);
   1463a:	f009 bf67 	b.w	1e50c <os_sem_release>
   1463e:	4770      	bx	lr
   14640:	2000211c 	.word	0x2000211c

00014644 <ble_hci_cmd_init>:
}

void
ble_hci_cmd_init(void)
{
   14644:	b508      	push	{r3, lr}
    int rc;

    rc = os_sem_init(&ble_hci_cmd_sem, 0);
   14646:	4804      	ldr	r0, [pc, #16]	; (14658 <ble_hci_cmd_init+0x14>)
   14648:	2100      	movs	r1, #0
   1464a:	f009 ff57 	bl	1e4fc <os_sem_init>
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    rc = os_mutex_init(&ble_hci_cmd_mutex);
   1464e:	4803      	ldr	r0, [pc, #12]	; (1465c <ble_hci_cmd_init+0x18>)
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);
}
   14650:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    int rc;

    rc = os_sem_init(&ble_hci_cmd_sem, 0);
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    rc = os_mutex_init(&ble_hci_cmd_mutex);
   14654:	f7f6 b9f8 	b.w	aa48 <os_mutex_init>
   14658:	2000211c 	.word	0x2000211c
   1465c:	20002124 	.word	0x20002124

00014660 <ble_hci_util_read_adv_tx_pwr>:
#include "host/host_hci.h"
#include "ble_hs_priv.h"

int
ble_hci_util_read_adv_tx_pwr(int8_t *out_tx_pwr)
{
   14660:	b513      	push	{r0, r1, r4, lr}
   14662:	4604      	mov	r4, r0
    uint8_t buf[BLE_HCI_CMD_HDR_LEN];
    uint8_t params_len;
    int rc;

    host_hci_cmd_build_read_adv_pwr(buf, sizeof buf);
   14664:	2103      	movs	r1, #3
   14666:	a801      	add	r0, sp, #4
   14668:	f005 f887 	bl	1977a <host_hci_cmd_build_read_adv_pwr>
    rc = ble_hci_cmd_tx(buf, out_tx_pwr, 1, &params_len);
   1466c:	a801      	add	r0, sp, #4
   1466e:	4621      	mov	r1, r4
   14670:	2201      	movs	r2, #1
   14672:	f10d 0303 	add.w	r3, sp, #3
   14676:	f7ff ff43 	bl	14500 <ble_hci_cmd_tx>
    if (rc != 0) {
   1467a:	b960      	cbnz	r0, 14696 <ble_hci_util_read_adv_tx_pwr+0x36>
        return rc;
    }

    if (params_len != 1                     ||
   1467c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   14680:	2b01      	cmp	r3, #1
   14682:	d107      	bne.n	14694 <ble_hci_util_read_adv_tx_pwr+0x34>
        *out_tx_pwr < BLE_HCI_ADV_CHAN_TXPWR_MIN ||
   14684:	7823      	ldrb	r3, [r4, #0]
   14686:	3314      	adds	r3, #20
   14688:	b2db      	uxtb	r3, r3
   1468a:	2b1e      	cmp	r3, #30
        *out_tx_pwr > BLE_HCI_ADV_CHAN_TXPWR_MAX) {

        return BLE_HS_ECONTROLLER;
    }

    return 0;
   1468c:	bf8c      	ite	hi
   1468e:	200c      	movhi	r0, #12
   14690:	2000      	movls	r0, #0
   14692:	e000      	b.n	14696 <ble_hci_util_read_adv_tx_pwr+0x36>

    if (params_len != 1                     ||
        *out_tx_pwr < BLE_HCI_ADV_CHAN_TXPWR_MIN ||
        *out_tx_pwr > BLE_HCI_ADV_CHAN_TXPWR_MAX) {

        return BLE_HS_ECONTROLLER;
   14694:	200c      	movs	r0, #12
    }

    return 0;
}
   14696:	b002      	add	sp, #8
   14698:	bd10      	pop	{r4, pc}

0001469a <ble_hci_util_rand>:

int
ble_hci_util_rand(void *dst, int len)
{
   1469a:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   1469c:	4605      	mov	r5, r0
   1469e:	460c      	mov	r4, r1
    uint8_t params_len;
    uint8_t *u8ptr;
    int chunk_sz;
    int rc;

    host_hci_cmd_build_le_rand(req_buf, sizeof req_buf);
   146a0:	a801      	add	r0, sp, #4
   146a2:	2103      	movs	r1, #3
   146a4:	f005 f8f1 	bl	1988a <host_hci_cmd_build_le_rand>

    u8ptr = dst;
    while (len > 0) {
   146a8:	2c00      	cmp	r4, #0
   146aa:	dd17      	ble.n	146dc <ble_hci_util_rand+0x42>
        rc = ble_hci_cmd_tx(req_buf, rsp_buf, sizeof rsp_buf, &params_len);
   146ac:	a801      	add	r0, sp, #4
   146ae:	a902      	add	r1, sp, #8
   146b0:	2208      	movs	r2, #8
   146b2:	f10d 0303 	add.w	r3, sp, #3
   146b6:	f7ff ff23 	bl	14500 <ble_hci_cmd_tx>
        if (rc != 0) {
   146ba:	b990      	cbnz	r0, 146e2 <ble_hci_util_rand+0x48>
            return rc;
        }
        if (params_len != sizeof rsp_buf) {
   146bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
   146c0:	2b08      	cmp	r3, #8
   146c2:	d10d      	bne.n	146e0 <ble_hci_util_rand+0x46>
            return BLE_HS_ECONTROLLER;
        }

        chunk_sz = min(len, sizeof rsp_buf);
   146c4:	2c08      	cmp	r4, #8
   146c6:	4626      	mov	r6, r4
   146c8:	bf28      	it	cs
   146ca:	2608      	movcs	r6, #8
        memcpy(u8ptr, rsp_buf, chunk_sz);
   146cc:	4628      	mov	r0, r5
   146ce:	a902      	add	r1, sp, #8
   146d0:	4632      	mov	r2, r6
   146d2:	f7f4 fc93 	bl	8ffc <memcpy>

        len -= chunk_sz;
   146d6:	1ba4      	subs	r4, r4, r6
        u8ptr += chunk_sz;
   146d8:	4435      	add	r5, r6
   146da:	e7e5      	b.n	146a8 <ble_hci_util_rand+0xe>
    }

    return 0;
   146dc:	2000      	movs	r0, #0
   146de:	e000      	b.n	146e2 <ble_hci_util_rand+0x48>
        rc = ble_hci_cmd_tx(req_buf, rsp_buf, sizeof rsp_buf, &params_len);
        if (rc != 0) {
            return rc;
        }
        if (params_len != sizeof rsp_buf) {
            return BLE_HS_ECONTROLLER;
   146e0:	200c      	movs	r0, #12
        len -= chunk_sz;
        u8ptr += chunk_sz;
    }

    return 0;
}
   146e2:	b004      	add	sp, #16
   146e4:	bd70      	pop	{r4, r5, r6, pc}

000146e6 <ble_hci_util_data_hdr_strip>:
    return 0;
}

int
ble_hci_util_data_hdr_strip(struct os_mbuf *om, struct hci_data_hdr *out_hdr)
{
   146e6:	b570      	push	{r4, r5, r6, lr}
   146e8:	460d      	mov	r5, r1
    int rc;

    rc = os_mbuf_copydata(om, 0, BLE_HCI_DATA_HDR_SZ, out_hdr);
   146ea:	2204      	movs	r2, #4
   146ec:	2100      	movs	r1, #0
   146ee:	462b      	mov	r3, r5
    return 0;
}

int
ble_hci_util_data_hdr_strip(struct os_mbuf *om, struct hci_data_hdr *out_hdr)
{
   146f0:	4606      	mov	r6, r0
    int rc;

    rc = os_mbuf_copydata(om, 0, BLE_HCI_DATA_HDR_SZ, out_hdr);
   146f2:	f7f5 fcbd 	bl	a070 <os_mbuf_copydata>
    if (rc != 0) {
   146f6:	4604      	mov	r4, r0
   146f8:	b978      	cbnz	r0, 1471a <ble_hci_util_data_hdr_strip+0x34>
        return BLE_HS_ECONTROLLER;
    }

    /* Strip HCI ACL data header from the front of the packet. */
    os_mbuf_adj(om, BLE_HCI_DATA_HDR_SZ);
   146fa:	2104      	movs	r1, #4
   146fc:	4630      	mov	r0, r6
   146fe:	f7f5 fcde 	bl	a0be <os_mbuf_adj>

    out_hdr->hdh_handle_pb_bc = le16toh(&out_hdr->hdh_handle_pb_bc);
   14702:	4628      	mov	r0, r5
   14704:	f008 fcc3 	bl	1d08e <le16toh>
   14708:	462b      	mov	r3, r5
   1470a:	f823 0b02 	strh.w	r0, [r3], #2
    out_hdr->hdh_len = le16toh(&out_hdr->hdh_len);
   1470e:	4618      	mov	r0, r3
   14710:	f008 fcbd 	bl	1d08e <le16toh>
   14714:	8068      	strh	r0, [r5, #2]

    return 0;
   14716:	4620      	mov	r0, r4
   14718:	bd70      	pop	{r4, r5, r6, pc}
{
    int rc;

    rc = os_mbuf_copydata(om, 0, BLE_HCI_DATA_HDR_SZ, out_hdr);
    if (rc != 0) {
        return BLE_HS_ECONTROLLER;
   1471a:	200c      	movs	r0, #12

    out_hdr->hdh_handle_pb_bc = le16toh(&out_hdr->hdh_handle_pb_bc);
    out_hdr->hdh_len = le16toh(&out_hdr->hdh_len);

    return 0;
}
   1471c:	bd70      	pop	{r4, r5, r6, pc}
	...

00014720 <ble_hs_free_mem>:
    return 0;
}

static void
ble_hs_free_mem(void)
{
   14720:	b538      	push	{r3, r4, r5, lr}
    free(ble_hs_hci_evt_buf);
   14722:	4c06      	ldr	r4, [pc, #24]	; (1473c <ble_hs_free_mem+0x1c>)
    ble_hs_hci_evt_buf = NULL;
   14724:	2500      	movs	r5, #0
}

static void
ble_hs_free_mem(void)
{
    free(ble_hs_hci_evt_buf);
   14726:	6820      	ldr	r0, [r4, #0]
   14728:	f009 f9be 	bl	1daa8 <free>
    ble_hs_hci_evt_buf = NULL;
   1472c:	6025      	str	r5, [r4, #0]

    free(ble_hs_hci_os_event_buf);
   1472e:	4c04      	ldr	r4, [pc, #16]	; (14740 <ble_hs_free_mem+0x20>)
   14730:	6820      	ldr	r0, [r4, #0]
   14732:	f009 f9b9 	bl	1daa8 <free>
    ble_hs_hci_os_event_buf = NULL;
   14736:	6025      	str	r5, [r4, #0]
   14738:	bd38      	pop	{r3, r4, r5, pc}
   1473a:	bf00      	nop
   1473c:	20002138 	.word	0x20002138
   14740:	20002184 	.word	0x20002184

00014744 <ble_hs_lock>:
        ble_hs_dbg_mutex_locked = 1;
        return;
    }
#endif

    rc = os_mutex_pend(&ble_hs_mutex, 0xffffffff);
   14744:	4802      	ldr	r0, [pc, #8]	; (14750 <ble_hs_lock+0xc>)
   14746:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1474a:	f7f6 b9cf 	b.w	aaec <os_mutex_pend>
   1474e:	bf00      	nop
   14750:	2000213c 	.word	0x2000213c

00014754 <ble_hs_unlock>:
        ble_hs_dbg_mutex_locked = 0;
        return;
    }
#endif

    rc = os_mutex_release(&ble_hs_mutex);
   14754:	4801      	ldr	r0, [pc, #4]	; (1475c <ble_hs_unlock+0x8>)
   14756:	f7f6 b981 	b.w	aa5c <os_mutex_release>
   1475a:	bf00      	nop
   1475c:	2000213c 	.word	0x2000213c

00014760 <ble_hs_process_tx_data_queue>:
    BLE_HS_DBG_ASSERT_EVAL(rc == 0 || rc == OS_NOT_STARTED);
}

void
ble_hs_process_tx_data_queue(void)
{
   14760:	b508      	push	{r3, lr}
    struct os_mbuf *om;

    while ((om = os_mqueue_get(&ble_hs_tx_q)) != NULL) {
   14762:	4804      	ldr	r0, [pc, #16]	; (14774 <ble_hs_process_tx_data_queue+0x14>)
   14764:	f7f5 fb66 	bl	9e34 <os_mqueue_get>
   14768:	b110      	cbz	r0, 14770 <ble_hs_process_tx_data_queue+0x10>
#ifdef PHONY_TRANSPORT
        ble_hs_test_pkt_txed(om);
#else
        ble_hci_transport_host_acl_data_send(om);
   1476a:	f7fa fd05 	bl	f178 <ble_hci_transport_host_acl_data_send>
   1476e:	e7f8      	b.n	14762 <ble_hs_process_tx_data_queue+0x2>
#endif
    }
}
   14770:	bd08      	pop	{r3, pc}
   14772:	bf00      	nop
   14774:	2000219c 	.word	0x2000219c

00014778 <ble_hs_event_handle>:
    ble_hs_heartbeat_sched(ticks_until_next);
}

static void
ble_hs_event_handle(void *unused)
{
   14778:	b570      	push	{r4, r5, r6, lr}
   1477a:	2402      	movs	r4, #2
            break;
        }
        i++;

        OS_ENTER_CRITICAL(sr);
        ev = STAILQ_FIRST(&ble_hs_evq.evq_list);
   1477c:	4d1d      	ldr	r5, [pc, #116]	; (147f4 <ble_hs_event_handle+0x7c>)
            os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);
            break;
        }
        i++;

        OS_ENTER_CRITICAL(sr);
   1477e:	f7f5 f8cf 	bl	9920 <os_arch_save_sr>
        ev = STAILQ_FIRST(&ble_hs_evq.evq_list);
   14782:	686e      	ldr	r6, [r5, #4]
        OS_EXIT_CRITICAL(sr);
   14784:	f7f5 f8d2 	bl	992c <os_arch_restore_sr>

        if (ev == NULL) {
   14788:	b396      	cbz	r6, 147f0 <ble_hs_event_handle+0x78>
            break;
        }

        ev = os_eventq_get(&ble_hs_evq);
   1478a:	4628      	mov	r0, r5
   1478c:	f7f5 fa5b 	bl	9c46 <os_eventq_get>
        switch (ev->ev_type) {
   14790:	7843      	ldrb	r3, [r0, #1]
   14792:	2b02      	cmp	r3, #2
   14794:	d022      	beq.n	147dc <ble_hs_event_handle+0x64>
   14796:	d80c      	bhi.n	147b2 <ble_hs_event_handle+0x3a>
   14798:	2b01      	cmp	r3, #1
   1479a:	d011      	beq.n	147c0 <ble_hs_event_handle+0x48>
    while (1) {
        /* If the host has already processed several consecutive events, stop
         * and return control to the parent task.  Put an event on the parent
         * task's eventq so indicate that more host events are enqueued.
         */
        if (i >= BLE_HS_MAX_EVS_IN_A_ROW) {
   1479c:	2c01      	cmp	r4, #1
   1479e:	d106      	bne.n	147ae <ble_hs_event_handle+0x36>
            os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);
   147a0:	4b15      	ldr	r3, [pc, #84]	; (147f8 <ble_hs_event_handle+0x80>)
   147a2:	4916      	ldr	r1, [pc, #88]	; (147fc <ble_hs_event_handle+0x84>)
   147a4:	6818      	ldr	r0, [r3, #0]
        default:
            BLE_HS_DBG_ASSERT(0);
            break;
        }
    }
}
   147a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        /* If the host has already processed several consecutive events, stop
         * and return control to the parent task.  Put an event on the parent
         * task's eventq so indicate that more host events are enqueued.
         */
        if (i >= BLE_HS_MAX_EVS_IN_A_ROW) {
            os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);
   147aa:	f7f5 ba22 	b.w	9bf2 <os_eventq_put>
   147ae:	2401      	movs	r4, #1
   147b0:	e7e4      	b.n	1477c <ble_hs_event_handle+0x4>
        if (ev == NULL) {
            break;
        }

        ev = os_eventq_get(&ble_hs_evq);
        switch (ev->ev_type) {
   147b2:	2b10      	cmp	r3, #16
   147b4:	d00f      	beq.n	147d6 <ble_hs_event_handle+0x5e>
   147b6:	2b11      	cmp	r3, #17
   147b8:	d1f0      	bne.n	1479c <ble_hs_event_handle+0x24>
        case BLE_HOST_HCI_EVENT_CTLR_EVENT:
            host_hci_os_event_proc(ev);
            break;

        case BLE_HS_EVENT_TX_NOTIFICATIONS:
            ble_gatts_tx_notifications();
   147ba:	f7ff fd3b 	bl	14234 <ble_gatts_tx_notifications>
   147be:	e00d      	b.n	147dc <ble_hs_event_handle+0x64>

        ev = os_eventq_get(&ble_hs_evq);
        switch (ev->ev_type) {
        case OS_EVENT_T_TIMER:
            cf = (struct os_callout_func *)ev;
            assert(cf->cf_func);
   147c0:	69c2      	ldr	r2, [r0, #28]
   147c2:	b92a      	cbnz	r2, 147d0 <ble_hs_event_handle+0x58>
   147c4:	480e      	ldr	r0, [pc, #56]	; (14800 <ble_hs_event_handle+0x88>)
   147c6:	f240 1109 	movw	r1, #265	; 0x109
   147ca:	4613      	mov	r3, r2
   147cc:	f7f5 fa80 	bl	9cd0 <__assert_func>
            cf->cf_func(ev->ev_arg);
   147d0:	6840      	ldr	r0, [r0, #4]
   147d2:	4790      	blx	r2
            break;
   147d4:	e7e2      	b.n	1479c <ble_hs_event_handle+0x24>

        case BLE_HOST_HCI_EVENT_CTLR_EVENT:
            host_hci_os_event_proc(ev);
   147d6:	f004 fd31 	bl	1923c <host_hci_os_event_proc>
            break;
   147da:	e7df      	b.n	1479c <ble_hs_event_handle+0x24>

        case BLE_HS_EVENT_TX_NOTIFICATIONS:
            ble_gatts_tx_notifications();

        case OS_EVENT_T_MQUEUE_DATA:
            ble_hs_process_tx_data_queue();
   147dc:	f7ff ffc0 	bl	14760 <ble_hs_process_tx_data_queue>
static void
ble_hs_process_rx_data_queue(void)
{
    struct os_mbuf *om;

    while ((om = os_mqueue_get(&ble_hs_rx_q)) != NULL) {
   147e0:	4808      	ldr	r0, [pc, #32]	; (14804 <ble_hs_event_handle+0x8c>)
   147e2:	f7f5 fb27 	bl	9e34 <os_mqueue_get>
   147e6:	2800      	cmp	r0, #0
   147e8:	d0d8      	beq.n	1479c <ble_hs_event_handle+0x24>
        host_hci_data_rx(om);
   147ea:	f004 fd63 	bl	192b4 <host_hci_data_rx>
   147ee:	e7f7      	b.n	147e0 <ble_hs_event_handle+0x68>
   147f0:	bd70      	pop	{r4, r5, r6, pc}
   147f2:	bf00      	nop
   147f4:	200021d0 	.word	0x200021d0
   147f8:	20002134 	.word	0x20002134
   147fc:	200021b0 	.word	0x200021b0
   14800:	0001fa19 	.word	0x0001fa19
   14804:	20002188 	.word	0x20002188

00014808 <ble_hs_heartbeat_sched>:
}

void
ble_hs_heartbeat_sched(int32_t ticks_from_now)
{
    if (ticks_from_now == BLE_HS_FOREVER) {
   14808:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   1480c:	4298      	cmp	r0, r3
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);
}

void
ble_hs_heartbeat_sched(int32_t ticks_from_now)
{
   1480e:	4601      	mov	r1, r0
    if (ticks_from_now == BLE_HS_FOREVER) {
   14810:	d009      	beq.n	14826 <ble_hs_heartbeat_sched+0x1e>
   14812:	4b05      	ldr	r3, [pc, #20]	; (14828 <ble_hs_heartbeat_sched+0x20>)
    }

    /* Reset heartbeat timer if it is not currently scheduled or if the
     * specified time is sooner than the current expiration time.
     */
    if (!os_callout_queued(&ble_hs_heartbeat_timer.cf_c) ||
   14814:	699a      	ldr	r2, [r3, #24]
   14816:	b11a      	cbz	r2, 14820 <ble_hs_heartbeat_sched+0x18>
        OS_TIME_TICK_LT(ticks_from_now, ble_hs_heartbeat_timer.cf_c.c_ticks)) {
   14818:	691b      	ldr	r3, [r3, #16]
   1481a:	1ac3      	subs	r3, r0, r3
    }

    /* Reset heartbeat timer if it is not currently scheduled or if the
     * specified time is sooner than the current expiration time.
     */
    if (!os_callout_queued(&ble_hs_heartbeat_timer.cf_c) ||
   1481c:	2b00      	cmp	r3, #0
   1481e:	da02      	bge.n	14826 <ble_hs_heartbeat_sched+0x1e>
static void
ble_hs_heartbeat_timer_reset(uint32_t ticks)
{
    int rc;

    rc = os_callout_reset(&ble_hs_heartbeat_timer.cf_c, ticks);
   14820:	4801      	ldr	r0, [pc, #4]	; (14828 <ble_hs_heartbeat_sched+0x20>)
   14822:	f7f5 b96d 	b.w	9b00 <os_callout_reset>
   14826:	4770      	bx	lr
   14828:	20002148 	.word	0x20002148

0001482c <ble_hs_heartbeat>:
 * Called once a second by the ble_hs heartbeat timer.  Handles unresponsive
 * timeouts and periodic retries in case of resource shortage.
 */
static void
ble_hs_heartbeat(void *unused)
{
   1482c:	b508      	push	{r3, lr}
    /* Ensure the timer expires at least once in the next second.
     * XXX: This is not very power efficient.  We will need separate timers for
     * each module.
     */
    ticks_until_next = BLE_HS_HEARTBEAT_OS_TICKS;
    ble_hs_heartbeat_sched(ticks_until_next);
   1482e:	2080      	movs	r0, #128	; 0x80
   14830:	f7ff ffea 	bl	14808 <ble_hs_heartbeat_sched>

    ticks_until_next = ble_gattc_heartbeat();
   14834:	f7fe fc84 	bl	13140 <ble_gattc_heartbeat>
    ble_hs_heartbeat_sched(ticks_until_next);
   14838:	f7ff ffe6 	bl	14808 <ble_hs_heartbeat_sched>

    ticks_until_next = ble_gap_heartbeat();
   1483c:	f7fd fa3e 	bl	11cbc <ble_gap_heartbeat>
    ble_hs_heartbeat_sched(ticks_until_next);
   14840:	f7ff ffe2 	bl	14808 <ble_hs_heartbeat_sched>

    ticks_until_next = ble_l2cap_sig_heartbeat();
   14844:	f001 fa3a 	bl	15cbc <ble_l2cap_sig_heartbeat>
    ble_hs_heartbeat_sched(ticks_until_next);
   14848:	f7ff ffde 	bl	14808 <ble_hs_heartbeat_sched>

    ticks_until_next = ble_sm_heartbeat();
   1484c:	f002 fce4 	bl	17218 <ble_sm_heartbeat>
    ble_hs_heartbeat_sched(ticks_until_next);
}
   14850:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

    ticks_until_next = ble_l2cap_sig_heartbeat();
    ble_hs_heartbeat_sched(ticks_until_next);

    ticks_until_next = ble_sm_heartbeat();
    ble_hs_heartbeat_sched(ticks_until_next);
   14854:	f7ff bfd8 	b.w	14808 <ble_hs_heartbeat_sched>

00014858 <ble_hs_event_enqueue>:
    }
}

void
ble_hs_event_enqueue(struct os_event *ev)
{
   14858:	b508      	push	{r3, lr}
   1485a:	4601      	mov	r1, r0
    os_eventq_put(&ble_hs_evq, ev);
   1485c:	4804      	ldr	r0, [pc, #16]	; (14870 <ble_hs_event_enqueue+0x18>)
   1485e:	f7f5 f9c8 	bl	9bf2 <os_eventq_put>
    os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);
   14862:	4b04      	ldr	r3, [pc, #16]	; (14874 <ble_hs_event_enqueue+0x1c>)
   14864:	4904      	ldr	r1, [pc, #16]	; (14878 <ble_hs_event_enqueue+0x20>)
   14866:	6818      	ldr	r0, [r3, #0]
}
   14868:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void
ble_hs_event_enqueue(struct os_event *ev)
{
    os_eventq_put(&ble_hs_evq, ev);
    os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);
   1486c:	f7f5 b9c1 	b.w	9bf2 <os_eventq_put>
   14870:	200021d0 	.word	0x200021d0
   14874:	20002134 	.word	0x20002134
   14878:	200021b0 	.word	0x200021b0

0001487c <ble_hs_notifications_sched>:
        ble_gatts_tx_notifications();
        return;
    }
#endif

    ble_hs_event_enqueue(&ble_hs_event_tx_notifications);
   1487c:	4801      	ldr	r0, [pc, #4]	; (14884 <ble_hs_notifications_sched+0x8>)
   1487e:	f7ff bfeb 	b.w	14858 <ble_hs_event_enqueue>
   14882:	bf00      	nop
   14884:	2000023c 	.word	0x2000023c

00014888 <ble_hs_start>:
 *
 * @return                      0 on success; nonzero on error.
 */
int
ble_hs_start(void)
{
   14888:	b508      	push	{r3, lr}
    int rc;

    ble_hs_parent_task = os_sched_get_current_task();
   1488a:	f7f5 fe31 	bl	a4f0 <os_sched_get_current_task>
   1488e:	4b06      	ldr	r3, [pc, #24]	; (148a8 <ble_hs_start+0x20>)
static void
ble_hs_heartbeat_timer_reset(uint32_t ticks)
{
    int rc;

    rc = os_callout_reset(&ble_hs_heartbeat_timer.cf_c, ticks);
   14890:	2180      	movs	r1, #128	; 0x80
int
ble_hs_start(void)
{
    int rc;

    ble_hs_parent_task = os_sched_get_current_task();
   14892:	6018      	str	r0, [r3, #0]
static void
ble_hs_heartbeat_timer_reset(uint32_t ticks)
{
    int rc;

    rc = os_callout_reset(&ble_hs_heartbeat_timer.cf_c, ticks);
   14894:	4805      	ldr	r0, [pc, #20]	; (148ac <ble_hs_start+0x24>)
   14896:	f7f5 f933 	bl	9b00 <os_callout_reset>

    ble_hs_parent_task = os_sched_get_current_task();

    ble_hs_heartbeat_timer_reset(BLE_HS_HEARTBEAT_OS_TICKS);

    ble_gatts_start();
   1489a:	f7ff fb4b 	bl	13f34 <ble_gatts_start>

    rc = ble_hs_startup_go();
    return rc;
}
   1489e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

    ble_hs_heartbeat_timer_reset(BLE_HS_HEARTBEAT_OS_TICKS);

    ble_gatts_start();

    rc = ble_hs_startup_go();
   148a2:	f000 bf39 	b.w	15718 <ble_hs_startup_go>
   148a6:	bf00      	nop
   148a8:	20002130 	.word	0x20002130
   148ac:	20002148 	.word	0x20002148

000148b0 <ble_hs_rx_data>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
ble_hs_rx_data(struct os_mbuf *om)
{
   148b0:	b510      	push	{r4, lr}
   148b2:	4602      	mov	r2, r0
    int rc;

    rc = os_mqueue_put(&ble_hs_rx_q, &ble_hs_evq, om);
   148b4:	4907      	ldr	r1, [pc, #28]	; (148d4 <ble_hs_rx_data+0x24>)
   148b6:	4808      	ldr	r0, [pc, #32]	; (148d8 <ble_hs_rx_data+0x28>)
   148b8:	f7f5 face 	bl	9e58 <os_mqueue_put>
    if (rc != 0) {
   148bc:	4604      	mov	r4, r0
   148be:	b930      	cbnz	r0, 148ce <ble_hs_rx_data+0x1e>
        return BLE_HS_EOS;
    }
    os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);
   148c0:	4b06      	ldr	r3, [pc, #24]	; (148dc <ble_hs_rx_data+0x2c>)
   148c2:	4907      	ldr	r1, [pc, #28]	; (148e0 <ble_hs_rx_data+0x30>)
   148c4:	6818      	ldr	r0, [r3, #0]
   148c6:	f7f5 f994 	bl	9bf2 <os_eventq_put>

    return 0;
   148ca:	4620      	mov	r0, r4
   148cc:	bd10      	pop	{r4, pc}
{
    int rc;

    rc = os_mqueue_put(&ble_hs_rx_q, &ble_hs_evq, om);
    if (rc != 0) {
        return BLE_HS_EOS;
   148ce:	200b      	movs	r0, #11
    }
    os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);

    return 0;
}
   148d0:	bd10      	pop	{r4, pc}
   148d2:	bf00      	nop
   148d4:	200021d0 	.word	0x200021d0
   148d8:	20002188 	.word	0x20002188
   148dc:	20002134 	.word	0x20002134
   148e0:	200021b0 	.word	0x200021b0

000148e4 <ble_hs_tx_data>:

int
ble_hs_tx_data(struct os_mbuf *om)
{
   148e4:	b510      	push	{r4, lr}
   148e6:	4602      	mov	r2, r0
    int rc;

    rc = os_mqueue_put(&ble_hs_tx_q, &ble_hs_evq, om);
   148e8:	4907      	ldr	r1, [pc, #28]	; (14908 <ble_hs_tx_data+0x24>)
   148ea:	4808      	ldr	r0, [pc, #32]	; (1490c <ble_hs_tx_data+0x28>)
   148ec:	f7f5 fab4 	bl	9e58 <os_mqueue_put>
    if (rc != 0) {
   148f0:	4604      	mov	r4, r0
   148f2:	b930      	cbnz	r0, 14902 <ble_hs_tx_data+0x1e>
        return BLE_HS_EOS;
    }
    os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);
   148f4:	4b06      	ldr	r3, [pc, #24]	; (14910 <ble_hs_tx_data+0x2c>)
   148f6:	4907      	ldr	r1, [pc, #28]	; (14914 <ble_hs_tx_data+0x30>)
   148f8:	6818      	ldr	r0, [r3, #0]
   148fa:	f7f5 f97a 	bl	9bf2 <os_eventq_put>

    return 0;
   148fe:	4620      	mov	r0, r4
   14900:	bd10      	pop	{r4, pc}
{
    int rc;

    rc = os_mqueue_put(&ble_hs_tx_q, &ble_hs_evq, om);
    if (rc != 0) {
        return BLE_HS_EOS;
   14902:	200b      	movs	r0, #11
    }
    os_eventq_put(ble_hs_parent_evq, &ble_hs_event_co.cf_c.c_ev);

    return 0;
}
   14904:	bd10      	pop	{r4, pc}
   14906:	bf00      	nop
   14908:	200021d0 	.word	0x200021d0
   1490c:	2000219c 	.word	0x2000219c
   14910:	20002134 	.word	0x20002134
   14914:	200021b0 	.word	0x200021b0

00014918 <ble_hs_init>:
 *                                  resource exhaustion.
 *                              Other nonzero on error.
 */
int
ble_hs_init(struct os_eventq *app_evq, struct ble_hs_cfg *cfg)
{
   14918:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1491a:	4604      	mov	r4, r0
   1491c:	460e      	mov	r6, r1
    int rc;

    ble_hs_free_mem();
   1491e:	f7ff feff 	bl	14720 <ble_hs_free_mem>

    if (app_evq == NULL) {
   14922:	2c00      	cmp	r4, #0
   14924:	f000 8095 	beq.w	14a52 <ble_hs_init+0x13a>
        rc = BLE_HS_EINVAL;
        goto err;
    }
    ble_hs_parent_evq = app_evq;
   14928:	4d4d      	ldr	r5, [pc, #308]	; (14a60 <ble_hs_init+0x148>)

    ble_hs_cfg_init(cfg);
   1492a:	4630      	mov	r0, r6

    if (app_evq == NULL) {
        rc = BLE_HS_EINVAL;
        goto err;
    }
    ble_hs_parent_evq = app_evq;
   1492c:	602c      	str	r4, [r5, #0]

    ble_hs_cfg_init(cfg);
   1492e:	f000 fbe5 	bl	150fc <ble_hs_cfg_init>

    log_init();
    log_console_handler_init(&ble_hs_log_console_handler);
    log_register("ble_hs", &ble_hs_log, &ble_hs_log_console_handler);

    ble_hs_hci_evt_buf = malloc(OS_MEMPOOL_BYTES(ble_hs_cfg.max_hci_bufs,
   14932:	4c4c      	ldr	r4, [pc, #304]	; (14a64 <ble_hs_init+0x14c>)
    }
    ble_hs_parent_evq = app_evq;

    ble_hs_cfg_init(cfg);

    log_init();
   14934:	f008 fc00 	bl	1d138 <log_init>
    log_console_handler_init(&ble_hs_log_console_handler);
   14938:	484b      	ldr	r0, [pc, #300]	; (14a68 <ble_hs_init+0x150>)
   1493a:	f008 fcb5 	bl	1d2a8 <log_console_handler_init>
    log_register("ble_hs", &ble_hs_log, &ble_hs_log_console_handler);
   1493e:	4a4a      	ldr	r2, [pc, #296]	; (14a68 <ble_hs_init+0x150>)
   14940:	494a      	ldr	r1, [pc, #296]	; (14a6c <ble_hs_init+0x154>)
   14942:	484b      	ldr	r0, [pc, #300]	; (14a70 <ble_hs_init+0x158>)
   14944:	f008 fc02 	bl	1d14c <log_register>

    ble_hs_hci_evt_buf = malloc(OS_MEMPOOL_BYTES(ble_hs_cfg.max_hci_bufs,
   14948:	7827      	ldrb	r7, [r4, #0]
   1494a:	f44f 7682 	mov.w	r6, #260	; 0x104
   1494e:	fb06 f007 	mul.w	r0, r6, r7
   14952:	f009 f85f 	bl	1da14 <malloc>
   14956:	4a47      	ldr	r2, [pc, #284]	; (14a74 <ble_hs_init+0x15c>)
   14958:	4603      	mov	r3, r0
   1495a:	6010      	str	r0, [r2, #0]
                                                 HCI_EVT_BUF_SIZE));
    if (ble_hs_hci_evt_buf == NULL) {
   1495c:	b908      	cbnz	r0, 14962 <ble_hs_init+0x4a>
        rc = BLE_HS_ENOMEM;
   1495e:	2406      	movs	r4, #6
   14960:	e078      	b.n	14a54 <ble_hs_init+0x13c>
        goto err;
    }

    /* Create memory pool of command buffers */
    rc = os_mempool_init(&g_hci_evt_pool, ble_hs_cfg.max_hci_bufs,
   14962:	4a45      	ldr	r2, [pc, #276]	; (14a78 <ble_hs_init+0x160>)
   14964:	9200      	str	r2, [sp, #0]
   14966:	4845      	ldr	r0, [pc, #276]	; (14a7c <ble_hs_init+0x164>)
   14968:	4632      	mov	r2, r6
   1496a:	4639      	mov	r1, r7
   1496c:	f7f5 fd10 	bl	a390 <os_mempool_init>
                         HCI_EVT_BUF_SIZE, ble_hs_hci_evt_buf,
                         "HCICmdPool");
    assert(rc == 0);
   14970:	4606      	mov	r6, r0
   14972:	b120      	cbz	r0, 1497e <ble_hs_init+0x66>
   14974:	4842      	ldr	r0, [pc, #264]	; (14a80 <ble_hs_init+0x168>)
   14976:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   1497a:	2200      	movs	r2, #0
   1497c:	e016      	b.n	149ac <ble_hs_init+0x94>

    ble_hs_hci_os_event_buf = malloc(OS_MEMPOOL_BYTES(ble_hs_cfg.max_hci_bufs,
   1497e:	7824      	ldrb	r4, [r4, #0]
   14980:	eb04 0044 	add.w	r0, r4, r4, lsl #1
   14984:	0080      	lsls	r0, r0, #2
   14986:	f009 f845 	bl	1da14 <malloc>
   1498a:	4a3e      	ldr	r2, [pc, #248]	; (14a84 <ble_hs_init+0x16c>)
   1498c:	4603      	mov	r3, r0
   1498e:	6010      	str	r0, [r2, #0]
                                                      HCI_OS_EVENT_BUF_SIZE));
    if (ble_hs_hci_os_event_buf == NULL) {
   14990:	2800      	cmp	r0, #0
   14992:	d0e4      	beq.n	1495e <ble_hs_init+0x46>
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    /* Create memory pool of OS events */
    rc = os_mempool_init(&g_hci_os_event_pool, ble_hs_cfg.max_hci_bufs,
   14994:	4a3c      	ldr	r2, [pc, #240]	; (14a88 <ble_hs_init+0x170>)
   14996:	9200      	str	r2, [sp, #0]
   14998:	483c      	ldr	r0, [pc, #240]	; (14a8c <ble_hs_init+0x174>)
   1499a:	4621      	mov	r1, r4
   1499c:	220c      	movs	r2, #12
   1499e:	f7f5 fcf7 	bl	a390 <os_mempool_init>
                         HCI_OS_EVENT_BUF_SIZE, ble_hs_hci_os_event_buf,
                         "HCIOsEventPool");
    assert(rc == 0);
   149a2:	b130      	cbz	r0, 149b2 <ble_hs_init+0x9a>
   149a4:	4836      	ldr	r0, [pc, #216]	; (14a80 <ble_hs_init+0x168>)
   149a6:	f240 11bb 	movw	r1, #443	; 0x1bb
   149aa:	4632      	mov	r2, r6
   149ac:	4613      	mov	r3, r2
   149ae:	f7f5 f98f 	bl	9cd0 <__assert_func>

    /* Initialize eventq */
    os_eventq_init(&ble_hs_evq);
   149b2:	4837      	ldr	r0, [pc, #220]	; (14a90 <ble_hs_init+0x178>)
   149b4:	f7f5 f914 	bl	9be0 <os_eventq_init>

    /* Initialize stats. */
    rc = stats_module_init();
   149b8:	f008 fcac 	bl	1d314 <stats_module_init>
    if (rc != 0) {
   149bc:	b108      	cbz	r0, 149c2 <ble_hs_init+0xaa>
        rc = BLE_HS_EOS;
   149be:	240b      	movs	r4, #11
   149c0:	e048      	b.n	14a54 <ble_hs_init+0x13c>
        goto err;
    }

    ble_hci_cmd_init();
   149c2:	f7ff fe3f 	bl	14644 <ble_hci_cmd_init>

    rc = ble_hs_conn_init();
   149c6:	f000 fce9 	bl	1539c <ble_hs_conn_init>
    if (rc != 0) {
   149ca:	4604      	mov	r4, r0
   149cc:	2800      	cmp	r0, #0
   149ce:	d141      	bne.n	14a54 <ble_hs_init+0x13c>
        goto err;
    }

    rc = ble_l2cap_init();
   149d0:	f001 f80c 	bl	159ec <ble_l2cap_init>
    if (rc != 0) {
   149d4:	4604      	mov	r4, r0
   149d6:	2800      	cmp	r0, #0
   149d8:	d13c      	bne.n	14a54 <ble_hs_init+0x13c>
        goto err;
    }

    rc = ble_att_init();
   149da:	f005 fa35 	bl	19e48 <ble_att_init>
    if (rc != 0) {
   149de:	4604      	mov	r4, r0
   149e0:	2800      	cmp	r0, #0
   149e2:	d137      	bne.n	14a54 <ble_hs_init+0x13c>
        goto err;
    }

    rc = ble_att_svr_init();
   149e4:	f008 f842 	bl	1ca6c <ble_att_svr_init>
    if (rc != 0) {
   149e8:	4604      	mov	r4, r0
   149ea:	2800      	cmp	r0, #0
   149ec:	d132      	bne.n	14a54 <ble_hs_init+0x13c>
        goto err;
    }

    rc = ble_gap_init();
   149ee:	f7fd fd2f 	bl	12450 <ble_gap_init>
    if (rc != 0) {
   149f2:	4604      	mov	r4, r0
   149f4:	bb70      	cbnz	r0, 14a54 <ble_hs_init+0x13c>
        goto err;
    }

    rc = ble_gattc_init();
   149f6:	f7fe fecf 	bl	13798 <ble_gattc_init>
    if (rc != 0) {
   149fa:	4604      	mov	r4, r0
   149fc:	bb50      	cbnz	r0, 14a54 <ble_hs_init+0x13c>
        goto err;
    }

    rc = ble_gatts_init();
   149fe:	f7ff fd41 	bl	14484 <ble_gatts_init>
    if (rc != 0) {
   14a02:	4604      	mov	r4, r0
   14a04:	bb30      	cbnz	r0, 14a54 <ble_hs_init+0x13c>
        goto err;
    }

    os_mqueue_init(&ble_hs_rx_q, NULL);
   14a06:	4621      	mov	r1, r4
   14a08:	4822      	ldr	r0, [pc, #136]	; (14a94 <ble_hs_init+0x17c>)
   14a0a:	f7f5 fa03 	bl	9e14 <os_mqueue_init>
    os_mqueue_init(&ble_hs_tx_q, NULL);
   14a0e:	4621      	mov	r1, r4
   14a10:	4821      	ldr	r0, [pc, #132]	; (14a98 <ble_hs_init+0x180>)
   14a12:	f7f5 f9ff 	bl	9e14 <os_mqueue_init>

    rc = stats_init_and_reg(
   14a16:	4b16      	ldr	r3, [pc, #88]	; (14a70 <ble_hs_init+0x158>)
   14a18:	9400      	str	r4, [sp, #0]
   14a1a:	9301      	str	r3, [sp, #4]
   14a1c:	481f      	ldr	r0, [pc, #124]	; (14a9c <ble_hs_init+0x184>)
   14a1e:	4623      	mov	r3, r4
   14a20:	2104      	movs	r1, #4
   14a22:	2206      	movs	r2, #6
   14a24:	f008 fc92 	bl	1d34c <stats_init_and_reg>
        STATS_HDR(ble_hs_stats), STATS_SIZE_INIT_PARMS(ble_hs_stats,
        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_hs_stats), "ble_hs");
    if (rc != 0) {
   14a28:	4604      	mov	r4, r0
   14a2a:	2800      	cmp	r0, #0
   14a2c:	d1c7      	bne.n	149be <ble_hs_init+0xa6>
        rc = BLE_HS_EOS;
        goto err;
    }

    os_callout_func_init(&ble_hs_heartbeat_timer, ble_hs_parent_evq,
   14a2e:	481c      	ldr	r0, [pc, #112]	; (14aa0 <ble_hs_init+0x188>)
   14a30:	6829      	ldr	r1, [r5, #0]
   14a32:	4a1c      	ldr	r2, [pc, #112]	; (14aa4 <ble_hs_init+0x18c>)
   14a34:	4623      	mov	r3, r4
   14a36:	f7f5 f835 	bl	9aa4 <os_callout_func_init>
                         ble_hs_heartbeat, NULL);
    os_callout_func_init(&ble_hs_event_co, &ble_hs_evq,
   14a3a:	481b      	ldr	r0, [pc, #108]	; (14aa8 <ble_hs_init+0x190>)
   14a3c:	4914      	ldr	r1, [pc, #80]	; (14a90 <ble_hs_init+0x178>)
   14a3e:	4a1b      	ldr	r2, [pc, #108]	; (14aac <ble_hs_init+0x194>)
   14a40:	4623      	mov	r3, r4
   14a42:	f7f5 f82f 	bl	9aa4 <os_callout_func_init>
                         ble_hs_event_handle, NULL);

    rc = os_mutex_init(&ble_hs_mutex);
   14a46:	481a      	ldr	r0, [pc, #104]	; (14ab0 <ble_hs_init+0x198>)
   14a48:	f7f5 fffe 	bl	aa48 <os_mutex_init>
    if (rc != 0) {
   14a4c:	2800      	cmp	r0, #0
   14a4e:	d1b6      	bne.n	149be <ble_hs_init+0xa6>
   14a50:	e003      	b.n	14a5a <ble_hs_init+0x142>
    int rc;

    ble_hs_free_mem();

    if (app_evq == NULL) {
        rc = BLE_HS_EINVAL;
   14a52:	2403      	movs	r4, #3
#endif

    return 0;

err:
    ble_hs_free_mem();
   14a54:	f7ff fe64 	bl	14720 <ble_hs_free_mem>
    return rc;
   14a58:	4620      	mov	r0, r4
}
   14a5a:	b003      	add	sp, #12
   14a5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   14a5e:	bf00      	nop
   14a60:	20002134 	.word	0x20002134
   14a64:	20003b78 	.word	0x20003b78
   14a68:	20002168 	.word	0x20002168
   14a6c:	20003b9c 	.word	0x20003b9c
   14a70:	0001fa22 	.word	0x0001fa22
   14a74:	20002138 	.word	0x20002138
   14a78:	0001fa29 	.word	0x0001fa29
   14a7c:	20003b5c 	.word	0x20003b5c
   14a80:	0001fa19 	.word	0x0001fa19
   14a84:	20002184 	.word	0x20002184
   14a88:	0001fa34 	.word	0x0001fa34
   14a8c:	20003b40 	.word	0x20003b40
   14a90:	200021d0 	.word	0x200021d0
   14a94:	20002188 	.word	0x20002188
   14a98:	2000219c 	.word	0x2000219c
   14a9c:	20003b1c 	.word	0x20003b1c
   14aa0:	20002148 	.word	0x20002148
   14aa4:	0001482d 	.word	0x0001482d
   14aa8:	200021b0 	.word	0x200021b0
   14aac:	00014779 	.word	0x00014779
   14ab0:	2000213c 	.word	0x2000213c

00014ab4 <ble_hs_adv_parse_uuids16>:
}

static int
ble_hs_adv_parse_uuids16(struct ble_hs_adv_fields *adv_fields,
                         const uint8_t *data, uint8_t data_len)
{
   14ab4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int i;

    if (data_len % 2 != 0) {
   14ab6:	f012 0401 	ands.w	r4, r2, #1
}

static int
ble_hs_adv_parse_uuids16(struct ble_hs_adv_fields *adv_fields,
                         const uint8_t *data, uint8_t data_len)
{
   14aba:	4605      	mov	r5, r0
   14abc:	460e      	mov	r6, r1
    int i;

    if (data_len % 2 != 0) {
   14abe:	d111      	bne.n	14ae4 <ble_hs_adv_parse_uuids16+0x30>
        return BLE_HS_EBADDATA;
    }

    adv_fields->uuids16 = ble_hs_adv_uuids16;
   14ac0:	4b09      	ldr	r3, [pc, #36]	; (14ae8 <ble_hs_adv_parse_uuids16+0x34>)
   14ac2:	6043      	str	r3, [r0, #4]
    adv_fields->num_uuids16 = data_len / 2;
   14ac4:	0852      	lsrs	r2, r2, #1
   14ac6:	7202      	strb	r2, [r0, #8]

    for (i = 0; i < adv_fields->num_uuids16; i++) {
   14ac8:	7a2b      	ldrb	r3, [r5, #8]
   14aca:	429c      	cmp	r4, r3
   14acc:	da08      	bge.n	14ae0 <ble_hs_adv_parse_uuids16+0x2c>
        adv_fields->uuids16[i] = le16toh(data + i * 2);
   14ace:	eb06 0044 	add.w	r0, r6, r4, lsl #1
   14ad2:	686f      	ldr	r7, [r5, #4]
   14ad4:	f008 fadb 	bl	1d08e <le16toh>
   14ad8:	f827 0014 	strh.w	r0, [r7, r4, lsl #1]
    }

    adv_fields->uuids16 = ble_hs_adv_uuids16;
    adv_fields->num_uuids16 = data_len / 2;

    for (i = 0; i < adv_fields->num_uuids16; i++) {
   14adc:	3401      	adds	r4, #1
   14ade:	e7f3      	b.n	14ac8 <ble_hs_adv_parse_uuids16+0x14>
   14ae0:	2000      	movs	r0, #0
   14ae2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                         const uint8_t *data, uint8_t data_len)
{
    int i;

    if (data_len % 2 != 0) {
        return BLE_HS_EBADDATA;
   14ae4:	200a      	movs	r0, #10
    for (i = 0; i < adv_fields->num_uuids16; i++) {
        adv_fields->uuids16[i] = le16toh(data + i * 2);
    }

    return 0;
}
   14ae6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14ae8:	200021dc 	.word	0x200021dc

00014aec <ble_hs_adv_parse_uuids32>:

static int
ble_hs_adv_parse_uuids32(struct ble_hs_adv_fields *adv_fields,
                         const uint8_t *data, uint8_t data_len)
{
   14aec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int i;

    if (data_len % 4 != 0) {
   14aee:	f012 0403 	ands.w	r4, r2, #3
}

static int
ble_hs_adv_parse_uuids32(struct ble_hs_adv_fields *adv_fields,
                         const uint8_t *data, uint8_t data_len)
{
   14af2:	4605      	mov	r5, r0
   14af4:	460e      	mov	r6, r1
    int i;

    if (data_len % 4 != 0) {
   14af6:	d111      	bne.n	14b1c <ble_hs_adv_parse_uuids32+0x30>
        return BLE_HS_EBADDATA;
    }

    adv_fields->uuids32 = ble_hs_adv_uuids32;
   14af8:	4b09      	ldr	r3, [pc, #36]	; (14b20 <ble_hs_adv_parse_uuids32+0x34>)
   14afa:	60c3      	str	r3, [r0, #12]
    adv_fields->num_uuids32 = data_len / 4;
   14afc:	0892      	lsrs	r2, r2, #2
   14afe:	7402      	strb	r2, [r0, #16]

    for (i = 0; i < adv_fields->num_uuids32; i++) {
   14b00:	7c2b      	ldrb	r3, [r5, #16]
   14b02:	429c      	cmp	r4, r3
   14b04:	da08      	bge.n	14b18 <ble_hs_adv_parse_uuids32+0x2c>
        adv_fields->uuids32[i] = le32toh(data + i * 4);
   14b06:	eb06 0084 	add.w	r0, r6, r4, lsl #2
   14b0a:	68ef      	ldr	r7, [r5, #12]
   14b0c:	f008 fac4 	bl	1d098 <le32toh>
   14b10:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    }

    adv_fields->uuids32 = ble_hs_adv_uuids32;
    adv_fields->num_uuids32 = data_len / 4;

    for (i = 0; i < adv_fields->num_uuids32; i++) {
   14b14:	3401      	adds	r4, #1
   14b16:	e7f3      	b.n	14b00 <ble_hs_adv_parse_uuids32+0x14>
   14b18:	2000      	movs	r0, #0
   14b1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                         const uint8_t *data, uint8_t data_len)
{
    int i;

    if (data_len % 4 != 0) {
        return BLE_HS_EBADDATA;
   14b1c:	200a      	movs	r0, #10
    for (i = 0; i < adv_fields->num_uuids32; i++) {
        adv_fields->uuids32[i] = le32toh(data + i * 4);
    }

    return 0;
}
   14b1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14b20:	200021f8 	.word	0x200021f8

00014b24 <ble_hs_adv_set_array16>:
}

static int
ble_hs_adv_set_array16(uint8_t type, uint8_t num_elems, const uint16_t *elems,
                       uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14b28:	9c06      	ldr	r4, [sp, #24]

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14b2a:	f89d 501c 	ldrb.w	r5, [sp, #28]
}

static int
ble_hs_adv_set_array16(uint8_t type, uint8_t num_elems, const uint16_t *elems,
                       uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14b2e:	4690      	mov	r8, r2

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14b30:	7822      	ldrb	r2, [r4, #0]
}

static int
ble_hs_adv_set_array16(uint8_t type, uint8_t num_elems, const uint16_t *elems,
                       uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14b32:	460f      	mov	r7, r1
    int rc;
    int i;

    rc = ble_hs_adv_set_hdr(type, num_elems * sizeof *elems, max_len, dst,
   14b34:	0049      	lsls	r1, r1, #1
}

static int
ble_hs_adv_set_array16(uint8_t type, uint8_t num_elems, const uint16_t *elems,
                       uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14b36:	461e      	mov	r6, r3
    int rc;
    int i;

    rc = ble_hs_adv_set_hdr(type, num_elems * sizeof *elems, max_len, dst,
   14b38:	b2c9      	uxtb	r1, r1

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14b3a:	1c93      	adds	r3, r2, #2
   14b3c:	440b      	add	r3, r1
   14b3e:	42ab      	cmp	r3, r5
   14b40:	dc18      	bgt.n	14b74 <ble_hs_adv_set_array16+0x50>
        return BLE_HS_EMSGSIZE;
    }

    dst[*dst_len] = data_len + 1;
   14b42:	3101      	adds	r1, #1
   14b44:	54b1      	strb	r1, [r6, r2]
    dst[*dst_len + 1] = type;
   14b46:	7823      	ldrb	r3, [r4, #0]
   14b48:	4433      	add	r3, r6

    *dst_len += 2;
   14b4a:	2500      	movs	r5, #0
    if (*dst_len + 2 + data_len > max_len) {
        return BLE_HS_EMSGSIZE;
    }

    dst[*dst_len] = data_len + 1;
    dst[*dst_len + 1] = type;
   14b4c:	7058      	strb	r0, [r3, #1]

    *dst_len += 2;
   14b4e:	7823      	ldrb	r3, [r4, #0]
   14b50:	3302      	adds	r3, #2
   14b52:	7023      	strb	r3, [r4, #0]
                            dst_len);
    if (rc != 0) {
        return rc;
    }

    for (i = 0; i < num_elems; i++) {
   14b54:	42bd      	cmp	r5, r7
   14b56:	da0a      	bge.n	14b6e <ble_hs_adv_set_array16+0x4a>
        htole16(dst + *dst_len, elems[i]);
   14b58:	7820      	ldrb	r0, [r4, #0]
   14b5a:	f838 1015 	ldrh.w	r1, [r8, r5, lsl #1]
   14b5e:	4430      	add	r0, r6
   14b60:	f008 fa7a 	bl	1d058 <htole16>
        *dst_len += sizeof elems[i];
   14b64:	7823      	ldrb	r3, [r4, #0]
   14b66:	3302      	adds	r3, #2
   14b68:	7023      	strb	r3, [r4, #0]
                            dst_len);
    if (rc != 0) {
        return rc;
    }

    for (i = 0; i < num_elems; i++) {
   14b6a:	3501      	adds	r5, #1
   14b6c:	e7f2      	b.n	14b54 <ble_hs_adv_set_array16+0x30>
   14b6e:	2000      	movs	r0, #0
   14b70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
        return BLE_HS_EMSGSIZE;
   14b74:	2004      	movs	r0, #4
        htole16(dst + *dst_len, elems[i]);
        *dst_len += sizeof elems[i];
    }

    return 0;
}
   14b76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00014b7a <ble_hs_adv_set_flat>:
}

int
ble_hs_adv_set_flat(uint8_t type, int data_len, const void *data,
                    uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14b7a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14b7c:	9c06      	ldr	r4, [sp, #24]

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14b7e:	f89d e01c 	ldrb.w	lr, [sp, #28]
}

int
ble_hs_adv_set_flat(uint8_t type, int data_len, const void *data,
                    uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14b82:	460f      	mov	r7, r1

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14b84:	7821      	ldrb	r1, [r4, #0]
   14b86:	b2fd      	uxtb	r5, r7
   14b88:	1c8e      	adds	r6, r1, #2
   14b8a:	442e      	add	r6, r5
   14b8c:	4576      	cmp	r6, lr
   14b8e:	dc12      	bgt.n	14bb6 <ble_hs_adv_set_flat+0x3c>
        return BLE_HS_EMSGSIZE;
    }

    dst[*dst_len] = data_len + 1;
   14b90:	1c6e      	adds	r6, r5, #1
   14b92:	545e      	strb	r6, [r3, r1]
    dst[*dst_len + 1] = type;
   14b94:	7826      	ldrb	r6, [r4, #0]
   14b96:	441e      	add	r6, r3
    rc = ble_hs_adv_set_hdr(type, data_len, max_len, dst, dst_len);
    if (rc != 0) {
        return rc;
    }

    memcpy(dst + *dst_len, data, data_len);
   14b98:	4611      	mov	r1, r2
    if (*dst_len + 2 + data_len > max_len) {
        return BLE_HS_EMSGSIZE;
    }

    dst[*dst_len] = data_len + 1;
    dst[*dst_len + 1] = type;
   14b9a:	7070      	strb	r0, [r6, #1]

    *dst_len += 2;
   14b9c:	7820      	ldrb	r0, [r4, #0]
   14b9e:	3002      	adds	r0, #2
   14ba0:	b2c0      	uxtb	r0, r0
   14ba2:	7020      	strb	r0, [r4, #0]
    rc = ble_hs_adv_set_hdr(type, data_len, max_len, dst, dst_len);
    if (rc != 0) {
        return rc;
    }

    memcpy(dst + *dst_len, data, data_len);
   14ba4:	463a      	mov	r2, r7
   14ba6:	4418      	add	r0, r3
   14ba8:	f7f4 fa28 	bl	8ffc <memcpy>
    *dst_len += data_len;
   14bac:	7823      	ldrb	r3, [r4, #0]
   14bae:	442b      	add	r3, r5
   14bb0:	7023      	strb	r3, [r4, #0]

    return 0;
   14bb2:	2000      	movs	r0, #0
   14bb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
        return BLE_HS_EMSGSIZE;
   14bb6:	2004      	movs	r0, #4

    memcpy(dst + *dst_len, data, data_len);
    *dst_len += data_len;

    return 0;
}
   14bb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00014bba <ble_hs_adv_set_fields>:
 * @return                      0 on success; nonzero on failure.
 */
int
ble_hs_adv_set_fields(const struct ble_hs_adv_fields *adv_fields,
                      uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14bba:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   14bbe:	461e      	mov	r6, r3

    uint8_t type;
    int8_t tx_pwr_lvl;
    int rc;

    *dst_len = 0;
   14bc0:	2300      	movs	r3, #0
   14bc2:	7013      	strb	r3, [r2, #0]
     * advertising being performed which is not known at this time.
     *
     * Note: The CSS prohibits advertising a flags value of 0, so this method
     * of specifying option 2 vs. 3 is sound.
     */
    if (adv_fields->flags_is_present && adv_fields->flags != 0) {
   14bc4:	7843      	ldrb	r3, [r0, #1]
   14bc6:	07db      	lsls	r3, r3, #31
 * @return                      0 on success; nonzero on failure.
 */
int
ble_hs_adv_set_fields(const struct ble_hs_adv_fields *adv_fields,
                      uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
   14bc8:	4607      	mov	r7, r0
   14bca:	460d      	mov	r5, r1
   14bcc:	4614      	mov	r4, r2
     * advertising being performed which is not known at this time.
     *
     * Note: The CSS prohibits advertising a flags value of 0, so this method
     * of specifying option 2 vs. 3 is sound.
     */
    if (adv_fields->flags_is_present && adv_fields->flags != 0) {
   14bce:	d509      	bpl.n	14be4 <ble_hs_adv_set_fields+0x2a>
   14bd0:	7803      	ldrb	r3, [r0, #0]
   14bd2:	b13b      	cbz	r3, 14be4 <ble_hs_adv_set_fields+0x2a>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_FLAGS, 1, &adv_fields->flags,
   14bd4:	2001      	movs	r0, #1
   14bd6:	e88d 0050 	stmia.w	sp, {r4, r6}
   14bda:	4601      	mov	r1, r0
   14bdc:	463a      	mov	r2, r7
   14bde:	462b      	mov	r3, r5
   14be0:	f7ff ffcb 	bl	14b7a <ble_hs_adv_set_flat>
                                 dst, dst_len, max_len);
    }

    /*** 0x02,0x03 - 16-bit service class UUIDs. */
    if (adv_fields->uuids16 != NULL && adv_fields->num_uuids16) {
   14be4:	687a      	ldr	r2, [r7, #4]
   14be6:	b92a      	cbnz	r2, 14bf4 <ble_hs_adv_set_fields+0x3a>
            return rc;
        }
    }

    /*** 0x04,0x05 - 32-bit service class UUIDs. */
    if (adv_fields->uuids32 != NULL && adv_fields->num_uuids32) {
   14be8:	f8d7 a00c 	ldr.w	sl, [r7, #12]
   14bec:	f1ba 0f00 	cmp.w	sl, #0
   14bf0:	d111      	bne.n	14c16 <ble_hs_adv_set_fields+0x5c>
   14bf2:	e015      	b.n	14c20 <ble_hs_adv_set_fields+0x66>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_FLAGS, 1, &adv_fields->flags,
                                 dst, dst_len, max_len);
    }

    /*** 0x02,0x03 - 16-bit service class UUIDs. */
    if (adv_fields->uuids16 != NULL && adv_fields->num_uuids16) {
   14bf4:	7a39      	ldrb	r1, [r7, #8]
   14bf6:	2900      	cmp	r1, #0
   14bf8:	d0f6      	beq.n	14be8 <ble_hs_adv_set_fields+0x2e>
        if (adv_fields->uuids16_is_complete) {
   14bfa:	7a7b      	ldrb	r3, [r7, #9]
            type = BLE_HS_ADV_TYPE_COMP_UUIDS16;
        } else {
            type = BLE_HS_ADV_TYPE_INCOMP_UUIDS16;
   14bfc:	f013 0f01 	tst.w	r3, #1
        }

        rc = ble_hs_adv_set_array16(type, adv_fields->num_uuids16,
   14c00:	bf14      	ite	ne
   14c02:	2003      	movne	r0, #3
   14c04:	2002      	moveq	r0, #2
   14c06:	e88d 0050 	stmia.w	sp, {r4, r6}
   14c0a:	462b      	mov	r3, r5
   14c0c:	f7ff ff8a 	bl	14b24 <ble_hs_adv_set_array16>
                                    adv_fields->uuids16, dst, dst_len,
                                    max_len);
        if (rc != 0) {
   14c10:	2800      	cmp	r0, #0
   14c12:	d0e9      	beq.n	14be8 <ble_hs_adv_set_fields+0x2e>
   14c14:	e111      	b.n	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x04,0x05 - 32-bit service class UUIDs. */
    if (adv_fields->uuids32 != NULL && adv_fields->num_uuids32) {
   14c16:	f897 9010 	ldrb.w	r9, [r7, #16]
   14c1a:	f1b9 0f00 	cmp.w	r9, #0
   14c1e:	d102      	bne.n	14c26 <ble_hs_adv_set_fields+0x6c>
            return rc;
        }
    }

    /*** 0x06,0x07 - 128-bit service class UUIDs. */
    if (adv_fields->uuids128 != NULL && adv_fields->num_uuids128 > 0) {
   14c20:	697a      	ldr	r2, [r7, #20]
   14c22:	bb42      	cbnz	r2, 14c76 <ble_hs_adv_set_fields+0xbc>
   14c24:	e029      	b.n	14c7a <ble_hs_adv_set_fields+0xc0>
        }
    }

    /*** 0x04,0x05 - 32-bit service class UUIDs. */
    if (adv_fields->uuids32 != NULL && adv_fields->num_uuids32) {
        if (adv_fields->uuids32_is_complete) {
   14c26:	7c7b      	ldrb	r3, [r7, #17]

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14c28:	7820      	ldrb	r0, [r4, #0]
    /*** 0x04,0x05 - 32-bit service class UUIDs. */
    if (adv_fields->uuids32 != NULL && adv_fields->num_uuids32) {
        if (adv_fields->uuids32_is_complete) {
            type = BLE_HS_ADV_TYPE_COMP_UUIDS32;
        } else {
            type = BLE_HS_ADV_TYPE_INCOMP_UUIDS32;
   14c2a:	f013 0f01 	tst.w	r3, #1
                       uint8_t *dst, uint8_t *dst_len, uint8_t max_len)
{
    int rc;
    int i;

    rc = ble_hs_adv_set_hdr(type, num_elems * sizeof *elems, max_len, dst,
   14c2e:	ea4f 0389 	mov.w	r3, r9, lsl #2
   14c32:	b2db      	uxtb	r3, r3

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14c34:	f100 0202 	add.w	r2, r0, #2
   14c38:	441a      	add	r2, r3
    /*** 0x04,0x05 - 32-bit service class UUIDs. */
    if (adv_fields->uuids32 != NULL && adv_fields->num_uuids32) {
        if (adv_fields->uuids32_is_complete) {
            type = BLE_HS_ADV_TYPE_COMP_UUIDS32;
        } else {
            type = BLE_HS_ADV_TYPE_INCOMP_UUIDS32;
   14c3a:	bf14      	ite	ne
   14c3c:	2105      	movne	r1, #5
   14c3e:	2104      	moveq	r1, #4

static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
   14c40:	42b2      	cmp	r2, r6
   14c42:	f300 80f9 	bgt.w	14e38 <ble_hs_adv_set_fields+0x27e>
        return BLE_HS_EMSGSIZE;
    }

    dst[*dst_len] = data_len + 1;
   14c46:	3301      	adds	r3, #1
   14c48:	542b      	strb	r3, [r5, r0]
    dst[*dst_len + 1] = type;
   14c4a:	7823      	ldrb	r3, [r4, #0]
   14c4c:	442b      	add	r3, r5

    *dst_len += 2;
   14c4e:	f04f 0800 	mov.w	r8, #0
    if (*dst_len + 2 + data_len > max_len) {
        return BLE_HS_EMSGSIZE;
    }

    dst[*dst_len] = data_len + 1;
    dst[*dst_len + 1] = type;
   14c52:	7059      	strb	r1, [r3, #1]

    *dst_len += 2;
   14c54:	7823      	ldrb	r3, [r4, #0]
   14c56:	3302      	adds	r3, #2
   14c58:	7023      	strb	r3, [r4, #0]
                            dst_len);
    if (rc != 0) {
        return rc;
    }

    for (i = 0; i < num_elems; i++) {
   14c5a:	45c8      	cmp	r8, r9
   14c5c:	dae0      	bge.n	14c20 <ble_hs_adv_set_fields+0x66>
        htole32(dst + *dst_len, elems[i]);
   14c5e:	7820      	ldrb	r0, [r4, #0]
   14c60:	f85a 1028 	ldr.w	r1, [sl, r8, lsl #2]
   14c64:	4428      	add	r0, r5
   14c66:	f008 f9fb 	bl	1d060 <htole32>
        *dst_len += sizeof elems[i];
   14c6a:	7823      	ldrb	r3, [r4, #0]
   14c6c:	3304      	adds	r3, #4
   14c6e:	7023      	strb	r3, [r4, #0]
                            dst_len);
    if (rc != 0) {
        return rc;
    }

    for (i = 0; i < num_elems; i++) {
   14c70:	f108 0801 	add.w	r8, r8, #1
   14c74:	e7f1      	b.n	14c5a <ble_hs_adv_set_fields+0xa0>
            return rc;
        }
    }

    /*** 0x06,0x07 - 128-bit service class UUIDs. */
    if (adv_fields->uuids128 != NULL && adv_fields->num_uuids128 > 0) {
   14c76:	7e39      	ldrb	r1, [r7, #24]
   14c78:	b911      	cbnz	r1, 14c80 <ble_hs_adv_set_fields+0xc6>
            return rc;
        }
    }

    /*** 0x08,0x09 - Local name. */
    if (adv_fields->name != NULL && adv_fields->name_len > 0) {
   14c7a:	69fa      	ldr	r2, [r7, #28]
   14c7c:	b97a      	cbnz	r2, 14c9e <ble_hs_adv_set_fields+0xe4>
   14c7e:	e011      	b.n	14ca4 <ble_hs_adv_set_fields+0xea>
        }
    }

    /*** 0x06,0x07 - 128-bit service class UUIDs. */
    if (adv_fields->uuids128 != NULL && adv_fields->num_uuids128 > 0) {
        if (adv_fields->uuids128_is_complete) {
   14c80:	7e7b      	ldrb	r3, [r7, #25]
            type = BLE_HS_ADV_TYPE_COMP_UUIDS128;
        } else {
            type = BLE_HS_ADV_TYPE_INCOMP_UUIDS128;
   14c82:	f013 0f01 	tst.w	r3, #1
        }

        rc = ble_hs_adv_set_flat(type, adv_fields->num_uuids128 * 16,
   14c86:	bf14      	ite	ne
   14c88:	2007      	movne	r0, #7
   14c8a:	2006      	moveq	r0, #6
   14c8c:	e88d 0050 	stmia.w	sp, {r4, r6}
   14c90:	0109      	lsls	r1, r1, #4
   14c92:	462b      	mov	r3, r5
   14c94:	f7ff ff71 	bl	14b7a <ble_hs_adv_set_flat>
                                 adv_fields->uuids128, dst, dst_len, max_len);
        if (rc != 0) {
   14c98:	2800      	cmp	r0, #0
   14c9a:	d0ee      	beq.n	14c7a <ble_hs_adv_set_fields+0xc0>
   14c9c:	e0cd      	b.n	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x08,0x09 - Local name. */
    if (adv_fields->name != NULL && adv_fields->name_len > 0) {
   14c9e:	f897 1020 	ldrb.w	r1, [r7, #32]
   14ca2:	b921      	cbnz	r1, 14cae <ble_hs_adv_set_fields+0xf4>
            return rc;
        }
    }

    /*** 0x0a - Tx power level. */
    if (adv_fields->tx_pwr_lvl_is_present) {
   14ca4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   14ca8:	07d8      	lsls	r0, r3, #31
   14caa:	d40f      	bmi.n	14ccc <ble_hs_adv_set_fields+0x112>
   14cac:	e025      	b.n	14cfa <ble_hs_adv_set_fields+0x140>
        }
    }

    /*** 0x08,0x09 - Local name. */
    if (adv_fields->name != NULL && adv_fields->name_len > 0) {
        if (adv_fields->name_is_complete) {
   14cae:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
            type = BLE_HS_ADV_TYPE_COMP_NAME;
        } else {
            type = BLE_HS_ADV_TYPE_INCOMP_NAME;
   14cb2:	f013 0f01 	tst.w	r3, #1
        }

        rc = ble_hs_adv_set_flat(type, adv_fields->name_len, adv_fields->name,
   14cb6:	bf14      	ite	ne
   14cb8:	2009      	movne	r0, #9
   14cba:	2008      	moveq	r0, #8
   14cbc:	e88d 0050 	stmia.w	sp, {r4, r6}
   14cc0:	462b      	mov	r3, r5
   14cc2:	f7ff ff5a 	bl	14b7a <ble_hs_adv_set_flat>
                                 dst, dst_len, max_len);
        if (rc != 0) {
   14cc6:	2800      	cmp	r0, #0
   14cc8:	d0ec      	beq.n	14ca4 <ble_hs_adv_set_fields+0xea>
   14cca:	e0b6      	b.n	14e3a <ble_hs_adv_set_fields+0x280>
    /*** 0x0a - Tx power level. */
    if (adv_fields->tx_pwr_lvl_is_present) {
        /* Read the power level from the controller if requested; otherwise use
         * the explicitly specified value.
         */
        if (adv_fields->tx_pwr_lvl == BLE_HS_ADV_TX_PWR_LVL_AUTO) {
   14ccc:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
   14cd0:	2b80      	cmp	r3, #128	; 0x80
   14cd2:	d115      	bne.n	14d00 <ble_hs_adv_set_fields+0x146>
            rc = ble_hci_util_read_adv_tx_pwr(&tx_pwr_lvl);
   14cd4:	f10d 000f 	add.w	r0, sp, #15
   14cd8:	f7ff fcc2 	bl	14660 <ble_hci_util_read_adv_tx_pwr>
            if (rc != 0) {
   14cdc:	2800      	cmp	r0, #0
   14cde:	f040 80ac 	bne.w	14e3a <ble_hs_adv_set_fields+0x280>
            }
        } else {
            tx_pwr_lvl = adv_fields->tx_pwr_lvl;
        }

        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_TX_PWR_LVL, 1, &tx_pwr_lvl,
   14ce2:	e88d 0050 	stmia.w	sp, {r4, r6}
   14ce6:	200a      	movs	r0, #10
   14ce8:	2101      	movs	r1, #1
   14cea:	f10d 020f 	add.w	r2, sp, #15
   14cee:	462b      	mov	r3, r5
   14cf0:	f7ff ff43 	bl	14b7a <ble_hs_adv_set_flat>
                                 dst, dst_len, max_len);
        if (rc != 0) {
   14cf4:	2800      	cmp	r0, #0
   14cf6:	f040 80a0 	bne.w	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x0d - Class of device. */
    if (adv_fields->device_class != NULL) {
   14cfa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   14cfc:	b91a      	cbnz	r2, 14d06 <ble_hs_adv_set_fields+0x14c>
   14cfe:	e00c      	b.n	14d1a <ble_hs_adv_set_fields+0x160>
            rc = ble_hci_util_read_adv_tx_pwr(&tx_pwr_lvl);
            if (rc != 0) {
                return rc;
            }
        } else {
            tx_pwr_lvl = adv_fields->tx_pwr_lvl;
   14d00:	f88d 300f 	strb.w	r3, [sp, #15]
   14d04:	e7ed      	b.n	14ce2 <ble_hs_adv_set_fields+0x128>
        }
    }

    /*** 0x0d - Class of device. */
    if (adv_fields->device_class != NULL) {
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_DEVICE_CLASS,
   14d06:	e88d 0050 	stmia.w	sp, {r4, r6}
   14d0a:	200d      	movs	r0, #13
   14d0c:	2103      	movs	r1, #3
   14d0e:	462b      	mov	r3, r5
   14d10:	f7ff ff33 	bl	14b7a <ble_hs_adv_set_flat>
                                 BLE_HS_ADV_DEVICE_CLASS_LEN,
                                 adv_fields->device_class, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14d14:	2800      	cmp	r0, #0
   14d16:	f040 8090 	bne.w	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x12 - Slave connection interval range. */
    if (adv_fields->slave_itvl_range != NULL) {
   14d1a:	6aba      	ldr	r2, [r7, #40]	; 0x28
   14d1c:	b14a      	cbz	r2, 14d32 <ble_hs_adv_set_fields+0x178>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_SLAVE_ITVL_RANGE,
   14d1e:	e88d 0050 	stmia.w	sp, {r4, r6}
   14d22:	2012      	movs	r0, #18
   14d24:	2104      	movs	r1, #4
   14d26:	462b      	mov	r3, r5
   14d28:	f7ff ff27 	bl	14b7a <ble_hs_adv_set_flat>
                                 BLE_HS_ADV_SLAVE_ITVL_RANGE_LEN,
                                 adv_fields->slave_itvl_range, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14d2c:	2800      	cmp	r0, #0
   14d2e:	f040 8084 	bne.w	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x16 - Service data - 16-bit UUID. */
    if (adv_fields->svc_data_uuid16 != NULL) {
   14d32:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   14d34:	b14a      	cbz	r2, 14d4a <ble_hs_adv_set_fields+0x190>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_SVC_DATA_UUID16,
   14d36:	f897 1030 	ldrb.w	r1, [r7, #48]	; 0x30
   14d3a:	2016      	movs	r0, #22
   14d3c:	e88d 0050 	stmia.w	sp, {r4, r6}
   14d40:	462b      	mov	r3, r5
   14d42:	f7ff ff1a 	bl	14b7a <ble_hs_adv_set_flat>
                                 adv_fields->svc_data_uuid16_len,
                                 adv_fields->svc_data_uuid16, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14d46:	2800      	cmp	r0, #0
   14d48:	d177      	bne.n	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x17 - Public target address. */
    if (adv_fields->public_tgt_addr != NULL &&
   14d4a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   14d4c:	b112      	cbz	r2, 14d54 <ble_hs_adv_set_fields+0x19a>
        adv_fields->num_public_tgt_addrs != 0) {
   14d4e:	f897 1038 	ldrb.w	r1, [r7, #56]	; 0x38
            return rc;
        }
    }

    /*** 0x17 - Public target address. */
    if (adv_fields->public_tgt_addr != NULL &&
   14d52:	b921      	cbnz	r1, 14d5e <ble_hs_adv_set_fields+0x1a4>
            return rc;
        }
    }

    /*** 0x19 - Appearance. */
    if (adv_fields->appearance_is_present) {
   14d54:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
   14d58:	07d9      	lsls	r1, r3, #31
   14d5a:	d517      	bpl.n	14d8c <ble_hs_adv_set_fields+0x1d2>
   14d5c:	e00b      	b.n	14d76 <ble_hs_adv_set_fields+0x1bc>

    /*** 0x17 - Public target address. */
    if (adv_fields->public_tgt_addr != NULL &&
        adv_fields->num_public_tgt_addrs != 0) {

        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_PUBLIC_TGT_ADDR,
   14d5e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   14d62:	e88d 0050 	stmia.w	sp, {r4, r6}
   14d66:	2017      	movs	r0, #23
   14d68:	0049      	lsls	r1, r1, #1
   14d6a:	462b      	mov	r3, r5
   14d6c:	f7ff ff05 	bl	14b7a <ble_hs_adv_set_flat>
                                 BLE_HS_ADV_PUBLIC_TGT_ADDR_ENTRY_LEN *
                                     adv_fields->num_public_tgt_addrs,
                                 adv_fields->public_tgt_addr, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14d70:	2800      	cmp	r0, #0
   14d72:	d0ef      	beq.n	14d54 <ble_hs_adv_set_fields+0x19a>
   14d74:	e061      	b.n	14e3a <ble_hs_adv_set_fields+0x280>
        }
    }

    /*** 0x19 - Appearance. */
    if (adv_fields->appearance_is_present) {
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_APPEARANCE,
   14d76:	e88d 0050 	stmia.w	sp, {r4, r6}
   14d7a:	2019      	movs	r0, #25
   14d7c:	2102      	movs	r1, #2
   14d7e:	f107 023a 	add.w	r2, r7, #58	; 0x3a
   14d82:	462b      	mov	r3, r5
   14d84:	f7ff fef9 	bl	14b7a <ble_hs_adv_set_flat>
                                 BLE_HS_ADV_APPEARANCE_LEN,
                                 &adv_fields->appearance, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14d88:	2800      	cmp	r0, #0
   14d8a:	d156      	bne.n	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x1a - Advertising interval. */
    if (adv_fields->adv_itvl_is_present) {
   14d8c:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
   14d90:	07da      	lsls	r2, r3, #31
   14d92:	d50a      	bpl.n	14daa <ble_hs_adv_set_fields+0x1f0>
        rc = ble_hs_adv_set_array16(BLE_HS_ADV_TYPE_ADV_ITVL, 1,
   14d94:	e88d 0050 	stmia.w	sp, {r4, r6}
   14d98:	201a      	movs	r0, #26
   14d9a:	2101      	movs	r1, #1
   14d9c:	f107 023e 	add.w	r2, r7, #62	; 0x3e
   14da0:	462b      	mov	r3, r5
   14da2:	f7ff febf 	bl	14b24 <ble_hs_adv_set_array16>
                                    &adv_fields->adv_itvl, dst, dst_len,
                                    max_len);
        if (rc != 0) {
   14da6:	2800      	cmp	r0, #0
   14da8:	d147      	bne.n	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x1b - LE bluetooth device address. */
    if (adv_fields->le_addr != NULL) {
   14daa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   14dac:	b142      	cbz	r2, 14dc0 <ble_hs_adv_set_fields+0x206>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_LE_ADDR,
   14dae:	e88d 0050 	stmia.w	sp, {r4, r6}
   14db2:	201b      	movs	r0, #27
   14db4:	2107      	movs	r1, #7
   14db6:	462b      	mov	r3, r5
   14db8:	f7ff fedf 	bl	14b7a <ble_hs_adv_set_flat>
                                 BLE_HS_ADV_LE_ADDR_LEN,
                                 adv_fields->le_addr, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14dbc:	2800      	cmp	r0, #0
   14dbe:	d13c      	bne.n	14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x1c - LE role. */
    if (adv_fields->le_role_is_present) {
   14dc0:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
   14dc4:	07db      	lsls	r3, r3, #31
   14dc6:	d509      	bpl.n	14ddc <ble_hs_adv_set_fields+0x222>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_LE_ROLE,
   14dc8:	e88d 0050 	stmia.w	sp, {r4, r6}
   14dcc:	201c      	movs	r0, #28
   14dce:	2101      	movs	r1, #1
   14dd0:	f107 0248 	add.w	r2, r7, #72	; 0x48
   14dd4:	462b      	mov	r3, r5
   14dd6:	f7ff fed0 	bl	14b7a <ble_hs_adv_set_flat>
                                 BLE_HS_ADV_LE_ROLE_LEN,
                                 &adv_fields->le_role, dst, dst_len, max_len);
        if (rc != 0) {
   14dda:	bb70      	cbnz	r0, 14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x20 - Service data - 32-bit UUID. */
    if (adv_fields->svc_data_uuid32 != NULL) {
   14ddc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   14dde:	b142      	cbz	r2, 14df2 <ble_hs_adv_set_fields+0x238>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_SVC_DATA_UUID32,
   14de0:	f897 1050 	ldrb.w	r1, [r7, #80]	; 0x50
   14de4:	2020      	movs	r0, #32
   14de6:	e88d 0050 	stmia.w	sp, {r4, r6}
   14dea:	462b      	mov	r3, r5
   14dec:	f7ff fec5 	bl	14b7a <ble_hs_adv_set_flat>
                                 adv_fields->svc_data_uuid32_len,
                                 adv_fields->svc_data_uuid32, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14df0:	bb18      	cbnz	r0, 14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x21 - Service data - 128-bit UUID. */
    if (adv_fields->svc_data_uuid128 != NULL) {
   14df2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   14df4:	b142      	cbz	r2, 14e08 <ble_hs_adv_set_fields+0x24e>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_SVC_DATA_UUID128,
   14df6:	f897 1058 	ldrb.w	r1, [r7, #88]	; 0x58
   14dfa:	2021      	movs	r0, #33	; 0x21
   14dfc:	e88d 0050 	stmia.w	sp, {r4, r6}
   14e00:	462b      	mov	r3, r5
   14e02:	f7ff feba 	bl	14b7a <ble_hs_adv_set_flat>
                                 adv_fields->svc_data_uuid128_len,
                                 adv_fields->svc_data_uuid128, dst, dst_len,
                                 max_len);
        if (rc != 0) {
   14e06:	b9c0      	cbnz	r0, 14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0x24 - URI. */
    if (adv_fields->uri != NULL) {
   14e08:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   14e0a:	b142      	cbz	r2, 14e1e <ble_hs_adv_set_fields+0x264>
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_URI, adv_fields->uri_len,
   14e0c:	f897 1060 	ldrb.w	r1, [r7, #96]	; 0x60
   14e10:	2024      	movs	r0, #36	; 0x24
   14e12:	e88d 0050 	stmia.w	sp, {r4, r6}
   14e16:	462b      	mov	r3, r5
   14e18:	f7ff feaf 	bl	14b7a <ble_hs_adv_set_flat>
                                 adv_fields->uri, dst, dst_len, max_len);
        if (rc != 0) {
   14e1c:	b968      	cbnz	r0, 14e3a <ble_hs_adv_set_fields+0x280>
            return rc;
        }
    }

    /*** 0xff - Manufacturer specific data. */
    if (adv_fields->mfg_data != NULL) {
   14e1e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   14e20:	b90a      	cbnz	r2, 14e26 <ble_hs_adv_set_fields+0x26c>
        if (rc != 0) {
            return rc;
        }
    }

    return 0;
   14e22:	4610      	mov	r0, r2
   14e24:	e009      	b.n	14e3a <ble_hs_adv_set_fields+0x280>
        }
    }

    /*** 0xff - Manufacturer specific data. */
    if (adv_fields->mfg_data != NULL) {
        rc = ble_hs_adv_set_flat(BLE_HS_ADV_TYPE_MFG_DATA,
   14e26:	f897 1068 	ldrb.w	r1, [r7, #104]	; 0x68
   14e2a:	462b      	mov	r3, r5
   14e2c:	e88d 0050 	stmia.w	sp, {r4, r6}
   14e30:	20ff      	movs	r0, #255	; 0xff
   14e32:	f7ff fea2 	bl	14b7a <ble_hs_adv_set_flat>
   14e36:	e000      	b.n	14e3a <ble_hs_adv_set_fields+0x280>
static int
ble_hs_adv_set_hdr(uint8_t type, uint8_t data_len, uint8_t max_len,
                   uint8_t *dst, uint8_t *dst_len)
{
    if (*dst_len + 2 + data_len > max_len) {
        return BLE_HS_EMSGSIZE;
   14e38:	2004      	movs	r0, #4
            return rc;
        }
    }

    return 0;
}
   14e3a:	b004      	add	sp, #16
   14e3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00014e40 <ble_hs_adv_parse_fields>:
}

int
ble_hs_adv_parse_fields(struct ble_hs_adv_fields *adv_fields, uint8_t *src,
                        uint8_t src_len)
{
   14e40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14e42:	460d      	mov	r5, r1
   14e44:	4617      	mov	r7, r2
    uint8_t field_len;
    int rc;

    memset(adv_fields, 0, sizeof *adv_fields);
   14e46:	2100      	movs	r1, #0
   14e48:	226c      	movs	r2, #108	; 0x6c
}

int
ble_hs_adv_parse_fields(struct ble_hs_adv_fields *adv_fields, uint8_t *src,
                        uint8_t src_len)
{
   14e4a:	4604      	mov	r4, r0
    uint8_t field_len;
    int rc;

    memset(adv_fields, 0, sizeof *adv_fields);
   14e4c:	f7f4 f8e1 	bl	9012 <memset>

    while (src_len > 0) {
   14e50:	2f00      	cmp	r7, #0
   14e52:	f000 8108 	beq.w	15066 <ble_hs_adv_parse_fields+0x226>
    int rc;

    if (src_len < 1) {
        return BLE_HS_EMSGSIZE;
    }
    *total_len = src[0] + 1;
   14e56:	782a      	ldrb	r2, [r5, #0]
   14e58:	1c56      	adds	r6, r2, #1
   14e5a:	b2f6      	uxtb	r6, r6

    if (src_len < *total_len) {
   14e5c:	42b7      	cmp	r7, r6
   14e5e:	f0c0 8104 	bcc.w	1506a <ble_hs_adv_parse_fields+0x22a>
        return BLE_HS_EMSGSIZE;
    }

    type = src[1];
    data = src + 2;
    data_len = *total_len - 2;
   14e62:	3a01      	subs	r2, #1
   14e64:	b2d2      	uxtb	r2, r2

    if (data_len > BLE_HS_ADV_MAX_FIELD_SZ) {
   14e66:	2a1c      	cmp	r2, #28

    if (src_len < *total_len) {
        return BLE_HS_EMSGSIZE;
    }

    type = src[1];
   14e68:	7868      	ldrb	r0, [r5, #1]
    data = src + 2;
    data_len = *total_len - 2;

    if (data_len > BLE_HS_ADV_MAX_FIELD_SZ) {
   14e6a:	f200 8100 	bhi.w	1506e <ble_hs_adv_parse_fields+0x22e>
        return BLE_HS_EBADDATA;
    }

    switch (type) {
   14e6e:	280d      	cmp	r0, #13
    if (src_len < *total_len) {
        return BLE_HS_EMSGSIZE;
    }

    type = src[1];
    data = src + 2;
   14e70:	f105 0102 	add.w	r1, r5, #2

    if (data_len > BLE_HS_ADV_MAX_FIELD_SZ) {
        return BLE_HS_EBADDATA;
    }

    switch (type) {
   14e74:	f000 80a0 	beq.w	14fb8 <ble_hs_adv_parse_fields+0x178>
   14e78:	d81e      	bhi.n	14eb8 <ble_hs_adv_parse_fields+0x78>
   14e7a:	2805      	cmp	r0, #5
   14e7c:	d064      	beq.n	14f48 <ble_hs_adv_parse_fields+0x108>
   14e7e:	d80e      	bhi.n	14e9e <ble_hs_adv_parse_fields+0x5e>
   14e80:	2802      	cmp	r0, #2
   14e82:	d04c      	beq.n	14f1e <ble_hs_adv_parse_fields+0xde>
   14e84:	d802      	bhi.n	14e8c <ble_hs_adv_parse_fields+0x4c>
   14e86:	2801      	cmp	r0, #1
   14e88:	d03f      	beq.n	14f0a <ble_hs_adv_parse_fields+0xca>
   14e8a:	e0e8      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
   14e8c:	2803      	cmp	r0, #3
   14e8e:	d050      	beq.n	14f32 <ble_hs_adv_parse_fields+0xf2>
   14e90:	2804      	cmp	r0, #4
   14e92:	f040 80e4 	bne.w	1505e <ble_hs_adv_parse_fields+0x21e>
        }
        adv_fields->uuids16_is_complete = 1;
        break;

    case BLE_HS_ADV_TYPE_INCOMP_UUIDS32:
        rc = ble_hs_adv_parse_uuids32(adv_fields, data, data_len);
   14e96:	4620      	mov	r0, r4
   14e98:	f7ff fe28 	bl	14aec <ble_hs_adv_parse_uuids32>
   14e9c:	e042      	b.n	14f24 <ble_hs_adv_parse_fields+0xe4>

    if (data_len > BLE_HS_ADV_MAX_FIELD_SZ) {
        return BLE_HS_EBADDATA;
    }

    switch (type) {
   14e9e:	2808      	cmp	r0, #8
   14ea0:	d06c      	beq.n	14f7c <ble_hs_adv_parse_fields+0x13c>
   14ea2:	d804      	bhi.n	14eae <ble_hs_adv_parse_fields+0x6e>
   14ea4:	2806      	cmp	r0, #6
   14ea6:	d053      	beq.n	14f50 <ble_hs_adv_parse_fields+0x110>
   14ea8:	2807      	cmp	r0, #7
   14eaa:	d05c      	beq.n	14f66 <ble_hs_adv_parse_fields+0x126>
   14eac:	e0d7      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
   14eae:	2809      	cmp	r0, #9
   14eb0:	d06c      	beq.n	14f8c <ble_hs_adv_parse_fields+0x14c>
   14eb2:	280a      	cmp	r0, #10
   14eb4:	d074      	beq.n	14fa0 <ble_hs_adv_parse_fields+0x160>
   14eb6:	e0d2      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
   14eb8:	281b      	cmp	r0, #27
   14eba:	f000 80b1 	beq.w	15020 <ble_hs_adv_parse_fields+0x1e0>
   14ebe:	d80f      	bhi.n	14ee0 <ble_hs_adv_parse_fields+0xa0>
   14ec0:	2817      	cmp	r0, #23
   14ec2:	f000 8087 	beq.w	14fd4 <ble_hs_adv_parse_fields+0x194>
   14ec6:	d804      	bhi.n	14ed2 <ble_hs_adv_parse_fields+0x92>
   14ec8:	2812      	cmp	r0, #18
   14eca:	d079      	beq.n	14fc0 <ble_hs_adv_parse_fields+0x180>
   14ecc:	2816      	cmp	r0, #22
   14ece:	d07b      	beq.n	14fc8 <ble_hs_adv_parse_fields+0x188>
   14ed0:	e0c5      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
   14ed2:	2819      	cmp	r0, #25
   14ed4:	f000 808a 	beq.w	14fec <ble_hs_adv_parse_fields+0x1ac>
   14ed8:	281a      	cmp	r0, #26
   14eda:	f000 8094 	beq.w	15006 <ble_hs_adv_parse_fields+0x1c6>
   14ede:	e0be      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
   14ee0:	2821      	cmp	r0, #33	; 0x21
   14ee2:	f000 80b3 	beq.w	1504c <ble_hs_adv_parse_fields+0x20c>
   14ee6:	d806      	bhi.n	14ef6 <ble_hs_adv_parse_fields+0xb6>
   14ee8:	281c      	cmp	r0, #28
   14eea:	f000 809d 	beq.w	15028 <ble_hs_adv_parse_fields+0x1e8>
   14eee:	2820      	cmp	r0, #32
   14ef0:	f000 80a6 	beq.w	15040 <ble_hs_adv_parse_fields+0x200>
   14ef4:	e0b3      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
   14ef6:	2824      	cmp	r0, #36	; 0x24
   14ef8:	f000 80ae 	beq.w	15058 <ble_hs_adv_parse_fields+0x218>
   14efc:	28ff      	cmp	r0, #255	; 0xff
   14efe:	f040 80ae 	bne.w	1505e <ble_hs_adv_parse_fields+0x21e>
        adv_fields->uri = data;
        adv_fields->uri_len = data_len;
        break;

    case BLE_HS_ADV_TYPE_MFG_DATA:
        adv_fields->mfg_data = data;
   14f02:	6661      	str	r1, [r4, #100]	; 0x64
        adv_fields->mfg_data_len = data_len;
   14f04:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
   14f08:	e0a9      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        return BLE_HS_EBADDATA;
    }

    switch (type) {
    case BLE_HS_ADV_TYPE_FLAGS:
        if (data_len != BLE_HS_ADV_FLAGS_LEN) {
   14f0a:	2a01      	cmp	r2, #1
   14f0c:	f040 80af 	bne.w	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->flags = *data;
   14f10:	78ab      	ldrb	r3, [r5, #2]
   14f12:	7023      	strb	r3, [r4, #0]
        adv_fields->flags_is_present = 1;
   14f14:	7863      	ldrb	r3, [r4, #1]
   14f16:	f043 0301 	orr.w	r3, r3, #1
   14f1a:	7063      	strb	r3, [r4, #1]
   14f1c:	e09f      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_INCOMP_UUIDS16:
        rc = ble_hs_adv_parse_uuids16(adv_fields, data, data_len);
   14f1e:	4620      	mov	r0, r4
   14f20:	f7ff fdc8 	bl	14ab4 <ble_hs_adv_parse_uuids16>
        if (rc != 0) {
   14f24:	2800      	cmp	r0, #0
   14f26:	f040 80a3 	bne.w	15070 <ble_hs_adv_parse_fields+0x230>
            return rc;
        }
        adv_fields->uuids16_is_complete = 0;
   14f2a:	7a63      	ldrb	r3, [r4, #9]
   14f2c:	f36f 0300 	bfc	r3, #0, #1
   14f30:	e008      	b.n	14f44 <ble_hs_adv_parse_fields+0x104>
        break;

    case BLE_HS_ADV_TYPE_COMP_UUIDS16:
        rc = ble_hs_adv_parse_uuids16(adv_fields, data, data_len);
   14f32:	4620      	mov	r0, r4
   14f34:	f7ff fdbe 	bl	14ab4 <ble_hs_adv_parse_uuids16>
        if (rc != 0) {
   14f38:	2800      	cmp	r0, #0
   14f3a:	f040 8099 	bne.w	15070 <ble_hs_adv_parse_fields+0x230>
            return rc;
        }
        adv_fields->uuids16_is_complete = 1;
   14f3e:	7a63      	ldrb	r3, [r4, #9]
   14f40:	f043 0301 	orr.w	r3, r3, #1
   14f44:	7263      	strb	r3, [r4, #9]
   14f46:	e08a      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        }
        adv_fields->uuids16_is_complete = 0;
        break;

    case BLE_HS_ADV_TYPE_COMP_UUIDS32:
        rc = ble_hs_adv_parse_uuids32(adv_fields, data, data_len);
   14f48:	4620      	mov	r0, r4
   14f4a:	f7ff fdcf 	bl	14aec <ble_hs_adv_parse_uuids32>
   14f4e:	e7f3      	b.n	14f38 <ble_hs_adv_parse_fields+0xf8>
        }
        adv_fields->uuids16_is_complete = 1;
        break;

    case BLE_HS_ADV_TYPE_INCOMP_UUIDS128:
        if (data_len % 16 != 0) {
   14f50:	f012 000f 	ands.w	r0, r2, #15
   14f54:	f040 808b 	bne.w	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->uuids128 = data;
        adv_fields->num_uuids128 = data_len / 16;
        adv_fields->uuids128_is_complete = 0;
   14f58:	7e63      	ldrb	r3, [r4, #25]

    case BLE_HS_ADV_TYPE_INCOMP_UUIDS128:
        if (data_len % 16 != 0) {
            return BLE_HS_EBADDATA;
        }
        adv_fields->uuids128 = data;
   14f5a:	6161      	str	r1, [r4, #20]
        adv_fields->num_uuids128 = data_len / 16;
   14f5c:	0912      	lsrs	r2, r2, #4
   14f5e:	7622      	strb	r2, [r4, #24]
        adv_fields->uuids128_is_complete = 0;
   14f60:	f360 0300 	bfi	r3, r0, #0, #1
   14f64:	e008      	b.n	14f78 <ble_hs_adv_parse_fields+0x138>
        break;

    case BLE_HS_ADV_TYPE_COMP_UUIDS128:
        if (data_len % 16 != 0) {
   14f66:	0713      	lsls	r3, r2, #28
   14f68:	f040 8081 	bne.w	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->uuids128 = data;
        adv_fields->num_uuids128 = data_len / 16;
        adv_fields->uuids128_is_complete = 1;
   14f6c:	7e63      	ldrb	r3, [r4, #25]

    case BLE_HS_ADV_TYPE_COMP_UUIDS128:
        if (data_len % 16 != 0) {
            return BLE_HS_EBADDATA;
        }
        adv_fields->uuids128 = data;
   14f6e:	6161      	str	r1, [r4, #20]
        adv_fields->num_uuids128 = data_len / 16;
   14f70:	0912      	lsrs	r2, r2, #4
   14f72:	7622      	strb	r2, [r4, #24]
        adv_fields->uuids128_is_complete = 1;
   14f74:	f043 0301 	orr.w	r3, r3, #1
   14f78:	7663      	strb	r3, [r4, #25]
   14f7a:	e070      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_INCOMP_NAME:
        adv_fields->name = data;
        adv_fields->name_len = data_len;
        adv_fields->name_is_complete = 0;
   14f7c:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
        adv_fields->num_uuids128 = data_len / 16;
        adv_fields->uuids128_is_complete = 1;
        break;

    case BLE_HS_ADV_TYPE_INCOMP_NAME:
        adv_fields->name = data;
   14f80:	61e1      	str	r1, [r4, #28]
        adv_fields->name_len = data_len;
   14f82:	f884 2020 	strb.w	r2, [r4, #32]
        adv_fields->name_is_complete = 0;
   14f86:	f36f 0300 	bfc	r3, #0, #1
   14f8a:	e006      	b.n	14f9a <ble_hs_adv_parse_fields+0x15a>
        break;

    case BLE_HS_ADV_TYPE_COMP_NAME:
        adv_fields->name = data;
        adv_fields->name_len = data_len;
        adv_fields->name_is_complete = 1;
   14f8c:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
        adv_fields->name_len = data_len;
        adv_fields->name_is_complete = 0;
        break;

    case BLE_HS_ADV_TYPE_COMP_NAME:
        adv_fields->name = data;
   14f90:	61e1      	str	r1, [r4, #28]
        adv_fields->name_len = data_len;
   14f92:	f884 2020 	strb.w	r2, [r4, #32]
        adv_fields->name_is_complete = 1;
   14f96:	f043 0301 	orr.w	r3, r3, #1
   14f9a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
   14f9e:	e05e      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_TX_PWR_LVL:
        if (data_len != BLE_HS_ADV_TX_PWR_LVL_LEN) {
   14fa0:	2a01      	cmp	r2, #1
   14fa2:	d165      	bne.n	15070 <ble_hs_adv_parse_fields+0x230>
            return BLE_HS_EBADDATA;
        }
        adv_fields->tx_pwr_lvl = *data;
   14fa4:	78ab      	ldrb	r3, [r5, #2]
   14fa6:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
        adv_fields->tx_pwr_lvl_is_present = 1;
   14faa:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
   14fae:	f043 0301 	orr.w	r3, r3, #1
   14fb2:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
   14fb6:	e052      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_DEVICE_CLASS:
        if (data_len != BLE_HS_ADV_DEVICE_CLASS_LEN) {
   14fb8:	2a03      	cmp	r2, #3
   14fba:	d158      	bne.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->device_class = data;
   14fbc:	6261      	str	r1, [r4, #36]	; 0x24
   14fbe:	e04e      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_SLAVE_ITVL_RANGE:
        if (data_len != BLE_HS_ADV_SLAVE_ITVL_RANGE_LEN) {
   14fc0:	2a04      	cmp	r2, #4
   14fc2:	d154      	bne.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->slave_itvl_range = data;
   14fc4:	62a1      	str	r1, [r4, #40]	; 0x28
   14fc6:	e04a      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_SVC_DATA_UUID16:
        if (data_len < BLE_HS_ADV_SVC_DATA_UUID16_MIN_LEN) {
   14fc8:	2a01      	cmp	r2, #1
   14fca:	d950      	bls.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->svc_data_uuid16 = data;
   14fcc:	62e1      	str	r1, [r4, #44]	; 0x2c
        adv_fields->svc_data_uuid16_len = data_len;
   14fce:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
   14fd2:	e044      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_PUBLIC_TGT_ADDR:
        if (data_len % BLE_HS_ADV_PUBLIC_TGT_ADDR_ENTRY_LEN != 0) {
   14fd4:	2306      	movs	r3, #6
   14fd6:	fbb2 f0f3 	udiv	r0, r2, r3
   14fda:	fb03 2210 	mls	r2, r3, r0, r2
   14fde:	f012 0fff 	tst.w	r2, #255	; 0xff
   14fe2:	d144      	bne.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->public_tgt_addr = data;
   14fe4:	6361      	str	r1, [r4, #52]	; 0x34
        adv_fields->num_public_tgt_addrs =
   14fe6:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
   14fea:	e038      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
            data_len / BLE_HS_ADV_PUBLIC_TGT_ADDR_ENTRY_LEN;
        break;

    case BLE_HS_ADV_TYPE_APPEARANCE:
        if (data_len != BLE_HS_ADV_APPEARANCE_LEN) {
   14fec:	2a02      	cmp	r2, #2
   14fee:	d13e      	bne.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->appearance = le16toh(data);
   14ff0:	4608      	mov	r0, r1
   14ff2:	f008 f84c 	bl	1d08e <le16toh>
        adv_fields->appearance_is_present = 1;
   14ff6:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c

    case BLE_HS_ADV_TYPE_APPEARANCE:
        if (data_len != BLE_HS_ADV_APPEARANCE_LEN) {
            return BLE_HS_EBADDATA;
        }
        adv_fields->appearance = le16toh(data);
   14ffa:	8760      	strh	r0, [r4, #58]	; 0x3a
        adv_fields->appearance_is_present = 1;
   14ffc:	f043 0301 	orr.w	r3, r3, #1
   15000:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
   15004:	e02b      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_ADV_ITVL:
        if (data_len != BLE_HS_ADV_ADV_ITVL_LEN) {
   15006:	2a02      	cmp	r2, #2
   15008:	d131      	bne.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->adv_itvl = le16toh(data);
   1500a:	4608      	mov	r0, r1
   1500c:	f008 f83f 	bl	1d08e <le16toh>
        adv_fields->adv_itvl_is_present = 1;
   15010:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40

    case BLE_HS_ADV_TYPE_ADV_ITVL:
        if (data_len != BLE_HS_ADV_ADV_ITVL_LEN) {
            return BLE_HS_EBADDATA;
        }
        adv_fields->adv_itvl = le16toh(data);
   15014:	87e0      	strh	r0, [r4, #62]	; 0x3e
        adv_fields->adv_itvl_is_present = 1;
   15016:	f043 0301 	orr.w	r3, r3, #1
   1501a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
   1501e:	e01e      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_LE_ADDR:
        if (data_len != BLE_HS_ADV_LE_ADDR_LEN) {
   15020:	2a07      	cmp	r2, #7
   15022:	d124      	bne.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->le_addr = data;
   15024:	6461      	str	r1, [r4, #68]	; 0x44
   15026:	e01a      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_LE_ROLE:
        if (data_len != BLE_HS_ADV_LE_ROLE_LEN) {
   15028:	2a01      	cmp	r2, #1
   1502a:	d120      	bne.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->le_role = *data;
   1502c:	78ab      	ldrb	r3, [r5, #2]
   1502e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
        adv_fields->le_role_is_present = 1;
   15032:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
   15036:	f043 0301 	orr.w	r3, r3, #1
   1503a:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
   1503e:	e00e      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_SVC_DATA_UUID32:
        if (data_len < BLE_HS_ADV_SVC_DATA_UUID32_MIN_LEN) {
   15040:	2a03      	cmp	r2, #3
   15042:	d914      	bls.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->svc_data_uuid32 = data;
   15044:	64e1      	str	r1, [r4, #76]	; 0x4c
        adv_fields->svc_data_uuid32_len = data_len;
   15046:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
   1504a:	e008      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_SVC_DATA_UUID128:
        if (data_len < BLE_HS_ADV_SVC_DATA_UUID128_MIN_LEN) {
   1504c:	2a0f      	cmp	r2, #15
   1504e:	d90e      	bls.n	1506e <ble_hs_adv_parse_fields+0x22e>
            return BLE_HS_EBADDATA;
        }
        adv_fields->svc_data_uuid128 = data;
   15050:	6561      	str	r1, [r4, #84]	; 0x54
        adv_fields->svc_data_uuid128_len = data_len;
   15052:	f884 2058 	strb.w	r2, [r4, #88]	; 0x58
   15056:	e002      	b.n	1505e <ble_hs_adv_parse_fields+0x21e>
        break;

    case BLE_HS_ADV_TYPE_URI:
        adv_fields->uri = data;
   15058:	65e1      	str	r1, [r4, #92]	; 0x5c
        adv_fields->uri_len = data_len;
   1505a:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
        if (rc != 0) {
            return rc;
        }

        src += field_len;
        src_len -= field_len;
   1505e:	1bb8      	subs	r0, r7, r6
        rc = ble_hs_adv_parse_one_field(adv_fields, &field_len, src, src_len);
        if (rc != 0) {
            return rc;
        }

        src += field_len;
   15060:	4435      	add	r5, r6
        src_len -= field_len;
   15062:	b2c7      	uxtb	r7, r0
   15064:	e6f4      	b.n	14e50 <ble_hs_adv_parse_fields+0x10>
    }

    return 0;
   15066:	4638      	mov	r0, r7
   15068:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BLE_HS_EMSGSIZE;
    }
    *total_len = src[0] + 1;

    if (src_len < *total_len) {
        return BLE_HS_EMSGSIZE;
   1506a:	2004      	movs	r0, #4
   1506c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    type = src[1];
    data = src + 2;
    data_len = *total_len - 2;

    if (data_len > BLE_HS_ADV_MAX_FIELD_SZ) {
        return BLE_HS_EBADDATA;
   1506e:	200a      	movs	r0, #10
        src += field_len;
        src_len -= field_len;
    }

    return 0;
}
   15070:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00015072 <ble_hs_atomic_conn_delete>:

#include "ble_hs_priv.h"

int
ble_hs_atomic_conn_delete(uint16_t conn_handle)
{
   15072:	b510      	push	{r4, lr}
   15074:	4604      	mov	r4, r0
    struct ble_hs_conn *conn;

    ble_hs_lock();
   15076:	f7ff fb65 	bl	14744 <ble_hs_lock>
    conn = ble_hs_conn_find(conn_handle);
   1507a:	4620      	mov	r0, r4
   1507c:	f000 f90a 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   15080:	4604      	mov	r4, r0
   15082:	b120      	cbz	r0, 1508e <ble_hs_atomic_conn_delete+0x1c>
        ble_hs_conn_remove(conn);
   15084:	f000 f8f4 	bl	15270 <ble_hs_conn_remove>
        ble_hs_conn_free(conn);
   15088:	4620      	mov	r0, r4
   1508a:	f000 f899 	bl	151c0 <ble_hs_conn_free>

    }
    ble_hs_unlock();
   1508e:	f7ff fb61 	bl	14754 <ble_hs_unlock>

    return conn != NULL ? 0 : BLE_HS_ENOTCONN;
   15092:	2c00      	cmp	r4, #0
}
   15094:	bf0c      	ite	eq
   15096:	2007      	moveq	r0, #7
   15098:	2000      	movne	r0, #0
   1509a:	bd10      	pop	{r4, pc}

0001509c <ble_hs_atomic_conn_flags>:
    ble_hs_unlock();
}

int
ble_hs_atomic_conn_flags(uint16_t conn_handle, ble_hs_conn_flags_t *out_flags)
{
   1509c:	b538      	push	{r3, r4, r5, lr}
   1509e:	4605      	mov	r5, r0
   150a0:	460c      	mov	r4, r1
    struct ble_hs_conn *conn;
    int rc;

    ble_hs_lock();
   150a2:	f7ff fb4f 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   150a6:	4628      	mov	r0, r5
   150a8:	f000 f8f4 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   150ac:	b128      	cbz	r0, 150ba <ble_hs_atomic_conn_flags+0x1e>
        rc = BLE_HS_ENOTCONN;
    } else {
        rc = 0;
        if (out_flags != NULL) {
   150ae:	b12c      	cbz	r4, 150bc <ble_hs_atomic_conn_flags+0x20>
            *out_flags = conn->bhc_flags;
   150b0:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
   150b4:	7023      	strb	r3, [r4, #0]

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
    } else {
        rc = 0;
   150b6:	2400      	movs	r4, #0
   150b8:	e000      	b.n	150bc <ble_hs_atomic_conn_flags+0x20>

    ble_hs_lock();

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
   150ba:	2407      	movs	r4, #7
        if (out_flags != NULL) {
            *out_flags = conn->bhc_flags;
        }
    }

    ble_hs_unlock();
   150bc:	f7ff fb4a 	bl	14754 <ble_hs_unlock>

    return rc;
}
   150c0:	4620      	mov	r0, r4
   150c2:	bd38      	pop	{r3, r4, r5, pc}

000150c4 <ble_hs_atomic_conn_set_flags>:

int
ble_hs_atomic_conn_set_flags(uint16_t conn_handle, ble_hs_conn_flags_t flags,
                             int on)
{
   150c4:	b570      	push	{r4, r5, r6, lr}
   150c6:	4606      	mov	r6, r0
   150c8:	460d      	mov	r5, r1
   150ca:	4614      	mov	r4, r2
    struct ble_hs_conn *conn;
    int rc;

    ble_hs_lock();
   150cc:	f7ff fb3a 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   150d0:	4630      	mov	r0, r6
   150d2:	f000 f8df 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   150d6:	b160      	cbz	r0, 150f2 <ble_hs_atomic_conn_set_flags+0x2e>
   150d8:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
        rc = BLE_HS_ENOTCONN;
    } else {
        rc = 0;

        if (on) {
   150dc:	b124      	cbz	r4, 150e8 <ble_hs_atomic_conn_set_flags+0x24>
            conn->bhc_flags |= flags;
   150de:	432b      	orrs	r3, r5
   150e0:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
    } else {
        rc = 0;
   150e4:	2400      	movs	r4, #0
   150e6:	e005      	b.n	150f4 <ble_hs_atomic_conn_set_flags+0x30>

        if (on) {
            conn->bhc_flags |= flags;
        } else {
            conn->bhc_flags &= ~flags;
   150e8:	ea23 0305 	bic.w	r3, r3, r5
   150ec:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
   150f0:	e000      	b.n	150f4 <ble_hs_atomic_conn_set_flags+0x30>

    ble_hs_lock();

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
   150f2:	2407      	movs	r4, #7
        } else {
            conn->bhc_flags &= ~flags;
        }
    }

    ble_hs_unlock();
   150f4:	f7ff fb2e 	bl	14754 <ble_hs_unlock>

    return rc;
}
   150f8:	4620      	mov	r0, r4
   150fa:	bd70      	pop	{r4, r5, r6, pc}

000150fc <ble_hs_cfg_init>:

struct ble_hs_cfg ble_hs_cfg;

void
ble_hs_cfg_init(struct ble_hs_cfg *cfg)
{
   150fc:	b538      	push	{r3, r4, r5, lr}
    if (cfg == NULL) {
   150fe:	4601      	mov	r1, r0
   15100:	4c11      	ldr	r4, [pc, #68]	; (15148 <ble_hs_cfg_init+0x4c>)
   15102:	b9c8      	cbnz	r0, 15138 <ble_hs_cfg_init+0x3c>
        ble_hs_cfg = ble_hs_cfg_dflt;
   15104:	2224      	movs	r2, #36	; 0x24
   15106:	4620      	mov	r0, r4
   15108:	f7f3 ff83 	bl	9012 <memset>
   1510c:	2020      	movs	r0, #32
   1510e:	2310      	movs	r3, #16
   15110:	80a0      	strh	r0, [r4, #4]
   15112:	2040      	movs	r0, #64	; 0x40
   15114:	2108      	movs	r1, #8
   15116:	2201      	movs	r2, #1
   15118:	8063      	strh	r3, [r4, #2]
   1511a:	71a3      	strb	r3, [r4, #6]
   1511c:	8120      	strh	r0, [r4, #8]
   1511e:	72e3      	strb	r3, [r4, #11]
   15120:	2006      	movs	r0, #6
   15122:	2303      	movs	r3, #3
   15124:	73a3      	strb	r3, [r4, #14]
   15126:	7021      	strb	r1, [r4, #0]
   15128:	f44f 7396 	mov.w	r3, #300	; 0x12c
   1512c:	7062      	strb	r2, [r4, #1]
   1512e:	72a0      	strb	r0, [r4, #10]
   15130:	7321      	strb	r1, [r4, #12]
   15132:	7362      	strb	r2, [r4, #13]
   15134:	8423      	strh	r3, [r4, #32]
   15136:	bd38      	pop	{r3, r4, r5, pc}
    } else {
        ble_hs_cfg = *cfg;
   15138:	4605      	mov	r5, r0
   1513a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1513c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1513e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   15140:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   15142:	682b      	ldr	r3, [r5, #0]
   15144:	6023      	str	r3, [r4, #0]
   15146:	bd38      	pop	{r3, r4, r5, pc}
   15148:	20003b78 	.word	0x20003b78

0001514c <ble_hs_conn_can_alloc>:

static const uint8_t ble_hs_conn_null_addr[6];

int
ble_hs_conn_can_alloc(void)
{
   1514c:	b508      	push	{r3, lr}
#if !NIMBLE_OPT(CONNECT)
    return 0;
#endif

    return ble_hs_conn_pool.mp_num_free >= 1 &&
   1514e:	4b08      	ldr	r3, [pc, #32]	; (15170 <ble_hs_conn_can_alloc+0x24>)
           ble_l2cap_chan_pool.mp_num_free >= BLE_HS_CONN_MIN_CHANS &&
   15150:	689b      	ldr	r3, [r3, #8]
   15152:	2b00      	cmp	r3, #0
   15154:	dd09      	ble.n	1516a <ble_hs_conn_can_alloc+0x1e>
   15156:	4b07      	ldr	r3, [pc, #28]	; (15174 <ble_hs_conn_can_alloc+0x28>)
{
#if !NIMBLE_OPT(CONNECT)
    return 0;
#endif

    return ble_hs_conn_pool.mp_num_free >= 1 &&
   15158:	689b      	ldr	r3, [r3, #8]
   1515a:	2b02      	cmp	r3, #2
   1515c:	dd05      	ble.n	1516a <ble_hs_conn_can_alloc+0x1e>
           ble_l2cap_chan_pool.mp_num_free >= BLE_HS_CONN_MIN_CHANS &&
           ble_gatts_conn_can_alloc();
   1515e:	f7fe ff37 	bl	13fd0 <ble_gatts_conn_can_alloc>
#if !NIMBLE_OPT(CONNECT)
    return 0;
#endif

    return ble_hs_conn_pool.mp_num_free >= 1 &&
           ble_l2cap_chan_pool.mp_num_free >= BLE_HS_CONN_MIN_CHANS &&
   15162:	3000      	adds	r0, #0
   15164:	bf18      	it	ne
   15166:	2001      	movne	r0, #1
   15168:	bd08      	pop	{r3, pc}
   1516a:	2000      	movs	r0, #0
           ble_gatts_conn_can_alloc();
}
   1516c:	bd08      	pop	{r3, pc}
   1516e:	bf00      	nop
   15170:	20002218 	.word	0x20002218
   15174:	20003bc0 	.word	0x20003bc0

00015178 <ble_hs_conn_chan_find>:
    return NULL;
#endif

    struct ble_l2cap_chan *chan;

    SLIST_FOREACH(chan, &conn->bhc_channels, blc_next) {
   15178:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1517a:	b128      	cbz	r0, 15188 <ble_hs_conn_chan_find+0x10>
        if (chan->blc_cid == cid) {
   1517c:	8883      	ldrh	r3, [r0, #4]
   1517e:	428b      	cmp	r3, r1
   15180:	d004      	beq.n	1518c <ble_hs_conn_chan_find+0x14>
            return chan;
        }
        if (chan->blc_cid > cid) {
   15182:	d802      	bhi.n	1518a <ble_hs_conn_chan_find+0x12>
    return NULL;
#endif

    struct ble_l2cap_chan *chan;

    SLIST_FOREACH(chan, &conn->bhc_channels, blc_next) {
   15184:	6800      	ldr	r0, [r0, #0]
   15186:	e7f8      	b.n	1517a <ble_hs_conn_chan_find+0x2>
   15188:	4770      	bx	lr
        if (chan->blc_cid == cid) {
            return chan;
        }
        if (chan->blc_cid > cid) {
            return NULL;
   1518a:	2000      	movs	r0, #0
        }
    }

    return NULL;
}
   1518c:	4770      	bx	lr

0001518e <ble_hs_conn_chan_insert>:

int
ble_hs_conn_chan_insert(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
   1518e:	b570      	push	{r4, r5, r6, lr}

    struct ble_l2cap_chan *prev;
    struct ble_l2cap_chan *cur;

    prev = NULL;
    SLIST_FOREACH(cur, &conn->bhc_channels, blc_next) {
   15190:	6a44      	ldr	r4, [r0, #36]	; 0x24
#endif

    struct ble_l2cap_chan *prev;
    struct ble_l2cap_chan *cur;

    prev = NULL;
   15192:	2300      	movs	r3, #0
    SLIST_FOREACH(cur, &conn->bhc_channels, blc_next) {
   15194:	4622      	mov	r2, r4
   15196:	b122      	cbz	r2, 151a2 <ble_hs_conn_chan_insert+0x14>
        if (cur->blc_cid == chan->blc_cid) {
   15198:	8896      	ldrh	r6, [r2, #4]
   1519a:	888d      	ldrh	r5, [r1, #4]
   1519c:	42ae      	cmp	r6, r5
   1519e:	d00c      	beq.n	151ba <ble_hs_conn_chan_insert+0x2c>
            return BLE_HS_EALREADY;
        }
        if (cur->blc_cid > chan->blc_cid) {
   151a0:	d903      	bls.n	151aa <ble_hs_conn_chan_insert+0x1c>
        }

        prev = cur;
    }

    if (prev == NULL) {
   151a2:	b92b      	cbnz	r3, 151b0 <ble_hs_conn_chan_insert+0x22>
        SLIST_INSERT_HEAD(&conn->bhc_channels, chan, blc_next);
   151a4:	600c      	str	r4, [r1, #0]
   151a6:	6241      	str	r1, [r0, #36]	; 0x24
   151a8:	e005      	b.n	151b6 <ble_hs_conn_chan_insert+0x28>

    struct ble_l2cap_chan *prev;
    struct ble_l2cap_chan *cur;

    prev = NULL;
    SLIST_FOREACH(cur, &conn->bhc_channels, blc_next) {
   151aa:	4613      	mov	r3, r2
   151ac:	6812      	ldr	r2, [r2, #0]
   151ae:	e7f2      	b.n	15196 <ble_hs_conn_chan_insert+0x8>
    }

    if (prev == NULL) {
        SLIST_INSERT_HEAD(&conn->bhc_channels, chan, blc_next);
    } else {
        SLIST_INSERT_AFTER(prev, chan, blc_next);
   151b0:	681a      	ldr	r2, [r3, #0]
   151b2:	600a      	str	r2, [r1, #0]
   151b4:	6019      	str	r1, [r3, #0]
    }

    return 0;
   151b6:	2000      	movs	r0, #0
   151b8:	bd70      	pop	{r4, r5, r6, pc}
    struct ble_l2cap_chan *cur;

    prev = NULL;
    SLIST_FOREACH(cur, &conn->bhc_channels, blc_next) {
        if (cur->blc_cid == chan->blc_cid) {
            return BLE_HS_EALREADY;
   151ba:	2002      	movs	r0, #2
    } else {
        SLIST_INSERT_AFTER(prev, chan, blc_next);
    }

    return 0;
}
   151bc:	bd70      	pop	{r4, r5, r6, pc}
	...

000151c0 <ble_hs_conn_free>:
    ble_l2cap_chan_free(chan);
}

void
ble_hs_conn_free(struct ble_hs_conn *conn)
{
   151c0:	b510      	push	{r4, lr}
#endif

    struct ble_l2cap_chan *chan;
    int rc;

    if (conn == NULL) {
   151c2:	4604      	mov	r4, r0
   151c4:	b1b0      	cbz	r0, 151f4 <ble_hs_conn_free+0x34>
        return;
    }

    ble_att_svr_prep_clear(&conn->bhc_att_svr.basc_prep_list);
   151c6:	3030      	adds	r0, #48	; 0x30
   151c8:	f007 f986 	bl	1c4d8 <ble_att_svr_prep_clear>

    while ((chan = SLIST_FIRST(&conn->bhc_channels)) != NULL) {
   151cc:	6a60      	ldr	r0, [r4, #36]	; 0x24
   151ce:	b148      	cbz	r0, 151e4 <ble_hs_conn_free+0x24>
}

static void
ble_hs_conn_delete_chan(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
    if (conn->bhc_rx_chan == chan) {
   151d0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   151d2:	4283      	cmp	r3, r0
        conn->bhc_rx_chan = NULL;
   151d4:	bf04      	itt	eq
   151d6:	2300      	moveq	r3, #0
   151d8:	62a3      	streq	r3, [r4, #40]	; 0x28
    }

    SLIST_REMOVE(&conn->bhc_channels, chan, ble_l2cap_chan, blc_next);
   151da:	6803      	ldr	r3, [r0, #0]
   151dc:	6263      	str	r3, [r4, #36]	; 0x24
    ble_l2cap_chan_free(chan);
   151de:	f000 fb2b 	bl	15838 <ble_l2cap_chan_free>
   151e2:	e7f3      	b.n	151cc <ble_hs_conn_free+0xc>

    while ((chan = SLIST_FIRST(&conn->bhc_channels)) != NULL) {
        ble_hs_conn_delete_chan(conn, chan);
    }

    rc = os_memblock_put(&ble_hs_conn_pool, conn);
   151e4:	4804      	ldr	r0, [pc, #16]	; (151f8 <ble_hs_conn_free+0x38>)
   151e6:	4621      	mov	r1, r4
   151e8:	f7f5 f91a 	bl	a420 <os_memblock_put>
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    STATS_INC(ble_hs_stats, conn_delete);
   151ec:	4a03      	ldr	r2, [pc, #12]	; (151fc <ble_hs_conn_free+0x3c>)
   151ee:	6913      	ldr	r3, [r2, #16]
   151f0:	3301      	adds	r3, #1
   151f2:	6113      	str	r3, [r2, #16]
   151f4:	bd10      	pop	{r4, pc}
   151f6:	bf00      	nop
   151f8:	20002218 	.word	0x20002218
   151fc:	20003b1c 	.word	0x20003b1c

00015200 <ble_hs_conn_alloc>:
    return 0;
}

struct ble_hs_conn *
ble_hs_conn_alloc(void)
{
   15200:	b510      	push	{r4, lr}

    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    int rc;

    conn = os_memblock_get(&ble_hs_conn_pool);
   15202:	4819      	ldr	r0, [pc, #100]	; (15268 <ble_hs_conn_alloc+0x68>)
   15204:	f7f5 f8f8 	bl	a3f8 <os_memblock_get>
    if (conn == NULL) {
   15208:	4604      	mov	r4, r0
   1520a:	b340      	cbz	r0, 1525e <ble_hs_conn_alloc+0x5e>
        goto err;
    }
    memset(conn, 0, sizeof *conn);
   1520c:	2100      	movs	r1, #0
   1520e:	2250      	movs	r2, #80	; 0x50
   15210:	f7f3 feff 	bl	9012 <memset>

    SLIST_INIT(&conn->bhc_channels);
   15214:	2300      	movs	r3, #0
   15216:	6263      	str	r3, [r4, #36]	; 0x24

    chan = ble_att_create_chan();
   15218:	f004 fe04 	bl	19e24 <ble_att_create_chan>
    if (chan == NULL) {
   1521c:	4601      	mov	r1, r0
   1521e:	b1f0      	cbz	r0, 1525e <ble_hs_conn_alloc+0x5e>
        goto err;
    }
    rc = ble_hs_conn_chan_insert(conn, chan);
   15220:	4620      	mov	r0, r4
   15222:	f7ff ffb4 	bl	1518e <ble_hs_conn_chan_insert>
    if (rc != 0) {
   15226:	b9d0      	cbnz	r0, 1525e <ble_hs_conn_alloc+0x5e>
        goto err;
    }

    chan = ble_l2cap_sig_create_chan();
   15228:	f000 fd3a 	bl	15ca0 <ble_l2cap_sig_create_chan>
    if (chan == NULL) {
   1522c:	4601      	mov	r1, r0
   1522e:	b1b0      	cbz	r0, 1525e <ble_hs_conn_alloc+0x5e>
        goto err;
    }
    rc = ble_hs_conn_chan_insert(conn, chan);
   15230:	4620      	mov	r0, r4
   15232:	f7ff ffac 	bl	1518e <ble_hs_conn_chan_insert>
    if (rc != 0) {
   15236:	b990      	cbnz	r0, 1525e <ble_hs_conn_alloc+0x5e>

    /* XXX: We should create the SM channel even if not configured.  We need it
     * to reject SM messages.
     */
#if NIMBLE_OPT(SM)
    chan = ble_sm_create_chan();
   15238:	f002 f950 	bl	174dc <ble_sm_create_chan>
    if (chan == NULL) {
   1523c:	4601      	mov	r1, r0
   1523e:	b170      	cbz	r0, 1525e <ble_hs_conn_alloc+0x5e>
        goto err;
    }
    rc = ble_hs_conn_chan_insert(conn, chan);
   15240:	4620      	mov	r0, r4
   15242:	f7ff ffa4 	bl	1518e <ble_hs_conn_chan_insert>
    if (rc != 0) {
   15246:	b950      	cbnz	r0, 1525e <ble_hs_conn_alloc+0x5e>
        goto err;
    }
#endif

    rc = ble_gatts_conn_init(&conn->bhc_gatt_svr);
   15248:	f104 0038 	add.w	r0, r4, #56	; 0x38
   1524c:	f7fe fed0 	bl	13ff0 <ble_gatts_conn_init>
    if (rc != 0) {
   15250:	b928      	cbnz	r0, 1525e <ble_hs_conn_alloc+0x5e>
        goto err;
    }

    STATS_INC(ble_hs_stats, conn_create);
   15252:	4a06      	ldr	r2, [pc, #24]	; (1526c <ble_hs_conn_alloc+0x6c>)
   15254:	68d3      	ldr	r3, [r2, #12]
   15256:	3301      	adds	r3, #1
   15258:	60d3      	str	r3, [r2, #12]

    return conn;
   1525a:	4620      	mov	r0, r4
   1525c:	bd10      	pop	{r4, pc}

err:
    ble_hs_conn_free(conn);
   1525e:	4620      	mov	r0, r4
   15260:	f7ff ffae 	bl	151c0 <ble_hs_conn_free>
    return NULL;
   15264:	2000      	movs	r0, #0
}
   15266:	bd10      	pop	{r4, pc}
   15268:	20002218 	.word	0x20002218
   1526c:	20003b1c 	.word	0x20003b1c

00015270 <ble_hs_conn_remove>:
    return;
#endif

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    SLIST_REMOVE(&ble_hs_conns, conn, ble_hs_conn, bhc_next);
   15270:	4a07      	ldr	r2, [pc, #28]	; (15290 <ble_hs_conn_remove+0x20>)
   15272:	6813      	ldr	r3, [r2, #0]
   15274:	4283      	cmp	r3, r0
   15276:	d102      	bne.n	1527e <ble_hs_conn_remove+0xe>
   15278:	681b      	ldr	r3, [r3, #0]
   1527a:	6013      	str	r3, [r2, #0]
   1527c:	4770      	bx	lr
   1527e:	681a      	ldr	r2, [r3, #0]
   15280:	4282      	cmp	r2, r0
   15282:	d001      	beq.n	15288 <ble_hs_conn_remove+0x18>
   15284:	4613      	mov	r3, r2
   15286:	e7fa      	b.n	1527e <ble_hs_conn_remove+0xe>
   15288:	6802      	ldr	r2, [r0, #0]
   1528a:	601a      	str	r2, [r3, #0]
   1528c:	4770      	bx	lr
   1528e:	bf00      	nop
   15290:	20002234 	.word	0x20002234

00015294 <ble_hs_conn_find>:

    struct ble_hs_conn *conn;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   15294:	4b03      	ldr	r3, [pc, #12]	; (152a4 <ble_hs_conn_find+0x10>)
   15296:	681b      	ldr	r3, [r3, #0]
   15298:	b113      	cbz	r3, 152a0 <ble_hs_conn_find+0xc>
        if (conn->bhc_handle == conn_handle) {
   1529a:	889a      	ldrh	r2, [r3, #4]
   1529c:	4282      	cmp	r2, r0
   1529e:	d1fa      	bne.n	15296 <ble_hs_conn_find+0x2>
            return conn;
        }
    }

    return NULL;
}
   152a0:	4618      	mov	r0, r3
   152a2:	4770      	bx	lr
   152a4:	20002234 	.word	0x20002234

000152a8 <ble_hs_conn_insert>:
    STATS_INC(ble_hs_stats, conn_delete);
}

void
ble_hs_conn_insert(struct ble_hs_conn *conn)
{
   152a8:	b510      	push	{r4, lr}
   152aa:	4604      	mov	r4, r0
    return;
#endif

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    BLE_HS_DBG_ASSERT_EVAL(ble_hs_conn_find(conn->bhc_handle) == NULL);
   152ac:	8880      	ldrh	r0, [r0, #4]
   152ae:	f7ff fff1 	bl	15294 <ble_hs_conn_find>
    SLIST_INSERT_HEAD(&ble_hs_conns, conn, bhc_next);
   152b2:	4b02      	ldr	r3, [pc, #8]	; (152bc <ble_hs_conn_insert+0x14>)
   152b4:	681a      	ldr	r2, [r3, #0]
   152b6:	6022      	str	r2, [r4, #0]
   152b8:	601c      	str	r4, [r3, #0]
   152ba:	bd10      	pop	{r4, pc}
   152bc:	20002234 	.word	0x20002234

000152c0 <ble_hs_conn_find_by_addr>:

    struct ble_hs_conn *conn;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   152c0:	4b09      	ldr	r3, [pc, #36]	; (152e8 <ble_hs_conn_find_by_addr+0x28>)
    return NULL;
}

struct ble_hs_conn *
ble_hs_conn_find_by_addr(uint8_t addr_type, uint8_t *addr)
{
   152c2:	b570      	push	{r4, r5, r6, lr}

    struct ble_hs_conn *conn;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   152c4:	681c      	ldr	r4, [r3, #0]
    return NULL;
}

struct ble_hs_conn *
ble_hs_conn_find_by_addr(uint8_t addr_type, uint8_t *addr)
{
   152c6:	4605      	mov	r5, r0
   152c8:	460e      	mov	r6, r1

    struct ble_hs_conn *conn;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   152ca:	b15c      	cbz	r4, 152e4 <ble_hs_conn_find_by_addr+0x24>
        if (conn->bhc_peer_addr_type == addr_type &&
   152cc:	79a3      	ldrb	r3, [r4, #6]
   152ce:	42ab      	cmp	r3, r5
   152d0:	d106      	bne.n	152e0 <ble_hs_conn_find_by_addr+0x20>
            memcmp(conn->bhc_peer_addr, addr, 6) == 0) {
   152d2:	f104 0008 	add.w	r0, r4, #8
   152d6:	4631      	mov	r1, r6
   152d8:	2206      	movs	r2, #6
   152da:	f7f3 fe81 	bl	8fe0 <memcmp>
    struct ble_hs_conn *conn;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
        if (conn->bhc_peer_addr_type == addr_type &&
   152de:	b108      	cbz	r0, 152e4 <ble_hs_conn_find_by_addr+0x24>

    struct ble_hs_conn *conn;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   152e0:	6824      	ldr	r4, [r4, #0]
   152e2:	e7f2      	b.n	152ca <ble_hs_conn_find_by_addr+0xa>
            return conn;
        }
    }

    return NULL;
}
   152e4:	4620      	mov	r0, r4
   152e6:	bd70      	pop	{r4, r5, r6, pc}
   152e8:	20002234 	.word	0x20002234

000152ec <ble_hs_conn_find_by_idx>:
    int i;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    i = 0;
    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   152ec:	4b05      	ldr	r3, [pc, #20]	; (15304 <ble_hs_conn_find_by_idx+0x18>)
   152ee:	681b      	ldr	r3, [r3, #0]
    struct ble_hs_conn *conn;
    int i;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    i = 0;
   152f0:	2200      	movs	r2, #0
    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   152f2:	b123      	cbz	r3, 152fe <ble_hs_conn_find_by_idx+0x12>
        if (i == idx) {
   152f4:	4282      	cmp	r2, r0
   152f6:	d002      	beq.n	152fe <ble_hs_conn_find_by_idx+0x12>
            return conn;
        }

        i++;
   152f8:	3201      	adds	r2, #1
    int i;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    i = 0;
    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
   152fa:	681b      	ldr	r3, [r3, #0]
   152fc:	e7f9      	b.n	152f2 <ble_hs_conn_find_by_idx+0x6>

        i++;
    }

    return NULL;
}
   152fe:	4618      	mov	r0, r3
   15300:	4770      	bx	lr
   15302:	bf00      	nop
   15304:	20002234 	.word	0x20002234

00015308 <ble_hs_conn_exists>:

int
ble_hs_conn_exists(uint16_t conn_handle)
{
   15308:	b508      	push	{r3, lr}
#if !NIMBLE_OPT(CONNECT)
    return 0;
#endif
    return ble_hs_conn_find(conn_handle) != NULL;
   1530a:	f7ff ffc3 	bl	15294 <ble_hs_conn_find>
}
   1530e:	3000      	adds	r0, #0
   15310:	bf18      	it	ne
   15312:	2001      	movne	r0, #1
   15314:	bd08      	pop	{r3, pc}
	...

00015318 <ble_hs_conn_addrs>:
}

void
ble_hs_conn_addrs(const struct ble_hs_conn *conn,
                  struct ble_hs_conn_addrs *addrs)
{
   15318:	b570      	push	{r4, r5, r6, lr}
   1531a:	4605      	mov	r5, r0
    int rc;

    /* Determine our address information. */
    addrs->our_id_addr_type =
        ble_hs_misc_addr_type_to_id(conn->bhc_our_addr_type);
   1531c:	79c0      	ldrb	r0, [r0, #7]
}

void
ble_hs_conn_addrs(const struct ble_hs_conn *conn,
                  struct ble_hs_conn_addrs *addrs)
{
   1531e:	460c      	mov	r4, r1
    int rc;

    /* Determine our address information. */
    addrs->our_id_addr_type =
        ble_hs_misc_addr_type_to_id(conn->bhc_our_addr_type);
   15320:	f000 f942 	bl	155a8 <ble_hs_misc_addr_type_to_id>
    rc = ble_hs_id_addr(addrs->our_id_addr_type, &addrs->our_id_addr, NULL);
   15324:	f104 0108 	add.w	r1, r4, #8
                  struct ble_hs_conn_addrs *addrs)
{
    int rc;

    /* Determine our address information. */
    addrs->our_id_addr_type =
   15328:	7060      	strb	r0, [r4, #1]
        ble_hs_misc_addr_type_to_id(conn->bhc_our_addr_type);
    rc = ble_hs_id_addr(addrs->our_id_addr_type, &addrs->our_id_addr, NULL);
   1532a:	2200      	movs	r2, #0
   1532c:	f000 f876 	bl	1541c <ble_hs_id_addr>
    assert(rc == 0);
   15330:	b130      	cbz	r0, 15340 <ble_hs_conn_addrs+0x28>
   15332:	2200      	movs	r2, #0
   15334:	4817      	ldr	r0, [pc, #92]	; (15394 <ble_hs_conn_addrs+0x7c>)
   15336:	f240 1147 	movw	r1, #327	; 0x147
   1533a:	4613      	mov	r3, r2
   1533c:	f7f4 fcc8 	bl	9cd0 <__assert_func>

    if (memcmp(conn->bhc_our_rpa_addr, ble_hs_conn_null_addr, 6) == 0) {
   15340:	f105 060e 	add.w	r6, r5, #14
   15344:	4630      	mov	r0, r6
   15346:	4914      	ldr	r1, [pc, #80]	; (15398 <ble_hs_conn_addrs+0x80>)
   15348:	2206      	movs	r2, #6
   1534a:	f7f3 fe49 	bl	8fe0 <memcmp>
   1534e:	b920      	cbnz	r0, 1535a <ble_hs_conn_addrs+0x42>
        addrs->our_ota_addr_type = addrs->our_id_addr_type;
   15350:	7863      	ldrb	r3, [r4, #1]
   15352:	7023      	strb	r3, [r4, #0]
        addrs->our_ota_addr = addrs->our_id_addr;
   15354:	68a3      	ldr	r3, [r4, #8]
   15356:	6063      	str	r3, [r4, #4]
   15358:	e002      	b.n	15360 <ble_hs_conn_addrs+0x48>
    } else {
        addrs->our_ota_addr_type = conn->bhc_our_addr_type;
   1535a:	79eb      	ldrb	r3, [r5, #7]
   1535c:	7023      	strb	r3, [r4, #0]
        addrs->our_ota_addr = conn->bhc_our_rpa_addr;
   1535e:	6066      	str	r6, [r4, #4]
    }

    /* Determine peer address information. */
    addrs->peer_ota_addr_type = conn->bhc_peer_addr_type;
   15360:	79ab      	ldrb	r3, [r5, #6]
   15362:	70a3      	strb	r3, [r4, #2]
    addrs->peer_id_addr = conn->bhc_peer_addr;
   15364:	f105 0308 	add.w	r3, r5, #8
   15368:	6123      	str	r3, [r4, #16]
    switch (conn->bhc_peer_addr_type) {
   1536a:	79aa      	ldrb	r2, [r5, #6]
   1536c:	2a03      	cmp	r2, #3
   1536e:	d80f      	bhi.n	15390 <ble_hs_conn_addrs+0x78>
   15370:	e8df f002 	tbb	[pc, r2]
   15374:	0a080402 	.word	0x0a080402
    case BLE_ADDR_TYPE_PUBLIC:
        addrs->peer_id_addr_type = BLE_ADDR_TYPE_PUBLIC;
   15378:	2200      	movs	r2, #0
   1537a:	e000      	b.n	1537e <ble_hs_conn_addrs+0x66>
        addrs->peer_ota_addr = conn->bhc_peer_addr;
        break;

    case BLE_ADDR_TYPE_RANDOM:
        addrs->peer_id_addr_type = BLE_ADDR_TYPE_RANDOM;
   1537c:	2201      	movs	r2, #1
   1537e:	70e2      	strb	r2, [r4, #3]
        addrs->peer_ota_addr = conn->bhc_peer_addr;
   15380:	60e3      	str	r3, [r4, #12]
        break;
   15382:	bd70      	pop	{r4, r5, r6, pc}

    case BLE_ADDR_TYPE_RPA_PUB_DEFAULT:
        addrs->peer_id_addr_type = BLE_ADDR_TYPE_PUBLIC;
   15384:	2300      	movs	r3, #0
   15386:	e000      	b.n	1538a <ble_hs_conn_addrs+0x72>
        addrs->peer_ota_addr = conn->bhc_peer_rpa_addr;
        break;

    case BLE_ADDR_TYPE_RPA_RND_DEFAULT:
        addrs->peer_id_addr_type = BLE_ADDR_TYPE_RANDOM;
   15388:	2301      	movs	r3, #1
        addrs->peer_ota_addr = conn->bhc_peer_rpa_addr;
   1538a:	3514      	adds	r5, #20
        addrs->peer_id_addr_type = BLE_ADDR_TYPE_PUBLIC;
        addrs->peer_ota_addr = conn->bhc_peer_rpa_addr;
        break;

    case BLE_ADDR_TYPE_RPA_RND_DEFAULT:
        addrs->peer_id_addr_type = BLE_ADDR_TYPE_RANDOM;
   1538c:	70e3      	strb	r3, [r4, #3]
        addrs->peer_ota_addr = conn->bhc_peer_rpa_addr;
   1538e:	60e5      	str	r5, [r4, #12]
   15390:	bd70      	pop	{r4, r5, r6, pc}
   15392:	bf00      	nop
   15394:	0001fa68 	.word	0x0001fa68
   15398:	20002238 	.word	0x20002238

0001539c <ble_hs_conn_init>:
    ble_hs_conn_elem_mem = NULL;
}

int 
ble_hs_conn_init(void)
{
   1539c:	b573      	push	{r0, r1, r4, r5, r6, lr}
}

static void
ble_hs_conn_free_mem(void)
{
    free(ble_hs_conn_elem_mem);
   1539e:	4c12      	ldr	r4, [pc, #72]	; (153e8 <ble_hs_conn_init+0x4c>)
   153a0:	6820      	ldr	r0, [r4, #0]
   153a2:	f008 fb81 	bl	1daa8 <free>
    int rc;

    ble_hs_conn_free_mem();

    ble_hs_conn_elem_mem = malloc(
        OS_MEMPOOL_BYTES(ble_hs_cfg.max_connections,
   153a6:	4b11      	ldr	r3, [pc, #68]	; (153ec <ble_hs_conn_init+0x50>)
   153a8:	785e      	ldrb	r6, [r3, #1]
{
    int rc;

    ble_hs_conn_free_mem();

    ble_hs_conn_elem_mem = malloc(
   153aa:	eb06 0086 	add.w	r0, r6, r6, lsl #2
   153ae:	0100      	lsls	r0, r0, #4
   153b0:	f008 fb30 	bl	1da14 <malloc>
   153b4:	4625      	mov	r5, r4
   153b6:	4603      	mov	r3, r0
   153b8:	6020      	str	r0, [r4, #0]
        OS_MEMPOOL_BYTES(ble_hs_cfg.max_connections,
                         sizeof (struct ble_hs_conn)));
    if (ble_hs_conn_elem_mem == NULL) {
   153ba:	b150      	cbz	r0, 153d2 <ble_hs_conn_init+0x36>
        rc = BLE_HS_ENOMEM;
        goto err;
    }
    rc = os_mempool_init(&ble_hs_conn_pool, ble_hs_cfg.max_connections,
   153bc:	4a0c      	ldr	r2, [pc, #48]	; (153f0 <ble_hs_conn_init+0x54>)
   153be:	9200      	str	r2, [sp, #0]
   153c0:	480c      	ldr	r0, [pc, #48]	; (153f4 <ble_hs_conn_init+0x58>)
   153c2:	4631      	mov	r1, r6
   153c4:	2250      	movs	r2, #80	; 0x50
   153c6:	f7f4 ffe3 	bl	a390 <os_mempool_init>
                         sizeof (struct ble_hs_conn),
                         ble_hs_conn_elem_mem, "ble_hs_conn_pool");
    if (rc != 0) {
   153ca:	b920      	cbnz	r0, 153d6 <ble_hs_conn_init+0x3a>
        rc = BLE_HS_EOS;
        goto err;
    }

    SLIST_INIT(&ble_hs_conns);
   153cc:	4b0a      	ldr	r3, [pc, #40]	; (153f8 <ble_hs_conn_init+0x5c>)
   153ce:	6018      	str	r0, [r3, #0]

    return 0;
   153d0:	e008      	b.n	153e4 <ble_hs_conn_init+0x48>

    ble_hs_conn_elem_mem = malloc(
        OS_MEMPOOL_BYTES(ble_hs_cfg.max_connections,
                         sizeof (struct ble_hs_conn)));
    if (ble_hs_conn_elem_mem == NULL) {
        rc = BLE_HS_ENOMEM;
   153d2:	2406      	movs	r4, #6
   153d4:	e000      	b.n	153d8 <ble_hs_conn_init+0x3c>
    }
    rc = os_mempool_init(&ble_hs_conn_pool, ble_hs_cfg.max_connections,
                         sizeof (struct ble_hs_conn),
                         ble_hs_conn_elem_mem, "ble_hs_conn_pool");
    if (rc != 0) {
        rc = BLE_HS_EOS;
   153d6:	240b      	movs	r4, #11
}

static void
ble_hs_conn_free_mem(void)
{
    free(ble_hs_conn_elem_mem);
   153d8:	6828      	ldr	r0, [r5, #0]
   153da:	f008 fb65 	bl	1daa8 <free>
    ble_hs_conn_elem_mem = NULL;
   153de:	2300      	movs	r3, #0
   153e0:	602b      	str	r3, [r5, #0]

    return 0;

err:
    ble_hs_conn_free_mem();
    return rc;
   153e2:	4620      	mov	r0, r4
}
   153e4:	b002      	add	sp, #8
   153e6:	bd70      	pop	{r4, r5, r6, pc}
   153e8:	20002214 	.word	0x20002214
   153ec:	20003b78 	.word	0x20003b78
   153f0:	0001fa76 	.word	0x0001fa76
   153f4:	20002218 	.word	0x20002218
   153f8:	20002234 	.word	0x20002234

000153fc <ble_hs_id_set_pub>:
static uint8_t ble_hs_id_pub[6];
static uint8_t ble_hs_id_rnd[6];

void
ble_hs_id_set_pub(const uint8_t *pub_addr)
{
   153fc:	b510      	push	{r4, lr}
   153fe:	4604      	mov	r4, r0
    ble_hs_lock();
   15400:	f7ff f9a0 	bl	14744 <ble_hs_lock>
    memcpy(ble_hs_id_pub, pub_addr, 6);
   15404:	4b04      	ldr	r3, [pc, #16]	; (15418 <ble_hs_id_set_pub+0x1c>)
   15406:	6822      	ldr	r2, [r4, #0]
   15408:	601a      	str	r2, [r3, #0]
   1540a:	88a2      	ldrh	r2, [r4, #4]
   1540c:	809a      	strh	r2, [r3, #4]
    ble_hs_unlock();
}
   1540e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void
ble_hs_id_set_pub(const uint8_t *pub_addr)
{
    ble_hs_lock();
    memcpy(ble_hs_id_pub, pub_addr, 6);
    ble_hs_unlock();
   15412:	f7ff b99f 	b.w	14754 <ble_hs_unlock>
   15416:	bf00      	nop
   15418:	2000223e 	.word	0x2000223e

0001541c <ble_hs_id_addr>:
 *                              Other BLE host core code on error.
 */
int
ble_hs_id_addr(uint8_t id_addr_type, const uint8_t **out_id_addr,
               int *out_is_nrpa)
{
   1541c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1541e:	460f      	mov	r7, r1
   15420:	4614      	mov	r4, r2
    const uint8_t *id_addr;
    int nrpa;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    switch (id_addr_type) {
   15422:	b148      	cbz	r0, 15438 <ble_hs_id_addr+0x1c>
   15424:	2801      	cmp	r0, #1
   15426:	d115      	bne.n	15454 <ble_hs_id_addr+0x38>
        nrpa = 0;
        break;

    case BLE_ADDR_TYPE_RANDOM:
        id_addr = ble_hs_id_rnd;
        nrpa = (ble_hs_id_rnd[5] & 0xc0) == 0;
   15428:	4e0c      	ldr	r6, [pc, #48]	; (1545c <ble_hs_id_addr+0x40>)
   1542a:	7973      	ldrb	r3, [r6, #5]
   1542c:	f013 0fc0 	tst.w	r3, #192	; 0xc0
   15430:	bf0c      	ite	eq
   15432:	2501      	moveq	r5, #1
   15434:	2500      	movne	r5, #0
        break;
   15436:	e001      	b.n	1543c <ble_hs_id_addr+0x20>

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    switch (id_addr_type) {
    case BLE_ADDR_TYPE_PUBLIC:
        id_addr = ble_hs_id_pub;
   15438:	4e09      	ldr	r6, [pc, #36]	; (15460 <ble_hs_id_addr+0x44>)
        nrpa = 0;
   1543a:	4605      	mov	r5, r0

    default:
        return BLE_HS_EINVAL;
    }

    if (memcmp(id_addr, ble_hs_misc_null_addr, 6) == 0) {
   1543c:	4630      	mov	r0, r6
   1543e:	4909      	ldr	r1, [pc, #36]	; (15464 <ble_hs_id_addr+0x48>)
   15440:	2206      	movs	r2, #6
   15442:	f7f3 fdcd 	bl	8fe0 <memcmp>
   15446:	b138      	cbz	r0, 15458 <ble_hs_id_addr+0x3c>
        return BLE_HS_ENOADDR;
    }

    if (out_id_addr != NULL) {
   15448:	b107      	cbz	r7, 1544c <ble_hs_id_addr+0x30>
        *out_id_addr = id_addr;
   1544a:	603e      	str	r6, [r7, #0]
    }
    if (out_is_nrpa != NULL) {
   1544c:	b104      	cbz	r4, 15450 <ble_hs_id_addr+0x34>
        *out_is_nrpa = nrpa;
   1544e:	6025      	str	r5, [r4, #0]
    }

    return 0;
   15450:	2000      	movs	r0, #0
   15452:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        id_addr = ble_hs_id_rnd;
        nrpa = (ble_hs_id_rnd[5] & 0xc0) == 0;
        break;

    default:
        return BLE_HS_EINVAL;
   15454:	2003      	movs	r0, #3
   15456:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    if (memcmp(id_addr, ble_hs_misc_null_addr, 6) == 0) {
        return BLE_HS_ENOADDR;
   15458:	2015      	movs	r0, #21
   1545a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1545c:	20002244 	.word	0x20002244
   15460:	2000223e 	.word	0x2000223e
   15464:	20003ba8 	.word	0x20003ba8

00015468 <ble_hs_id_use_addr>:
    return rc;
}

int
ble_hs_id_use_addr(uint8_t addr_type)
{
   15468:	b507      	push	{r0, r1, r2, lr}
    uint8_t id_addr_type;
    int nrpa;
    int rc;

    switch (addr_type) {
   1546a:	2803      	cmp	r0, #3
   1546c:	d814      	bhi.n	15498 <ble_hs_id_use_addr+0x30>
   1546e:	e8df f000 	tbb	[pc, r0]
   15472:	0202      	.short	0x0202
   15474:	0707      	.short	0x0707
    case BLE_ADDR_TYPE_PUBLIC:
    case BLE_ADDR_TYPE_RANDOM:
        rc = ble_hs_id_addr(addr_type, NULL, NULL);
   15476:	2100      	movs	r1, #0
   15478:	460a      	mov	r2, r1
   1547a:	f7ff ffcf 	bl	1541c <ble_hs_id_addr>
   1547e:	e00e      	b.n	1549e <ble_hs_id_use_addr+0x36>
        }
        break;

    case BLE_ADDR_TYPE_RPA_PUB_DEFAULT:
    case BLE_ADDR_TYPE_RPA_RND_DEFAULT:
        id_addr_type = ble_hs_misc_addr_type_to_id(addr_type);
   15480:	f000 f892 	bl	155a8 <ble_hs_misc_addr_type_to_id>
        rc = ble_hs_id_addr(id_addr_type, NULL, &nrpa);
   15484:	2100      	movs	r1, #0
   15486:	aa01      	add	r2, sp, #4
   15488:	f7ff ffc8 	bl	1541c <ble_hs_id_addr>
        if (rc != 0) {
   1548c:	b938      	cbnz	r0, 1549e <ble_hs_id_use_addr+0x36>
            return rc;
        }
        if (nrpa) {
   1548e:	9b01      	ldr	r3, [sp, #4]
   15490:	b923      	cbnz	r3, 1549c <ble_hs_id_use_addr+0x34>
            return BLE_HS_ENOADDR;
        }

        rc = ble_hs_pvcy_ensure_started();
   15492:	f000 f8d1 	bl	15638 <ble_hs_pvcy_ensure_started>
   15496:	e002      	b.n	1549e <ble_hs_id_use_addr+0x36>
            return rc;
        }
        break;

    default:
        return BLE_HS_EINVAL;
   15498:	2003      	movs	r0, #3
   1549a:	e000      	b.n	1549e <ble_hs_id_use_addr+0x36>
        rc = ble_hs_id_addr(id_addr_type, NULL, &nrpa);
        if (rc != 0) {
            return rc;
        }
        if (nrpa) {
            return BLE_HS_ENOADDR;
   1549c:	2015      	movs	r0, #21
    default:
        return BLE_HS_EINVAL;
    }

    return 0;
}
   1549e:	b003      	add	sp, #12
   154a0:	f85d fb04 	ldr.w	pc, [sp], #4

000154a4 <ble_hs_log_mbuf>:

struct log ble_hs_log;

void
ble_hs_log_mbuf(const struct os_mbuf *om)
{
   154a4:	b530      	push	{r4, r5, lr}
   154a6:	4605      	mov	r5, r0
   154a8:	b085      	sub	sp, #20
    uint8_t u8;
    int i;

    for (i = 0; i < OS_MBUF_PKTLEN(om); i++) {
   154aa:	2400      	movs	r4, #0
   154ac:	8a2b      	ldrh	r3, [r5, #16]
   154ae:	429c      	cmp	r4, r3
   154b0:	da11      	bge.n	154d6 <ble_hs_log_mbuf+0x32>
        os_mbuf_copydata(om, i, 1, &u8);
   154b2:	4621      	mov	r1, r4
   154b4:	2201      	movs	r2, #1
   154b6:	f10d 030f 	add.w	r3, sp, #15
   154ba:	4628      	mov	r0, r5
   154bc:	f7f4 fdd8 	bl	a070 <os_mbuf_copydata>
        BLE_HS_LOG(DEBUG, "0x%02x ", u8);
   154c0:	f89d 300f 	ldrb.w	r3, [sp, #15]
   154c4:	9300      	str	r3, [sp, #0]
   154c6:	4805      	ldr	r0, [pc, #20]	; (154dc <ble_hs_log_mbuf+0x38>)
   154c8:	4b05      	ldr	r3, [pc, #20]	; (154e0 <ble_hs_log_mbuf+0x3c>)
   154ca:	2104      	movs	r1, #4
   154cc:	2200      	movs	r2, #0
   154ce:	f007 feab 	bl	1d228 <log_printf>
ble_hs_log_mbuf(const struct os_mbuf *om)
{
    uint8_t u8;
    int i;

    for (i = 0; i < OS_MBUF_PKTLEN(om); i++) {
   154d2:	3401      	adds	r4, #1
   154d4:	e7ea      	b.n	154ac <ble_hs_log_mbuf+0x8>
        os_mbuf_copydata(om, i, 1, &u8);
        BLE_HS_LOG(DEBUG, "0x%02x ", u8);
    }
}
   154d6:	b005      	add	sp, #20
   154d8:	bd30      	pop	{r4, r5, pc}
   154da:	bf00      	nop
   154dc:	20003b9c 	.word	0x20003b9c
   154e0:	0001fa87 	.word	0x0001fa87

000154e4 <ble_hs_log_flat_buf>:

void
ble_hs_log_flat_buf(const void *data, int len)
{
   154e4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   154e6:	4605      	mov	r5, r0
   154e8:	460e      	mov	r6, r1
    const uint8_t *u8ptr;
    int i;

    u8ptr = data;
    for (i = 0; i < len; i++) {
   154ea:	4604      	mov	r4, r0
   154ec:	1b63      	subs	r3, r4, r5
   154ee:	42b3      	cmp	r3, r6
   154f0:	da09      	bge.n	15506 <ble_hs_log_flat_buf+0x22>
        BLE_HS_LOG(DEBUG, "0x%02x ", u8ptr[i]);
   154f2:	f814 3b01 	ldrb.w	r3, [r4], #1
   154f6:	9300      	str	r3, [sp, #0]
   154f8:	4804      	ldr	r0, [pc, #16]	; (1550c <ble_hs_log_flat_buf+0x28>)
   154fa:	4b05      	ldr	r3, [pc, #20]	; (15510 <ble_hs_log_flat_buf+0x2c>)
   154fc:	2104      	movs	r1, #4
   154fe:	2200      	movs	r2, #0
   15500:	f007 fe92 	bl	1d228 <log_printf>
   15504:	e7f2      	b.n	154ec <ble_hs_log_flat_buf+0x8>
    }
}
   15506:	b002      	add	sp, #8
   15508:	bd70      	pop	{r4, r5, r6, pc}
   1550a:	bf00      	nop
   1550c:	20003b9c 	.word	0x20003b9c
   15510:	0001fa87 	.word	0x0001fa87

00015514 <ble_hs_misc_pkthdr>:
ble_hs_misc_pkthdr(void)
{
    struct os_mbuf *om;
    int rc;

    om = os_msys_get_pkthdr(0, 0);
   15514:	2000      	movs	r0, #0
/**
 * Allocates an mbuf for use by the nimble host.
 */
struct os_mbuf *
ble_hs_misc_pkthdr(void)
{
   15516:	b508      	push	{r3, lr}
    struct os_mbuf *om;
    int rc;

    om = os_msys_get_pkthdr(0, 0);
   15518:	4601      	mov	r1, r0
   1551a:	f7f4 fd0a 	bl	9f32 <os_msys_get_pkthdr>
    if (om == NULL) {
   1551e:	b128      	cbz	r0, 1552c <ble_hs_misc_pkthdr+0x18>
        return NULL;
    }

    /* Make room in the buffer for various headers.  XXX Check this number. */
    if (om->om_omp->omp_databuf_len < 8) {
   15520:	6882      	ldr	r2, [r0, #8]
   15522:	8812      	ldrh	r2, [r2, #0]
   15524:	2a07      	cmp	r2, #7
   15526:	d803      	bhi.n	15530 <ble_hs_misc_pkthdr+0x1c>
        rc = os_mbuf_free_chain(om);
   15528:	f7f4 fd19 	bl	9f5e <os_mbuf_free_chain>
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
        return NULL;
   1552c:	2000      	movs	r0, #0
   1552e:	bd08      	pop	{r3, pc}
    }

    om->om_data += 8;
   15530:	6802      	ldr	r2, [r0, #0]
   15532:	3208      	adds	r2, #8
   15534:	6002      	str	r2, [r0, #0]

    return om;
   15536:	bd08      	pop	{r3, pc}

00015538 <ble_hs_misc_pullup_base>:
}

int
ble_hs_misc_pullup_base(struct os_mbuf **om, int base_len)
{
   15538:	b510      	push	{r4, lr}
   1553a:	4604      	mov	r4, r0
    if (OS_MBUF_PKTLEN(*om) < base_len) {
   1553c:	6800      	ldr	r0, [r0, #0]
   1553e:	8a03      	ldrh	r3, [r0, #16]
   15540:	428b      	cmp	r3, r1
   15542:	db08      	blt.n	15556 <ble_hs_misc_pullup_base+0x1e>
        return BLE_HS_EBADDATA;
    }

    *om = os_mbuf_pullup(*om, base_len);
   15544:	b289      	uxth	r1, r1
   15546:	f7f4 fec1 	bl	a2cc <os_mbuf_pullup>
    if (*om == NULL) {
   1554a:	2800      	cmp	r0, #0
{
    if (OS_MBUF_PKTLEN(*om) < base_len) {
        return BLE_HS_EBADDATA;
    }

    *om = os_mbuf_pullup(*om, base_len);
   1554c:	6020      	str	r0, [r4, #0]
    if (*om == NULL) {
        return BLE_HS_ENOMEM;
    }

    return 0;
   1554e:	bf0c      	ite	eq
   15550:	2006      	moveq	r0, #6
   15552:	2000      	movne	r0, #0
   15554:	bd10      	pop	{r4, pc}

int
ble_hs_misc_pullup_base(struct os_mbuf **om, int base_len)
{
    if (OS_MBUF_PKTLEN(*om) < base_len) {
        return BLE_HS_EBADDATA;
   15556:	200a      	movs	r0, #10
    if (*om == NULL) {
        return BLE_HS_ENOMEM;
    }

    return 0;
}
   15558:	bd10      	pop	{r4, pc}

0001555a <ble_hs_misc_conn_chan_find>:

int
ble_hs_misc_conn_chan_find(uint16_t conn_handle, uint16_t cid,
                           struct ble_hs_conn **out_conn,
                           struct ble_l2cap_chan **out_chan)
{
   1555a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1555c:	460f      	mov	r7, r1
   1555e:	4615      	mov	r5, r2
   15560:	461c      	mov	r4, r3
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    int rc;

    conn = ble_hs_conn_find(conn_handle);
   15562:	f7ff fe97 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   15566:	4606      	mov	r6, r0
   15568:	b140      	cbz	r0, 1557c <ble_hs_misc_conn_chan_find+0x22>
        chan = NULL;
        rc = BLE_HS_ENOTCONN;
    } else {
        chan = ble_hs_conn_chan_find(conn, cid);
   1556a:	4639      	mov	r1, r7
   1556c:	f7ff fe04 	bl	15178 <ble_hs_conn_chan_find>
        if (chan == NULL) {
            rc = BLE_HS_ENOTCONN;
        } else {
            rc = 0;
   15570:	4603      	mov	r3, r0
   15572:	2800      	cmp	r0, #0
   15574:	bf0c      	ite	eq
   15576:	2007      	moveq	r0, #7
   15578:	2000      	movne	r0, #0
   1557a:	e001      	b.n	15580 <ble_hs_misc_conn_chan_find+0x26>
    int rc;

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        chan = NULL;
        rc = BLE_HS_ENOTCONN;
   1557c:	2007      	movs	r0, #7
    struct ble_hs_conn *conn;
    int rc;

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        chan = NULL;
   1557e:	4633      	mov	r3, r6
        } else {
            rc = 0;
        }
    }

    if (out_conn != NULL) {
   15580:	b105      	cbz	r5, 15584 <ble_hs_misc_conn_chan_find+0x2a>
        *out_conn = conn;
   15582:	602e      	str	r6, [r5, #0]
    }
    if (out_chan != NULL) {
   15584:	b104      	cbz	r4, 15588 <ble_hs_misc_conn_chan_find+0x2e>
        *out_chan = chan;
   15586:	6023      	str	r3, [r4, #0]
    }

    return rc;
}
   15588:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001558a <ble_hs_misc_conn_chan_find_reqd>:

int
ble_hs_misc_conn_chan_find_reqd(uint16_t conn_handle, uint16_t cid,
                                struct ble_hs_conn **out_conn,
                                struct ble_l2cap_chan **out_chan)
{
   1558a:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1558c:	4615      	mov	r5, r2
   1558e:	461c      	mov	r4, r3
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    int rc;

    rc = ble_hs_misc_conn_chan_find(conn_handle, cid, &conn, &chan);
   15590:	aa01      	add	r2, sp, #4
   15592:	466b      	mov	r3, sp
   15594:	f7ff ffe1 	bl	1555a <ble_hs_misc_conn_chan_find>
    BLE_HS_DBG_ASSERT(conn == NULL || chan != NULL);

    if (out_conn != NULL) {
   15598:	b10d      	cbz	r5, 1559e <ble_hs_misc_conn_chan_find_reqd+0x14>
        *out_conn = conn;
   1559a:	9b01      	ldr	r3, [sp, #4]
   1559c:	602b      	str	r3, [r5, #0]
    }
    if (out_chan != NULL) {
   1559e:	b10c      	cbz	r4, 155a4 <ble_hs_misc_conn_chan_find_reqd+0x1a>
        *out_chan = chan;
   155a0:	9b00      	ldr	r3, [sp, #0]
   155a2:	6023      	str	r3, [r4, #0]
    }

    return rc;
}
   155a4:	b003      	add	sp, #12
   155a6:	bd30      	pop	{r4, r5, pc}

000155a8 <ble_hs_misc_addr_type_to_id>:

uint8_t
ble_hs_misc_addr_type_to_id(uint8_t addr_type)
{
    switch (addr_type) {
   155a8:	2801      	cmp	r0, #1
   155aa:	d001      	beq.n	155b0 <ble_hs_misc_addr_type_to_id+0x8>
   155ac:	2803      	cmp	r0, #3
   155ae:	d101      	bne.n	155b4 <ble_hs_misc_addr_type_to_id+0xc>
    case BLE_ADDR_TYPE_RPA_PUB_DEFAULT:
         return BLE_ADDR_TYPE_PUBLIC;

    case BLE_ADDR_TYPE_RANDOM:
    case BLE_ADDR_TYPE_RPA_RND_DEFAULT:
         return BLE_ADDR_TYPE_RANDOM;
   155b0:	2001      	movs	r0, #1
   155b2:	4770      	bx	lr
ble_hs_misc_addr_type_to_id(uint8_t addr_type)
{
    switch (addr_type) {
    case BLE_ADDR_TYPE_PUBLIC:
    case BLE_ADDR_TYPE_RPA_PUB_DEFAULT:
         return BLE_ADDR_TYPE_PUBLIC;
   155b4:	2000      	movs	r0, #0

    default:
        BLE_HS_DBG_ASSERT(0);
        return BLE_ADDR_TYPE_PUBLIC;
    }
}
   155b6:	4770      	bx	lr

000155b8 <ble_hs_pvcy_set_resolve_enabled>:
    return rc;
}

static int
ble_hs_pvcy_set_resolve_enabled(int enable)
{
   155b8:	b507      	push	{r0, r1, r2, lr}
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_SET_ADDR_RESOL_ENA_LEN];
    int rc;

    rc = host_hci_cmd_build_set_addr_res_en(enable, buf, sizeof(buf));
   155ba:	b2c0      	uxtb	r0, r0
   155bc:	a901      	add	r1, sp, #4
   155be:	2204      	movs	r2, #4
   155c0:	f004 f9c6 	bl	19950 <host_hci_cmd_build_set_addr_res_en>
    if (rc != 0) {
   155c4:	4601      	mov	r1, r0
   155c6:	b920      	cbnz	r0, 155d2 <ble_hs_pvcy_set_resolve_enabled+0x1a>
        return rc;
    }

    rc = ble_hci_cmd_tx(buf, NULL, 0, NULL);
   155c8:	a801      	add	r0, sp, #4
   155ca:	460a      	mov	r2, r1
   155cc:	460b      	mov	r3, r1
   155ce:	f7fe ff97 	bl	14500 <ble_hci_cmd_tx>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   155d2:	b003      	add	sp, #12
   155d4:	f85d fb04 	ldr.w	pc, [sp], #4

000155d8 <ble_hs_pvcy_add_entry>:
    return 0;
}

int
ble_hs_pvcy_add_entry(uint8_t *addr, uint8_t addr_type, uint8_t *irk)
{
   155d8:	b510      	push	{r4, lr}
   155da:	b096      	sub	sp, #88	; 0x58
    struct hci_add_dev_to_resolving_list add;
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_ADD_TO_RESOLV_LIST_LEN];
    int rc;

    add.addr_type = addr_type;
    memcpy(add.addr, addr, 6);
   155dc:	6803      	ldr	r3, [r0, #0]
   155de:	f8cd 3005 	str.w	r3, [sp, #5]
   155e2:	8883      	ldrh	r3, [r0, #4]
   155e4:	f8ad 3009 	strh.w	r3, [sp, #9]
    memcpy(add.local_irk, ble_hs_pvcy_irk, 16);
   155e8:	4b12      	ldr	r3, [pc, #72]	; (15634 <ble_hs_pvcy_add_entry+0x5c>)
{
    struct hci_add_dev_to_resolving_list add;
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_ADD_TO_RESOLV_LIST_LEN];
    int rc;

    add.addr_type = addr_type;
   155ea:	f88d 1004 	strb.w	r1, [sp, #4]
    memcpy(add.addr, addr, 6);
    memcpy(add.local_irk, ble_hs_pvcy_irk, 16);
   155ee:	f103 0010 	add.w	r0, r3, #16
   155f2:	f10d 010b 	add.w	r1, sp, #11
   155f6:	f853 4b04 	ldr.w	r4, [r3], #4
   155fa:	f841 4b04 	str.w	r4, [r1], #4
   155fe:	4283      	cmp	r3, r0
   15600:	d1f9      	bne.n	155f6 <ble_hs_pvcy_add_entry+0x1e>
    memcpy(add.peer_irk, irk, 16);
   15602:	f10d 031b 	add.w	r3, sp, #27
   15606:	f102 0110 	add.w	r1, r2, #16
   1560a:	f852 0b04 	ldr.w	r0, [r2], #4
   1560e:	f843 0b04 	str.w	r0, [r3], #4
   15612:	428a      	cmp	r2, r1
   15614:	d1f9      	bne.n	1560a <ble_hs_pvcy_add_entry+0x32>

    rc = host_hci_cmd_build_add_to_resolv_list(&add, buf, sizeof(buf));
   15616:	a90b      	add	r1, sp, #44	; 0x2c
   15618:	a801      	add	r0, sp, #4
   1561a:	222a      	movs	r2, #42	; 0x2a
   1561c:	f004 f962 	bl	198e4 <host_hci_cmd_build_add_to_resolv_list>
    if (rc != 0) {
   15620:	4601      	mov	r1, r0
   15622:	b920      	cbnz	r0, 1562e <ble_hs_pvcy_add_entry+0x56>
        return rc;
    }

    rc = ble_hci_cmd_tx(buf, NULL, 0, NULL);
   15624:	a80b      	add	r0, sp, #44	; 0x2c
   15626:	460a      	mov	r2, r1
   15628:	460b      	mov	r3, r1
   1562a:	f7fe ff69 	bl	14500 <ble_hci_cmd_tx>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1562e:	b016      	add	sp, #88	; 0x58
   15630:	bd10      	pop	{r4, pc}
   15632:	bf00      	nop
   15634:	20003bae 	.word	0x20003bae

00015638 <ble_hs_pvcy_ensure_started>:

int
ble_hs_pvcy_ensure_started(void)
{
   15638:	b513      	push	{r0, r1, r4, lr}
    int rc;

    if (ble_hs_pvcy_started) {
   1563a:	4c08      	ldr	r4, [pc, #32]	; (1565c <ble_hs_pvcy_ensure_started+0x24>)
   1563c:	7823      	ldrb	r3, [r4, #0]
   1563e:	b94b      	cbnz	r3, 15654 <ble_hs_pvcy_ensure_started+0x1c>
ble_hs_pvcy_set_addr_timeout(uint16_t timeout)
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_SET_RESOLV_PRIV_ADDR_TO_LEN];
    int rc;

    rc = host_hci_cmd_build_set_resolv_priv_addr_timeout(
   15640:	4b07      	ldr	r3, [pc, #28]	; (15660 <ble_hs_pvcy_ensure_started+0x28>)
   15642:	4669      	mov	r1, sp
   15644:	8c18      	ldrh	r0, [r3, #32]
   15646:	2205      	movs	r2, #5
   15648:	f004 f992 	bl	19970 <host_hci_cmd_build_set_resolv_priv_addr_timeout>
        return 0;
    }

    /* Set up the periodic change of our RPA. */
    rc = ble_hs_pvcy_set_addr_timeout(ble_hs_cfg.rpa_timeout);
    if (rc != 0) {
   1564c:	b918      	cbnz	r0, 15656 <ble_hs_pvcy_ensure_started+0x1e>
        return rc;
    }

    ble_hs_pvcy_started = 1;
   1564e:	2301      	movs	r3, #1
   15650:	7023      	strb	r3, [r4, #0]

    return 0;
   15652:	e000      	b.n	15656 <ble_hs_pvcy_ensure_started+0x1e>
ble_hs_pvcy_ensure_started(void)
{
    int rc;

    if (ble_hs_pvcy_started) {
        return 0;
   15654:	2000      	movs	r0, #0
    }

    ble_hs_pvcy_started = 1;

    return 0;
}
   15656:	b002      	add	sp, #8
   15658:	bd10      	pop	{r4, pc}
   1565a:	bf00      	nop
   1565c:	2000224a 	.word	0x2000224a
   15660:	20003b78 	.word	0x20003b78

00015664 <ble_hs_pvcy_set_our_irk>:

void
ble_hs_pvcy_set_our_irk(const uint8_t *irk)
{
   15664:	b530      	push	{r4, r5, lr}
   15666:	b087      	sub	sp, #28
   15668:	4604      	mov	r4, r0
    uint8_t tmp_addr[6];
    uint8_t new_irk[16];

    memset(new_irk, 0, sizeof(new_irk));
   1566a:	2100      	movs	r1, #0
   1566c:	a802      	add	r0, sp, #8
   1566e:	2210      	movs	r2, #16
   15670:	f7f3 fccf 	bl	9012 <memset>

    if (irk != NULL) {
   15674:	b164      	cbz	r4, 15690 <ble_hs_pvcy_set_our_irk+0x2c>
        memcpy(new_irk, irk, 16);
   15676:	4623      	mov	r3, r4
   15678:	f103 0510 	add.w	r5, r3, #16
   1567c:	ac02      	add	r4, sp, #8
   1567e:	6818      	ldr	r0, [r3, #0]
   15680:	6859      	ldr	r1, [r3, #4]
   15682:	4622      	mov	r2, r4
   15684:	c203      	stmia	r2!, {r0, r1}
   15686:	3308      	adds	r3, #8
   15688:	42ab      	cmp	r3, r5
   1568a:	4614      	mov	r4, r2
   1568c:	d1f7      	bne.n	1567e <ble_hs_pvcy_set_our_irk+0x1a>
   1568e:	e00b      	b.n	156a8 <ble_hs_pvcy_set_our_irk+0x44>
    } else {
        memcpy(new_irk, default_irk, 16);
   15690:	4b1c      	ldr	r3, [pc, #112]	; (15704 <ble_hs_pvcy_set_our_irk+0xa0>)
   15692:	ac02      	add	r4, sp, #8
   15694:	f103 0510 	add.w	r5, r3, #16
   15698:	6818      	ldr	r0, [r3, #0]
   1569a:	6859      	ldr	r1, [r3, #4]
   1569c:	4622      	mov	r2, r4
   1569e:	c203      	stmia	r2!, {r0, r1}
   156a0:	3308      	adds	r3, #8
   156a2:	42ab      	cmp	r3, r5
   156a4:	4614      	mov	r4, r2
   156a6:	d1f7      	bne.n	15698 <ble_hs_pvcy_set_our_irk+0x34>
    }

    /* Clear the resolving list if this is a new IRK. */
    if (memcmp(ble_hs_pvcy_irk, new_irk, 16) != 0) {
   156a8:	4817      	ldr	r0, [pc, #92]	; (15708 <ble_hs_pvcy_set_our_irk+0xa4>)
   156aa:	a902      	add	r1, sp, #8
   156ac:	2210      	movs	r2, #16
   156ae:	f7f3 fc97 	bl	8fe0 <memcmp>
   156b2:	b320      	cbz	r0, 156fe <ble_hs_pvcy_set_our_irk+0x9a>
        memcpy(ble_hs_pvcy_irk, new_irk, 16);
   156b4:	4c14      	ldr	r4, [pc, #80]	; (15708 <ble_hs_pvcy_set_our_irk+0xa4>)
   156b6:	ab02      	add	r3, sp, #8
   156b8:	ad06      	add	r5, sp, #24
   156ba:	461a      	mov	r2, r3
   156bc:	ca03      	ldmia	r2!, {r0, r1}
   156be:	42aa      	cmp	r2, r5
   156c0:	6020      	str	r0, [r4, #0]
   156c2:	6061      	str	r1, [r4, #4]
   156c4:	4613      	mov	r3, r2
   156c6:	f104 0408 	add.w	r4, r4, #8
   156ca:	d1f6      	bne.n	156ba <ble_hs_pvcy_set_our_irk+0x56>

        ble_hs_pvcy_set_resolve_enabled(0);
   156cc:	2000      	movs	r0, #0
   156ce:	f7ff ff73 	bl	155b8 <ble_hs_pvcy_set_resolve_enabled>
ble_hs_pvcy_clear_entries(void)
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN ];
    int rc;

    rc = host_hci_cmd_build_clear_resolv_list(buf, sizeof(buf));
   156d2:	2103      	movs	r1, #3
   156d4:	4668      	mov	r0, sp
   156d6:	f004 f932 	bl	1993e <host_hci_cmd_build_clear_resolv_list>
    if (rc != 0) {
   156da:	4601      	mov	r1, r0
   156dc:	b920      	cbnz	r0, 156e8 <ble_hs_pvcy_set_our_irk+0x84>
        return rc;
    }

    rc = ble_hci_cmd_tx(buf, NULL, 0, NULL);
   156de:	4668      	mov	r0, sp
   156e0:	460a      	mov	r2, r1
   156e2:	460b      	mov	r3, r1
   156e4:	f7fe ff0c 	bl	14500 <ble_hci_cmd_tx>
    if (memcmp(ble_hs_pvcy_irk, new_irk, 16) != 0) {
        memcpy(ble_hs_pvcy_irk, new_irk, 16);

        ble_hs_pvcy_set_resolve_enabled(0);
        ble_hs_pvcy_clear_entries();
        ble_hs_pvcy_set_resolve_enabled(1);
   156e8:	2001      	movs	r0, #1
   156ea:	f7ff ff65 	bl	155b8 <ble_hs_pvcy_set_resolve_enabled>

        /* Push a null address identity to the controller.  The controller uses
         * this entry to generate an RPA when we do advertising with
         * own-addr-type = rpa.
         */
        memset(tmp_addr, 0, 6);
   156ee:	2100      	movs	r1, #0
        ble_hs_pvcy_add_entry(tmp_addr, 0, ble_hs_pvcy_irk);
   156f0:	4668      	mov	r0, sp
   156f2:	4a05      	ldr	r2, [pc, #20]	; (15708 <ble_hs_pvcy_set_our_irk+0xa4>)

        /* Push a null address identity to the controller.  The controller uses
         * this entry to generate an RPA when we do advertising with
         * own-addr-type = rpa.
         */
        memset(tmp_addr, 0, 6);
   156f4:	9100      	str	r1, [sp, #0]
   156f6:	f8ad 1004 	strh.w	r1, [sp, #4]
        ble_hs_pvcy_add_entry(tmp_addr, 0, ble_hs_pvcy_irk);
   156fa:	f7ff ff6d 	bl	155d8 <ble_hs_pvcy_add_entry>
    }
}
   156fe:	b007      	add	sp, #28
   15700:	bd30      	pop	{r4, r5, pc}
   15702:	bf00      	nop
   15704:	0001fa8f 	.word	0x0001fa8f
   15708:	20003bae 	.word	0x20003bae

0001570c <ble_hs_pvcy_our_irk>:
int
ble_hs_pvcy_our_irk(const uint8_t **out_irk)
{
    /* XXX: Return error if privacy not supported. */

    *out_irk = ble_hs_pvcy_irk;
   1570c:	4b01      	ldr	r3, [pc, #4]	; (15714 <ble_hs_pvcy_our_irk+0x8>)
   1570e:	6003      	str	r3, [r0, #0]
    return 0;
}
   15710:	2000      	movs	r0, #0
   15712:	4770      	bx	lr
   15714:	20003bae 	.word	0x20003bae

00015718 <ble_hs_startup_go>:
    return 0;
}

int
ble_hs_startup_go(void)
{
   15718:	b510      	push	{r4, lr}
   1571a:	b086      	sub	sp, #24
ble_hs_startup_reset_tx(void)
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN];
    int rc;

    host_hci_cmd_build_reset(buf, sizeof buf);
   1571c:	a803      	add	r0, sp, #12
   1571e:	2103      	movs	r1, #3
   15720:	f004 f822 	bl	19768 <host_hci_cmd_build_reset>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   15724:	a803      	add	r0, sp, #12
   15726:	f7fe ff7f 	bl	14628 <ble_hci_cmd_tx_empty_ack>
ble_hs_startup_go(void)
{
    int rc;

    rc = ble_hs_startup_reset_tx();
    if (rc != 0) {
   1572a:	2800      	cmp	r0, #0
   1572c:	d161      	bne.n	157f2 <ble_hs_startup_go+0xda>
     *     0x0000080000000000 Synchronous Connection Complete Event
     *     0x0000100000000000 Synchronous Connection Changed Event
     *     0x0000800000000000 Encryption Key Refresh Complete Event
     *     0x2000000000000000 LE Meta-Event
     */
    host_hci_cmd_build_set_event_mask(0x20009fffffffffff, buf, sizeof buf);
   1572e:	a136      	add	r1, pc, #216	; (adr r1, 15808 <ble_hs_startup_go+0xf0>)
   15730:	e9d1 0100 	ldrd	r0, r1, [r1]
   15734:	aa03      	add	r2, sp, #12
   15736:	230b      	movs	r3, #11
   15738:	f003 ffa3 	bl	19682 <host_hci_cmd_build_set_event_mask>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   1573c:	a803      	add	r0, sp, #12
   1573e:	f7fe ff73 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    if (rc != 0) {
   15742:	b948      	cbnz	r0, 15758 <ble_hs_startup_go+0x40>

    /**
     * Enable the following events:
     *     0x0000000000800000 Authenticated Payload Timeout Event
     */
    host_hci_cmd_build_set_event_mask2(0x0000000000800000, buf, sizeof buf);
   15744:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
   15748:	2100      	movs	r1, #0
   1574a:	aa03      	add	r2, sp, #12
   1574c:	230b      	movs	r3, #11
   1574e:	f003 ffaa 	bl	196a6 <host_hci_cmd_build_set_event_mask2>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   15752:	a803      	add	r0, sp, #12
   15754:	f7fe ff68 	bl	14628 <ble_hci_cmd_tx_empty_ack>
     *     0x0000800000000000 Encryption Key Refresh Complete Event
     *     0x2000000000000000 LE Meta-Event
     */
    host_hci_cmd_build_set_event_mask(0x20009fffffffffff, buf, sizeof buf);
    rc = ble_hci_cmd_tx_empty_ack(buf);
    if (rc != 0) {
   15758:	4604      	mov	r4, r0

    /* XXX: Read local supported commands. */
    /* XXX: Read local supported features. */

    rc = ble_hs_startup_set_evmask_tx();
    if (rc != 0) {
   1575a:	b110      	cbz	r0, 15762 <ble_hs_startup_go+0x4a>
        assert(0);
   1575c:	4828      	ldr	r0, [pc, #160]	; (15800 <ble_hs_startup_go+0xe8>)
   1575e:	21cb      	movs	r1, #203	; 0xcb
   15760:	e03e      	b.n	157e0 <ble_hs_startup_go+0xc8>
     *     0x0000000000000010 LE Long Term Key Request Event
     *     0x0000000000000020 LE Remote Connection Parameter Request Event
     *     0x0000000000000040 LE Data Length Change Event
     *     0x0000000000000200 LE Enhanced Connection Complete Event
     */
    host_hci_cmd_build_le_set_event_mask(0x000000000000027f, buf, sizeof buf);
   15762:	f240 207f 	movw	r0, #639	; 0x27f
   15766:	2100      	movs	r1, #0
   15768:	aa03      	add	r2, sp, #12
   1576a:	230b      	movs	r3, #11
   1576c:	f003 ffbe 	bl	196ec <host_hci_cmd_build_le_set_event_mask>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   15770:	a803      	add	r0, sp, #12
   15772:	f7fe ff59 	bl	14628 <ble_hci_cmd_tx_empty_ack>
        assert(0);
        return rc;
    }

    rc = ble_hs_startup_le_set_evmask_tx();
    if (rc != 0) {
   15776:	b128      	cbz	r0, 15784 <ble_hs_startup_go+0x6c>
        assert(0);
   15778:	4821      	ldr	r0, [pc, #132]	; (15800 <ble_hs_startup_go+0xe8>)
   1577a:	21d1      	movs	r1, #209	; 0xd1
   1577c:	4622      	mov	r2, r4
   1577e:	4613      	mov	r3, r2
   15780:	f7f4 faa6 	bl	9cd0 <__assert_func>
    uint8_t buf[BLE_HCI_CMD_HDR_LEN];
    uint8_t ack_params_len;
    uint8_t max_pkts;
    int rc;

    host_hci_cmd_build_le_read_buffer_size(buf, sizeof buf);
   15784:	a803      	add	r0, sp, #12
   15786:	2103      	movs	r1, #3
   15788:	f003 ffc2 	bl	19710 <host_hci_cmd_build_le_read_buffer_size>
    rc = ble_hci_cmd_tx(buf, ack_params, sizeof ack_params, &ack_params_len);
   1578c:	a803      	add	r0, sp, #12
   1578e:	a902      	add	r1, sp, #8
   15790:	2203      	movs	r2, #3
   15792:	f10d 0307 	add.w	r3, sp, #7
   15796:	f7fe feb3 	bl	14500 <ble_hci_cmd_tx>
    if (rc != 0) {
   1579a:	b950      	cbnz	r0, 157b2 <ble_hs_startup_go+0x9a>
        return rc;
    }

    if (ack_params_len != BLE_HCI_RD_BUF_SIZE_RSPLEN) {
   1579c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   157a0:	2b03      	cmp	r3, #3
   157a2:	d108      	bne.n	157b6 <ble_hs_startup_go+0x9e>
        return BLE_HS_ECONTROLLER;
    }

    pktlen = le16toh(ack_params + 0);
   157a4:	a802      	add	r0, sp, #8
   157a6:	f007 fc72 	bl	1d08e <le16toh>
    max_pkts = ack_params[2];

    rc = host_hci_set_buf_size(pktlen, max_pkts);
   157aa:	f89d 100a 	ldrb.w	r1, [sp, #10]
   157ae:	f003 fd13 	bl	191d8 <host_hci_set_buf_size>
    uint8_t max_pkts;
    int rc;

    host_hci_cmd_build_le_read_buffer_size(buf, sizeof buf);
    rc = ble_hci_cmd_tx(buf, ack_params, sizeof ack_params, &ack_params_len);
    if (rc != 0) {
   157b2:	4604      	mov	r4, r0
        assert(0);
        return rc;
    }

    rc = ble_hs_startup_le_read_buf_sz_tx();
    if (rc != 0) {
   157b4:	b110      	cbz	r0, 157bc <ble_hs_startup_go+0xa4>
        assert(0);
   157b6:	4812      	ldr	r0, [pc, #72]	; (15800 <ble_hs_startup_go+0xe8>)
   157b8:	21d7      	movs	r1, #215	; 0xd7
   157ba:	e011      	b.n	157e0 <ble_hs_startup_go+0xc8>
    uint8_t ack_params[BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN];
    uint8_t buf[BLE_HCI_CMD_HDR_LEN];
    uint8_t ack_params_len;
    int rc;

    host_hci_cmd_build_le_read_loc_supp_feat(buf, sizeof buf);
   157bc:	a802      	add	r0, sp, #8
   157be:	2103      	movs	r1, #3
   157c0:	f003 ffaf 	bl	19722 <host_hci_cmd_build_le_read_loc_supp_feat>
    rc = ble_hci_cmd_tx(buf, ack_params, sizeof ack_params, &ack_params_len);
   157c4:	a802      	add	r0, sp, #8
   157c6:	a903      	add	r1, sp, #12
   157c8:	2208      	movs	r2, #8
   157ca:	f10d 0307 	add.w	r3, sp, #7
   157ce:	f7fe fe97 	bl	14500 <ble_hci_cmd_tx>
    if (rc != 0) {
   157d2:	b918      	cbnz	r0, 157dc <ble_hs_startup_go+0xc4>
        return rc;
    }

    if (ack_params_len != BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN) {
   157d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   157d8:	2b08      	cmp	r3, #8
   157da:	d003      	beq.n	157e4 <ble_hs_startup_go+0xcc>

    /* XXX: Read buffer size. */

    rc = ble_hs_startup_le_read_sup_f_tx();
    if (rc != 0) {
        assert(0);
   157dc:	4808      	ldr	r0, [pc, #32]	; (15800 <ble_hs_startup_go+0xe8>)
   157de:	21df      	movs	r1, #223	; 0xdf
   157e0:	2200      	movs	r2, #0
   157e2:	e7cc      	b.n	1577e <ble_hs_startup_go+0x66>
        return rc;
    }

    /* XXX: Read BD_ADDR. */

    ble_hs_id_set_pub(g_dev_addr);
   157e4:	4807      	ldr	r0, [pc, #28]	; (15804 <ble_hs_startup_go+0xec>)
   157e6:	f7ff fe09 	bl	153fc <ble_hs_id_set_pub>
    ble_hs_pvcy_set_our_irk(NULL);
   157ea:	4620      	mov	r0, r4
   157ec:	f7ff ff3a 	bl	15664 <ble_hs_pvcy_set_our_irk>

    return rc;
   157f0:	e000      	b.n	157f4 <ble_hs_startup_go+0xdc>
   157f2:	4604      	mov	r4, r0
}
   157f4:	4620      	mov	r0, r4
   157f6:	b006      	add	sp, #24
   157f8:	bd10      	pop	{r4, pc}
   157fa:	bf00      	nop
   157fc:	f3af 8000 	nop.w
   15800:	0001fa9f 	.word	0x0001fa9f
   15804:	200000d8 	.word	0x200000d8
   15808:	ffffffff 	.word	0xffffffff
   1580c:	20009fff 	.word	0x20009fff

00015810 <ble_l2cap_chan_alloc>:
    STATS_NAME(ble_l2cap_stats, sm_rx)
STATS_NAME_END(ble_l2cap_stats)

struct ble_l2cap_chan *
ble_l2cap_chan_alloc(void)
{
   15810:	b510      	push	{r4, lr}
    struct ble_l2cap_chan *chan;

    chan = os_memblock_get(&ble_l2cap_chan_pool);
   15812:	4807      	ldr	r0, [pc, #28]	; (15830 <ble_l2cap_chan_alloc+0x20>)
   15814:	f7f4 fdf0 	bl	a3f8 <os_memblock_get>
    if (chan == NULL) {
   15818:	4604      	mov	r4, r0
   1581a:	b138      	cbz	r0, 1582c <ble_l2cap_chan_alloc+0x1c>
        return NULL;
    }

    memset(chan, 0, sizeof *chan);
   1581c:	221c      	movs	r2, #28
   1581e:	2100      	movs	r1, #0
   15820:	f7f3 fbf7 	bl	9012 <memset>

    STATS_INC(ble_l2cap_stats, chan_create);
   15824:	4a03      	ldr	r2, [pc, #12]	; (15834 <ble_l2cap_chan_alloc+0x24>)
   15826:	68d3      	ldr	r3, [r2, #12]
   15828:	3301      	adds	r3, #1
   1582a:	60d3      	str	r3, [r2, #12]

    return chan;
}
   1582c:	4620      	mov	r0, r4
   1582e:	bd10      	pop	{r4, pc}
   15830:	20003bc0 	.word	0x20003bc0
   15834:	20003bdc 	.word	0x20003bdc

00015838 <ble_l2cap_chan_free>:

void
ble_l2cap_chan_free(struct ble_l2cap_chan *chan)
{
   15838:	b508      	push	{r3, lr}
    int rc;

    if (chan == NULL) {
   1583a:	4601      	mov	r1, r0
   1583c:	b130      	cbz	r0, 1584c <ble_l2cap_chan_free+0x14>
        return;
    }

    rc = os_memblock_put(&ble_l2cap_chan_pool, chan);
   1583e:	4804      	ldr	r0, [pc, #16]	; (15850 <ble_l2cap_chan_free+0x18>)
   15840:	f7f4 fdee 	bl	a420 <os_memblock_put>
    BLE_HS_DBG_ASSERT_EVAL(rc == 0);

    STATS_INC(ble_l2cap_stats, chan_delete);
   15844:	4a03      	ldr	r2, [pc, #12]	; (15854 <ble_l2cap_chan_free+0x1c>)
   15846:	6913      	ldr	r3, [r2, #16]
   15848:	3301      	adds	r3, #1
   1584a:	6113      	str	r3, [r2, #16]
   1584c:	bd08      	pop	{r3, pc}
   1584e:	bf00      	nop
   15850:	20003bc0 	.word	0x20003bc0
   15854:	20003bdc 	.word	0x20003bdc

00015858 <ble_l2cap_chan_mtu>:
    uint16_t mtu;

    /* If either side has not exchanged MTU size, use the default.  Otherwise,
     * use the lesser of the two exchanged values.
     */
    if (!(chan->blc_flags & BLE_L2CAP_CHAN_F_TXED_MTU) ||
   15858:	7b03      	ldrb	r3, [r0, #12]
   1585a:	07db      	lsls	r3, r3, #31
   1585c:	d501      	bpl.n	15862 <ble_l2cap_chan_mtu+0xa>
        chan->blc_peer_mtu == 0) {
   1585e:	8903      	ldrh	r3, [r0, #8]
    uint16_t mtu;

    /* If either side has not exchanged MTU size, use the default.  Otherwise,
     * use the lesser of the two exchanged values.
     */
    if (!(chan->blc_flags & BLE_L2CAP_CHAN_F_TXED_MTU) ||
   15860:	b90b      	cbnz	r3, 15866 <ble_l2cap_chan_mtu+0xe>
        chan->blc_peer_mtu == 0) {

        mtu = chan->blc_default_mtu;
   15862:	8940      	ldrh	r0, [r0, #10]
   15864:	4770      	bx	lr
    } else {
        mtu = min(chan->blc_my_mtu, chan->blc_peer_mtu);
   15866:	88c0      	ldrh	r0, [r0, #6]
   15868:	4298      	cmp	r0, r3
   1586a:	bf28      	it	cs
   1586c:	4618      	movcs	r0, r3
    }

    BLE_HS_DBG_ASSERT(mtu >= chan->blc_default_mtu);

    return mtu;
}
   1586e:	4770      	bx	lr

00015870 <ble_l2cap_parse_hdr>:

int
ble_l2cap_parse_hdr(struct os_mbuf *om, int off,
                    struct ble_l2cap_hdr *l2cap_hdr)
{
   15870:	b538      	push	{r3, r4, r5, lr}
   15872:	4615      	mov	r5, r2
    int rc;

    rc = os_mbuf_copydata(om, off, sizeof *l2cap_hdr, l2cap_hdr);
   15874:	462b      	mov	r3, r5
   15876:	2204      	movs	r2, #4
   15878:	f7f4 fbfa 	bl	a070 <os_mbuf_copydata>
    if (rc != 0) {
   1587c:	4604      	mov	r4, r0
   1587e:	b958      	cbnz	r0, 15898 <ble_l2cap_parse_hdr+0x28>
        return BLE_HS_EMSGSIZE;
    }

    l2cap_hdr->blh_len = le16toh(&l2cap_hdr->blh_len);
   15880:	4628      	mov	r0, r5
   15882:	f007 fc04 	bl	1d08e <le16toh>
   15886:	462b      	mov	r3, r5
   15888:	f823 0b02 	strh.w	r0, [r3], #2
    l2cap_hdr->blh_cid = le16toh(&l2cap_hdr->blh_cid);
   1588c:	4618      	mov	r0, r3
   1588e:	f007 fbfe 	bl	1d08e <le16toh>
   15892:	8068      	strh	r0, [r5, #2]
   15894:	4620      	mov	r0, r4
   15896:	bd38      	pop	{r3, r4, r5, pc}
{
    int rc;

    rc = os_mbuf_copydata(om, off, sizeof *l2cap_hdr, l2cap_hdr);
    if (rc != 0) {
        return BLE_HS_EMSGSIZE;
   15898:	2004      	movs	r0, #4

    l2cap_hdr->blh_len = le16toh(&l2cap_hdr->blh_len);
    l2cap_hdr->blh_cid = le16toh(&l2cap_hdr->blh_cid);

    return 0;
}
   1589a:	bd38      	pop	{r3, r4, r5, pc}

0001589c <ble_l2cap_prepend_hdr>:

struct os_mbuf *
ble_l2cap_prepend_hdr(struct os_mbuf *om, uint16_t cid, uint16_t len)
{
   1589c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1589e:	4604      	mov	r4, r0
   158a0:	460d      	mov	r5, r1
    struct ble_l2cap_hdr hdr;

    htole16(&hdr.blh_len, len);
   158a2:	a801      	add	r0, sp, #4
   158a4:	4611      	mov	r1, r2
   158a6:	f007 fbd7 	bl	1d058 <htole16>
    htole16(&hdr.blh_cid, cid);
   158aa:	f10d 0006 	add.w	r0, sp, #6
   158ae:	4629      	mov	r1, r5
   158b0:	f007 fbd2 	bl	1d058 <htole16>

    om = os_mbuf_prepend(om, sizeof hdr);
   158b4:	4620      	mov	r0, r4
   158b6:	2104      	movs	r1, #4
   158b8:	f7f4 fc79 	bl	a1ae <os_mbuf_prepend>
    if (om == NULL) {
   158bc:	4603      	mov	r3, r0
   158be:	b110      	cbz	r0, 158c6 <ble_l2cap_prepend_hdr+0x2a>
        return NULL;
    }

    memcpy(om->om_data, &hdr, sizeof hdr);
   158c0:	6802      	ldr	r2, [r0, #0]
   158c2:	9801      	ldr	r0, [sp, #4]
   158c4:	6010      	str	r0, [r2, #0]

    return om;
}
   158c6:	4618      	mov	r0, r3
   158c8:	b003      	add	sp, #12
   158ca:	bd30      	pop	{r4, r5, pc}

000158cc <ble_l2cap_rx>:
ble_l2cap_rx(struct ble_hs_conn *conn,
             struct hci_data_hdr *hci_hdr,
             struct os_mbuf *om,
             ble_l2cap_rx_fn **out_rx_cb,
             struct os_mbuf **out_rx_buf)
{
   158cc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   158d0:	4698      	mov	r8, r3
    struct ble_l2cap_chan *chan;
    struct ble_l2cap_hdr l2cap_hdr;
    uint8_t pb;
    int rc;

    pb = BLE_HCI_DATA_PB(hci_hdr->hdh_handle_pb_bc);
   158d2:	880b      	ldrh	r3, [r1, #0]
   158d4:	f3c3 3301 	ubfx	r3, r3, #12, #2
    switch (pb) {
   158d8:	2b01      	cmp	r3, #1
ble_l2cap_rx(struct ble_hs_conn *conn,
             struct hci_data_hdr *hci_hdr,
             struct os_mbuf *om,
             ble_l2cap_rx_fn **out_rx_cb,
             struct os_mbuf **out_rx_buf)
{
   158da:	4606      	mov	r6, r0
   158dc:	4617      	mov	r7, r2
    struct ble_l2cap_hdr l2cap_hdr;
    uint8_t pb;
    int rc;

    pb = BLE_HCI_DATA_PB(hci_hdr->hdh_handle_pb_bc);
    switch (pb) {
   158de:	d03c      	beq.n	1595a <ble_l2cap_rx+0x8e>
   158e0:	2b02      	cmp	r3, #2
   158e2:	d15e      	bne.n	159a2 <ble_l2cap_rx+0xd6>
    case BLE_HCI_PB_FIRST_FLUSH:
        /* First fragment. */
        rc = ble_l2cap_parse_hdr(om, 0, &l2cap_hdr);
   158e4:	4610      	mov	r0, r2
   158e6:	2100      	movs	r1, #0
   158e8:	aa03      	add	r2, sp, #12
   158ea:	f7ff ffc1 	bl	15870 <ble_l2cap_parse_hdr>
        if (rc != 0) {
   158ee:	4604      	mov	r4, r0
   158f0:	2800      	cmp	r0, #0
   158f2:	d157      	bne.n	159a4 <ble_l2cap_rx+0xd8>
            goto err;
        }

        /* Strip L2CAP header from the front of the mbuf. */
        os_mbuf_adj(om, BLE_L2CAP_HDR_SZ);
   158f4:	4638      	mov	r0, r7
   158f6:	2104      	movs	r1, #4
   158f8:	f7f4 fbe1 	bl	a0be <os_mbuf_adj>

        chan = ble_hs_conn_chan_find(conn, l2cap_hdr.blh_cid);
   158fc:	4630      	mov	r0, r6
   158fe:	f8bd 100e 	ldrh.w	r1, [sp, #14]
   15902:	f7ff fc39 	bl	15178 <ble_hs_conn_chan_find>
        if (chan == NULL) {
   15906:	4605      	mov	r5, r0
   15908:	b9e0      	cbnz	r0, 15944 <ble_l2cap_rx+0x78>

            /* Unsupported channel. If the target CID is the black hole
             * channel, quietly drop the packet.  Otherwise, send an invalid
             * CID response.
             */
            if (l2cap_hdr.blh_cid != BLE_L2CAP_CID_BLACK_HOLE) {
   1590a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1590e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   15912:	4293      	cmp	r3, r2
   15914:	d014      	beq.n	15940 <ble_l2cap_rx+0x74>
                BLE_HS_LOG(DEBUG, "rx on unknown L2CAP channel: %d\n",
   15916:	9300      	str	r3, [sp, #0]
   15918:	4827      	ldr	r0, [pc, #156]	; (159b8 <ble_l2cap_rx+0xec>)
   1591a:	4b28      	ldr	r3, [pc, #160]	; (159bc <ble_l2cap_rx+0xf0>)
   1591c:	2104      	movs	r1, #4
   1591e:	4622      	mov	r2, r4
   15920:	f007 fc82 	bl	1d228 <log_printf>
                           l2cap_hdr.blh_cid);

                chan = ble_hs_conn_chan_find(conn, BLE_L2CAP_CID_SIG);
   15924:	2105      	movs	r1, #5
   15926:	4630      	mov	r0, r6
   15928:	f7ff fc26 	bl	15178 <ble_hs_conn_chan_find>
                if (chan != NULL) {
   1592c:	4601      	mov	r1, r0
   1592e:	b138      	cbz	r0, 15940 <ble_l2cap_rx+0x74>
                    ble_l2cap_sig_reject_invalid_cid_tx(conn, chan, 0, 0,
   15930:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   15934:	9300      	str	r3, [sp, #0]
   15936:	4630      	mov	r0, r6
   15938:	4622      	mov	r2, r4
   1593a:	4623      	mov	r3, r4
   1593c:	f000 fa74 	bl	15e28 <ble_l2cap_sig_reject_invalid_cid_tx>
        /* Strip L2CAP header from the front of the mbuf. */
        os_mbuf_adj(om, BLE_L2CAP_HDR_SZ);

        chan = ble_hs_conn_chan_find(conn, l2cap_hdr.blh_cid);
        if (chan == NULL) {
            rc = BLE_HS_ENOENT;
   15940:	2405      	movs	r4, #5
   15942:	e02f      	b.n	159a4 <ble_l2cap_rx+0xd8>
                }
            }
            goto err;
        }

        if (chan->blc_rx_buf != NULL) {
   15944:	6900      	ldr	r0, [r0, #16]
   15946:	b118      	cbz	r0, 15950 <ble_l2cap_rx+0x84>
}

static void
ble_l2cap_discard_rx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
    os_mbuf_free_chain(chan->blc_rx_buf);
   15948:	f7f4 fb09 	bl	9f5e <os_mbuf_free_chain>
}

static void
ble_l2cap_forget_rx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
    conn->bhc_rx_chan = NULL;
   1594c:	62b4      	str	r4, [r6, #40]	; 0x28
    chan->blc_rx_buf = NULL;
   1594e:	612c      	str	r4, [r5, #16]
            ble_l2cap_discard_rx(conn, chan);
        }

        /* Remember channel and length of L2CAP data for reassembly. */
        conn->bhc_rx_chan = chan;
        chan->blc_rx_len = l2cap_hdr.blh_len;
   15950:	f8bd 300c 	ldrh.w	r3, [sp, #12]
            /* Previous data packet never completed.  Discard old packet. */
            ble_l2cap_discard_rx(conn, chan);
        }

        /* Remember channel and length of L2CAP data for reassembly. */
        conn->bhc_rx_chan = chan;
   15954:	62b5      	str	r5, [r6, #40]	; 0x28
        chan->blc_rx_len = l2cap_hdr.blh_len;
   15956:	82ab      	strh	r3, [r5, #20]
        break;
   15958:	e003      	b.n	15962 <ble_l2cap_rx+0x96>

    case BLE_HCI_PB_MIDDLE:
        chan = conn->bhc_rx_chan;
   1595a:	6a85      	ldr	r5, [r0, #40]	; 0x28
        if (chan == NULL || chan->blc_rx_buf == NULL) {
   1595c:	b30d      	cbz	r5, 159a2 <ble_l2cap_rx+0xd6>
   1595e:	692b      	ldr	r3, [r5, #16]
   15960:	b1fb      	cbz	r3, 159a2 <ble_l2cap_rx+0xd6>
                     ble_l2cap_rx_fn **out_rx_cb, struct os_mbuf **out_rx_buf)
{
    int len_diff;
    int rc;

    if (chan->blc_rx_buf == NULL) {
   15962:	6928      	ldr	r0, [r5, #16]
   15964:	b908      	cbnz	r0, 1596a <ble_l2cap_rx+0x9e>
        chan->blc_rx_buf = om;
   15966:	612f      	str	r7, [r5, #16]
   15968:	e002      	b.n	15970 <ble_l2cap_rx+0xa4>
    } else {
        os_mbuf_concat(chan->blc_rx_buf, om);
   1596a:	4639      	mov	r1, r7
   1596c:	f7f4 fc63 	bl	a236 <os_mbuf_concat>
    }

    /* Determine if packet is fully reassembled. */
    len_diff = OS_MBUF_PKTLEN(chan->blc_rx_buf) - chan->blc_rx_len;
   15970:	6928      	ldr	r0, [r5, #16]
   15972:	8aac      	ldrh	r4, [r5, #20]
   15974:	8a03      	ldrh	r3, [r0, #16]
   15976:	1b1c      	subs	r4, r3, r4
    if (len_diff > 0) {
   15978:	2c00      	cmp	r4, #0
   1597a:	dd07      	ble.n	1598c <ble_l2cap_rx+0xc0>
}

static void
ble_l2cap_discard_rx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
    os_mbuf_free_chain(chan->blc_rx_buf);
   1597c:	f7f4 faef 	bl	9f5e <os_mbuf_free_chain>
}

static void
ble_l2cap_forget_rx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
    conn->bhc_rx_chan = NULL;
   15980:	2300      	movs	r3, #0
   15982:	62b3      	str	r3, [r6, #40]	; 0x28
    /* Determine if packet is fully reassembled. */
    len_diff = OS_MBUF_PKTLEN(chan->blc_rx_buf) - chan->blc_rx_len;
    if (len_diff > 0) {
        /* More data than expected; data corruption. */
        ble_l2cap_discard_rx(conn, chan);
        rc = BLE_HS_EBADDATA;
   15984:	240a      	movs	r4, #10

static void
ble_l2cap_forget_rx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
    conn->bhc_rx_chan = NULL;
    chan->blc_rx_buf = NULL;
   15986:	612b      	str	r3, [r5, #16]
    chan->blc_rx_len = 0;
   15988:	82ab      	strh	r3, [r5, #20]
   1598a:	e013      	b.n	159b4 <ble_l2cap_rx+0xe8>
    len_diff = OS_MBUF_PKTLEN(chan->blc_rx_buf) - chan->blc_rx_len;
    if (len_diff > 0) {
        /* More data than expected; data corruption. */
        ble_l2cap_discard_rx(conn, chan);
        rc = BLE_HS_EBADDATA;
    } else if (len_diff == 0) {
   1598c:	d111      	bne.n	159b2 <ble_l2cap_rx+0xe6>
        /* All fragments received. */
        *out_rx_cb = chan->blc_rx_fn;
   1598e:	69ab      	ldr	r3, [r5, #24]
   15990:	f8c8 3000 	str.w	r3, [r8]
        *out_rx_buf = chan->blc_rx_buf;
   15994:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15996:	692a      	ldr	r2, [r5, #16]
   15998:	601a      	str	r2, [r3, #0]
}

static void
ble_l2cap_forget_rx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
{
    conn->bhc_rx_chan = NULL;
   1599a:	62b4      	str	r4, [r6, #40]	; 0x28
    chan->blc_rx_buf = NULL;
   1599c:	612c      	str	r4, [r5, #16]
    chan->blc_rx_len = 0;
   1599e:	82ac      	strh	r4, [r5, #20]
   159a0:	e003      	b.n	159aa <ble_l2cap_rx+0xde>

    case BLE_HCI_PB_MIDDLE:
        chan = conn->bhc_rx_chan;
        if (chan == NULL || chan->blc_rx_buf == NULL) {
            /* Middle fragment without the start.  Discard new packet. */
            rc = BLE_HS_EBADDATA;
   159a2:	240a      	movs	r4, #10
    }

    return 0;

err:
    os_mbuf_free_chain(om);
   159a4:	4638      	mov	r0, r7
   159a6:	f7f4 fada 	bl	9f5e <os_mbuf_free_chain>
    return rc;
   159aa:	4620      	mov	r0, r4
}
   159ac:	b004      	add	sp, #16
   159ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        *out_rx_buf = chan->blc_rx_buf;
        ble_l2cap_forget_rx(conn, chan);
        rc = 0;
    } else {
        /* More fragments remain. */
        rc = BLE_HS_EAGAIN;
   159b2:	2401      	movs	r4, #1
        rc = BLE_HS_EBADDATA;
        goto err;
    }

    rc = ble_l2cap_rx_payload(conn, chan, om, out_rx_cb, out_rx_buf);
    om = NULL;
   159b4:	2700      	movs	r7, #0
   159b6:	e7f5      	b.n	159a4 <ble_l2cap_rx+0xd8>
   159b8:	20003b9c 	.word	0x20003b9c
   159bc:	0001fab0 	.word	0x0001fab0

000159c0 <ble_l2cap_tx>:
 * @return                      0 on success; nonzero on error.
 */
int
ble_l2cap_tx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan,
             struct os_mbuf *om)
{
   159c0:	b510      	push	{r4, lr}
    int rc;

    om = ble_l2cap_prepend_hdr(om, chan->blc_cid, OS_MBUF_PKTLEN(om));
   159c2:	8889      	ldrh	r1, [r1, #4]
 * @return                      0 on success; nonzero on error.
 */
int
ble_l2cap_tx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan,
             struct os_mbuf *om)
{
   159c4:	4604      	mov	r4, r0
    int rc;

    om = ble_l2cap_prepend_hdr(om, chan->blc_cid, OS_MBUF_PKTLEN(om));
   159c6:	4610      	mov	r0, r2
   159c8:	8a12      	ldrh	r2, [r2, #16]
   159ca:	f7ff ff67 	bl	1589c <ble_l2cap_prepend_hdr>
    if (om == NULL) {
   159ce:	4601      	mov	r1, r0
   159d0:	b128      	cbz	r0, 159de <ble_l2cap_tx+0x1e>
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    rc = host_hci_data_tx(conn, om);
   159d2:	4620      	mov	r0, r4
   159d4:	f003 fcea 	bl	193ac <host_hci_data_tx>
    om = NULL;
    if (rc != 0) {
   159d8:	4604      	mov	r4, r0
   159da:	b908      	cbnz	r0, 159e0 <ble_l2cap_tx+0x20>
   159dc:	e003      	b.n	159e6 <ble_l2cap_tx+0x26>
{
    int rc;

    om = ble_l2cap_prepend_hdr(om, chan->blc_cid, OS_MBUF_PKTLEN(om));
    if (om == NULL) {
        rc = BLE_HS_ENOMEM;
   159de:	2406      	movs	r4, #6
    }

    return 0;

err:
    os_mbuf_free_chain(om);
   159e0:	2000      	movs	r0, #0
   159e2:	f7f4 fabc 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   159e6:	4620      	mov	r0, r4
   159e8:	bd10      	pop	{r4, pc}
	...

000159ec <ble_l2cap_init>:
    ble_l2cap_chan_mem = NULL;
}

int
ble_l2cap_init(void)
{
   159ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
}

static void
ble_l2cap_free_mem(void)
{
    free(ble_l2cap_chan_mem);
   159ee:	4c1b      	ldr	r4, [pc, #108]	; (15a5c <ble_l2cap_init+0x70>)
   159f0:	6820      	ldr	r0, [r4, #0]
   159f2:	f008 f859 	bl	1daa8 <free>
    int rc;

    ble_l2cap_free_mem();

    ble_l2cap_chan_mem = malloc(
        OS_MEMPOOL_BYTES(ble_hs_cfg.max_l2cap_chans,
   159f6:	4b1a      	ldr	r3, [pc, #104]	; (15a60 <ble_l2cap_init+0x74>)
   159f8:	7ade      	ldrb	r6, [r3, #11]
{
    int rc;

    ble_l2cap_free_mem();

    ble_l2cap_chan_mem = malloc(
   159fa:	ebc6 00c6 	rsb	r0, r6, r6, lsl #3
   159fe:	0080      	lsls	r0, r0, #2
   15a00:	f008 f808 	bl	1da14 <malloc>
   15a04:	4625      	mov	r5, r4
   15a06:	4603      	mov	r3, r0
   15a08:	6020      	str	r0, [r4, #0]
        OS_MEMPOOL_BYTES(ble_hs_cfg.max_l2cap_chans,
                         sizeof (struct ble_l2cap_chan)));
    if (ble_l2cap_chan_mem == NULL) {
   15a0a:	b1e8      	cbz	r0, 15a48 <ble_l2cap_init+0x5c>
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    rc = os_mempool_init(&ble_l2cap_chan_pool, ble_hs_cfg.max_l2cap_chans,
   15a0c:	4a15      	ldr	r2, [pc, #84]	; (15a64 <ble_l2cap_init+0x78>)
   15a0e:	9200      	str	r2, [sp, #0]
   15a10:	4815      	ldr	r0, [pc, #84]	; (15a68 <ble_l2cap_init+0x7c>)
   15a12:	4631      	mov	r1, r6
   15a14:	221c      	movs	r2, #28
   15a16:	f7f4 fcbb 	bl	a390 <os_mempool_init>
                         sizeof (struct ble_l2cap_chan),
                         ble_l2cap_chan_mem, "ble_l2cap_chan_pool");
    if (rc != 0) {
   15a1a:	b108      	cbz	r0, 15a20 <ble_l2cap_init+0x34>
        rc = BLE_HS_EOS;
   15a1c:	240b      	movs	r4, #11
   15a1e:	e014      	b.n	15a4a <ble_l2cap_init+0x5e>
        goto err;
    }

    rc = ble_l2cap_sig_init();
   15a20:	f000 f982 	bl	15d28 <ble_l2cap_sig_init>
    if (rc != 0) {
   15a24:	4604      	mov	r4, r0
   15a26:	b980      	cbnz	r0, 15a4a <ble_l2cap_init+0x5e>
        goto err;
    }

    rc = ble_sm_init();
   15a28:	f001 fd7a 	bl	17520 <ble_sm_init>
    if (rc != 0) {
   15a2c:	4604      	mov	r4, r0
   15a2e:	b960      	cbnz	r0, 15a4a <ble_l2cap_init+0x5e>
        goto err;
    }

    rc = stats_init_and_reg(
   15a30:	4b0e      	ldr	r3, [pc, #56]	; (15a6c <ble_l2cap_init+0x80>)
   15a32:	9000      	str	r0, [sp, #0]
   15a34:	9301      	str	r3, [sp, #4]
   15a36:	480e      	ldr	r0, [pc, #56]	; (15a70 <ble_l2cap_init+0x84>)
   15a38:	2104      	movs	r1, #4
   15a3a:	220a      	movs	r2, #10
   15a3c:	4623      	mov	r3, r4
   15a3e:	f007 fc85 	bl	1d34c <stats_init_and_reg>
        STATS_HDR(ble_l2cap_stats), STATS_SIZE_INIT_PARMS(ble_l2cap_stats,
        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_l2cap_stats), "ble_l2cap");
    if (rc != 0) {
   15a42:	2800      	cmp	r0, #0
   15a44:	d1ea      	bne.n	15a1c <ble_l2cap_init+0x30>
   15a46:	e006      	b.n	15a56 <ble_l2cap_init+0x6a>

    ble_l2cap_chan_mem = malloc(
        OS_MEMPOOL_BYTES(ble_hs_cfg.max_l2cap_chans,
                         sizeof (struct ble_l2cap_chan)));
    if (ble_l2cap_chan_mem == NULL) {
        rc = BLE_HS_ENOMEM;
   15a48:	2406      	movs	r4, #6
}

static void
ble_l2cap_free_mem(void)
{
    free(ble_l2cap_chan_mem);
   15a4a:	6828      	ldr	r0, [r5, #0]
   15a4c:	f008 f82c 	bl	1daa8 <free>
    ble_l2cap_chan_mem = NULL;
   15a50:	2300      	movs	r3, #0
   15a52:	602b      	str	r3, [r5, #0]

    return 0;

err:
    ble_l2cap_free_mem();
    return rc;
   15a54:	4620      	mov	r0, r4
}
   15a56:	b002      	add	sp, #8
   15a58:	bd70      	pop	{r4, r5, r6, pc}
   15a5a:	bf00      	nop
   15a5c:	2000224c 	.word	0x2000224c
   15a60:	20003b78 	.word	0x20003b78
   15a64:	0001fad1 	.word	0x0001fad1
   15a68:	20003bc0 	.word	0x20003bc0
   15a6c:	0001fae5 	.word	0x0001fae5
   15a70:	20003bdc 	.word	0x20003bdc

00015a74 <ble_l2cap_sig_rx_noop>:
ble_l2cap_sig_rx_noop(uint16_t conn_handle,
                      struct ble_l2cap_sig_hdr *hdr,
                      struct os_mbuf **om)
{
    return BLE_HS_ENOTSUP;
}
   15a74:	2008      	movs	r0, #8
   15a76:	4770      	bx	lr

00015a78 <ble_l2cap_sig_rx>:
    return rc;
}

static int
ble_l2cap_sig_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   15a78:	b530      	push	{r4, r5, lr}
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    ble_l2cap_sig_rx_fn *rx_cb;
    int rc;

    STATS_INC(ble_l2cap_stats, sig_rx);
   15a7a:	4a2a      	ldr	r2, [pc, #168]	; (15b24 <ble_l2cap_sig_rx+0xac>)
   15a7c:	6a93      	ldr	r3, [r2, #40]	; 0x28
    return rc;
}

static int
ble_l2cap_sig_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   15a7e:	460c      	mov	r4, r1
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    ble_l2cap_sig_rx_fn *rx_cb;
    int rc;

    STATS_INC(ble_l2cap_stats, sig_rx);
   15a80:	3301      	adds	r3, #1
    return rc;
}

static int
ble_l2cap_sig_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   15a82:	b087      	sub	sp, #28
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    ble_l2cap_sig_rx_fn *rx_cb;
    int rc;

    STATS_INC(ble_l2cap_stats, sig_rx);
   15a84:	6293      	str	r3, [r2, #40]	; 0x28
    BLE_HS_LOG(DEBUG, "L2CAP - rxed signalling msg: ");
   15a86:	2104      	movs	r1, #4
   15a88:	2200      	movs	r2, #0
   15a8a:	4b27      	ldr	r3, [pc, #156]	; (15b28 <ble_l2cap_sig_rx+0xb0>)
    return rc;
}

static int
ble_l2cap_sig_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   15a8c:	4605      	mov	r5, r0
    struct ble_hs_conn *conn;
    ble_l2cap_sig_rx_fn *rx_cb;
    int rc;

    STATS_INC(ble_l2cap_stats, sig_rx);
    BLE_HS_LOG(DEBUG, "L2CAP - rxed signalling msg: ");
   15a8e:	4827      	ldr	r0, [pc, #156]	; (15b2c <ble_l2cap_sig_rx+0xb4>)
   15a90:	f007 fbca 	bl	1d228 <log_printf>
    ble_hs_log_mbuf(*om);
   15a94:	6820      	ldr	r0, [r4, #0]
   15a96:	f7ff fd05 	bl	154a4 <ble_hs_log_mbuf>
    BLE_HS_LOG(DEBUG, "\n");
   15a9a:	4824      	ldr	r0, [pc, #144]	; (15b2c <ble_l2cap_sig_rx+0xb4>)
   15a9c:	4b24      	ldr	r3, [pc, #144]	; (15b30 <ble_l2cap_sig_rx+0xb8>)
   15a9e:	2104      	movs	r1, #4
   15aa0:	2200      	movs	r2, #0
   15aa2:	f007 fbc1 	bl	1d228 <log_printf>

    rc = ble_hs_misc_pullup_base(om, BLE_L2CAP_SIG_HDR_SZ);
   15aa6:	4620      	mov	r0, r4
   15aa8:	2104      	movs	r1, #4
   15aaa:	f7ff fd45 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   15aae:	2800      	cmp	r0, #0
   15ab0:	d136      	bne.n	15b20 <ble_l2cap_sig_rx+0xa8>
        return rc;
    }

    ble_l2cap_sig_hdr_parse((*om)->om_data, (*om)->om_len, &hdr);
   15ab2:	6823      	ldr	r3, [r4, #0]
   15ab4:	aa03      	add	r2, sp, #12
   15ab6:	6818      	ldr	r0, [r3, #0]
   15ab8:	88d9      	ldrh	r1, [r3, #6]
   15aba:	f000 f98a 	bl	15dd2 <ble_l2cap_sig_hdr_parse>

    /* Strip L2CAP sig header from the front of the mbuf. */
    os_mbuf_adj(*om, BLE_L2CAP_SIG_HDR_SZ);
   15abe:	6820      	ldr	r0, [r4, #0]
   15ac0:	2104      	movs	r1, #4
   15ac2:	f7f4 fafc 	bl	a0be <os_mbuf_adj>

    if (OS_MBUF_PKTLEN(*om) != hdr.length) {
   15ac6:	6823      	ldr	r3, [r4, #0]
   15ac8:	8a1a      	ldrh	r2, [r3, #16]
   15aca:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   15ace:	429a      	cmp	r2, r3
   15ad0:	d125      	bne.n	15b1e <ble_l2cap_sig_rx+0xa6>
        return BLE_HS_EBADDATA;
    }

    rx_cb = ble_l2cap_sig_dispatch_get(hdr.op);
   15ad2:	f89d 300c 	ldrb.w	r3, [sp, #12]
}

static ble_l2cap_sig_rx_fn *
ble_l2cap_sig_dispatch_get(uint8_t op)
{
    if (op > BLE_L2CAP_SIG_OP_MAX) {
   15ad6:	2b17      	cmp	r3, #23
   15ad8:	d803      	bhi.n	15ae2 <ble_l2cap_sig_rx+0x6a>
        return NULL;
    }

    return ble_l2cap_sig_dispatch[op];
   15ada:	4a16      	ldr	r2, [pc, #88]	; (15b34 <ble_l2cap_sig_rx+0xbc>)
   15adc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    if (OS_MBUF_PKTLEN(*om) != hdr.length) {
        return BLE_HS_EBADDATA;
    }

    rx_cb = ble_l2cap_sig_dispatch_get(hdr.op);
    if (rx_cb == NULL) {
   15ae0:	b9c3      	cbnz	r3, 15b14 <ble_l2cap_sig_rx+0x9c>
        ble_hs_lock();
   15ae2:	f7fe fe2f 	bl	14744 <ble_hs_lock>
        rc = ble_hs_misc_conn_chan_find_reqd(conn_handle, BLE_L2CAP_CID_SIG,
   15ae6:	4628      	mov	r0, r5
   15ae8:	2105      	movs	r1, #5
   15aea:	aa05      	add	r2, sp, #20
   15aec:	ab04      	add	r3, sp, #16
   15aee:	f7ff fd4c 	bl	1558a <ble_hs_misc_conn_chan_find_reqd>
                                             &conn, &chan);
        if (rc == 0) {
   15af2:	4604      	mov	r4, r0
   15af4:	b948      	cbnz	r0, 15b0a <ble_l2cap_sig_rx+0x92>
            ble_l2cap_sig_reject_tx(conn, chan, hdr.identifier,
   15af6:	9000      	str	r0, [sp, #0]
   15af8:	9001      	str	r0, [sp, #4]
   15afa:	f89d 200d 	ldrb.w	r2, [sp, #13]
   15afe:	9805      	ldr	r0, [sp, #20]
   15b00:	9904      	ldr	r1, [sp, #16]
   15b02:	4623      	mov	r3, r4
   15b04:	f000 f96c 	bl	15de0 <ble_l2cap_sig_reject_tx>
   15b08:	e000      	b.n	15b0c <ble_l2cap_sig_rx+0x94>
                                    BLE_L2CAP_SIG_ERR_CMD_NOT_UNDERSTOOD,
                                    NULL, 0);
            rc = BLE_HS_L2C_ERR(BLE_L2CAP_SIG_ERR_CMD_NOT_UNDERSTOOD);
        } else {
            rc = BLE_HS_ENOTCONN;
   15b0a:	2407      	movs	r4, #7
        }
        ble_hs_unlock();
   15b0c:	f7fe fe22 	bl	14754 <ble_hs_unlock>
   15b10:	4620      	mov	r0, r4
   15b12:	e005      	b.n	15b20 <ble_l2cap_sig_rx+0xa8>
    } else {
        rc = rx_cb(conn_handle, &hdr, om);
   15b14:	4628      	mov	r0, r5
   15b16:	a903      	add	r1, sp, #12
   15b18:	4622      	mov	r2, r4
   15b1a:	4798      	blx	r3
   15b1c:	e000      	b.n	15b20 <ble_l2cap_sig_rx+0xa8>

    /* Strip L2CAP sig header from the front of the mbuf. */
    os_mbuf_adj(*om, BLE_L2CAP_SIG_HDR_SZ);

    if (OS_MBUF_PKTLEN(*om) != hdr.length) {
        return BLE_HS_EBADDATA;
   15b1e:	200a      	movs	r0, #10
    } else {
        rc = rx_cb(conn_handle, &hdr, om);
    }

    return rc;
}
   15b20:	b007      	add	sp, #28
   15b22:	bd30      	pop	{r4, r5, pc}
   15b24:	20003bdc 	.word	0x20003bdc
   15b28:	0001fb48 	.word	0x0001fb48
   15b2c:	20003b9c 	.word	0x20003b9c
   15b30:	0001fdec 	.word	0x0001fdec
   15b34:	0001faf0 	.word	0x0001faf0

00015b38 <ble_l2cap_sig_update_req_rx>:

int
ble_l2cap_sig_update_req_rx(uint16_t conn_handle,
                            struct ble_l2cap_sig_hdr *hdr,
                            struct os_mbuf **om)
{
   15b38:	b5f0      	push	{r4, r5, r6, r7, lr}
   15b3a:	4604      	mov	r4, r0
   15b3c:	b08b      	sub	sp, #44	; 0x2c
   15b3e:	460d      	mov	r5, r1
    int sig_err;
    int rc;

    l2cap_result = 0; /* Silence spurious gcc warning. */

    rc = ble_hs_misc_pullup_base(om, BLE_L2CAP_SIG_UPDATE_REQ_SZ);
   15b40:	4610      	mov	r0, r2
   15b42:	2108      	movs	r1, #8

int
ble_l2cap_sig_update_req_rx(uint16_t conn_handle,
                            struct ble_l2cap_sig_hdr *hdr,
                            struct os_mbuf **om)
{
   15b44:	4616      	mov	r6, r2
    int sig_err;
    int rc;

    l2cap_result = 0; /* Silence spurious gcc warning. */

    rc = ble_hs_misc_pullup_base(om, BLE_L2CAP_SIG_UPDATE_REQ_SZ);
   15b46:	f7ff fcf7 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   15b4a:	2800      	cmp	r0, #0
   15b4c:	d156      	bne.n	15bfc <ble_l2cap_sig_update_req_rx+0xc4>
        return rc;
    }

    rc = ble_hs_atomic_conn_flags(conn_handle, &conn_flags);
   15b4e:	4620      	mov	r0, r4
   15b50:	f10d 010b 	add.w	r1, sp, #11
   15b54:	f7ff faa2 	bl	1509c <ble_hs_atomic_conn_flags>
    if (rc != 0) {
   15b58:	2800      	cmp	r0, #0
   15b5a:	d14f      	bne.n	15bfc <ble_l2cap_sig_update_req_rx+0xc4>
        return rc;
    }

    /* Only a master can process an update request. */
    sig_err = !(conn_flags & BLE_HS_CONN_F_MASTER);
   15b5c:	f89d 300b 	ldrb.w	r3, [sp, #11]
   15b60:	f003 0301 	and.w	r3, r3, #1
    if (!sig_err) {
   15b64:	f083 0701 	eor.w	r7, r3, #1
   15b68:	b90b      	cbnz	r3, 15b6e <ble_l2cap_sig_update_req_rx+0x36>
    struct ble_hs_conn *conn;
    uint16_t l2cap_result;
    int sig_err;
    int rc;

    l2cap_result = 0; /* Silence spurious gcc warning. */
   15b6a:	2600      	movs	r6, #0
   15b6c:	e029      	b.n	15bc2 <ble_l2cap_sig_update_req_rx+0x8a>
    }

    /* Only a master can process an update request. */
    sig_err = !(conn_flags & BLE_HS_CONN_F_MASTER);
    if (!sig_err) {
        ble_l2cap_sig_update_req_parse((*om)->om_data, (*om)->om_len, &req);
   15b6e:	6833      	ldr	r3, [r6, #0]
   15b70:	aa05      	add	r2, sp, #20
   15b72:	6818      	ldr	r0, [r3, #0]
   15b74:	88d9      	ldrh	r1, [r3, #6]
   15b76:	f000 f967 	bl	15e48 <ble_l2cap_sig_update_req_parse>

        params.itvl_min = req.itvl_min;
   15b7a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   15b7e:	f8ad 301c 	strh.w	r3, [sp, #28]
        params.itvl_max = req.itvl_max;
   15b82:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   15b86:	f8ad 301e 	strh.w	r3, [sp, #30]
        params.latency = req.slave_latency;
   15b8a:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   15b8e:	f8ad 3020 	strh.w	r3, [sp, #32]
        params.supervision_timeout = req.timeout_multiplier;
   15b92:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   15b96:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
        params.min_ce_len = BLE_GAP_INITIAL_CONN_MIN_CE_LEN;
   15b9a:	2310      	movs	r3, #16
   15b9c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        params.max_ce_len = BLE_GAP_INITIAL_CONN_MAX_CE_LEN;

        /* Ask application if slave's connection parameters are acceptable. */
        rc = ble_gap_rx_l2cap_update_req(conn_handle, &params);
   15ba0:	4620      	mov	r0, r4
        params.itvl_min = req.itvl_min;
        params.itvl_max = req.itvl_max;
        params.latency = req.slave_latency;
        params.supervision_timeout = req.timeout_multiplier;
        params.min_ce_len = BLE_GAP_INITIAL_CONN_MIN_CE_LEN;
        params.max_ce_len = BLE_GAP_INITIAL_CONN_MAX_CE_LEN;
   15ba2:	f44f 7340 	mov.w	r3, #768	; 0x300

        /* Ask application if slave's connection parameters are acceptable. */
        rc = ble_gap_rx_l2cap_update_req(conn_handle, &params);
   15ba6:	a907      	add	r1, sp, #28
        params.itvl_min = req.itvl_min;
        params.itvl_max = req.itvl_max;
        params.latency = req.slave_latency;
        params.supervision_timeout = req.timeout_multiplier;
        params.min_ce_len = BLE_GAP_INITIAL_CONN_MIN_CE_LEN;
        params.max_ce_len = BLE_GAP_INITIAL_CONN_MAX_CE_LEN;
   15ba8:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26

        /* Ask application if slave's connection parameters are acceptable. */
        rc = ble_gap_rx_l2cap_update_req(conn_handle, &params);
   15bac:	f7fc f870 	bl	11c90 <ble_gap_rx_l2cap_update_req>
        if (rc == 0) {
   15bb0:	b930      	cbnz	r0, 15bc0 <ble_l2cap_sig_update_req_rx+0x88>
            /* Application agrees to accept parameters; schedule update. */
            rc = ble_gap_update_params(conn_handle, &params);
   15bb2:	4620      	mov	r0, r4
   15bb4:	a907      	add	r1, sp, #28
   15bb6:	f7fc fb25 	bl	12204 <ble_gap_update_params>
            if (rc != 0) {
   15bba:	2800      	cmp	r0, #0
   15bbc:	d0d5      	beq.n	15b6a <ble_l2cap_sig_update_req_rx+0x32>
   15bbe:	e01d      	b.n	15bfc <ble_l2cap_sig_update_req_rx+0xc4>
                return rc;
            }
            l2cap_result = BLE_L2CAP_SIG_UPDATE_RSP_RESULT_ACCEPT;
        } else {
            l2cap_result = BLE_L2CAP_SIG_UPDATE_RSP_RESULT_REJECT;
   15bc0:	2601      	movs	r6, #1
        }
    }

    /* Send L2CAP response. */
    ble_hs_lock();
   15bc2:	f7fe fdbf 	bl	14744 <ble_hs_lock>
    rc = ble_hs_misc_conn_chan_find_reqd(conn_handle, BLE_L2CAP_CID_SIG,
   15bc6:	4620      	mov	r0, r4
   15bc8:	2105      	movs	r1, #5
   15bca:	aa04      	add	r2, sp, #16
   15bcc:	ab03      	add	r3, sp, #12
   15bce:	f7ff fcdc 	bl	1558a <ble_hs_misc_conn_chan_find_reqd>
                                         &conn, &chan);
    if (rc == 0) {
   15bd2:	4604      	mov	r4, r0
   15bd4:	b978      	cbnz	r0, 15bf6 <ble_l2cap_sig_update_req_rx+0xbe>
   15bd6:	786a      	ldrb	r2, [r5, #1]
        if (!sig_err) {
   15bd8:	b937      	cbnz	r7, 15be8 <ble_l2cap_sig_update_req_rx+0xb0>
            rc = ble_l2cap_sig_update_rsp_tx(conn, chan, hdr->identifier,
   15bda:	9804      	ldr	r0, [sp, #16]
   15bdc:	9903      	ldr	r1, [sp, #12]
   15bde:	4633      	mov	r3, r6
   15be0:	f000 f93e 	bl	15e60 <ble_l2cap_sig_update_rsp_tx>
   15be4:	4604      	mov	r4, r0
   15be6:	e006      	b.n	15bf6 <ble_l2cap_sig_update_req_rx+0xbe>
                                             l2cap_result);
        } else {
            ble_l2cap_sig_reject_tx(conn, chan, hdr->identifier,
   15be8:	9000      	str	r0, [sp, #0]
   15bea:	9001      	str	r0, [sp, #4]
   15bec:	9903      	ldr	r1, [sp, #12]
   15bee:	9804      	ldr	r0, [sp, #16]
   15bf0:	4623      	mov	r3, r4
   15bf2:	f000 f8f5 	bl	15de0 <ble_l2cap_sig_reject_tx>
                                    BLE_L2CAP_SIG_ERR_CMD_NOT_UNDERSTOOD,
                                    NULL, 0);
            rc = BLE_HS_L2C_ERR(BLE_L2CAP_SIG_ERR_CMD_NOT_UNDERSTOOD);
        }
    }
    ble_hs_unlock();
   15bf6:	f7fe fdad 	bl	14754 <ble_hs_unlock>

    return rc;
   15bfa:	4620      	mov	r0, r4
}
   15bfc:	b00b      	add	sp, #44	; 0x2c
   15bfe:	bdf0      	pop	{r4, r5, r6, r7, pc}

00015c00 <ble_l2cap_sig_update_rsp_rx>:

static int
ble_l2cap_sig_update_rsp_rx(uint16_t conn_handle,
                            struct ble_l2cap_sig_hdr *hdr,
                            struct os_mbuf **om)
{
   15c00:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   15c02:	4616      	mov	r6, r2
   15c04:	4607      	mov	r7, r0
    struct ble_l2cap_sig_update_rsp rsp;
    struct ble_l2cap_sig_proc *proc;
    int cb_status;
    int rc;

    proc = ble_l2cap_sig_proc_extract(conn_handle,
   15c06:	784d      	ldrb	r5, [r1, #1]
                           uint8_t identifier)
{
    struct ble_l2cap_sig_proc *proc;
    struct ble_l2cap_sig_proc *prev;

    ble_hs_lock();
   15c08:	f7fe fd9c 	bl	14744 <ble_hs_lock>

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_l2cap_sig_procs, next) {
   15c0c:	4b21      	ldr	r3, [pc, #132]	; (15c94 <ble_l2cap_sig_update_rsp_rx+0x94>)
   15c0e:	681a      	ldr	r2, [r3, #0]
   15c10:	4614      	mov	r4, r2
   15c12:	b174      	cbz	r4, 15c32 <ble_l2cap_sig_update_rsp_rx+0x32>
 */
static int
ble_l2cap_sig_proc_matches(struct ble_l2cap_sig_proc *proc,
                           uint16_t conn_handle, uint8_t op, uint8_t id)
{
    if (conn_handle != proc->conn_handle) {
   15c14:	8921      	ldrh	r1, [r4, #8]
   15c16:	42b9      	cmp	r1, r7
   15c18:	d104      	bne.n	15c24 <ble_l2cap_sig_update_rsp_rx+0x24>
        return 0;
    }

    if (op != proc->op) {
   15c1a:	7aa1      	ldrb	r1, [r4, #10]
   15c1c:	b911      	cbnz	r1, 15c24 <ble_l2cap_sig_update_rsp_rx+0x24>
        return 0;
    }

    if (id != proc->id) {
   15c1e:	7ae1      	ldrb	r1, [r4, #11]
   15c20:	42a9      	cmp	r1, r5
   15c22:	d001      	beq.n	15c28 <ble_l2cap_sig_update_rsp_rx+0x28>
    struct ble_l2cap_sig_proc *prev;

    ble_hs_lock();

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_l2cap_sig_procs, next) {
   15c24:	6824      	ldr	r4, [r4, #0]
   15c26:	e7f4      	b.n	15c12 <ble_l2cap_sig_update_rsp_rx+0x12>
        if (ble_l2cap_sig_proc_matches(proc, conn_handle, op, identifier)) {
            if (prev == NULL) {
                STAILQ_REMOVE_HEAD(&ble_l2cap_sig_procs, next);
   15c28:	6811      	ldr	r1, [r2, #0]
   15c2a:	6019      	str	r1, [r3, #0]
   15c2c:	4a19      	ldr	r2, [pc, #100]	; (15c94 <ble_l2cap_sig_update_rsp_rx+0x94>)
   15c2e:	b901      	cbnz	r1, 15c32 <ble_l2cap_sig_update_rsp_rx+0x32>
   15c30:	6052      	str	r2, [r2, #4]
            }
            break;
        }
    }

    ble_hs_unlock();
   15c32:	f7fe fd8f 	bl	14754 <ble_hs_unlock>
    int rc;

    proc = ble_l2cap_sig_proc_extract(conn_handle,
                                      BLE_L2CAP_SIG_PROC_OP_UPDATE,
                                      hdr->identifier);
    if (proc == NULL) {
   15c36:	b1f4      	cbz	r4, 15c76 <ble_l2cap_sig_update_rsp_rx+0x76>
        return BLE_HS_ENOENT;
    }

    rc = ble_hs_misc_pullup_base(om, BLE_L2CAP_SIG_UPDATE_RSP_SZ);
   15c38:	4630      	mov	r0, r6
   15c3a:	2102      	movs	r1, #2
   15c3c:	f7ff fc7c 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   15c40:	4605      	mov	r5, r0
   15c42:	b9d0      	cbnz	r0, 15c7a <ble_l2cap_sig_update_rsp_rx+0x7a>
        cb_status = rc;
        goto done;
    }

    ble_l2cap_sig_update_rsp_parse((*om)->om_data, (*om)->om_len, &rsp);
   15c44:	6833      	ldr	r3, [r6, #0]
   15c46:	aa01      	add	r2, sp, #4
   15c48:	6818      	ldr	r0, [r3, #0]
   15c4a:	88d9      	ldrh	r1, [r3, #6]
   15c4c:	f000 f905 	bl	15e5a <ble_l2cap_sig_update_rsp_parse>

    switch (rsp.result) {
   15c50:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   15c54:	b11b      	cbz	r3, 15c5e <ble_l2cap_sig_update_rsp_rx+0x5e>
   15c56:	2b01      	cmp	r3, #1
   15c58:	d011      	beq.n	15c7e <ble_l2cap_sig_update_rsp_rx+0x7e>
        rc = 0;
        break;

    default:
        cb_status = BLE_HS_EBADDATA;
        rc = BLE_HS_EBADDATA;
   15c5a:	250a      	movs	r5, #10
   15c5c:	e00d      	b.n	15c7a <ble_l2cap_sig_update_rsp_rx+0x7a>
    ble_l2cap_sig_update_rsp_parse((*om)->om_data, (*om)->om_len, &rsp);

    switch (rsp.result) {
    case BLE_L2CAP_SIG_UPDATE_RSP_RESULT_ACCEPT:
        cb_status = 0;
        rc = 0;
   15c5e:	462e      	mov	r6, r5

    if (status != 0) {
        STATS_INC(ble_l2cap_stats, update_fail);
    }

    if (proc->update.cb != NULL) {
   15c60:	68e3      	ldr	r3, [r4, #12]
   15c62:	b113      	cbz	r3, 15c6a <ble_l2cap_sig_update_rsp_rx+0x6a>
        proc->update.cb(status, proc->update.cb_arg);
   15c64:	4628      	mov	r0, r5
   15c66:	6921      	ldr	r1, [r4, #16]
   15c68:	4798      	blx	r3
    int rc;

    if (proc != NULL) {
        ble_l2cap_sig_dbg_assert_proc_not_inserted(proc);

        rc = os_memblock_put(&ble_l2cap_sig_proc_pool, proc);
   15c6a:	480b      	ldr	r0, [pc, #44]	; (15c98 <ble_l2cap_sig_update_rsp_rx+0x98>)
   15c6c:	4621      	mov	r1, r4
   15c6e:	f7f4 fbd7 	bl	a420 <os_memblock_put>
   15c72:	4630      	mov	r0, r6
   15c74:	e00b      	b.n	15c8e <ble_l2cap_sig_update_rsp_rx+0x8e>

    proc = ble_l2cap_sig_proc_extract(conn_handle,
                                      BLE_L2CAP_SIG_PROC_OP_UPDATE,
                                      hdr->identifier);
    if (proc == NULL) {
        return BLE_HS_ENOENT;
   15c76:	2005      	movs	r0, #5
   15c78:	e009      	b.n	15c8e <ble_l2cap_sig_update_rsp_rx+0x8e>
   15c7a:	462b      	mov	r3, r5
   15c7c:	e000      	b.n	15c80 <ble_l2cap_sig_update_rsp_rx+0x80>
        cb_status = 0;
        rc = 0;
        break;

    case BLE_L2CAP_SIG_UPDATE_RSP_RESULT_REJECT:
        cb_status = BLE_HS_EREJECT;
   15c7e:	2310      	movs	r3, #16
ble_l2cap_sig_update_call_cb(struct ble_l2cap_sig_proc *proc, int status)
{
    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (status != 0) {
        STATS_INC(ble_l2cap_stats, update_fail);
   15c80:	4906      	ldr	r1, [pc, #24]	; (15c9c <ble_l2cap_sig_update_rsp_rx+0x9c>)
   15c82:	69ca      	ldr	r2, [r1, #28]
   15c84:	3201      	adds	r2, #1
   15c86:	462e      	mov	r6, r5
   15c88:	61ca      	str	r2, [r1, #28]
   15c8a:	461d      	mov	r5, r3
   15c8c:	e7e8      	b.n	15c60 <ble_l2cap_sig_update_rsp_rx+0x60>

done:
    ble_l2cap_sig_update_call_cb(proc, cb_status);
    ble_l2cap_sig_proc_free(proc);
    return rc;
}
   15c8e:	b003      	add	sp, #12
   15c90:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15c92:	bf00      	nop
   15c94:	20002270 	.word	0x20002270
   15c98:	20002250 	.word	0x20002250
   15c9c:	20003bdc 	.word	0x20003bdc

00015ca0 <ble_l2cap_sig_create_chan>:
    return rc;
}

struct ble_l2cap_chan *
ble_l2cap_sig_create_chan(void)
{
   15ca0:	b508      	push	{r3, lr}
    struct ble_l2cap_chan *chan;

    chan = ble_l2cap_chan_alloc();
   15ca2:	f7ff fdb5 	bl	15810 <ble_l2cap_chan_alloc>
    if (chan == NULL) {
   15ca6:	b130      	cbz	r0, 15cb6 <ble_l2cap_sig_create_chan+0x16>
        return NULL;
    }

    chan->blc_cid = BLE_L2CAP_CID_SIG;
   15ca8:	2305      	movs	r3, #5
   15caa:	8083      	strh	r3, [r0, #4]
    chan->blc_my_mtu = BLE_L2CAP_SIG_MTU;
   15cac:	2364      	movs	r3, #100	; 0x64
   15cae:	80c3      	strh	r3, [r0, #6]
    chan->blc_default_mtu = BLE_L2CAP_SIG_MTU;
   15cb0:	8143      	strh	r3, [r0, #10]
    chan->blc_rx_fn = ble_l2cap_sig_rx;
   15cb2:	4b01      	ldr	r3, [pc, #4]	; (15cb8 <ble_l2cap_sig_create_chan+0x18>)
   15cb4:	6183      	str	r3, [r0, #24]

    return chan;
}
   15cb6:	bd08      	pop	{r3, pc}
   15cb8:	00015a79 	.word	0x00015a79

00015cbc <ble_l2cap_sig_heartbeat>:
 *                                  be called again; currently always
 *                                  UINT32_MAX.
 */
int32_t
ble_l2cap_sig_heartbeat(void)
{
   15cbc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    struct ble_l2cap_sig_proc *prev;
    struct ble_l2cap_sig_proc *next;
    uint32_t now;
    int32_t time_diff;

    now = os_time_get();
   15cbe:	f7f4 fd7f 	bl	a7c0 <os_time_get>
    STAILQ_INIT(dst_list);
   15cc2:	ab02      	add	r3, sp, #8
   15cc4:	2200      	movs	r2, #0
   15cc6:	f843 2d08 	str.w	r2, [r3, #-8]!
    struct ble_l2cap_sig_proc *prev;
    struct ble_l2cap_sig_proc *next;
    uint32_t now;
    int32_t time_diff;

    now = os_time_get();
   15cca:	4605      	mov	r5, r0
    STAILQ_INIT(dst_list);
   15ccc:	9301      	str	r3, [sp, #4]

    ble_hs_lock();
   15cce:	f7fe fd39 	bl	14744 <ble_hs_lock>

    prev = NULL;
    proc = STAILQ_FIRST(&ble_l2cap_sig_procs);
   15cd2:	4a13      	ldr	r2, [pc, #76]	; (15d20 <ble_l2cap_sig_heartbeat+0x64>)
   15cd4:	6813      	ldr	r3, [r2, #0]
    while (proc != NULL) {
   15cd6:	b18b      	cbz	r3, 15cfc <ble_l2cap_sig_heartbeat+0x40>
        next = STAILQ_NEXT(proc, next);
    
        time_diff = now - proc->exp_os_ticks;
   15cd8:	e893 0003 	ldmia.w	r3, {r0, r1}
   15cdc:	1a69      	subs	r1, r5, r1
        if (time_diff >= 0) {
   15cde:	2900      	cmp	r1, #0
   15ce0:	db0a      	blt.n	15cf8 <ble_l2cap_sig_heartbeat+0x3c>
            if (prev == NULL) {
                STAILQ_REMOVE_HEAD(&ble_l2cap_sig_procs, next);
   15ce2:	6814      	ldr	r4, [r2, #0]
   15ce4:	490e      	ldr	r1, [pc, #56]	; (15d20 <ble_l2cap_sig_heartbeat+0x64>)
   15ce6:	6824      	ldr	r4, [r4, #0]
   15ce8:	6014      	str	r4, [r2, #0]
   15cea:	b904      	cbnz	r4, 15cee <ble_l2cap_sig_heartbeat+0x32>
   15cec:	6049      	str	r1, [r1, #4]
            } else {
                STAILQ_REMOVE_AFTER(&ble_l2cap_sig_procs, prev, next);
            }
            STAILQ_INSERT_TAIL(dst_list, proc, next);
   15cee:	2100      	movs	r1, #0
   15cf0:	6019      	str	r1, [r3, #0]
   15cf2:	9901      	ldr	r1, [sp, #4]
   15cf4:	600b      	str	r3, [r1, #0]
   15cf6:	9301      	str	r3, [sp, #4]
 *                                  be called again; currently always
 *                                  UINT32_MAX.
 */
int32_t
ble_l2cap_sig_heartbeat(void)
{
   15cf8:	4603      	mov	r3, r0
   15cfa:	e7ec      	b.n	15cd6 <ble_l2cap_sig_heartbeat+0x1a>
        }

        proc = next;
    }

    ble_hs_unlock();
   15cfc:	f7fe fd2a 	bl	14754 <ble_hs_unlock>
     * temporary list.
     */
    ble_l2cap_sig_extract_expired(&temp_list);

    /* Terminate the connection associated with each timed-out procedure. */
    STAILQ_FOREACH(proc, &temp_list, next) {
   15d00:	9c00      	ldr	r4, [sp, #0]
   15d02:	b14c      	cbz	r4, 15d18 <ble_l2cap_sig_heartbeat+0x5c>
        STATS_INC(ble_l2cap_stats, proc_timeout);
   15d04:	4a07      	ldr	r2, [pc, #28]	; (15d24 <ble_l2cap_sig_heartbeat+0x68>)
        ble_gap_terminate(proc->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
   15d06:	8920      	ldrh	r0, [r4, #8]
     */
    ble_l2cap_sig_extract_expired(&temp_list);

    /* Terminate the connection associated with each timed-out procedure. */
    STAILQ_FOREACH(proc, &temp_list, next) {
        STATS_INC(ble_l2cap_stats, proc_timeout);
   15d08:	6a13      	ldr	r3, [r2, #32]
        ble_gap_terminate(proc->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
   15d0a:	2113      	movs	r1, #19
     */
    ble_l2cap_sig_extract_expired(&temp_list);

    /* Terminate the connection associated with each timed-out procedure. */
    STAILQ_FOREACH(proc, &temp_list, next) {
        STATS_INC(ble_l2cap_stats, proc_timeout);
   15d0c:	3301      	adds	r3, #1
   15d0e:	6213      	str	r3, [r2, #32]
        ble_gap_terminate(proc->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
   15d10:	f7fc f9c4 	bl	1209c <ble_gap_terminate>
     * temporary list.
     */
    ble_l2cap_sig_extract_expired(&temp_list);

    /* Terminate the connection associated with each timed-out procedure. */
    STAILQ_FOREACH(proc, &temp_list, next) {
   15d14:	6824      	ldr	r4, [r4, #0]
   15d16:	e7f4      	b.n	15d02 <ble_l2cap_sig_heartbeat+0x46>
        STATS_INC(ble_l2cap_stats, proc_timeout);
        ble_gap_terminate(proc->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
    }

    return BLE_HS_FOREVER;
}
   15d18:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   15d1c:	b003      	add	sp, #12
   15d1e:	bd30      	pop	{r4, r5, pc}
   15d20:	20002270 	.word	0x20002270
   15d24:	20003bdc 	.word	0x20003bdc

00015d28 <ble_l2cap_sig_init>:

int
ble_l2cap_sig_init(void)
{
   15d28:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int rc;

    free(ble_l2cap_sig_proc_mem);
   15d2a:	4d13      	ldr	r5, [pc, #76]	; (15d78 <ble_l2cap_sig_init+0x50>)
   15d2c:	6828      	ldr	r0, [r5, #0]
   15d2e:	f007 febb 	bl	1daa8 <free>

    STAILQ_INIT(&ble_l2cap_sig_procs);
   15d32:	4b12      	ldr	r3, [pc, #72]	; (15d7c <ble_l2cap_sig_init+0x54>)
   15d34:	2200      	movs	r2, #0
   15d36:	e883 000c 	stmia.w	r3, {r2, r3}

    if (ble_hs_cfg.max_l2cap_sig_procs > 0) {
   15d3a:	4b11      	ldr	r3, [pc, #68]	; (15d80 <ble_l2cap_sig_init+0x58>)
   15d3c:	7b1c      	ldrb	r4, [r3, #12]
   15d3e:	b90c      	cbnz	r4, 15d44 <ble_l2cap_sig_init+0x1c>
        if (rc != 0) {
            goto err;
        }
    }

    return 0;
   15d40:	2000      	movs	r0, #0
   15d42:	e016      	b.n	15d72 <ble_l2cap_sig_init+0x4a>
    free(ble_l2cap_sig_proc_mem);

    STAILQ_INIT(&ble_l2cap_sig_procs);

    if (ble_hs_cfg.max_l2cap_sig_procs > 0) {
        ble_l2cap_sig_proc_mem = malloc(
   15d44:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   15d48:	0080      	lsls	r0, r0, #2
   15d4a:	f007 fe63 	bl	1da14 <malloc>
   15d4e:	4603      	mov	r3, r0
   15d50:	6028      	str	r0, [r5, #0]
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_l2cap_sig_procs,
                             sizeof (struct ble_l2cap_sig_proc)));
        if (ble_l2cap_sig_proc_mem == NULL) {
   15d52:	b148      	cbz	r0, 15d68 <ble_l2cap_sig_init+0x40>
            rc = BLE_HS_ENOMEM;
            goto err;
        }

        rc = os_mempool_init(&ble_l2cap_sig_proc_pool,
   15d54:	4a0b      	ldr	r2, [pc, #44]	; (15d84 <ble_l2cap_sig_init+0x5c>)
   15d56:	9200      	str	r2, [sp, #0]
   15d58:	4621      	mov	r1, r4
   15d5a:	480b      	ldr	r0, [pc, #44]	; (15d88 <ble_l2cap_sig_init+0x60>)
   15d5c:	2214      	movs	r2, #20
   15d5e:	f7f4 fb17 	bl	a390 <os_mempool_init>
                             ble_hs_cfg.max_l2cap_sig_procs,
                             sizeof (struct ble_l2cap_sig_proc),
                             ble_l2cap_sig_proc_mem,
                             "ble_l2cap_sig_proc_pool");
        if (rc != 0) {
   15d62:	4604      	mov	r4, r0
   15d64:	b908      	cbnz	r0, 15d6a <ble_l2cap_sig_init+0x42>
   15d66:	e7eb      	b.n	15d40 <ble_l2cap_sig_init+0x18>
    if (ble_hs_cfg.max_l2cap_sig_procs > 0) {
        ble_l2cap_sig_proc_mem = malloc(
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_l2cap_sig_procs,
                             sizeof (struct ble_l2cap_sig_proc)));
        if (ble_l2cap_sig_proc_mem == NULL) {
            rc = BLE_HS_ENOMEM;
   15d68:	2406      	movs	r4, #6
    }

    return 0;

err:
    free(ble_l2cap_sig_proc_mem);
   15d6a:	6828      	ldr	r0, [r5, #0]
   15d6c:	f007 fe9c 	bl	1daa8 <free>
    return rc;
   15d70:	4620      	mov	r0, r4
}
   15d72:	b003      	add	sp, #12
   15d74:	bd30      	pop	{r4, r5, pc}
   15d76:	bf00      	nop
   15d78:	2000226c 	.word	0x2000226c
   15d7c:	20002270 	.word	0x20002270
   15d80:	20003b78 	.word	0x20003b78
   15d84:	0001fb66 	.word	0x0001fb66
   15d88:	20002250 	.word	0x20002250

00015d8c <ble_l2cap_sig_init_cmd>:
#include "ble_hs_priv.h"

int
ble_l2cap_sig_init_cmd(uint8_t op, uint8_t id, uint8_t payload_len,
                       struct os_mbuf **out_om, void **out_payload_buf)
{
   15d8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15d90:	9e08      	ldr	r6, [sp, #32]
    struct ble_l2cap_sig_hdr hdr;
    struct os_mbuf *txom;
    void *v;

    *out_om = NULL;
   15d92:	2400      	movs	r4, #0
   15d94:	601c      	str	r4, [r3, #0]
    *out_payload_buf = NULL;
   15d96:	6034      	str	r4, [r6, #0]
#include "ble_hs_priv.h"

int
ble_l2cap_sig_init_cmd(uint8_t op, uint8_t id, uint8_t payload_len,
                       struct os_mbuf **out_om, void **out_payload_buf)
{
   15d98:	4681      	mov	r9, r0
   15d9a:	4688      	mov	r8, r1
   15d9c:	4615      	mov	r5, r2
   15d9e:	461f      	mov	r7, r3
    void *v;

    *out_om = NULL;
    *out_payload_buf = NULL;

    txom = ble_hs_misc_pkthdr();
   15da0:	f7ff fbb8 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   15da4:	4682      	mov	sl, r0
   15da6:	b910      	cbnz	r0, 15dae <ble_l2cap_sig_init_cmd+0x22>
        return BLE_HS_ENOMEM;
   15da8:	2006      	movs	r0, #6
   15daa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }

    v = os_mbuf_extend(txom, BLE_L2CAP_SIG_HDR_SZ + payload_len);
   15dae:	b2ad      	uxth	r5, r5
   15db0:	1d29      	adds	r1, r5, #4
   15db2:	f7f4 fa5d 	bl	a270 <os_mbuf_extend>
    if (v == NULL) {
   15db6:	2800      	cmp	r0, #0
   15db8:	d0f6      	beq.n	15da8 <ble_l2cap_sig_init_cmd+0x1c>

static void
ble_l2cap_sig_hdr_swap(struct ble_l2cap_sig_hdr *dst,
                       struct ble_l2cap_sig_hdr *src)
{
    dst->op = src->op;
   15dba:	f880 9000 	strb.w	r9, [r0]
    dst->identifier = src->identifier;
   15dbe:	f880 8001 	strb.w	r8, [r0, #1]
    hdr.length = TOFROMLE16(payload_len);

    ble_l2cap_sig_hdr_write(v, BLE_L2CAP_SIG_HDR_SZ, &hdr);

    *out_om = txom;
    *out_payload_buf = (uint8_t *)v + BLE_L2CAP_SIG_HDR_SZ;
   15dc2:	1d03      	adds	r3, r0, #4
ble_l2cap_sig_hdr_swap(struct ble_l2cap_sig_hdr *dst,
                       struct ble_l2cap_sig_hdr *src)
{
    dst->op = src->op;
    dst->identifier = src->identifier;
    dst->length = TOFROMLE16(src->length);
   15dc4:	8045      	strh	r5, [r0, #2]
    hdr.identifier = id;
    hdr.length = TOFROMLE16(payload_len);

    ble_l2cap_sig_hdr_write(v, BLE_L2CAP_SIG_HDR_SZ, &hdr);

    *out_om = txom;
   15dc6:	f8c7 a000 	str.w	sl, [r7]
    *out_payload_buf = (uint8_t *)v + BLE_L2CAP_SIG_HDR_SZ;

    return 0;
   15dca:	4620      	mov	r0, r4
    hdr.length = TOFROMLE16(payload_len);

    ble_l2cap_sig_hdr_write(v, BLE_L2CAP_SIG_HDR_SZ, &hdr);

    *out_om = txom;
    *out_payload_buf = (uint8_t *)v + BLE_L2CAP_SIG_HDR_SZ;
   15dcc:	6033      	str	r3, [r6, #0]

    return 0;
}
   15dce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00015dd2 <ble_l2cap_sig_hdr_parse>:

static void
ble_l2cap_sig_hdr_swap(struct ble_l2cap_sig_hdr *dst,
                       struct ble_l2cap_sig_hdr *src)
{
    dst->op = src->op;
   15dd2:	7803      	ldrb	r3, [r0, #0]
   15dd4:	7013      	strb	r3, [r2, #0]
    dst->identifier = src->identifier;
   15dd6:	7843      	ldrb	r3, [r0, #1]
   15dd8:	7053      	strb	r3, [r2, #1]
    dst->length = TOFROMLE16(src->length);
   15dda:	8843      	ldrh	r3, [r0, #2]
   15ddc:	8053      	strh	r3, [r2, #2]
   15dde:	4770      	bx	lr

00015de0 <ble_l2cap_sig_reject_tx>:

int
ble_l2cap_sig_reject_tx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan,
                        uint8_t id, uint16_t reason,
                        void *data, int data_len)
{
   15de0:	b5f0      	push	{r4, r5, r6, r7, lr}
   15de2:	b085      	sub	sp, #20
   15de4:	460d      	mov	r5, r1
   15de6:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   15de8:	461f      	mov	r7, r3
    struct ble_l2cap_sig_reject cmd;
    struct os_mbuf *txom;
    void *payload_buf;
    int rc;

    rc = ble_l2cap_sig_init_cmd(BLE_L2CAP_SIG_OP_REJECT, id,
   15dea:	a903      	add	r1, sp, #12
   15dec:	1ca3      	adds	r3, r4, #2

int
ble_l2cap_sig_reject_tx(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan,
                        uint8_t id, uint16_t reason,
                        void *data, int data_len)
{
   15dee:	4606      	mov	r6, r0
    struct ble_l2cap_sig_reject cmd;
    struct os_mbuf *txom;
    void *payload_buf;
    int rc;

    rc = ble_l2cap_sig_init_cmd(BLE_L2CAP_SIG_OP_REJECT, id,
   15df0:	9100      	str	r1, [sp, #0]
   15df2:	2001      	movs	r0, #1
   15df4:	4611      	mov	r1, r2
   15df6:	b2da      	uxtb	r2, r3
   15df8:	ab02      	add	r3, sp, #8
   15dfa:	f7ff ffc7 	bl	15d8c <ble_l2cap_sig_init_cmd>
}
static void
ble_l2cap_sig_reject_swap(struct ble_l2cap_sig_reject *dst,
                          struct ble_l2cap_sig_reject *src)
{
    dst->reason = TOFROMLE16(src->reason);
   15dfe:	9803      	ldr	r0, [sp, #12]

    ble_l2cap_sig_reject_swap(payload, src);

    u8ptr = payload;
    u8ptr += BLE_L2CAP_SIG_REJECT_MIN_SZ;
    memcpy(u8ptr, data, data_len);
   15e00:	990a      	ldr	r1, [sp, #40]	; 0x28
}
static void
ble_l2cap_sig_reject_swap(struct ble_l2cap_sig_reject *dst,
                          struct ble_l2cap_sig_reject *src)
{
    dst->reason = TOFROMLE16(src->reason);
   15e02:	f820 7b02 	strh.w	r7, [r0], #2

    ble_l2cap_sig_reject_swap(payload, src);

    u8ptr = payload;
    u8ptr += BLE_L2CAP_SIG_REJECT_MIN_SZ;
    memcpy(u8ptr, data, data_len);
   15e06:	4622      	mov	r2, r4
   15e08:	f7f3 f8f8 	bl	8ffc <memcpy>

    cmd.reason = reason;
    ble_l2cap_sig_reject_write(payload_buf, txom->om_len, &cmd,
                               data, data_len);

    STATS_INC(ble_l2cap_stats, sig_rx);
   15e0c:	4a05      	ldr	r2, [pc, #20]	; (15e24 <ble_l2cap_sig_reject_tx+0x44>)
   15e0e:	6a93      	ldr	r3, [r2, #40]	; 0x28
   15e10:	3301      	adds	r3, #1
   15e12:	6293      	str	r3, [r2, #40]	; 0x28
    rc = ble_l2cap_tx(conn, chan, txom);
   15e14:	4630      	mov	r0, r6
   15e16:	4629      	mov	r1, r5
   15e18:	9a02      	ldr	r2, [sp, #8]
   15e1a:	f7ff fdd1 	bl	159c0 <ble_l2cap_tx>
    return rc;
}
   15e1e:	b005      	add	sp, #20
   15e20:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15e22:	bf00      	nop
   15e24:	20003bdc 	.word	0x20003bdc

00015e28 <ble_l2cap_sig_reject_invalid_cid_tx>:

int
ble_l2cap_sig_reject_invalid_cid_tx(struct ble_hs_conn *conn,
                                    struct ble_l2cap_chan *chan, uint8_t id,
                                    uint16_t src_cid, uint16_t dst_cid)
{
   15e28:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    int rc;

    struct {
        uint16_t local_cid;
        uint16_t remote_cid;
    } data = {
   15e2a:	f8ad 300e 	strh.w	r3, [sp, #14]
        .local_cid = dst_cid,
        .remote_cid = src_cid,
    };

    rc = ble_l2cap_sig_reject_tx(conn, chan, id,
   15e2e:	ab03      	add	r3, sp, #12
   15e30:	9300      	str	r3, [sp, #0]
   15e32:	2304      	movs	r3, #4
    int rc;

    struct {
        uint16_t local_cid;
        uint16_t remote_cid;
    } data = {
   15e34:	f8bd 4018 	ldrh.w	r4, [sp, #24]
        .local_cid = dst_cid,
        .remote_cid = src_cid,
    };

    rc = ble_l2cap_sig_reject_tx(conn, chan, id,
   15e38:	9301      	str	r3, [sp, #4]
   15e3a:	2302      	movs	r3, #2
    int rc;

    struct {
        uint16_t local_cid;
        uint16_t remote_cid;
    } data = {
   15e3c:	f8ad 400c 	strh.w	r4, [sp, #12]
        .local_cid = dst_cid,
        .remote_cid = src_cid,
    };

    rc = ble_l2cap_sig_reject_tx(conn, chan, id,
   15e40:	f7ff ffce 	bl	15de0 <ble_l2cap_sig_reject_tx>
                                 BLE_L2CAP_SIG_ERR_INVALID_CID,
                                 &data, sizeof data);
    return rc;
}
   15e44:	b004      	add	sp, #16
   15e46:	bd10      	pop	{r4, pc}

00015e48 <ble_l2cap_sig_update_req_parse>:

static void
ble_l2cap_sig_update_req_swap(struct ble_l2cap_sig_update_req *dst,
                              struct ble_l2cap_sig_update_req *src)
{
    dst->itvl_min = TOFROMLE16(src->itvl_min);
   15e48:	8803      	ldrh	r3, [r0, #0]
   15e4a:	8013      	strh	r3, [r2, #0]
    dst->itvl_max = TOFROMLE16(src->itvl_max);
   15e4c:	8843      	ldrh	r3, [r0, #2]
   15e4e:	8053      	strh	r3, [r2, #2]
    dst->slave_latency = TOFROMLE16(src->slave_latency);
   15e50:	8883      	ldrh	r3, [r0, #4]
   15e52:	8093      	strh	r3, [r2, #4]
    dst->timeout_multiplier = TOFROMLE16(src->timeout_multiplier);
   15e54:	88c3      	ldrh	r3, [r0, #6]
   15e56:	80d3      	strh	r3, [r2, #6]
   15e58:	4770      	bx	lr

00015e5a <ble_l2cap_sig_update_rsp_parse>:

static void
ble_l2cap_sig_update_rsp_swap(struct ble_l2cap_sig_update_rsp *dst,
                              struct ble_l2cap_sig_update_rsp *src)
{
    dst->result = TOFROMLE16(src->result);
   15e5a:	8803      	ldrh	r3, [r0, #0]
   15e5c:	8013      	strh	r3, [r2, #0]
   15e5e:	4770      	bx	lr

00015e60 <ble_l2cap_sig_update_rsp_tx>:

int
ble_l2cap_sig_update_rsp_tx(struct ble_hs_conn *conn,
                            struct ble_l2cap_chan *chan, uint8_t id,
                            uint16_t result)
{
   15e60:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   15e62:	461e      	mov	r6, r3
    struct ble_l2cap_sig_update_rsp rsp;
    struct os_mbuf *txom;
    void *payload_buf;
    int rc;

    rc = ble_l2cap_sig_init_cmd(BLE_L2CAP_SIG_OP_UPDATE_RSP, id,
   15e64:	ab03      	add	r3, sp, #12

int
ble_l2cap_sig_update_rsp_tx(struct ble_hs_conn *conn,
                            struct ble_l2cap_chan *chan, uint8_t id,
                            uint16_t result)
{
   15e66:	4605      	mov	r5, r0
   15e68:	460c      	mov	r4, r1
    struct ble_l2cap_sig_update_rsp rsp;
    struct os_mbuf *txom;
    void *payload_buf;
    int rc;

    rc = ble_l2cap_sig_init_cmd(BLE_L2CAP_SIG_OP_UPDATE_RSP, id,
   15e6a:	9300      	str	r3, [sp, #0]
   15e6c:	4611      	mov	r1, r2
   15e6e:	2013      	movs	r0, #19
   15e70:	2202      	movs	r2, #2
   15e72:	ab02      	add	r3, sp, #8
   15e74:	f7ff ff8a 	bl	15d8c <ble_l2cap_sig_init_cmd>
                                BLE_L2CAP_SIG_UPDATE_RSP_SZ, &txom,
                                &payload_buf);
    if (rc != 0) {
   15e78:	b930      	cbnz	r0, 15e88 <ble_l2cap_sig_update_rsp_tx+0x28>

static void
ble_l2cap_sig_update_rsp_swap(struct ble_l2cap_sig_update_rsp *dst,
                              struct ble_l2cap_sig_update_rsp *src)
{
    dst->result = TOFROMLE16(src->result);
   15e7a:	9b03      	ldr	r3, [sp, #12]

    rsp.result = result;
    ble_l2cap_sig_update_rsp_write(payload_buf, BLE_L2CAP_SIG_UPDATE_RSP_SZ,
                                   &rsp);

    rc = ble_l2cap_tx(conn, chan, txom);
   15e7c:	9a02      	ldr	r2, [sp, #8]

static void
ble_l2cap_sig_update_rsp_swap(struct ble_l2cap_sig_update_rsp *dst,
                              struct ble_l2cap_sig_update_rsp *src)
{
    dst->result = TOFROMLE16(src->result);
   15e7e:	801e      	strh	r6, [r3, #0]

    rsp.result = result;
    ble_l2cap_sig_update_rsp_write(payload_buf, BLE_L2CAP_SIG_UPDATE_RSP_SZ,
                                   &rsp);

    rc = ble_l2cap_tx(conn, chan, txom);
   15e80:	4628      	mov	r0, r5
   15e82:	4621      	mov	r1, r4
   15e84:	f7ff fd9c 	bl	159c0 <ble_l2cap_tx>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   15e88:	b004      	add	sp, #16
   15e8a:	bd70      	pop	{r4, r5, r6, pc}

00015e8c <ble_sm_insert>:
    STAILQ_FOREACH(cur, &ble_sm_procs, next) {
        BLE_HS_DBG_ASSERT(cur != proc);
    }
#endif

    STAILQ_INSERT_HEAD(&ble_sm_procs, proc, next);
   15e8c:	4b03      	ldr	r3, [pc, #12]	; (15e9c <ble_sm_insert+0x10>)
   15e8e:	681a      	ldr	r2, [r3, #0]
   15e90:	6002      	str	r2, [r0, #0]
   15e92:	b902      	cbnz	r2, 15e96 <ble_sm_insert+0xa>
   15e94:	6058      	str	r0, [r3, #4]
   15e96:	6018      	str	r0, [r3, #0]
   15e98:	4770      	bx	lr
   15e9a:	bf00      	nop
   15e9c:	20002278 	.word	0x20002278

00015ea0 <ble_sm_rx_noop>:

static void
ble_sm_rx_noop(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
               struct ble_sm_result *res)
{
    res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
   15ea0:	f240 4207 	movw	r2, #1031	; 0x407
   15ea4:	601a      	str	r2, [r3, #0]
    res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
   15ea6:	2207      	movs	r2, #7
   15ea8:	711a      	strb	r2, [r3, #4]
   15eaa:	4770      	bx	lr

00015eac <ble_sm_io_action>:
}

static int
ble_sm_io_action(struct ble_sm_proc *proc)
{
    if (proc->flags & BLE_SM_PROC_F_SC) {
   15eac:	7a03      	ldrb	r3, [r0, #8]
   15eae:	06db      	lsls	r3, r3, #27
   15eb0:	d401      	bmi.n	15eb6 <ble_sm_io_action+0xa>
        return ble_sm_sc_io_action(proc);
    } else {
        return ble_sm_lgcy_io_action(proc);
   15eb2:	f002 b93b 	b.w	1812c <ble_sm_lgcy_io_action>
    }
}
   15eb6:	2000      	movs	r0, #0
   15eb8:	4770      	bx	lr

00015eba <ble_sm_fill_store_value>:
static void
ble_sm_fill_store_value(uint8_t peer_addr_type, uint8_t *peer_addr,
                        int authenticated,
                        struct ble_sm_keys *keys,
                        struct ble_store_value_sec *value_sec)
{
   15eba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15ebe:	9c06      	ldr	r4, [sp, #24]
   15ec0:	460f      	mov	r7, r1
   15ec2:	4680      	mov	r8, r0
   15ec4:	4616      	mov	r6, r2
    memset(value_sec, 0, sizeof *value_sec);
   15ec6:	4620      	mov	r0, r4
   15ec8:	2100      	movs	r1, #0
   15eca:	2250      	movs	r2, #80	; 0x50
static void
ble_sm_fill_store_value(uint8_t peer_addr_type, uint8_t *peer_addr,
                        int authenticated,
                        struct ble_sm_keys *keys,
                        struct ble_store_value_sec *value_sec)
{
   15ecc:	461d      	mov	r5, r3
    memset(value_sec, 0, sizeof *value_sec);
   15ece:	f7f3 f8a0 	bl	9012 <memset>

    value_sec->peer_addr_type = peer_addr_type;
   15ed2:	f884 8006 	strb.w	r8, [r4, #6]
    memcpy(value_sec->peer_addr, peer_addr, sizeof value_sec->peer_addr);
   15ed6:	683b      	ldr	r3, [r7, #0]
   15ed8:	6023      	str	r3, [r4, #0]
   15eda:	88bb      	ldrh	r3, [r7, #4]
   15edc:	80a3      	strh	r3, [r4, #4]

    if (keys->ediv_rand_valid && keys->ltk_valid) {
   15ede:	782b      	ldrb	r3, [r5, #0]
   15ee0:	f003 0303 	and.w	r3, r3, #3
   15ee4:	2b03      	cmp	r3, #3
   15ee6:	d122      	bne.n	15f2e <ble_sm_fill_store_value+0x74>
        value_sec->ediv = keys->ediv;
   15ee8:	886b      	ldrh	r3, [r5, #2]
   15eea:	8123      	strh	r3, [r4, #8]
        value_sec->rand_num = keys->rand_val;
   15eec:	e9d5 2302 	ldrd	r2, r3, [r5, #8]

        memcpy(value_sec->ltk, keys->ltk, sizeof value_sec->ltk);
   15ef0:	f105 0121 	add.w	r1, r5, #33	; 0x21
    value_sec->peer_addr_type = peer_addr_type;
    memcpy(value_sec->peer_addr, peer_addr, sizeof value_sec->peer_addr);

    if (keys->ediv_rand_valid && keys->ltk_valid) {
        value_sec->ediv = keys->ediv;
        value_sec->rand_num = keys->rand_val;
   15ef4:	e9c4 2304 	strd	r2, r3, [r4, #16]

        memcpy(value_sec->ltk, keys->ltk, sizeof value_sec->ltk);
   15ef8:	f105 0311 	add.w	r3, r5, #17
   15efc:	f104 0218 	add.w	r2, r4, #24
   15f00:	f853 0b04 	ldr.w	r0, [r3], #4
   15f04:	f842 0b04 	str.w	r0, [r2], #4
   15f08:	428b      	cmp	r3, r1
   15f0a:	d1f9      	bne.n	15f00 <ble_sm_fill_store_value+0x46>
        value_sec->ltk_present = 1;
   15f0c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   15f10:	f043 0301 	orr.w	r3, r3, #1

        value_sec->authenticated = !!authenticated;
   15f14:	3600      	adds	r6, #0
    if (keys->ediv_rand_valid && keys->ltk_valid) {
        value_sec->ediv = keys->ediv;
        value_sec->rand_num = keys->rand_val;

        memcpy(value_sec->ltk, keys->ltk, sizeof value_sec->ltk);
        value_sec->ltk_present = 1;
   15f16:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28

        value_sec->authenticated = !!authenticated;
   15f1a:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
   15f1e:	bf18      	it	ne
   15f20:	2601      	movne	r6, #1
   15f22:	f366 0341 	bfi	r3, r6, #1, #1
        value_sec->sc = 0;
   15f26:	f36f 0382 	bfc	r3, #2, #1
   15f2a:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
    }

    if (keys->irk_valid) {
   15f2e:	782b      	ldrb	r3, [r5, #0]
   15f30:	075a      	lsls	r2, r3, #29
   15f32:	d511      	bpl.n	15f58 <ble_sm_fill_store_value+0x9e>
        memcpy(value_sec->irk, keys->irk, sizeof value_sec->irk);
   15f34:	f105 0321 	add.w	r3, r5, #33	; 0x21
   15f38:	f104 0229 	add.w	r2, r4, #41	; 0x29
   15f3c:	f105 0131 	add.w	r1, r5, #49	; 0x31
   15f40:	f853 0b04 	ldr.w	r0, [r3], #4
   15f44:	f842 0b04 	str.w	r0, [r2], #4
   15f48:	428b      	cmp	r3, r1
   15f4a:	d1f9      	bne.n	15f40 <ble_sm_fill_store_value+0x86>
        value_sec->irk_present = 1;
   15f4c:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   15f50:	f043 0301 	orr.w	r3, r3, #1
   15f54:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    }

    if (keys->csrk_valid) {
   15f58:	782b      	ldrb	r3, [r5, #0]
   15f5a:	071b      	lsls	r3, r3, #28
   15f5c:	d510      	bpl.n	15f80 <ble_sm_fill_store_value+0xc6>
        memcpy(value_sec->csrk, keys->csrk, sizeof value_sec->csrk);
   15f5e:	f105 0331 	add.w	r3, r5, #49	; 0x31
   15f62:	f104 023a 	add.w	r2, r4, #58	; 0x3a
   15f66:	3541      	adds	r5, #65	; 0x41
   15f68:	f853 1b04 	ldr.w	r1, [r3], #4
   15f6c:	f842 1b04 	str.w	r1, [r2], #4
   15f70:	42ab      	cmp	r3, r5
   15f72:	d1f9      	bne.n	15f68 <ble_sm_fill_store_value+0xae>
        value_sec->csrk_present = 1;
   15f74:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
   15f78:	f043 0301 	orr.w	r3, r3, #1
   15f7c:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
   15f80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00015f84 <ble_sm_enc_start_exec>:
}

static void
ble_sm_enc_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                      void *arg)
{
   15f84:	b570      	push	{r4, r5, r6, lr}
   15f86:	b090      	sub	sp, #64	; 0x40
    struct hci_start_encrypt cmd;
    int rc;

    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);

    cmd.connection_handle = proc->conn_handle;
   15f88:	8943      	ldrh	r3, [r0, #10]
   15f8a:	f8ad 3020 	strh.w	r3, [sp, #32]
    cmd.encrypted_diversifier = 0;
   15f8e:	2300      	movs	r3, #0
    cmd.random_number = 0;
   15f90:	2200      	movs	r2, #0
    int rc;

    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);

    cmd.connection_handle = proc->conn_handle;
    cmd.encrypted_diversifier = 0;
   15f92:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
    cmd.random_number = 0;
   15f96:	2300      	movs	r3, #0
   15f98:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
}

static void
ble_sm_enc_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                      void *arg)
{
   15f9c:	460c      	mov	r4, r1
    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);

    cmd.connection_handle = proc->conn_handle;
    cmd.encrypted_diversifier = 0;
    cmd.random_number = 0;
    memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);
   15f9e:	f100 025b 	add.w	r2, r0, #91	; 0x5b
   15fa2:	ae0c      	add	r6, sp, #48	; 0x30
   15fa4:	f100 036b 	add.w	r3, r0, #107	; 0x6b
   15fa8:	6810      	ldr	r0, [r2, #0]
   15faa:	6851      	ldr	r1, [r2, #4]
   15fac:	4635      	mov	r5, r6
   15fae:	c503      	stmia	r5!, {r0, r1}
   15fb0:	3208      	adds	r2, #8
   15fb2:	429a      	cmp	r2, r3
   15fb4:	462e      	mov	r6, r5
   15fb6:	d1f7      	bne.n	15fa8 <ble_sm_enc_start_exec+0x24>
ble_sm_start_encrypt_tx(struct hci_start_encrypt *cmd)
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_LE_START_ENCRYPT_LEN];
    int rc;

    host_hci_cmd_build_le_start_encrypt(cmd, buf, sizeof buf);
   15fb8:	a808      	add	r0, sp, #32
   15fba:	4669      	mov	r1, sp
   15fbc:	221f      	movs	r2, #31
   15fbe:	f003 fc6d 	bl	1989c <host_hci_cmd_build_le_start_encrypt>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   15fc2:	4668      	mov	r0, sp
   15fc4:	f7fe fb30 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    cmd.encrypted_diversifier = 0;
    cmd.random_number = 0;
    memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);

    rc = ble_sm_start_encrypt_tx(&cmd);
    if (rc != 0) {
   15fc8:	b130      	cbz	r0, 15fd8 <ble_sm_enc_start_exec+0x54>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   15fca:	2308      	movs	r3, #8
   15fcc:	7123      	strb	r3, [r4, #4]
        res->app_status = rc;
        res->enc_cb = 1;
   15fce:	7d23      	ldrb	r3, [r4, #20]
    memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);

    rc = ble_sm_start_encrypt_tx(&cmd);
    if (rc != 0) {
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
        res->app_status = rc;
   15fd0:	6020      	str	r0, [r4, #0]
        res->enc_cb = 1;
   15fd2:	f043 0302 	orr.w	r3, r3, #2
   15fd6:	7523      	strb	r3, [r4, #20]
    }
}
   15fd8:	b010      	add	sp, #64	; 0x40
   15fda:	bd70      	pop	{r4, r5, r6, pc}

00015fdc <ble_sm_ltk_req_reply_tx>:
    return rc;
}

static int
ble_sm_ltk_req_reply_tx(uint16_t conn_handle, uint8_t *ltk)
{
   15fdc:	b510      	push	{r4, lr}
   15fde:	b08c      	sub	sp, #48	; 0x30
   15fe0:	4604      	mov	r4, r0
    uint16_t ack_conn_handle;
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_LT_KEY_REQ_REPLY_LEN];
    uint8_t ack_params_len;
    int rc;

    cmd.conn_handle = conn_handle;
   15fe2:	f8ad 0004 	strh.w	r0, [sp, #4]
    memcpy(cmd.long_term_key, ltk, 16);
   15fe6:	f10d 0306 	add.w	r3, sp, #6
   15fea:	f101 0210 	add.w	r2, r1, #16
   15fee:	f851 0b04 	ldr.w	r0, [r1], #4
   15ff2:	f843 0b04 	str.w	r0, [r3], #4
   15ff6:	4291      	cmp	r1, r2
   15ff8:	d1f9      	bne.n	15fee <ble_sm_ltk_req_reply_tx+0x12>

    host_hci_cmd_build_le_lt_key_req_reply(&cmd, buf, sizeof buf);
   15ffa:	a801      	add	r0, sp, #4
   15ffc:	a906      	add	r1, sp, #24
   15ffe:	2215      	movs	r2, #21
   16000:	f003 fbdd 	bl	197be <host_hci_cmd_build_le_lt_key_req_reply>
    rc = ble_hci_cmd_tx(buf, &ack_conn_handle, sizeof ack_conn_handle,
   16004:	a806      	add	r0, sp, #24
   16006:	f10d 0102 	add.w	r1, sp, #2
   1600a:	2202      	movs	r2, #2
   1600c:	f10d 0301 	add.w	r3, sp, #1
   16010:	f7fe fa76 	bl	14500 <ble_hci_cmd_tx>
                        &ack_params_len);
    if (rc != 0) {
   16014:	b958      	cbnz	r0, 1602e <ble_sm_ltk_req_reply_tx+0x52>
        return rc;
    }
    if (ack_params_len != BLE_HCI_LT_KEY_REQ_REPLY_ACK_PARAM_LEN) {
   16016:	f89d 3001 	ldrb.w	r3, [sp, #1]
   1601a:	2b02      	cmp	r3, #2
   1601c:	d106      	bne.n	1602c <ble_sm_ltk_req_reply_tx+0x50>
        return BLE_HS_ECONTROLLER;
    }

    ack_conn_handle = TOFROMLE16(ack_conn_handle);
    if (ack_conn_handle != conn_handle) {
   1601e:	f8bd 0002 	ldrh.w	r0, [sp, #2]
        return BLE_HS_ECONTROLLER;
    }

    return 0;
   16022:	42a0      	cmp	r0, r4
   16024:	bf14      	ite	ne
   16026:	200c      	movne	r0, #12
   16028:	2000      	moveq	r0, #0
   1602a:	e000      	b.n	1602e <ble_sm_ltk_req_reply_tx+0x52>
                        &ack_params_len);
    if (rc != 0) {
        return rc;
    }
    if (ack_params_len != BLE_HCI_LT_KEY_REQ_REPLY_ACK_PARAM_LEN) {
        return BLE_HS_ECONTROLLER;
   1602c:	200c      	movs	r0, #12
    if (ack_conn_handle != conn_handle) {
        return BLE_HS_ECONTROLLER;
    }

    return 0;
}
   1602e:	b00c      	add	sp, #48	; 0x30
   16030:	bd10      	pop	{r4, pc}

00016032 <ble_sm_ltk_start_exec>:
}

static void
ble_sm_ltk_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                      void *arg)
{
   16032:	b538      	push	{r3, r4, r5, lr}
   16034:	4605      	mov	r5, r0
   16036:	460c      	mov	r4, r1
    BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));

    res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, proc->ltk);
   16038:	8940      	ldrh	r0, [r0, #10]
   1603a:	f105 015b 	add.w	r1, r5, #91	; 0x5b
   1603e:	f7ff ffcd 	bl	15fdc <ble_sm_ltk_req_reply_tx>
   16042:	6020      	str	r0, [r4, #0]
    if (res->app_status == 0) {
   16044:	b910      	cbnz	r0, 1604c <ble_sm_ltk_start_exec+0x1a>
        proc->state = BLE_SM_PROC_STATE_ENC_START;
   16046:	2305      	movs	r3, #5
   16048:	736b      	strb	r3, [r5, #13]
   1604a:	bd38      	pop	{r3, r4, r5, pc}
    } else {
        res->enc_cb = 1;
   1604c:	7d23      	ldrb	r3, [r4, #20]
   1604e:	f043 0302 	orr.w	r3, r3, #2
   16052:	7523      	strb	r3, [r4, #20]
   16054:	bd38      	pop	{r3, r4, r5, pc}

00016056 <ble_sm_ltk_req_neg_reply_tx>:
    return 0;
}

static int
ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
{
   16056:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint16_t ack_conn_handle;
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_LT_KEY_REQ_NEG_REPLY_LEN];
    uint8_t ack_params_len;
    int rc;

    host_hci_cmd_build_le_lt_key_req_neg_reply(conn_handle, buf, sizeof buf);
   16058:	2205      	movs	r2, #5
   1605a:	a902      	add	r1, sp, #8
    return 0;
}

static int
ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
{
   1605c:	4604      	mov	r4, r0
    uint16_t ack_conn_handle;
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_LT_KEY_REQ_NEG_REPLY_LEN];
    uint8_t ack_params_len;
    int rc;

    host_hci_cmd_build_le_lt_key_req_neg_reply(conn_handle, buf, sizeof buf);
   1605e:	f003 fbc7 	bl	197f0 <host_hci_cmd_build_le_lt_key_req_neg_reply>
    rc = ble_hci_cmd_tx(buf, &ack_conn_handle, sizeof ack_conn_handle,
   16062:	a802      	add	r0, sp, #8
   16064:	f10d 0106 	add.w	r1, sp, #6
   16068:	2202      	movs	r2, #2
   1606a:	f10d 0305 	add.w	r3, sp, #5
   1606e:	f7fe fa47 	bl	14500 <ble_hci_cmd_tx>
                        &ack_params_len);
    if (rc != 0) {
   16072:	b958      	cbnz	r0, 1608c <ble_sm_ltk_req_neg_reply_tx+0x36>
        return rc;
    }
    if (ack_params_len != BLE_HCI_LT_KEY_REQ_NEG_REPLY_ACK_PARAM_LEN) {
   16074:	f89d 3005 	ldrb.w	r3, [sp, #5]
   16078:	2b02      	cmp	r3, #2
   1607a:	d106      	bne.n	1608a <ble_sm_ltk_req_neg_reply_tx+0x34>
        return BLE_HS_ECONTROLLER;
    }

    ack_conn_handle = TOFROMLE16(ack_conn_handle);
    if (ack_conn_handle != conn_handle) {
   1607c:	f8bd 0006 	ldrh.w	r0, [sp, #6]
        return BLE_HS_ECONTROLLER;
    }

    return 0;
   16080:	42a0      	cmp	r0, r4
   16082:	bf14      	ite	ne
   16084:	200c      	movne	r0, #12
   16086:	2000      	moveq	r0, #0
   16088:	e000      	b.n	1608c <ble_sm_ltk_req_neg_reply_tx+0x36>
                        &ack_params_len);
    if (rc != 0) {
        return rc;
    }
    if (ack_params_len != BLE_HCI_LT_KEY_REQ_NEG_REPLY_ACK_PARAM_LEN) {
        return BLE_HS_ECONTROLLER;
   1608a:	200c      	movs	r0, #12
    if (ack_conn_handle != conn_handle) {
        return BLE_HS_ECONTROLLER;
    }

    return 0;
}
   1608c:	b004      	add	sp, #16
   1608e:	bd10      	pop	{r4, pc}

00016090 <ble_sm_ltk_restore_exec>:
}

static void
ble_sm_ltk_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                        void *arg)
{
   16090:	b570      	push	{r4, r5, r6, lr}
   16092:	4605      	mov	r5, r0
   16094:	460c      	mov	r4, r1

    BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));

    value_sec = arg;

    if (value_sec != NULL) {
   16096:	4616      	mov	r6, r2
   16098:	8940      	ldrh	r0, [r0, #10]
   1609a:	b19a      	cbz	r2, 160c4 <ble_sm_ltk_restore_exec+0x34>
        /* Store provided a key; send it to the controller. */
        res->app_status = ble_sm_ltk_req_reply_tx(
   1609c:	f102 0118 	add.w	r1, r2, #24
   160a0:	f7ff ff9c 	bl	15fdc <ble_sm_ltk_req_reply_tx>
   160a4:	6020      	str	r0, [r4, #0]
            proc->conn_handle, value_sec->ltk);

        if (res->app_status == 0) {
   160a6:	b940      	cbnz	r0, 160ba <ble_sm_ltk_restore_exec+0x2a>
            if (value_sec->authenticated) {
   160a8:	f896 304a 	ldrb.w	r3, [r6, #74]	; 0x4a
   160ac:	079b      	lsls	r3, r3, #30
   160ae:	d50d      	bpl.n	160cc <ble_sm_ltk_restore_exec+0x3c>
                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
   160b0:	7a2b      	ldrb	r3, [r5, #8]
   160b2:	f043 0308 	orr.w	r3, r3, #8
   160b6:	722b      	strb	r3, [r5, #8]
   160b8:	e008      	b.n	160cc <ble_sm_ltk_restore_exec+0x3c>
            }
        } else {
            /* Notify the app if it provided a key and the procedure failed. */
            res->enc_cb = 1;
   160ba:	7d23      	ldrb	r3, [r4, #20]
   160bc:	f043 0302 	orr.w	r3, r3, #2
   160c0:	7523      	strb	r3, [r4, #20]
   160c2:	e003      	b.n	160cc <ble_sm_ltk_restore_exec+0x3c>
        }
    } else {
        /* Application does not have the requested key in its database.  Send a
         * negative reply to the controller.
         */
        ble_sm_ltk_req_neg_reply_tx(proc->conn_handle);
   160c4:	f7ff ffc7 	bl	16056 <ble_sm_ltk_req_neg_reply_tx>
        res->app_status = BLE_HS_ENOENT;
   160c8:	2305      	movs	r3, #5
   160ca:	6023      	str	r3, [r4, #0]
    }

    if (res->app_status == 0) {
   160cc:	6823      	ldr	r3, [r4, #0]
   160ce:	b90b      	cbnz	r3, 160d4 <ble_sm_ltk_restore_exec+0x44>
        proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
   160d0:	2306      	movs	r3, #6
   160d2:	736b      	strb	r3, [r5, #13]
   160d4:	bd70      	pop	{r4, r5, r6, pc}

000160d6 <ble_sm_random_exec>:

static void
ble_sm_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                   void *arg)
{
    if (proc->flags & BLE_SM_PROC_F_SC) {
   160d6:	7a03      	ldrb	r3, [r0, #8]
   160d8:	06db      	lsls	r3, r3, #27
   160da:	d401      	bmi.n	160e0 <ble_sm_random_exec+0xa>
        ble_sm_sc_random_exec(proc, res);
    } else {
        ble_sm_lgcy_random_exec(proc, res);
   160dc:	f002 b8b2 	b.w	18244 <ble_sm_lgcy_random_exec>
   160e0:	4770      	bx	lr

000160e2 <ble_sm_confirm_exec>:

static void
ble_sm_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                    void *arg)
{
    if (!(proc->flags & BLE_SM_PROC_F_SC)) {
   160e2:	7a03      	ldrb	r3, [r0, #8]
   160e4:	06db      	lsls	r3, r3, #27
   160e6:	d401      	bmi.n	160ec <ble_sm_confirm_exec+0xa>
        ble_sm_lgcy_confirm_exec(proc, res);
   160e8:	f002 b854 	b.w	18194 <ble_sm_lgcy_confirm_exec>
   160ec:	4770      	bx	lr
	...

000160f0 <ble_sm_proc_free>:
static void
ble_sm_proc_free(struct ble_sm_proc *proc)
{
    int rc;

    if (proc != NULL) {
   160f0:	4601      	mov	r1, r0
   160f2:	b110      	cbz	r0, 160fa <ble_sm_proc_free+0xa>
        ble_sm_dbg_assert_not_inserted(proc);

        rc = os_memblock_put(&ble_sm_proc_pool, proc);
   160f4:	4801      	ldr	r0, [pc, #4]	; (160fc <ble_sm_proc_free+0xc>)
   160f6:	f7f4 b993 	b.w	a420 <os_memblock_put>
   160fa:	4770      	bx	lr
   160fc:	20002280 	.word	0x20002280

00016100 <ble_sm_proc_alloc>:
 *
 * @return                      An entry on success; null on failure.
 */
static struct ble_sm_proc *
ble_sm_proc_alloc(void)
{
   16100:	b510      	push	{r4, lr}
    struct ble_sm_proc *proc;

    proc = os_memblock_get(&ble_sm_proc_pool);
   16102:	4806      	ldr	r0, [pc, #24]	; (1611c <ble_sm_proc_alloc+0x1c>)
   16104:	f7f4 f978 	bl	a3f8 <os_memblock_get>
    if (proc != NULL) {
   16108:	4604      	mov	r4, r0
   1610a:	b120      	cbz	r0, 16116 <ble_sm_proc_alloc+0x16>
        memset(proc, 0, sizeof *proc);
   1610c:	2100      	movs	r1, #0
   1610e:	f44f 7280 	mov.w	r2, #256	; 0x100
   16112:	f7f2 ff7e 	bl	9012 <memset>
    }

    return proc;
}
   16116:	4620      	mov	r0, r4
   16118:	bd10      	pop	{r4, pc}
   1611a:	bf00      	nop
   1611c:	20002280 	.word	0x20002280

00016120 <ble_sm_proc_remove.isra.1>:

static void
ble_sm_proc_remove(struct ble_sm_proc *proc,
                         struct ble_sm_proc *prev)
{
    if (prev == NULL) {
   16120:	b930      	cbnz	r0, 16130 <ble_sm_proc_remove.isra.1+0x10>
        BLE_HS_DBG_ASSERT(STAILQ_FIRST(&ble_sm_procs) == proc);
        STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
   16122:	4b07      	ldr	r3, [pc, #28]	; (16140 <ble_sm_proc_remove.isra.1+0x20>)
   16124:	681a      	ldr	r2, [r3, #0]
   16126:	6812      	ldr	r2, [r2, #0]
   16128:	601a      	str	r2, [r3, #0]
   1612a:	b93a      	cbnz	r2, 1613c <ble_sm_proc_remove.isra.1+0x1c>
   1612c:	605b      	str	r3, [r3, #4]
   1612e:	4770      	bx	lr
    } else {
        BLE_HS_DBG_ASSERT(STAILQ_NEXT(prev, next) == proc);
        STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
   16130:	6803      	ldr	r3, [r0, #0]
   16132:	681b      	ldr	r3, [r3, #0]
   16134:	6003      	str	r3, [r0, #0]
   16136:	b90b      	cbnz	r3, 1613c <ble_sm_proc_remove.isra.1+0x1c>
   16138:	4b01      	ldr	r3, [pc, #4]	; (16140 <ble_sm_proc_remove.isra.1+0x20>)
   1613a:	6058      	str	r0, [r3, #4]
   1613c:	4770      	bx	lr
   1613e:	bf00      	nop
   16140:	20002278 	.word	0x20002278

00016144 <ble_sm_fail_rx>:
 *****************************************************************************/

static void
ble_sm_fail_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
               struct ble_sm_result *res)
{
   16144:	b5f0      	push	{r4, r5, r6, r7, lr}
   16146:	461d      	mov	r5, r3
    struct ble_sm_pair_fail cmd;

    res->enc_cb = 1;
   16148:	7d1b      	ldrb	r3, [r3, #20]
   1614a:	f043 0302 	orr.w	r3, r3, #2
 *****************************************************************************/

static void
ble_sm_fail_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
               struct ble_sm_result *res)
{
   1614e:	b087      	sub	sp, #28
   16150:	4607      	mov	r7, r0
    struct ble_sm_pair_fail cmd;

    res->enc_cb = 1;
   16152:	752b      	strb	r3, [r5, #20]

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_FAIL_SZ);
   16154:	4610      	mov	r0, r2
   16156:	2101      	movs	r1, #1
 *****************************************************************************/

static void
ble_sm_fail_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
               struct ble_sm_result *res)
{
   16158:	4616      	mov	r6, r2
    struct ble_sm_pair_fail cmd;

    res->enc_cb = 1;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_FAIL_SZ);
   1615a:	f7ff f9ed 	bl	15538 <ble_hs_misc_pullup_base>
   1615e:	4604      	mov	r4, r0
   16160:	6028      	str	r0, [r5, #0]
    if (res->app_status == 0) {
   16162:	bb08      	cbnz	r0, 161a8 <ble_sm_fail_rx+0x64>
        ble_sm_pair_fail_parse((*om)->om_data, (*om)->om_len, &cmd);
   16164:	6833      	ldr	r3, [r6, #0]
   16166:	aa05      	add	r2, sp, #20
   16168:	6818      	ldr	r0, [r3, #0]
   1616a:	88d9      	ldrh	r1, [r3, #6]
   1616c:	f001 fd08 	bl	17b80 <ble_sm_pair_fail_parse>
        BLE_SM_LOG_CMD(0, "fail", conn_handle, ble_sm_pair_fail_log, &cmd);
   16170:	4b0e      	ldr	r3, [pc, #56]	; (161ac <ble_sm_fail_rx+0x68>)
   16172:	9300      	str	r3, [sp, #0]
   16174:	4b0e      	ldr	r3, [pc, #56]	; (161b0 <ble_sm_fail_rx+0x6c>)
   16176:	9301      	str	r3, [sp, #4]
   16178:	4b0e      	ldr	r3, [pc, #56]	; (161b4 <ble_sm_fail_rx+0x70>)
   1617a:	9302      	str	r3, [sp, #8]
   1617c:	2104      	movs	r1, #4
   1617e:	4622      	mov	r2, r4
   16180:	4b0d      	ldr	r3, [pc, #52]	; (161b8 <ble_sm_fail_rx+0x74>)
   16182:	480e      	ldr	r0, [pc, #56]	; (161bc <ble_sm_fail_rx+0x78>)
   16184:	9703      	str	r7, [sp, #12]
   16186:	f007 f84f 	bl	1d228 <log_printf>
   1618a:	a805      	add	r0, sp, #20
   1618c:	f001 fcfc 	bl	17b88 <ble_sm_pair_fail_log>
   16190:	4b0b      	ldr	r3, [pc, #44]	; (161c0 <ble_sm_fail_rx+0x7c>)
   16192:	480a      	ldr	r0, [pc, #40]	; (161bc <ble_sm_fail_rx+0x78>)
   16194:	2104      	movs	r1, #4
   16196:	4622      	mov	r2, r4
   16198:	f007 f846 	bl	1d228 <log_printf>

        res->app_status = BLE_HS_SM_PEER_ERR(cmd.reason);
   1619c:	f89d 3014 	ldrb.w	r3, [sp, #20]
   161a0:	b10b      	cbz	r3, 161a6 <ble_sm_fail_rx+0x62>
   161a2:	f503 64a0 	add.w	r4, r3, #1280	; 0x500
   161a6:	602c      	str	r4, [r5, #0]
    }
}
   161a8:	b007      	add	sp, #28
   161aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   161ac:	0001fbda 	.word	0x0001fbda
   161b0:	0001fbdd 	.word	0x0001fbdd
   161b4:	0001fbe0 	.word	0x0001fbe0
   161b8:	0001fbbc 	.word	0x0001fbbc
   161bc:	20003b9c 	.word	0x20003b9c
   161c0:	0001fdec 	.word	0x0001fdec

000161c4 <ble_sm_key_exch_exec>:
}

static void
ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                     void *arg)
{
   161c4:	b5f0      	push	{r4, r5, r6, r7, lr}
{
    *out_init_key_dist = proc->pair_rsp.init_key_dist;
    *out_resp_key_dist = proc->pair_rsp.resp_key_dist;

    /* Encryption info and master ID are only sent in legacy pairing. */
    if (proc->flags & BLE_SM_PROC_F_SC) {
   161c6:	7a02      	ldrb	r2, [r0, #8]

static void
ble_sm_key_dist(struct ble_sm_proc *proc,
                uint8_t *out_init_key_dist, uint8_t *out_resp_key_dist)
{
    *out_init_key_dist = proc->pair_rsp.init_key_dist;
   161c8:	7e46      	ldrb	r6, [r0, #25]
    *out_resp_key_dist = proc->pair_rsp.resp_key_dist;
   161ca:	7e83      	ldrb	r3, [r0, #26]

    /* Encryption info and master ID are only sent in legacy pairing. */
    if (proc->flags & BLE_SM_PROC_F_SC) {
   161cc:	06d7      	lsls	r7, r2, #27
        *out_init_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
   161ce:	bf44      	itt	mi
   161d0:	f006 06fe 	andmi.w	r6, r6, #254	; 0xfe
        *out_resp_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
   161d4:	f003 03fe 	andmi.w	r3, r3, #254	; 0xfe

    ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
        our_key_dist = init_key_dist;
    } else {
        our_key_dist = resp_key_dist;
   161d8:	f012 0f01 	tst.w	r2, #1
   161dc:	bf08      	it	eq
   161de:	461e      	moveq	r6, r3
}

static void
ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                     void *arg)
{
   161e0:	4604      	mov	r4, r0
        our_key_dist = init_key_dist;
    } else {
        our_key_dist = resp_key_dist;
    }

    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
   161e2:	07f0      	lsls	r0, r6, #31
}

static void
ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                     void *arg)
{
   161e4:	b09b      	sub	sp, #108	; 0x6c
   161e6:	460d      	mov	r5, r1
        our_key_dist = init_key_dist;
    } else {
        our_key_dist = resp_key_dist;
    }

    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
   161e8:	d544      	bpl.n	16274 <ble_sm_key_exch_exec+0xb0>
               sizeof ble_sm_dbg_next_ltk);
        return 0;
    }
#endif

    rc = ble_hci_util_rand(ltk, 16);
   161ea:	a80d      	add	r0, sp, #52	; 0x34
   161ec:	2110      	movs	r1, #16
   161ee:	f7fe fa54 	bl	1469a <ble_hci_util_rand>
    if (rc != 0) {
   161f2:	2800      	cmp	r0, #0
   161f4:	f040 80c9 	bne.w	1638a <ble_sm_key_exch_exec+0x1c6>
        /* Send encryption information. */
        rc = ble_sm_gen_ltk(proc, enc_info.ltk);
        if (rc != 0) {
            goto err;
        }
        rc = ble_sm_enc_info_tx(proc->conn_handle, &enc_info);
   161f8:	8960      	ldrh	r0, [r4, #10]
   161fa:	a90d      	add	r1, sp, #52	; 0x34
   161fc:	f001 fd40 	bl	17c80 <ble_sm_enc_info_tx>
        if (rc != 0) {
   16200:	2800      	cmp	r0, #0
   16202:	f040 80c2 	bne.w	1638a <ble_sm_key_exch_exec+0x1c6>
            goto err;
        }
        proc->our_keys.ltk_valid = 1;
   16206:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   1620a:	f043 0301 	orr.w	r3, r3, #1
   1620e:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
        memcpy(proc->our_keys.ltk, enc_info.ltk, 16);
   16212:	af0d      	add	r7, sp, #52	; 0x34
   16214:	f104 0281 	add.w	r2, r4, #129	; 0x81
   16218:	f10d 0e44 	add.w	lr, sp, #68	; 0x44
   1621c:	463b      	mov	r3, r7
   1621e:	cb03      	ldmia	r3!, {r0, r1}
   16220:	4573      	cmp	r3, lr
   16222:	6010      	str	r0, [r2, #0]
   16224:	6051      	str	r1, [r2, #4]
   16226:	461f      	mov	r7, r3
   16228:	f102 0208 	add.w	r2, r2, #8
   1622c:	d1f6      	bne.n	1621c <ble_sm_key_exch_exec+0x58>
        *ediv = ble_sm_dbg_next_ediv;
        return 0;
    }
#endif

    rc = ble_hci_util_rand(ediv, sizeof *ediv);
   1622e:	a804      	add	r0, sp, #16
   16230:	2102      	movs	r1, #2
   16232:	f7fe fa32 	bl	1469a <ble_hci_util_rand>
    if (rc != 0) {
   16236:	2800      	cmp	r0, #0
   16238:	f040 80a7 	bne.w	1638a <ble_sm_key_exch_exec+0x1c6>
        *master_id_rand = ble_sm_dbg_next_master_id_rand;
        return 0;
    }
#endif

    rc = ble_hci_util_rand(master_id_rand, sizeof *master_id_rand);
   1623c:	a806      	add	r0, sp, #24
   1623e:	2108      	movs	r1, #8
   16240:	f7fe fa2b 	bl	1469a <ble_hci_util_rand>
    if (rc != 0) {
   16244:	2800      	cmp	r0, #0
   16246:	f040 80a0 	bne.w	1638a <ble_sm_key_exch_exec+0x1c6>
        }
        rc = ble_sm_gen_master_id_rand(&master_id.rand_val);
        if (rc != 0) {
            goto err;
        }
        rc = ble_sm_master_id_tx(proc->conn_handle, &master_id);
   1624a:	8960      	ldrh	r0, [r4, #10]
   1624c:	a904      	add	r1, sp, #16
   1624e:	f001 fd81 	bl	17d54 <ble_sm_master_id_tx>
        if (rc != 0) {
   16252:	2800      	cmp	r0, #0
   16254:	f040 8099 	bne.w	1638a <ble_sm_key_exch_exec+0x1c6>
            goto err;
        }
        proc->our_keys.ediv_rand_valid = 1;
   16258:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   1625c:	f043 0302 	orr.w	r3, r3, #2
   16260:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
        proc->our_keys.rand_val = master_id.rand_val;
   16264:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   16268:	e9c4 231e 	strd	r2, r3, [r4, #120]	; 0x78
        proc->our_keys.ediv = master_id.ediv;
   1626c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   16270:	f8a4 3072 	strh.w	r3, [r4, #114]	; 0x72
    }

    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
   16274:	07b1      	lsls	r1, r6, #30
   16276:	d554      	bpl.n	16322 <ble_sm_key_exch_exec+0x15e>
        /* Send identity information. */
        rc = ble_hs_pvcy_our_irk(&irk);
   16278:	a801      	add	r0, sp, #4
   1627a:	f7ff fa47 	bl	1570c <ble_hs_pvcy_our_irk>
        if (rc != 0) {
   1627e:	2800      	cmp	r0, #0
   16280:	f040 8083 	bne.w	1638a <ble_sm_key_exch_exec+0x1c6>
            goto err;
        }

        memcpy(id_info.irk, irk, 16);
   16284:	9b01      	ldr	r3, [sp, #4]
   16286:	aa11      	add	r2, sp, #68	; 0x44
   16288:	f103 0c10 	add.w	ip, r3, #16
   1628c:	4696      	mov	lr, r2
   1628e:	6818      	ldr	r0, [r3, #0]
   16290:	6859      	ldr	r1, [r3, #4]
   16292:	4617      	mov	r7, r2
   16294:	c703      	stmia	r7!, {r0, r1}
   16296:	3308      	adds	r3, #8
   16298:	4563      	cmp	r3, ip
   1629a:	463a      	mov	r2, r7
   1629c:	d1f7      	bne.n	1628e <ble_sm_key_exch_exec+0xca>

        rc = ble_sm_id_info_tx(proc->conn_handle, &id_info);
   1629e:	8960      	ldrh	r0, [r4, #10]
   162a0:	4671      	mov	r1, lr
   162a2:	f001 fdcb 	bl	17e3c <ble_sm_id_info_tx>
        if (rc != 0) {
   162a6:	2800      	cmp	r0, #0
   162a8:	d16f      	bne.n	1638a <ble_sm_key_exch_exec+0x1c6>
            goto err;
        }
        proc->our_keys.irk_valid = 1;
   162aa:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70

        /* Send identity address information. */
        conn = ble_hs_conn_find(proc->conn_handle);
   162ae:	8960      	ldrh	r0, [r4, #10]

        rc = ble_sm_id_info_tx(proc->conn_handle, &id_info);
        if (rc != 0) {
            goto err;
        }
        proc->our_keys.irk_valid = 1;
   162b0:	f043 0304 	orr.w	r3, r3, #4
   162b4:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70

        /* Send identity address information. */
        conn = ble_hs_conn_find(proc->conn_handle);
   162b8:	f7fe ffec 	bl	15294 <ble_hs_conn_find>
        if (conn == NULL) {
   162bc:	2800      	cmp	r0, #0
   162be:	d063      	beq.n	16388 <ble_sm_key_exch_exec+0x1c4>
            rc = BLE_HS_ENOTCONN;
            goto err;
        }

        ble_hs_conn_addrs(conn, &addrs);
   162c0:	a915      	add	r1, sp, #84	; 0x54
   162c2:	f7ff f829 	bl	15318 <ble_hs_conn_addrs>
        addr_info.addr_type = addrs.our_id_addr_type;
   162c6:	f89d 3055 	ldrb.w	r3, [sp, #85]	; 0x55
   162ca:	f88d 3008 	strb.w	r3, [sp, #8]
        memcpy(addr_info.bd_addr, addrs.our_id_addr, 6);
   162ce:	9b17      	ldr	r3, [sp, #92]	; 0x5c
        rc = ble_sm_id_addr_info_tx(proc->conn_handle, &addr_info);
   162d0:	8960      	ldrh	r0, [r4, #10]
            goto err;
        }

        ble_hs_conn_addrs(conn, &addrs);
        addr_info.addr_type = addrs.our_id_addr_type;
        memcpy(addr_info.bd_addr, addrs.our_id_addr, 6);
   162d2:	681a      	ldr	r2, [r3, #0]
   162d4:	f8cd 2009 	str.w	r2, [sp, #9]
   162d8:	889b      	ldrh	r3, [r3, #4]
   162da:	f8ad 300d 	strh.w	r3, [sp, #13]
        rc = ble_sm_id_addr_info_tx(proc->conn_handle, &addr_info);
   162de:	a902      	add	r1, sp, #8
   162e0:	f001 fe28 	bl	17f34 <ble_sm_id_addr_info_tx>
        if (rc != 0) {
   162e4:	2800      	cmp	r0, #0
   162e6:	d150      	bne.n	1638a <ble_sm_key_exch_exec+0x1c6>
            goto err;
        }

        proc->our_keys.addr_valid = 1;
   162e8:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   162ec:	f043 0310 	orr.w	r3, r3, #16
   162f0:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
        memcpy(proc->our_keys.irk, irk, 16);
   162f4:	9b01      	ldr	r3, [sp, #4]
   162f6:	f104 0291 	add.w	r2, r4, #145	; 0x91
   162fa:	f103 0110 	add.w	r1, r3, #16
   162fe:	f853 0b04 	ldr.w	r0, [r3], #4
   16302:	f842 0b04 	str.w	r0, [r2], #4
   16306:	428b      	cmp	r3, r1
   16308:	d1f9      	bne.n	162fe <ble_sm_key_exch_exec+0x13a>
        proc->our_keys.addr_type = addr_info.addr_type;
   1630a:	f89d 3008 	ldrb.w	r3, [sp, #8]
   1630e:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
        memcpy(proc->our_keys.addr, addr_info.bd_addr, 6);
   16312:	f8dd 3009 	ldr.w	r3, [sp, #9]
   16316:	f8c4 30b1 	str.w	r3, [r4, #177]	; 0xb1
   1631a:	f8bd 300d 	ldrh.w	r3, [sp, #13]
   1631e:	f8a4 30b5 	strh.w	r3, [r4, #181]	; 0xb5
    }

    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
   16322:	0772      	lsls	r2, r6, #29
   16324:	d51c      	bpl.n	16360 <ble_sm_key_exch_exec+0x19c>
               sizeof ble_sm_dbg_next_csrk);
        return 0;
    }
#endif

    rc = ble_hci_util_rand(csrk, 16);
   16326:	a809      	add	r0, sp, #36	; 0x24
   16328:	2110      	movs	r1, #16
   1632a:	f7fe f9b6 	bl	1469a <ble_hci_util_rand>
    if (rc != 0) {
   1632e:	bb60      	cbnz	r0, 1638a <ble_sm_key_exch_exec+0x1c6>
        /* Send signing information. */
        rc = ble_sm_gen_csrk(proc, sign_info.sig_key);
        if (rc != 0) {
            goto err;
        }
        rc = ble_sm_sign_info_tx(proc->conn_handle, &sign_info);
   16330:	8960      	ldrh	r0, [r4, #10]
   16332:	a909      	add	r1, sp, #36	; 0x24
   16334:	f001 fe66 	bl	18004 <ble_sm_sign_info_tx>
        if (rc != 0) {
   16338:	bb38      	cbnz	r0, 1638a <ble_sm_key_exch_exec+0x1c6>
            goto err;
        }
        proc->our_keys.csrk_valid = 1;
   1633a:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   1633e:	f043 0308 	orr.w	r3, r3, #8
   16342:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
        memcpy(proc->our_keys.csrk, sign_info.sig_key, 16);
   16346:	ae09      	add	r6, sp, #36	; 0x24
   16348:	f104 02a1 	add.w	r2, r4, #161	; 0xa1
   1634c:	af0d      	add	r7, sp, #52	; 0x34
   1634e:	4633      	mov	r3, r6
   16350:	cb03      	ldmia	r3!, {r0, r1}
   16352:	42bb      	cmp	r3, r7
   16354:	6010      	str	r0, [r2, #0]
   16356:	6051      	str	r1, [r2, #4]
   16358:	461e      	mov	r6, r3
   1635a:	f102 0208 	add.w	r2, r2, #8
   1635e:	d1f6      	bne.n	1634e <ble_sm_key_exch_exec+0x18a>
    }

    if (proc->flags & BLE_SM_PROC_F_INITIATOR || proc->rx_key_flags == 0) {
   16360:	7a23      	ldrb	r3, [r4, #8]
   16362:	07db      	lsls	r3, r3, #31
   16364:	d401      	bmi.n	1636a <ble_sm_key_exch_exec+0x1a6>
   16366:	7ba3      	ldrb	r3, [r4, #14]
   16368:	b9b3      	cbnz	r3, 16398 <ble_sm_key_exch_exec+0x1d4>
ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
                        int authenticated, int bonded)
{
    struct ble_hs_conn *conn;

    conn = ble_hs_conn_find(conn_handle);
   1636a:	8960      	ldrh	r0, [r4, #10]
   1636c:	f7fe ff92 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   16370:	b128      	cbz	r0, 1637e <ble_sm_key_exch_exec+0x1ba>
        conn->bhc_sec_state.encrypted = encrypted;
   16372:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
        /* Authentication and bonding are never revoked from a secure link */
        if (authenticated) {
            conn->bhc_sec_state.authenticated = 1;
        }
        if (bonded) {
            conn->bhc_sec_state.bonded = 1;
   16376:	f043 0305 	orr.w	r3, r3, #5
   1637a:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
{
    /* The procedure is now complete.  Update connection bonded state and
     * terminate procedure.
     */
    ble_sm_update_sec_state(proc->conn_handle, 1, 0, 1);
    proc->state = BLE_SM_PROC_STATE_NONE;
   1637e:	23ff      	movs	r3, #255	; 0xff
   16380:	7363      	strb	r3, [r4, #13]

    res->app_status = 0;
   16382:	2300      	movs	r3, #0
   16384:	602b      	str	r3, [r5, #0]
   16386:	e003      	b.n	16390 <ble_sm_key_exch_exec+0x1cc>
        proc->our_keys.irk_valid = 1;

        /* Send identity address information. */
        conn = ble_hs_conn_find(proc->conn_handle);
        if (conn == NULL) {
            rc = BLE_HS_ENOTCONN;
   16388:	2007      	movs	r0, #7

    return;

err:
    res->app_status = rc;
    res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1638a:	2308      	movs	r3, #8
    }

    return;

err:
    res->app_status = rc;
   1638c:	6028      	str	r0, [r5, #0]
    res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1638e:	712b      	strb	r3, [r5, #4]
    res->enc_cb = 1;
   16390:	7d2b      	ldrb	r3, [r5, #20]
   16392:	f043 0302 	orr.w	r3, r3, #2
   16396:	752b      	strb	r3, [r5, #20]
}
   16398:	b01b      	add	sp, #108	; 0x6c
   1639a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001639c <ble_sm_enc_restore_exec>:
}

static void
ble_sm_enc_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                        void *arg)
{
   1639c:	b510      	push	{r4, lr}
   1639e:	b088      	sub	sp, #32
   163a0:	460c      	mov	r4, r1
ble_sm_start_encrypt_tx(struct hci_start_encrypt *cmd)
{
    uint8_t buf[BLE_HCI_CMD_HDR_LEN + BLE_HCI_LE_START_ENCRYPT_LEN];
    int rc;

    host_hci_cmd_build_le_start_encrypt(cmd, buf, sizeof buf);
   163a2:	4610      	mov	r0, r2
   163a4:	4669      	mov	r1, sp
   163a6:	221f      	movs	r2, #31
   163a8:	f003 fa78 	bl	1989c <host_hci_cmd_build_le_start_encrypt>
    rc = ble_hci_cmd_tx_empty_ack(buf);
   163ac:	4668      	mov	r0, sp
   163ae:	f7fe f93b 	bl	14628 <ble_hci_cmd_tx_empty_ack>
    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);

    cmd = arg;
    BLE_HS_DBG_ASSERT(cmd != NULL);

    res->app_status = ble_sm_start_encrypt_tx(cmd);
   163b2:	6020      	str	r0, [r4, #0]
}
   163b4:	b008      	add	sp, #32
   163b6:	bd10      	pop	{r4, pc}

000163b8 <ble_sm_pair_cfg>:
{
    uint8_t init_key_dist;
    uint8_t resp_key_dist;
    uint8_t rx_key_dist;

    if (proc->pair_req.authreq & BLE_SM_PAIR_AUTHREQ_SC &&
   163b8:	7c42      	ldrb	r2, [r0, #17]
   163ba:	0713      	lsls	r3, r2, #28
   163bc:	d506      	bpl.n	163cc <ble_sm_pair_cfg+0x14>
        proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_SC) {
   163be:	7dc3      	ldrb	r3, [r0, #23]
{
    uint8_t init_key_dist;
    uint8_t resp_key_dist;
    uint8_t rx_key_dist;

    if (proc->pair_req.authreq & BLE_SM_PAIR_AUTHREQ_SC &&
   163c0:	0719      	lsls	r1, r3, #28
        proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_SC) {

        proc->flags |= BLE_SM_PROC_F_SC;
   163c2:	bf42      	ittt	mi
   163c4:	7a03      	ldrbmi	r3, [r0, #8]
   163c6:	f043 0310 	orrmi.w	r3, r3, #16
   163ca:	7203      	strbmi	r3, [r0, #8]
    }

    if (proc->pair_req.authreq & BLE_SM_PAIR_AUTHREQ_BOND &&
   163cc:	07d2      	lsls	r2, r2, #31
   163ce:	d506      	bpl.n	163de <ble_sm_pair_cfg+0x26>
        proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
   163d0:	7dc3      	ldrb	r3, [r0, #23]
        proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_SC) {

        proc->flags |= BLE_SM_PROC_F_SC;
    }

    if (proc->pair_req.authreq & BLE_SM_PAIR_AUTHREQ_BOND &&
   163d2:	07db      	lsls	r3, r3, #31
        proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_BOND) {

        proc->flags |= BLE_SM_PROC_F_BONDING;
   163d4:	bf42      	ittt	mi
   163d6:	7a03      	ldrbmi	r3, [r0, #8]
   163d8:	f043 0320 	orrmi.w	r3, r3, #32
   163dc:	7203      	strbmi	r3, [r0, #8]
{
    *out_init_key_dist = proc->pair_rsp.init_key_dist;
    *out_resp_key_dist = proc->pair_rsp.resp_key_dist;

    /* Encryption info and master ID are only sent in legacy pairing. */
    if (proc->flags & BLE_SM_PROC_F_SC) {
   163de:	7a01      	ldrb	r1, [r0, #8]
static void
ble_sm_key_dist(struct ble_sm_proc *proc,
                uint8_t *out_init_key_dist, uint8_t *out_resp_key_dist)
{
    *out_init_key_dist = proc->pair_rsp.init_key_dist;
    *out_resp_key_dist = proc->pair_rsp.resp_key_dist;
   163e0:	7e83      	ldrb	r3, [r0, #26]

static void
ble_sm_key_dist(struct ble_sm_proc *proc,
                uint8_t *out_init_key_dist, uint8_t *out_resp_key_dist)
{
    *out_init_key_dist = proc->pair_rsp.init_key_dist;
   163e2:	7e42      	ldrb	r2, [r0, #25]
    *out_resp_key_dist = proc->pair_rsp.resp_key_dist;

    /* Encryption info and master ID are only sent in legacy pairing. */
    if (proc->flags & BLE_SM_PROC_F_SC) {
   163e4:	f011 0f10 	tst.w	r1, #16
        *out_init_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
        *out_resp_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
   163e8:	bf1c      	itt	ne
   163ea:	f003 03fe 	andne.w	r3, r3, #254	; 0xfe
    *out_init_key_dist = proc->pair_rsp.init_key_dist;
    *out_resp_key_dist = proc->pair_rsp.resp_key_dist;

    /* Encryption info and master ID are only sent in legacy pairing. */
    if (proc->flags & BLE_SM_PROC_F_SC) {
        *out_init_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
   163ee:	f002 02fe 	andne.w	r2, r2, #254	; 0xfe

    ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
        rx_key_dist = resp_key_dist;
    } else {
        rx_key_dist = init_key_dist;
   163f2:	f011 0f01 	tst.w	r1, #1
   163f6:	bf08      	it	eq
   163f8:	4613      	moveq	r3, r2
    }

    proc->rx_key_flags = 0;
    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
   163fa:	f013 0201 	ands.w	r2, r3, #1
        proc->rx_key_flags |= BLE_SM_KE_F_ENC_INFO |
   163fe:	bf18      	it	ne
   16400:	2203      	movne	r2, #3
   16402:	7382      	strb	r2, [r0, #14]
                              BLE_SM_KE_F_MASTER_ID;
    }
    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
   16404:	079a      	lsls	r2, r3, #30
        proc->rx_key_flags |= BLE_SM_KE_F_ID_INFO |
   16406:	bf42      	ittt	mi
   16408:	7b82      	ldrbmi	r2, [r0, #14]
   1640a:	f042 020c 	orrmi.w	r2, r2, #12
   1640e:	7382      	strbmi	r2, [r0, #14]
                              BLE_SM_KE_F_ADDR_INFO;
    }
    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
   16410:	075b      	lsls	r3, r3, #29
        proc->rx_key_flags |= BLE_SM_KE_F_SIGN_INFO;
   16412:	bf42      	ittt	mi
   16414:	7b83      	ldrbmi	r3, [r0, #14]
   16416:	f043 0310 	orrmi.w	r3, r3, #16
   1641a:	7383      	strbmi	r3, [r0, #14]
   1641c:	4770      	bx	lr
	...

00016420 <ble_sm_key_rxed>:
    res->enc_cb = 1;
}

static void
ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   16420:	b537      	push	{r0, r1, r2, r4, r5, lr}
   16422:	4605      	mov	r5, r0
    BLE_HS_LOG(DEBUG, "rx_key_flags=0x%02x\n", proc->rx_key_flags);
   16424:	7b83      	ldrb	r3, [r0, #14]
   16426:	9300      	str	r3, [sp, #0]
    res->enc_cb = 1;
}

static void
ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   16428:	460c      	mov	r4, r1
    BLE_HS_LOG(DEBUG, "rx_key_flags=0x%02x\n", proc->rx_key_flags);
   1642a:	4b11      	ldr	r3, [pc, #68]	; (16470 <ble_sm_key_rxed+0x50>)
   1642c:	4811      	ldr	r0, [pc, #68]	; (16474 <ble_sm_key_rxed+0x54>)
   1642e:	2104      	movs	r1, #4
   16430:	2200      	movs	r2, #0
   16432:	f006 fef9 	bl	1d228 <log_printf>

    if (proc->rx_key_flags == 0) {
   16436:	7bab      	ldrb	r3, [r5, #14]
   16438:	b9c3      	cbnz	r3, 1646c <ble_sm_key_rxed+0x4c>
        /* The peer is done sending keys.  If we are the initiator, we need to
         * send ours.  If we are the responder, the procedure is complete.
         */
        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
   1643a:	7a2b      	ldrb	r3, [r5, #8]
   1643c:	07db      	lsls	r3, r3, #31
   1643e:	d503      	bpl.n	16448 <ble_sm_key_rxed+0x28>
            res->execute = 1;
   16440:	7d23      	ldrb	r3, [r4, #20]
   16442:	f043 0301 	orr.w	r3, r3, #1
   16446:	e010      	b.n	1646a <ble_sm_key_rxed+0x4a>
ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
                        int authenticated, int bonded)
{
    struct ble_hs_conn *conn;

    conn = ble_hs_conn_find(conn_handle);
   16448:	8968      	ldrh	r0, [r5, #10]
   1644a:	f7fe ff23 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   1644e:	b128      	cbz	r0, 1645c <ble_sm_key_rxed+0x3c>
        conn->bhc_sec_state.encrypted = encrypted;
   16450:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
        /* Authentication and bonding are never revoked from a secure link */
        if (authenticated) {
            conn->bhc_sec_state.authenticated = 1;
        }
        if (bonded) {
            conn->bhc_sec_state.bonded = 1;
   16454:	f043 0305 	orr.w	r3, r3, #5
   16458:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
{
    /* The procedure is now complete.  Update connection bonded state and
     * terminate procedure.
     */
    ble_sm_update_sec_state(proc->conn_handle, 1, 0, 1);
    proc->state = BLE_SM_PROC_STATE_NONE;
   1645c:	23ff      	movs	r3, #255	; 0xff
   1645e:	736b      	strb	r3, [r5, #13]

    res->app_status = 0;
   16460:	2300      	movs	r3, #0
   16462:	6023      	str	r3, [r4, #0]
    res->enc_cb = 1;
   16464:	7d23      	ldrb	r3, [r4, #20]
   16466:	f043 0302 	orr.w	r3, r3, #2
   1646a:	7523      	strb	r3, [r4, #20]
            res->execute = 1;
        } else {
            ble_sm_key_exch_success(proc, res);
        }
    }
}
   1646c:	b003      	add	sp, #12
   1646e:	bd30      	pop	{r4, r5, pc}
   16470:	0001fbe5 	.word	0x0001fbe5
   16474:	20003b9c 	.word	0x20003b9c

00016478 <ble_sm_gen_pair_rand>:
               sizeof ble_sm_dbg_next_pair_rand);
        return 0;
    }
#endif

    rc = ble_hci_util_rand(pair_rand, 16);
   16478:	2110      	movs	r1, #16
   1647a:	f7fe b90e 	b.w	1469a <ble_hci_util_rand>

0001647e <ble_sm_ia_ra>:

int
ble_sm_ia_ra(struct ble_sm_proc *proc,
             uint8_t *out_iat, uint8_t *out_ia,
             uint8_t *out_rat, uint8_t *out_ra)
{
   1647e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16482:	b086      	sub	sp, #24
   16484:	4680      	mov	r8, r0
    struct ble_hs_conn_addrs addrs;
    struct ble_hs_conn *conn;

    conn = ble_hs_conn_find(proc->conn_handle);
   16486:	8940      	ldrh	r0, [r0, #10]

int
ble_sm_ia_ra(struct ble_sm_proc *proc,
             uint8_t *out_iat, uint8_t *out_ia,
             uint8_t *out_rat, uint8_t *out_ra)
{
   16488:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   1648a:	460f      	mov	r7, r1
   1648c:	4615      	mov	r5, r2
   1648e:	461e      	mov	r6, r3
    struct ble_hs_conn_addrs addrs;
    struct ble_hs_conn *conn;

    conn = ble_hs_conn_find(proc->conn_handle);
   16490:	f7fe ff00 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   16494:	b330      	cbz	r0, 164e4 <ble_sm_ia_ra+0x66>
        return BLE_HS_ENOTCONN;
    }

    ble_hs_conn_addrs(conn, &addrs);
   16496:	a901      	add	r1, sp, #4
   16498:	f7fe ff3e 	bl	15318 <ble_hs_conn_addrs>

    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
   1649c:	f898 0008 	ldrb.w	r0, [r8, #8]
   164a0:	f89d 1005 	ldrb.w	r1, [sp, #5]
   164a4:	9b02      	ldr	r3, [sp, #8]
   164a6:	f89d e007 	ldrb.w	lr, [sp, #7]
   164aa:	9a04      	ldr	r2, [sp, #16]
   164ac:	f010 0001 	ands.w	r0, r0, #1
   164b0:	d00c      	beq.n	164cc <ble_sm_ia_ra+0x4e>
        *out_iat = addrs.our_id_addr_type;
   164b2:	7039      	strb	r1, [r7, #0]
        memcpy(out_ia, addrs.our_ota_addr, 6);
   164b4:	6819      	ldr	r1, [r3, #0]
   164b6:	6029      	str	r1, [r5, #0]
   164b8:	889b      	ldrh	r3, [r3, #4]
   164ba:	80ab      	strh	r3, [r5, #4]

        *out_rat = addrs.peer_id_addr_type;
   164bc:	f886 e000 	strb.w	lr, [r6]
        memcpy(out_ra, addrs.peer_ota_addr, 6);
   164c0:	6813      	ldr	r3, [r2, #0]
   164c2:	6023      	str	r3, [r4, #0]
   164c4:	8893      	ldrh	r3, [r2, #4]
   164c6:	80a3      	strh	r3, [r4, #4]

        *out_rat = addrs.our_id_addr_type;
        memcpy(out_ra, addrs.our_ota_addr, 6);
    }

    return 0;
   164c8:	2000      	movs	r0, #0
   164ca:	e00c      	b.n	164e6 <ble_sm_ia_ra+0x68>
        memcpy(out_ia, addrs.our_ota_addr, 6);

        *out_rat = addrs.peer_id_addr_type;
        memcpy(out_ra, addrs.peer_ota_addr, 6);
    } else {
        *out_iat = addrs.peer_id_addr_type;
   164cc:	f887 e000 	strb.w	lr, [r7]
        memcpy(out_ia, addrs.peer_ota_addr, 6);
   164d0:	6817      	ldr	r7, [r2, #0]
   164d2:	602f      	str	r7, [r5, #0]
   164d4:	8892      	ldrh	r2, [r2, #4]
   164d6:	80aa      	strh	r2, [r5, #4]

        *out_rat = addrs.our_id_addr_type;
   164d8:	7031      	strb	r1, [r6, #0]
        memcpy(out_ra, addrs.our_ota_addr, 6);
   164da:	681a      	ldr	r2, [r3, #0]
   164dc:	6022      	str	r2, [r4, #0]
   164de:	889b      	ldrh	r3, [r3, #4]
   164e0:	80a3      	strh	r3, [r4, #4]
   164e2:	e000      	b.n	164e6 <ble_sm_ia_ra+0x68>
    struct ble_hs_conn_addrs addrs;
    struct ble_hs_conn *conn;

    conn = ble_hs_conn_find(proc->conn_handle);
    if (conn == NULL) {
        return BLE_HS_ENOTCONN;
   164e4:	2007      	movs	r0, #7
        *out_rat = addrs.our_id_addr_type;
        memcpy(out_ra, addrs.our_ota_addr, 6);
    }

    return 0;
}
   164e6:	b006      	add	sp, #24
   164e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000164ec <ble_sm_proc_find>:
 *                                  null on failure.
 */
struct ble_sm_proc *
ble_sm_proc_find(uint16_t conn_handle, uint8_t state, int is_initiator,
                 struct ble_sm_proc **out_prev)
{
   164ec:	b570      	push	{r4, r5, r6, lr}
   164ee:	4606      	mov	r6, r0
    struct ble_sm_proc *prev;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
   164f0:	480d      	ldr	r0, [pc, #52]	; (16528 <ble_sm_proc_find+0x3c>)
   164f2:	6800      	ldr	r0, [r0, #0]
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    prev = NULL;
   164f4:	2500      	movs	r5, #0
    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
   164f6:	b190      	cbz	r0, 1651e <ble_sm_proc_find+0x32>
ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
                    uint8_t state, int is_initiator)
{
    int proc_is_initiator;

    if (conn_handle != proc->conn_handle) {
   164f8:	8944      	ldrh	r4, [r0, #10]
   164fa:	42b4      	cmp	r4, r6
   164fc:	d10c      	bne.n	16518 <ble_sm_proc_find+0x2c>
        return 0;
    }

    if (state != BLE_SM_PROC_STATE_NONE && state != proc->state) {
   164fe:	29ff      	cmp	r1, #255	; 0xff
   16500:	d002      	beq.n	16508 <ble_sm_proc_find+0x1c>
   16502:	7b44      	ldrb	r4, [r0, #13]
   16504:	428c      	cmp	r4, r1
   16506:	d107      	bne.n	16518 <ble_sm_proc_find+0x2c>
        return 0;
    }

    proc_is_initiator = !!(proc->flags & BLE_SM_PROC_F_INITIATOR);
    if (is_initiator != -1 && is_initiator != proc_is_initiator) {
   16508:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff

    if (state != BLE_SM_PROC_STATE_NONE && state != proc->state) {
        return 0;
    }

    proc_is_initiator = !!(proc->flags & BLE_SM_PROC_F_INITIATOR);
   1650c:	7a04      	ldrb	r4, [r0, #8]
    if (is_initiator != -1 && is_initiator != proc_is_initiator) {
   1650e:	d007      	beq.n	16520 <ble_sm_proc_find+0x34>

    if (state != BLE_SM_PROC_STATE_NONE && state != proc->state) {
        return 0;
    }

    proc_is_initiator = !!(proc->flags & BLE_SM_PROC_F_INITIATOR);
   16510:	f004 0401 	and.w	r4, r4, #1
    if (is_initiator != -1 && is_initiator != proc_is_initiator) {
   16514:	42a2      	cmp	r2, r4
   16516:	d003      	beq.n	16520 <ble_sm_proc_find+0x34>
    struct ble_sm_proc *prev;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    prev = NULL;
    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
   16518:	4605      	mov	r5, r0
   1651a:	6800      	ldr	r0, [r0, #0]
   1651c:	e7eb      	b.n	164f6 <ble_sm_proc_find+0xa>
   1651e:	bd70      	pop	{r4, r5, r6, pc}
        if (ble_sm_proc_matches(proc, conn_handle, state, is_initiator)) {
            if (out_prev != NULL) {
   16520:	b10b      	cbz	r3, 16526 <ble_sm_proc_find+0x3a>
                *out_prev = prev;
   16522:	601d      	str	r5, [r3, #0]
   16524:	bd70      	pop	{r4, r5, r6, pc}

        prev = proc;
    }

    return proc;
}
   16526:	bd70      	pop	{r4, r5, r6, pc}
   16528:	20002278 	.word	0x20002278

0001652c <ble_sm_sign_info_rx>:
}

static void
ble_sm_sign_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                    struct ble_sm_result *res)
{
   1652c:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_sign_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_SIGN_INFO_SZ);
   1652e:	2110      	movs	r1, #16
}

static void
ble_sm_sign_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                    struct ble_sm_result *res)
{
   16530:	b08b      	sub	sp, #44	; 0x2c
   16532:	4606      	mov	r6, r0
    struct ble_sm_sign_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_SIGN_INFO_SZ);
   16534:	4610      	mov	r0, r2
}

static void
ble_sm_sign_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                    struct ble_sm_result *res)
{
   16536:	461c      	mov	r4, r3
   16538:	4617      	mov	r7, r2
    struct ble_sm_sign_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_SIGN_INFO_SZ);
   1653a:	f7fe fffd 	bl	15538 <ble_hs_misc_pullup_base>
   1653e:	4605      	mov	r5, r0
   16540:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   16542:	b130      	cbz	r0, 16552 <ble_sm_sign_info_rx+0x26>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   16544:	2308      	movs	r3, #8
   16546:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   16548:	7d23      	ldrb	r3, [r4, #20]
   1654a:	f043 0302 	orr.w	r3, r3, #2
   1654e:	7523      	strb	r3, [r4, #20]
   16550:	e048      	b.n	165e4 <ble_sm_sign_info_rx+0xb8>
        return;
    }

    ble_sm_sign_info_parse((*om)->om_data, (*om)->om_len, &cmd);
   16552:	683b      	ldr	r3, [r7, #0]
   16554:	aa06      	add	r2, sp, #24
   16556:	6818      	ldr	r0, [r3, #0]
   16558:	88d9      	ldrh	r1, [r3, #6]
   1655a:	f001 fd2b 	bl	17fb4 <ble_sm_sign_info_parse>
    BLE_SM_LOG_CMD(0, "sign info", conn_handle, ble_sm_sign_info_log, &cmd);
   1655e:	4b22      	ldr	r3, [pc, #136]	; (165e8 <ble_sm_sign_info_rx+0xbc>)
   16560:	9300      	str	r3, [sp, #0]
   16562:	4b22      	ldr	r3, [pc, #136]	; (165ec <ble_sm_sign_info_rx+0xc0>)
   16564:	9301      	str	r3, [sp, #4]
   16566:	4b22      	ldr	r3, [pc, #136]	; (165f0 <ble_sm_sign_info_rx+0xc4>)
   16568:	9302      	str	r3, [sp, #8]
   1656a:	2104      	movs	r1, #4
   1656c:	462a      	mov	r2, r5
   1656e:	4b21      	ldr	r3, [pc, #132]	; (165f4 <ble_sm_sign_info_rx+0xc8>)
   16570:	4821      	ldr	r0, [pc, #132]	; (165f8 <ble_sm_sign_info_rx+0xcc>)
   16572:	9603      	str	r6, [sp, #12]
   16574:	f006 fe58 	bl	1d228 <log_printf>
   16578:	a806      	add	r0, sp, #24
   1657a:	f001 fd31 	bl	17fe0 <ble_sm_sign_info_log>
   1657e:	481e      	ldr	r0, [pc, #120]	; (165f8 <ble_sm_sign_info_rx+0xcc>)
   16580:	4b1e      	ldr	r3, [pc, #120]	; (165fc <ble_sm_sign_info_rx+0xd0>)
   16582:	2104      	movs	r1, #4
   16584:	462a      	mov	r2, r5
   16586:	f006 fe4f 	bl	1d228 <log_printf>

    ble_hs_lock();
   1658a:	f7fe f8db 	bl	14744 <ble_hs_lock>

    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1,
   1658e:	ab05      	add	r3, sp, #20
   16590:	4630      	mov	r0, r6
   16592:	2107      	movs	r1, #7
   16594:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16598:	f7ff ffa8 	bl	164ec <ble_sm_proc_find>
                            &prev);
    if (proc == NULL) {
   1659c:	4603      	mov	r3, r0
   1659e:	b920      	cbnz	r0, 165aa <ble_sm_sign_info_rx+0x7e>
        res->app_status = BLE_HS_ENOENT;
   165a0:	2305      	movs	r3, #5
   165a2:	6023      	str	r3, [r4, #0]
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   165a4:	2308      	movs	r3, #8
   165a6:	7123      	strb	r3, [r4, #4]
   165a8:	e01a      	b.n	165e0 <ble_sm_sign_info_rx+0xb4>
    } else {
        proc->rx_key_flags &= ~BLE_SM_KE_F_SIGN_INFO;
   165aa:	7b82      	ldrb	r2, [r0, #14]
   165ac:	f022 0210 	bic.w	r2, r2, #16
   165b0:	7382      	strb	r2, [r0, #14]

        memcpy(proc->peer_keys.csrk, cmd.sig_key, 16);
   165b2:	f100 06e9 	add.w	r6, r0, #233	; 0xe9
   165b6:	aa06      	add	r2, sp, #24
   165b8:	af0a      	add	r7, sp, #40	; 0x28
   165ba:	4615      	mov	r5, r2
   165bc:	cd03      	ldmia	r5!, {r0, r1}
   165be:	42bd      	cmp	r5, r7
   165c0:	6030      	str	r0, [r6, #0]
   165c2:	6071      	str	r1, [r6, #4]
   165c4:	462a      	mov	r2, r5
   165c6:	f106 0608 	add.w	r6, r6, #8
   165ca:	d1f6      	bne.n	165ba <ble_sm_sign_info_rx+0x8e>
        proc->peer_keys.csrk_valid = 1;
   165cc:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
   165d0:	f042 0208 	orr.w	r2, r2, #8
   165d4:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8

        ble_sm_key_rxed(proc, res);
   165d8:	4618      	mov	r0, r3
   165da:	4621      	mov	r1, r4
   165dc:	f7ff ff20 	bl	16420 <ble_sm_key_rxed>
    }

    ble_hs_unlock();
   165e0:	f7fe f8b8 	bl	14754 <ble_hs_unlock>
}
   165e4:	b00b      	add	sp, #44	; 0x2c
   165e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   165e8:	0001fbda 	.word	0x0001fbda
   165ec:	0001fbdd 	.word	0x0001fbdd
   165f0:	0001fbfa 	.word	0x0001fbfa
   165f4:	0001fbbc 	.word	0x0001fbbc
   165f8:	20003b9c 	.word	0x20003b9c
   165fc:	0001fdec 	.word	0x0001fdec

00016600 <ble_sm_id_addr_info_rx>:
}

static void
ble_sm_id_addr_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                       struct ble_sm_result *res)
{
   16600:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_id_addr_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ID_ADDR_INFO_SZ);
   16602:	2107      	movs	r1, #7
}

static void
ble_sm_id_addr_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                       struct ble_sm_result *res)
{
   16604:	b089      	sub	sp, #36	; 0x24
   16606:	4606      	mov	r6, r0
    struct ble_sm_id_addr_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ID_ADDR_INFO_SZ);
   16608:	4610      	mov	r0, r2
}

static void
ble_sm_id_addr_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                       struct ble_sm_result *res)
{
   1660a:	461c      	mov	r4, r3
   1660c:	4617      	mov	r7, r2
    struct ble_sm_id_addr_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ID_ADDR_INFO_SZ);
   1660e:	f7fe ff93 	bl	15538 <ble_hs_misc_pullup_base>
   16612:	4605      	mov	r5, r0
   16614:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   16616:	b130      	cbz	r0, 16626 <ble_sm_id_addr_info_rx+0x26>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   16618:	2308      	movs	r3, #8
   1661a:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   1661c:	7d23      	ldrb	r3, [r4, #20]
   1661e:	f043 0302 	orr.w	r3, r3, #2
   16622:	7523      	strb	r3, [r4, #20]
   16624:	e045      	b.n	166b2 <ble_sm_id_addr_info_rx+0xb2>
        return;
    }

    ble_sm_id_addr_info_parse((*om)->om_data, (*om)->om_len, &cmd);
   16626:	683b      	ldr	r3, [r7, #0]
   16628:	aa06      	add	r2, sp, #24
   1662a:	6818      	ldr	r0, [r3, #0]
   1662c:	88d9      	ldrh	r1, [r3, #6]
   1662e:	f001 fc45 	bl	17ebc <ble_sm_id_addr_info_parse>
    BLE_SM_LOG_CMD(0, "id addr info", conn_handle, ble_sm_id_addr_info_log,
   16632:	4b21      	ldr	r3, [pc, #132]	; (166b8 <ble_sm_id_addr_info_rx+0xb8>)
   16634:	9300      	str	r3, [sp, #0]
   16636:	4b21      	ldr	r3, [pc, #132]	; (166bc <ble_sm_id_addr_info_rx+0xbc>)
   16638:	9301      	str	r3, [sp, #4]
   1663a:	4b21      	ldr	r3, [pc, #132]	; (166c0 <ble_sm_id_addr_info_rx+0xc0>)
   1663c:	9302      	str	r3, [sp, #8]
   1663e:	2104      	movs	r1, #4
   16640:	462a      	mov	r2, r5
   16642:	4b20      	ldr	r3, [pc, #128]	; (166c4 <ble_sm_id_addr_info_rx+0xc4>)
   16644:	4820      	ldr	r0, [pc, #128]	; (166c8 <ble_sm_id_addr_info_rx+0xc8>)
   16646:	9603      	str	r6, [sp, #12]
   16648:	f006 fdee 	bl	1d228 <log_printf>
   1664c:	a806      	add	r0, sp, #24
   1664e:	f001 fc4b 	bl	17ee8 <ble_sm_id_addr_info_log>
   16652:	481d      	ldr	r0, [pc, #116]	; (166c8 <ble_sm_id_addr_info_rx+0xc8>)
   16654:	4b1d      	ldr	r3, [pc, #116]	; (166cc <ble_sm_id_addr_info_rx+0xcc>)
   16656:	2104      	movs	r1, #4
   16658:	462a      	mov	r2, r5
   1665a:	f006 fde5 	bl	1d228 <log_printf>
                   &cmd);

    ble_hs_lock();
   1665e:	f7fe f871 	bl	14744 <ble_hs_lock>

    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1,
   16662:	4630      	mov	r0, r6
   16664:	2107      	movs	r1, #7
   16666:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1666a:	ab05      	add	r3, sp, #20
   1666c:	f7ff ff3e 	bl	164ec <ble_sm_proc_find>
                            &prev);
    if (proc == NULL) {
   16670:	b920      	cbnz	r0, 1667c <ble_sm_id_addr_info_rx+0x7c>
        res->app_status = BLE_HS_ENOENT;
   16672:	2305      	movs	r3, #5
   16674:	6023      	str	r3, [r4, #0]
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   16676:	2308      	movs	r3, #8
   16678:	7123      	strb	r3, [r4, #4]
   1667a:	e018      	b.n	166ae <ble_sm_id_addr_info_rx+0xae>
    } else {
        proc->rx_key_flags &= ~BLE_SM_KE_F_ADDR_INFO;
   1667c:	7b82      	ldrb	r2, [r0, #14]
   1667e:	f022 0208 	bic.w	r2, r2, #8
   16682:	7382      	strb	r2, [r0, #14]
        proc->peer_keys.addr_valid = 1;
   16684:	f890 20b8 	ldrb.w	r2, [r0, #184]	; 0xb8
   16688:	f042 0210 	orr.w	r2, r2, #16
   1668c:	f880 20b8 	strb.w	r2, [r0, #184]	; 0xb8
        proc->peer_keys.addr_type = cmd.addr_type;
   16690:	f89d 2018 	ldrb.w	r2, [sp, #24]
   16694:	f880 20c8 	strb.w	r2, [r0, #200]	; 0xc8
        memcpy(proc->peer_keys.addr, cmd.bd_addr, 6);
   16698:	aa08      	add	r2, sp, #32
   1669a:	f852 1d07 	ldr.w	r1, [r2, #-7]!
   1669e:	f8c0 10f9 	str.w	r1, [r0, #249]	; 0xf9
   166a2:	8892      	ldrh	r2, [r2, #4]
   166a4:	f8a0 20fd 	strh.w	r2, [r0, #253]	; 0xfd

        ble_sm_key_rxed(proc, res);
   166a8:	4621      	mov	r1, r4
   166aa:	f7ff feb9 	bl	16420 <ble_sm_key_rxed>
    }

    ble_hs_unlock();
   166ae:	f7fe f851 	bl	14754 <ble_hs_unlock>
}
   166b2:	b009      	add	sp, #36	; 0x24
   166b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   166b6:	bf00      	nop
   166b8:	0001fbda 	.word	0x0001fbda
   166bc:	0001fbdd 	.word	0x0001fbdd
   166c0:	0001fc04 	.word	0x0001fc04
   166c4:	0001fbbc 	.word	0x0001fbbc
   166c8:	20003b9c 	.word	0x20003b9c
   166cc:	0001fdec 	.word	0x0001fdec

000166d0 <ble_sm_id_info_rx>:
}

static void
ble_sm_id_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   166d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_id_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ID_INFO_SZ);
   166d2:	2110      	movs	r1, #16
}

static void
ble_sm_id_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   166d4:	b08b      	sub	sp, #44	; 0x2c
   166d6:	4606      	mov	r6, r0
    struct ble_sm_id_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ID_INFO_SZ);
   166d8:	4610      	mov	r0, r2
}

static void
ble_sm_id_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   166da:	461c      	mov	r4, r3
   166dc:	4617      	mov	r7, r2
    struct ble_sm_id_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ID_INFO_SZ);
   166de:	f7fe ff2b 	bl	15538 <ble_hs_misc_pullup_base>
   166e2:	4605      	mov	r5, r0
   166e4:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   166e6:	b130      	cbz	r0, 166f6 <ble_sm_id_info_rx+0x26>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   166e8:	2308      	movs	r3, #8
   166ea:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   166ec:	7d23      	ldrb	r3, [r4, #20]
   166ee:	f043 0302 	orr.w	r3, r3, #2
   166f2:	7523      	strb	r3, [r4, #20]
   166f4:	e048      	b.n	16788 <ble_sm_id_info_rx+0xb8>
        return;
    }

    ble_sm_id_info_parse((*om)->om_data, (*om)->om_len, &cmd);
   166f6:	683b      	ldr	r3, [r7, #0]
   166f8:	aa06      	add	r2, sp, #24
   166fa:	6818      	ldr	r0, [r3, #0]
   166fc:	88d9      	ldrh	r1, [r3, #6]
   166fe:	f001 fb75 	bl	17dec <ble_sm_id_info_parse>
    BLE_SM_LOG_CMD(0, "id info", conn_handle, ble_sm_id_info_log, &cmd);
   16702:	4b22      	ldr	r3, [pc, #136]	; (1678c <ble_sm_id_info_rx+0xbc>)
   16704:	9300      	str	r3, [sp, #0]
   16706:	4b22      	ldr	r3, [pc, #136]	; (16790 <ble_sm_id_info_rx+0xc0>)
   16708:	9301      	str	r3, [sp, #4]
   1670a:	4b22      	ldr	r3, [pc, #136]	; (16794 <ble_sm_id_info_rx+0xc4>)
   1670c:	9302      	str	r3, [sp, #8]
   1670e:	2104      	movs	r1, #4
   16710:	462a      	mov	r2, r5
   16712:	4b21      	ldr	r3, [pc, #132]	; (16798 <ble_sm_id_info_rx+0xc8>)
   16714:	4821      	ldr	r0, [pc, #132]	; (1679c <ble_sm_id_info_rx+0xcc>)
   16716:	9603      	str	r6, [sp, #12]
   16718:	f006 fd86 	bl	1d228 <log_printf>
   1671c:	a806      	add	r0, sp, #24
   1671e:	f001 fb7b 	bl	17e18 <ble_sm_id_info_log>
   16722:	481e      	ldr	r0, [pc, #120]	; (1679c <ble_sm_id_info_rx+0xcc>)
   16724:	4b1e      	ldr	r3, [pc, #120]	; (167a0 <ble_sm_id_info_rx+0xd0>)
   16726:	2104      	movs	r1, #4
   16728:	462a      	mov	r2, r5
   1672a:	f006 fd7d 	bl	1d228 <log_printf>

    ble_hs_lock();
   1672e:	f7fe f809 	bl	14744 <ble_hs_lock>

    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1,
   16732:	ab05      	add	r3, sp, #20
   16734:	4630      	mov	r0, r6
   16736:	2107      	movs	r1, #7
   16738:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1673c:	f7ff fed6 	bl	164ec <ble_sm_proc_find>
                            &prev);
    if (proc == NULL) {
   16740:	4603      	mov	r3, r0
   16742:	b920      	cbnz	r0, 1674e <ble_sm_id_info_rx+0x7e>
        res->app_status = BLE_HS_ENOENT;
   16744:	2305      	movs	r3, #5
   16746:	6023      	str	r3, [r4, #0]
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   16748:	2308      	movs	r3, #8
   1674a:	7123      	strb	r3, [r4, #4]
   1674c:	e01a      	b.n	16784 <ble_sm_id_info_rx+0xb4>
    } else {
        proc->rx_key_flags &= ~BLE_SM_KE_F_ID_INFO;
   1674e:	7b82      	ldrb	r2, [r0, #14]
   16750:	f022 0204 	bic.w	r2, r2, #4
   16754:	7382      	strb	r2, [r0, #14]

        memcpy(proc->peer_keys.irk, cmd.irk, 16);
   16756:	f100 06d9 	add.w	r6, r0, #217	; 0xd9
   1675a:	aa06      	add	r2, sp, #24
   1675c:	af0a      	add	r7, sp, #40	; 0x28
   1675e:	4615      	mov	r5, r2
   16760:	cd03      	ldmia	r5!, {r0, r1}
   16762:	42bd      	cmp	r5, r7
   16764:	6030      	str	r0, [r6, #0]
   16766:	6071      	str	r1, [r6, #4]
   16768:	462a      	mov	r2, r5
   1676a:	f106 0608 	add.w	r6, r6, #8
   1676e:	d1f6      	bne.n	1675e <ble_sm_id_info_rx+0x8e>
        proc->peer_keys.irk_valid = 1;
   16770:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
   16774:	f042 0204 	orr.w	r2, r2, #4
   16778:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8

        ble_sm_key_rxed(proc, res);
   1677c:	4618      	mov	r0, r3
   1677e:	4621      	mov	r1, r4
   16780:	f7ff fe4e 	bl	16420 <ble_sm_key_rxed>
    }

    ble_hs_unlock();
   16784:	f7fd ffe6 	bl	14754 <ble_hs_unlock>
}
   16788:	b00b      	add	sp, #44	; 0x2c
   1678a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1678c:	0001fbda 	.word	0x0001fbda
   16790:	0001fbdd 	.word	0x0001fbdd
   16794:	0001fc11 	.word	0x0001fc11
   16798:	0001fbbc 	.word	0x0001fbbc
   1679c:	20003b9c 	.word	0x20003b9c
   167a0:	0001fdec 	.word	0x0001fdec

000167a4 <ble_sm_master_id_rx>:
}

static void
ble_sm_master_id_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                    struct ble_sm_result *res)
{
   167a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_master_id cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_MASTER_ID_SZ);
   167a6:	210a      	movs	r1, #10
}

static void
ble_sm_master_id_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                    struct ble_sm_result *res)
{
   167a8:	b08b      	sub	sp, #44	; 0x2c
   167aa:	4606      	mov	r6, r0
    struct ble_sm_master_id cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_MASTER_ID_SZ);
   167ac:	4610      	mov	r0, r2
}

static void
ble_sm_master_id_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                    struct ble_sm_result *res)
{
   167ae:	461c      	mov	r4, r3
   167b0:	4617      	mov	r7, r2
    struct ble_sm_master_id cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_MASTER_ID_SZ);
   167b2:	f7fe fec1 	bl	15538 <ble_hs_misc_pullup_base>
   167b6:	4605      	mov	r5, r0
   167b8:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   167ba:	b130      	cbz	r0, 167ca <ble_sm_master_id_rx+0x26>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   167bc:	2308      	movs	r3, #8
   167be:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   167c0:	7d23      	ldrb	r3, [r4, #20]
   167c2:	f043 0302 	orr.w	r3, r3, #2
   167c6:	7523      	strb	r3, [r4, #20]
   167c8:	e041      	b.n	1684e <ble_sm_master_id_rx+0xaa>
        return;
    }

    ble_sm_master_id_parse((*om)->om_data, (*om)->om_len, &cmd);
   167ca:	683b      	ldr	r3, [r7, #0]
   167cc:	aa06      	add	r2, sp, #24
   167ce:	6818      	ldr	r0, [r3, #0]
   167d0:	88d9      	ldrh	r1, [r3, #6]
   167d2:	f001 fa95 	bl	17d00 <ble_sm_master_id_parse>
    BLE_SM_LOG_CMD(0, "master id", conn_handle, ble_sm_master_id_log, &cmd);
   167d6:	4b1f      	ldr	r3, [pc, #124]	; (16854 <ble_sm_master_id_rx+0xb0>)
   167d8:	9300      	str	r3, [sp, #0]
   167da:	4b1f      	ldr	r3, [pc, #124]	; (16858 <ble_sm_master_id_rx+0xb4>)
   167dc:	9301      	str	r3, [sp, #4]
   167de:	4b1f      	ldr	r3, [pc, #124]	; (1685c <ble_sm_master_id_rx+0xb8>)
   167e0:	9302      	str	r3, [sp, #8]
   167e2:	2104      	movs	r1, #4
   167e4:	462a      	mov	r2, r5
   167e6:	4b1e      	ldr	r3, [pc, #120]	; (16860 <ble_sm_master_id_rx+0xbc>)
   167e8:	481e      	ldr	r0, [pc, #120]	; (16864 <ble_sm_master_id_rx+0xc0>)
   167ea:	9603      	str	r6, [sp, #12]
   167ec:	f006 fd1c 	bl	1d228 <log_printf>
   167f0:	a806      	add	r0, sp, #24
   167f2:	f001 fa91 	bl	17d18 <ble_sm_master_id_log>
   167f6:	481b      	ldr	r0, [pc, #108]	; (16864 <ble_sm_master_id_rx+0xc0>)
   167f8:	4b1b      	ldr	r3, [pc, #108]	; (16868 <ble_sm_master_id_rx+0xc4>)
   167fa:	2104      	movs	r1, #4
   167fc:	462a      	mov	r2, r5
   167fe:	f006 fd13 	bl	1d228 <log_printf>

    ble_hs_lock();
   16802:	f7fd ff9f 	bl	14744 <ble_hs_lock>

    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1,
   16806:	4630      	mov	r0, r6
   16808:	2107      	movs	r1, #7
   1680a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1680e:	ab05      	add	r3, sp, #20
   16810:	f7ff fe6c 	bl	164ec <ble_sm_proc_find>
                            &prev);
    if (proc == NULL) {
   16814:	b920      	cbnz	r0, 16820 <ble_sm_master_id_rx+0x7c>
        res->app_status = BLE_HS_ENOENT;
   16816:	2305      	movs	r3, #5
   16818:	6023      	str	r3, [r4, #0]
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1681a:	2308      	movs	r3, #8
   1681c:	7123      	strb	r3, [r4, #4]
   1681e:	e014      	b.n	1684a <ble_sm_master_id_rx+0xa6>
    } else {
        proc->rx_key_flags &= ~BLE_SM_KE_F_MASTER_ID;
   16820:	7b82      	ldrb	r2, [r0, #14]
   16822:	f022 0202 	bic.w	r2, r2, #2
   16826:	7382      	strb	r2, [r0, #14]
        proc->peer_keys.ediv_rand_valid = 1;
   16828:	f890 20b8 	ldrb.w	r2, [r0, #184]	; 0xb8
        proc->peer_keys.ediv = cmd.ediv;
        proc->peer_keys.rand_val = cmd.rand_val;
   1682c:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
    if (proc == NULL) {
        res->app_status = BLE_HS_ENOENT;
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
    } else {
        proc->rx_key_flags &= ~BLE_SM_KE_F_MASTER_ID;
        proc->peer_keys.ediv_rand_valid = 1;
   16830:	f042 0202 	orr.w	r2, r2, #2
   16834:	f880 20b8 	strb.w	r2, [r0, #184]	; 0xb8
        proc->peer_keys.ediv = cmd.ediv;
   16838:	f8bd 2018 	ldrh.w	r2, [sp, #24]
   1683c:	f8a0 20ba 	strh.w	r2, [r0, #186]	; 0xba
        proc->peer_keys.rand_val = cmd.rand_val;
   16840:	e9c0 6730 	strd	r6, r7, [r0, #192]	; 0xc0

        ble_sm_key_rxed(proc, res);
   16844:	4621      	mov	r1, r4
   16846:	f7ff fdeb 	bl	16420 <ble_sm_key_rxed>
    }

    ble_hs_unlock();
   1684a:	f7fd ff83 	bl	14754 <ble_hs_unlock>
}
   1684e:	b00b      	add	sp, #44	; 0x2c
   16850:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16852:	bf00      	nop
   16854:	0001fbda 	.word	0x0001fbda
   16858:	0001fbdd 	.word	0x0001fbdd
   1685c:	0001fc19 	.word	0x0001fc19
   16860:	0001fbbc 	.word	0x0001fbbc
   16864:	20003b9c 	.word	0x20003b9c
   16868:	0001fdec 	.word	0x0001fdec

0001686c <ble_sm_enc_info_rx>:
}

static void
ble_sm_enc_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   1686c:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_enc_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ENC_INFO_SZ);
   1686e:	2110      	movs	r1, #16
}

static void
ble_sm_enc_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   16870:	b08b      	sub	sp, #44	; 0x2c
   16872:	4606      	mov	r6, r0
    struct ble_sm_enc_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ENC_INFO_SZ);
   16874:	4610      	mov	r0, r2
}

static void
ble_sm_enc_info_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   16876:	461c      	mov	r4, r3
   16878:	4617      	mov	r7, r2
    struct ble_sm_enc_info cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_ENC_INFO_SZ);
   1687a:	f7fe fe5d 	bl	15538 <ble_hs_misc_pullup_base>
   1687e:	4605      	mov	r5, r0
   16880:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   16882:	b130      	cbz	r0, 16892 <ble_sm_enc_info_rx+0x26>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   16884:	2308      	movs	r3, #8
   16886:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   16888:	7d23      	ldrb	r3, [r4, #20]
   1688a:	f043 0302 	orr.w	r3, r3, #2
   1688e:	7523      	strb	r3, [r4, #20]
   16890:	e048      	b.n	16924 <ble_sm_enc_info_rx+0xb8>
        return;
    }

    ble_sm_enc_info_parse((*om)->om_data, (*om)->om_len, &cmd);
   16892:	683b      	ldr	r3, [r7, #0]
   16894:	aa06      	add	r2, sp, #24
   16896:	6818      	ldr	r0, [r3, #0]
   16898:	88d9      	ldrh	r1, [r3, #6]
   1689a:	f001 f9c9 	bl	17c30 <ble_sm_enc_info_parse>
    BLE_SM_LOG_CMD(0, "enc info", conn_handle, ble_sm_enc_info_log, &cmd);
   1689e:	4b22      	ldr	r3, [pc, #136]	; (16928 <ble_sm_enc_info_rx+0xbc>)
   168a0:	9300      	str	r3, [sp, #0]
   168a2:	4b22      	ldr	r3, [pc, #136]	; (1692c <ble_sm_enc_info_rx+0xc0>)
   168a4:	9301      	str	r3, [sp, #4]
   168a6:	4b22      	ldr	r3, [pc, #136]	; (16930 <ble_sm_enc_info_rx+0xc4>)
   168a8:	9302      	str	r3, [sp, #8]
   168aa:	2104      	movs	r1, #4
   168ac:	462a      	mov	r2, r5
   168ae:	4b21      	ldr	r3, [pc, #132]	; (16934 <ble_sm_enc_info_rx+0xc8>)
   168b0:	4821      	ldr	r0, [pc, #132]	; (16938 <ble_sm_enc_info_rx+0xcc>)
   168b2:	9603      	str	r6, [sp, #12]
   168b4:	f006 fcb8 	bl	1d228 <log_printf>
   168b8:	a806      	add	r0, sp, #24
   168ba:	f001 f9cf 	bl	17c5c <ble_sm_enc_info_log>
   168be:	481e      	ldr	r0, [pc, #120]	; (16938 <ble_sm_enc_info_rx+0xcc>)
   168c0:	4b1e      	ldr	r3, [pc, #120]	; (1693c <ble_sm_enc_info_rx+0xd0>)
   168c2:	2104      	movs	r1, #4
   168c4:	462a      	mov	r2, r5
   168c6:	f006 fcaf 	bl	1d228 <log_printf>

    ble_hs_lock();
   168ca:	f7fd ff3b 	bl	14744 <ble_hs_lock>

    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1,
   168ce:	ab05      	add	r3, sp, #20
   168d0:	4630      	mov	r0, r6
   168d2:	2107      	movs	r1, #7
   168d4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   168d8:	f7ff fe08 	bl	164ec <ble_sm_proc_find>
                            &prev);
    if (proc == NULL) {
   168dc:	4603      	mov	r3, r0
   168de:	b920      	cbnz	r0, 168ea <ble_sm_enc_info_rx+0x7e>
        res->app_status = BLE_HS_ENOENT;
   168e0:	2305      	movs	r3, #5
   168e2:	6023      	str	r3, [r4, #0]
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   168e4:	2308      	movs	r3, #8
   168e6:	7123      	strb	r3, [r4, #4]
   168e8:	e01a      	b.n	16920 <ble_sm_enc_info_rx+0xb4>
    } else {
        proc->rx_key_flags &= ~BLE_SM_KE_F_ENC_INFO;
   168ea:	7b82      	ldrb	r2, [r0, #14]
   168ec:	f022 0201 	bic.w	r2, r2, #1
   168f0:	7382      	strb	r2, [r0, #14]
        proc->peer_keys.ltk_valid = 1;
   168f2:	f890 20b8 	ldrb.w	r2, [r0, #184]	; 0xb8
   168f6:	f042 0201 	orr.w	r2, r2, #1
   168fa:	f880 20b8 	strb.w	r2, [r0, #184]	; 0xb8
        memcpy(proc->peer_keys.ltk, cmd.ltk, 16);
   168fe:	f100 06c9 	add.w	r6, r0, #201	; 0xc9
   16902:	aa06      	add	r2, sp, #24
   16904:	af0a      	add	r7, sp, #40	; 0x28
   16906:	4615      	mov	r5, r2
   16908:	cd03      	ldmia	r5!, {r0, r1}
   1690a:	42bd      	cmp	r5, r7
   1690c:	6030      	str	r0, [r6, #0]
   1690e:	6071      	str	r1, [r6, #4]
   16910:	462a      	mov	r2, r5
   16912:	f106 0608 	add.w	r6, r6, #8
   16916:	d1f6      	bne.n	16906 <ble_sm_enc_info_rx+0x9a>

        ble_sm_key_rxed(proc, res);
   16918:	4618      	mov	r0, r3
   1691a:	4621      	mov	r1, r4
   1691c:	f7ff fd80 	bl	16420 <ble_sm_key_rxed>
    }

    ble_hs_unlock();
   16920:	f7fd ff18 	bl	14754 <ble_hs_unlock>
}
   16924:	b00b      	add	sp, #44	; 0x2c
   16926:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16928:	0001fbda 	.word	0x0001fbda
   1692c:	0001fbdd 	.word	0x0001fbdd
   16930:	0001fc23 	.word	0x0001fc23
   16934:	0001fbbc 	.word	0x0001fbbc
   16938:	20003b9c 	.word	0x20003b9c
   1693c:	0001fdec 	.word	0x0001fdec

00016940 <ble_sm_pair_req_rx>:
}

static void
ble_sm_pair_req_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   16940:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_pair_cmd req;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    struct ble_hs_conn *conn;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CMD_SZ);
   16942:	2106      	movs	r1, #6
}

static void
ble_sm_pair_req_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   16944:	b089      	sub	sp, #36	; 0x24
   16946:	4606      	mov	r6, r0
    struct ble_sm_pair_cmd req;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    struct ble_hs_conn *conn;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CMD_SZ);
   16948:	4610      	mov	r0, r2
}

static void
ble_sm_pair_req_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   1694a:	461c      	mov	r4, r3
   1694c:	4617      	mov	r7, r2
    struct ble_sm_pair_cmd req;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    struct ble_hs_conn *conn;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CMD_SZ);
   1694e:	f7fe fdf3 	bl	15538 <ble_hs_misc_pullup_base>
   16952:	4605      	mov	r5, r0
   16954:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   16956:	2800      	cmp	r0, #0
   16958:	d15d      	bne.n	16a16 <ble_sm_pair_req_rx+0xd6>
        return;
    }

    ble_sm_pair_cmd_parse((*om)->om_data, (*om)->om_len, &req);
   1695a:	683b      	ldr	r3, [r7, #0]
   1695c:	aa06      	add	r2, sp, #24
   1695e:	6818      	ldr	r0, [r3, #0]
   16960:	88d9      	ldrh	r1, [r3, #6]
   16962:	f000 ff9f 	bl	178a4 <ble_sm_pair_cmd_parse>
    BLE_SM_LOG_CMD(0, "pair req", conn_handle, ble_sm_pair_cmd_log, &req);
   16966:	4b2d      	ldr	r3, [pc, #180]	; (16a1c <ble_sm_pair_req_rx+0xdc>)
   16968:	9300      	str	r3, [sp, #0]
   1696a:	4b2d      	ldr	r3, [pc, #180]	; (16a20 <ble_sm_pair_req_rx+0xe0>)
   1696c:	9301      	str	r3, [sp, #4]
   1696e:	4b2d      	ldr	r3, [pc, #180]	; (16a24 <ble_sm_pair_req_rx+0xe4>)
   16970:	9302      	str	r3, [sp, #8]
   16972:	462a      	mov	r2, r5
   16974:	2104      	movs	r1, #4
   16976:	4b2c      	ldr	r3, [pc, #176]	; (16a28 <ble_sm_pair_req_rx+0xe8>)
   16978:	482c      	ldr	r0, [pc, #176]	; (16a2c <ble_sm_pair_req_rx+0xec>)
   1697a:	9603      	str	r6, [sp, #12]
   1697c:	f006 fc54 	bl	1d228 <log_printf>
   16980:	a806      	add	r0, sp, #24
   16982:	f000 ffcb 	bl	1791c <ble_sm_pair_cmd_log>
   16986:	462a      	mov	r2, r5
   16988:	4828      	ldr	r0, [pc, #160]	; (16a2c <ble_sm_pair_req_rx+0xec>)
   1698a:	4b29      	ldr	r3, [pc, #164]	; (16a30 <ble_sm_pair_req_rx+0xf0>)
   1698c:	2104      	movs	r1, #4
   1698e:	f006 fc4b 	bl	1d228 <log_printf>

    ble_hs_lock();
   16992:	f7fd fed7 	bl	14744 <ble_hs_lock>

    /* XXX: Check connection state; reject if not appropriate. */
    /* XXX: Ensure enough time has passed since the previous failed pairing
     * attempt.
     */
    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
   16996:	4630      	mov	r0, r6
   16998:	21ff      	movs	r1, #255	; 0xff
   1699a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1699e:	ab05      	add	r3, sp, #20
   169a0:	f7ff fda4 	bl	164ec <ble_sm_proc_find>
    if (proc != NULL) {
   169a4:	4605      	mov	r5, r0
   169a6:	b128      	cbz	r0, 169b4 <ble_sm_pair_req_rx+0x74>
        /* Pairing already in progress; abort old procedure and start new. */
        /* XXX: Check the spec on this. */
        ble_sm_proc_remove(proc, prev);
   169a8:	9805      	ldr	r0, [sp, #20]
   169aa:	f7ff fbb9 	bl	16120 <ble_sm_proc_remove.isra.1>
        ble_sm_proc_free(proc);
   169ae:	4628      	mov	r0, r5
   169b0:	f7ff fb9e 	bl	160f0 <ble_sm_proc_free>
    }

    proc = ble_sm_proc_alloc();
   169b4:	f7ff fba4 	bl	16100 <ble_sm_proc_alloc>
    if (proc != NULL) {
   169b8:	4605      	mov	r5, r0
   169ba:	b350      	cbz	r0, 16a12 <ble_sm_pair_req_rx+0xd2>
        proc->conn_handle = conn_handle;
        proc->state = BLE_SM_PROC_STATE_PAIR;
   169bc:	2300      	movs	r3, #0
   169be:	7343      	strb	r3, [r0, #13]
        ble_sm_proc_free(proc);
    }

    proc = ble_sm_proc_alloc();
    if (proc != NULL) {
        proc->conn_handle = conn_handle;
   169c0:	8146      	strh	r6, [r0, #10]
        proc->state = BLE_SM_PROC_STATE_PAIR;
        ble_sm_insert(proc);
   169c2:	f7ff fa63 	bl	15e8c <ble_sm_insert>

        proc->pair_req = req;
   169c6:	9806      	ldr	r0, [sp, #24]
   169c8:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   169cc:	f8c5 000f 	str.w	r0, [r5, #15]
   169d0:	f8a5 3013 	strh.w	r3, [r5, #19]

        conn = ble_hs_conn_find(proc->conn_handle);
   169d4:	8968      	ldrh	r0, [r5, #10]
   169d6:	f7fe fc5d 	bl	15294 <ble_hs_conn_find>
        if (conn == NULL) {
   169da:	b918      	cbnz	r0, 169e4 <ble_sm_pair_req_rx+0xa4>
            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   169dc:	2308      	movs	r3, #8
   169de:	7123      	strb	r3, [r4, #4]
            res->app_status = BLE_HS_ENOTCONN;
   169e0:	2307      	movs	r3, #7
   169e2:	e007      	b.n	169f4 <ble_sm_pair_req_rx+0xb4>
        } else if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
   169e4:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
   169e8:	07db      	lsls	r3, r3, #31
   169ea:	d505      	bpl.n	169f8 <ble_sm_pair_req_rx+0xb8>
            res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
   169ec:	2307      	movs	r3, #7
   169ee:	7123      	strb	r3, [r4, #4]
            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
   169f0:	f240 4307 	movw	r3, #1031	; 0x407
   169f4:	6023      	str	r3, [r4, #0]
   169f6:	e00c      	b.n	16a12 <ble_sm_pair_req_rx+0xd2>
        } else if (!ble_sm_pair_cmd_is_valid(&req)) {
   169f8:	a806      	add	r0, sp, #24
   169fa:	f000 ff60 	bl	178be <ble_sm_pair_cmd_is_valid>
   169fe:	b920      	cbnz	r0, 16a0a <ble_sm_pair_req_rx+0xca>
            res->sm_err = BLE_SM_ERR_INVAL;
   16a00:	230a      	movs	r3, #10
   16a02:	7123      	strb	r3, [r4, #4]
            res->app_status =  BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
   16a04:	f240 430a 	movw	r3, #1034	; 0x40a
   16a08:	e7f4      	b.n	169f4 <ble_sm_pair_req_rx+0xb4>
        } else {
            res->execute = 1;
   16a0a:	7d23      	ldrb	r3, [r4, #20]
   16a0c:	f043 0301 	orr.w	r3, r3, #1
   16a10:	7523      	strb	r3, [r4, #20]
        }
    }

    ble_hs_unlock();
   16a12:	f7fd fe9f 	bl	14754 <ble_hs_unlock>
}
   16a16:	b009      	add	sp, #36	; 0x24
   16a18:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16a1a:	bf00      	nop
   16a1c:	0001fbda 	.word	0x0001fbda
   16a20:	0001fbdd 	.word	0x0001fbdd
   16a24:	0001fc2c 	.word	0x0001fc2c
   16a28:	0001fbbc 	.word	0x0001fbbc
   16a2c:	20003b9c 	.word	0x20003b9c
   16a30:	0001fdec 	.word	0x0001fdec

00016a34 <ble_sm_build_authreq>:

uint8_t
ble_sm_build_authreq(void)
{
    return ble_hs_cfg.sm_bonding << 0  |
           ble_hs_cfg.sm_mitm << 2     |
   16a34:	4b03      	ldr	r3, [pc, #12]	; (16a44 <ble_sm_build_authreq+0x10>)
   16a36:	7bdb      	ldrb	r3, [r3, #15]
           ble_hs_cfg.sm_sc << 3       |
           ble_hs_cfg.sm_keypress << 4;
   16a38:	f003 001c 	and.w	r0, r3, #28
}

uint8_t
ble_sm_build_authreq(void)
{
    return ble_hs_cfg.sm_bonding << 0  |
   16a3c:	f3c3 0340 	ubfx	r3, r3, #1, #1
           ble_hs_cfg.sm_mitm << 2     |
           ble_hs_cfg.sm_sc << 3       |
           ble_hs_cfg.sm_keypress << 4;
}
   16a40:	4318      	orrs	r0, r3
   16a42:	4770      	bx	lr
   16a44:	20003b78 	.word	0x20003b78

00016a48 <ble_sm_sec_req_exec>:
 *****************************************************************************/

static void
ble_sm_sec_req_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                    void *arg)
{
   16a48:	b537      	push	{r0, r1, r2, r4, r5, lr}
   16a4a:	4605      	mov	r5, r0
   16a4c:	460c      	mov	r4, r1
    struct ble_sm_sec_req cmd;
    int rc;

    cmd.authreq = ble_sm_build_authreq();
   16a4e:	f7ff fff1 	bl	16a34 <ble_sm_build_authreq>
   16a52:	a902      	add	r1, sp, #8
   16a54:	f801 0d04 	strb.w	r0, [r1, #-4]!
    rc = ble_sm_sec_req_tx(proc->conn_handle, &cmd);
   16a58:	8968      	ldrh	r0, [r5, #10]
   16a5a:	f001 fb27 	bl	180ac <ble_sm_sec_req_tx>
    if (rc != 0) {
   16a5e:	b100      	cbz	r0, 16a62 <ble_sm_sec_req_exec+0x1a>
        res->app_status = rc;
   16a60:	6020      	str	r0, [r4, #0]
        return;
    }
}
   16a62:	b003      	add	sp, #12
   16a64:	bd30      	pop	{r4, r5, pc}

00016a66 <ble_sm_ioact_state>:
}

int
ble_sm_ioact_state(uint8_t action)
{
    switch (action) {
   16a66:	b138      	cbz	r0, 16a78 <ble_sm_ioact_state+0x12>
   16a68:	2803      	cmp	r0, #3
   16a6a:	d903      	bls.n	16a74 <ble_sm_ioact_state+0xe>
   16a6c:	2804      	cmp	r0, #4
   16a6e:	d103      	bne.n	16a78 <ble_sm_ioact_state+0x12>
    case BLE_SM_IOACT_NONE:
        return BLE_SM_PROC_STATE_NONE;

    case BLE_SM_IOACT_NUMCMP:
        return BLE_SM_PROC_STATE_DHKEY_CHECK;
   16a70:	200a      	movs	r0, #10
   16a72:	4770      	bx	lr

    case BLE_SM_IOACT_OOB:
    case BLE_SM_IOACT_INPUT:
    case BLE_SM_IOACT_DISP:
        return BLE_SM_PROC_STATE_CONFIRM;
   16a74:	2001      	movs	r0, #1
   16a76:	4770      	bx	lr
int
ble_sm_ioact_state(uint8_t action)
{
    switch (action) {
    case BLE_SM_IOACT_NONE:
        return BLE_SM_PROC_STATE_NONE;
   16a78:	20ff      	movs	r0, #255	; 0xff

    default:
        BLE_HS_DBG_ASSERT(0);
        return BLE_SM_PROC_STATE_NONE;
    }
}
   16a7a:	4770      	bx	lr

00016a7c <ble_sm_proc_can_advance>:

int
ble_sm_proc_can_advance(struct ble_sm_proc *proc)
{
   16a7c:	b510      	push	{r4, lr}
   16a7e:	4604      	mov	r4, r0
    uint8_t ioact;

    ioact = ble_sm_io_action(proc);
   16a80:	f7ff fa14 	bl	15eac <ble_sm_io_action>
    if (ble_sm_ioact_state(ioact) != proc->state) {
   16a84:	b2c0      	uxtb	r0, r0
   16a86:	f7ff ffee 	bl	16a66 <ble_sm_ioact_state>
   16a8a:	7b63      	ldrb	r3, [r4, #13]
   16a8c:	4298      	cmp	r0, r3
   16a8e:	d106      	bne.n	16a9e <ble_sm_proc_can_advance+0x22>
        return 1;
    }

    if (proc->flags & BLE_SM_PROC_F_IO_INJECTED &&
   16a90:	7a20      	ldrb	r0, [r4, #8]
   16a92:	f000 0006 	and.w	r0, r0, #6
   16a96:	1f83      	subs	r3, r0, #6
   16a98:	4258      	negs	r0, r3
   16a9a:	4158      	adcs	r0, r3
   16a9c:	bd10      	pop	{r4, pc}
{
    uint8_t ioact;

    ioact = ble_sm_io_action(proc);
    if (ble_sm_ioact_state(ioact) != proc->state) {
        return 1;
   16a9e:	2001      	movs	r0, #1

        return 1;
    }

    return 0;
}
   16aa0:	bd10      	pop	{r4, pc}
	...

00016aa4 <ble_sm_confirm_rx>:
}

static void
ble_sm_confirm_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   16aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_pair_confirm cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    uint8_t ioact;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CONFIRM_SZ);
   16aa6:	2110      	movs	r1, #16
}

static void
ble_sm_confirm_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   16aa8:	b08b      	sub	sp, #44	; 0x2c
   16aaa:	4606      	mov	r6, r0
    struct ble_sm_pair_confirm cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    uint8_t ioact;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CONFIRM_SZ);
   16aac:	4610      	mov	r0, r2
}

static void
ble_sm_confirm_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   16aae:	461c      	mov	r4, r3
   16ab0:	4617      	mov	r7, r2
    struct ble_sm_pair_confirm cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    uint8_t ioact;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CONFIRM_SZ);
   16ab2:	f7fe fd41 	bl	15538 <ble_hs_misc_pullup_base>
   16ab6:	4605      	mov	r5, r0
   16ab8:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   16aba:	b130      	cbz	r0, 16aca <ble_sm_confirm_rx+0x26>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   16abc:	2308      	movs	r3, #8
   16abe:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   16ac0:	7d23      	ldrb	r3, [r4, #20]
   16ac2:	f043 0302 	orr.w	r3, r3, #2
   16ac6:	7523      	strb	r3, [r4, #20]
   16ac8:	e053      	b.n	16b72 <ble_sm_confirm_rx+0xce>
        return;
    }

    ble_sm_pair_confirm_parse((*om)->om_data, (*om)->om_len, &cmd);
   16aca:	683b      	ldr	r3, [r7, #0]
   16acc:	aa06      	add	r2, sp, #24
   16ace:	6818      	ldr	r0, [r3, #0]
   16ad0:	88d9      	ldrh	r1, [r3, #6]
   16ad2:	f000 ff85 	bl	179e0 <ble_sm_pair_confirm_parse>
    BLE_SM_LOG_CMD(0, "confirm", conn_handle, ble_sm_pair_confirm_log, &cmd);
   16ad6:	4b28      	ldr	r3, [pc, #160]	; (16b78 <ble_sm_confirm_rx+0xd4>)
   16ad8:	9300      	str	r3, [sp, #0]
   16ada:	4b28      	ldr	r3, [pc, #160]	; (16b7c <ble_sm_confirm_rx+0xd8>)
   16adc:	9301      	str	r3, [sp, #4]
   16ade:	4b28      	ldr	r3, [pc, #160]	; (16b80 <ble_sm_confirm_rx+0xdc>)
   16ae0:	9302      	str	r3, [sp, #8]
   16ae2:	462a      	mov	r2, r5
   16ae4:	2104      	movs	r1, #4
   16ae6:	4b27      	ldr	r3, [pc, #156]	; (16b84 <ble_sm_confirm_rx+0xe0>)
   16ae8:	4827      	ldr	r0, [pc, #156]	; (16b88 <ble_sm_confirm_rx+0xe4>)
   16aea:	9603      	str	r6, [sp, #12]
   16aec:	f006 fb9c 	bl	1d228 <log_printf>
   16af0:	a806      	add	r0, sp, #24
   16af2:	f000 ff8b 	bl	17a0c <ble_sm_pair_confirm_log>
   16af6:	462a      	mov	r2, r5
   16af8:	4823      	ldr	r0, [pc, #140]	; (16b88 <ble_sm_confirm_rx+0xe4>)
   16afa:	4b24      	ldr	r3, [pc, #144]	; (16b8c <ble_sm_confirm_rx+0xe8>)
   16afc:	2104      	movs	r1, #4
   16afe:	f006 fb93 	bl	1d228 <log_printf>

    ble_hs_lock();
   16b02:	f7fd fe1f 	bl	14744 <ble_hs_lock>
    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_CONFIRM, -1, &prev);
   16b06:	4630      	mov	r0, r6
   16b08:	2101      	movs	r1, #1
   16b0a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16b0e:	ab05      	add	r3, sp, #20
   16b10:	f7ff fcec 	bl	164ec <ble_sm_proc_find>
    if (proc == NULL) {
   16b14:	4605      	mov	r5, r0
   16b16:	b910      	cbnz	r0, 16b1e <ble_sm_confirm_rx+0x7a>
        res->app_status = BLE_HS_ENOENT;
   16b18:	2305      	movs	r3, #5
   16b1a:	6023      	str	r3, [r4, #0]
   16b1c:	e027      	b.n	16b6e <ble_sm_confirm_rx+0xca>
    } else {
        memcpy(proc->confirm_peer, cmd.value, 16);
   16b1e:	ab06      	add	r3, sp, #24
   16b20:	f100 062b 	add.w	r6, r0, #43	; 0x2b
   16b24:	af0a      	add	r7, sp, #40	; 0x28
   16b26:	461a      	mov	r2, r3
   16b28:	ca03      	ldmia	r2!, {r0, r1}
   16b2a:	42ba      	cmp	r2, r7
   16b2c:	6030      	str	r0, [r6, #0]
   16b2e:	6071      	str	r1, [r6, #4]
   16b30:	4613      	mov	r3, r2
   16b32:	f106 0608 	add.w	r6, r6, #8
   16b36:	d1f6      	bne.n	16b26 <ble_sm_confirm_rx+0x82>

        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
   16b38:	7a2b      	ldrb	r3, [r5, #8]
   16b3a:	07db      	lsls	r3, r3, #31
   16b3c:	d502      	bpl.n	16b44 <ble_sm_confirm_rx+0xa0>
            proc->state = BLE_SM_PROC_STATE_RANDOM;
   16b3e:	2302      	movs	r3, #2
   16b40:	736b      	strb	r3, [r5, #13]
   16b42:	e010      	b.n	16b66 <ble_sm_confirm_rx+0xc2>
            res->execute = 1;
        } else {
            ioact = ble_sm_io_action(proc);
   16b44:	4628      	mov	r0, r5
   16b46:	f7ff f9b1 	bl	15eac <ble_sm_io_action>
            if (ble_sm_ioact_state(ioact) == proc->state) {
   16b4a:	b2c0      	uxtb	r0, r0
   16b4c:	f7ff ff8b 	bl	16a66 <ble_sm_ioact_state>
   16b50:	7b6b      	ldrb	r3, [r5, #13]
   16b52:	4298      	cmp	r0, r3
                proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
   16b54:	bf02      	ittt	eq
   16b56:	7a2b      	ldrbeq	r3, [r5, #8]
   16b58:	f043 0304 	orreq.w	r3, r3, #4
   16b5c:	722b      	strbeq	r3, [r5, #8]
            }
            if (ble_sm_proc_can_advance(proc)) {
   16b5e:	4628      	mov	r0, r5
   16b60:	f7ff ff8c 	bl	16a7c <ble_sm_proc_can_advance>
   16b64:	b118      	cbz	r0, 16b6e <ble_sm_confirm_rx+0xca>
                res->execute = 1;
   16b66:	7d23      	ldrb	r3, [r4, #20]
   16b68:	f043 0301 	orr.w	r3, r3, #1
   16b6c:	7523      	strb	r3, [r4, #20]
            }
        }
    }
    ble_hs_unlock();
   16b6e:	f7fd fdf1 	bl	14754 <ble_hs_unlock>
}
   16b72:	b00b      	add	sp, #44	; 0x2c
   16b74:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16b76:	bf00      	nop
   16b78:	0001fbda 	.word	0x0001fbda
   16b7c:	0001fbdd 	.word	0x0001fbdd
   16b80:	0001fc35 	.word	0x0001fc35
   16b84:	0001fbbc 	.word	0x0001fbbc
   16b88:	20003b9c 	.word	0x20003b9c
   16b8c:	0001fdec 	.word	0x0001fdec

00016b90 <ble_sm_pair_rsp_rx>:
}

static void
ble_sm_pair_rsp_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   16b90:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_pair_cmd rsp;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    uint8_t ioact;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CMD_SZ);
   16b92:	2106      	movs	r1, #6
}

static void
ble_sm_pair_rsp_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   16b94:	b089      	sub	sp, #36	; 0x24
   16b96:	4606      	mov	r6, r0
    struct ble_sm_pair_cmd rsp;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    uint8_t ioact;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CMD_SZ);
   16b98:	4610      	mov	r0, r2
}

static void
ble_sm_pair_rsp_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                   struct ble_sm_result *res)
{
   16b9a:	461d      	mov	r5, r3
   16b9c:	4617      	mov	r7, r2
    struct ble_sm_pair_cmd rsp;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;
    uint8_t ioact;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_CMD_SZ);
   16b9e:	f7fe fccb 	bl	15538 <ble_hs_misc_pullup_base>
   16ba2:	4604      	mov	r4, r0
   16ba4:	6028      	str	r0, [r5, #0]
    if (res->app_status != 0) {
   16ba6:	b120      	cbz	r0, 16bb2 <ble_sm_pair_rsp_rx+0x22>
        res->enc_cb = 1;
   16ba8:	7d2b      	ldrb	r3, [r5, #20]
   16baa:	f043 0302 	orr.w	r3, r3, #2
   16bae:	752b      	strb	r3, [r5, #20]
   16bb0:	e055      	b.n	16c5e <ble_sm_pair_rsp_rx+0xce>
        return;
    }

    ble_sm_pair_cmd_parse((*om)->om_data, (*om)->om_len, &rsp);
   16bb2:	683b      	ldr	r3, [r7, #0]
   16bb4:	aa06      	add	r2, sp, #24
   16bb6:	6818      	ldr	r0, [r3, #0]
   16bb8:	88d9      	ldrh	r1, [r3, #6]
   16bba:	f000 fe73 	bl	178a4 <ble_sm_pair_cmd_parse>
    BLE_SM_LOG_CMD(0, "pair rsp", conn_handle, ble_sm_pair_cmd_log, &rsp);
   16bbe:	4b29      	ldr	r3, [pc, #164]	; (16c64 <ble_sm_pair_rsp_rx+0xd4>)
   16bc0:	9300      	str	r3, [sp, #0]
   16bc2:	4b29      	ldr	r3, [pc, #164]	; (16c68 <ble_sm_pair_rsp_rx+0xd8>)
   16bc4:	9301      	str	r3, [sp, #4]
   16bc6:	4b29      	ldr	r3, [pc, #164]	; (16c6c <ble_sm_pair_rsp_rx+0xdc>)
   16bc8:	9302      	str	r3, [sp, #8]
   16bca:	4622      	mov	r2, r4
   16bcc:	2104      	movs	r1, #4
   16bce:	4b28      	ldr	r3, [pc, #160]	; (16c70 <ble_sm_pair_rsp_rx+0xe0>)
   16bd0:	4828      	ldr	r0, [pc, #160]	; (16c74 <ble_sm_pair_rsp_rx+0xe4>)
   16bd2:	9603      	str	r6, [sp, #12]
   16bd4:	f006 fb28 	bl	1d228 <log_printf>
   16bd8:	a806      	add	r0, sp, #24
   16bda:	f000 fe9f 	bl	1791c <ble_sm_pair_cmd_log>
   16bde:	4622      	mov	r2, r4
   16be0:	4824      	ldr	r0, [pc, #144]	; (16c74 <ble_sm_pair_rsp_rx+0xe4>)
   16be2:	4b25      	ldr	r3, [pc, #148]	; (16c78 <ble_sm_pair_rsp_rx+0xe8>)
   16be4:	2104      	movs	r1, #4
   16be6:	f006 fb1f 	bl	1d228 <log_printf>

    ble_hs_lock();
   16bea:	f7fd fdab 	bl	14744 <ble_hs_lock>
    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PAIR, 1, &prev);
   16bee:	4621      	mov	r1, r4
   16bf0:	4630      	mov	r0, r6
   16bf2:	2201      	movs	r2, #1
   16bf4:	ab05      	add	r3, sp, #20
   16bf6:	f7ff fc79 	bl	164ec <ble_sm_proc_find>
    if (proc != NULL) {
   16bfa:	4604      	mov	r4, r0
   16bfc:	b368      	cbz	r0, 16c5a <ble_sm_pair_rsp_rx+0xca>
        proc->pair_rsp = rsp;
   16bfe:	9806      	ldr	r0, [sp, #24]
   16c00:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   16c04:	f8c4 0015 	str.w	r0, [r4, #21]
   16c08:	f8a4 3019 	strh.w	r3, [r4, #25]
        if (!ble_sm_pair_cmd_is_valid(&rsp)) {
   16c0c:	a806      	add	r0, sp, #24
   16c0e:	f000 fe56 	bl	178be <ble_sm_pair_cmd_is_valid>
   16c12:	b928      	cbnz	r0, 16c20 <ble_sm_pair_rsp_rx+0x90>
            res->sm_err = BLE_SM_ERR_INVAL;
   16c14:	230a      	movs	r3, #10
   16c16:	712b      	strb	r3, [r5, #4]
            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
   16c18:	f240 430a 	movw	r3, #1034	; 0x40a
   16c1c:	602b      	str	r3, [r5, #0]
   16c1e:	e01c      	b.n	16c5a <ble_sm_pair_rsp_rx+0xca>
        } else {
            ble_sm_pair_cfg(proc);
   16c20:	4620      	mov	r0, r4
   16c22:	f7ff fbc9 	bl	163b8 <ble_sm_pair_cfg>
 *****************************************************************************/

static uint8_t
ble_sm_state_after_pair(struct ble_sm_proc *proc)
{
    if (proc->flags & BLE_SM_PROC_F_SC) {
   16c26:	7a23      	ldrb	r3, [r4, #8]
        return BLE_SM_PROC_STATE_PUBLIC_KEY;
    } else {
        return BLE_SM_PROC_STATE_CONFIRM;
   16c28:	f013 0f10 	tst.w	r3, #16
   16c2c:	bf14      	ite	ne
   16c2e:	2309      	movne	r3, #9
   16c30:	2301      	moveq	r3, #1
            res->sm_err = BLE_SM_ERR_INVAL;
            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
        } else {
            ble_sm_pair_cfg(proc);

            proc->state = ble_sm_state_after_pair(proc);
   16c32:	7363      	strb	r3, [r4, #13]
            ioact = ble_sm_io_action(proc);
   16c34:	4620      	mov	r0, r4
   16c36:	f7ff f939 	bl	15eac <ble_sm_io_action>
   16c3a:	b2c6      	uxtb	r6, r0
            if (ble_sm_ioact_state(ioact) == proc->state) {
   16c3c:	4630      	mov	r0, r6
   16c3e:	f7ff ff12 	bl	16a66 <ble_sm_ioact_state>
   16c42:	7b63      	ldrb	r3, [r4, #13]
   16c44:	4298      	cmp	r0, r3
                res->passkey_params.action = ioact;
   16c46:	bf08      	it	eq
   16c48:	722e      	strbeq	r6, [r5, #8]
            }
            if (ble_sm_proc_can_advance(proc)) {
   16c4a:	4620      	mov	r0, r4
   16c4c:	f7ff ff16 	bl	16a7c <ble_sm_proc_can_advance>
   16c50:	b118      	cbz	r0, 16c5a <ble_sm_pair_rsp_rx+0xca>
                res->execute = 1;
   16c52:	7d2b      	ldrb	r3, [r5, #20]
   16c54:	f043 0301 	orr.w	r3, r3, #1
   16c58:	752b      	strb	r3, [r5, #20]
            }
        }
    }

    ble_hs_unlock();
   16c5a:	f7fd fd7b 	bl	14754 <ble_hs_unlock>
}
   16c5e:	b009      	add	sp, #36	; 0x24
   16c60:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16c62:	bf00      	nop
   16c64:	0001fbda 	.word	0x0001fbda
   16c68:	0001fbdd 	.word	0x0001fbdd
   16c6c:	0001fc3d 	.word	0x0001fc3d
   16c70:	0001fbbc 	.word	0x0001fbbc
   16c74:	20003b9c 	.word	0x20003b9c
   16c78:	0001fdec 	.word	0x0001fdec

00016c7c <ble_sm_process_result>:
    cb(proc, res, arg);
}

void
ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res)
{
   16c7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16c80:	4607      	mov	r7, r0
   16c82:	b09a      	sub	sp, #104	; 0x68
   16c84:	460d      	mov	r5, r1
    int rm;

    rm = 0;

    while (1) {
        ble_hs_lock();
   16c86:	f7fd fd5d 	bl	14744 <ble_hs_lock>
        proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1,
   16c8a:	4638      	mov	r0, r7
   16c8c:	21ff      	movs	r1, #255	; 0xff
   16c8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16c92:	ab03      	add	r3, sp, #12
   16c94:	f7ff fc2a 	bl	164ec <ble_sm_proc_find>
                                &prev);

        if (proc != NULL) {
   16c98:	4604      	mov	r4, r0
   16c9a:	b308      	cbz	r0, 16ce0 <ble_sm_process_result+0x64>
            if (res->execute) {
   16c9c:	7d2b      	ldrb	r3, [r5, #20]
   16c9e:	07de      	lsls	r6, r3, #31
   16ca0:	d50e      	bpl.n	16cc0 <ble_sm_process_result+0x44>
ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
{
    ble_sm_state_fn *cb;

    BLE_HS_DBG_ASSERT(proc->state < BLE_SM_PROC_STATE_CNT);
    cb = ble_sm_state_dispatch[proc->state];
   16ca2:	7b42      	ldrb	r2, [r0, #13]
   16ca4:	4b47      	ldr	r3, [pc, #284]	; (16dc4 <ble_sm_process_result+0x148>)
        proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1,
                                &prev);

        if (proc != NULL) {
            if (res->execute) {
                ble_sm_exec(proc, res, res->state_arg);
   16ca6:	f8d5 8010 	ldr.w	r8, [r5, #16]
ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
{
    ble_sm_state_fn *cb;

    BLE_HS_DBG_ASSERT(proc->state < BLE_SM_PROC_STATE_CNT);
    cb = ble_sm_state_dispatch[proc->state];
   16caa:	f853 6022 	ldr.w	r6, [r3, r2, lsl #2]
    BLE_HS_DBG_ASSERT(cb != NULL);

    memset(res, 0, sizeof *res);
   16cae:	2100      	movs	r1, #0
   16cb0:	2218      	movs	r2, #24
   16cb2:	4628      	mov	r0, r5
   16cb4:	f7f2 f9ad 	bl	9012 <memset>

    cb(proc, res, arg);
   16cb8:	4620      	mov	r0, r4
   16cba:	4629      	mov	r1, r5
   16cbc:	4642      	mov	r2, r8
   16cbe:	47b0      	blx	r6

            if (res->app_status != 0) {
                rm = 1;
            }

            if (proc->state == BLE_SM_PROC_STATE_NONE) {
   16cc0:	7b63      	ldrb	r3, [r4, #13]
        if (proc != NULL) {
            if (res->execute) {
                ble_sm_exec(proc, res, res->state_arg);
            }

            if (res->app_status != 0) {
   16cc2:	682e      	ldr	r6, [r5, #0]
                rm = 1;
            }

            if (proc->state == BLE_SM_PROC_STATE_NONE) {
   16cc4:	2bff      	cmp	r3, #255	; 0xff
   16cc6:	d000      	beq.n	16cca <ble_sm_process_result+0x4e>
                rm = 1;
            }

            if (rm) {
   16cc8:	b126      	cbz	r6, 16cd4 <ble_sm_process_result+0x58>
                ble_sm_proc_remove(proc, prev);
   16cca:	9803      	ldr	r0, [sp, #12]
   16ccc:	f7ff fa28 	bl	16120 <ble_sm_proc_remove.isra.1>
   16cd0:	2601      	movs	r6, #1
   16cd2:	e006      	b.n	16ce2 <ble_sm_process_result+0x66>

static void
ble_sm_proc_set_timer(struct ble_sm_proc *proc)
{
    /* Set a timeout of 30 seconds. */
    proc->exp_os_ticks = os_time_get() + BLE_SM_TIMEOUT_OS_TICKS;
   16cd4:	f7f3 fd74 	bl	a7c0 <os_time_get>
   16cd8:	f500 6070 	add.w	r0, r0, #3840	; 0xf00
   16cdc:	6060      	str	r0, [r4, #4]
   16cde:	e000      	b.n	16ce2 <ble_sm_process_result+0x66>
   16ce0:	4606      	mov	r6, r0
            } else {
                ble_sm_proc_set_timer(proc);
            }
        }

        if (res->sm_err != 0) {
   16ce2:	7929      	ldrb	r1, [r5, #4]
   16ce4:	b111      	cbz	r1, 16cec <ble_sm_process_result+0x70>
            ble_sm_pair_fail_tx(conn_handle, res->sm_err);
   16ce6:	4638      	mov	r0, r7
   16ce8:	f000 ff5e 	bl	17ba8 <ble_sm_pair_fail_tx>
        }

        ble_hs_unlock();
   16cec:	f7fd fd32 	bl	14754 <ble_hs_unlock>

        if (proc == NULL) {
   16cf0:	2c00      	cmp	r4, #0
   16cf2:	d064      	beq.n	16dbe <ble_sm_process_result+0x142>
            break;
        }

        if (res->enc_cb) {
   16cf4:	7d2a      	ldrb	r2, [r5, #20]
   16cf6:	0790      	lsls	r0, r2, #30
   16cf8:	d505      	bpl.n	16d06 <ble_sm_process_result+0x8a>
            BLE_HS_DBG_ASSERT(proc == NULL || rm);
            ble_gap_enc_event(conn_handle, res->app_status, res->restore);
   16cfa:	4638      	mov	r0, r7
   16cfc:	6829      	ldr	r1, [r5, #0]
   16cfe:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   16d02:	f7fb fb15 	bl	12330 <ble_gap_enc_event>
        }

        if (res->app_status == 0 &&
   16d06:	682b      	ldr	r3, [r5, #0]
   16d08:	b933      	cbnz	r3, 16d18 <ble_sm_process_result+0x9c>
   16d0a:	7a2b      	ldrb	r3, [r5, #8]
   16d0c:	b123      	cbz	r3, 16d18 <ble_sm_process_result+0x9c>
            res->passkey_params.action != BLE_SM_IOACT_NONE) {

            ble_gap_passkey_event(conn_handle, &res->passkey_params);
   16d0e:	4638      	mov	r0, r7
   16d10:	f105 0108 	add.w	r1, r5, #8
   16d14:	f7fb fae6 	bl	122e4 <ble_gap_passkey_event>
        }

        /* Persist keys if bonding has successfully completed. */
        if (res->app_status == 0    &&
   16d18:	682b      	ldr	r3, [r5, #0]
   16d1a:	2b00      	cmp	r3, #0
   16d1c:	d13f      	bne.n	16d9e <ble_sm_process_result+0x122>
   16d1e:	2e00      	cmp	r6, #0
   16d20:	d042      	beq.n	16da8 <ble_sm_process_result+0x12c>
            rm                      &&
            proc->flags & BLE_SM_PROC_F_BONDING) {
   16d22:	7a23      	ldrb	r3, [r4, #8]
            ble_gap_passkey_event(conn_handle, &res->passkey_params);
        }

        /* Persist keys if bonding has successfully completed. */
        if (res->app_status == 0    &&
            rm                      &&
   16d24:	0699      	lsls	r1, r3, #26
   16d26:	d53b      	bpl.n	16da0 <ble_sm_process_result+0x124>
    struct ble_hs_conn *conn;
    uint8_t peer_addr[8];
    uint8_t peer_addr_type;
    int authenticated;

    ble_hs_lock();
   16d28:	f7fd fd0c 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(proc->conn_handle);
   16d2c:	8960      	ldrh	r0, [r4, #10]
   16d2e:	f7fe fab1 	bl	15294 <ble_hs_conn_find>
    BLE_HS_DBG_ASSERT(conn != NULL);

    /* If we got an identity address, use that for key storage. */
    if (proc->peer_keys.addr_valid) {
   16d32:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
   16d36:	06da      	lsls	r2, r3, #27
    uint8_t peer_addr_type;
    int authenticated;

    ble_hs_lock();

    conn = ble_hs_conn_find(proc->conn_handle);
   16d38:	4605      	mov	r5, r0
    BLE_HS_DBG_ASSERT(conn != NULL);

    /* If we got an identity address, use that for key storage. */
    if (proc->peer_keys.addr_valid) {
   16d3a:	d508      	bpl.n	16d4e <ble_sm_process_result+0xd2>
        peer_addr_type = proc->peer_keys.addr_type;
        memcpy(peer_addr, proc->peer_keys.addr, sizeof peer_addr);
   16d3c:	4622      	mov	r2, r4
   16d3e:	ab04      	add	r3, sp, #16
   16d40:	f852 0ff9 	ldr.w	r0, [r2, #249]!
    conn = ble_hs_conn_find(proc->conn_handle);
    BLE_HS_DBG_ASSERT(conn != NULL);

    /* If we got an identity address, use that for key storage. */
    if (proc->peer_keys.addr_valid) {
        peer_addr_type = proc->peer_keys.addr_type;
   16d44:	f894 70c8 	ldrb.w	r7, [r4, #200]	; 0xc8
        memcpy(peer_addr, proc->peer_keys.addr, sizeof peer_addr);
   16d48:	6851      	ldr	r1, [r2, #4]
   16d4a:	c303      	stmia	r3!, {r0, r1}
   16d4c:	e009      	b.n	16d62 <ble_sm_process_result+0xe6>
    } else {
        peer_addr_type = ble_hs_misc_addr_type_to_id(conn->bhc_peer_addr_type);
   16d4e:	7980      	ldrb	r0, [r0, #6]
   16d50:	f7fe fc2a 	bl	155a8 <ble_hs_misc_addr_type_to_id>
        memcpy(peer_addr, conn->bhc_peer_addr, sizeof peer_addr);
   16d54:	462b      	mov	r3, r5
    /* If we got an identity address, use that for key storage. */
    if (proc->peer_keys.addr_valid) {
        peer_addr_type = proc->peer_keys.addr_type;
        memcpy(peer_addr, proc->peer_keys.addr, sizeof peer_addr);
    } else {
        peer_addr_type = ble_hs_misc_addr_type_to_id(conn->bhc_peer_addr_type);
   16d56:	4607      	mov	r7, r0
        memcpy(peer_addr, conn->bhc_peer_addr, sizeof peer_addr);
   16d58:	f853 0f08 	ldr.w	r0, [r3, #8]!
   16d5c:	6859      	ldr	r1, [r3, #4]
   16d5e:	aa04      	add	r2, sp, #16
   16d60:	c203      	stmia	r2!, {r0, r1}
    }

    ble_hs_unlock();
   16d62:	f7fd fcf7 	bl	14754 <ble_hs_unlock>

    authenticated = proc->flags & BLE_SM_PROC_F_AUTHENTICATED;
   16d66:	7a25      	ldrb	r5, [r4, #8]
   16d68:	f005 0508 	and.w	r5, r5, #8

    ble_sm_fill_store_value(peer_addr_type, peer_addr, authenticated,
   16d6c:	ae06      	add	r6, sp, #24
        memcpy(peer_addr, conn->bhc_peer_addr, sizeof peer_addr);
    }

    ble_hs_unlock();

    authenticated = proc->flags & BLE_SM_PROC_F_AUTHENTICATED;
   16d6e:	b2ed      	uxtb	r5, r5

    ble_sm_fill_store_value(peer_addr_type, peer_addr, authenticated,
   16d70:	a904      	add	r1, sp, #16
   16d72:	462a      	mov	r2, r5
   16d74:	f104 0370 	add.w	r3, r4, #112	; 0x70
   16d78:	4638      	mov	r0, r7
   16d7a:	9600      	str	r6, [sp, #0]
   16d7c:	f7ff f89d 	bl	15eba <ble_sm_fill_store_value>
                            &proc->our_keys, &value_sec);
    ble_store_write_our_sec(&value_sec);
   16d80:	4630      	mov	r0, r6
   16d82:	f001 fb6d 	bl	18460 <ble_store_write_our_sec>

    ble_sm_fill_store_value(peer_addr_type, peer_addr, authenticated,
   16d86:	4638      	mov	r0, r7
   16d88:	9600      	str	r6, [sp, #0]
   16d8a:	a904      	add	r1, sp, #16
   16d8c:	462a      	mov	r2, r5
   16d8e:	f104 03b8 	add.w	r3, r4, #184	; 0xb8
   16d92:	f7ff f892 	bl	15eba <ble_sm_fill_store_value>
                            &proc->peer_keys, &value_sec);
    ble_store_write_peer_sec(&value_sec);
   16d96:	4630      	mov	r0, r6
   16d98:	f001 fb66 	bl	18468 <ble_store_write_peer_sec>
   16d9c:	e000      	b.n	16da0 <ble_sm_process_result+0x124>
            proc->flags & BLE_SM_PROC_F_BONDING) {

            ble_sm_persist_keys(proc);
        }

        if (rm) {
   16d9e:	b11e      	cbz	r6, 16da8 <ble_sm_process_result+0x12c>
            ble_sm_proc_free(proc);
   16da0:	4620      	mov	r0, r4
   16da2:	f7ff f9a5 	bl	160f0 <ble_sm_proc_free>
            break;
   16da6:	e00a      	b.n	16dbe <ble_sm_process_result+0x142>
        }

        if (!res->execute) {
   16da8:	7d2b      	ldrb	r3, [r5, #20]
   16daa:	07db      	lsls	r3, r3, #31
   16dac:	d507      	bpl.n	16dbe <ble_sm_process_result+0x142>
            break;
        }

        memset(res, 0, sizeof *res);
   16dae:	4628      	mov	r0, r5
   16db0:	2100      	movs	r1, #0
   16db2:	2218      	movs	r2, #24
   16db4:	f7f2 f92d 	bl	9012 <memset>
        res->execute = 1;
   16db8:	2301      	movs	r3, #1
   16dba:	752b      	strb	r3, [r5, #20]
    }
   16dbc:	e763      	b.n	16c86 <ble_sm_process_result+0xa>
}
   16dbe:	b01a      	add	sp, #104	; 0x68
   16dc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   16dc4:	0001fc68 	.word	0x0001fc68

00016dc8 <ble_sm_enc_event_rx>:
    res->app_status = ble_sm_start_encrypt_tx(cmd);
}

static void
ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
{
   16dc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   16dcc:	b087      	sub	sp, #28
   16dce:	4607      	mov	r7, r0
   16dd0:	4689      	mov	r9, r1
   16dd2:	4690      	mov	r8, r2
    struct ble_sm_result res;
    struct ble_sm_proc *proc;
    int authenticated;
    int bonded;

    memset(&res, 0, sizeof res);
   16dd4:	2100      	movs	r1, #0
   16dd6:	2218      	movs	r2, #24
   16dd8:	4668      	mov	r0, sp
   16dda:	f7f2 f91a 	bl	9012 <memset>

    /* Assume no change in authenticated and bonded statuses. */
    authenticated = 0;
    bonded = 0;

    ble_hs_lock();
   16dde:	f7fd fcb1 	bl	14744 <ble_hs_lock>

    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
   16de2:	4638      	mov	r0, r7
   16de4:	21ff      	movs	r1, #255	; 0xff
   16de6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16dea:	2300      	movs	r3, #0
   16dec:	f7ff fb7e 	bl	164ec <ble_sm_proc_find>
    if (proc != NULL) {
   16df0:	4604      	mov	r4, r0
   16df2:	b388      	cbz	r0, 16e58 <ble_sm_enc_event_rx+0x90>
        switch (proc->state) {
   16df4:	7b43      	ldrb	r3, [r0, #13]
   16df6:	2b05      	cmp	r3, #5
   16df8:	d00f      	beq.n	16e1a <ble_sm_enc_event_rx+0x52>
   16dfa:	2b06      	cmp	r3, #6
   16dfc:	f04f 03ff 	mov.w	r3, #255	; 0xff
   16e00:	d123      	bne.n	16e4a <ble_sm_enc_event_rx+0x82>
            /* A secure link is being restored via the encryption
             * procedure.  Keys were exchanged during pairing; they don't
             * get exchanged again now.  Procedure is complete.
             */
            BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
            proc->state = BLE_SM_PROC_STATE_NONE;
   16e02:	7343      	strb	r3, [r0, #13]
            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
                authenticated = 1;
            }
            bonded = 1;
            res.restore = 1;
   16e04:	f89d 3014 	ldrb.w	r3, [sp, #20]
             * procedure.  Keys were exchanged during pairing; they don't
             * get exchanged again now.  Procedure is complete.
             */
            BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
            proc->state = BLE_SM_PROC_STATE_NONE;
            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
   16e08:	7a05      	ldrb	r5, [r0, #8]
                authenticated = 1;
            }
            bonded = 1;
            res.restore = 1;
   16e0a:	f043 0308 	orr.w	r3, r3, #8
             * procedure.  Keys were exchanged during pairing; they don't
             * get exchanged again now.  Procedure is complete.
             */
            BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
            proc->state = BLE_SM_PROC_STATE_NONE;
            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
   16e0e:	f3c5 05c0 	ubfx	r5, r5, #3, #1
                authenticated = 1;
            }
            bonded = 1;
            res.restore = 1;
   16e12:	f88d 3014 	strb.w	r3, [sp, #20]
            BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
            proc->state = BLE_SM_PROC_STATE_NONE;
            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
                authenticated = 1;
            }
            bonded = 1;
   16e16:	2601      	movs	r6, #1
            res.restore = 1;
            break;
   16e18:	e03b      	b.n	16e92 <ble_sm_enc_event_rx+0xca>
        switch (proc->state) {
        case BLE_SM_PROC_STATE_ENC_START:
            /* We are completing a pairing procedure; keys may need to be
             * exchanged.
             */
            if (evt_status == 0) {
   16e1a:	f1b9 0f00 	cmp.w	r9, #0
   16e1e:	d10d      	bne.n	16e3c <ble_sm_enc_event_rx+0x74>
                /* If the responder has any keys to send, it sends them
                 * first.
                 */
                proc->state = BLE_SM_PROC_STATE_KEY_EXCH;
   16e20:	2307      	movs	r3, #7
   16e22:	7343      	strb	r3, [r0, #13]
                if (!(proc->flags & BLE_SM_PROC_F_INITIATOR) ||
   16e24:	7a03      	ldrb	r3, [r0, #8]
   16e26:	07db      	lsls	r3, r3, #31
   16e28:	d501      	bpl.n	16e2e <ble_sm_enc_event_rx+0x66>
   16e2a:	7b83      	ldrb	r3, [r0, #14]
   16e2c:	b943      	cbnz	r3, 16e40 <ble_sm_enc_event_rx+0x78>
                    proc->rx_key_flags == 0) {

                    res.execute = 1;
   16e2e:	f89d 3014 	ldrb.w	r3, [sp, #20]
   16e32:	f043 0301 	orr.w	r3, r3, #1
   16e36:	f88d 3014 	strb.w	r3, [sp, #20]
   16e3a:	e001      	b.n	16e40 <ble_sm_enc_event_rx+0x78>
                }
            } else {
                /* Failure or no keys to exchange; procedure is complete. */
                proc->state = BLE_SM_PROC_STATE_NONE;
   16e3c:	23ff      	movs	r3, #255	; 0xff
   16e3e:	7343      	strb	r3, [r0, #13]
            }
            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
   16e40:	7a25      	ldrb	r5, [r4, #8]

    memset(&res, 0, sizeof res);

    /* Assume no change in authenticated and bonded statuses. */
    authenticated = 0;
    bonded = 0;
   16e42:	2600      	movs	r6, #0
                }
            } else {
                /* Failure or no keys to exchange; procedure is complete. */
                proc->state = BLE_SM_PROC_STATE_NONE;
            }
            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
   16e44:	f3c5 05c0 	ubfx	r5, r5, #3, #1
   16e48:	e023      	b.n	16e92 <ble_sm_enc_event_rx+0xca>
        default:
            /* The encryption change event is unexpected.  We take the
             * controller at its word that the state has changed and we
             * terminate the procedure.
             */
            proc->state = BLE_SM_PROC_STATE_NONE;
   16e4a:	7343      	strb	r3, [r0, #13]

    memset(&res, 0, sizeof res);

    /* Assume no change in authenticated and bonded statuses. */
    authenticated = 0;
    bonded = 0;
   16e4c:	2600      	movs	r6, #0
            /* The encryption change event is unexpected.  We take the
             * controller at its word that the state has changed and we
             * terminate the procedure.
             */
            proc->state = BLE_SM_PROC_STATE_NONE;
            res.sm_err = BLE_SM_ERR_UNSPECIFIED;
   16e4e:	2308      	movs	r3, #8
   16e50:	f88d 3004 	strb.w	r3, [sp, #4]
    int bonded;

    memset(&res, 0, sizeof res);

    /* Assume no change in authenticated and bonded statuses. */
    authenticated = 0;
   16e54:	4635      	mov	r5, r6
             * controller at its word that the state has changed and we
             * terminate the procedure.
             */
            proc->state = BLE_SM_PROC_STATE_NONE;
            res.sm_err = BLE_SM_ERR_UNSPECIFIED;
            break;
   16e56:	e01c      	b.n	16e92 <ble_sm_enc_event_rx+0xca>
        }
    }

    if (evt_status == 0) {
   16e58:	f1b9 0f00 	cmp.w	r9, #0
   16e5c:	d136      	bne.n	16ecc <ble_sm_enc_event_rx+0x104>

    memset(&res, 0, sizeof res);

    /* Assume no change in authenticated and bonded statuses. */
    authenticated = 0;
    bonded = 0;
   16e5e:	464e      	mov	r6, r9
    int bonded;

    memset(&res, 0, sizeof res);

    /* Assume no change in authenticated and bonded statuses. */
    authenticated = 0;
   16e60:	464d      	mov	r5, r9
ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
                        int authenticated, int bonded)
{
    struct ble_hs_conn *conn;

    conn = ble_hs_conn_find(conn_handle);
   16e62:	4638      	mov	r0, r7
   16e64:	f7fe fa16 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   16e68:	b3b8      	cbz	r0, 16eda <ble_sm_enc_event_rx+0x112>
        conn->bhc_sec_state.encrypted = encrypted;
   16e6a:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
   16e6e:	f368 0300 	bfi	r3, r8, #0, #1
   16e72:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44

        /* Authentication and bonding are never revoked from a secure link */
        if (authenticated) {
   16e76:	b125      	cbz	r5, 16e82 <ble_sm_enc_event_rx+0xba>
            conn->bhc_sec_state.authenticated = 1;
   16e78:	b2db      	uxtb	r3, r3
   16e7a:	f043 0302 	orr.w	r3, r3, #2
   16e7e:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
        }
        if (bonded) {
   16e82:	b356      	cbz	r6, 16eda <ble_sm_enc_event_rx+0x112>
            conn->bhc_sec_state.bonded = 1;
   16e84:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
   16e88:	f043 0304 	orr.w	r3, r3, #4
   16e8c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
   16e90:	e023      	b.n	16eda <ble_sm_enc_event_rx+0x112>
            res.sm_err = BLE_SM_ERR_UNSPECIFIED;
            break;
        }
    }

    if (evt_status == 0) {
   16e92:	f1b9 0f00 	cmp.w	r9, #0
   16e96:	d0e4      	beq.n	16e62 <ble_sm_enc_event_rx+0x9a>

    /* Unless keys need to be exchanged, notify the application of the security
     * change.  If key exchange is pending, the application callback is
     * triggered after exchange completes.
     */
    if (proc == NULL || proc->state == BLE_SM_PROC_STATE_NONE) {
   16e98:	7b63      	ldrb	r3, [r4, #13]
   16e9a:	2bff      	cmp	r3, #255	; 0xff
   16e9c:	d10d      	bne.n	16eba <ble_sm_enc_event_rx+0xf2>
        res.enc_cb = 1;
   16e9e:	f89d 3014 	ldrb.w	r3, [sp, #20]
   16ea2:	f043 0302 	orr.w	r3, r3, #2
   16ea6:	f88d 3014 	strb.w	r3, [sp, #20]
        res.app_status = BLE_HS_HCI_ERR(evt_status);
   16eaa:	f1b9 0f00 	cmp.w	r9, #0
   16eae:	d002      	beq.n	16eb6 <ble_sm_enc_event_rx+0xee>
   16eb0:	f509 7400 	add.w	r4, r9, #512	; 0x200
   16eb4:	e000      	b.n	16eb8 <ble_sm_enc_event_rx+0xf0>
   16eb6:	464c      	mov	r4, r9
   16eb8:	9400      	str	r4, [sp, #0]
    }

    ble_hs_unlock();
   16eba:	f7fd fc4b 	bl	14754 <ble_hs_unlock>

    ble_sm_process_result(conn_handle, &res);
   16ebe:	4638      	mov	r0, r7
   16ec0:	4669      	mov	r1, sp
   16ec2:	f7ff fedb 	bl	16c7c <ble_sm_process_result>
}
   16ec6:	b007      	add	sp, #28
   16ec8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    /* Unless keys need to be exchanged, notify the application of the security
     * change.  If key exchange is pending, the application callback is
     * triggered after exchange completes.
     */
    if (proc == NULL || proc->state == BLE_SM_PROC_STATE_NONE) {
        res.enc_cb = 1;
   16ecc:	f89d 3014 	ldrb.w	r3, [sp, #20]
   16ed0:	f043 0302 	orr.w	r3, r3, #2
   16ed4:	f88d 3014 	strb.w	r3, [sp, #20]
   16ed8:	e7ea      	b.n	16eb0 <ble_sm_enc_event_rx+0xe8>

    /* Unless keys need to be exchanged, notify the application of the security
     * change.  If key exchange is pending, the application callback is
     * triggered after exchange completes.
     */
    if (proc == NULL || proc->state == BLE_SM_PROC_STATE_NONE) {
   16eda:	2c00      	cmp	r4, #0
   16edc:	d1dc      	bne.n	16e98 <ble_sm_enc_event_rx+0xd0>
        res.enc_cb = 1;
   16ede:	f89d 3014 	ldrb.w	r3, [sp, #20]
   16ee2:	f043 0302 	orr.w	r3, r3, #2
   16ee6:	f88d 3014 	strb.w	r3, [sp, #20]
   16eea:	e7e5      	b.n	16eb8 <ble_sm_enc_event_rx+0xf0>

00016eec <ble_sm_rx>:
    return res.app_status;
}

static int
ble_sm_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   16eec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    struct ble_sm_result res;
    ble_sm_rx_fn *rx_cb;
    uint8_t op;
    int rc;

    STATS_INC(ble_l2cap_stats, sm_rx);
   16ef0:	4a18      	ldr	r2, [pc, #96]	; (16f54 <ble_sm_rx+0x68>)
   16ef2:	6b13      	ldr	r3, [r2, #48]	; 0x30
    return res.app_status;
}

static int
ble_sm_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   16ef4:	b088      	sub	sp, #32
    struct ble_sm_result res;
    ble_sm_rx_fn *rx_cb;
    uint8_t op;
    int rc;

    STATS_INC(ble_l2cap_stats, sm_rx);
   16ef6:	3301      	adds	r3, #1
   16ef8:	6313      	str	r3, [r2, #48]	; 0x30
    return res.app_status;
}

static int
ble_sm_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   16efa:	4606      	mov	r6, r0
   16efc:	460c      	mov	r4, r1
    uint8_t op;
    int rc;

    STATS_INC(ble_l2cap_stats, sm_rx);

    rc = os_mbuf_copydata(*om, 0, 1, &op);
   16efe:	6808      	ldr	r0, [r1, #0]
   16f00:	2201      	movs	r2, #1
   16f02:	2100      	movs	r1, #0
   16f04:	f10d 0307 	add.w	r3, sp, #7
   16f08:	f7f3 f8b2 	bl	a070 <os_mbuf_copydata>
    if (rc != 0) {
   16f0c:	4680      	mov	r8, r0
   16f0e:	b9d8      	cbnz	r0, 16f48 <ble_sm_rx+0x5c>
        return BLE_HS_EBADDATA;
    }

    /* Strip L2CAP SM header from the front of the mbuf. */
    os_mbuf_adj(*om, 1);
   16f10:	6820      	ldr	r0, [r4, #0]
   16f12:	2101      	movs	r1, #1
   16f14:	f7f3 f8d3 	bl	a0be <os_mbuf_adj>

    rx_cb = ble_sm_dispatch_get(op);
   16f18:	f89d 5007 	ldrb.w	r5, [sp, #7]
}

static ble_sm_rx_fn *
ble_sm_dispatch_get(uint8_t op)
{
    if (op >= sizeof ble_sm_dispatch / sizeof ble_sm_dispatch[0]) {
   16f1c:	2d0e      	cmp	r5, #14
   16f1e:	d815      	bhi.n	16f4c <ble_sm_rx+0x60>
        return NULL;
    }

    return ble_sm_dispatch[op];
   16f20:	4b0d      	ldr	r3, [pc, #52]	; (16f58 <ble_sm_rx+0x6c>)
   16f22:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]

    /* Strip L2CAP SM header from the front of the mbuf. */
    os_mbuf_adj(*om, 1);

    rx_cb = ble_sm_dispatch_get(op);
    if (rx_cb != NULL) {
   16f26:	b18f      	cbz	r7, 16f4c <ble_sm_rx+0x60>
        memset(&res, 0, sizeof res);
   16f28:	4641      	mov	r1, r8
   16f2a:	2218      	movs	r2, #24
   16f2c:	a802      	add	r0, sp, #8
   16f2e:	f7f2 f870 	bl	9012 <memset>

        rx_cb(conn_handle, op, om, &res);
   16f32:	4630      	mov	r0, r6
   16f34:	4629      	mov	r1, r5
   16f36:	4622      	mov	r2, r4
   16f38:	ab02      	add	r3, sp, #8
   16f3a:	47b8      	blx	r7
        ble_sm_process_result(conn_handle, &res);
   16f3c:	4630      	mov	r0, r6
   16f3e:	a902      	add	r1, sp, #8
   16f40:	f7ff fe9c 	bl	16c7c <ble_sm_process_result>
        rc = res.app_status;
   16f44:	9802      	ldr	r0, [sp, #8]
   16f46:	e002      	b.n	16f4e <ble_sm_rx+0x62>

    STATS_INC(ble_l2cap_stats, sm_rx);

    rc = os_mbuf_copydata(*om, 0, 1, &op);
    if (rc != 0) {
        return BLE_HS_EBADDATA;
   16f48:	200a      	movs	r0, #10
   16f4a:	e000      	b.n	16f4e <ble_sm_rx+0x62>

        rx_cb(conn_handle, op, om, &res);
        ble_sm_process_result(conn_handle, &res);
        rc = res.app_status;
    } else {
        rc = BLE_HS_ENOTSUP;
   16f4c:	2008      	movs	r0, #8
    }

    return rc;
}
   16f4e:	b008      	add	sp, #32
   16f50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   16f54:	20003bdc 	.word	0x20003bdc
   16f58:	0001fb80 	.word	0x0001fb80

00016f5c <ble_sm_enc_change_rx>:
    ble_sm_process_result(conn_handle, &res);
}

void
ble_sm_enc_change_rx(struct hci_encrypt_change *evt)
{
   16f5c:	4603      	mov	r3, r0
    /* For encrypted state: read LE-encryption bit; ignore BR/EDR and reserved
     * bits.
     */
    ble_sm_enc_event_rx(evt->connection_handle, evt->status,
   16f5e:	7842      	ldrb	r2, [r0, #1]
   16f60:	7819      	ldrb	r1, [r3, #0]
   16f62:	8840      	ldrh	r0, [r0, #2]
   16f64:	f002 0201 	and.w	r2, r2, #1
   16f68:	f7ff bf2e 	b.w	16dc8 <ble_sm_enc_event_rx>

00016f6c <ble_sm_enc_key_refresh_rx>:
                        evt->encryption_enabled & 0x01);
}

void
ble_sm_enc_key_refresh_rx(struct hci_encrypt_key_refresh *evt)
{
   16f6c:	4603      	mov	r3, r0
    ble_sm_enc_event_rx(evt->connection_handle, evt->status, 1);
   16f6e:	2201      	movs	r2, #1
   16f70:	8840      	ldrh	r0, [r0, #2]
   16f72:	7819      	ldrb	r1, [r3, #0]
   16f74:	f7ff bf28 	b.w	16dc8 <ble_sm_enc_event_rx>

00016f78 <ble_sm_ltk_req_rx>:
    }
}

int
ble_sm_ltk_req_rx(struct hci_le_lt_key_req *evt)
{
   16f78:	b570      	push	{r4, r5, r6, lr}
   16f7a:	b0aa      	sub	sp, #168	; 0xa8
    struct ble_hs_conn *conn;
    uint8_t peer_id_addr[6];
    int store_rc;
    int restore;

    memset(&res, 0, sizeof res);
   16f7c:	2100      	movs	r1, #0
   16f7e:	2218      	movs	r2, #24
    }
}

int
ble_sm_ltk_req_rx(struct hci_le_lt_key_req *evt)
{
   16f80:	4605      	mov	r5, r0
    struct ble_hs_conn *conn;
    uint8_t peer_id_addr[6];
    int store_rc;
    int restore;

    memset(&res, 0, sizeof res);
   16f82:	a808      	add	r0, sp, #32
   16f84:	f7f2 f845 	bl	9012 <memset>

    ble_hs_lock();
   16f88:	f7fd fbdc 	bl	14744 <ble_hs_lock>
    proc = ble_sm_proc_find(evt->connection_handle, BLE_SM_PROC_STATE_NONE,
   16f8c:	2200      	movs	r2, #0
   16f8e:	8928      	ldrh	r0, [r5, #8]
   16f90:	21ff      	movs	r1, #255	; 0xff
   16f92:	4613      	mov	r3, r2
   16f94:	f7ff faaa 	bl	164ec <ble_sm_proc_find>
                            0, NULL);
    if (proc == NULL) {
   16f98:	4604      	mov	r4, r0
   16f9a:	b968      	cbnz	r0, 16fb8 <ble_sm_ltk_req_rx+0x40>
         * encryption procedure.  Create a proc entry to indicate that security
         * establishment is in progress and execute the procedure after the
         * mutex gets unlocked.
         */
        restore = 1;
        proc = ble_sm_proc_alloc();
   16f9c:	f7ff f8b0 	bl	16100 <ble_sm_proc_alloc>
        if (proc == NULL) {
   16fa0:	4604      	mov	r4, r0
   16fa2:	b910      	cbnz	r0, 16faa <ble_sm_ltk_req_rx+0x32>
            res.app_status = BLE_HS_ENOMEM;
   16fa4:	2306      	movs	r3, #6
   16fa6:	9308      	str	r3, [sp, #32]
   16fa8:	e052      	b.n	17050 <ble_sm_ltk_req_rx+0xd8>
        } else {
            proc->conn_handle = evt->connection_handle;
   16faa:	892b      	ldrh	r3, [r5, #8]
   16fac:	8143      	strh	r3, [r0, #10]
            proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
   16fae:	2304      	movs	r3, #4
   16fb0:	7343      	strb	r3, [r0, #13]
            ble_sm_insert(proc);
   16fb2:	f7fe ff6b 	bl	15e8c <ble_sm_insert>
   16fb6:	e004      	b.n	16fc2 <ble_sm_ltk_req_rx+0x4a>

            res.execute = 1;
        }
    } else if (proc->state == BLE_SM_PROC_STATE_SEC_REQ) {
   16fb8:	7b43      	ldrb	r3, [r0, #13]
   16fba:	2b08      	cmp	r3, #8
   16fbc:	d108      	bne.n	16fd0 <ble_sm_ltk_req_rx+0x58>
        /* Same as above, except we solicited the encryption procedure by
         * sending a security request.
         */
        restore = 1;
        proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
   16fbe:	2304      	movs	r3, #4
   16fc0:	7343      	strb	r3, [r0, #13]
        res.execute = 1;
   16fc2:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
   16fc6:	f043 0301 	orr.w	r3, r3, #1
   16fca:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
   16fce:	e03f      	b.n	17050 <ble_sm_ltk_req_rx+0xd8>
    } else if (proc->state == BLE_SM_PROC_STATE_LTK_START) {
   16fd0:	2b03      	cmp	r3, #3
   16fd2:	d106      	bne.n	16fe2 <ble_sm_ltk_req_rx+0x6a>
        /* Legacy pairing just completed.  Send the short term key to the
         * controller.
         */
        restore = 0;
        res.execute = 1;
   16fd4:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
   16fd8:	f043 0301 	orr.w	r3, r3, #1
   16fdc:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
   16fe0:	e003      	b.n	16fea <ble_sm_ltk_req_rx+0x72>
    } else {
        /* The request is unexpected; nack and forget. */
        restore = 0;
        ble_sm_ltk_req_neg_reply_tx(evt->connection_handle);
   16fe2:	8928      	ldrh	r0, [r5, #8]
   16fe4:	f7ff f837 	bl	16056 <ble_sm_ltk_req_neg_reply_tx>
        proc = NULL;
   16fe8:	2400      	movs	r4, #0
    }
}

int
ble_sm_ltk_req_rx(struct hci_le_lt_key_req *evt)
{
   16fea:	2600      	movs	r6, #0
            ble_hs_conn_addrs(conn, &addrs);
            memcpy(peer_id_addr, addrs.peer_id_addr, 6);
        }
    }

    ble_hs_unlock();
   16fec:	f7fd fbb2 	bl	14754 <ble_hs_unlock>
   16ff0:	9908      	ldr	r1, [sp, #32]

    if (proc == NULL) {
   16ff2:	b90c      	cbnz	r4, 16ff8 <ble_sm_ltk_req_rx+0x80>
        return res.app_status;
   16ff4:	4608      	mov	r0, r1
   16ff6:	e03d      	b.n	17074 <ble_sm_ltk_req_rx+0xfc>
    }

    if (res.app_status == 0) {
   16ff8:	bb21      	cbnz	r1, 17044 <ble_sm_ltk_req_rx+0xcc>
        if (restore) {
   16ffa:	b31e      	cbz	r6, 17044 <ble_sm_ltk_req_rx+0xcc>
            store_rc = ble_sm_retrieve_ltk(evt, addrs.peer_id_addr_type,
   16ffc:	f89d 400f 	ldrb.w	r4, [sp, #15]
{
    struct ble_store_key_sec key_sec;
    int rc;

    /* Tell applicaiton to look up LTK by peer address and ediv/rand pair. */
    memset(&key_sec, 0, sizeof key_sec);
   17000:	2220      	movs	r2, #32
   17002:	a80e      	add	r0, sp, #56	; 0x38
   17004:	f7f2 f805 	bl	9012 <memset>
    key_sec.peer_addr_type = peer_addr_type;
   17008:	f88d 403e 	strb.w	r4, [sp, #62]	; 0x3e
    memcpy(key_sec.peer_addr, peer_addr, 6);
   1700c:	ab01      	add	r3, sp, #4
   1700e:	e893 0003 	ldmia.w	r3, {r0, r1}
    key_sec.ediv = evt->encrypted_diversifier;
   17012:	896b      	ldrh	r3, [r5, #10]
   17014:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
    key_sec.rand_num = evt->random_number;
   17018:	e9d5 2300 	ldrd	r2, r3, [r5]
   1701c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
    key_sec.ediv_rand_present = 1;
   17020:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
    int rc;

    /* Tell applicaiton to look up LTK by peer address and ediv/rand pair. */
    memset(&key_sec, 0, sizeof key_sec);
    key_sec.peer_addr_type = peer_addr_type;
    memcpy(key_sec.peer_addr, peer_addr, 6);
   17024:	900e      	str	r0, [sp, #56]	; 0x38
    key_sec.ediv = evt->encrypted_diversifier;
    key_sec.rand_num = evt->random_number;
    key_sec.ediv_rand_present = 1;

    rc = ble_store_read_our_sec(&key_sec, value_sec);
   17026:	ac16      	add	r4, sp, #88	; 0x58
    int rc;

    /* Tell applicaiton to look up LTK by peer address and ediv/rand pair. */
    memset(&key_sec, 0, sizeof key_sec);
    key_sec.peer_addr_type = peer_addr_type;
    memcpy(key_sec.peer_addr, peer_addr, 6);
   17028:	f8ad 103c 	strh.w	r1, [sp, #60]	; 0x3c
    key_sec.ediv = evt->encrypted_diversifier;
    key_sec.rand_num = evt->random_number;
    key_sec.ediv_rand_present = 1;
   1702c:	f043 0301 	orr.w	r3, r3, #1

    rc = ble_store_read_our_sec(&key_sec, value_sec);
   17030:	4621      	mov	r1, r4
   17032:	a80e      	add	r0, sp, #56	; 0x38
    memset(&key_sec, 0, sizeof key_sec);
    key_sec.peer_addr_type = peer_addr_type;
    memcpy(key_sec.peer_addr, peer_addr, 6);
    key_sec.ediv = evt->encrypted_diversifier;
    key_sec.rand_num = evt->random_number;
    key_sec.ediv_rand_present = 1;
   17034:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50

    rc = ble_store_read_our_sec(&key_sec, value_sec);
   17038:	f001 f9bc 	bl	183b4 <ble_store_read_our_sec>
        if (restore) {
            store_rc = ble_sm_retrieve_ltk(evt, addrs.peer_id_addr_type,
                                           peer_id_addr, &value_sec);
            if (store_rc == 0) {
                /* Send the key to the controller. */
                res.state_arg = &value_sec;
   1703c:	2800      	cmp	r0, #0
   1703e:	bf18      	it	ne
   17040:	2400      	movne	r4, #0
   17042:	940c      	str	r4, [sp, #48]	; 0x30
                res.state_arg = NULL;
            }
        }
    }

    ble_sm_process_result(evt->connection_handle, &res);
   17044:	8928      	ldrh	r0, [r5, #8]
   17046:	a908      	add	r1, sp, #32
   17048:	f7ff fe18 	bl	16c7c <ble_sm_process_result>

    return 0;
   1704c:	2000      	movs	r0, #0
   1704e:	e011      	b.n	17074 <ble_sm_ltk_req_rx+0xfc>
        ble_sm_ltk_req_neg_reply_tx(evt->connection_handle);
        proc = NULL;
    }

    if (restore) {
        conn = ble_hs_conn_find(evt->connection_handle);
   17050:	8928      	ldrh	r0, [r5, #8]
   17052:	f7fe f91f 	bl	15294 <ble_hs_conn_find>
        if (conn == NULL) {
   17056:	b910      	cbnz	r0, 1705e <ble_sm_ltk_req_rx+0xe6>
            res.app_status = BLE_HS_ENOTCONN;
   17058:	2307      	movs	r3, #7
   1705a:	9308      	str	r3, [sp, #32]
   1705c:	e008      	b.n	17070 <ble_sm_ltk_req_rx+0xf8>
        } else {
            ble_hs_conn_addrs(conn, &addrs);
   1705e:	a903      	add	r1, sp, #12
   17060:	f7fe f95a 	bl	15318 <ble_hs_conn_addrs>
            memcpy(peer_id_addr, addrs.peer_id_addr, 6);
   17064:	9b07      	ldr	r3, [sp, #28]
   17066:	6818      	ldr	r0, [r3, #0]
   17068:	889b      	ldrh	r3, [r3, #4]
   1706a:	9001      	str	r0, [sp, #4]
   1706c:	f8ad 3008 	strh.w	r3, [sp, #8]
   17070:	2601      	movs	r6, #1
   17072:	e7bb      	b.n	16fec <ble_sm_ltk_req_rx+0x74>
    }

    ble_sm_process_result(evt->connection_handle, &res);

    return 0;
}
   17074:	b02a      	add	sp, #168	; 0xa8
   17076:	bd70      	pop	{r4, r5, r6, pc}

00017078 <ble_sm_our_pair_rand>:
 *****************************************************************************/

uint8_t *
ble_sm_our_pair_rand(struct ble_sm_proc *proc)
{
    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
   17078:	7a03      	ldrb	r3, [r0, #8]
   1707a:	07db      	lsls	r3, r3, #31
        return proc->randm;
   1707c:	bf4c      	ite	mi
   1707e:	303b      	addmi	r0, #59	; 0x3b
    } else {
        return proc->rands;
   17080:	304b      	addpl	r0, #75	; 0x4b
    }
}
   17082:	4770      	bx	lr

00017084 <ble_sm_pair_exec>:
}

static void
ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                 void *arg)
{
   17084:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    int is_req;
    int rc;

    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;

    cmd.io_cap = ble_hs_cfg.sm_io_cap;
   17086:	4f2f      	ldr	r7, [pc, #188]	; (17144 <ble_sm_pair_exec+0xc0>)
    struct ble_sm_pair_cmd cmd;
    uint8_t ioact;
    int is_req;
    int rc;

    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;
   17088:	7a06      	ldrb	r6, [r0, #8]

    cmd.io_cap = ble_hs_cfg.sm_io_cap;
   1708a:	7bbb      	ldrb	r3, [r7, #14]
   1708c:	f88d 3000 	strb.w	r3, [sp]
    cmd.oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
   17090:	7bfb      	ldrb	r3, [r7, #15]
   17092:	f3c3 0300 	ubfx	r3, r3, #0, #1
}

static void
ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                 void *arg)
{
   17096:	460d      	mov	r5, r1
    int rc;

    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;

    cmd.io_cap = ble_hs_cfg.sm_io_cap;
    cmd.oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
   17098:	f88d 3001 	strb.w	r3, [sp, #1]
}

static void
ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
                 void *arg)
{
   1709c:	4604      	mov	r4, r0

    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;

    cmd.io_cap = ble_hs_cfg.sm_io_cap;
    cmd.oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
    cmd.authreq = ble_sm_build_authreq();
   1709e:	f7ff fcc9 	bl	16a34 <ble_sm_build_authreq>
    struct ble_sm_pair_cmd cmd;
    uint8_t ioact;
    int is_req;
    int rc;

    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;
   170a2:	f006 0601 	and.w	r6, r6, #1

    cmd.io_cap = ble_hs_cfg.sm_io_cap;
    cmd.oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
    cmd.authreq = ble_sm_build_authreq();
    cmd.max_enc_key_size = 16;
   170a6:	2310      	movs	r3, #16
   170a8:	f88d 3003 	strb.w	r3, [sp, #3]

    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;

    cmd.io_cap = ble_hs_cfg.sm_io_cap;
    cmd.oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
    cmd.authreq = ble_sm_build_authreq();
   170ac:	f88d 0002 	strb.w	r0, [sp, #2]
   170b0:	7c39      	ldrb	r1, [r7, #16]
   170b2:	7c7b      	ldrb	r3, [r7, #17]
    cmd.max_enc_key_size = 16;

    if (is_req) {
   170b4:	b116      	cbz	r6, 170bc <ble_sm_pair_exec+0x38>
        cmd.init_key_dist = ble_hs_cfg.sm_our_key_dist;
   170b6:	f88d 1004 	strb.w	r1, [sp, #4]
   170ba:	e005      	b.n	170c8 <ble_sm_pair_exec+0x44>
        cmd.resp_key_dist = ble_hs_cfg.sm_their_key_dist;
    } else {
        /* The response's key distribution flags field is the intersection of
         * the peer's preferences and our capabilities.
         */
        cmd.init_key_dist = proc->pair_req.init_key_dist &
   170bc:	7ce2      	ldrb	r2, [r4, #19]
   170be:	401a      	ands	r2, r3
                            ble_hs_cfg.sm_their_key_dist;
        cmd.resp_key_dist = proc->pair_req.resp_key_dist &
   170c0:	7d23      	ldrb	r3, [r4, #20]
        cmd.resp_key_dist = ble_hs_cfg.sm_their_key_dist;
    } else {
        /* The response's key distribution flags field is the intersection of
         * the peer's preferences and our capabilities.
         */
        cmd.init_key_dist = proc->pair_req.init_key_dist &
   170c2:	f88d 2004 	strb.w	r2, [sp, #4]
                            ble_hs_cfg.sm_their_key_dist;
        cmd.resp_key_dist = proc->pair_req.resp_key_dist &
   170c6:	400b      	ands	r3, r1
                            ble_hs_cfg.sm_our_key_dist;
    }

    rc = ble_sm_pair_cmd_tx(proc->conn_handle, is_req, &cmd);
   170c8:	8960      	ldrh	r0, [r4, #10]
        /* The response's key distribution flags field is the intersection of
         * the peer's preferences and our capabilities.
         */
        cmd.init_key_dist = proc->pair_req.init_key_dist &
                            ble_hs_cfg.sm_their_key_dist;
        cmd.resp_key_dist = proc->pair_req.resp_key_dist &
   170ca:	f88d 3005 	strb.w	r3, [sp, #5]
                            ble_hs_cfg.sm_our_key_dist;
    }

    rc = ble_sm_pair_cmd_tx(proc->conn_handle, is_req, &cmd);
   170ce:	4631      	mov	r1, r6
   170d0:	466a      	mov	r2, sp
   170d2:	f000 fc3d 	bl	17950 <ble_sm_pair_cmd_tx>
    if (rc != 0) {
   170d6:	bb78      	cbnz	r0, 17138 <ble_sm_pair_exec+0xb4>
   170d8:	f8bd 3004 	ldrh.w	r3, [sp, #4]
        goto err;
    }

    if (is_req) {
        proc->pair_req = cmd;
   170dc:	9800      	ldr	r0, [sp, #0]
    rc = ble_sm_pair_cmd_tx(proc->conn_handle, is_req, &cmd);
    if (rc != 0) {
        goto err;
    }

    if (is_req) {
   170de:	b126      	cbz	r6, 170ea <ble_sm_pair_exec+0x66>
        proc->pair_req = cmd;
   170e0:	f8c4 000f 	str.w	r0, [r4, #15]
   170e4:	f8a4 3013 	strh.w	r3, [r4, #19]
   170e8:	e018      	b.n	1711c <ble_sm_pair_exec+0x98>
    } else {
        proc->pair_rsp = cmd;
   170ea:	f8c4 0015 	str.w	r0, [r4, #21]
   170ee:	f8a4 3019 	strh.w	r3, [r4, #25]

        ble_sm_pair_cfg(proc);
   170f2:	4620      	mov	r0, r4
   170f4:	f7ff f960 	bl	163b8 <ble_sm_pair_cfg>
 *****************************************************************************/

static uint8_t
ble_sm_state_after_pair(struct ble_sm_proc *proc)
{
    if (proc->flags & BLE_SM_PROC_F_SC) {
   170f8:	7a23      	ldrb	r3, [r4, #8]
        return BLE_SM_PROC_STATE_PUBLIC_KEY;
    } else {
        return BLE_SM_PROC_STATE_CONFIRM;
   170fa:	f013 0f10 	tst.w	r3, #16
   170fe:	bf14      	ite	ne
   17100:	2309      	movne	r3, #9
   17102:	2301      	moveq	r3, #1
        proc->pair_req = cmd;
    } else {
        proc->pair_rsp = cmd;

        ble_sm_pair_cfg(proc);
        proc->state = ble_sm_state_after_pair(proc);
   17104:	7363      	strb	r3, [r4, #13]

        ioact = ble_sm_io_action(proc);
   17106:	4620      	mov	r0, r4
   17108:	f7fe fed0 	bl	15eac <ble_sm_io_action>
   1710c:	b2c6      	uxtb	r6, r0
        if (ble_sm_ioact_state(ioact) == proc->state) {
   1710e:	4630      	mov	r0, r6
   17110:	f7ff fca9 	bl	16a66 <ble_sm_ioact_state>
   17114:	7b63      	ldrb	r3, [r4, #13]
   17116:	4298      	cmp	r0, r3
            res->passkey_params.action = ioact;
   17118:	bf08      	it	eq
   1711a:	722e      	strbeq	r6, [r5, #8]
        }
    }

    res->app_status = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
   1711c:	4620      	mov	r0, r4
   1711e:	f7ff ffab 	bl	17078 <ble_sm_our_pair_rand>
   17122:	f7ff f9a9 	bl	16478 <ble_sm_gen_pair_rand>
   17126:	6028      	str	r0, [r5, #0]
    if (res->app_status != 0) {
   17128:	b150      	cbz	r0, 17140 <ble_sm_pair_exec+0xbc>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1712a:	2308      	movs	r3, #8
   1712c:	712b      	strb	r3, [r5, #4]
        res->enc_cb = 1;
   1712e:	7d2b      	ldrb	r3, [r5, #20]
   17130:	f043 0302 	orr.w	r3, r3, #2
   17134:	752b      	strb	r3, [r5, #20]
        return;
   17136:	e003      	b.n	17140 <ble_sm_pair_exec+0xbc>
    }

    return;

err:
    res->app_status = rc;
   17138:	6028      	str	r0, [r5, #0]

    if (!is_req) {
   1713a:	b90e      	cbnz	r6, 17140 <ble_sm_pair_exec+0xbc>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1713c:	2308      	movs	r3, #8
   1713e:	712b      	strb	r3, [r5, #4]
    }
}
   17140:	b003      	add	sp, #12
   17142:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17144:	20003b78 	.word	0x20003b78

00017148 <ble_sm_peer_pair_rand>:
}

uint8_t *
ble_sm_peer_pair_rand(struct ble_sm_proc *proc)
{
    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
   17148:	7a03      	ldrb	r3, [r0, #8]
   1714a:	07db      	lsls	r3, r3, #31
        return proc->rands;
   1714c:	bf4c      	ite	mi
   1714e:	304b      	addmi	r0, #75	; 0x4b
    } else {
        return proc->randm;
   17150:	303b      	addpl	r0, #59	; 0x3b
    }
}
   17152:	4770      	bx	lr

00017154 <ble_sm_random_rx>:
}

static void
ble_sm_random_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                 struct ble_sm_result *res)
{
   17154:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_sm_pair_random cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_RANDOM_SZ);
   17156:	2110      	movs	r1, #16
}

static void
ble_sm_random_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                 struct ble_sm_result *res)
{
   17158:	b08b      	sub	sp, #44	; 0x2c
   1715a:	4606      	mov	r6, r0
    struct ble_sm_pair_random cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_RANDOM_SZ);
   1715c:	4610      	mov	r0, r2
}

static void
ble_sm_random_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                 struct ble_sm_result *res)
{
   1715e:	461c      	mov	r4, r3
   17160:	4617      	mov	r7, r2
    struct ble_sm_pair_random cmd;
    struct ble_sm_proc *proc;
    struct ble_sm_proc *prev;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_PAIR_RANDOM_SZ);
   17162:	f7fe f9e9 	bl	15538 <ble_hs_misc_pullup_base>
   17166:	4605      	mov	r5, r0
   17168:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   1716a:	b130      	cbz	r0, 1717a <ble_sm_random_rx+0x26>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1716c:	2308      	movs	r3, #8
   1716e:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   17170:	7d23      	ldrb	r3, [r4, #20]
   17172:	f043 0302 	orr.w	r3, r3, #2
   17176:	7523      	strb	r3, [r4, #20]
   17178:	e040      	b.n	171fc <ble_sm_random_rx+0xa8>
        return;
    }

    ble_sm_pair_random_parse((*om)->om_data, (*om)->om_len, &cmd);
   1717a:	683b      	ldr	r3, [r7, #0]
   1717c:	aa06      	add	r2, sp, #24
   1717e:	6818      	ldr	r0, [r3, #0]
   17180:	88d9      	ldrh	r1, [r3, #6]
   17182:	f000 fc95 	bl	17ab0 <ble_sm_pair_random_parse>
    BLE_SM_LOG_CMD(0, "random", conn_handle, ble_sm_pair_random_log, &cmd);
   17186:	4b1e      	ldr	r3, [pc, #120]	; (17200 <ble_sm_random_rx+0xac>)
   17188:	9300      	str	r3, [sp, #0]
   1718a:	4b1e      	ldr	r3, [pc, #120]	; (17204 <ble_sm_random_rx+0xb0>)
   1718c:	9301      	str	r3, [sp, #4]
   1718e:	4b1e      	ldr	r3, [pc, #120]	; (17208 <ble_sm_random_rx+0xb4>)
   17190:	9302      	str	r3, [sp, #8]
   17192:	2104      	movs	r1, #4
   17194:	462a      	mov	r2, r5
   17196:	4b1d      	ldr	r3, [pc, #116]	; (1720c <ble_sm_random_rx+0xb8>)
   17198:	9603      	str	r6, [sp, #12]
   1719a:	481d      	ldr	r0, [pc, #116]	; (17210 <ble_sm_random_rx+0xbc>)
   1719c:	f006 f844 	bl	1d228 <log_printf>
   171a0:	a806      	add	r0, sp, #24
   171a2:	f000 fc9b 	bl	17adc <ble_sm_pair_random_log>
   171a6:	481a      	ldr	r0, [pc, #104]	; (17210 <ble_sm_random_rx+0xbc>)
   171a8:	4b1a      	ldr	r3, [pc, #104]	; (17214 <ble_sm_random_rx+0xc0>)
   171aa:	2104      	movs	r1, #4
   171ac:	462a      	mov	r2, r5
   171ae:	f006 f83b 	bl	1d228 <log_printf>

    ble_hs_lock();
   171b2:	f7fd fac7 	bl	14744 <ble_hs_lock>
    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_RANDOM, -1, &prev);
   171b6:	4630      	mov	r0, r6
   171b8:	2102      	movs	r1, #2
   171ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   171be:	ab05      	add	r3, sp, #20
   171c0:	f7ff f994 	bl	164ec <ble_sm_proc_find>
    if (proc == NULL) {
   171c4:	4606      	mov	r6, r0
   171c6:	b910      	cbnz	r0, 171ce <ble_sm_random_rx+0x7a>
        res->app_status = BLE_HS_ENOENT;
   171c8:	2305      	movs	r3, #5
   171ca:	6023      	str	r3, [r4, #0]
   171cc:	e014      	b.n	171f8 <ble_sm_random_rx+0xa4>
    } else {
        memcpy(ble_sm_peer_pair_rand(proc), cmd.value, 16);
   171ce:	f7ff ffbb 	bl	17148 <ble_sm_peer_pair_rand>
   171d2:	af0a      	add	r7, sp, #40	; 0x28
   171d4:	ab06      	add	r3, sp, #24
   171d6:	4605      	mov	r5, r0
   171d8:	461a      	mov	r2, r3
   171da:	ca03      	ldmia	r2!, {r0, r1}
   171dc:	42ba      	cmp	r2, r7
   171de:	6028      	str	r0, [r5, #0]
   171e0:	6069      	str	r1, [r5, #4]
   171e2:	4613      	mov	r3, r2
   171e4:	f105 0508 	add.w	r5, r5, #8
   171e8:	d1f6      	bne.n	171d8 <ble_sm_random_rx+0x84>

        if (proc->flags & BLE_SM_PROC_F_SC) {
   171ea:	7a33      	ldrb	r3, [r6, #8]
   171ec:	06db      	lsls	r3, r3, #27
   171ee:	d403      	bmi.n	171f8 <ble_sm_random_rx+0xa4>
            ble_sm_sc_random_rx(proc, res);
        } else {
            ble_sm_lgcy_random_rx(proc, res);
   171f0:	4630      	mov	r0, r6
   171f2:	4621      	mov	r1, r4
   171f4:	f001 f84d 	bl	18292 <ble_sm_lgcy_random_rx>
        }
    }
    ble_hs_unlock();
   171f8:	f7fd faac 	bl	14754 <ble_hs_unlock>
}
   171fc:	b00b      	add	sp, #44	; 0x2c
   171fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17200:	0001fbda 	.word	0x0001fbda
   17204:	0001fbdd 	.word	0x0001fbdd
   17208:	0001fc46 	.word	0x0001fc46
   1720c:	0001fbbc 	.word	0x0001fbbc
   17210:	20003b9c 	.word	0x20003b9c
   17214:	0001fdec 	.word	0x0001fdec

00017218 <ble_sm_heartbeat>:
 *                                  be called again; currently always
 *                                  UINT32_MAX.
 */
int32_t
ble_sm_heartbeat(void)
{
   17218:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    struct ble_sm_proc *next;
    uint32_t now;
    int32_t time_diff;

    now = os_time_get();
    STAILQ_INIT(dst_list);
   1721c:	ae02      	add	r6, sp, #8
    struct ble_sm_proc *prev;
    struct ble_sm_proc *next;
    uint32_t now;
    int32_t time_diff;

    now = os_time_get();
   1721e:	f7f3 facf 	bl	a7c0 <os_time_get>
    STAILQ_INIT(dst_list);
   17222:	2400      	movs	r4, #0
   17224:	f846 4d08 	str.w	r4, [r6, #-8]!
    struct ble_sm_proc *prev;
    struct ble_sm_proc *next;
    uint32_t now;
    int32_t time_diff;

    now = os_time_get();
   17228:	4680      	mov	r8, r0
    STAILQ_INIT(dst_list);
   1722a:	9601      	str	r6, [sp, #4]

    ble_hs_lock();
   1722c:	f7fd fa8a 	bl	14744 <ble_hs_lock>

    prev = NULL;
    proc = STAILQ_FIRST(&ble_sm_procs);
   17230:	491f      	ldr	r1, [pc, #124]	; (172b0 <ble_sm_heartbeat+0x98>)
   17232:	e891 0028 	ldmia.w	r1, {r3, r5}
   17236:	e89d 4001 	ldmia.w	sp, {r0, lr}
    now = os_time_get();
    STAILQ_INIT(dst_list);

    ble_hs_lock();

    prev = NULL;
   1723a:	4622      	mov	r2, r4
    proc = STAILQ_FIRST(&ble_sm_procs);
   1723c:	461f      	mov	r7, r3
   1723e:	460c      	mov	r4, r1
    while (proc != NULL) {
   17240:	b1db      	cbz	r3, 1727a <ble_sm_heartbeat+0x62>
        next = STAILQ_NEXT(proc, next);

        time_diff = now - proc->exp_os_ticks;
   17242:	6859      	ldr	r1, [r3, #4]
    ble_hs_lock();

    prev = NULL;
    proc = STAILQ_FIRST(&ble_sm_procs);
    while (proc != NULL) {
        next = STAILQ_NEXT(proc, next);
   17244:	f8d3 c000 	ldr.w	ip, [r3]

        time_diff = now - proc->exp_os_ticks;
   17248:	ebc1 0108 	rsb	r1, r1, r8
        if (time_diff >= 0) {
   1724c:	2900      	cmp	r1, #0
   1724e:	db11      	blt.n	17274 <ble_sm_heartbeat+0x5c>
            if (prev == NULL) {
   17250:	b92a      	cbnz	r2, 1725e <ble_sm_heartbeat+0x46>
                STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
   17252:	683f      	ldr	r7, [r7, #0]
   17254:	4a16      	ldr	r2, [pc, #88]	; (172b0 <ble_sm_heartbeat+0x98>)
   17256:	2f00      	cmp	r7, #0
   17258:	bf08      	it	eq
   1725a:	4615      	moveq	r5, r2
   1725c:	e005      	b.n	1726a <ble_sm_heartbeat+0x52>
            } else {
                STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
   1725e:	6811      	ldr	r1, [r2, #0]
   17260:	6809      	ldr	r1, [r1, #0]
   17262:	6011      	str	r1, [r2, #0]
   17264:	2900      	cmp	r1, #0
   17266:	bf08      	it	eq
   17268:	4615      	moveq	r5, r2
            }
            STAILQ_INSERT_HEAD(dst_list, proc, next);
   1726a:	6018      	str	r0, [r3, #0]
   1726c:	2800      	cmp	r0, #0
   1726e:	bf08      	it	eq
   17270:	469e      	moveq	lr, r3
        next = STAILQ_NEXT(proc, next);

        time_diff = now - proc->exp_os_ticks;
        if (time_diff >= 0) {
            if (prev == NULL) {
                STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
   17272:	4618      	mov	r0, r3
   17274:	461a      	mov	r2, r3
   17276:	4663      	mov	r3, ip
   17278:	e7e2      	b.n	17240 <ble_sm_heartbeat+0x28>
   1727a:	e88d 4001 	stmia.w	sp, {r0, lr}
   1727e:	6065      	str	r5, [r4, #4]
   17280:	6027      	str	r7, [r4, #0]
        proc = next;
    }

    ble_sm_dbg_assert_no_cycles();

    ble_hs_unlock();
   17282:	f7fd fa67 	bl	14754 <ble_hs_unlock>
    /* Notify application of each failure and free the corresponding procedure
     * object.
     * XXX: Mark connection as tainted; don't allow any subsequent SMP
     * procedures without reconnect.
     */
    while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
   17286:	9c00      	ldr	r4, [sp, #0]
   17288:	b16c      	cbz	r4, 172a6 <ble_sm_heartbeat+0x8e>
        ble_gap_enc_event(proc->conn_handle, BLE_HS_ETIMEOUT, 0);
   1728a:	8960      	ldrh	r0, [r4, #10]
   1728c:	210d      	movs	r1, #13
   1728e:	2200      	movs	r2, #0
   17290:	f7fb f84e 	bl	12330 <ble_gap_enc_event>

        STAILQ_REMOVE_HEAD(&exp_list, next);
   17294:	9b00      	ldr	r3, [sp, #0]
   17296:	681b      	ldr	r3, [r3, #0]
   17298:	9300      	str	r3, [sp, #0]
   1729a:	b903      	cbnz	r3, 1729e <ble_sm_heartbeat+0x86>
   1729c:	9601      	str	r6, [sp, #4]
        ble_sm_proc_free(proc);
   1729e:	4620      	mov	r0, r4
   172a0:	f7fe ff26 	bl	160f0 <ble_sm_proc_free>
   172a4:	e7ef      	b.n	17286 <ble_sm_heartbeat+0x6e>
    }

    return BLE_HS_FOREVER;
}
   172a6:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   172aa:	b002      	add	sp, #8
   172ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   172b0:	20002278 	.word	0x20002278

000172b4 <ble_sm_pair_initiate>:
/**
 * Initiates the pairing procedure for the specified connection.
 */
int
ble_sm_pair_initiate(uint16_t conn_handle)
{
   172b4:	b570      	push	{r4, r5, r6, lr}
   172b6:	4605      	mov	r5, r0
   172b8:	b086      	sub	sp, #24
    struct ble_sm_result res;
    struct ble_sm_proc *proc;

    /* Make sure a procedure isn't already in progress for this connection. */
    ble_hs_lock();
   172ba:	f7fd fa43 	bl	14744 <ble_hs_lock>
    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE,
   172be:	4628      	mov	r0, r5
   172c0:	21ff      	movs	r1, #255	; 0xff
   172c2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   172c6:	2300      	movs	r3, #0
   172c8:	f7ff f910 	bl	164ec <ble_sm_proc_find>
                                  -1, NULL);
    if (proc != NULL) {
   172cc:	4606      	mov	r6, r0
   172ce:	b118      	cbz	r0, 172d8 <ble_sm_pair_initiate+0x24>
        res.app_status = BLE_HS_EALREADY;
   172d0:	2302      	movs	r3, #2
   172d2:	9300      	str	r3, [sp, #0]

        /* Set pointer to null so that existing entry doesn't get freed. */
        proc = NULL;
   172d4:	2400      	movs	r4, #0
   172d6:	e014      	b.n	17302 <ble_sm_pair_initiate+0x4e>
    } else {
        proc = ble_sm_proc_alloc();
   172d8:	f7fe ff12 	bl	16100 <ble_sm_proc_alloc>
        if (proc == NULL) {
   172dc:	4604      	mov	r4, r0
   172de:	b910      	cbnz	r0, 172e6 <ble_sm_pair_initiate+0x32>
            res.app_status = BLE_HS_ENOMEM;
   172e0:	2306      	movs	r3, #6
   172e2:	9300      	str	r3, [sp, #0]
   172e4:	e00d      	b.n	17302 <ble_sm_pair_initiate+0x4e>
        } else {
            proc->conn_handle = conn_handle;
            proc->state = BLE_SM_PROC_STATE_PAIR;
            proc->flags |= BLE_SM_PROC_F_INITIATOR;
   172e6:	7a03      	ldrb	r3, [r0, #8]
    } else {
        proc = ble_sm_proc_alloc();
        if (proc == NULL) {
            res.app_status = BLE_HS_ENOMEM;
        } else {
            proc->conn_handle = conn_handle;
   172e8:	8145      	strh	r5, [r0, #10]
            proc->state = BLE_SM_PROC_STATE_PAIR;
            proc->flags |= BLE_SM_PROC_F_INITIATOR;
   172ea:	f043 0301 	orr.w	r3, r3, #1
   172ee:	7203      	strb	r3, [r0, #8]
        proc = ble_sm_proc_alloc();
        if (proc == NULL) {
            res.app_status = BLE_HS_ENOMEM;
        } else {
            proc->conn_handle = conn_handle;
            proc->state = BLE_SM_PROC_STATE_PAIR;
   172f0:	7346      	strb	r6, [r0, #13]
            proc->flags |= BLE_SM_PROC_F_INITIATOR;
            ble_sm_insert(proc);
   172f2:	f7fe fdcb 	bl	15e8c <ble_sm_insert>

            res.execute = 1;
   172f6:	f89d 3014 	ldrb.w	r3, [sp, #20]
   172fa:	f043 0301 	orr.w	r3, r3, #1
   172fe:	f88d 3014 	strb.w	r3, [sp, #20]
        }
    }

    ble_hs_unlock();
   17302:	f7fd fa27 	bl	14754 <ble_hs_unlock>

    if (proc != NULL) {
   17306:	b11c      	cbz	r4, 17310 <ble_sm_pair_initiate+0x5c>
        ble_sm_process_result(conn_handle, &res);
   17308:	4628      	mov	r0, r5
   1730a:	4669      	mov	r1, sp
   1730c:	f7ff fcb6 	bl	16c7c <ble_sm_process_result>
    }

    return res.app_status;
}
   17310:	9800      	ldr	r0, [sp, #0]
   17312:	b006      	add	sp, #24
   17314:	bd70      	pop	{r4, r5, r6, pc}

00017316 <ble_sm_enc_initiate>:
 * Initiates the encryption procedure for the specified connection.
 */
int
ble_sm_enc_initiate(uint16_t conn_handle, const uint8_t *ltk, uint16_t ediv,
                    uint64_t rand_val, int auth)
{
   17316:	b570      	push	{r4, r5, r6, lr}
   17318:	b08e      	sub	sp, #56	; 0x38
   1731a:	4605      	mov	r5, r0
   1731c:	460c      	mov	r4, r1
   1731e:	4616      	mov	r6, r2
    struct ble_sm_result res;
    struct ble_sm_proc *proc;
    struct hci_start_encrypt cmd;

    memset(&res, 0, sizeof res);
   17320:	2100      	movs	r1, #0
   17322:	2218      	movs	r2, #24
   17324:	4668      	mov	r0, sp
   17326:	f7f1 fe74 	bl	9012 <memset>

    /* Make sure a procedure isn't already in progress for this connection. */
    ble_hs_lock();
   1732a:	f7fd fa0b 	bl	14744 <ble_hs_lock>
    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE,
   1732e:	4628      	mov	r0, r5
   17330:	21ff      	movs	r1, #255	; 0xff
   17332:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17336:	2300      	movs	r3, #0
   17338:	f7ff f8d8 	bl	164ec <ble_sm_proc_find>
                            -1, NULL);
    if (proc != NULL) {
   1733c:	b108      	cbz	r0, 17342 <ble_sm_enc_initiate+0x2c>
        res.app_status = BLE_HS_EALREADY;
   1733e:	2302      	movs	r3, #2
   17340:	e003      	b.n	1734a <ble_sm_enc_initiate+0x34>

        /* Set pointer to null so that existing entry doesn't get freed. */
        proc = NULL;
    } else {
        proc = ble_sm_proc_alloc();
   17342:	f7fe fedd 	bl	16100 <ble_sm_proc_alloc>
   17346:	2306      	movs	r3, #6
        if (proc == NULL) {
   17348:	b908      	cbnz	r0, 1734e <ble_sm_enc_initiate+0x38>
            res.app_status = BLE_HS_ENOMEM;
   1734a:	9300      	str	r3, [sp, #0]
   1734c:	e028      	b.n	173a0 <ble_sm_enc_initiate+0x8a>
        } else {
            proc->conn_handle = conn_handle;
            proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
            proc->flags |= BLE_SM_PROC_F_INITIATOR;
            if (auth) {
   1734e:	9a14      	ldr	r2, [sp, #80]	; 0x50
        proc = ble_sm_proc_alloc();
        if (proc == NULL) {
            res.app_status = BLE_HS_ENOMEM;
        } else {
            proc->conn_handle = conn_handle;
            proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
   17350:	7343      	strb	r3, [r0, #13]
    } else {
        proc = ble_sm_proc_alloc();
        if (proc == NULL) {
            res.app_status = BLE_HS_ENOMEM;
        } else {
            proc->conn_handle = conn_handle;
   17352:	8145      	strh	r5, [r0, #10]
            proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
            proc->flags |= BLE_SM_PROC_F_INITIATOR;
   17354:	7a03      	ldrb	r3, [r0, #8]
            if (auth) {
   17356:	b912      	cbnz	r2, 1735e <ble_sm_enc_initiate+0x48>
        if (proc == NULL) {
            res.app_status = BLE_HS_ENOMEM;
        } else {
            proc->conn_handle = conn_handle;
            proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
            proc->flags |= BLE_SM_PROC_F_INITIATOR;
   17358:	f043 0301 	orr.w	r3, r3, #1
   1735c:	e001      	b.n	17362 <ble_sm_enc_initiate+0x4c>
            if (auth) {
                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
   1735e:	f043 0309 	orr.w	r3, r3, #9
   17362:	7203      	strb	r3, [r0, #8]
            }
            ble_sm_insert(proc);
   17364:	f7fe fd92 	bl	15e8c <ble_sm_insert>

            cmd.connection_handle = conn_handle;
            cmd.encrypted_diversifier = ediv;
            cmd.random_number = rand_val;
   17368:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
   1736c:	e9cd 2308 	strd	r2, r3, [sp, #32]
            memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
   17370:	4623      	mov	r3, r4
                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
            }
            ble_sm_insert(proc);

            cmd.connection_handle = conn_handle;
            cmd.encrypted_diversifier = ediv;
   17372:	f8ad 601a 	strh.w	r6, [sp, #26]
            if (auth) {
                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
            }
            ble_sm_insert(proc);

            cmd.connection_handle = conn_handle;
   17376:	f8ad 5018 	strh.w	r5, [sp, #24]
            cmd.encrypted_diversifier = ediv;
            cmd.random_number = rand_val;
            memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
   1737a:	ac0a      	add	r4, sp, #40	; 0x28
   1737c:	f103 0610 	add.w	r6, r3, #16
   17380:	6818      	ldr	r0, [r3, #0]
   17382:	6859      	ldr	r1, [r3, #4]
   17384:	4622      	mov	r2, r4
   17386:	c203      	stmia	r2!, {r0, r1}
   17388:	3308      	adds	r3, #8
   1738a:	42b3      	cmp	r3, r6
   1738c:	4614      	mov	r4, r2
   1738e:	d1f7      	bne.n	17380 <ble_sm_enc_initiate+0x6a>

            res.execute = 1;
   17390:	f89d 3014 	ldrb.w	r3, [sp, #20]
   17394:	f043 0301 	orr.w	r3, r3, #1
   17398:	f88d 3014 	strb.w	r3, [sp, #20]
            res.state_arg = &cmd;
   1739c:	ab06      	add	r3, sp, #24
   1739e:	9304      	str	r3, [sp, #16]
        }
    }

    ble_hs_unlock();
   173a0:	f7fd f9d8 	bl	14754 <ble_hs_unlock>

    ble_sm_process_result(conn_handle, &res);
   173a4:	4628      	mov	r0, r5
   173a6:	4669      	mov	r1, sp
   173a8:	f7ff fc68 	bl	16c7c <ble_sm_process_result>

    return res.app_status;
}
   173ac:	9800      	ldr	r0, [sp, #0]
   173ae:	b00e      	add	sp, #56	; 0x38
   173b0:	bd70      	pop	{r4, r5, r6, pc}
	...

000173b4 <ble_sm_sec_req_rx>:
}

static void
ble_sm_sec_req_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   173b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_hs_conn_addrs addrs;
    struct ble_sm_sec_req cmd;
    struct ble_hs_conn *conn;
    int authreq_mitm;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_SEC_REQ_SZ);
   173b6:	2101      	movs	r1, #1
}

static void
ble_sm_sec_req_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   173b8:	b0a7      	sub	sp, #156	; 0x9c
   173ba:	4606      	mov	r6, r0
    struct ble_hs_conn_addrs addrs;
    struct ble_sm_sec_req cmd;
    struct ble_hs_conn *conn;
    int authreq_mitm;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_SEC_REQ_SZ);
   173bc:	4610      	mov	r0, r2
}

static void
ble_sm_sec_req_rx(uint16_t conn_handle, uint8_t op, struct os_mbuf **om,
                  struct ble_sm_result *res)
{
   173be:	461c      	mov	r4, r3
   173c0:	4617      	mov	r7, r2
    struct ble_hs_conn_addrs addrs;
    struct ble_sm_sec_req cmd;
    struct ble_hs_conn *conn;
    int authreq_mitm;

    res->app_status = ble_hs_misc_pullup_base(om, BLE_SM_SEC_REQ_SZ);
   173c2:	f7fe f8b9 	bl	15538 <ble_hs_misc_pullup_base>
   173c6:	4605      	mov	r5, r0
   173c8:	6020      	str	r0, [r4, #0]
    if (res->app_status != 0) {
   173ca:	2800      	cmp	r0, #0
   173cc:	d177      	bne.n	174be <ble_sm_sec_req_rx+0x10a>
        return;
    }

    ble_sm_sec_req_parse((*om)->om_data, (*om)->om_len, &cmd);
   173ce:	683b      	ldr	r3, [r7, #0]
   173d0:	aa04      	add	r2, sp, #16
   173d2:	6818      	ldr	r0, [r3, #0]
   173d4:	88d9      	ldrh	r1, [r3, #6]
   173d6:	f000 fe55 	bl	18084 <ble_sm_sec_req_parse>
    BLE_SM_LOG_CMD(0, "sec req", conn_handle, ble_sm_sec_req_log, &cmd);
   173da:	4b3a      	ldr	r3, [pc, #232]	; (174c4 <ble_sm_sec_req_rx+0x110>)
   173dc:	9300      	str	r3, [sp, #0]
   173de:	4b3a      	ldr	r3, [pc, #232]	; (174c8 <ble_sm_sec_req_rx+0x114>)
   173e0:	9301      	str	r3, [sp, #4]
   173e2:	4b3a      	ldr	r3, [pc, #232]	; (174cc <ble_sm_sec_req_rx+0x118>)
   173e4:	9302      	str	r3, [sp, #8]
   173e6:	2104      	movs	r1, #4
   173e8:	462a      	mov	r2, r5
   173ea:	4b39      	ldr	r3, [pc, #228]	; (174d0 <ble_sm_sec_req_rx+0x11c>)
   173ec:	4839      	ldr	r0, [pc, #228]	; (174d4 <ble_sm_sec_req_rx+0x120>)
   173ee:	9603      	str	r6, [sp, #12]
   173f0:	f005 ff1a 	bl	1d228 <log_printf>
   173f4:	a804      	add	r0, sp, #16
   173f6:	f000 fe49 	bl	1808c <ble_sm_sec_req_log>
   173fa:	4836      	ldr	r0, [pc, #216]	; (174d4 <ble_sm_sec_req_rx+0x120>)
   173fc:	4b36      	ldr	r3, [pc, #216]	; (174d8 <ble_sm_sec_req_rx+0x124>)
   173fe:	2104      	movs	r1, #4
   17400:	462a      	mov	r2, r5
   17402:	f005 ff11 	bl	1d228 <log_printf>

    /* XXX: Reject if:
     *     o authreq-reserved flags set?
     */

    ble_hs_lock();
   17406:	f7fd f99d 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   1740a:	4630      	mov	r0, r6
   1740c:	f7fd ff42 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   17410:	b910      	cbnz	r0, 17418 <ble_sm_sec_req_rx+0x64>
        res->app_status = BLE_HS_ENOTCONN;
   17412:	2307      	movs	r3, #7
   17414:	6023      	str	r3, [r4, #0]
   17416:	e01b      	b.n	17450 <ble_sm_sec_req_rx+0x9c>
    } else if (!(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
   17418:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
   1741c:	07df      	lsls	r7, r3, #31
   1741e:	d405      	bmi.n	1742c <ble_sm_sec_req_rx+0x78>
        res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
   17420:	f240 4307 	movw	r3, #1031	; 0x407
   17424:	6023      	str	r3, [r4, #0]
        res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
   17426:	2307      	movs	r3, #7
   17428:	7123      	strb	r3, [r4, #4]
   1742a:	e011      	b.n	17450 <ble_sm_sec_req_rx+0x9c>
    } else {
        /* We will be querying the SM database for a key corresponding to the
         * sender; remember the sender's address while the connection list is
         * locked.
         */
        ble_hs_conn_addrs(conn, &addrs);
   1742c:	a905      	add	r1, sp, #20
   1742e:	f7fd ff73 	bl	15318 <ble_hs_conn_addrs>
        memset(&key_sec, 0, sizeof key_sec);
   17432:	a80a      	add	r0, sp, #40	; 0x28
   17434:	4629      	mov	r1, r5
   17436:	2220      	movs	r2, #32
   17438:	f7f1 fdeb 	bl	9012 <memset>
        key_sec.peer_addr_type = addrs.peer_id_addr_type;
   1743c:	f89d 3017 	ldrb.w	r3, [sp, #23]
   17440:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
        memcpy(key_sec.peer_addr, addrs.peer_id_addr, 6);
   17444:	9b09      	ldr	r3, [sp, #36]	; 0x24
   17446:	6818      	ldr	r0, [r3, #0]
   17448:	900a      	str	r0, [sp, #40]	; 0x28
   1744a:	889b      	ldrh	r3, [r3, #4]
   1744c:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    }

    ble_hs_unlock();
   17450:	f7fd f980 	bl	14754 <ble_hs_unlock>

    if (res->app_status == 0) {
   17454:	6823      	ldr	r3, [r4, #0]
   17456:	2b00      	cmp	r3, #0
   17458:	d131      	bne.n	174be <ble_sm_sec_req_rx+0x10a>
        /* If the peer is requesting a bonded connection, query database for an
         * LTK corresponding to the sender.
         */
        if (cmd.authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
   1745a:	f89d 3010 	ldrb.w	r3, [sp, #16]
   1745e:	07d9      	lsls	r1, r3, #31
   17460:	d505      	bpl.n	1746e <ble_sm_sec_req_rx+0xba>
            res->app_status = ble_store_read_peer_sec(&key_sec, &value_sec);
   17462:	a80a      	add	r0, sp, #40	; 0x28
   17464:	a912      	add	r1, sp, #72	; 0x48
   17466:	f000 ffab 	bl	183c0 <ble_store_read_peer_sec>
   1746a:	6020      	str	r0, [r4, #0]
   1746c:	e001      	b.n	17472 <ble_sm_sec_req_rx+0xbe>
        } else {
            res->app_status = BLE_HS_ENOENT;
   1746e:	2305      	movs	r3, #5
   17470:	6023      	str	r3, [r4, #0]
        }
        if (res->app_status == 0) {
   17472:	6823      	ldr	r3, [r4, #0]
   17474:	b96b      	cbnz	r3, 17492 <ble_sm_sec_req_rx+0xde>
            /* Found a key corresponding to this peer.  Make sure it meets the
             * requested minimum authreq.
             */
            authreq_mitm = cmd.authreq & BLE_SM_PAIR_AUTHREQ_MITM;
   17476:	f89d 3010 	ldrb.w	r3, [sp, #16]
            if ((!authreq_mitm && value_sec.authenticated) ||
   1747a:	f013 0f04 	tst.w	r3, #4
   1747e:	f89d 3092 	ldrb.w	r3, [sp, #146]	; 0x92
   17482:	d102      	bne.n	1748a <ble_sm_sec_req_rx+0xd6>
   17484:	079a      	lsls	r2, r3, #30
   17486:	d402      	bmi.n	1748e <ble_sm_sec_req_rx+0xda>
   17488:	e003      	b.n	17492 <ble_sm_sec_req_rx+0xde>
                (authreq_mitm && !value_sec.authenticated)) {
   1748a:	079b      	lsls	r3, r3, #30
   1748c:	d401      	bmi.n	17492 <ble_sm_sec_req_rx+0xde>

                res->app_status = BLE_HS_EREJECT;
   1748e:	2310      	movs	r3, #16
   17490:	6023      	str	r3, [r4, #0]
            }
        }

        if (res->app_status == 0) {
   17492:	6823      	ldr	r3, [r4, #0]
   17494:	b97b      	cbnz	r3, 174b6 <ble_sm_sec_req_rx+0x102>
            res->app_status = ble_sm_enc_initiate(conn_handle, value_sec.ltk,
   17496:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
                                                  value_sec.ediv,
                                                  value_sec.rand_num,
                                                  value_sec.authenticated);
   1749a:	f89d 3092 	ldrb.w	r3, [sp, #146]	; 0x92
                res->app_status = BLE_HS_EREJECT;
            }
        }

        if (res->app_status == 0) {
            res->app_status = ble_sm_enc_initiate(conn_handle, value_sec.ltk,
   1749e:	f8bd 2050 	ldrh.w	r2, [sp, #80]	; 0x50
   174a2:	f3c3 0340 	ubfx	r3, r3, #1, #1
   174a6:	e9cd 0100 	strd	r0, r1, [sp]
   174aa:	9302      	str	r3, [sp, #8]
   174ac:	4630      	mov	r0, r6
   174ae:	a918      	add	r1, sp, #96	; 0x60
   174b0:	f7ff ff31 	bl	17316 <ble_sm_enc_initiate>
   174b4:	e002      	b.n	174bc <ble_sm_sec_req_rx+0x108>
                                                  value_sec.ediv,
                                                  value_sec.rand_num,
                                                  value_sec.authenticated);
        } else {
            res->app_status = ble_sm_pair_initiate(conn_handle);
   174b6:	4630      	mov	r0, r6
   174b8:	f7ff fefc 	bl	172b4 <ble_sm_pair_initiate>
   174bc:	6020      	str	r0, [r4, #0]
        }
    }
}
   174be:	b027      	add	sp, #156	; 0x9c
   174c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   174c2:	bf00      	nop
   174c4:	0001fbda 	.word	0x0001fbda
   174c8:	0001fbdd 	.word	0x0001fbdd
   174cc:	0001fc4d 	.word	0x0001fc4d
   174d0:	0001fbbc 	.word	0x0001fbbc
   174d4:	20003b9c 	.word	0x20003b9c
   174d8:	0001fdec 	.word	0x0001fdec

000174dc <ble_sm_create_chan>:
    return rc;
}

struct ble_l2cap_chan *
ble_sm_create_chan(void)
{
   174dc:	b508      	push	{r3, lr}
    struct ble_l2cap_chan *chan;

    chan = ble_l2cap_chan_alloc();
   174de:	f7fe f997 	bl	15810 <ble_l2cap_chan_alloc>
    if (chan == NULL) {
   174e2:	b130      	cbz	r0, 174f2 <ble_sm_create_chan+0x16>
        return NULL;
    }

    chan->blc_cid = BLE_L2CAP_CID_SM;
   174e4:	2306      	movs	r3, #6
   174e6:	8083      	strh	r3, [r0, #4]
    chan->blc_my_mtu = BLE_SM_MTU;
   174e8:	2341      	movs	r3, #65	; 0x41
   174ea:	80c3      	strh	r3, [r0, #6]
    chan->blc_default_mtu = BLE_SM_MTU;
   174ec:	8143      	strh	r3, [r0, #10]
    chan->blc_rx_fn = ble_sm_rx;
   174ee:	4b01      	ldr	r3, [pc, #4]	; (174f4 <ble_sm_create_chan+0x18>)
   174f0:	6183      	str	r3, [r0, #24]

    return chan;
}
   174f2:	bd08      	pop	{r3, pc}
   174f4:	00016eed 	.word	0x00016eed

000174f8 <ble_sm_connection_broken>:
    return res.app_status;
}

void
ble_sm_connection_broken(uint16_t conn_handle)
{
   174f8:	b510      	push	{r4, lr}
   174fa:	b086      	sub	sp, #24
   174fc:	4604      	mov	r4, r0
    struct ble_sm_result res;

    memset(&res, 0, sizeof res);
   174fe:	2218      	movs	r2, #24
   17500:	4668      	mov	r0, sp
   17502:	2100      	movs	r1, #0
   17504:	f7f1 fd85 	bl	9012 <memset>
    res.app_status = BLE_HS_ENOTCONN;
   17508:	2307      	movs	r3, #7
   1750a:	9300      	str	r3, [sp, #0]
    res.enc_cb = 1;

    ble_sm_process_result(conn_handle, &res);
   1750c:	4620      	mov	r0, r4
{
    struct ble_sm_result res;

    memset(&res, 0, sizeof res);
    res.app_status = BLE_HS_ENOTCONN;
    res.enc_cb = 1;
   1750e:	2302      	movs	r3, #2

    ble_sm_process_result(conn_handle, &res);
   17510:	4669      	mov	r1, sp
{
    struct ble_sm_result res;

    memset(&res, 0, sizeof res);
    res.app_status = BLE_HS_ENOTCONN;
    res.enc_cb = 1;
   17512:	f88d 3014 	strb.w	r3, [sp, #20]

    ble_sm_process_result(conn_handle, &res);
   17516:	f7ff fbb1 	bl	16c7c <ble_sm_process_result>
}
   1751a:	b006      	add	sp, #24
   1751c:	bd10      	pop	{r4, pc}
	...

00017520 <ble_sm_init>:
    free(ble_sm_proc_mem);
}

int
ble_sm_init(void)
{
   17520:	b537      	push	{r0, r1, r2, r4, r5, lr}
}

static void
ble_sm_free_mem(void)
{
    free(ble_sm_proc_mem);
   17522:	4d12      	ldr	r5, [pc, #72]	; (1756c <ble_sm_init+0x4c>)
   17524:	6828      	ldr	r0, [r5, #0]
   17526:	f006 fabf 	bl	1daa8 <free>
{
    int rc;

    ble_sm_free_mem();

    STAILQ_INIT(&ble_sm_procs);
   1752a:	4b11      	ldr	r3, [pc, #68]	; (17570 <ble_sm_init+0x50>)
   1752c:	2200      	movs	r2, #0
   1752e:	e883 000c 	stmia.w	r3, {r2, r3}

    if (ble_hs_cfg.max_l2cap_sm_procs > 0) {
   17532:	4b10      	ldr	r3, [pc, #64]	; (17574 <ble_sm_init+0x54>)
   17534:	7b5c      	ldrb	r4, [r3, #13]
   17536:	b90c      	cbnz	r4, 1753c <ble_sm_init+0x1c>
        }
    }

    ble_sm_sc_init();

    return 0;
   17538:	2000      	movs	r0, #0
   1753a:	e015      	b.n	17568 <ble_sm_init+0x48>
    ble_sm_free_mem();

    STAILQ_INIT(&ble_sm_procs);

    if (ble_hs_cfg.max_l2cap_sm_procs > 0) {
        ble_sm_proc_mem = malloc(
   1753c:	0220      	lsls	r0, r4, #8
   1753e:	f006 fa69 	bl	1da14 <malloc>
   17542:	4603      	mov	r3, r0
   17544:	6028      	str	r0, [r5, #0]
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_l2cap_sm_procs,
                             sizeof (struct ble_sm_proc)));
        if (ble_sm_proc_mem == NULL) {
   17546:	b150      	cbz	r0, 1755e <ble_sm_init+0x3e>
            rc = BLE_HS_ENOMEM;
            goto err;
        }
        rc = os_mempool_init(&ble_sm_proc_pool,
   17548:	4a0b      	ldr	r2, [pc, #44]	; (17578 <ble_sm_init+0x58>)
   1754a:	9200      	str	r2, [sp, #0]
   1754c:	4621      	mov	r1, r4
   1754e:	480b      	ldr	r0, [pc, #44]	; (1757c <ble_sm_init+0x5c>)
   17550:	f44f 7280 	mov.w	r2, #256	; 0x100
   17554:	f7f2 ff1c 	bl	a390 <os_mempool_init>
                             ble_hs_cfg.max_l2cap_sm_procs,
                             sizeof (struct ble_sm_proc),
                             ble_sm_proc_mem,
                             "ble_sm_proc_pool");
        if (rc != 0) {
   17558:	4604      	mov	r4, r0
   1755a:	b908      	cbnz	r0, 17560 <ble_sm_init+0x40>
   1755c:	e7ec      	b.n	17538 <ble_sm_init+0x18>
    if (ble_hs_cfg.max_l2cap_sm_procs > 0) {
        ble_sm_proc_mem = malloc(
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_l2cap_sm_procs,
                             sizeof (struct ble_sm_proc)));
        if (ble_sm_proc_mem == NULL) {
            rc = BLE_HS_ENOMEM;
   1755e:	2406      	movs	r4, #6
}

static void
ble_sm_free_mem(void)
{
    free(ble_sm_proc_mem);
   17560:	6828      	ldr	r0, [r5, #0]
   17562:	f006 faa1 	bl	1daa8 <free>

    return 0;

err:
    ble_sm_free_mem();
    return rc;
   17566:	4620      	mov	r0, r4
}
   17568:	b003      	add	sp, #12
   1756a:	bd30      	pop	{r4, r5, pc}
   1756c:	2000229c 	.word	0x2000229c
   17570:	20002278 	.word	0x20002278
   17574:	20003b78 	.word	0x20003b78
   17578:	0001fc55 	.word	0x0001fc55
   1757c:	20002280 	.word	0x20002280

00017580 <ble_sm_alg_encrypt>:
    }
}

static int
ble_sm_alg_encrypt(uint8_t *key, uint8_t *plaintext, uint8_t *enc_data)
{
   17580:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   17582:	4606      	mov	r6, r0
    mbedtls_aes_init(&ble_sm_alg_ctxt);
   17584:	4813      	ldr	r0, [pc, #76]	; (175d4 <ble_sm_alg_encrypt+0x54>)
    }
}

static int
ble_sm_alg_encrypt(uint8_t *key, uint8_t *plaintext, uint8_t *enc_data)
{
   17586:	460c      	mov	r4, r1
   17588:	4615      	mov	r5, r2
    mbedtls_aes_init(&ble_sm_alg_ctxt);
   1758a:	f006 fae5 	bl	1db58 <mbedtls_aes_init>
    uint8_t tmp[16];
    int rc;

    swap_buf(tmp, key, 16);
   1758e:	4668      	mov	r0, sp
   17590:	4631      	mov	r1, r6
   17592:	2210      	movs	r2, #16
   17594:	f005 fdc4 	bl	1d120 <swap_buf>

    rc = mbedtls_aes_setkey_enc(&ble_sm_alg_ctxt, tmp, 128);
   17598:	480e      	ldr	r0, [pc, #56]	; (175d4 <ble_sm_alg_encrypt+0x54>)
   1759a:	4669      	mov	r1, sp
   1759c:	2280      	movs	r2, #128	; 0x80
   1759e:	f006 fae1 	bl	1db64 <mbedtls_aes_setkey_enc>
    if (rc != 0) {
   175a2:	b108      	cbz	r0, 175a8 <ble_sm_alg_encrypt+0x28>
        return BLE_HS_EUNKNOWN;
   175a4:	2011      	movs	r0, #17
   175a6:	e012      	b.n	175ce <ble_sm_alg_encrypt+0x4e>
    }

    swap_buf(tmp, plaintext, 16);
   175a8:	4621      	mov	r1, r4
   175aa:	4668      	mov	r0, sp
   175ac:	2210      	movs	r2, #16
   175ae:	f005 fdb7 	bl	1d120 <swap_buf>

    rc = mbedtls_aes_crypt_ecb(&ble_sm_alg_ctxt, MBEDTLS_AES_ENCRYPT,
   175b2:	4808      	ldr	r0, [pc, #32]	; (175d4 <ble_sm_alg_encrypt+0x54>)
   175b4:	2101      	movs	r1, #1
   175b6:	466a      	mov	r2, sp
   175b8:	462b      	mov	r3, r5
   175ba:	f006 ff93 	bl	1e4e4 <mbedtls_aes_crypt_ecb>
                               tmp, enc_data);
    if (rc != 0) {
   175be:	4604      	mov	r4, r0
   175c0:	2800      	cmp	r0, #0
   175c2:	d1ef      	bne.n	175a4 <ble_sm_alg_encrypt+0x24>
        return BLE_HS_EUNKNOWN;
    }

    swap_in_place(enc_data, 16);
   175c4:	4628      	mov	r0, r5
   175c6:	2110      	movs	r1, #16
   175c8:	f005 fd9d 	bl	1d106 <swap_in_place>

    return 0;
   175cc:	4620      	mov	r0, r4
}
   175ce:	b004      	add	sp, #16
   175d0:	bd70      	pop	{r4, r5, r6, pc}
   175d2:	bf00      	nop
   175d4:	200022a0 	.word	0x200022a0

000175d8 <ble_sm_alg_s1>:
    return 0;
}

int
ble_sm_alg_s1(uint8_t *k, uint8_t *r1, uint8_t *r2, uint8_t *out)
{
   175d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   175dc:	461d      	mov	r5, r3
     * r1' is concatenated with r2' to generate r' which is used as
     * the 128-bit input parameter plaintextData to security function e:
     *
     *    r' = r1' || r2'
     */
    memcpy(out, r2, 8);
   175de:	6813      	ldr	r3, [r2, #0]
   175e0:	602b      	str	r3, [r5, #0]
   175e2:	6853      	ldr	r3, [r2, #4]
   175e4:	606b      	str	r3, [r5, #4]
    memcpy(out + 8, r1, 8);
   175e6:	680b      	ldr	r3, [r1, #0]
   175e8:	60ab      	str	r3, [r5, #8]
   175ea:	684b      	ldr	r3, [r1, #4]
   175ec:	60eb      	str	r3, [r5, #12]
    return 0;
}

int
ble_sm_alg_s1(uint8_t *k, uint8_t *r1, uint8_t *r2, uint8_t *out)
{
   175ee:	460f      	mov	r7, r1
   175f0:	4616      	mov	r6, r2
     */
    memcpy(out, r2, 8);
    memcpy(out + 8, r1, 8);

    /* s1(k, r1 , r2) = e(k, r') */
    rc = ble_sm_alg_encrypt(k, out, out);
   175f2:	4629      	mov	r1, r5
   175f4:	462a      	mov	r2, r5
    return 0;
}

int
ble_sm_alg_s1(uint8_t *k, uint8_t *r1, uint8_t *r2, uint8_t *out)
{
   175f6:	4680      	mov	r8, r0
     */
    memcpy(out, r2, 8);
    memcpy(out + 8, r1, 8);

    /* s1(k, r1 , r2) = e(k, r') */
    rc = ble_sm_alg_encrypt(k, out, out);
   175f8:	f7ff ffc2 	bl	17580 <ble_sm_alg_encrypt>
    if (rc != 0) {
   175fc:	4604      	mov	r4, r0
   175fe:	bb68      	cbnz	r0, 1765c <ble_sm_alg_s1+0x84>
        return rc;
    }

    BLE_HS_LOG(DEBUG, "ble_sm_alg_s1()\n    k=");
   17600:	4622      	mov	r2, r4
   17602:	4b18      	ldr	r3, [pc, #96]	; (17664 <ble_sm_alg_s1+0x8c>)
   17604:	4818      	ldr	r0, [pc, #96]	; (17668 <ble_sm_alg_s1+0x90>)
   17606:	2104      	movs	r1, #4
   17608:	f005 fe0e 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(k, 16);
   1760c:	4640      	mov	r0, r8
   1760e:	2110      	movs	r1, #16
   17610:	f7fd ff68 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    r1=");
   17614:	4622      	mov	r2, r4
   17616:	4b15      	ldr	r3, [pc, #84]	; (1766c <ble_sm_alg_s1+0x94>)
   17618:	4813      	ldr	r0, [pc, #76]	; (17668 <ble_sm_alg_s1+0x90>)
   1761a:	2104      	movs	r1, #4
   1761c:	f005 fe04 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(r1, 16);
   17620:	4638      	mov	r0, r7
   17622:	2110      	movs	r1, #16
   17624:	f7fd ff5e 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    r2=");
   17628:	4622      	mov	r2, r4
   1762a:	4b11      	ldr	r3, [pc, #68]	; (17670 <ble_sm_alg_s1+0x98>)
   1762c:	480e      	ldr	r0, [pc, #56]	; (17668 <ble_sm_alg_s1+0x90>)
   1762e:	2104      	movs	r1, #4
   17630:	f005 fdfa 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(r2, 16);
   17634:	4630      	mov	r0, r6
   17636:	2110      	movs	r1, #16
   17638:	f7fd ff54 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    out=");
   1763c:	4622      	mov	r2, r4
   1763e:	4b0d      	ldr	r3, [pc, #52]	; (17674 <ble_sm_alg_s1+0x9c>)
   17640:	4809      	ldr	r0, [pc, #36]	; (17668 <ble_sm_alg_s1+0x90>)
   17642:	2104      	movs	r1, #4
   17644:	f005 fdf0 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(out, 16);
   17648:	4628      	mov	r0, r5
   1764a:	2110      	movs	r1, #16
   1764c:	f7fd ff4a 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n");
   17650:	4805      	ldr	r0, [pc, #20]	; (17668 <ble_sm_alg_s1+0x90>)
   17652:	4b09      	ldr	r3, [pc, #36]	; (17678 <ble_sm_alg_s1+0xa0>)
   17654:	2104      	movs	r1, #4
   17656:	4622      	mov	r2, r4
   17658:	f005 fde6 	bl	1d228 <log_printf>

    return 0;
}
   1765c:	4620      	mov	r0, r4
   1765e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17662:	bf00      	nop
   17664:	0001fc9c 	.word	0x0001fc9c
   17668:	20003b9c 	.word	0x20003b9c
   1766c:	0001fcb3 	.word	0x0001fcb3
   17670:	0001fcbc 	.word	0x0001fcbc
   17674:	0001fcc5 	.word	0x0001fcc5
   17678:	0001fdec 	.word	0x0001fdec

0001767c <ble_sm_alg_c1>:
ble_sm_alg_c1(uint8_t *k, uint8_t *r,
              uint8_t *preq, uint8_t *pres,
              uint8_t iat, uint8_t rat,
              uint8_t *ia, uint8_t *ra,
              uint8_t *out_enc_data)
{
   1767c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17680:	b08b      	sub	sp, #44	; 0x2c
   17682:	4690      	mov	r8, r2
   17684:	461c      	mov	r4, r3
    uint8_t p1[16], p2[16];
    int rc;

    BLE_HS_LOG(DEBUG, "ble_sm_alg_c1()\n    k=");
   17686:	2200      	movs	r2, #0
   17688:	4b64      	ldr	r3, [pc, #400]	; (1781c <ble_sm_alg_c1+0x1a0>)
ble_sm_alg_c1(uint8_t *k, uint8_t *r,
              uint8_t *preq, uint8_t *pres,
              uint8_t iat, uint8_t rat,
              uint8_t *ia, uint8_t *ra,
              uint8_t *out_enc_data)
{
   1768a:	f89d b050 	ldrb.w	fp, [sp, #80]	; 0x50
   1768e:	f89d a054 	ldrb.w	sl, [sp, #84]	; 0x54
   17692:	9f16      	ldr	r7, [sp, #88]	; 0x58
   17694:	9d18      	ldr	r5, [sp, #96]	; 0x60
   17696:	4606      	mov	r6, r0
   17698:	4689      	mov	r9, r1
    uint8_t p1[16], p2[16];
    int rc;

    BLE_HS_LOG(DEBUG, "ble_sm_alg_c1()\n    k=");
   1769a:	4861      	ldr	r0, [pc, #388]	; (17820 <ble_sm_alg_c1+0x1a4>)
   1769c:	2104      	movs	r1, #4
   1769e:	f005 fdc3 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(k, 16);
   176a2:	4630      	mov	r0, r6
   176a4:	2110      	movs	r1, #16
   176a6:	f7fd ff1d 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    r=");
   176aa:	2200      	movs	r2, #0
   176ac:	4b5d      	ldr	r3, [pc, #372]	; (17824 <ble_sm_alg_c1+0x1a8>)
   176ae:	485c      	ldr	r0, [pc, #368]	; (17820 <ble_sm_alg_c1+0x1a4>)
   176b0:	2104      	movs	r1, #4
   176b2:	f005 fdb9 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(r, 16);
   176b6:	4648      	mov	r0, r9
   176b8:	2110      	movs	r1, #16
   176ba:	f7fd ff13 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    iat=%d rat=%d", iat, rat);
   176be:	f8cd b000 	str.w	fp, [sp]
   176c2:	f8cd a004 	str.w	sl, [sp, #4]
   176c6:	4856      	ldr	r0, [pc, #344]	; (17820 <ble_sm_alg_c1+0x1a4>)
   176c8:	4b57      	ldr	r3, [pc, #348]	; (17828 <ble_sm_alg_c1+0x1ac>)
   176ca:	2104      	movs	r1, #4
   176cc:	2200      	movs	r2, #0
   176ce:	f005 fdab 	bl	1d228 <log_printf>
    BLE_HS_LOG(DEBUG, "\n    ia=");
   176d2:	2200      	movs	r2, #0
   176d4:	4b55      	ldr	r3, [pc, #340]	; (1782c <ble_sm_alg_c1+0x1b0>)
   176d6:	4852      	ldr	r0, [pc, #328]	; (17820 <ble_sm_alg_c1+0x1a4>)
   176d8:	2104      	movs	r1, #4
   176da:	f005 fda5 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(ia, 6);
   176de:	4638      	mov	r0, r7
   176e0:	2106      	movs	r1, #6
   176e2:	f7fd feff 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    ra=");
   176e6:	2200      	movs	r2, #0
   176e8:	4b51      	ldr	r3, [pc, #324]	; (17830 <ble_sm_alg_c1+0x1b4>)
   176ea:	484d      	ldr	r0, [pc, #308]	; (17820 <ble_sm_alg_c1+0x1a4>)
   176ec:	2104      	movs	r1, #4
   176ee:	f005 fd9b 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(ra, 6);
   176f2:	9817      	ldr	r0, [sp, #92]	; 0x5c
   176f4:	2106      	movs	r1, #6
   176f6:	f7fd fef5 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    preq=");
   176fa:	2200      	movs	r2, #0
   176fc:	4b4d      	ldr	r3, [pc, #308]	; (17834 <ble_sm_alg_c1+0x1b8>)
   176fe:	4848      	ldr	r0, [pc, #288]	; (17820 <ble_sm_alg_c1+0x1a4>)
   17700:	2104      	movs	r1, #4
   17702:	f005 fd91 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(preq, 7);
   17706:	4640      	mov	r0, r8
   17708:	2107      	movs	r1, #7
   1770a:	f7fd feeb 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n    pres=");
   1770e:	2200      	movs	r2, #0
   17710:	4b49      	ldr	r3, [pc, #292]	; (17838 <ble_sm_alg_c1+0x1bc>)
   17712:	4843      	ldr	r0, [pc, #268]	; (17820 <ble_sm_alg_c1+0x1a4>)
   17714:	2104      	movs	r1, #4
   17716:	f005 fd87 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(pres, 7);
   1771a:	4620      	mov	r0, r4
   1771c:	2107      	movs	r1, #7
   1771e:	f7fd fee1 	bl	154e4 <ble_hs_log_flat_buf>

    /* pres, preq, rat and iat are concatenated to generate p1 */
    p1[0] = iat;
    p1[1] = rat;
    memcpy(p1 + 2, preq, 7);
   17722:	f8d8 3000 	ldr.w	r3, [r8]
   17726:	f8cd 300a 	str.w	r3, [sp, #10]
   1772a:	f8b8 3004 	ldrh.w	r3, [r8, #4]
   1772e:	f8ad 300e 	strh.w	r3, [sp, #14]
   17732:	f898 3006 	ldrb.w	r3, [r8, #6]
   17736:	f88d 3010 	strb.w	r3, [sp, #16]
    memcpy(p1 + 9, pres, 7);
   1773a:	6823      	ldr	r3, [r4, #0]
   1773c:	f8cd 3011 	str.w	r3, [sp, #17]
   17740:	88a3      	ldrh	r3, [r4, #4]
   17742:	f8ad 3015 	strh.w	r3, [sp, #21]
   17746:	79a3      	ldrb	r3, [r4, #6]
    BLE_HS_LOG(DEBUG, "\n    pres=");
    ble_hs_log_flat_buf(pres, 7);

    /* pres, preq, rat and iat are concatenated to generate p1 */
    p1[0] = iat;
    p1[1] = rat;
   17748:	f88d a009 	strb.w	sl, [sp, #9]
    memcpy(p1 + 2, preq, 7);
    memcpy(p1 + 9, pres, 7);
   1774c:	f88d 3017 	strb.w	r3, [sp, #23]

    BLE_HS_LOG(DEBUG, "\n    p1=");
   17750:	4833      	ldr	r0, [pc, #204]	; (17820 <ble_sm_alg_c1+0x1a4>)
   17752:	4b3a      	ldr	r3, [pc, #232]	; (1783c <ble_sm_alg_c1+0x1c0>)
    ble_hs_log_flat_buf(preq, 7);
    BLE_HS_LOG(DEBUG, "\n    pres=");
    ble_hs_log_flat_buf(pres, 7);

    /* pres, preq, rat and iat are concatenated to generate p1 */
    p1[0] = iat;
   17754:	f88d b008 	strb.w	fp, [sp, #8]
    p1[1] = rat;
    memcpy(p1 + 2, preq, 7);
    memcpy(p1 + 9, pres, 7);

    BLE_HS_LOG(DEBUG, "\n    p1=");
   17758:	2104      	movs	r1, #4
   1775a:	2200      	movs	r2, #0
    ble_hs_log_flat_buf(pres, 7);

    /* pres, preq, rat and iat are concatenated to generate p1 */
    p1[0] = iat;
    p1[1] = rat;
    memcpy(p1 + 2, preq, 7);
   1775c:	f10d 0a08 	add.w	sl, sp, #8
    memcpy(p1 + 9, pres, 7);

    BLE_HS_LOG(DEBUG, "\n    p1=");
   17760:	f005 fd62 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(p1, sizeof p1);
   17764:	4650      	mov	r0, sl
   17766:	2110      	movs	r1, #16
   17768:	f7fd febc 	bl	154e4 <ble_hs_log_flat_buf>
static void
ble_sm_alg_xor_128(uint8_t *p, uint8_t *q, uint8_t *r)
{
    int i;

    for (i = 0; i < 16; i++) {
   1776c:	f04f 0b00 	mov.w	fp, #0
        r[i] = p[i] ^ q[i];
   17770:	f819 300b 	ldrb.w	r3, [r9, fp]
   17774:	f81a 200b 	ldrb.w	r2, [sl, fp]
   17778:	4053      	eors	r3, r2
   1777a:	f805 300b 	strb.w	r3, [r5, fp]
static void
ble_sm_alg_xor_128(uint8_t *p, uint8_t *q, uint8_t *r)
{
    int i;

    for (i = 0; i < 16; i++) {
   1777e:	f10b 0b01 	add.w	fp, fp, #1
   17782:	f1bb 0f10 	cmp.w	fp, #16
   17786:	d1f3      	bne.n	17770 <ble_sm_alg_c1+0xf4>
    /* c1 = e(k, e(k, r XOR p1) XOR p2) */

    /* Using out_enc_data as temporary output buffer */
    ble_sm_alg_xor_128(r, p1, out_enc_data);

    rc = ble_sm_alg_encrypt(k, out_enc_data, out_enc_data);
   17788:	4630      	mov	r0, r6
   1778a:	4629      	mov	r1, r5
   1778c:	462a      	mov	r2, r5
   1778e:	f7ff fef7 	bl	17580 <ble_sm_alg_encrypt>
    if (rc != 0) {
   17792:	4604      	mov	r4, r0
   17794:	b108      	cbz	r0, 1779a <ble_sm_alg_c1+0x11e>
        rc = BLE_HS_EUNKNOWN;
   17796:	2611      	movs	r6, #17
   17798:	e034      	b.n	17804 <ble_sm_alg_c1+0x188>
        goto done;
    }

    /* ra is concatenated with ia and padding to generate p2 */
    memcpy(p2, ra, 6);
   1779a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    memcpy(p2 + 6, ia, 6);
    memset(p2 + 12, 0, 4);
   1779c:	9409      	str	r4, [sp, #36]	; 0x24
        rc = BLE_HS_EUNKNOWN;
        goto done;
    }

    /* ra is concatenated with ia and padding to generate p2 */
    memcpy(p2, ra, 6);
   1779e:	f10d 0918 	add.w	r9, sp, #24
   177a2:	6818      	ldr	r0, [r3, #0]
   177a4:	889b      	ldrh	r3, [r3, #4]
   177a6:	9006      	str	r0, [sp, #24]
   177a8:	f8a9 3004 	strh.w	r3, [r9, #4]
    memcpy(p2 + 6, ia, 6);
   177ac:	683b      	ldr	r3, [r7, #0]
   177ae:	f8cd 301e 	str.w	r3, [sp, #30]
   177b2:	88bb      	ldrh	r3, [r7, #4]
   177b4:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
    memset(p2 + 12, 0, 4);

    BLE_HS_LOG(DEBUG, "\n    p2=");
   177b8:	4819      	ldr	r0, [pc, #100]	; (17820 <ble_sm_alg_c1+0x1a4>)
   177ba:	4b21      	ldr	r3, [pc, #132]	; (17840 <ble_sm_alg_c1+0x1c4>)
   177bc:	2104      	movs	r1, #4
   177be:	4622      	mov	r2, r4
   177c0:	f005 fd32 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(p2, sizeof p2);
   177c4:	4648      	mov	r0, r9
   177c6:	4659      	mov	r1, fp
   177c8:	f7fd fe8c 	bl	154e4 <ble_hs_log_flat_buf>
   177cc:	1e6b      	subs	r3, r5, #1
ble_sm_alg_xor_128(uint8_t *p, uint8_t *q, uint8_t *r)
{
    int i;

    for (i = 0; i < 16; i++) {
        r[i] = p[i] ^ q[i];
   177ce:	f819 1004 	ldrb.w	r1, [r9, r4]
   177d2:	f813 2f01 	ldrb.w	r2, [r3, #1]!
static void
ble_sm_alg_xor_128(uint8_t *p, uint8_t *q, uint8_t *r)
{
    int i;

    for (i = 0; i < 16; i++) {
   177d6:	3401      	adds	r4, #1
        r[i] = p[i] ^ q[i];
   177d8:	404a      	eors	r2, r1
static void
ble_sm_alg_xor_128(uint8_t *p, uint8_t *q, uint8_t *r)
{
    int i;

    for (i = 0; i < 16; i++) {
   177da:	2c10      	cmp	r4, #16
        r[i] = p[i] ^ q[i];
   177dc:	701a      	strb	r2, [r3, #0]
static void
ble_sm_alg_xor_128(uint8_t *p, uint8_t *q, uint8_t *r)
{
    int i;

    for (i = 0; i < 16; i++) {
   177de:	d1f6      	bne.n	177ce <ble_sm_alg_c1+0x152>
    BLE_HS_LOG(DEBUG, "\n    p2=");
    ble_hs_log_flat_buf(p2, sizeof p2);

    ble_sm_alg_xor_128(out_enc_data, p2, out_enc_data);

    rc = ble_sm_alg_encrypt(k, out_enc_data, out_enc_data);
   177e0:	4630      	mov	r0, r6
   177e2:	4629      	mov	r1, r5
   177e4:	462a      	mov	r2, r5
   177e6:	f7ff fecb 	bl	17580 <ble_sm_alg_encrypt>
    if (rc != 0) {
   177ea:	4606      	mov	r6, r0
   177ec:	2800      	cmp	r0, #0
   177ee:	d1d2      	bne.n	17796 <ble_sm_alg_c1+0x11a>
        rc = BLE_HS_EUNKNOWN;
        goto done;
    }

    BLE_HS_LOG(DEBUG, "\n    out_enc_data=");
   177f0:	480b      	ldr	r0, [pc, #44]	; (17820 <ble_sm_alg_c1+0x1a4>)
   177f2:	4b14      	ldr	r3, [pc, #80]	; (17844 <ble_sm_alg_c1+0x1c8>)
   177f4:	2104      	movs	r1, #4
   177f6:	4632      	mov	r2, r6
   177f8:	f005 fd16 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(out_enc_data, 16);
   177fc:	4628      	mov	r0, r5
   177fe:	4621      	mov	r1, r4
   17800:	f7fd fe70 	bl	154e4 <ble_hs_log_flat_buf>

    rc = 0;

done:
    BLE_HS_LOG(DEBUG, "\n    rc=%d\n", rc);
   17804:	9600      	str	r6, [sp, #0]
   17806:	4806      	ldr	r0, [pc, #24]	; (17820 <ble_sm_alg_c1+0x1a4>)
   17808:	4b0f      	ldr	r3, [pc, #60]	; (17848 <ble_sm_alg_c1+0x1cc>)
   1780a:	2104      	movs	r1, #4
   1780c:	2200      	movs	r2, #0
   1780e:	f005 fd0b 	bl	1d228 <log_printf>
    return rc;
}
   17812:	4630      	mov	r0, r6
   17814:	b00b      	add	sp, #44	; 0x2c
   17816:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1781a:	bf00      	nop
   1781c:	0001fccf 	.word	0x0001fccf
   17820:	20003b9c 	.word	0x20003b9c
   17824:	0001fce6 	.word	0x0001fce6
   17828:	0001fcee 	.word	0x0001fcee
   1782c:	0001fd01 	.word	0x0001fd01
   17830:	0001fd0a 	.word	0x0001fd0a
   17834:	0001fd13 	.word	0x0001fd13
   17838:	0001fd1e 	.word	0x0001fd1e
   1783c:	0001fd29 	.word	0x0001fd29
   17840:	0001fd32 	.word	0x0001fd32
   17844:	0001fd3b 	.word	0x0001fd3b
   17848:	0001fd4e 	.word	0x0001fd4e

0001784c <ble_sm_tx>:

#if NIMBLE_OPT(SM)

static int
ble_sm_tx(uint16_t conn_handle, struct os_mbuf *txom)
{
   1784c:	b513      	push	{r0, r1, r4, lr}
    struct ble_hs_conn *conn;
    int rc;

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    STATS_INC(ble_l2cap_stats, sm_tx);
   1784e:	4a09      	ldr	r2, [pc, #36]	; (17874 <ble_sm_tx+0x28>)
   17850:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   17852:	3301      	adds	r3, #1
   17854:	62d3      	str	r3, [r2, #44]	; 0x2c

#if NIMBLE_OPT(SM)

static int
ble_sm_tx(uint16_t conn_handle, struct os_mbuf *txom)
{
   17856:	460c      	mov	r4, r1

    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());

    STATS_INC(ble_l2cap_stats, sm_tx);

    rc = ble_hs_misc_conn_chan_find_reqd(conn_handle, BLE_L2CAP_CID_SM,
   17858:	aa01      	add	r2, sp, #4
   1785a:	2106      	movs	r1, #6
   1785c:	466b      	mov	r3, sp
   1785e:	f7fd fe94 	bl	1558a <ble_hs_misc_conn_chan_find_reqd>
                                         &conn, &chan);
    if (rc == 0) {
   17862:	b920      	cbnz	r0, 1786e <ble_sm_tx+0x22>
        rc = ble_l2cap_tx(conn, chan, txom);
   17864:	9801      	ldr	r0, [sp, #4]
   17866:	9900      	ldr	r1, [sp, #0]
   17868:	4622      	mov	r2, r4
   1786a:	f7fe f8a9 	bl	159c0 <ble_l2cap_tx>
    }

    return rc;
}
   1786e:	b002      	add	sp, #8
   17870:	bd10      	pop	{r4, pc}
   17872:	bf00      	nop
   17874:	20003bdc 	.word	0x20003bdc

00017878 <ble_sm_init_req>:

static int
ble_sm_init_req(uint16_t initial_sz, struct os_mbuf **out_txom)
{
   17878:	b538      	push	{r3, r4, r5, lr}
   1787a:	460d      	mov	r5, r1
   1787c:	4604      	mov	r4, r0
    void *buf;
    int rc;

    *out_txom = ble_hs_misc_pkthdr();
   1787e:	f7fd fe49 	bl	15514 <ble_hs_misc_pkthdr>
   17882:	6028      	str	r0, [r5, #0]
    if (*out_txom == NULL) {
   17884:	b930      	cbnz	r0, 17894 <ble_sm_init_req+0x1c>
    }

    return 0;

err:
    os_mbuf_free_chain(*out_txom);
   17886:	6828      	ldr	r0, [r5, #0]
   17888:	f7f2 fb69 	bl	9f5e <os_mbuf_free_chain>
    *out_txom = NULL;
   1788c:	2300      	movs	r3, #0
   1788e:	602b      	str	r3, [r5, #0]
   17890:	2006      	movs	r0, #6
   17892:	bd38      	pop	{r3, r4, r5, pc}
    if (*out_txom == NULL) {
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    buf = os_mbuf_extend(*out_txom, BLE_SM_HDR_SZ + initial_sz);
   17894:	1c61      	adds	r1, r4, #1
   17896:	b289      	uxth	r1, r1
   17898:	f7f2 fcea 	bl	a270 <os_mbuf_extend>
    if (buf == NULL) {
   1789c:	2800      	cmp	r0, #0
   1789e:	d0f2      	beq.n	17886 <ble_sm_init_req+0xe>
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    return 0;
   178a0:	2000      	movs	r0, #0

err:
    os_mbuf_free_chain(*out_txom);
    *out_txom = NULL;
    return rc;
}
   178a2:	bd38      	pop	{r3, r4, r5, pc}

000178a4 <ble_sm_pair_cmd_parse>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(len >= BLE_SM_PAIR_CMD_SZ);

    u8ptr = payload;
    cmd->io_cap = u8ptr[0];
   178a4:	7803      	ldrb	r3, [r0, #0]
   178a6:	7013      	strb	r3, [r2, #0]
    cmd->oob_data_flag = u8ptr[1];
   178a8:	7843      	ldrb	r3, [r0, #1]
   178aa:	7053      	strb	r3, [r2, #1]
    cmd->authreq = u8ptr[2];
   178ac:	7883      	ldrb	r3, [r0, #2]
   178ae:	7093      	strb	r3, [r2, #2]
    cmd->max_enc_key_size = u8ptr[3];
   178b0:	78c3      	ldrb	r3, [r0, #3]
   178b2:	70d3      	strb	r3, [r2, #3]
    cmd->init_key_dist = u8ptr[4];
   178b4:	7903      	ldrb	r3, [r0, #4]
   178b6:	7113      	strb	r3, [r2, #4]
    cmd->resp_key_dist = u8ptr[5];
   178b8:	7943      	ldrb	r3, [r0, #5]
   178ba:	7153      	strb	r3, [r2, #5]
   178bc:	4770      	bx	lr

000178be <ble_sm_pair_cmd_is_valid>:
}

int
ble_sm_pair_cmd_is_valid(struct ble_sm_pair_cmd *cmd)
{
    if (cmd->io_cap >= BLE_SM_IO_CAP_RESERVED) {
   178be:	7803      	ldrb	r3, [r0, #0]
   178c0:	2b04      	cmp	r3, #4
    cmd->resp_key_dist = u8ptr[5];
}

int
ble_sm_pair_cmd_is_valid(struct ble_sm_pair_cmd *cmd)
{
   178c2:	4602      	mov	r2, r0
    if (cmd->io_cap >= BLE_SM_IO_CAP_RESERVED) {
   178c4:	d815      	bhi.n	178f2 <ble_sm_pair_cmd_is_valid+0x34>
        return 0;
    }

    if (cmd->oob_data_flag >= BLE_SM_PAIR_OOB_RESERVED) {
   178c6:	7843      	ldrb	r3, [r0, #1]
   178c8:	2b01      	cmp	r3, #1
   178ca:	d812      	bhi.n	178f2 <ble_sm_pair_cmd_is_valid+0x34>
        return 0;
    }

    if (cmd->authreq & BLE_SM_PAIR_AUTHREQ_RESERVED) {
   178cc:	7883      	ldrb	r3, [r0, #2]
   178ce:	f013 00e2 	ands.w	r0, r3, #226	; 0xe2
   178d2:	d10e      	bne.n	178f2 <ble_sm_pair_cmd_is_valid+0x34>
        return 0;
    }

    if (cmd->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN ||
   178d4:	78d3      	ldrb	r3, [r2, #3]
   178d6:	3b07      	subs	r3, #7
   178d8:	2b09      	cmp	r3, #9
   178da:	d80b      	bhi.n	178f4 <ble_sm_pair_cmd_is_valid+0x36>
        cmd->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {

        return 0;
    }

    if (cmd->init_key_dist & BLE_SM_PAIR_KEY_DIST_RESERVED) {
   178dc:	7913      	ldrb	r3, [r2, #4]
   178de:	f013 0ff0 	tst.w	r3, #240	; 0xf0
   178e2:	d107      	bne.n	178f4 <ble_sm_pair_cmd_is_valid+0x36>
        return 0;
    }

    if (cmd->resp_key_dist & BLE_SM_PAIR_KEY_DIST_RESERVED) {
   178e4:	7953      	ldrb	r3, [r2, #5]
   178e6:	f013 0ff0 	tst.w	r3, #240	; 0xf0
   178ea:	bf0c      	ite	eq
   178ec:	2001      	moveq	r0, #1
   178ee:	2000      	movne	r0, #0
   178f0:	4770      	bx	lr

int
ble_sm_pair_cmd_is_valid(struct ble_sm_pair_cmd *cmd)
{
    if (cmd->io_cap >= BLE_SM_IO_CAP_RESERVED) {
        return 0;
   178f2:	2000      	movs	r0, #0
    if (cmd->resp_key_dist & BLE_SM_PAIR_KEY_DIST_RESERVED) {
        return 0;
    }

    return 1;
}
   178f4:	4770      	bx	lr

000178f6 <ble_sm_pair_cmd_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_PAIR_CMD_SZ);

    u8ptr = payload;
    u8ptr[0] = is_req ? BLE_SM_OP_PAIR_REQ : BLE_SM_OP_PAIR_RSP;
   178f6:	2a00      	cmp	r2, #0
   178f8:	bf14      	ite	ne
   178fa:	2201      	movne	r2, #1
   178fc:	2202      	moveq	r2, #2
   178fe:	7002      	strb	r2, [r0, #0]
    u8ptr[1] = cmd->io_cap;
   17900:	781a      	ldrb	r2, [r3, #0]
   17902:	7042      	strb	r2, [r0, #1]
    u8ptr[2] = cmd->oob_data_flag;
   17904:	785a      	ldrb	r2, [r3, #1]
   17906:	7082      	strb	r2, [r0, #2]
    u8ptr[3] = cmd->authreq;
   17908:	789a      	ldrb	r2, [r3, #2]
   1790a:	70c2      	strb	r2, [r0, #3]
    u8ptr[4] = cmd->max_enc_key_size;
   1790c:	78da      	ldrb	r2, [r3, #3]
   1790e:	7102      	strb	r2, [r0, #4]
    u8ptr[5] = cmd->init_key_dist;
   17910:	791a      	ldrb	r2, [r3, #4]
   17912:	7142      	strb	r2, [r0, #5]
    u8ptr[6] = cmd->resp_key_dist;
   17914:	795b      	ldrb	r3, [r3, #5]
   17916:	7183      	strb	r3, [r0, #6]
   17918:	4770      	bx	lr
	...

0001791c <ble_sm_pair_cmd_log>:
    return rc;
}

void
ble_sm_pair_cmd_log(struct ble_sm_pair_cmd *cmd)
{
   1791c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    BLE_HS_LOG(DEBUG, "io_cap=%d oob_data_flag=%d authreq=0x%02x "
   1791e:	7803      	ldrb	r3, [r0, #0]
   17920:	9300      	str	r3, [sp, #0]
   17922:	7843      	ldrb	r3, [r0, #1]
   17924:	9301      	str	r3, [sp, #4]
   17926:	7883      	ldrb	r3, [r0, #2]
   17928:	9302      	str	r3, [sp, #8]
   1792a:	78c3      	ldrb	r3, [r0, #3]
   1792c:	9303      	str	r3, [sp, #12]
   1792e:	7903      	ldrb	r3, [r0, #4]
   17930:	9304      	str	r3, [sp, #16]
   17932:	7943      	ldrb	r3, [r0, #5]
   17934:	9305      	str	r3, [sp, #20]
   17936:	4804      	ldr	r0, [pc, #16]	; (17948 <ble_sm_pair_cmd_log+0x2c>)
   17938:	4b04      	ldr	r3, [pc, #16]	; (1794c <ble_sm_pair_cmd_log+0x30>)
   1793a:	2104      	movs	r1, #4
   1793c:	2200      	movs	r2, #0
   1793e:	f005 fc73 	bl	1d228 <log_printf>
                      "mac_enc_key_size=%d init_key_dist=%d "
                      "resp_key_dist=%d",
               cmd->io_cap, cmd->oob_data_flag, cmd->authreq,
               cmd->max_enc_key_size, cmd->init_key_dist,
               cmd->resp_key_dist);
}
   17942:	b007      	add	sp, #28
   17944:	f85d fb04 	ldr.w	pc, [sp], #4
   17948:	20003b9c 	.word	0x20003b9c
   1794c:	0001fe00 	.word	0x0001fe00

00017950 <ble_sm_pair_cmd_tx>:
}

int
ble_sm_pair_cmd_tx(uint16_t conn_handle, int is_req,
                   struct ble_sm_pair_cmd *cmd)
{
   17950:	b5f0      	push	{r4, r5, r6, r7, lr}
   17952:	b087      	sub	sp, #28
   17954:	4605      	mov	r5, r0
   17956:	460f      	mov	r7, r1
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_PAIR_CMD_SZ, &txom);
   17958:	2006      	movs	r0, #6
   1795a:	a905      	add	r1, sp, #20
}

int
ble_sm_pair_cmd_tx(uint16_t conn_handle, int is_req,
                   struct ble_sm_pair_cmd *cmd)
{
   1795c:	4616      	mov	r6, r2
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_PAIR_CMD_SZ, &txom);
   1795e:	f7ff ff8b 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17962:	4604      	mov	r4, r0
   17964:	bb38      	cbnz	r0, 179b6 <ble_sm_pair_cmd_tx+0x66>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_pair_cmd_write(txom->om_data, txom->om_len, is_req, cmd);
   17966:	9b05      	ldr	r3, [sp, #20]
   17968:	463a      	mov	r2, r7
   1796a:	6818      	ldr	r0, [r3, #0]
   1796c:	88d9      	ldrh	r1, [r3, #6]
   1796e:	4633      	mov	r3, r6
   17970:	f7ff ffc1 	bl	178f6 <ble_sm_pair_cmd_write>
    BLE_SM_LOG_CMD(1, is_req ? "pair req" : "pair rsp", conn_handle,
   17974:	4b13      	ldr	r3, [pc, #76]	; (179c4 <ble_sm_pair_cmd_tx+0x74>)
   17976:	4914      	ldr	r1, [pc, #80]	; (179c8 <ble_sm_pair_cmd_tx+0x78>)
   17978:	9503      	str	r5, [sp, #12]
   1797a:	2f00      	cmp	r7, #0
   1797c:	bf18      	it	ne
   1797e:	4619      	movne	r1, r3
   17980:	4b12      	ldr	r3, [pc, #72]	; (179cc <ble_sm_pair_cmd_tx+0x7c>)
   17982:	9300      	str	r3, [sp, #0]
   17984:	4b12      	ldr	r3, [pc, #72]	; (179d0 <ble_sm_pair_cmd_tx+0x80>)
   17986:	9301      	str	r3, [sp, #4]
   17988:	4622      	mov	r2, r4
   1798a:	4b12      	ldr	r3, [pc, #72]	; (179d4 <ble_sm_pair_cmd_tx+0x84>)
   1798c:	9102      	str	r1, [sp, #8]
   1798e:	4812      	ldr	r0, [pc, #72]	; (179d8 <ble_sm_pair_cmd_tx+0x88>)
   17990:	2104      	movs	r1, #4
   17992:	f005 fc49 	bl	1d228 <log_printf>
   17996:	4630      	mov	r0, r6
   17998:	f7ff ffc0 	bl	1791c <ble_sm_pair_cmd_log>
   1799c:	480e      	ldr	r0, [pc, #56]	; (179d8 <ble_sm_pair_cmd_tx+0x88>)
   1799e:	4b0f      	ldr	r3, [pc, #60]	; (179dc <ble_sm_pair_cmd_tx+0x8c>)
   179a0:	2104      	movs	r1, #4
   179a2:	4622      	mov	r2, r4
   179a4:	f005 fc40 	bl	1d228 <log_printf>
                   ble_sm_pair_cmd_log, cmd);
    BLE_HS_DBG_ASSERT(ble_sm_pair_cmd_is_valid(cmd));

    rc = ble_sm_tx(conn_handle, txom);
   179a8:	4628      	mov	r0, r5
   179aa:	9905      	ldr	r1, [sp, #20]
   179ac:	f7ff ff4e 	bl	1784c <ble_sm_tx>
    txom = NULL;
   179b0:	9405      	str	r4, [sp, #20]
    ble_sm_pair_cmd_write(txom->om_data, txom->om_len, is_req, cmd);
    BLE_SM_LOG_CMD(1, is_req ? "pair req" : "pair rsp", conn_handle,
                   ble_sm_pair_cmd_log, cmd);
    BLE_HS_DBG_ASSERT(ble_sm_pair_cmd_is_valid(cmd));

    rc = ble_sm_tx(conn_handle, txom);
   179b2:	4605      	mov	r5, r0
   179b4:	e000      	b.n	179b8 <ble_sm_pair_cmd_tx+0x68>
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_PAIR_CMD_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   179b6:	2506      	movs	r5, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   179b8:	9805      	ldr	r0, [sp, #20]
   179ba:	f7f2 fad0 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   179be:	4628      	mov	r0, r5
   179c0:	b007      	add	sp, #28
   179c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   179c4:	0001fc2c 	.word	0x0001fc2c
   179c8:	0001fc3d 	.word	0x0001fc3d
   179cc:	0001fe60 	.word	0x0001fe60
   179d0:	0001fbdd 	.word	0x0001fbdd
   179d4:	0001fbbc 	.word	0x0001fbbc
   179d8:	20003b9c 	.word	0x20003b9c
   179dc:	0001fdec 	.word	0x0001fdec

000179e0 <ble_sm_pair_confirm_parse>:
void
ble_sm_pair_confirm_parse(void *payload, int len,
                          struct ble_sm_pair_confirm *cmd)
{
    BLE_HS_DBG_ASSERT(len >= BLE_SM_PAIR_CONFIRM_SZ);
    memcpy(cmd->value, payload, sizeof cmd->value);
   179e0:	f100 0310 	add.w	r3, r0, #16
   179e4:	f850 1b04 	ldr.w	r1, [r0], #4
   179e8:	f842 1b04 	str.w	r1, [r2], #4
   179ec:	4298      	cmp	r0, r3
   179ee:	d1f9      	bne.n	179e4 <ble_sm_pair_confirm_parse+0x4>
}
   179f0:	4770      	bx	lr

000179f2 <ble_sm_pair_confirm_write>:

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_PAIR_CONFIRM_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_PAIR_CONFIRM;
   179f2:	2303      	movs	r3, #3
   179f4:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->value, sizeof cmd->value);
   179f8:	f102 0310 	add.w	r3, r2, #16
   179fc:	f852 1b04 	ldr.w	r1, [r2], #4
   17a00:	f840 1b04 	str.w	r1, [r0], #4
   17a04:	429a      	cmp	r2, r3
   17a06:	d1f9      	bne.n	179fc <ble_sm_pair_confirm_write+0xa>
}
   17a08:	4770      	bx	lr
	...

00017a0c <ble_sm_pair_confirm_log>:
    return rc;
}

void
ble_sm_pair_confirm_log(struct ble_sm_pair_confirm *cmd)
{
   17a0c:	b510      	push	{r4, lr}
    BLE_HS_LOG(DEBUG, "value=");
   17a0e:	2104      	movs	r1, #4
    return rc;
}

void
ble_sm_pair_confirm_log(struct ble_sm_pair_confirm *cmd)
{
   17a10:	4604      	mov	r4, r0
    BLE_HS_LOG(DEBUG, "value=");
   17a12:	2200      	movs	r2, #0
   17a14:	4804      	ldr	r0, [pc, #16]	; (17a28 <ble_sm_pair_confirm_log+0x1c>)
   17a16:	4b05      	ldr	r3, [pc, #20]	; (17a2c <ble_sm_pair_confirm_log+0x20>)
   17a18:	f005 fc06 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(cmd->value, sizeof cmd->value);
   17a1c:	4620      	mov	r0, r4
   17a1e:	2110      	movs	r1, #16
}
   17a20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void
ble_sm_pair_confirm_log(struct ble_sm_pair_confirm *cmd)
{
    BLE_HS_LOG(DEBUG, "value=");
    ble_hs_log_flat_buf(cmd->value, sizeof cmd->value);
   17a24:	f7fd bd5e 	b.w	154e4 <ble_hs_log_flat_buf>
   17a28:	20003b9c 	.word	0x20003b9c
   17a2c:	0001fe63 	.word	0x0001fe63

00017a30 <ble_sm_pair_confirm_tx>:
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->value, sizeof cmd->value);
}

int
ble_sm_pair_confirm_tx(uint16_t conn_handle, struct ble_sm_pair_confirm *cmd)
{
   17a30:	b570      	push	{r4, r5, r6, lr}
   17a32:	b086      	sub	sp, #24
   17a34:	4605      	mov	r5, r0
   17a36:	460e      	mov	r6, r1
    struct os_mbuf *txom;
    int rc;


    rc = ble_sm_init_req(BLE_SM_PAIR_CONFIRM_SZ, &txom);
   17a38:	2010      	movs	r0, #16
   17a3a:	a905      	add	r1, sp, #20
   17a3c:	f7ff ff1c 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17a40:	4604      	mov	r4, r0
   17a42:	bb10      	cbnz	r0, 17a8a <ble_sm_pair_confirm_tx+0x5a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_pair_confirm_write(txom->om_data, txom->om_len, cmd);
   17a44:	9b05      	ldr	r3, [sp, #20]
   17a46:	4632      	mov	r2, r6
   17a48:	6818      	ldr	r0, [r3, #0]
   17a4a:	88d9      	ldrh	r1, [r3, #6]
   17a4c:	f7ff ffd1 	bl	179f2 <ble_sm_pair_confirm_write>
    BLE_SM_LOG_CMD(1, "confirm", conn_handle, ble_sm_pair_confirm_log, cmd);
   17a50:	4b11      	ldr	r3, [pc, #68]	; (17a98 <ble_sm_pair_confirm_tx+0x68>)
   17a52:	9300      	str	r3, [sp, #0]
   17a54:	4b11      	ldr	r3, [pc, #68]	; (17a9c <ble_sm_pair_confirm_tx+0x6c>)
   17a56:	9301      	str	r3, [sp, #4]
   17a58:	4b11      	ldr	r3, [pc, #68]	; (17aa0 <ble_sm_pair_confirm_tx+0x70>)
   17a5a:	9302      	str	r3, [sp, #8]
   17a5c:	2104      	movs	r1, #4
   17a5e:	4622      	mov	r2, r4
   17a60:	4b10      	ldr	r3, [pc, #64]	; (17aa4 <ble_sm_pair_confirm_tx+0x74>)
   17a62:	9503      	str	r5, [sp, #12]
   17a64:	4810      	ldr	r0, [pc, #64]	; (17aa8 <ble_sm_pair_confirm_tx+0x78>)
   17a66:	f005 fbdf 	bl	1d228 <log_printf>
   17a6a:	4630      	mov	r0, r6
   17a6c:	f7ff ffce 	bl	17a0c <ble_sm_pair_confirm_log>
   17a70:	480d      	ldr	r0, [pc, #52]	; (17aa8 <ble_sm_pair_confirm_tx+0x78>)
   17a72:	4b0e      	ldr	r3, [pc, #56]	; (17aac <ble_sm_pair_confirm_tx+0x7c>)
   17a74:	2104      	movs	r1, #4
   17a76:	4622      	mov	r2, r4
   17a78:	f005 fbd6 	bl	1d228 <log_printf>

    rc = ble_sm_tx(conn_handle, txom);
   17a7c:	4628      	mov	r0, r5
   17a7e:	9905      	ldr	r1, [sp, #20]
   17a80:	f7ff fee4 	bl	1784c <ble_sm_tx>
    txom = NULL;
   17a84:	9405      	str	r4, [sp, #20]
    }

    ble_sm_pair_confirm_write(txom->om_data, txom->om_len, cmd);
    BLE_SM_LOG_CMD(1, "confirm", conn_handle, ble_sm_pair_confirm_log, cmd);

    rc = ble_sm_tx(conn_handle, txom);
   17a86:	4605      	mov	r5, r0
   17a88:	e000      	b.n	17a8c <ble_sm_pair_confirm_tx+0x5c>
    int rc;


    rc = ble_sm_init_req(BLE_SM_PAIR_CONFIRM_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   17a8a:	2506      	movs	r5, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   17a8c:	9805      	ldr	r0, [sp, #20]
   17a8e:	f7f2 fa66 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   17a92:	4628      	mov	r0, r5
   17a94:	b006      	add	sp, #24
   17a96:	bd70      	pop	{r4, r5, r6, pc}
   17a98:	0001fe60 	.word	0x0001fe60
   17a9c:	0001fbdd 	.word	0x0001fbdd
   17aa0:	0001fc35 	.word	0x0001fc35
   17aa4:	0001fbbc 	.word	0x0001fbbc
   17aa8:	20003b9c 	.word	0x20003b9c
   17aac:	0001fdec 	.word	0x0001fdec

00017ab0 <ble_sm_pair_random_parse>:
void
ble_sm_pair_random_parse(void *payload, int len,
                         struct ble_sm_pair_random *cmd)
{
    BLE_HS_DBG_ASSERT(len >= BLE_SM_PAIR_RANDOM_SZ);
    memcpy(cmd->value, payload, sizeof cmd->value);
   17ab0:	f100 0310 	add.w	r3, r0, #16
   17ab4:	f850 1b04 	ldr.w	r1, [r0], #4
   17ab8:	f842 1b04 	str.w	r1, [r2], #4
   17abc:	4298      	cmp	r0, r3
   17abe:	d1f9      	bne.n	17ab4 <ble_sm_pair_random_parse+0x4>
}
   17ac0:	4770      	bx	lr

00017ac2 <ble_sm_pair_random_write>:
    BLE_HS_DBG_ASSERT(len >=
                      BLE_SM_HDR_SZ + BLE_SM_PAIR_RANDOM_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_PAIR_RANDOM;
   17ac2:	2304      	movs	r3, #4
   17ac4:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->value, sizeof cmd->value);
   17ac8:	f102 0310 	add.w	r3, r2, #16
   17acc:	f852 1b04 	ldr.w	r1, [r2], #4
   17ad0:	f840 1b04 	str.w	r1, [r0], #4
   17ad4:	429a      	cmp	r2, r3
   17ad6:	d1f9      	bne.n	17acc <ble_sm_pair_random_write+0xa>
}
   17ad8:	4770      	bx	lr
	...

00017adc <ble_sm_pair_random_log>:
    return rc;
}

void
ble_sm_pair_random_log(struct ble_sm_pair_random *cmd)
{
   17adc:	b510      	push	{r4, lr}
    BLE_HS_LOG(DEBUG, "value=");
   17ade:	2104      	movs	r1, #4
    return rc;
}

void
ble_sm_pair_random_log(struct ble_sm_pair_random *cmd)
{
   17ae0:	4604      	mov	r4, r0
    BLE_HS_LOG(DEBUG, "value=");
   17ae2:	2200      	movs	r2, #0
   17ae4:	4804      	ldr	r0, [pc, #16]	; (17af8 <ble_sm_pair_random_log+0x1c>)
   17ae6:	4b05      	ldr	r3, [pc, #20]	; (17afc <ble_sm_pair_random_log+0x20>)
   17ae8:	f005 fb9e 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(cmd->value, sizeof cmd->value);
   17aec:	4620      	mov	r0, r4
   17aee:	2110      	movs	r1, #16
}
   17af0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void
ble_sm_pair_random_log(struct ble_sm_pair_random *cmd)
{
    BLE_HS_LOG(DEBUG, "value=");
    ble_hs_log_flat_buf(cmd->value, sizeof cmd->value);
   17af4:	f7fd bcf6 	b.w	154e4 <ble_hs_log_flat_buf>
   17af8:	20003b9c 	.word	0x20003b9c
   17afc:	0001fe63 	.word	0x0001fe63

00017b00 <ble_sm_pair_random_tx>:
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->value, sizeof cmd->value);
}

int
ble_sm_pair_random_tx(uint16_t conn_handle, struct ble_sm_pair_random *cmd)
{
   17b00:	b570      	push	{r4, r5, r6, lr}
   17b02:	b086      	sub	sp, #24
   17b04:	4605      	mov	r5, r0
   17b06:	460e      	mov	r6, r1
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_PAIR_RANDOM_SZ, &txom);
   17b08:	2010      	movs	r0, #16
   17b0a:	a905      	add	r1, sp, #20
   17b0c:	f7ff feb4 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17b10:	4604      	mov	r4, r0
   17b12:	bb10      	cbnz	r0, 17b5a <ble_sm_pair_random_tx+0x5a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_pair_random_write(txom->om_data, txom->om_len, cmd);
   17b14:	9b05      	ldr	r3, [sp, #20]
   17b16:	4632      	mov	r2, r6
   17b18:	6818      	ldr	r0, [r3, #0]
   17b1a:	88d9      	ldrh	r1, [r3, #6]
   17b1c:	f7ff ffd1 	bl	17ac2 <ble_sm_pair_random_write>
    BLE_SM_LOG_CMD(1, "random", conn_handle, ble_sm_pair_random_log, cmd);
   17b20:	4b11      	ldr	r3, [pc, #68]	; (17b68 <ble_sm_pair_random_tx+0x68>)
   17b22:	9300      	str	r3, [sp, #0]
   17b24:	4b11      	ldr	r3, [pc, #68]	; (17b6c <ble_sm_pair_random_tx+0x6c>)
   17b26:	9301      	str	r3, [sp, #4]
   17b28:	4b11      	ldr	r3, [pc, #68]	; (17b70 <ble_sm_pair_random_tx+0x70>)
   17b2a:	9302      	str	r3, [sp, #8]
   17b2c:	2104      	movs	r1, #4
   17b2e:	4622      	mov	r2, r4
   17b30:	4b10      	ldr	r3, [pc, #64]	; (17b74 <ble_sm_pair_random_tx+0x74>)
   17b32:	9503      	str	r5, [sp, #12]
   17b34:	4810      	ldr	r0, [pc, #64]	; (17b78 <ble_sm_pair_random_tx+0x78>)
   17b36:	f005 fb77 	bl	1d228 <log_printf>
   17b3a:	4630      	mov	r0, r6
   17b3c:	f7ff ffce 	bl	17adc <ble_sm_pair_random_log>
   17b40:	480d      	ldr	r0, [pc, #52]	; (17b78 <ble_sm_pair_random_tx+0x78>)
   17b42:	4b0e      	ldr	r3, [pc, #56]	; (17b7c <ble_sm_pair_random_tx+0x7c>)
   17b44:	2104      	movs	r1, #4
   17b46:	4622      	mov	r2, r4
   17b48:	f005 fb6e 	bl	1d228 <log_printf>

    rc = ble_sm_tx(conn_handle, txom);
   17b4c:	4628      	mov	r0, r5
   17b4e:	9905      	ldr	r1, [sp, #20]
   17b50:	f7ff fe7c 	bl	1784c <ble_sm_tx>
    txom = NULL;
   17b54:	9405      	str	r4, [sp, #20]
    }

    ble_sm_pair_random_write(txom->om_data, txom->om_len, cmd);
    BLE_SM_LOG_CMD(1, "random", conn_handle, ble_sm_pair_random_log, cmd);

    rc = ble_sm_tx(conn_handle, txom);
   17b56:	4605      	mov	r5, r0
   17b58:	e000      	b.n	17b5c <ble_sm_pair_random_tx+0x5c>
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_PAIR_RANDOM_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   17b5a:	2506      	movs	r5, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   17b5c:	9805      	ldr	r0, [sp, #20]
   17b5e:	f7f2 f9fe 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   17b62:	4628      	mov	r0, r5
   17b64:	b006      	add	sp, #24
   17b66:	bd70      	pop	{r4, r5, r6, pc}
   17b68:	0001fe60 	.word	0x0001fe60
   17b6c:	0001fbdd 	.word	0x0001fbdd
   17b70:	0001fc46 	.word	0x0001fc46
   17b74:	0001fbbc 	.word	0x0001fbbc
   17b78:	20003b9c 	.word	0x20003b9c
   17b7c:	0001fdec 	.word	0x0001fdec

00017b80 <ble_sm_pair_fail_parse>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(len >= BLE_SM_PAIR_FAIL_SZ);

    u8ptr = payload;
    cmd->reason = u8ptr[0];
   17b80:	7803      	ldrb	r3, [r0, #0]
   17b82:	7013      	strb	r3, [r2, #0]
   17b84:	4770      	bx	lr
	...

00017b88 <ble_sm_pair_fail_log>:
    return rc;
}

void
ble_sm_pair_fail_log(struct ble_sm_pair_fail *cmd)
{
   17b88:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "reason=%d", cmd->reason);
   17b8a:	7803      	ldrb	r3, [r0, #0]
   17b8c:	9300      	str	r3, [sp, #0]
   17b8e:	4804      	ldr	r0, [pc, #16]	; (17ba0 <ble_sm_pair_fail_log+0x18>)
   17b90:	4b04      	ldr	r3, [pc, #16]	; (17ba4 <ble_sm_pair_fail_log+0x1c>)
   17b92:	2104      	movs	r1, #4
   17b94:	2200      	movs	r2, #0
   17b96:	f005 fb47 	bl	1d228 <log_printf>
}
   17b9a:	b003      	add	sp, #12
   17b9c:	f85d fb04 	ldr.w	pc, [sp], #4
   17ba0:	20003b9c 	.word	0x20003b9c
   17ba4:	0001fe6a 	.word	0x0001fe6a

00017ba8 <ble_sm_pair_fail_tx>:
}

/* XXX: Should not require locked. */
int
ble_sm_pair_fail_tx(uint16_t conn_handle, uint8_t reason)
{
   17ba8:	b570      	push	{r4, r5, r6, lr}
   17baa:	b086      	sub	sp, #24
   17bac:	4606      	mov	r6, r0
   17bae:	460d      	mov	r5, r1
    struct os_mbuf *txom;
    int rc;

    BLE_HS_DBG_ASSERT(reason > 0 && reason < BLE_SM_ERR_MAX_PLUS_1);

    rc = ble_sm_init_req(BLE_SM_PAIR_FAIL_SZ, &txom);
   17bb0:	2001      	movs	r0, #1
   17bb2:	a905      	add	r1, sp, #20
   17bb4:	f7ff fe60 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17bb8:	4604      	mov	r4, r0
   17bba:	bb30      	cbnz	r0, 17c0a <ble_sm_pair_fail_tx+0x62>
        goto done;
    }

    cmd.reason = reason;

    ble_sm_pair_fail_write(txom->om_data, txom->om_len, &cmd);
   17bbc:	9b05      	ldr	r3, [sp, #20]
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    cmd.reason = reason;
   17bbe:	f88d 5010 	strb.w	r5, [sp, #16]

    ble_sm_pair_fail_write(txom->om_data, txom->om_len, &cmd);
   17bc2:	681b      	ldr	r3, [r3, #0]
    BLE_SM_LOG_CMD(1, "fail", conn_handle, ble_sm_pair_fail_log, &cmd);
   17bc4:	4814      	ldr	r0, [pc, #80]	; (17c18 <ble_sm_pair_fail_tx+0x70>)
    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_PAIR_FAIL_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_PAIR_FAIL;
    u8ptr[1] = cmd->reason;
   17bc6:	ad06      	add	r5, sp, #24

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_PAIR_FAIL_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_PAIR_FAIL;
   17bc8:	2205      	movs	r2, #5
   17bca:	701a      	strb	r2, [r3, #0]
    u8ptr[1] = cmd->reason;
   17bcc:	f815 2d08 	ldrb.w	r2, [r5, #-8]!
   17bd0:	705a      	strb	r2, [r3, #1]
    }

    cmd.reason = reason;

    ble_sm_pair_fail_write(txom->om_data, txom->om_len, &cmd);
    BLE_SM_LOG_CMD(1, "fail", conn_handle, ble_sm_pair_fail_log, &cmd);
   17bd2:	4b12      	ldr	r3, [pc, #72]	; (17c1c <ble_sm_pair_fail_tx+0x74>)
   17bd4:	9300      	str	r3, [sp, #0]
   17bd6:	4b12      	ldr	r3, [pc, #72]	; (17c20 <ble_sm_pair_fail_tx+0x78>)
   17bd8:	9301      	str	r3, [sp, #4]
   17bda:	4b12      	ldr	r3, [pc, #72]	; (17c24 <ble_sm_pair_fail_tx+0x7c>)
   17bdc:	9302      	str	r3, [sp, #8]
   17bde:	2104      	movs	r1, #4
   17be0:	4622      	mov	r2, r4
   17be2:	4b11      	ldr	r3, [pc, #68]	; (17c28 <ble_sm_pair_fail_tx+0x80>)
   17be4:	9603      	str	r6, [sp, #12]
   17be6:	f005 fb1f 	bl	1d228 <log_printf>
   17bea:	4628      	mov	r0, r5
   17bec:	f7ff ffcc 	bl	17b88 <ble_sm_pair_fail_log>
   17bf0:	4809      	ldr	r0, [pc, #36]	; (17c18 <ble_sm_pair_fail_tx+0x70>)
   17bf2:	4b0e      	ldr	r3, [pc, #56]	; (17c2c <ble_sm_pair_fail_tx+0x84>)
   17bf4:	2104      	movs	r1, #4
   17bf6:	4622      	mov	r2, r4
   17bf8:	f005 fb16 	bl	1d228 <log_printf>

    rc = ble_sm_tx(conn_handle, txom);
   17bfc:	4630      	mov	r0, r6
   17bfe:	9905      	ldr	r1, [sp, #20]
   17c00:	f7ff fe24 	bl	1784c <ble_sm_tx>
    txom = NULL;
   17c04:	9405      	str	r4, [sp, #20]
    cmd.reason = reason;

    ble_sm_pair_fail_write(txom->om_data, txom->om_len, &cmd);
    BLE_SM_LOG_CMD(1, "fail", conn_handle, ble_sm_pair_fail_log, &cmd);

    rc = ble_sm_tx(conn_handle, txom);
   17c06:	4605      	mov	r5, r0
   17c08:	e000      	b.n	17c0c <ble_sm_pair_fail_tx+0x64>

    BLE_HS_DBG_ASSERT(reason > 0 && reason < BLE_SM_ERR_MAX_PLUS_1);

    rc = ble_sm_init_req(BLE_SM_PAIR_FAIL_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   17c0a:	2506      	movs	r5, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   17c0c:	9805      	ldr	r0, [sp, #20]
   17c0e:	f7f2 f9a6 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   17c12:	4628      	mov	r0, r5
   17c14:	b006      	add	sp, #24
   17c16:	bd70      	pop	{r4, r5, r6, pc}
   17c18:	20003b9c 	.word	0x20003b9c
   17c1c:	0001fe60 	.word	0x0001fe60
   17c20:	0001fbdd 	.word	0x0001fbdd
   17c24:	0001fbe0 	.word	0x0001fbe0
   17c28:	0001fbbc 	.word	0x0001fbbc
   17c2c:	0001fdec 	.word	0x0001fdec

00017c30 <ble_sm_enc_info_parse>:
}

void
ble_sm_enc_info_parse(void *payload, int len, struct ble_sm_enc_info *cmd)
{
    memcpy(cmd->ltk, payload, sizeof cmd->ltk);
   17c30:	f100 0310 	add.w	r3, r0, #16
   17c34:	f850 1b04 	ldr.w	r1, [r0], #4
   17c38:	f842 1b04 	str.w	r1, [r2], #4
   17c3c:	4298      	cmp	r0, r3
   17c3e:	d1f9      	bne.n	17c34 <ble_sm_enc_info_parse+0x4>
}
   17c40:	4770      	bx	lr

00017c42 <ble_sm_enc_info_write>:

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_ENC_INFO_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_ENC_INFO;
   17c42:	2306      	movs	r3, #6
   17c44:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(u8ptr + 1, cmd->ltk, sizeof cmd->ltk);
   17c48:	f102 0310 	add.w	r3, r2, #16
   17c4c:	f852 1b04 	ldr.w	r1, [r2], #4
   17c50:	f840 1b04 	str.w	r1, [r0], #4
   17c54:	429a      	cmp	r2, r3
   17c56:	d1f9      	bne.n	17c4c <ble_sm_enc_info_write+0xa>
}
   17c58:	4770      	bx	lr
	...

00017c5c <ble_sm_enc_info_log>:
    return rc;
}

void
ble_sm_enc_info_log(struct ble_sm_enc_info *cmd)
{
   17c5c:	b510      	push	{r4, lr}
    BLE_HS_LOG(DEBUG, "ltk=");
   17c5e:	2104      	movs	r1, #4
    return rc;
}

void
ble_sm_enc_info_log(struct ble_sm_enc_info *cmd)
{
   17c60:	4604      	mov	r4, r0
    BLE_HS_LOG(DEBUG, "ltk=");
   17c62:	2200      	movs	r2, #0
   17c64:	4804      	ldr	r0, [pc, #16]	; (17c78 <ble_sm_enc_info_log+0x1c>)
   17c66:	4b05      	ldr	r3, [pc, #20]	; (17c7c <ble_sm_enc_info_log+0x20>)
   17c68:	f005 fade 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(cmd->ltk, sizeof cmd->ltk);
   17c6c:	4620      	mov	r0, r4
   17c6e:	2110      	movs	r1, #16
}
   17c70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void
ble_sm_enc_info_log(struct ble_sm_enc_info *cmd)
{
    BLE_HS_LOG(DEBUG, "ltk=");
    ble_hs_log_flat_buf(cmd->ltk, sizeof cmd->ltk);
   17c74:	f7fd bc36 	b.w	154e4 <ble_hs_log_flat_buf>
   17c78:	20003b9c 	.word	0x20003b9c
   17c7c:	00020abf 	.word	0x00020abf

00017c80 <ble_sm_enc_info_tx>:
    memcpy(u8ptr + 1, cmd->ltk, sizeof cmd->ltk);
}

int
ble_sm_enc_info_tx(uint16_t conn_handle, struct ble_sm_enc_info *cmd)
{
   17c80:	b570      	push	{r4, r5, r6, lr}
   17c82:	b086      	sub	sp, #24
   17c84:	4605      	mov	r5, r0
   17c86:	460e      	mov	r6, r1
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_ENC_INFO_SZ, &txom);
   17c88:	2010      	movs	r0, #16
   17c8a:	a905      	add	r1, sp, #20
   17c8c:	f7ff fdf4 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17c90:	4604      	mov	r4, r0
   17c92:	bb10      	cbnz	r0, 17cda <ble_sm_enc_info_tx+0x5a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_enc_info_write(txom->om_data, txom->om_len, cmd);
   17c94:	9b05      	ldr	r3, [sp, #20]
   17c96:	4632      	mov	r2, r6
   17c98:	6818      	ldr	r0, [r3, #0]
   17c9a:	88d9      	ldrh	r1, [r3, #6]
   17c9c:	f7ff ffd1 	bl	17c42 <ble_sm_enc_info_write>

    BLE_SM_LOG_CMD(1, "enc info", conn_handle, ble_sm_enc_info_log, cmd);
   17ca0:	4b11      	ldr	r3, [pc, #68]	; (17ce8 <ble_sm_enc_info_tx+0x68>)
   17ca2:	9300      	str	r3, [sp, #0]
   17ca4:	4b11      	ldr	r3, [pc, #68]	; (17cec <ble_sm_enc_info_tx+0x6c>)
   17ca6:	9301      	str	r3, [sp, #4]
   17ca8:	4b11      	ldr	r3, [pc, #68]	; (17cf0 <ble_sm_enc_info_tx+0x70>)
   17caa:	9302      	str	r3, [sp, #8]
   17cac:	2104      	movs	r1, #4
   17cae:	4622      	mov	r2, r4
   17cb0:	4b10      	ldr	r3, [pc, #64]	; (17cf4 <ble_sm_enc_info_tx+0x74>)
   17cb2:	9503      	str	r5, [sp, #12]
   17cb4:	4810      	ldr	r0, [pc, #64]	; (17cf8 <ble_sm_enc_info_tx+0x78>)
   17cb6:	f005 fab7 	bl	1d228 <log_printf>
   17cba:	4630      	mov	r0, r6
   17cbc:	f7ff ffce 	bl	17c5c <ble_sm_enc_info_log>
   17cc0:	480d      	ldr	r0, [pc, #52]	; (17cf8 <ble_sm_enc_info_tx+0x78>)
   17cc2:	4b0e      	ldr	r3, [pc, #56]	; (17cfc <ble_sm_enc_info_tx+0x7c>)
   17cc4:	2104      	movs	r1, #4
   17cc6:	4622      	mov	r2, r4
   17cc8:	f005 faae 	bl	1d228 <log_printf>
    
    rc = ble_sm_tx(conn_handle, txom);
   17ccc:	4628      	mov	r0, r5
   17cce:	9905      	ldr	r1, [sp, #20]
   17cd0:	f7ff fdbc 	bl	1784c <ble_sm_tx>
    txom = NULL;
   17cd4:	9405      	str	r4, [sp, #20]

    ble_sm_enc_info_write(txom->om_data, txom->om_len, cmd);

    BLE_SM_LOG_CMD(1, "enc info", conn_handle, ble_sm_enc_info_log, cmd);
    
    rc = ble_sm_tx(conn_handle, txom);
   17cd6:	4605      	mov	r5, r0
   17cd8:	e000      	b.n	17cdc <ble_sm_enc_info_tx+0x5c>
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_ENC_INFO_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   17cda:	2506      	movs	r5, #6
    
    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   17cdc:	9805      	ldr	r0, [sp, #20]
   17cde:	f7f2 f93e 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   17ce2:	4628      	mov	r0, r5
   17ce4:	b006      	add	sp, #24
   17ce6:	bd70      	pop	{r4, r5, r6, pc}
   17ce8:	0001fe60 	.word	0x0001fe60
   17cec:	0001fbdd 	.word	0x0001fbdd
   17cf0:	0001fc23 	.word	0x0001fc23
   17cf4:	0001fbbc 	.word	0x0001fbbc
   17cf8:	20003b9c 	.word	0x20003b9c
   17cfc:	0001fdec 	.word	0x0001fdec

00017d00 <ble_sm_master_id_parse>:
    ble_hs_log_flat_buf(cmd->ltk, sizeof cmd->ltk);
}

void
ble_sm_master_id_parse(void *payload, int len, struct ble_sm_master_id *cmd)
{
   17d00:	b538      	push	{r3, r4, r5, lr}
   17d02:	4614      	mov	r4, r2
   17d04:	4605      	mov	r5, r0
    uint8_t *u8ptr;

    u8ptr = payload;

    cmd->ediv = le16toh(u8ptr);
   17d06:	f005 f9c2 	bl	1d08e <le16toh>
   17d0a:	8020      	strh	r0, [r4, #0]
    cmd->rand_val = le64toh(u8ptr + 2);
   17d0c:	1ca8      	adds	r0, r5, #2
   17d0e:	f005 f9ce 	bl	1d0ae <le64toh>
   17d12:	e9c4 0102 	strd	r0, r1, [r4, #8]
   17d16:	bd38      	pop	{r3, r4, r5, pc}

00017d18 <ble_sm_master_id_log>:
    return rc;
}

void
ble_sm_master_id_log(struct ble_sm_master_id *cmd)
{
   17d18:	b537      	push	{r0, r1, r2, r4, r5, lr}
    /* These get logged separately to accommodate a bug in the va_args
     * implementation related to 64-bit integers.
     */
    BLE_HS_LOG(DEBUG, "ediv=0x%04x ", cmd->ediv);
   17d1a:	4c0b      	ldr	r4, [pc, #44]	; (17d48 <ble_sm_master_id_log+0x30>)
   17d1c:	8803      	ldrh	r3, [r0, #0]
   17d1e:	9300      	str	r3, [sp, #0]
    return rc;
}

void
ble_sm_master_id_log(struct ble_sm_master_id *cmd)
{
   17d20:	4605      	mov	r5, r0
    /* These get logged separately to accommodate a bug in the va_args
     * implementation related to 64-bit integers.
     */
    BLE_HS_LOG(DEBUG, "ediv=0x%04x ", cmd->ediv);
   17d22:	2104      	movs	r1, #4
   17d24:	4620      	mov	r0, r4
   17d26:	2200      	movs	r2, #0
   17d28:	4b08      	ldr	r3, [pc, #32]	; (17d4c <ble_sm_master_id_log+0x34>)
   17d2a:	f005 fa7d 	bl	1d228 <log_printf>
    BLE_HS_LOG(DEBUG, "rand=0x%016llx", cmd->rand_val);
   17d2e:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
   17d32:	4620      	mov	r0, r4
   17d34:	e9cd 2300 	strd	r2, r3, [sp]
   17d38:	2104      	movs	r1, #4
   17d3a:	2200      	movs	r2, #0
   17d3c:	4b04      	ldr	r3, [pc, #16]	; (17d50 <ble_sm_master_id_log+0x38>)
   17d3e:	f005 fa73 	bl	1d228 <log_printf>
}
   17d42:	b003      	add	sp, #12
   17d44:	bd30      	pop	{r4, r5, pc}
   17d46:	bf00      	nop
   17d48:	20003b9c 	.word	0x20003b9c
   17d4c:	0001fe74 	.word	0x0001fe74
   17d50:	0001fe81 	.word	0x0001fe81

00017d54 <ble_sm_master_id_tx>:
    htole64(u8ptr + 3, cmd->rand_val);
}

int
ble_sm_master_id_tx(uint16_t conn_handle, struct ble_sm_master_id *cmd)
{
   17d54:	b570      	push	{r4, r5, r6, lr}
   17d56:	b086      	sub	sp, #24
   17d58:	4606      	mov	r6, r0
   17d5a:	460d      	mov	r5, r1
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_MASTER_ID_SZ, &txom);
   17d5c:	200a      	movs	r0, #10
   17d5e:	a905      	add	r1, sp, #20
   17d60:	f7ff fd8a 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17d64:	4604      	mov	r4, r0
   17d66:	2800      	cmp	r0, #0
   17d68:	d12d      	bne.n	17dc6 <ble_sm_master_id_tx+0x72>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    txom->om_data[0] = BLE_SM_OP_MASTER_ID;
   17d6a:	9b05      	ldr	r3, [sp, #20]
   17d6c:	681b      	ldr	r3, [r3, #0]
   17d6e:	2207      	movs	r2, #7
   17d70:	701a      	strb	r2, [r3, #0]
    htole16(txom->om_data + 1, cmd->ediv);
   17d72:	9b05      	ldr	r3, [sp, #20]
   17d74:	8829      	ldrh	r1, [r5, #0]
   17d76:	6818      	ldr	r0, [r3, #0]
   17d78:	3001      	adds	r0, #1
   17d7a:	f005 f96d 	bl	1d058 <htole16>
    htole64(txom->om_data + 3, cmd->rand_val);
   17d7e:	9b05      	ldr	r3, [sp, #20]
   17d80:	6818      	ldr	r0, [r3, #0]
   17d82:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
   17d86:	3003      	adds	r0, #3
   17d88:	f005 f972 	bl	1d070 <htole64>

    BLE_SM_LOG_CMD(1, "master id", conn_handle, ble_sm_master_id_log, cmd);
   17d8c:	4b11      	ldr	r3, [pc, #68]	; (17dd4 <ble_sm_master_id_tx+0x80>)
   17d8e:	9300      	str	r3, [sp, #0]
   17d90:	4b11      	ldr	r3, [pc, #68]	; (17dd8 <ble_sm_master_id_tx+0x84>)
   17d92:	9301      	str	r3, [sp, #4]
   17d94:	4b11      	ldr	r3, [pc, #68]	; (17ddc <ble_sm_master_id_tx+0x88>)
   17d96:	9302      	str	r3, [sp, #8]
   17d98:	2104      	movs	r1, #4
   17d9a:	4622      	mov	r2, r4
   17d9c:	4b10      	ldr	r3, [pc, #64]	; (17de0 <ble_sm_master_id_tx+0x8c>)
   17d9e:	4811      	ldr	r0, [pc, #68]	; (17de4 <ble_sm_master_id_tx+0x90>)
   17da0:	9603      	str	r6, [sp, #12]
   17da2:	f005 fa41 	bl	1d228 <log_printf>
   17da6:	4628      	mov	r0, r5
   17da8:	f7ff ffb6 	bl	17d18 <ble_sm_master_id_log>
   17dac:	480d      	ldr	r0, [pc, #52]	; (17de4 <ble_sm_master_id_tx+0x90>)
   17dae:	4b0e      	ldr	r3, [pc, #56]	; (17de8 <ble_sm_master_id_tx+0x94>)
   17db0:	2104      	movs	r1, #4
   17db2:	4622      	mov	r2, r4
   17db4:	f005 fa38 	bl	1d228 <log_printf>

    rc = ble_sm_tx(conn_handle, txom);
   17db8:	4630      	mov	r0, r6
   17dba:	9905      	ldr	r1, [sp, #20]
   17dbc:	f7ff fd46 	bl	1784c <ble_sm_tx>
    txom = NULL;
   17dc0:	9405      	str	r4, [sp, #20]
    htole16(txom->om_data + 1, cmd->ediv);
    htole64(txom->om_data + 3, cmd->rand_val);

    BLE_SM_LOG_CMD(1, "master id", conn_handle, ble_sm_master_id_log, cmd);

    rc = ble_sm_tx(conn_handle, txom);
   17dc2:	4605      	mov	r5, r0
   17dc4:	e000      	b.n	17dc8 <ble_sm_master_id_tx+0x74>
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_MASTER_ID_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   17dc6:	2506      	movs	r5, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   17dc8:	9805      	ldr	r0, [sp, #20]
   17dca:	f7f2 f8c8 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   17dce:	4628      	mov	r0, r5
   17dd0:	b006      	add	sp, #24
   17dd2:	bd70      	pop	{r4, r5, r6, pc}
   17dd4:	0001fe60 	.word	0x0001fe60
   17dd8:	0001fbdd 	.word	0x0001fbdd
   17ddc:	0001fc19 	.word	0x0001fc19
   17de0:	0001fbbc 	.word	0x0001fbbc
   17de4:	20003b9c 	.word	0x20003b9c
   17de8:	0001fdec 	.word	0x0001fdec

00017dec <ble_sm_id_info_parse>:
}

void
ble_sm_id_info_parse(void *payload, int len, struct ble_sm_id_info *cmd)
{
    memcpy(cmd->irk, payload, 16);
   17dec:	f100 0310 	add.w	r3, r0, #16
   17df0:	f850 1b04 	ldr.w	r1, [r0], #4
   17df4:	f842 1b04 	str.w	r1, [r2], #4
   17df8:	4298      	cmp	r0, r3
   17dfa:	d1f9      	bne.n	17df0 <ble_sm_id_info_parse+0x4>
}
   17dfc:	4770      	bx	lr

00017dfe <ble_sm_id_info_write>:

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_ID_INFO_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_IDENTITY_INFO;
   17dfe:	2308      	movs	r3, #8
   17e00:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->irk, sizeof cmd->irk);
   17e04:	f102 0310 	add.w	r3, r2, #16
   17e08:	f852 1b04 	ldr.w	r1, [r2], #4
   17e0c:	f840 1b04 	str.w	r1, [r0], #4
   17e10:	429a      	cmp	r2, r3
   17e12:	d1f9      	bne.n	17e08 <ble_sm_id_info_write+0xa>
}
   17e14:	4770      	bx	lr
	...

00017e18 <ble_sm_id_info_log>:
    return rc;
}

void
ble_sm_id_info_log(struct ble_sm_id_info *cmd)
{
   17e18:	b510      	push	{r4, lr}
    BLE_HS_LOG(DEBUG, "irk=");
   17e1a:	2104      	movs	r1, #4
    return rc;
}

void
ble_sm_id_info_log(struct ble_sm_id_info *cmd)
{
   17e1c:	4604      	mov	r4, r0
    BLE_HS_LOG(DEBUG, "irk=");
   17e1e:	2200      	movs	r2, #0
   17e20:	4804      	ldr	r0, [pc, #16]	; (17e34 <ble_sm_id_info_log+0x1c>)
   17e22:	4b05      	ldr	r3, [pc, #20]	; (17e38 <ble_sm_id_info_log+0x20>)
   17e24:	f005 fa00 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(cmd->irk, sizeof cmd->irk);
   17e28:	4620      	mov	r0, r4
   17e2a:	2110      	movs	r1, #16
}
   17e2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void
ble_sm_id_info_log(struct ble_sm_id_info *cmd)
{
    BLE_HS_LOG(DEBUG, "irk=");
    ble_hs_log_flat_buf(cmd->irk, sizeof cmd->irk);
   17e30:	f7fd bb58 	b.w	154e4 <ble_hs_log_flat_buf>
   17e34:	20003b9c 	.word	0x20003b9c
   17e38:	0001fe90 	.word	0x0001fe90

00017e3c <ble_sm_id_info_tx>:
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->irk, sizeof cmd->irk);
}

int
ble_sm_id_info_tx(uint16_t conn_handle, struct ble_sm_id_info *cmd)
{
   17e3c:	b570      	push	{r4, r5, r6, lr}
   17e3e:	b086      	sub	sp, #24
    struct os_mbuf *txom;
    int rc;

    BLE_SM_LOG_CMD(1, "id info", conn_handle, ble_sm_id_info_log, cmd);
   17e40:	4b18      	ldr	r3, [pc, #96]	; (17ea4 <ble_sm_id_info_tx+0x68>)
   17e42:	9300      	str	r3, [sp, #0]
   17e44:	4b18      	ldr	r3, [pc, #96]	; (17ea8 <ble_sm_id_info_tx+0x6c>)
   17e46:	9301      	str	r3, [sp, #4]
   17e48:	4b18      	ldr	r3, [pc, #96]	; (17eac <ble_sm_id_info_tx+0x70>)
   17e4a:	9302      	str	r3, [sp, #8]
   17e4c:	2200      	movs	r2, #0
   17e4e:	4b18      	ldr	r3, [pc, #96]	; (17eb0 <ble_sm_id_info_tx+0x74>)
   17e50:	9003      	str	r0, [sp, #12]
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->irk, sizeof cmd->irk);
}

int
ble_sm_id_info_tx(uint16_t conn_handle, struct ble_sm_id_info *cmd)
{
   17e52:	460e      	mov	r6, r1
   17e54:	4604      	mov	r4, r0
    struct os_mbuf *txom;
    int rc;

    BLE_SM_LOG_CMD(1, "id info", conn_handle, ble_sm_id_info_log, cmd);
   17e56:	2104      	movs	r1, #4
   17e58:	4816      	ldr	r0, [pc, #88]	; (17eb4 <ble_sm_id_info_tx+0x78>)
   17e5a:	f005 f9e5 	bl	1d228 <log_printf>
   17e5e:	4630      	mov	r0, r6
   17e60:	f7ff ffda 	bl	17e18 <ble_sm_id_info_log>
   17e64:	4813      	ldr	r0, [pc, #76]	; (17eb4 <ble_sm_id_info_tx+0x78>)
   17e66:	4b14      	ldr	r3, [pc, #80]	; (17eb8 <ble_sm_id_info_tx+0x7c>)
   17e68:	2104      	movs	r1, #4
   17e6a:	2200      	movs	r2, #0
   17e6c:	f005 f9dc 	bl	1d228 <log_printf>

    rc = ble_sm_init_req(BLE_SM_ID_INFO_SZ, &txom);
   17e70:	2010      	movs	r0, #16
   17e72:	a905      	add	r1, sp, #20
   17e74:	f7ff fd00 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17e78:	4605      	mov	r5, r0
   17e7a:	b960      	cbnz	r0, 17e96 <ble_sm_id_info_tx+0x5a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_id_info_write(txom->om_data, txom->om_len, cmd);
   17e7c:	9b05      	ldr	r3, [sp, #20]
   17e7e:	4632      	mov	r2, r6
   17e80:	6818      	ldr	r0, [r3, #0]
   17e82:	88d9      	ldrh	r1, [r3, #6]
   17e84:	f7ff ffbb 	bl	17dfe <ble_sm_id_info_write>

    rc = ble_sm_tx(conn_handle, txom);
   17e88:	4620      	mov	r0, r4
   17e8a:	9905      	ldr	r1, [sp, #20]
   17e8c:	f7ff fcde 	bl	1784c <ble_sm_tx>
    txom = NULL;
   17e90:	9505      	str	r5, [sp, #20]
        goto done;
    }

    ble_sm_id_info_write(txom->om_data, txom->om_len, cmd);

    rc = ble_sm_tx(conn_handle, txom);
   17e92:	4604      	mov	r4, r0
   17e94:	e000      	b.n	17e98 <ble_sm_id_info_tx+0x5c>

    BLE_SM_LOG_CMD(1, "id info", conn_handle, ble_sm_id_info_log, cmd);

    rc = ble_sm_init_req(BLE_SM_ID_INFO_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   17e96:	2406      	movs	r4, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   17e98:	9805      	ldr	r0, [sp, #20]
   17e9a:	f7f2 f860 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   17e9e:	4620      	mov	r0, r4
   17ea0:	b006      	add	sp, #24
   17ea2:	bd70      	pop	{r4, r5, r6, pc}
   17ea4:	0001fe60 	.word	0x0001fe60
   17ea8:	0001fbdd 	.word	0x0001fbdd
   17eac:	0001fc11 	.word	0x0001fc11
   17eb0:	0001fbbc 	.word	0x0001fbbc
   17eb4:	20003b9c 	.word	0x20003b9c
   17eb8:	0001fdec 	.word	0x0001fdec

00017ebc <ble_sm_id_addr_info_parse>:
void
ble_sm_id_addr_info_parse(void *payload, int len,
                          struct ble_sm_id_addr_info *cmd)
{
    uint8_t *u8ptr = payload;
    cmd->addr_type = *u8ptr;
   17ebc:	4613      	mov	r3, r2
   17ebe:	7801      	ldrb	r1, [r0, #0]
   17ec0:	f803 1b01 	strb.w	r1, [r3], #1
    memcpy(cmd->bd_addr, u8ptr + 1, 6);
   17ec4:	f850 1f01 	ldr.w	r1, [r0, #1]!
   17ec8:	f8c2 1001 	str.w	r1, [r2, #1]
   17ecc:	8882      	ldrh	r2, [r0, #4]
   17ece:	809a      	strh	r2, [r3, #4]
   17ed0:	4770      	bx	lr

00017ed2 <ble_sm_id_addr_info_write>:

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_ID_ADDR_INFO_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_IDENTITY_ADDR_INFO;
   17ed2:	2309      	movs	r3, #9
   17ed4:	7003      	strb	r3, [r0, #0]
    u8ptr[1] = cmd->addr_type;
   17ed6:	7813      	ldrb	r3, [r2, #0]
   17ed8:	7043      	strb	r3, [r0, #1]
    memcpy(u8ptr + 2, cmd->bd_addr, sizeof cmd->bd_addr);
   17eda:	f852 3f01 	ldr.w	r3, [r2, #1]!
   17ede:	f8c0 3002 	str.w	r3, [r0, #2]
   17ee2:	8893      	ldrh	r3, [r2, #4]
   17ee4:	80c3      	strh	r3, [r0, #6]
   17ee6:	4770      	bx	lr

00017ee8 <ble_sm_id_addr_info_log>:
    return rc;
}

void
ble_sm_id_addr_info_log(struct ble_sm_id_addr_info *cmd)
{
   17ee8:	b530      	push	{r4, r5, lr}
    BLE_HS_LOG(DEBUG, "addr_type=%d addr=", cmd->addr_type);
   17eea:	4d0f      	ldr	r5, [pc, #60]	; (17f28 <ble_sm_id_addr_info_log+0x40>)
   17eec:	7803      	ldrb	r3, [r0, #0]
    return rc;
}

void
ble_sm_id_addr_info_log(struct ble_sm_id_addr_info *cmd)
{
   17eee:	b087      	sub	sp, #28
   17ef0:	4604      	mov	r4, r0
    BLE_HS_LOG(DEBUG, "addr_type=%d addr=", cmd->addr_type);
   17ef2:	9300      	str	r3, [sp, #0]
   17ef4:	4628      	mov	r0, r5
   17ef6:	2104      	movs	r1, #4
   17ef8:	2200      	movs	r2, #0
   17efa:	4b0c      	ldr	r3, [pc, #48]	; (17f2c <ble_sm_id_addr_info_log+0x44>)
   17efc:	f005 f994 	bl	1d228 <log_printf>
    BLE_HS_LOG_ADDR(DEBUG, cmd->bd_addr);
   17f00:	79a3      	ldrb	r3, [r4, #6]
   17f02:	9300      	str	r3, [sp, #0]
   17f04:	7963      	ldrb	r3, [r4, #5]
   17f06:	9301      	str	r3, [sp, #4]
   17f08:	7923      	ldrb	r3, [r4, #4]
   17f0a:	9302      	str	r3, [sp, #8]
   17f0c:	78e3      	ldrb	r3, [r4, #3]
   17f0e:	9303      	str	r3, [sp, #12]
   17f10:	78a3      	ldrb	r3, [r4, #2]
   17f12:	9304      	str	r3, [sp, #16]
   17f14:	7863      	ldrb	r3, [r4, #1]
   17f16:	9305      	str	r3, [sp, #20]
   17f18:	4628      	mov	r0, r5
   17f1a:	2104      	movs	r1, #4
   17f1c:	2200      	movs	r2, #0
   17f1e:	4b04      	ldr	r3, [pc, #16]	; (17f30 <ble_sm_id_addr_info_log+0x48>)
   17f20:	f005 f982 	bl	1d228 <log_printf>
}
   17f24:	b007      	add	sp, #28
   17f26:	bd30      	pop	{r4, r5, pc}
   17f28:	20003b9c 	.word	0x20003b9c
   17f2c:	0001f340 	.word	0x0001f340
   17f30:	0001ee7f 	.word	0x0001ee7f

00017f34 <ble_sm_id_addr_info_tx>:
    memcpy(u8ptr + 2, cmd->bd_addr, sizeof cmd->bd_addr);
}

int
ble_sm_id_addr_info_tx(uint16_t conn_handle, struct ble_sm_id_addr_info *cmd)
{
   17f34:	b570      	push	{r4, r5, r6, lr}
   17f36:	b086      	sub	sp, #24
    struct os_mbuf *txom;
    int rc;

    BLE_SM_LOG_CMD(1, "id addr info", conn_handle, ble_sm_id_addr_info_log,
   17f38:	4b18      	ldr	r3, [pc, #96]	; (17f9c <ble_sm_id_addr_info_tx+0x68>)
   17f3a:	9300      	str	r3, [sp, #0]
   17f3c:	4b18      	ldr	r3, [pc, #96]	; (17fa0 <ble_sm_id_addr_info_tx+0x6c>)
   17f3e:	9301      	str	r3, [sp, #4]
   17f40:	4b18      	ldr	r3, [pc, #96]	; (17fa4 <ble_sm_id_addr_info_tx+0x70>)
   17f42:	9302      	str	r3, [sp, #8]
   17f44:	2200      	movs	r2, #0
   17f46:	4b18      	ldr	r3, [pc, #96]	; (17fa8 <ble_sm_id_addr_info_tx+0x74>)
   17f48:	9003      	str	r0, [sp, #12]
    memcpy(u8ptr + 2, cmd->bd_addr, sizeof cmd->bd_addr);
}

int
ble_sm_id_addr_info_tx(uint16_t conn_handle, struct ble_sm_id_addr_info *cmd)
{
   17f4a:	460e      	mov	r6, r1
   17f4c:	4604      	mov	r4, r0
    struct os_mbuf *txom;
    int rc;

    BLE_SM_LOG_CMD(1, "id addr info", conn_handle, ble_sm_id_addr_info_log,
   17f4e:	2104      	movs	r1, #4
   17f50:	4816      	ldr	r0, [pc, #88]	; (17fac <ble_sm_id_addr_info_tx+0x78>)
   17f52:	f005 f969 	bl	1d228 <log_printf>
   17f56:	4630      	mov	r0, r6
   17f58:	f7ff ffc6 	bl	17ee8 <ble_sm_id_addr_info_log>
   17f5c:	4813      	ldr	r0, [pc, #76]	; (17fac <ble_sm_id_addr_info_tx+0x78>)
   17f5e:	4b14      	ldr	r3, [pc, #80]	; (17fb0 <ble_sm_id_addr_info_tx+0x7c>)
   17f60:	2104      	movs	r1, #4
   17f62:	2200      	movs	r2, #0
   17f64:	f005 f960 	bl	1d228 <log_printf>
                   cmd);

    rc = ble_sm_init_req(BLE_SM_ID_ADDR_INFO_SZ, &txom);
   17f68:	2007      	movs	r0, #7
   17f6a:	a905      	add	r1, sp, #20
   17f6c:	f7ff fc84 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   17f70:	4605      	mov	r5, r0
   17f72:	b960      	cbnz	r0, 17f8e <ble_sm_id_addr_info_tx+0x5a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_id_addr_info_write(txom->om_data, txom->om_len, cmd);
   17f74:	9b05      	ldr	r3, [sp, #20]
   17f76:	4632      	mov	r2, r6
   17f78:	6818      	ldr	r0, [r3, #0]
   17f7a:	88d9      	ldrh	r1, [r3, #6]
   17f7c:	f7ff ffa9 	bl	17ed2 <ble_sm_id_addr_info_write>

    rc = ble_sm_tx(conn_handle, txom);
   17f80:	4620      	mov	r0, r4
   17f82:	9905      	ldr	r1, [sp, #20]
   17f84:	f7ff fc62 	bl	1784c <ble_sm_tx>
    txom = NULL;
   17f88:	9505      	str	r5, [sp, #20]
        goto done;
    }

    ble_sm_id_addr_info_write(txom->om_data, txom->om_len, cmd);

    rc = ble_sm_tx(conn_handle, txom);
   17f8a:	4604      	mov	r4, r0
   17f8c:	e000      	b.n	17f90 <ble_sm_id_addr_info_tx+0x5c>
    BLE_SM_LOG_CMD(1, "id addr info", conn_handle, ble_sm_id_addr_info_log,
                   cmd);

    rc = ble_sm_init_req(BLE_SM_ID_ADDR_INFO_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   17f8e:	2406      	movs	r4, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   17f90:	9805      	ldr	r0, [sp, #20]
   17f92:	f7f1 ffe4 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   17f96:	4620      	mov	r0, r4
   17f98:	b006      	add	sp, #24
   17f9a:	bd70      	pop	{r4, r5, r6, pc}
   17f9c:	0001fe60 	.word	0x0001fe60
   17fa0:	0001fbdd 	.word	0x0001fbdd
   17fa4:	0001fc04 	.word	0x0001fc04
   17fa8:	0001fbbc 	.word	0x0001fbbc
   17fac:	20003b9c 	.word	0x20003b9c
   17fb0:	0001fdec 	.word	0x0001fdec

00017fb4 <ble_sm_sign_info_parse>:
}

void
ble_sm_sign_info_parse(void *payload, int len, struct ble_sm_sign_info *cmd)
{
    memcpy(cmd->sig_key, payload, 16);
   17fb4:	f100 0310 	add.w	r3, r0, #16
   17fb8:	f850 1b04 	ldr.w	r1, [r0], #4
   17fbc:	f842 1b04 	str.w	r1, [r2], #4
   17fc0:	4298      	cmp	r0, r3
   17fc2:	d1f9      	bne.n	17fb8 <ble_sm_sign_info_parse+0x4>
}
   17fc4:	4770      	bx	lr

00017fc6 <ble_sm_sign_info_write>:

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_SIGN_INFO_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_SIGN_INFO;
   17fc6:	230a      	movs	r3, #10
   17fc8:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->sig_key, sizeof cmd->sig_key);
   17fcc:	f102 0310 	add.w	r3, r2, #16
   17fd0:	f852 1b04 	ldr.w	r1, [r2], #4
   17fd4:	f840 1b04 	str.w	r1, [r0], #4
   17fd8:	429a      	cmp	r2, r3
   17fda:	d1f9      	bne.n	17fd0 <ble_sm_sign_info_write+0xa>
}
   17fdc:	4770      	bx	lr
	...

00017fe0 <ble_sm_sign_info_log>:
    return rc;
}

void
ble_sm_sign_info_log(struct ble_sm_sign_info *cmd)
{
   17fe0:	b510      	push	{r4, lr}
    BLE_HS_LOG(DEBUG, "sig_key=");
   17fe2:	2104      	movs	r1, #4
    return rc;
}

void
ble_sm_sign_info_log(struct ble_sm_sign_info *cmd)
{
   17fe4:	4604      	mov	r4, r0
    BLE_HS_LOG(DEBUG, "sig_key=");
   17fe6:	2200      	movs	r2, #0
   17fe8:	4804      	ldr	r0, [pc, #16]	; (17ffc <ble_sm_sign_info_log+0x1c>)
   17fea:	4b05      	ldr	r3, [pc, #20]	; (18000 <ble_sm_sign_info_log+0x20>)
   17fec:	f005 f91c 	bl	1d228 <log_printf>
    ble_hs_log_flat_buf(cmd->sig_key, sizeof cmd->sig_key);
   17ff0:	4620      	mov	r0, r4
   17ff2:	2110      	movs	r1, #16
}
   17ff4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void
ble_sm_sign_info_log(struct ble_sm_sign_info *cmd)
{
    BLE_HS_LOG(DEBUG, "sig_key=");
    ble_hs_log_flat_buf(cmd->sig_key, sizeof cmd->sig_key);
   17ff8:	f7fd ba74 	b.w	154e4 <ble_hs_log_flat_buf>
   17ffc:	20003b9c 	.word	0x20003b9c
   18000:	0001fe95 	.word	0x0001fe95

00018004 <ble_sm_sign_info_tx>:
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->sig_key, sizeof cmd->sig_key);
}

int
ble_sm_sign_info_tx(uint16_t conn_handle, struct ble_sm_sign_info *cmd)
{
   18004:	b570      	push	{r4, r5, r6, lr}
   18006:	b086      	sub	sp, #24
    struct os_mbuf *txom;
    int rc;

    BLE_SM_LOG_CMD(1, "sign info", conn_handle, ble_sm_sign_info_log, cmd);
   18008:	4b18      	ldr	r3, [pc, #96]	; (1806c <ble_sm_sign_info_tx+0x68>)
   1800a:	9300      	str	r3, [sp, #0]
   1800c:	4b18      	ldr	r3, [pc, #96]	; (18070 <ble_sm_sign_info_tx+0x6c>)
   1800e:	9301      	str	r3, [sp, #4]
   18010:	4b18      	ldr	r3, [pc, #96]	; (18074 <ble_sm_sign_info_tx+0x70>)
   18012:	9302      	str	r3, [sp, #8]
   18014:	2200      	movs	r2, #0
   18016:	4b18      	ldr	r3, [pc, #96]	; (18078 <ble_sm_sign_info_tx+0x74>)
   18018:	9003      	str	r0, [sp, #12]
    memcpy(u8ptr + BLE_SM_HDR_SZ, cmd->sig_key, sizeof cmd->sig_key);
}

int
ble_sm_sign_info_tx(uint16_t conn_handle, struct ble_sm_sign_info *cmd)
{
   1801a:	460e      	mov	r6, r1
   1801c:	4604      	mov	r4, r0
    struct os_mbuf *txom;
    int rc;

    BLE_SM_LOG_CMD(1, "sign info", conn_handle, ble_sm_sign_info_log, cmd);
   1801e:	2104      	movs	r1, #4
   18020:	4816      	ldr	r0, [pc, #88]	; (1807c <ble_sm_sign_info_tx+0x78>)
   18022:	f005 f901 	bl	1d228 <log_printf>
   18026:	4630      	mov	r0, r6
   18028:	f7ff ffda 	bl	17fe0 <ble_sm_sign_info_log>
   1802c:	4813      	ldr	r0, [pc, #76]	; (1807c <ble_sm_sign_info_tx+0x78>)
   1802e:	4b14      	ldr	r3, [pc, #80]	; (18080 <ble_sm_sign_info_tx+0x7c>)
   18030:	2104      	movs	r1, #4
   18032:	2200      	movs	r2, #0
   18034:	f005 f8f8 	bl	1d228 <log_printf>

    rc = ble_sm_init_req(BLE_SM_SIGN_INFO_SZ, &txom);
   18038:	2010      	movs	r0, #16
   1803a:	a905      	add	r1, sp, #20
   1803c:	f7ff fc1c 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   18040:	4605      	mov	r5, r0
   18042:	b960      	cbnz	r0, 1805e <ble_sm_sign_info_tx+0x5a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_sign_info_write(txom->om_data, txom->om_len, cmd);
   18044:	9b05      	ldr	r3, [sp, #20]
   18046:	4632      	mov	r2, r6
   18048:	6818      	ldr	r0, [r3, #0]
   1804a:	88d9      	ldrh	r1, [r3, #6]
   1804c:	f7ff ffbb 	bl	17fc6 <ble_sm_sign_info_write>

    rc = ble_sm_tx(conn_handle, txom);
   18050:	4620      	mov	r0, r4
   18052:	9905      	ldr	r1, [sp, #20]
   18054:	f7ff fbfa 	bl	1784c <ble_sm_tx>
    txom = NULL;
   18058:	9505      	str	r5, [sp, #20]
        goto done;
    }

    ble_sm_sign_info_write(txom->om_data, txom->om_len, cmd);

    rc = ble_sm_tx(conn_handle, txom);
   1805a:	4604      	mov	r4, r0
   1805c:	e000      	b.n	18060 <ble_sm_sign_info_tx+0x5c>

    BLE_SM_LOG_CMD(1, "sign info", conn_handle, ble_sm_sign_info_log, cmd);

    rc = ble_sm_init_req(BLE_SM_SIGN_INFO_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   1805e:	2406      	movs	r4, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   18060:	9805      	ldr	r0, [sp, #20]
   18062:	f7f1 ff7c 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   18066:	4620      	mov	r0, r4
   18068:	b006      	add	sp, #24
   1806a:	bd70      	pop	{r4, r5, r6, pc}
   1806c:	0001fe60 	.word	0x0001fe60
   18070:	0001fbdd 	.word	0x0001fbdd
   18074:	0001fbfa 	.word	0x0001fbfa
   18078:	0001fbbc 	.word	0x0001fbbc
   1807c:	20003b9c 	.word	0x20003b9c
   18080:	0001fdec 	.word	0x0001fdec

00018084 <ble_sm_sec_req_parse>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(len >= BLE_SM_SEC_REQ_SZ);

    u8ptr = payload;
    cmd->authreq = *u8ptr;
   18084:	7803      	ldrb	r3, [r0, #0]
   18086:	7013      	strb	r3, [r2, #0]
   18088:	4770      	bx	lr
	...

0001808c <ble_sm_sec_req_log>:
    return rc;
}

void
ble_sm_sec_req_log(struct ble_sm_sec_req *cmd)
{
   1808c:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "authreq=0x%02x", cmd->authreq);
   1808e:	7803      	ldrb	r3, [r0, #0]
   18090:	9300      	str	r3, [sp, #0]
   18092:	4804      	ldr	r0, [pc, #16]	; (180a4 <ble_sm_sec_req_log+0x18>)
   18094:	4b04      	ldr	r3, [pc, #16]	; (180a8 <ble_sm_sec_req_log+0x1c>)
   18096:	2104      	movs	r1, #4
   18098:	2200      	movs	r2, #0
   1809a:	f005 f8c5 	bl	1d228 <log_printf>
}
   1809e:	b003      	add	sp, #12
   180a0:	f85d fb04 	ldr.w	pc, [sp], #4
   180a4:	20003b9c 	.word	0x20003b9c
   180a8:	0001fe9e 	.word	0x0001fe9e

000180ac <ble_sm_sec_req_tx>:
    u8ptr[1] = cmd->authreq;
}

int
ble_sm_sec_req_tx(uint16_t conn_handle, struct ble_sm_sec_req *cmd)
{
   180ac:	b570      	push	{r4, r5, r6, lr}
   180ae:	b086      	sub	sp, #24
   180b0:	4605      	mov	r5, r0
   180b2:	460e      	mov	r6, r1
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_SEC_REQ_SZ, &txom);
   180b4:	2001      	movs	r0, #1
   180b6:	a905      	add	r1, sp, #20
   180b8:	f7ff fbde 	bl	17878 <ble_sm_init_req>
    if (rc != 0) {
   180bc:	4604      	mov	r4, r0
   180be:	bb10      	cbnz	r0, 18106 <ble_sm_sec_req_tx+0x5a>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_sec_req_write(txom->om_data, txom->om_len, cmd);
   180c0:	9b05      	ldr	r3, [sp, #20]

    BLE_SM_LOG_CMD(1, "sec req", conn_handle, ble_sm_sec_req_log, cmd);
   180c2:	4814      	ldr	r0, [pc, #80]	; (18114 <ble_sm_sec_req_tx+0x68>)
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_sm_sec_req_write(txom->om_data, txom->om_len, cmd);
   180c4:	681b      	ldr	r3, [r3, #0]

    BLE_HS_DBG_ASSERT(len >= BLE_SM_HDR_SZ + BLE_SM_SEC_REQ_SZ);

    u8ptr = payload;

    u8ptr[0] = BLE_SM_OP_SEC_REQ;
   180c6:	220b      	movs	r2, #11
   180c8:	701a      	strb	r2, [r3, #0]
    u8ptr[1] = cmd->authreq;
   180ca:	7832      	ldrb	r2, [r6, #0]
   180cc:	705a      	strb	r2, [r3, #1]
        goto done;
    }

    ble_sm_sec_req_write(txom->om_data, txom->om_len, cmd);

    BLE_SM_LOG_CMD(1, "sec req", conn_handle, ble_sm_sec_req_log, cmd);
   180ce:	4b12      	ldr	r3, [pc, #72]	; (18118 <ble_sm_sec_req_tx+0x6c>)
   180d0:	9300      	str	r3, [sp, #0]
   180d2:	4b12      	ldr	r3, [pc, #72]	; (1811c <ble_sm_sec_req_tx+0x70>)
   180d4:	9301      	str	r3, [sp, #4]
   180d6:	4b12      	ldr	r3, [pc, #72]	; (18120 <ble_sm_sec_req_tx+0x74>)
   180d8:	9302      	str	r3, [sp, #8]
   180da:	2104      	movs	r1, #4
   180dc:	4622      	mov	r2, r4
   180de:	4b11      	ldr	r3, [pc, #68]	; (18124 <ble_sm_sec_req_tx+0x78>)
   180e0:	9503      	str	r5, [sp, #12]
   180e2:	f005 f8a1 	bl	1d228 <log_printf>
   180e6:	4630      	mov	r0, r6
   180e8:	f7ff ffd0 	bl	1808c <ble_sm_sec_req_log>
   180ec:	4809      	ldr	r0, [pc, #36]	; (18114 <ble_sm_sec_req_tx+0x68>)
   180ee:	4b0e      	ldr	r3, [pc, #56]	; (18128 <ble_sm_sec_req_tx+0x7c>)
   180f0:	2104      	movs	r1, #4
   180f2:	4622      	mov	r2, r4
   180f4:	f005 f898 	bl	1d228 <log_printf>

    rc = ble_sm_tx(conn_handle, txom);
   180f8:	4628      	mov	r0, r5
   180fa:	9905      	ldr	r1, [sp, #20]
   180fc:	f7ff fba6 	bl	1784c <ble_sm_tx>
    txom = NULL;
   18100:	9405      	str	r4, [sp, #20]

    ble_sm_sec_req_write(txom->om_data, txom->om_len, cmd);

    BLE_SM_LOG_CMD(1, "sec req", conn_handle, ble_sm_sec_req_log, cmd);

    rc = ble_sm_tx(conn_handle, txom);
   18102:	4605      	mov	r5, r0
   18104:	e000      	b.n	18108 <ble_sm_sec_req_tx+0x5c>
    struct os_mbuf *txom;
    int rc;

    rc = ble_sm_init_req(BLE_SM_SEC_REQ_SZ, &txom);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   18106:	2506      	movs	r5, #6

    rc = ble_sm_tx(conn_handle, txom);
    txom = NULL;

done:
    os_mbuf_free_chain(txom);
   18108:	9805      	ldr	r0, [sp, #20]
   1810a:	f7f1 ff28 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   1810e:	4628      	mov	r0, r5
   18110:	b006      	add	sp, #24
   18112:	bd70      	pop	{r4, r5, r6, pc}
   18114:	20003b9c 	.word	0x20003b9c
   18118:	0001fe60 	.word	0x0001fe60
   1811c:	0001fbdd 	.word	0x0001fbdd
   18120:	0001fc4d 	.word	0x0001fc4d
   18124:	0001fbbc 	.word	0x0001fbbc
   18128:	0001fdec 	.word	0x0001fdec

0001812c <ble_sm_lgcy_io_action>:
    {IOACT_INPUT,   IOACT_INPUT,  IOACT_DISP,  IOACT_NONE, IOACT_INPUT},
};

int
ble_sm_lgcy_io_action(struct ble_sm_proc *proc)
{
   1812c:	b510      	push	{r4, lr}
    int action;

    if (proc->pair_req.oob_data_flag && proc->pair_rsp.oob_data_flag) {
   1812e:	7c02      	ldrb	r2, [r0, #16]
    {IOACT_INPUT,   IOACT_INPUT,  IOACT_DISP,  IOACT_NONE, IOACT_INPUT},
};

int
ble_sm_lgcy_io_action(struct ble_sm_proc *proc)
{
   18130:	4603      	mov	r3, r0
    int action;

    if (proc->pair_req.oob_data_flag && proc->pair_rsp.oob_data_flag) {
   18132:	b10a      	cbz	r2, 18138 <ble_sm_lgcy_io_action+0xc>
   18134:	7d82      	ldrb	r2, [r0, #22]
   18136:	b9d2      	cbnz	r2, 1816e <ble_sm_lgcy_io_action+0x42>
        action = BLE_SM_IOACT_OOB;
    } else if (!(proc->pair_req.authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
   18138:	7c5a      	ldrb	r2, [r3, #17]
   1813a:	0751      	lsls	r1, r2, #29
   1813c:	d402      	bmi.n	18144 <ble_sm_lgcy_io_action+0x18>
               !(proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {
   1813e:	7dda      	ldrb	r2, [r3, #23]
{
    int action;

    if (proc->pair_req.oob_data_flag && proc->pair_rsp.oob_data_flag) {
        action = BLE_SM_IOACT_OOB;
    } else if (!(proc->pair_req.authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
   18140:	0752      	lsls	r2, r2, #29
   18142:	d511      	bpl.n	18168 <ble_sm_lgcy_io_action+0x3c>
               !(proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {

        action = BLE_SM_IOACT_NONE;
    } else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
   18144:	7a1c      	ldrb	r4, [r3, #8]
   18146:	7d5a      	ldrb	r2, [r3, #21]
   18148:	7bd9      	ldrb	r1, [r3, #15]
   1814a:	f014 0f01 	tst.w	r4, #1
        action = ble_sm_lgcy_init_ioa[proc->pair_rsp.io_cap]
                                     [proc->pair_req.io_cap];
   1814e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   18152:	440a      	add	r2, r1
    } else if (!(proc->pair_req.authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
               !(proc->pair_rsp.authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {

        action = BLE_SM_IOACT_NONE;
    } else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
        action = ble_sm_lgcy_init_ioa[proc->pair_rsp.io_cap]
   18154:	bf14      	ite	ne
   18156:	490d      	ldrne	r1, [pc, #52]	; (1818c <ble_sm_lgcy_io_action+0x60>)
                                     [proc->pair_req.io_cap];
    } else {
        action = ble_sm_lgcy_resp_ioa[proc->pair_rsp.io_cap]
   18158:	490d      	ldreq	r1, [pc, #52]	; (18190 <ble_sm_lgcy_io_action+0x64>)
   1815a:	5c88      	ldrb	r0, [r1, r2]
                                     [proc->pair_req.io_cap];
    }

    switch (action) {
   1815c:	2803      	cmp	r0, #3
   1815e:	d813      	bhi.n	18188 <ble_sm_lgcy_io_action+0x5c>
   18160:	e8df f000 	tbb	[pc, r0]
   18164:	0d0d0502 	.word	0x0d0d0502
    case BLE_SM_IOACT_NONE:
        proc->pair_alg = BLE_SM_PAIR_ALG_JW;
   18168:	2000      	movs	r0, #0
   1816a:	7318      	strb	r0, [r3, #12]
        break;
   1816c:	bd10      	pop	{r4, pc}

    case BLE_SM_IOACT_OOB:
        proc->pair_alg = BLE_SM_PAIR_ALG_OOB;
   1816e:	2202      	movs	r2, #2
   18170:	731a      	strb	r2, [r3, #12]
        proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
   18172:	7a1a      	ldrb	r2, [r3, #8]
   18174:	f042 0208 	orr.w	r2, r2, #8
   18178:	721a      	strb	r2, [r3, #8]
        break;
   1817a:	2001      	movs	r0, #1
   1817c:	bd10      	pop	{r4, pc}

    case BLE_SM_IOACT_INPUT:
    case BLE_SM_IOACT_DISP:
        proc->pair_alg = BLE_SM_PAIR_ALG_PASSKEY;
   1817e:	2201      	movs	r2, #1
        proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
   18180:	f044 0408 	orr.w	r4, r4, #8
        proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
        break;

    case BLE_SM_IOACT_INPUT:
    case BLE_SM_IOACT_DISP:
        proc->pair_alg = BLE_SM_PAIR_ALG_PASSKEY;
   18184:	731a      	strb	r2, [r3, #12]
        proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
   18186:	721c      	strb	r4, [r3, #8]
        BLE_HS_DBG_ASSERT(0);
        break;
    }

    return action;
}
   18188:	bd10      	pop	{r4, pc}
   1818a:	bf00      	nop
   1818c:	0001feea 	.word	0x0001feea
   18190:	0001fed1 	.word	0x0001fed1

00018194 <ble_sm_lgcy_confirm_exec>:
    return 0;
}

void
ble_sm_lgcy_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   18194:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   18198:	b099      	sub	sp, #100	; 0x64
                                 uint8_t *iat, uint8_t *rat,
                                 uint8_t *ia, uint8_t *ra)
{
    int rc;

    rc = ble_sm_ia_ra(proc, iat, ia, rat, ra);
   1819a:	f10d 0820 	add.w	r8, sp, #32
   1819e:	ad0a      	add	r5, sp, #40	; 0x28
    return 0;
}

void
ble_sm_lgcy_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   181a0:	460e      	mov	r6, r1
                                 uint8_t *iat, uint8_t *rat,
                                 uint8_t *ia, uint8_t *ra)
{
    int rc;

    rc = ble_sm_ia_ra(proc, iat, ia, rat, ra);
   181a2:	9500      	str	r5, [sp, #0]
   181a4:	f10d 011e 	add.w	r1, sp, #30
   181a8:	4642      	mov	r2, r8
   181aa:	f10d 031f 	add.w	r3, sp, #31
    return 0;
}

void
ble_sm_lgcy_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   181ae:	4604      	mov	r4, r0
                                 uint8_t *iat, uint8_t *rat,
                                 uint8_t *ia, uint8_t *ra)
{
    int rc;

    rc = ble_sm_ia_ra(proc, iat, ia, rat, ra);
   181b0:	f7fe f965 	bl	1647e <ble_sm_ia_ra>
    if (rc != 0) {
   181b4:	2800      	cmp	r0, #0
   181b6:	d13b      	bne.n	18230 <ble_sm_lgcy_confirm_exec+0x9c>
        return rc;
    }

    memcpy(k, proc->tk, sizeof proc->tk);
   181b8:	aa14      	add	r2, sp, #80	; 0x50
   181ba:	f104 031b 	add.w	r3, r4, #27
   181be:	f104 0e2b 	add.w	lr, r4, #43	; 0x2b
   181c2:	4691      	mov	r9, r2
   181c4:	6818      	ldr	r0, [r3, #0]
   181c6:	6859      	ldr	r1, [r3, #4]
   181c8:	4617      	mov	r7, r2
   181ca:	c703      	stmia	r7!, {r0, r1}
   181cc:	3308      	adds	r3, #8
   181ce:	4573      	cmp	r3, lr
   181d0:	463a      	mov	r2, r7
   181d2:	d1f7      	bne.n	181c4 <ble_sm_lgcy_confirm_exec+0x30>

    ble_sm_pair_cmd_write(
   181d4:	a80c      	add	r0, sp, #48	; 0x30
   181d6:	2107      	movs	r1, #7
   181d8:	2201      	movs	r2, #1
   181da:	f104 030f 	add.w	r3, r4, #15
   181de:	f7ff fb8a 	bl	178f6 <ble_sm_pair_cmd_write>
        preq, BLE_SM_HDR_SZ + BLE_SM_PAIR_CMD_SZ, 1,
        &proc->pair_req);

    ble_sm_pair_cmd_write(
   181e2:	2107      	movs	r1, #7
   181e4:	2200      	movs	r2, #0
   181e6:	f104 0315 	add.w	r3, r4, #21
   181ea:	a80e      	add	r0, sp, #56	; 0x38
   181ec:	f7ff fb83 	bl	178f6 <ble_sm_pair_cmd_write>
                                          &iat, &rat, ia, ra);
    if (rc != 0) {
        goto err;
    }

    rc = ble_sm_alg_c1(k, ble_sm_our_pair_rand(proc),
   181f0:	4620      	mov	r0, r4
   181f2:	f7fe ff41 	bl	17078 <ble_sm_our_pair_rand>
   181f6:	f89d 301e 	ldrb.w	r3, [sp, #30]
   181fa:	9300      	str	r3, [sp, #0]
   181fc:	9503      	str	r5, [sp, #12]
   181fe:	f89d 301f 	ldrb.w	r3, [sp, #31]
   18202:	9301      	str	r3, [sp, #4]
   18204:	ad10      	add	r5, sp, #64	; 0x40
   18206:	4601      	mov	r1, r0
   18208:	f8cd 8008 	str.w	r8, [sp, #8]
   1820c:	9504      	str	r5, [sp, #16]
   1820e:	4648      	mov	r0, r9
   18210:	aa0c      	add	r2, sp, #48	; 0x30
   18212:	ab0e      	add	r3, sp, #56	; 0x38
   18214:	f7ff fa32 	bl	1767c <ble_sm_alg_c1>
                             preq, pres, iat, rat, ia, ra, cmd.value);
    if (rc != 0) {
   18218:	b950      	cbnz	r0, 18230 <ble_sm_lgcy_confirm_exec+0x9c>
        goto err;
    }

    rc = ble_sm_pair_confirm_tx(proc->conn_handle, &cmd);
   1821a:	8960      	ldrh	r0, [r4, #10]
   1821c:	4629      	mov	r1, r5
   1821e:	f7ff fc07 	bl	17a30 <ble_sm_pair_confirm_tx>
    if (rc != 0) {
   18222:	b928      	cbnz	r0, 18230 <ble_sm_lgcy_confirm_exec+0x9c>
        goto err;
    }

    if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
   18224:	7a23      	ldrb	r3, [r4, #8]
   18226:	07db      	lsls	r3, r3, #31
   18228:	d409      	bmi.n	1823e <ble_sm_lgcy_confirm_exec+0xaa>
        proc->state = BLE_SM_PROC_STATE_RANDOM;
   1822a:	2302      	movs	r3, #2
   1822c:	7363      	strb	r3, [r4, #13]
   1822e:	e006      	b.n	1823e <ble_sm_lgcy_confirm_exec+0xaa>

    return;

err:
    res->app_status = rc;
    res->enc_cb = 1;
   18230:	7d33      	ldrb	r3, [r6, #20]
    }

    return;

err:
    res->app_status = rc;
   18232:	6030      	str	r0, [r6, #0]
    res->enc_cb = 1;
   18234:	f043 0302 	orr.w	r3, r3, #2
   18238:	7533      	strb	r3, [r6, #20]
    res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1823a:	2308      	movs	r3, #8
   1823c:	7133      	strb	r3, [r6, #4]
}
   1823e:	b019      	add	sp, #100	; 0x64
   18240:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00018244 <ble_sm_lgcy_random_exec>:
    return 0;
}

void
ble_sm_lgcy_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   18244:	b5f0      	push	{r4, r5, r6, r7, lr}
   18246:	b085      	sub	sp, #20
   18248:	4606      	mov	r6, r0
   1824a:	460c      	mov	r4, r1
    struct ble_sm_pair_random cmd;
    int rc;

    memcpy(cmd.value, ble_sm_our_pair_rand(proc), 16);
   1824c:	f7fe ff14 	bl	17078 <ble_sm_our_pair_rand>
   18250:	466f      	mov	r7, sp
   18252:	4603      	mov	r3, r0
   18254:	466a      	mov	r2, sp
   18256:	f100 0e10 	add.w	lr, r0, #16
   1825a:	6818      	ldr	r0, [r3, #0]
   1825c:	6859      	ldr	r1, [r3, #4]
   1825e:	4615      	mov	r5, r2
   18260:	c503      	stmia	r5!, {r0, r1}
   18262:	3308      	adds	r3, #8
   18264:	4573      	cmp	r3, lr
   18266:	462a      	mov	r2, r5
   18268:	d1f7      	bne.n	1825a <ble_sm_lgcy_random_exec+0x16>

    rc = ble_sm_pair_random_tx(proc->conn_handle, &cmd);
   1826a:	8970      	ldrh	r0, [r6, #10]
   1826c:	4639      	mov	r1, r7
   1826e:	f7ff fc47 	bl	17b00 <ble_sm_pair_random_tx>
    if (rc != 0) {
   18272:	b138      	cbz	r0, 18284 <ble_sm_lgcy_random_exec+0x40>
        res->app_status = rc;
        res->enc_cb = 1;
   18274:	7d23      	ldrb	r3, [r4, #20]

    memcpy(cmd.value, ble_sm_our_pair_rand(proc), 16);

    rc = ble_sm_pair_random_tx(proc->conn_handle, &cmd);
    if (rc != 0) {
        res->app_status = rc;
   18276:	6020      	str	r0, [r4, #0]
        res->enc_cb = 1;
   18278:	f043 0302 	orr.w	r3, r3, #2
   1827c:	7523      	strb	r3, [r4, #20]
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   1827e:	2308      	movs	r3, #8
   18280:	7123      	strb	r3, [r4, #4]
   18282:	e004      	b.n	1828e <ble_sm_lgcy_random_exec+0x4a>
        return;
    }

    if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
   18284:	7a33      	ldrb	r3, [r6, #8]
   18286:	07db      	lsls	r3, r3, #31
        proc->state = BLE_SM_PROC_STATE_LTK_START;
   18288:	bf5c      	itt	pl
   1828a:	2303      	movpl	r3, #3
   1828c:	7373      	strbpl	r3, [r6, #13]
    }
}
   1828e:	b005      	add	sp, #20
   18290:	bdf0      	pop	{r4, r5, r6, r7, pc}

00018292 <ble_sm_lgcy_random_rx>:

void
ble_sm_lgcy_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   18292:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   18296:	b09c      	sub	sp, #112	; 0x70
                                 uint8_t *iat, uint8_t *rat,
                                 uint8_t *ia, uint8_t *ra)
{
    int rc;

    rc = ble_sm_ia_ra(proc, iat, ia, rat, ra);
   18298:	f10d 0820 	add.w	r8, sp, #32
   1829c:	af0a      	add	r7, sp, #40	; 0x28
    }
}

void
ble_sm_lgcy_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   1829e:	460c      	mov	r4, r1
                                 uint8_t *iat, uint8_t *rat,
                                 uint8_t *ia, uint8_t *ra)
{
    int rc;

    rc = ble_sm_ia_ra(proc, iat, ia, rat, ra);
   182a0:	9700      	str	r7, [sp, #0]
   182a2:	f10d 011e 	add.w	r1, sp, #30
   182a6:	4642      	mov	r2, r8
   182a8:	f10d 031f 	add.w	r3, sp, #31
    }
}

void
ble_sm_lgcy_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
{
   182ac:	4605      	mov	r5, r0
                                 uint8_t *iat, uint8_t *rat,
                                 uint8_t *ia, uint8_t *ra)
{
    int rc;

    rc = ble_sm_ia_ra(proc, iat, ia, rat, ra);
   182ae:	f7fe f8e6 	bl	1647e <ble_sm_ia_ra>
    if (rc != 0) {
   182b2:	2800      	cmp	r0, #0
   182b4:	d15b      	bne.n	1836e <ble_sm_lgcy_random_rx+0xdc>
        return rc;
    }

    memcpy(k, proc->tk, sizeof proc->tk);
   182b6:	f105 061b 	add.w	r6, r5, #27
   182ba:	ab14      	add	r3, sp, #80	; 0x50
   182bc:	f105 0e2b 	add.w	lr, r5, #43	; 0x2b
   182c0:	46b1      	mov	r9, r6
   182c2:	469a      	mov	sl, r3
   182c4:	6830      	ldr	r0, [r6, #0]
   182c6:	6871      	ldr	r1, [r6, #4]
   182c8:	461a      	mov	r2, r3
   182ca:	c203      	stmia	r2!, {r0, r1}
   182cc:	3608      	adds	r6, #8
   182ce:	4576      	cmp	r6, lr
   182d0:	4613      	mov	r3, r2
   182d2:	d1f7      	bne.n	182c4 <ble_sm_lgcy_random_rx+0x32>

    ble_sm_pair_cmd_write(
   182d4:	a80c      	add	r0, sp, #48	; 0x30
   182d6:	2107      	movs	r1, #7
   182d8:	2201      	movs	r2, #1
   182da:	f105 030f 	add.w	r3, r5, #15
   182de:	f7ff fb0a 	bl	178f6 <ble_sm_pair_cmd_write>
        preq, BLE_SM_HDR_SZ + BLE_SM_PAIR_CMD_SZ, 1,
        &proc->pair_req);

    ble_sm_pair_cmd_write(
   182e2:	2107      	movs	r1, #7
   182e4:	2200      	movs	r2, #0
   182e6:	f105 0315 	add.w	r3, r5, #21
   182ea:	a80e      	add	r0, sp, #56	; 0x38
   182ec:	f7ff fb03 	bl	178f6 <ble_sm_pair_cmd_write>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
        res->enc_cb = 1;
        return;
    }

    rc = ble_sm_alg_c1(k, ble_sm_peer_pair_rand(proc), preq, pres,
   182f0:	4628      	mov	r0, r5
   182f2:	f7fe ff29 	bl	17148 <ble_sm_peer_pair_rand>
   182f6:	f89d 301e 	ldrb.w	r3, [sp, #30]
   182fa:	9300      	str	r3, [sp, #0]
   182fc:	9703      	str	r7, [sp, #12]
   182fe:	f89d 301f 	ldrb.w	r3, [sp, #31]
   18302:	9301      	str	r3, [sp, #4]
   18304:	af10      	add	r7, sp, #64	; 0x40
   18306:	4601      	mov	r1, r0
   18308:	f8cd 8008 	str.w	r8, [sp, #8]
   1830c:	9704      	str	r7, [sp, #16]
   1830e:	4650      	mov	r0, sl
   18310:	aa0c      	add	r2, sp, #48	; 0x30
   18312:	ab0e      	add	r3, sp, #56	; 0x38
   18314:	f7ff f9b2 	bl	1767c <ble_sm_alg_c1>
                             iat, rat, ia, ra, confirm_val);
    if (rc != 0) {
   18318:	bb48      	cbnz	r0, 1836e <ble_sm_lgcy_random_rx+0xdc>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
        res->enc_cb = 1;
        return;
    }

    if (memcmp(proc->confirm_peer, confirm_val, 16) != 0) {
   1831a:	4630      	mov	r0, r6
   1831c:	4639      	mov	r1, r7
   1831e:	2210      	movs	r2, #16
   18320:	f7f0 fe5e 	bl	8fe0 <memcmp>
   18324:	b120      	cbz	r0, 18330 <ble_sm_lgcy_random_rx+0x9e>
        /* Random number mismatch. */
        res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CONFIRM_MISMATCH);
   18326:	f240 4304 	movw	r3, #1028	; 0x404
   1832a:	6023      	str	r3, [r4, #0]
        res->sm_err = BLE_SM_ERR_CONFIRM_MISMATCH;
   1832c:	2304      	movs	r3, #4
   1832e:	e020      	b.n	18372 <ble_sm_lgcy_random_rx+0xe0>
ble_sm_gen_stk(struct ble_sm_proc *proc)
{
    uint8_t key[16];
    int rc;

    rc = ble_sm_alg_s1(proc->tk, proc->rands, proc->randm, key);
   18330:	4648      	mov	r0, r9
   18332:	f105 014b 	add.w	r1, r5, #75	; 0x4b
   18336:	f105 023b 	add.w	r2, r5, #59	; 0x3b
   1833a:	ab18      	add	r3, sp, #96	; 0x60
   1833c:	f7ff f94c 	bl	175d8 <ble_sm_alg_s1>
    if (rc != 0) {
   18340:	b9a8      	cbnz	r0, 1836e <ble_sm_lgcy_random_rx+0xdc>
        return rc;
    }

    memcpy(proc->ltk, key, sizeof key);
   18342:	ab18      	add	r3, sp, #96	; 0x60
   18344:	f105 065b 	add.w	r6, r5, #91	; 0x5b
   18348:	af1c      	add	r7, sp, #112	; 0x70
   1834a:	461a      	mov	r2, r3
   1834c:	ca03      	ldmia	r2!, {r0, r1}
   1834e:	42ba      	cmp	r2, r7
   18350:	6030      	str	r0, [r6, #0]
   18352:	6071      	str	r1, [r6, #4]
   18354:	4613      	mov	r3, r2
   18356:	f106 0608 	add.w	r6, r6, #8
   1835a:	d1f6      	bne.n	1834a <ble_sm_lgcy_random_rx+0xb8>
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
        res->enc_cb = 1;
        return;
    }

    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
   1835c:	7a2b      	ldrb	r3, [r5, #8]
   1835e:	07db      	lsls	r3, r3, #31
        /* Send the start-encrypt HCI command to the controller.   For
         * short-term key generation, we always set ediv and rand to 0.
         * (Vol. 3, part H, 2.4.4.1).
         */
        proc->state = BLE_SM_PROC_STATE_ENC_START;
   18360:	bf44      	itt	mi
   18362:	2305      	movmi	r3, #5
   18364:	736b      	strbmi	r3, [r5, #13]
    }

    res->execute = 1;
   18366:	7d23      	ldrb	r3, [r4, #20]
   18368:	f043 0301 	orr.w	r3, r3, #1
   1836c:	e005      	b.n	1837a <ble_sm_lgcy_random_rx+0xe8>
    int rc;

    rc = ble_sm_lgcy_confirm_prepare_args(proc, k, preq, pres,
                                          &iat, &rat, ia, ra);
    if (rc != 0) {
        res->app_status = rc;
   1836e:	6020      	str	r0, [r4, #0]
        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
   18370:	2308      	movs	r3, #8
   18372:	7123      	strb	r3, [r4, #4]
        res->enc_cb = 1;
   18374:	7d23      	ldrb	r3, [r4, #20]
   18376:	f043 0302 	orr.w	r3, r3, #2
   1837a:	7523      	strb	r3, [r4, #20]
         */
        proc->state = BLE_SM_PROC_STATE_ENC_START;
    }

    res->execute = 1;
}
   1837c:	b01c      	add	sp, #112	; 0x70
   1837e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

00018384 <ble_store_read>:
ble_store_read(int obj_type, union ble_store_key *key,
               union ble_store_value *val)
{
    int rc;

    if (ble_hs_cfg.store_read_cb == NULL) {
   18384:	4b02      	ldr	r3, [pc, #8]	; (18390 <ble_store_read+0xc>)
   18386:	695b      	ldr	r3, [r3, #20]
   18388:	b103      	cbz	r3, 1838c <ble_store_read+0x8>
        rc = BLE_HS_ENOTSUP;
    } else {
        rc = ble_hs_cfg.store_read_cb(obj_type, key, val);
   1838a:	4718      	bx	r3
    }

    return rc;
}
   1838c:	2008      	movs	r0, #8
   1838e:	4770      	bx	lr
   18390:	20003b78 	.word	0x20003b78

00018394 <ble_store_write>:
int
ble_store_write(int obj_type, union ble_store_value *val)
{
    int rc;

    if (ble_hs_cfg.store_write_cb == NULL) {
   18394:	4b02      	ldr	r3, [pc, #8]	; (183a0 <ble_store_write+0xc>)
   18396:	699b      	ldr	r3, [r3, #24]
   18398:	b103      	cbz	r3, 1839c <ble_store_write+0x8>
        rc = BLE_HS_ENOTSUP;
    } else {
        rc = ble_hs_cfg.store_write_cb(obj_type, val);
   1839a:	4718      	bx	r3
    }

    return rc;
}
   1839c:	2008      	movs	r0, #8
   1839e:	4770      	bx	lr
   183a0:	20003b78 	.word	0x20003b78

000183a4 <ble_store_delete>:
int
ble_store_delete(int obj_type, union ble_store_key *key)
{
    int rc;

    if (ble_hs_cfg.store_delete_cb == NULL) {
   183a4:	4b02      	ldr	r3, [pc, #8]	; (183b0 <ble_store_delete+0xc>)
   183a6:	69db      	ldr	r3, [r3, #28]
   183a8:	b103      	cbz	r3, 183ac <ble_store_delete+0x8>
        rc = BLE_HS_ENOTSUP;
    } else {
        rc = ble_hs_cfg.store_delete_cb(obj_type, key);
   183aa:	4718      	bx	r3
    }

    return rc;
}
   183ac:	2008      	movs	r0, #8
   183ae:	4770      	bx	lr
   183b0:	20003b78 	.word	0x20003b78

000183b4 <ble_store_read_our_sec>:

int
ble_store_read_our_sec(struct ble_store_key_sec *key_sec,
                       struct ble_store_value_sec *value_sec)
{
   183b4:	4603      	mov	r3, r0
   183b6:	460a      	mov	r2, r1
                      key_sec->peer_addr_type == BLE_ADDR_TYPE_RANDOM ||
                      key_sec->peer_addr_type == BLE_STORE_ADDR_TYPE_NONE);

    store_key = (void *)key_sec;
    store_value = (void *)value_sec;
    rc = ble_store_read(BLE_STORE_OBJ_TYPE_OUR_SEC, store_key, store_value);
   183b8:	2001      	movs	r0, #1
   183ba:	4619      	mov	r1, r3
   183bc:	f7ff bfe2 	b.w	18384 <ble_store_read>

000183c0 <ble_store_read_peer_sec>:
}

int
ble_store_read_peer_sec(struct ble_store_key_sec *key_sec,
                        struct ble_store_value_sec *value_sec)
{
   183c0:	4603      	mov	r3, r0
   183c2:	460a      	mov	r2, r1
                      key_sec->peer_addr_type == BLE_ADDR_TYPE_RANDOM ||
                      key_sec->peer_addr_type == BLE_STORE_ADDR_TYPE_NONE);

    store_key = (void *)key_sec;
    store_value = (void *)value_sec;
    rc = ble_store_read(BLE_STORE_OBJ_TYPE_PEER_SEC, store_key, store_value);
   183c4:	2002      	movs	r0, #2
   183c6:	4619      	mov	r1, r3
   183c8:	f7ff bfdc 	b.w	18384 <ble_store_read>

000183cc <ble_store_read_cccd>:
}

int
ble_store_read_cccd(struct ble_store_key_cccd *key,
                    struct ble_store_value_cccd *out_value)
{
   183cc:	4603      	mov	r3, r0
   183ce:	460a      	mov	r2, r1
    union ble_store_key *store_key;
    int rc;

    store_key = (void *)key;
    store_value = (void *)out_value;
    rc = ble_store_read(BLE_STORE_OBJ_TYPE_CCCD, store_key, store_value);
   183d0:	2003      	movs	r0, #3
   183d2:	4619      	mov	r1, r3
   183d4:	f7ff bfd6 	b.w	18384 <ble_store_read>

000183d8 <ble_store_write_cccd>:
    return rc;
}

int
ble_store_write_cccd(struct ble_store_value_cccd *value)
{
   183d8:	4601      	mov	r1, r0
    union ble_store_value *store_value;
    int rc;

    store_value = (void *)value;
    rc = ble_store_write(BLE_STORE_OBJ_TYPE_CCCD, store_value);
   183da:	2003      	movs	r0, #3
   183dc:	f7ff bfda 	b.w	18394 <ble_store_write>

000183e0 <ble_store_delete_cccd>:
    return rc;
}

int
ble_store_delete_cccd(struct ble_store_key_cccd *key)
{
   183e0:	4601      	mov	r1, r0
    union ble_store_key *store_key;
    int rc;

    store_key = (void *)key;
    rc = ble_store_delete(BLE_STORE_OBJ_TYPE_CCCD, store_key);
   183e2:	2003      	movs	r0, #3
   183e4:	f7ff bfde 	b.w	183a4 <ble_store_delete>

000183e8 <ble_store_key_from_value_cccd>:

void
ble_store_key_from_value_cccd(struct ble_store_key_cccd *out_key,
                              struct ble_store_value_cccd *value)
{
    out_key->peer_addr_type = value->peer_addr_type;
   183e8:	798b      	ldrb	r3, [r1, #6]
   183ea:	7183      	strb	r3, [r0, #6]
    memcpy(out_key->peer_addr, value->peer_addr, 6);
   183ec:	680b      	ldr	r3, [r1, #0]
   183ee:	6003      	str	r3, [r0, #0]
   183f0:	888b      	ldrh	r3, [r1, #4]
   183f2:	8083      	strh	r3, [r0, #4]
    out_key->chr_val_handle = value->chr_val_handle;
   183f4:	890b      	ldrh	r3, [r1, #8]
   183f6:	8103      	strh	r3, [r0, #8]
    out_key->idx = 0;
   183f8:	2300      	movs	r3, #0
   183fa:	7283      	strb	r3, [r0, #10]
   183fc:	4770      	bx	lr

000183fe <ble_store_key_from_value_sec>:

void
ble_store_key_from_value_sec(struct ble_store_key_sec *out_key,
                             struct ble_store_value_sec *value)
{
    out_key->peer_addr_type = value->peer_addr_type;
   183fe:	798b      	ldrb	r3, [r1, #6]
   18400:	7183      	strb	r3, [r0, #6]
    memcpy(out_key->peer_addr, value->peer_addr, sizeof out_key->peer_addr);
   18402:	680b      	ldr	r3, [r1, #0]
   18404:	6003      	str	r3, [r0, #0]
   18406:	888b      	ldrh	r3, [r1, #4]
   18408:	8083      	strh	r3, [r0, #4]

    out_key->ediv = value->ediv;
   1840a:	890b      	ldrh	r3, [r1, #8]
   1840c:	8103      	strh	r3, [r0, #8]
    out_key->rand_num = value->rand_num;
   1840e:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
   18412:	e9c0 2304 	strd	r2, r3, [r0, #16]
    out_key->ediv_rand_present = 1;
   18416:	7e03      	ldrb	r3, [r0, #24]
   18418:	f043 0301 	orr.w	r3, r3, #1
   1841c:	7603      	strb	r3, [r0, #24]
    out_key->idx = 0;
   1841e:	2300      	movs	r3, #0
   18420:	7643      	strb	r3, [r0, #25]
   18422:	4770      	bx	lr

00018424 <ble_store_persist_sec>:
    return rc;
}

static int
ble_store_persist_sec(int obj_type, struct ble_store_value_sec *value_sec)
{
   18424:	b510      	push	{r4, lr}
                      value_sec->peer_addr_type == BLE_ADDR_TYPE_RANDOM);

    /* If the value contains no keys, delete the corresponding entry.
     * Otherwise, write it.
     */
    if (!value_sec->ltk_present &&
   18426:	f891 2028 	ldrb.w	r2, [r1, #40]	; 0x28
   1842a:	07d2      	lsls	r2, r2, #31
    return rc;
}

static int
ble_store_persist_sec(int obj_type, struct ble_store_value_sec *value_sec)
{
   1842c:	b088      	sub	sp, #32
   1842e:	4604      	mov	r4, r0
   18430:	460b      	mov	r3, r1
                      value_sec->peer_addr_type == BLE_ADDR_TYPE_RANDOM);

    /* If the value contains no keys, delete the corresponding entry.
     * Otherwise, write it.
     */
    if (!value_sec->ltk_present &&
   18432:	d40f      	bmi.n	18454 <ble_store_persist_sec+0x30>
        !value_sec->irk_present &&
   18434:	f891 2039 	ldrb.w	r2, [r1, #57]	; 0x39
                      value_sec->peer_addr_type == BLE_ADDR_TYPE_RANDOM);

    /* If the value contains no keys, delete the corresponding entry.
     * Otherwise, write it.
     */
    if (!value_sec->ltk_present &&
   18438:	07d0      	lsls	r0, r2, #31
   1843a:	d40b      	bmi.n	18454 <ble_store_persist_sec+0x30>
        !value_sec->irk_present &&
        !value_sec->csrk_present) {
   1843c:	f891 204a 	ldrb.w	r2, [r1, #74]	; 0x4a

    /* If the value contains no keys, delete the corresponding entry.
     * Otherwise, write it.
     */
    if (!value_sec->ltk_present &&
        !value_sec->irk_present &&
   18440:	07d2      	lsls	r2, r2, #31
   18442:	d407      	bmi.n	18454 <ble_store_persist_sec+0x30>
        !value_sec->csrk_present) {

        ble_store_key_from_value_sec(&key_sec, value_sec);
   18444:	4668      	mov	r0, sp
   18446:	f7ff ffda 	bl	183fe <ble_store_key_from_value_sec>
        store_key = (void *)&key_sec;
        rc = ble_store_delete(obj_type, store_key);
   1844a:	4620      	mov	r0, r4
   1844c:	4669      	mov	r1, sp
   1844e:	f7ff ffa9 	bl	183a4 <ble_store_delete>
   18452:	e003      	b.n	1845c <ble_store_persist_sec+0x38>
    } else {
        store_value = (void *)value_sec;
        rc = ble_store_write(obj_type, store_value);
   18454:	4620      	mov	r0, r4
   18456:	4619      	mov	r1, r3
   18458:	f7ff ff9c 	bl	18394 <ble_store_write>
    }

    return rc;
}
   1845c:	b008      	add	sp, #32
   1845e:	bd10      	pop	{r4, pc}

00018460 <ble_store_write_our_sec>:

int
ble_store_write_our_sec(struct ble_store_value_sec *value_sec)
{
   18460:	4601      	mov	r1, r0
    int rc;

    rc = ble_store_persist_sec(BLE_STORE_OBJ_TYPE_OUR_SEC, value_sec);
   18462:	2001      	movs	r0, #1
   18464:	f7ff bfde 	b.w	18424 <ble_store_persist_sec>

00018468 <ble_store_write_peer_sec>:
    return 0;
}

int
ble_store_write_peer_sec(struct ble_store_value_sec *value_sec)
{
   18468:	b510      	push	{r4, lr}
   1846a:	4604      	mov	r4, r0
    int rc;

    rc = ble_store_persist_sec(BLE_STORE_OBJ_TYPE_PEER_SEC, value_sec);
   1846c:	4621      	mov	r1, r4
   1846e:	2002      	movs	r0, #2
   18470:	f7ff ffd8 	bl	18424 <ble_store_persist_sec>
    if (rc != 0) {
   18474:	b970      	cbnz	r0, 18494 <ble_store_write_peer_sec+0x2c>
        return rc;
    }

    if (value_sec->peer_addr_type != BLE_STORE_ADDR_TYPE_NONE &&
   18476:	79a1      	ldrb	r1, [r4, #6]
   18478:	29ff      	cmp	r1, #255	; 0xff
   1847a:	d00b      	beq.n	18494 <ble_store_write_peer_sec+0x2c>
   1847c:	f894 0039 	ldrb.w	r0, [r4, #57]	; 0x39
   18480:	f010 0001 	ands.w	r0, r0, #1
   18484:	d006      	beq.n	18494 <ble_store_write_peer_sec+0x2c>
        value_sec->irk_present) {

        /* Write the peer IRK to the controller keycache
         * There is not much to do here if it fails */
        rc = ble_hs_pvcy_add_entry(value_sec->peer_addr,
   18486:	4620      	mov	r0, r4
   18488:	f104 0229 	add.w	r2, r4, #41	; 0x29
            return rc;
        }
    }

    return 0;
}
   1848c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (value_sec->peer_addr_type != BLE_STORE_ADDR_TYPE_NONE &&
        value_sec->irk_present) {

        /* Write the peer IRK to the controller keycache
         * There is not much to do here if it fails */
        rc = ble_hs_pvcy_add_entry(value_sec->peer_addr,
   18490:	f7fd b8a2 	b.w	155d8 <ble_hs_pvcy_add_entry>
            return rc;
        }
    }

    return 0;
}
   18494:	bd10      	pop	{r4, pc}
	...

00018498 <ble_uuid_128_to_16>:
 *                                  0 if the UUID cannot be represented in 16
 *                                      bits.
 */
uint16_t
ble_uuid_128_to_16(const void *uuid128)
{
   18498:	b510      	push	{r4, lr}
    u8ptr = uuid128;

    /* The UUID can only be converted if the final 96 bits of its big endian
     * representation are equal to the base UUID.
     */
    rc = memcmp(u8ptr, ble_uuid_base, sizeof ble_uuid_base - 4);
   1849a:	4909      	ldr	r1, [pc, #36]	; (184c0 <ble_uuid_128_to_16+0x28>)
   1849c:	220c      	movs	r2, #12
 *                                  0 if the UUID cannot be represented in 16
 *                                      bits.
 */
uint16_t
ble_uuid_128_to_16(const void *uuid128)
{
   1849e:	4604      	mov	r4, r0
    u8ptr = uuid128;

    /* The UUID can only be converted if the final 96 bits of its big endian
     * representation are equal to the base UUID.
     */
    rc = memcmp(u8ptr, ble_uuid_base, sizeof ble_uuid_base - 4);
   184a0:	f7f0 fd9e 	bl	8fe0 <memcmp>
    if (rc != 0) {
   184a4:	b948      	cbnz	r0, 184ba <ble_uuid_128_to_16+0x22>
        return 0;
    }

    if (u8ptr[14] != 0 || u8ptr[15] != 0) {
   184a6:	7ba3      	ldrb	r3, [r4, #14]
   184a8:	b93b      	cbnz	r3, 184ba <ble_uuid_128_to_16+0x22>
   184aa:	7be3      	ldrb	r3, [r4, #15]
   184ac:	b92b      	cbnz	r3, 184ba <ble_uuid_128_to_16+0x22>
        /* This UUID has a 32-bit form, but not a 16-bit form. */
        return 0;
    }

    uuid16 = le16toh(u8ptr + 12);
   184ae:	f104 000c 	add.w	r0, r4, #12
    if (uuid16 == 0) {
        return 0;
    }

    return uuid16;
}
   184b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (u8ptr[14] != 0 || u8ptr[15] != 0) {
        /* This UUID has a 32-bit form, but not a 16-bit form. */
        return 0;
    }

    uuid16 = le16toh(u8ptr + 12);
   184b6:	f004 bdea 	b.w	1d08e <le16toh>
    if (uuid16 == 0) {
        return 0;
    }

    return uuid16;
}
   184ba:	2000      	movs	r0, #0
   184bc:	bd10      	pop	{r4, pc}
   184be:	bf00      	nop
   184c0:	20000248 	.word	0x20000248

000184c4 <ble_uuid_16_to_128>:
 *                              BLE_HS_EINVAL if uuid16 is not a valid 16-bit
 *                                  UUID.
 */
int
ble_uuid_16_to_128(uint16_t uuid16, void *out_uuid128)
{
   184c4:	b538      	push	{r3, r4, r5, lr}
    uint8_t *u8ptr;

    if (uuid16 == 0) {
   184c6:	4602      	mov	r2, r0
   184c8:	b180      	cbz	r0, 184ec <ble_uuid_16_to_128+0x28>
        return BLE_HS_EINVAL;
    }

    u8ptr = out_uuid128;

    memcpy(u8ptr, ble_uuid_base, 16);
   184ca:	4b09      	ldr	r3, [pc, #36]	; (184f0 <ble_uuid_16_to_128+0x2c>)
   184cc:	4608      	mov	r0, r1
   184ce:	f103 0410 	add.w	r4, r3, #16
   184d2:	f853 5b04 	ldr.w	r5, [r3], #4
   184d6:	f840 5b04 	str.w	r5, [r0], #4
   184da:	42a3      	cmp	r3, r4
   184dc:	d1f9      	bne.n	184d2 <ble_uuid_16_to_128+0xe>
    htole16(u8ptr + 12, uuid16);
   184de:	f101 000c 	add.w	r0, r1, #12
   184e2:	4611      	mov	r1, r2
   184e4:	f004 fdb8 	bl	1d058 <htole16>
   184e8:	2000      	movs	r0, #0
   184ea:	bd38      	pop	{r3, r4, r5, pc}
ble_uuid_16_to_128(uint16_t uuid16, void *out_uuid128)
{
    uint8_t *u8ptr;

    if (uuid16 == 0) {
        return BLE_HS_EINVAL;
   184ec:	2003      	movs	r0, #3

    memcpy(u8ptr, ble_uuid_base, 16);
    htole16(u8ptr + 12, uuid16);

    return 0;
}
   184ee:	bd38      	pop	{r3, r4, r5, pc}
   184f0:	20000248 	.word	0x20000248

000184f4 <ble_uuid_append>:

int
ble_uuid_append(struct os_mbuf *om, const void *uuid128)
{
   184f4:	b570      	push	{r4, r5, r6, lr}
   184f6:	4605      	mov	r5, r0
    uint16_t uuid16;
    void *buf;
    int rc;

    uuid16 = ble_uuid_128_to_16(uuid128);
   184f8:	4608      	mov	r0, r1
    return 0;
}

int
ble_uuid_append(struct os_mbuf *om, const void *uuid128)
{
   184fa:	460c      	mov	r4, r1
    uint16_t uuid16;
    void *buf;
    int rc;

    uuid16 = ble_uuid_128_to_16(uuid128);
   184fc:	f7ff ffcc 	bl	18498 <ble_uuid_128_to_16>
    if (uuid16 != 0) {
   18500:	4606      	mov	r6, r0
        buf = os_mbuf_extend(om, 2);
   18502:	4628      	mov	r0, r5
    uint16_t uuid16;
    void *buf;
    int rc;

    uuid16 = ble_uuid_128_to_16(uuid128);
    if (uuid16 != 0) {
   18504:	b156      	cbz	r6, 1851c <ble_uuid_append+0x28>
        buf = os_mbuf_extend(om, 2);
   18506:	2102      	movs	r1, #2
   18508:	f7f1 feb2 	bl	a270 <os_mbuf_extend>
        if (buf == NULL) {
   1850c:	b908      	cbnz	r0, 18512 <ble_uuid_append+0x1e>
            return BLE_HS_ENOMEM;
   1850e:	2006      	movs	r0, #6
   18510:	bd70      	pop	{r4, r5, r6, pc}
        }

        htole16(buf, uuid16);
   18512:	4631      	mov	r1, r6
   18514:	f004 fda0 	bl	1d058 <htole16>
        if (rc != 0) {
            return BLE_HS_ENOMEM;
        }
    }

    return 0;
   18518:	2000      	movs	r0, #0
   1851a:	bd70      	pop	{r4, r5, r6, pc}
            return BLE_HS_ENOMEM;
        }

        htole16(buf, uuid16);
    } else {
        rc = os_mbuf_append(om, uuid128, 16);
   1851c:	4621      	mov	r1, r4
   1851e:	2210      	movs	r2, #16
   18520:	f7f1 fd26 	bl	9f70 <os_mbuf_append>
        if (rc != 0) {
   18524:	2800      	cmp	r0, #0
   18526:	d1f2      	bne.n	1850e <ble_uuid_append+0x1a>
            return BLE_HS_ENOMEM;
        }
    }

    return 0;
}
   18528:	bd70      	pop	{r4, r5, r6, pc}

0001852a <ble_uuid_extract>:

int
ble_uuid_extract(struct os_mbuf *om, int off, void *uuid128)
{
   1852a:	b513      	push	{r0, r1, r4, lr}
   1852c:	4614      	mov	r4, r2
    uint16_t uuid16;
    int remlen;
    int rc;

    remlen = OS_MBUF_PKTHDR(om)->omp_len - off;
   1852e:	8a02      	ldrh	r2, [r0, #16]
   18530:	1a52      	subs	r2, r2, r1
    switch (remlen) {
   18532:	2a02      	cmp	r2, #2
   18534:	d006      	beq.n	18544 <ble_uuid_extract+0x1a>
   18536:	2a10      	cmp	r2, #16
   18538:	d112      	bne.n	18560 <ble_uuid_extract+0x36>
            return rc;
        }
        return 0;

    case 16:
        rc = os_mbuf_copydata(om, off, 16, uuid128);
   1853a:	4623      	mov	r3, r4
   1853c:	f7f1 fd98 	bl	a070 <os_mbuf_copydata>
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
        return 0;
   18540:	2000      	movs	r0, #0
   18542:	e00e      	b.n	18562 <ble_uuid_extract+0x38>
    int rc;

    remlen = OS_MBUF_PKTHDR(om)->omp_len - off;
    switch (remlen) {
    case 2:
        rc = os_mbuf_copydata(om, off, 2, &uuid16);
   18544:	f10d 0306 	add.w	r3, sp, #6
   18548:	f7f1 fd92 	bl	a070 <os_mbuf_copydata>
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);

        uuid16 = le16toh(&uuid16);
   1854c:	f10d 0006 	add.w	r0, sp, #6
   18550:	f004 fd9d 	bl	1d08e <le16toh>
        rc = ble_uuid_16_to_128(uuid16, uuid128);
   18554:	4621      	mov	r1, r4
    switch (remlen) {
    case 2:
        rc = os_mbuf_copydata(om, off, 2, &uuid16);
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);

        uuid16 = le16toh(&uuid16);
   18556:	f8ad 0006 	strh.w	r0, [sp, #6]
        rc = ble_uuid_16_to_128(uuid16, uuid128);
   1855a:	f7ff ffb3 	bl	184c4 <ble_uuid_16_to_128>
   1855e:	e000      	b.n	18562 <ble_uuid_extract+0x38>
        rc = os_mbuf_copydata(om, off, 16, uuid128);
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
        return 0;

    default:
        return BLE_HS_EMSGSIZE;
   18560:	2004      	movs	r0, #4
    }
}
   18562:	b002      	add	sp, #8
   18564:	bd10      	pop	{r4, pc}
	...

00018568 <host_hci_dbg_event_disp>:
                      "ogf=0x%x\n", evdata[0], evdata[1], ocf, ogf);
}

void
host_hci_dbg_event_disp(uint8_t *evbuf)
{
   18568:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint8_t *evdata;
    uint8_t evcode;
    uint8_t len;

    /* Extract event code and length; move pointer to event parameter data */
    evcode = evbuf[0];
   1856c:	7803      	ldrb	r3, [r0, #0]
    len = evbuf[1];
   1856e:	7846      	ldrb	r6, [r0, #1]
    evdata = evbuf + BLE_HCI_EVENT_HDR_LEN;

    switch (evcode) {
   18570:	2b0f      	cmp	r3, #15
                      "ogf=0x%x\n", evdata[0], evdata[1], ocf, ogf);
}

void
host_hci_dbg_event_disp(uint8_t *evbuf)
{
   18572:	b095      	sub	sp, #84	; 0x54
   18574:	4604      	mov	r4, r0
    /* Extract event code and length; move pointer to event parameter data */
    evcode = evbuf[0];
    len = evbuf[1];
    evdata = evbuf + BLE_HCI_EVENT_HDR_LEN;

    switch (evcode) {
   18576:	f000 81ff 	beq.w	18978 <host_hci_dbg_event_disp+0x410>
   1857a:	d80a      	bhi.n	18592 <host_hci_dbg_event_disp+0x2a>
   1857c:	2b08      	cmp	r3, #8
   1857e:	d031      	beq.n	185e4 <host_hci_dbg_event_disp+0x7c>
   18580:	d802      	bhi.n	18588 <host_hci_dbg_event_disp+0x20>
   18582:	2b05      	cmp	r3, #5
   18584:	d013      	beq.n	185ae <host_hci_dbg_event_disp+0x46>
   18586:	e3c6      	b.n	18d16 <host_hci_dbg_event_disp+0x7ae>
   18588:	2b0c      	cmp	r3, #12
   1858a:	d03d      	beq.n	18608 <host_hci_dbg_event_disp+0xa0>
   1858c:	2b0e      	cmp	r3, #14
   1858e:	d055      	beq.n	1863c <host_hci_dbg_event_disp+0xd4>
   18590:	e3c1      	b.n	18d16 <host_hci_dbg_event_disp+0x7ae>
   18592:	2b30      	cmp	r3, #48	; 0x30
   18594:	d01b      	beq.n	185ce <host_hci_dbg_event_disp+0x66>
   18596:	d803      	bhi.n	185a0 <host_hci_dbg_event_disp+0x38>
   18598:	2b13      	cmp	r3, #19
   1859a:	f000 81fe 	beq.w	1899a <host_hci_dbg_event_disp+0x432>
   1859e:	e3ba      	b.n	18d16 <host_hci_dbg_event_disp+0x7ae>
   185a0:	2b3e      	cmp	r3, #62	; 0x3e
   185a2:	f000 822a 	beq.w	189fa <host_hci_dbg_event_disp+0x492>
   185a6:	2b57      	cmp	r3, #87	; 0x57
   185a8:	f000 83a2 	beq.w	18cf0 <host_hci_dbg_event_disp+0x788>
   185ac:	e3b3      	b.n	18d16 <host_hci_dbg_event_disp+0x7ae>
{
    uint8_t status;
    uint8_t reason;
    uint16_t handle;

    status = evdata[0];
   185ae:	7885      	ldrb	r5, [r0, #2]
    handle = le16toh(evdata + 1);
   185b0:	3003      	adds	r0, #3
   185b2:	f004 fd6c 	bl	1d08e <le16toh>
    /* Ignore reason if status is not success */
    if (status != BLE_ERR_SUCCESS) {
   185b6:	b90d      	cbnz	r5, 185bc <host_hci_dbg_event_disp+0x54>
        reason = 0;
    } else {
        reason = evdata[3];
   185b8:	7963      	ldrb	r3, [r4, #5]
   185ba:	e000      	b.n	185be <host_hci_dbg_event_disp+0x56>

    status = evdata[0];
    handle = le16toh(evdata + 1);
    /* Ignore reason if status is not success */
    if (status != BLE_ERR_SUCCESS) {
        reason = 0;
   185bc:	2300      	movs	r3, #0
    } else {
        reason = evdata[3];
    }
    BLE_HS_LOG(DEBUG, "Disconnection Complete: status=%u handle=%u "
   185be:	9001      	str	r0, [sp, #4]
   185c0:	9302      	str	r3, [sp, #8]
   185c2:	9500      	str	r5, [sp, #0]
   185c4:	48ac      	ldr	r0, [pc, #688]	; (18878 <host_hci_dbg_event_disp+0x310>)
   185c6:	4bad      	ldr	r3, [pc, #692]	; (1887c <host_hci_dbg_event_disp+0x314>)
   185c8:	2104      	movs	r1, #4
   185ca:	2200      	movs	r2, #0
   185cc:	e019      	b.n	18602 <host_hci_dbg_event_disp+0x9a>
host_hci_dbg_encrypt_refresh_disp(uint8_t *evdata, uint8_t len)
{
    uint8_t status;
    uint16_t handle;

    status = evdata[0];
   185ce:	7885      	ldrb	r5, [r0, #2]
    handle = le16toh(evdata + 1);
   185d0:	3003      	adds	r0, #3
   185d2:	f004 fd5c 	bl	1d08e <le16toh>

    BLE_HS_LOG(DEBUG, "Encrypt key refresh: status=%u handle=%u\n",
   185d6:	9500      	str	r5, [sp, #0]
   185d8:	9001      	str	r0, [sp, #4]
   185da:	2104      	movs	r1, #4
   185dc:	48a6      	ldr	r0, [pc, #664]	; (18878 <host_hci_dbg_event_disp+0x310>)
   185de:	4ba8      	ldr	r3, [pc, #672]	; (18880 <host_hci_dbg_event_disp+0x318>)
   185e0:	2200      	movs	r2, #0
   185e2:	e39e      	b.n	18d22 <host_hci_dbg_event_disp+0x7ba>
{
    uint8_t status;
    uint8_t enabled;
    uint16_t handle;

    status = evdata[0];
   185e4:	7885      	ldrb	r5, [r0, #2]
    handle = le16toh(evdata + 1);
   185e6:	3003      	adds	r0, #3
   185e8:	f004 fd51 	bl	1d08e <le16toh>

    /* Ignore reason if status is not success */
    if (status != BLE_ERR_SUCCESS) {
   185ec:	b90d      	cbnz	r5, 185f2 <host_hci_dbg_event_disp+0x8a>
        enabled = 0;
    } else {
        enabled = evdata[3];
   185ee:	7963      	ldrb	r3, [r4, #5]
   185f0:	e000      	b.n	185f4 <host_hci_dbg_event_disp+0x8c>
    status = evdata[0];
    handle = le16toh(evdata + 1);

    /* Ignore reason if status is not success */
    if (status != BLE_ERR_SUCCESS) {
        enabled = 0;
   185f2:	2300      	movs	r3, #0
    } else {
        enabled = evdata[3];
    }
    BLE_HS_LOG(DEBUG, "Encrypt change: status=%u handle=%u state=%u\n",
   185f4:	9001      	str	r0, [sp, #4]
   185f6:	9302      	str	r3, [sp, #8]
   185f8:	489f      	ldr	r0, [pc, #636]	; (18878 <host_hci_dbg_event_disp+0x310>)
   185fa:	4ba2      	ldr	r3, [pc, #648]	; (18884 <host_hci_dbg_event_disp+0x31c>)
   185fc:	9500      	str	r5, [sp, #0]
   185fe:	2104      	movs	r1, #4
   18600:	2200      	movs	r2, #0
   18602:	f004 fe11 	bl	1d228 <log_printf>
   18606:	e38e      	b.n	18d26 <host_hci_dbg_event_disp+0x7be>
 * @param len
 */
static void
host_hci_dbg_rd_rem_ver_disp(uint8_t *evdata, uint8_t len)
{
    BLE_HS_LOG(DEBUG, "Remote Version Info: status=%u handle=%u vers_nr=%u "
   18608:	f890 8002 	ldrb.w	r8, [r0, #2]
   1860c:	3003      	adds	r0, #3
   1860e:	f004 fd3e 	bl	1d08e <le16toh>
   18612:	4607      	mov	r7, r0
   18614:	1da0      	adds	r0, r4, #6
   18616:	7966      	ldrb	r6, [r4, #5]
   18618:	f004 fd39 	bl	1d08e <le16toh>
   1861c:	4605      	mov	r5, r0
   1861e:	f104 0008 	add.w	r0, r4, #8
   18622:	f004 fd34 	bl	1d08e <le16toh>
   18626:	f8cd 8000 	str.w	r8, [sp]
   1862a:	9004      	str	r0, [sp, #16]
   1862c:	9701      	str	r7, [sp, #4]
   1862e:	9602      	str	r6, [sp, #8]
   18630:	9503      	str	r5, [sp, #12]
   18632:	4891      	ldr	r0, [pc, #580]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18634:	4b94      	ldr	r3, [pc, #592]	; (18888 <host_hci_dbg_event_disp+0x320>)
   18636:	2104      	movs	r1, #4
   18638:	2200      	movs	r2, #0
   1863a:	e2f1      	b.n	18c20 <host_hci_dbg_event_disp+0x6b8>
    uint8_t ogf;
    uint8_t ocf;
    uint8_t status;
    uint16_t opcode;

    if (len < 3) {
   1863c:	2e02      	cmp	r6, #2
   1863e:	d805      	bhi.n	1864c <host_hci_dbg_event_disp+0xe4>
        BLE_HS_LOG(DEBUG, "Invalid command complete: len=%d "
   18640:	9600      	str	r6, [sp, #0]
   18642:	488d      	ldr	r0, [pc, #564]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18644:	4b91      	ldr	r3, [pc, #580]	; (1888c <host_hci_dbg_event_disp+0x324>)
   18646:	2104      	movs	r1, #4
   18648:	2200      	movs	r2, #0
   1864a:	e192      	b.n	18972 <host_hci_dbg_event_disp+0x40a>
                          "(expected >= 3)", len);
        goto done;
    }

    cmd_pkts = evdata[0];
   1864c:	f890 8002 	ldrb.w	r8, [r0, #2]
    opcode = le16toh(evdata + 1);
   18650:	3003      	adds	r0, #3
   18652:	f004 fd1c 	bl	1d08e <le16toh>
    ogf = BLE_HCI_OGF(opcode);
   18656:	f3c0 2785 	ubfx	r7, r0, #10, #6
    ocf = BLE_HCI_OCF(opcode);
   1865a:	b2c5      	uxtb	r5, r0

    BLE_HS_LOG(DEBUG, "Command complete: cmd_pkts=%u ogf=0x%x ocf=0x%x",
   1865c:	f8cd 8000 	str.w	r8, [sp]
   18660:	9701      	str	r7, [sp, #4]
   18662:	9502      	str	r5, [sp, #8]
   18664:	4884      	ldr	r0, [pc, #528]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18666:	4b8a      	ldr	r3, [pc, #552]	; (18890 <host_hci_dbg_event_disp+0x328>)
   18668:	2104      	movs	r1, #4
   1866a:	2200      	movs	r2, #0
   1866c:	f004 fddc 	bl	1d228 <log_printf>
               cmd_pkts, ogf, ocf);

    if (len == 3) {
   18670:	2e03      	cmp	r6, #3
   18672:	f000 8310 	beq.w	18c96 <host_hci_dbg_event_disp+0x72e>
        goto done;
    }

    status = evdata[3];
   18676:	f894 8005 	ldrb.w	r8, [r4, #5]
    BLE_HS_LOG(DEBUG, " status=%u ", status);
   1867a:	f8cd 8000 	str.w	r8, [sp]
   1867e:	487e      	ldr	r0, [pc, #504]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18680:	4b84      	ldr	r3, [pc, #528]	; (18894 <host_hci_dbg_event_disp+0x32c>)
   18682:	2104      	movs	r1, #4
   18684:	2200      	movs	r2, #0
   18686:	f004 fdcf 	bl	1d228 <log_printf>

    /* Move past header and status */
    evdata += 4;

    /* Display parameters based on command. */
    switch (ogf) {
   1868a:	2f05      	cmp	r7, #5

    status = evdata[3];
    BLE_HS_LOG(DEBUG, " status=%u ", status);

    /* Move past header and status */
    evdata += 4;
   1868c:	f104 0606 	add.w	r6, r4, #6

    /* Display parameters based on command. */
    switch (ogf) {
   18690:	f000 8081 	beq.w	18796 <host_hci_dbg_event_disp+0x22e>
   18694:	2f08      	cmp	r7, #8
   18696:	f000 808d 	beq.w	187b4 <host_hci_dbg_event_disp+0x24c>
   1869a:	2f04      	cmp	r7, #4
   1869c:	f040 82fb 	bne.w	18c96 <host_hci_dbg_event_disp+0x72e>
host_hci_dbg_cmd_comp_info_params(uint8_t status, uint8_t ocf, uint8_t *evdata)
{
    int i;
    uint8_t *dptr;

    if (status != BLE_ERR_SUCCESS) {
   186a0:	f1b8 0f00 	cmp.w	r8, #0
   186a4:	f040 82f7 	bne.w	18c96 <host_hci_dbg_event_disp+0x72e>
        return;
    }

    switch (ocf) {
   186a8:	3d01      	subs	r5, #1
   186aa:	2d08      	cmp	r5, #8
   186ac:	f200 82f3 	bhi.w	18c96 <host_hci_dbg_event_disp+0x72e>
   186b0:	e8df f015 	tbh	[pc, r5, lsl #1]
   186b4:	00260009 	.word	0x00260009
   186b8:	02f10051 	.word	0x02f10051
   186bc:	02f102f1 	.word	0x02f102f1
   186c0:	02f102f1 	.word	0x02f102f1
   186c4:	0060      	.short	0x0060
    case BLE_HCI_OCF_IP_RD_LOCAL_VER:
        BLE_HS_LOG(DEBUG, "hci_ver=%u hci_rev=%u lmp_ver=%u mfrg=%u "
   186c6:	1de0      	adds	r0, r4, #7
   186c8:	f894 8006 	ldrb.w	r8, [r4, #6]
   186cc:	f004 fcdf 	bl	1d08e <le16toh>
   186d0:	4607      	mov	r7, r0
   186d2:	f104 000a 	add.w	r0, r4, #10
   186d6:	7a66      	ldrb	r6, [r4, #9]
   186d8:	f004 fcd9 	bl	1d08e <le16toh>
   186dc:	4605      	mov	r5, r0
   186de:	f104 000c 	add.w	r0, r4, #12
   186e2:	f004 fcd4 	bl	1d08e <le16toh>
   186e6:	f8cd 8000 	str.w	r8, [sp]
   186ea:	9004      	str	r0, [sp, #16]
   186ec:	9701      	str	r7, [sp, #4]
   186ee:	9602      	str	r6, [sp, #8]
   186f0:	9503      	str	r5, [sp, #12]
   186f2:	4861      	ldr	r0, [pc, #388]	; (18878 <host_hci_dbg_event_disp+0x310>)
   186f4:	4b68      	ldr	r3, [pc, #416]	; (18898 <host_hci_dbg_event_disp+0x330>)
   186f6:	2104      	movs	r1, #4
   186f8:	2200      	movs	r2, #0
   186fa:	f004 fd95 	bl	1d228 <log_printf>
   186fe:	e2ca      	b.n	18c96 <host_hci_dbg_event_disp+0x72e>
                          "lmp_subver=%u",
                   evdata[0], le16toh(evdata + 1), evdata[3],
                   le16toh(evdata + 4), le16toh(evdata + 6));
        break;
    case BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD:
        BLE_HS_LOG(DEBUG, "supp_cmds=");
   18700:	485d      	ldr	r0, [pc, #372]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18702:	4b66      	ldr	r3, [pc, #408]	; (1889c <host_hci_dbg_event_disp+0x334>)
   18704:	2104      	movs	r1, #4
   18706:	2200      	movs	r2, #0
   18708:	f004 fd8e 	bl	1d228 <log_printf>
   1870c:	f104 050e 	add.w	r5, r4, #14
   18710:	344e      	adds	r4, #78	; 0x4e
        dptr = evdata;
        for (i = 0; i < 8; ++i) {
            BLE_HS_LOG(DEBUG, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:",
   18712:	f815 3c08 	ldrb.w	r3, [r5, #-8]
   18716:	9300      	str	r3, [sp, #0]
   18718:	f815 3c07 	ldrb.w	r3, [r5, #-7]
   1871c:	9301      	str	r3, [sp, #4]
   1871e:	f815 3c06 	ldrb.w	r3, [r5, #-6]
   18722:	9302      	str	r3, [sp, #8]
   18724:	f815 3c05 	ldrb.w	r3, [r5, #-5]
   18728:	9303      	str	r3, [sp, #12]
   1872a:	f815 3c04 	ldrb.w	r3, [r5, #-4]
   1872e:	9304      	str	r3, [sp, #16]
   18730:	f815 3c03 	ldrb.w	r3, [r5, #-3]
   18734:	9305      	str	r3, [sp, #20]
   18736:	f815 3c02 	ldrb.w	r3, [r5, #-2]
   1873a:	9306      	str	r3, [sp, #24]
   1873c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   18740:	9307      	str	r3, [sp, #28]
   18742:	484d      	ldr	r0, [pc, #308]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18744:	4b56      	ldr	r3, [pc, #344]	; (188a0 <host_hci_dbg_event_disp+0x338>)
   18746:	2104      	movs	r1, #4
   18748:	2200      	movs	r2, #0
   1874a:	3508      	adds	r5, #8
   1874c:	f004 fd6c 	bl	1d228 <log_printf>
                   le16toh(evdata + 4), le16toh(evdata + 6));
        break;
    case BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD:
        BLE_HS_LOG(DEBUG, "supp_cmds=");
        dptr = evdata;
        for (i = 0; i < 8; ++i) {
   18750:	42a5      	cmp	r5, r4
   18752:	d1de      	bne.n	18712 <host_hci_dbg_event_disp+0x1aa>
   18754:	e29f      	b.n	18c96 <host_hci_dbg_event_disp+0x72e>
                       dptr[4], dptr[5], dptr[6], dptr[7]);
            dptr += 8;
        }
        break;
    case BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT:
        BLE_HS_LOG(DEBUG, "supp_feat=0x%lx%08lx",
   18756:	f104 000a 	add.w	r0, r4, #10
   1875a:	f004 fc9d 	bl	1d098 <le32toh>
   1875e:	4604      	mov	r4, r0
   18760:	4630      	mov	r0, r6
   18762:	f004 fc99 	bl	1d098 <le32toh>
   18766:	9400      	str	r4, [sp, #0]
   18768:	9001      	str	r0, [sp, #4]
   1876a:	2104      	movs	r1, #4
   1876c:	4842      	ldr	r0, [pc, #264]	; (18878 <host_hci_dbg_event_disp+0x310>)
   1876e:	4b4d      	ldr	r3, [pc, #308]	; (188a4 <host_hci_dbg_event_disp+0x33c>)
   18770:	2200      	movs	r2, #0
   18772:	e0f3      	b.n	1895c <host_hci_dbg_event_disp+0x3f4>
                   le32toh(evdata + 4), le32toh(evdata));
        break;
    case BLE_HCI_OCF_IP_RD_BD_ADDR:
        BLE_HS_LOG(DEBUG, "bd_addr=%x:%x:%x:%x:%x:%x",
   18774:	7ae3      	ldrb	r3, [r4, #11]
   18776:	9300      	str	r3, [sp, #0]
   18778:	7aa3      	ldrb	r3, [r4, #10]
   1877a:	9301      	str	r3, [sp, #4]
   1877c:	7a63      	ldrb	r3, [r4, #9]
   1877e:	9302      	str	r3, [sp, #8]
   18780:	7a23      	ldrb	r3, [r4, #8]
   18782:	9303      	str	r3, [sp, #12]
   18784:	79e3      	ldrb	r3, [r4, #7]
   18786:	9304      	str	r3, [sp, #16]
   18788:	79a3      	ldrb	r3, [r4, #6]
   1878a:	9305      	str	r3, [sp, #20]
   1878c:	483a      	ldr	r0, [pc, #232]	; (18878 <host_hci_dbg_event_disp+0x310>)
   1878e:	4b46      	ldr	r3, [pc, #280]	; (188a8 <host_hci_dbg_event_disp+0x340>)
   18790:	2104      	movs	r1, #4
   18792:	2200      	movs	r2, #0
   18794:	e041      	b.n	1881a <host_hci_dbg_event_disp+0x2b2>
    switch (ogf) {
    case BLE_HCI_OGF_INFO_PARAMS:
        host_hci_dbg_cmd_comp_info_params(status, ocf, evdata);
        break;
    case BLE_HCI_OGF_STATUS_PARAMS:
        switch (ocf) {
   18796:	2d05      	cmp	r5, #5
   18798:	f040 827d 	bne.w	18c96 <host_hci_dbg_event_disp+0x72e>
        case BLE_HCI_OCF_RD_RSSI:
            BLE_HS_LOG(DEBUG, "handle=%u rssi=%d", le16toh(evdata),
   1879c:	4630      	mov	r0, r6
   1879e:	f004 fc76 	bl	1d08e <le16toh>
   187a2:	9000      	str	r0, [sp, #0]
   187a4:	f994 3008 	ldrsb.w	r3, [r4, #8]
   187a8:	9301      	str	r3, [sp, #4]
   187aa:	4833      	ldr	r0, [pc, #204]	; (18878 <host_hci_dbg_event_disp+0x310>)
   187ac:	4b3f      	ldr	r3, [pc, #252]	; (188ac <host_hci_dbg_event_disp+0x344>)
   187ae:	2104      	movs	r1, #4
   187b0:	2200      	movs	r2, #0
   187b2:	e0d3      	b.n	1895c <host_hci_dbg_event_disp+0x3f4>
        default:
            break;
        }
        break;
    case BLE_HCI_OGF_LE:
        switch (ocf) {
   187b4:	3d15      	subs	r5, #21
   187b6:	2d1a      	cmp	r5, #26
   187b8:	f200 826d 	bhi.w	18c96 <host_hci_dbg_event_disp+0x72e>
   187bc:	e8df f015 	tbh	[pc, r5, lsl #1]
   187c0:	026b001b 	.word	0x026b001b
   187c4:	00a9007e 	.word	0x00a9007e
   187c8:	00d1026b 	.word	0x00d1026b
   187cc:	004d00d1 	.word	0x004d00d1
   187d0:	026b026b 	.word	0x026b026b
   187d4:	026b026b 	.word	0x026b026b
   187d8:	00d1026b 	.word	0x00d1026b
   187dc:	026b00c0 	.word	0x026b00c0
   187e0:	026b026b 	.word	0x026b026b
   187e4:	026b026b 	.word	0x026b026b
   187e8:	026b026b 	.word	0x026b026b
   187ec:	026b026b 	.word	0x026b026b
   187f0:	026b026b 	.word	0x026b026b
   187f4:	0030      	.short	0x0030
        case BLE_HCI_OCF_LE_RD_CHAN_MAP:
            BLE_HS_LOG(DEBUG, "handle=%u chanmap=%x.%x.%x.%x.%x",
   187f6:	4630      	mov	r0, r6
   187f8:	f004 fc49 	bl	1d08e <le16toh>
   187fc:	9000      	str	r0, [sp, #0]
   187fe:	7a23      	ldrb	r3, [r4, #8]
   18800:	9301      	str	r3, [sp, #4]
   18802:	7a63      	ldrb	r3, [r4, #9]
   18804:	9302      	str	r3, [sp, #8]
   18806:	7aa3      	ldrb	r3, [r4, #10]
   18808:	9303      	str	r3, [sp, #12]
   1880a:	7ae3      	ldrb	r3, [r4, #11]
   1880c:	9304      	str	r3, [sp, #16]
   1880e:	7b23      	ldrb	r3, [r4, #12]
   18810:	9305      	str	r3, [sp, #20]
   18812:	4819      	ldr	r0, [pc, #100]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18814:	4b26      	ldr	r3, [pc, #152]	; (188b0 <host_hci_dbg_event_disp+0x348>)
   18816:	2104      	movs	r1, #4
   18818:	2200      	movs	r2, #0
   1881a:	f004 fd05 	bl	1d228 <log_printf>
   1881e:	e23a      	b.n	18c96 <host_hci_dbg_event_disp+0x72e>
                       le16toh(evdata), evdata[2], evdata[3], evdata[4],
                       evdata[5], evdata[6]);
            break;
        case BLE_HCI_OCF_LE_RD_MAX_DATA_LEN:
            BLE_HS_LOG(DEBUG, "txoct=%u txtime=%u rxoct=%u rxtime=%u",
   18820:	4630      	mov	r0, r6
   18822:	f004 fc34 	bl	1d08e <le16toh>
   18826:	4607      	mov	r7, r0
   18828:	f104 0008 	add.w	r0, r4, #8
   1882c:	f004 fc2f 	bl	1d08e <le16toh>
   18830:	4606      	mov	r6, r0
   18832:	f104 000a 	add.w	r0, r4, #10
   18836:	f004 fc2a 	bl	1d08e <le16toh>
   1883a:	4605      	mov	r5, r0
   1883c:	f104 000c 	add.w	r0, r4, #12
   18840:	f004 fc25 	bl	1d08e <le16toh>
   18844:	9700      	str	r7, [sp, #0]
   18846:	9003      	str	r0, [sp, #12]
   18848:	9601      	str	r6, [sp, #4]
   1884a:	9502      	str	r5, [sp, #8]
   1884c:	480a      	ldr	r0, [pc, #40]	; (18878 <host_hci_dbg_event_disp+0x310>)
   1884e:	4b19      	ldr	r3, [pc, #100]	; (188b4 <host_hci_dbg_event_disp+0x34c>)
   18850:	2104      	movs	r1, #4
   18852:	2200      	movs	r2, #0
   18854:	f004 fce8 	bl	1d228 <log_printf>
   18858:	e21d      	b.n	18c96 <host_hci_dbg_event_disp+0x72e>
                       le16toh(evdata), le16toh(evdata + 2),
                       le16toh(evdata + 4), le16toh(evdata + 6));
            break;
        case BLE_HCI_OCF_LE_RD_SUPP_STATES:
            BLE_HS_LOG(DEBUG, "states=0x%lx%08lx", le32toh(evdata + 4),
   1885a:	f104 000a 	add.w	r0, r4, #10
   1885e:	f004 fc1b 	bl	1d098 <le32toh>
   18862:	4604      	mov	r4, r0
   18864:	4630      	mov	r0, r6
   18866:	f004 fc17 	bl	1d098 <le32toh>
   1886a:	9400      	str	r4, [sp, #0]
   1886c:	9001      	str	r0, [sp, #4]
   1886e:	2104      	movs	r1, #4
   18870:	4801      	ldr	r0, [pc, #4]	; (18878 <host_hci_dbg_event_disp+0x310>)
   18872:	4b11      	ldr	r3, [pc, #68]	; (188b8 <host_hci_dbg_event_disp+0x350>)
   18874:	2200      	movs	r2, #0
   18876:	e071      	b.n	1895c <host_hci_dbg_event_disp+0x3f4>
   18878:	20003b9c 	.word	0x20003b9c
   1887c:	0001ff03 	.word	0x0001ff03
   18880:	0001ff3a 	.word	0x0001ff3a
   18884:	0001ff64 	.word	0x0001ff64
   18888:	0001ff92 	.word	0x0001ff92
   1888c:	0001ffdb 	.word	0x0001ffdb
   18890:	0002000c 	.word	0x0002000c
   18894:	0002003c 	.word	0x0002003c
   18898:	00020048 	.word	0x00020048
   1889c:	0002007f 	.word	0x0002007f
   188a0:	0002008a 	.word	0x0002008a
   188a4:	000200b3 	.word	0x000200b3
   188a8:	000200c8 	.word	0x000200c8
   188ac:	000200e2 	.word	0x000200e2
   188b0:	000200f4 	.word	0x000200f4
   188b4:	00020115 	.word	0x00020115
   188b8:	0002013b 	.word	0x0002013b
                       le32toh(evdata));
            break;
        case BLE_HCI_OCF_LE_ENCRYPT:
            BLE_HS_LOG(DEBUG, "encdata=0x%02x%02x%02x%02x%02x%02x%02x%02x",
   188bc:	7d63      	ldrb	r3, [r4, #21]
   188be:	9300      	str	r3, [sp, #0]
   188c0:	7d23      	ldrb	r3, [r4, #20]
   188c2:	9301      	str	r3, [sp, #4]
   188c4:	7ce3      	ldrb	r3, [r4, #19]
   188c6:	9302      	str	r3, [sp, #8]
   188c8:	7ca3      	ldrb	r3, [r4, #18]
   188ca:	9303      	str	r3, [sp, #12]
   188cc:	7c63      	ldrb	r3, [r4, #17]
   188ce:	9304      	str	r3, [sp, #16]
   188d0:	7c23      	ldrb	r3, [r4, #16]
   188d2:	9305      	str	r3, [sp, #20]
   188d4:	7be3      	ldrb	r3, [r4, #15]
   188d6:	9306      	str	r3, [sp, #24]
   188d8:	7ba3      	ldrb	r3, [r4, #14]
   188da:	9307      	str	r3, [sp, #28]
   188dc:	487e      	ldr	r0, [pc, #504]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   188de:	4b7f      	ldr	r3, [pc, #508]	; (18adc <host_hci_dbg_event_disp+0x574>)
   188e0:	2104      	movs	r1, #4
   188e2:	2200      	movs	r2, #0
   188e4:	f004 fca0 	bl	1d228 <log_printf>
                       evdata[15], evdata[14], evdata[13], evdata[12],
                       evdata[11], evdata[10], evdata[9], evdata[8]);
            BLE_HS_LOG(DEBUG, "%02x%02x%02x%02x%02x%02x%02x%02x",
   188e8:	7b63      	ldrb	r3, [r4, #13]
   188ea:	9300      	str	r3, [sp, #0]
   188ec:	7b23      	ldrb	r3, [r4, #12]
   188ee:	9301      	str	r3, [sp, #4]
   188f0:	7ae3      	ldrb	r3, [r4, #11]
   188f2:	9302      	str	r3, [sp, #8]
   188f4:	7aa3      	ldrb	r3, [r4, #10]
   188f6:	9303      	str	r3, [sp, #12]
   188f8:	7a63      	ldrb	r3, [r4, #9]
   188fa:	9304      	str	r3, [sp, #16]
   188fc:	7a23      	ldrb	r3, [r4, #8]
   188fe:	9305      	str	r3, [sp, #20]
   18900:	79e3      	ldrb	r3, [r4, #7]
   18902:	9306      	str	r3, [sp, #24]
   18904:	79a3      	ldrb	r3, [r4, #6]
   18906:	9307      	str	r3, [sp, #28]
   18908:	4873      	ldr	r0, [pc, #460]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   1890a:	4b75      	ldr	r3, [pc, #468]	; (18ae0 <host_hci_dbg_event_disp+0x578>)
   1890c:	2104      	movs	r1, #4
   1890e:	2200      	movs	r2, #0
   18910:	e013      	b.n	1893a <host_hci_dbg_event_disp+0x3d2>
                       evdata[7], evdata[6], evdata[5], evdata[4],
                       evdata[3], evdata[2], evdata[1], evdata[0]);

            break;
        case BLE_HCI_OCF_LE_RAND:
            BLE_HS_LOG(DEBUG, "rand=0x%02x%02x%02x%02x%02x%02x%02x%02x",
   18912:	79a3      	ldrb	r3, [r4, #6]
   18914:	9300      	str	r3, [sp, #0]
   18916:	79e3      	ldrb	r3, [r4, #7]
   18918:	9301      	str	r3, [sp, #4]
   1891a:	7a23      	ldrb	r3, [r4, #8]
   1891c:	9302      	str	r3, [sp, #8]
   1891e:	7a63      	ldrb	r3, [r4, #9]
   18920:	9303      	str	r3, [sp, #12]
   18922:	7aa3      	ldrb	r3, [r4, #10]
   18924:	9304      	str	r3, [sp, #16]
   18926:	7ae3      	ldrb	r3, [r4, #11]
   18928:	9305      	str	r3, [sp, #20]
   1892a:	7b23      	ldrb	r3, [r4, #12]
   1892c:	9306      	str	r3, [sp, #24]
   1892e:	7b63      	ldrb	r3, [r4, #13]
   18930:	9307      	str	r3, [sp, #28]
   18932:	4869      	ldr	r0, [pc, #420]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   18934:	4b6b      	ldr	r3, [pc, #428]	; (18ae4 <host_hci_dbg_event_disp+0x57c>)
   18936:	2104      	movs	r1, #4
   18938:	2200      	movs	r2, #0
   1893a:	f004 fc75 	bl	1d228 <log_printf>
   1893e:	e1aa      	b.n	18c96 <host_hci_dbg_event_disp+0x72e>
                       evdata[0], evdata[1], evdata[2], evdata[3],
                       evdata[4], evdata[5], evdata[6], evdata[7]);
            break;
        case BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN:
            BLE_HS_LOG(DEBUG, "txoct=%u txtime=%u", le16toh(evdata),
   18940:	4630      	mov	r0, r6
   18942:	f004 fba4 	bl	1d08e <le16toh>
   18946:	4605      	mov	r5, r0
   18948:	f104 0008 	add.w	r0, r4, #8
   1894c:	f004 fb9f 	bl	1d08e <le16toh>
   18950:	4b65      	ldr	r3, [pc, #404]	; (18ae8 <host_hci_dbg_event_disp+0x580>)
   18952:	9001      	str	r0, [sp, #4]
   18954:	4860      	ldr	r0, [pc, #384]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   18956:	9500      	str	r5, [sp, #0]
   18958:	2104      	movs	r1, #4
   1895a:	2200      	movs	r2, #0
   1895c:	f004 fc64 	bl	1d228 <log_printf>
   18960:	e199      	b.n	18c96 <host_hci_dbg_event_disp+0x72e>
                       le16toh(evdata + 2));
            break;
        case BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY:
        case BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY:
        case BLE_HCI_OCF_LE_SET_DATA_LEN:
            BLE_HS_LOG(DEBUG, "handle=%u", le16toh(evdata));
   18962:	4630      	mov	r0, r6
   18964:	f004 fb93 	bl	1d08e <le16toh>
   18968:	4b60      	ldr	r3, [pc, #384]	; (18aec <host_hci_dbg_event_disp+0x584>)
   1896a:	9000      	str	r0, [sp, #0]
   1896c:	485a      	ldr	r0, [pc, #360]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   1896e:	2104      	movs	r1, #4
   18970:	2200      	movs	r2, #0
   18972:	f004 fc59 	bl	1d228 <log_printf>
   18976:	e18e      	b.n	18c96 <host_hci_dbg_event_disp+0x72e>
{
    uint8_t ogf;
    uint8_t ocf;
    uint16_t opcode;

    opcode = le16toh(evdata + 2);
   18978:	3004      	adds	r0, #4
   1897a:	f004 fb88 	bl	1d08e <le16toh>
    ogf = BLE_HCI_OGF(opcode);
    ocf = BLE_HCI_OCF(opcode);

    BLE_HS_LOG(DEBUG, "Command Status: status=%u cmd_pkts=%u ocf=0x%x "
   1897e:	78a3      	ldrb	r3, [r4, #2]
   18980:	9300      	str	r3, [sp, #0]
   18982:	78e3      	ldrb	r3, [r4, #3]
   18984:	9301      	str	r3, [sp, #4]
   18986:	b2c3      	uxtb	r3, r0
   18988:	f3c0 2085 	ubfx	r0, r0, #10, #6
   1898c:	9302      	str	r3, [sp, #8]
   1898e:	9003      	str	r0, [sp, #12]
   18990:	2104      	movs	r1, #4
   18992:	4851      	ldr	r0, [pc, #324]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   18994:	4b56      	ldr	r3, [pc, #344]	; (18af0 <host_hci_dbg_event_disp+0x588>)
   18996:	2200      	movs	r2, #0
   18998:	e1a0      	b.n	18cdc <host_hci_dbg_event_disp+0x774>
    uint8_t *handle_ptr;
    uint8_t *pkt_ptr;
    uint16_t handle;
    uint16_t pkts;

    handles = evdata[0];
   1899a:	7885      	ldrb	r5, [r0, #2]
    if (len != ((handles * 4) + 1)) {
        BLE_HS_LOG(DEBUG, "ERR: Number of Completed Packets bad length: "
   1899c:	9500      	str	r5, [sp, #0]
    uint8_t *pkt_ptr;
    uint16_t handle;
    uint16_t pkts;

    handles = evdata[0];
    if (len != ((handles * 4) + 1)) {
   1899e:	2104      	movs	r1, #4
   189a0:	2301      	movs	r3, #1
   189a2:	fb11 3305 	smlabb	r3, r1, r5, r3
   189a6:	429e      	cmp	r6, r3
   189a8:	d004      	beq.n	189b4 <host_hci_dbg_event_disp+0x44c>
        BLE_HS_LOG(DEBUG, "ERR: Number of Completed Packets bad length: "
   189aa:	9601      	str	r6, [sp, #4]
   189ac:	484a      	ldr	r0, [pc, #296]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   189ae:	4b51      	ldr	r3, [pc, #324]	; (18af4 <host_hci_dbg_event_disp+0x58c>)
   189b0:	2200      	movs	r2, #0
   189b2:	e1b6      	b.n	18d22 <host_hci_dbg_event_disp+0x7ba>
                          "num_handles=%u len=%u\n", handles, len);
        return;

    }

    BLE_HS_LOG(DEBUG, "Number of Completed Packets: num_handles=%u\n",
   189b4:	4848      	ldr	r0, [pc, #288]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   189b6:	4b50      	ldr	r3, [pc, #320]	; (18af8 <host_hci_dbg_event_disp+0x590>)
   189b8:	2200      	movs	r2, #0
   189ba:	f004 fc35 	bl	1d228 <log_printf>
               handles);
    if (handles) {
   189be:	2d00      	cmp	r5, #0
   189c0:	f000 81b1 	beq.w	18d26 <host_hci_dbg_event_disp+0x7be>
        handle_ptr = evdata + 1;
   189c4:	3403      	adds	r4, #3
        pkt_ptr = handle_ptr + (2 * handles);
   189c6:	eb04 0645 	add.w	r6, r4, r5, lsl #1
        while (handles) {
            handle = le16toh(handle_ptr);
   189ca:	4620      	mov	r0, r4
   189cc:	f004 fb5f 	bl	1d08e <le16toh>
   189d0:	4607      	mov	r7, r0
            handle_ptr += 2;
            pkts = le16toh(pkt_ptr);
   189d2:	4630      	mov	r0, r6
   189d4:	f004 fb5b 	bl	1d08e <le16toh>
            pkt_ptr += 2;
            BLE_HS_LOG(DEBUG, "handle:%u pkts:%u\n", handle, pkts);
            --handles;
   189d8:	3d01      	subs	r5, #1
        while (handles) {
            handle = le16toh(handle_ptr);
            handle_ptr += 2;
            pkts = le16toh(pkt_ptr);
            pkt_ptr += 2;
            BLE_HS_LOG(DEBUG, "handle:%u pkts:%u\n", handle, pkts);
   189da:	9001      	str	r0, [sp, #4]
   189dc:	9700      	str	r7, [sp, #0]
   189de:	483e      	ldr	r0, [pc, #248]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   189e0:	4b46      	ldr	r3, [pc, #280]	; (18afc <host_hci_dbg_event_disp+0x594>)
   189e2:	2104      	movs	r1, #4
   189e4:	2200      	movs	r2, #0
   189e6:	f004 fc1f 	bl	1d228 <log_printf>
    BLE_HS_LOG(DEBUG, "Number of Completed Packets: num_handles=%u\n",
               handles);
    if (handles) {
        handle_ptr = evdata + 1;
        pkt_ptr = handle_ptr + (2 * handles);
        while (handles) {
   189ea:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
            handle = le16toh(handle_ptr);
            handle_ptr += 2;
   189ee:	f104 0402 	add.w	r4, r4, #2
            pkts = le16toh(pkt_ptr);
            pkt_ptr += 2;
   189f2:	f106 0602 	add.w	r6, r6, #2
    BLE_HS_LOG(DEBUG, "Number of Completed Packets: num_handles=%u\n",
               handles);
    if (handles) {
        handle_ptr = evdata + 1;
        pkt_ptr = handle_ptr + (2 * handles);
        while (handles) {
   189f6:	d1e8      	bne.n	189ca <host_hci_dbg_event_disp+0x462>
   189f8:	e195      	b.n	18d26 <host_hci_dbg_event_disp+0x7be>
        break;
    case BLE_HCI_EVCODE_NUM_COMP_PKTS:
        host_hci_dbg_num_comp_pkts_disp(evdata, len);
        break;
    case BLE_HCI_EVCODE_LE_META:
        host_hci_dbg_le_event_disp(evdata[0], len, evdata + 1);
   189fa:	7887      	ldrb	r7, [r0, #2]
    int imax;
    uint8_t *dptr;
    char *adv_ptr;
    char adv_data_buf[32];

    switch (subev) {
   189fc:	1e7b      	subs	r3, r7, #1
        break;
    case BLE_HCI_EVCODE_NUM_COMP_PKTS:
        host_hci_dbg_num_comp_pkts_disp(evdata, len);
        break;
    case BLE_HCI_EVCODE_LE_META:
        host_hci_dbg_le_event_disp(evdata[0], len, evdata + 1);
   189fe:	3003      	adds	r0, #3
    int imax;
    uint8_t *dptr;
    char *adv_ptr;
    char adv_data_buf[32];

    switch (subev) {
   18a00:	2b09      	cmp	r3, #9
   18a02:	f200 816e 	bhi.w	18ce2 <host_hci_dbg_event_disp+0x77a>
   18a06:	e8df f013 	tbh	[pc, r3, lsl #1]
   18a0a:	000a      	.short	0x000a
   18a0c:	00ca0083 	.word	0x00ca0083
   18a10:	0151012d 	.word	0x0151012d
   18a14:	00ed010e 	.word	0x00ed010e
   18a18:	016c016c 	.word	0x016c016c
   18a1c:	000a      	.short	0x000a
    case BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE:
    case BLE_HCI_LE_SUBEV_CONN_COMPLETE:
        status = evdata[0];
   18a1e:	78e6      	ldrb	r6, [r4, #3]
        if (status == BLE_ERR_SUCCESS) {
   18a20:	2e00      	cmp	r6, #0
   18a22:	d152      	bne.n	18aca <host_hci_dbg_event_disp+0x562>
            BLE_HS_LOG(DEBUG, "LE connection complete. handle=%u role=%u "
   18a24:	1d20      	adds	r0, r4, #4
   18a26:	f004 fb32 	bl	1d08e <le16toh>
   18a2a:	9000      	str	r0, [sp, #0]
   18a2c:	79a3      	ldrb	r3, [r4, #6]
   18a2e:	9301      	str	r3, [sp, #4]
   18a30:	79e3      	ldrb	r3, [r4, #7]
   18a32:	9302      	str	r3, [sp, #8]
   18a34:	7b63      	ldrb	r3, [r4, #13]
   18a36:	9303      	str	r3, [sp, #12]
   18a38:	7b23      	ldrb	r3, [r4, #12]
   18a3a:	9304      	str	r3, [sp, #16]
   18a3c:	7ae3      	ldrb	r3, [r4, #11]
   18a3e:	9305      	str	r3, [sp, #20]
   18a40:	7aa3      	ldrb	r3, [r4, #10]
   18a42:	9306      	str	r3, [sp, #24]
   18a44:	7a63      	ldrb	r3, [r4, #9]
   18a46:	9307      	str	r3, [sp, #28]
   18a48:	7a23      	ldrb	r3, [r4, #8]
   18a4a:	9308      	str	r3, [sp, #32]
   18a4c:	4822      	ldr	r0, [pc, #136]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   18a4e:	4b2c      	ldr	r3, [pc, #176]	; (18b00 <host_hci_dbg_event_disp+0x598>)
   18a50:	2104      	movs	r1, #4
   18a52:	4632      	mov	r2, r6
   18a54:	f004 fbe8 	bl	1d228 <log_printf>
                       le16toh(evdata + 1), evdata[3], evdata[4],
                       evdata[10], evdata[9], evdata[8], evdata[7],
                       evdata[6], evdata[5]);

            evdata += 11;
            if (subev == BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE) {
   18a58:	2f0a      	cmp	r7, #10
                              "paddrtype=%u addr=%x.%x.%x.%x.%x.%x ",
                       le16toh(evdata + 1), evdata[3], evdata[4],
                       evdata[10], evdata[9], evdata[8], evdata[7],
                       evdata[6], evdata[5]);

            evdata += 11;
   18a5a:	f104 050e 	add.w	r5, r4, #14
            if (subev == BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE) {
   18a5e:	d11f      	bne.n	18aa0 <host_hci_dbg_event_disp+0x538>
                BLE_HS_LOG(DEBUG, "local_rpa=%x.%x.%x.%x.%x.%x "
   18a60:	7ce3      	ldrb	r3, [r4, #19]
   18a62:	9300      	str	r3, [sp, #0]
   18a64:	7ca3      	ldrb	r3, [r4, #18]
   18a66:	9301      	str	r3, [sp, #4]
   18a68:	7c63      	ldrb	r3, [r4, #17]
   18a6a:	9302      	str	r3, [sp, #8]
   18a6c:	7c23      	ldrb	r3, [r4, #16]
   18a6e:	9303      	str	r3, [sp, #12]
   18a70:	7be3      	ldrb	r3, [r4, #15]
   18a72:	9304      	str	r3, [sp, #16]
   18a74:	7ba3      	ldrb	r3, [r4, #14]
   18a76:	9305      	str	r3, [sp, #20]
   18a78:	7e63      	ldrb	r3, [r4, #25]
   18a7a:	9306      	str	r3, [sp, #24]
   18a7c:	7e23      	ldrb	r3, [r4, #24]
   18a7e:	9307      	str	r3, [sp, #28]
   18a80:	7de3      	ldrb	r3, [r4, #23]
   18a82:	9308      	str	r3, [sp, #32]
   18a84:	7da3      	ldrb	r3, [r4, #22]
   18a86:	9309      	str	r3, [sp, #36]	; 0x24
   18a88:	7d63      	ldrb	r3, [r4, #21]
   18a8a:	930a      	str	r3, [sp, #40]	; 0x28
   18a8c:	7d23      	ldrb	r3, [r4, #20]
   18a8e:	930b      	str	r3, [sp, #44]	; 0x2c
   18a90:	4811      	ldr	r0, [pc, #68]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   18a92:	4b1c      	ldr	r3, [pc, #112]	; (18b04 <host_hci_dbg_event_disp+0x59c>)
   18a94:	2104      	movs	r1, #4
   18a96:	4632      	mov	r2, r6
   18a98:	f004 fbc6 	bl	1d228 <log_printf>
                           evdata[5], evdata[4], evdata[3], evdata[2],
                           evdata[1], evdata[0],
                           evdata[11], evdata[10], evdata[9], evdata[8],
                           evdata[7], evdata[6]);

                evdata += 12;
   18a9c:	f104 051a 	add.w	r5, r4, #26
            }
            BLE_HS_LOG(DEBUG, "itvl=%u latency=%u spvn_tmo=%u mca=%u\n",
   18aa0:	4628      	mov	r0, r5
   18aa2:	f004 faf4 	bl	1d08e <le16toh>
   18aa6:	4606      	mov	r6, r0
   18aa8:	1ca8      	adds	r0, r5, #2
   18aaa:	f004 faf0 	bl	1d08e <le16toh>
   18aae:	4604      	mov	r4, r0
   18ab0:	1d28      	adds	r0, r5, #4
   18ab2:	f004 faec 	bl	1d08e <le16toh>
   18ab6:	9600      	str	r6, [sp, #0]
   18ab8:	9002      	str	r0, [sp, #8]
   18aba:	9401      	str	r4, [sp, #4]
   18abc:	79ab      	ldrb	r3, [r5, #6]
   18abe:	9303      	str	r3, [sp, #12]
   18ac0:	4805      	ldr	r0, [pc, #20]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   18ac2:	4b11      	ldr	r3, [pc, #68]	; (18b08 <host_hci_dbg_event_disp+0x5a0>)
   18ac4:	2104      	movs	r1, #4
   18ac6:	2200      	movs	r2, #0
   18ac8:	e108      	b.n	18cdc <host_hci_dbg_event_disp+0x774>
                       le16toh(evdata), le16toh(evdata + 2),
                       le16toh(evdata + 4), evdata[6]);
        } else {
            BLE_HS_LOG(DEBUG, "LE connection complete. FAIL (status=%u)\n",
   18aca:	9600      	str	r6, [sp, #0]
   18acc:	4802      	ldr	r0, [pc, #8]	; (18ad8 <host_hci_dbg_event_disp+0x570>)
   18ace:	4b0f      	ldr	r3, [pc, #60]	; (18b0c <host_hci_dbg_event_disp+0x5a4>)
   18ad0:	2104      	movs	r1, #4
   18ad2:	2200      	movs	r2, #0
   18ad4:	e11c      	b.n	18d10 <host_hci_dbg_event_disp+0x7a8>
   18ad6:	bf00      	nop
   18ad8:	20003b9c 	.word	0x20003b9c
   18adc:	0002014d 	.word	0x0002014d
   18ae0:	0001f778 	.word	0x0001f778
   18ae4:	00020178 	.word	0x00020178
   18ae8:	000201a0 	.word	0x000201a0
   18aec:	000201b3 	.word	0x000201b3
   18af0:	000201bd 	.word	0x000201bd
   18af4:	000201f6 	.word	0x000201f6
   18af8:	0002023a 	.word	0x0002023a
   18afc:	00020267 	.word	0x00020267
   18b00:	0002027a 	.word	0x0002027a
   18b04:	000202c9 	.word	0x000202c9
   18b08:	00020301 	.word	0x00020301
   18b0c:	00020328 	.word	0x00020328
                       status);
        }
        break;
    case BLE_HCI_LE_SUBEV_ADV_RPT:
        advlen = evdata[9];
   18b10:	7b25      	ldrb	r5, [r4, #12]
        rssi = evdata[10 + advlen];
        BLE_HS_LOG(DEBUG, "LE advertising report. len=%u num=%u evtype=%u "
   18b12:	9600      	str	r6, [sp, #0]
   18b14:	78e3      	ldrb	r3, [r4, #3]
   18b16:	9301      	str	r3, [sp, #4]
   18b18:	7923      	ldrb	r3, [r4, #4]
   18b1a:	9302      	str	r3, [sp, #8]
   18b1c:	7963      	ldrb	r3, [r4, #5]
   18b1e:	9303      	str	r3, [sp, #12]
   18b20:	7ae3      	ldrb	r3, [r4, #11]
   18b22:	9304      	str	r3, [sp, #16]
   18b24:	7aa3      	ldrb	r3, [r4, #10]
   18b26:	9305      	str	r3, [sp, #20]
   18b28:	7a63      	ldrb	r3, [r4, #9]
   18b2a:	9306      	str	r3, [sp, #24]
   18b2c:	7a23      	ldrb	r3, [r4, #8]
   18b2e:	9307      	str	r3, [sp, #28]
   18b30:	79e3      	ldrb	r3, [r4, #7]
   18b32:	9308      	str	r3, [sp, #32]
   18b34:	79a3      	ldrb	r3, [r4, #6]
   18b36:	9309      	str	r3, [sp, #36]	; 0x24
                       status);
        }
        break;
    case BLE_HCI_LE_SUBEV_ADV_RPT:
        advlen = evdata[9];
        rssi = evdata[10 + advlen];
   18b38:	4428      	add	r0, r5
        BLE_HS_LOG(DEBUG, "LE advertising report. len=%u num=%u evtype=%u "
   18b3a:	950a      	str	r5, [sp, #40]	; 0x28
   18b3c:	f990 300a 	ldrsb.w	r3, [r0, #10]
   18b40:	930b      	str	r3, [sp, #44]	; 0x2c
   18b42:	487a      	ldr	r0, [pc, #488]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18b44:	4b7a      	ldr	r3, [pc, #488]	; (18d30 <host_hci_dbg_event_disp+0x7c8>)
   18b46:	2104      	movs	r1, #4
   18b48:	2200      	movs	r2, #0
   18b4a:	f004 fb6d 	bl	1d228 <log_printf>
                          "addrtype=%u addr=%x.%x.%x.%x.%x.%x advlen=%u "
                          "rssi=%d\n", len, evdata[0], evdata[1], evdata[2],
                   evdata[8], evdata[7], evdata[6], evdata[5],
                   evdata[4], evdata[3], advlen, rssi);
        if (advlen) {
   18b4e:	2d00      	cmp	r5, #0
   18b50:	f000 80e9 	beq.w	18d26 <host_hci_dbg_event_disp+0x7be>
            dptr = &evdata[10];
   18b54:	340d      	adds	r4, #13
            while (advlen > 0) {
                memset(adv_data_buf, 0, 32);
   18b56:	af0c      	add	r7, sp, #48	; 0x30
   18b58:	4638      	mov	r0, r7
   18b5a:	2100      	movs	r1, #0
   18b5c:	2220      	movs	r2, #32
   18b5e:	f7f0 fa58 	bl	9012 <memset>
   18b62:	2d08      	cmp	r5, #8
   18b64:	462e      	mov	r6, r5
   18b66:	bfa8      	it	ge
   18b68:	2608      	movge	r6, #8
   18b6a:	eb04 0906 	add.w	r9, r4, r6
                imax = advlen;
                if (imax > 8) {
                    imax = 8;
                }
                adv_ptr = &adv_data_buf[0];
   18b6e:	46b8      	mov	r8, r7
                for (i = 0; i < imax; ++i) {
                    snprintf(adv_ptr, 4, "%02x ", *dptr);
   18b70:	f814 3b01 	ldrb.w	r3, [r4], #1
   18b74:	4a6f      	ldr	r2, [pc, #444]	; (18d34 <host_hci_dbg_event_disp+0x7cc>)
   18b76:	4640      	mov	r0, r8
   18b78:	2104      	movs	r1, #4
   18b7a:	f7f0 fc6a 	bl	9452 <snprintf>
                imax = advlen;
                if (imax > 8) {
                    imax = 8;
                }
                adv_ptr = &adv_data_buf[0];
                for (i = 0; i < imax; ++i) {
   18b7e:	454c      	cmp	r4, r9
                    snprintf(adv_ptr, 4, "%02x ", *dptr);
                    adv_ptr += 3;
   18b80:	f108 0803 	add.w	r8, r8, #3
                imax = advlen;
                if (imax > 8) {
                    imax = 8;
                }
                adv_ptr = &adv_data_buf[0];
                for (i = 0; i < imax; ++i) {
   18b84:	d1f4      	bne.n	18b70 <host_hci_dbg_event_disp+0x608>
                    snprintf(adv_ptr, 4, "%02x ", *dptr);
                    adv_ptr += 3;
                    ++dptr;
                }
                advlen -= imax;
   18b86:	1bad      	subs	r5, r5, r6
   18b88:	b2ed      	uxtb	r5, r5
                BLE_HS_LOG(DEBUG, "%s\n", adv_data_buf);
   18b8a:	9700      	str	r7, [sp, #0]
   18b8c:	4867      	ldr	r0, [pc, #412]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18b8e:	4b6a      	ldr	r3, [pc, #424]	; (18d38 <host_hci_dbg_event_disp+0x7d0>)
   18b90:	2104      	movs	r1, #4
   18b92:	2200      	movs	r2, #0
   18b94:	f004 fb48 	bl	1d228 <log_printf>
                          "rssi=%d\n", len, evdata[0], evdata[1], evdata[2],
                   evdata[8], evdata[7], evdata[6], evdata[5],
                   evdata[4], evdata[3], advlen, rssi);
        if (advlen) {
            dptr = &evdata[10];
            while (advlen > 0) {
   18b98:	2d00      	cmp	r5, #0
   18b9a:	d1dc      	bne.n	18b56 <host_hci_dbg_event_disp+0x5ee>
   18b9c:	e0c3      	b.n	18d26 <host_hci_dbg_event_disp+0x7be>
                BLE_HS_LOG(DEBUG, "%s\n", adv_data_buf);
            }
        }
        break;
    case BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE:
        status = evdata[0];
   18b9e:	78e5      	ldrb	r5, [r4, #3]
        if (status == BLE_ERR_SUCCESS) {
   18ba0:	b9d5      	cbnz	r5, 18bd8 <host_hci_dbg_event_disp+0x670>
            BLE_HS_LOG(DEBUG, "LE Connection Update Complete. handle=%u "
   18ba2:	1d20      	adds	r0, r4, #4
   18ba4:	f004 fa73 	bl	1d08e <le16toh>
   18ba8:	4680      	mov	r8, r0
   18baa:	1da0      	adds	r0, r4, #6
   18bac:	f004 fa6f 	bl	1d08e <le16toh>
   18bb0:	4607      	mov	r7, r0
   18bb2:	f104 0008 	add.w	r0, r4, #8
   18bb6:	f004 fa6a 	bl	1d08e <le16toh>
   18bba:	4606      	mov	r6, r0
   18bbc:	f104 000a 	add.w	r0, r4, #10
   18bc0:	f004 fa65 	bl	1d08e <le16toh>
   18bc4:	f8cd 8000 	str.w	r8, [sp]
   18bc8:	9003      	str	r0, [sp, #12]
   18bca:	9701      	str	r7, [sp, #4]
   18bcc:	9602      	str	r6, [sp, #8]
   18bce:	4857      	ldr	r0, [pc, #348]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18bd0:	4b5a      	ldr	r3, [pc, #360]	; (18d3c <host_hci_dbg_event_disp+0x7d4>)
   18bd2:	2104      	movs	r1, #4
   18bd4:	462a      	mov	r2, r5
   18bd6:	e081      	b.n	18cdc <host_hci_dbg_event_disp+0x774>
                              "itvl=%u latency=%u timeout=%u\n",
                       le16toh(evdata + 1), le16toh(evdata + 3),
                       le16toh(evdata + 5), le16toh(evdata + 7));
        } else {
            BLE_HS_LOG(DEBUG, "LE Connection Update Complete. FAIL "
   18bd8:	9500      	str	r5, [sp, #0]
   18bda:	4854      	ldr	r0, [pc, #336]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18bdc:	4b58      	ldr	r3, [pc, #352]	; (18d40 <host_hci_dbg_event_disp+0x7d8>)
   18bde:	2104      	movs	r1, #4
   18be0:	2200      	movs	r2, #0
   18be2:	e095      	b.n	18d10 <host_hci_dbg_event_disp+0x7a8>
                              "(status=%u)\n", status);
        }
        break;

    case BLE_HCI_LE_SUBEV_DATA_LEN_CHG:
        BLE_HS_LOG(DEBUG, "LE Data Length Change. handle=%u max_tx_bytes=%u "
   18be4:	f004 fa53 	bl	1d08e <le16toh>
   18be8:	4680      	mov	r8, r0
   18bea:	1d60      	adds	r0, r4, #5
   18bec:	f004 fa4f 	bl	1d08e <le16toh>
   18bf0:	4607      	mov	r7, r0
   18bf2:	1de0      	adds	r0, r4, #7
   18bf4:	f004 fa4b 	bl	1d08e <le16toh>
   18bf8:	4606      	mov	r6, r0
   18bfa:	f104 0009 	add.w	r0, r4, #9
   18bfe:	f004 fa46 	bl	1d08e <le16toh>
   18c02:	4605      	mov	r5, r0
   18c04:	f104 000b 	add.w	r0, r4, #11
   18c08:	f004 fa41 	bl	1d08e <le16toh>
   18c0c:	4b4d      	ldr	r3, [pc, #308]	; (18d44 <host_hci_dbg_event_disp+0x7dc>)
   18c0e:	9004      	str	r0, [sp, #16]
   18c10:	4846      	ldr	r0, [pc, #280]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18c12:	f8cd 8000 	str.w	r8, [sp]
   18c16:	9701      	str	r7, [sp, #4]
   18c18:	9602      	str	r6, [sp, #8]
   18c1a:	9503      	str	r5, [sp, #12]
   18c1c:	2104      	movs	r1, #4
   18c1e:	2200      	movs	r2, #0
   18c20:	f004 fb02 	bl	1d228 <log_printf>
   18c24:	e07f      	b.n	18d26 <host_hci_dbg_event_disp+0x7be>
                   le16toh(evdata), le16toh(evdata + 2),
                   le16toh(evdata + 4), le16toh(evdata + 6),
                   le16toh(evdata + 8));
        break;
    case BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ:
        BLE_HS_LOG(DEBUG, "LE Remote Connection Parameter Request. handle=%u "
   18c26:	f004 fa32 	bl	1d08e <le16toh>
   18c2a:	4680      	mov	r8, r0
   18c2c:	1d60      	adds	r0, r4, #5
   18c2e:	f004 fa2e 	bl	1d08e <le16toh>
   18c32:	4607      	mov	r7, r0
   18c34:	1de0      	adds	r0, r4, #7
   18c36:	f004 fa2a 	bl	1d08e <le16toh>
   18c3a:	4606      	mov	r6, r0
   18c3c:	f104 0009 	add.w	r0, r4, #9
   18c40:	f004 fa25 	bl	1d08e <le16toh>
   18c44:	4605      	mov	r5, r0
   18c46:	f104 000b 	add.w	r0, r4, #11
   18c4a:	f004 fa20 	bl	1d08e <le16toh>
   18c4e:	f8cd 8000 	str.w	r8, [sp]
   18c52:	9004      	str	r0, [sp, #16]
   18c54:	9701      	str	r7, [sp, #4]
   18c56:	9602      	str	r6, [sp, #8]
   18c58:	9503      	str	r5, [sp, #12]
   18c5a:	4834      	ldr	r0, [pc, #208]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18c5c:	4b3a      	ldr	r3, [pc, #232]	; (18d48 <host_hci_dbg_event_disp+0x7e0>)
   18c5e:	2104      	movs	r1, #4
   18c60:	2200      	movs	r2, #0
   18c62:	e7dd      	b.n	18c20 <host_hci_dbg_event_disp+0x6b8>
                   le16toh(evdata + 4), le16toh(evdata + 6),
                   le16toh(evdata + 8));
        break;

    case BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT:
        status = evdata[0];
   18c64:	78e5      	ldrb	r5, [r4, #3]
        if (status == BLE_ERR_SUCCESS) {
   18c66:	b9dd      	cbnz	r5, 18ca0 <host_hci_dbg_event_disp+0x738>
            BLE_HS_LOG(DEBUG, "LE Remote Used Features. handle=%u feat=",
   18c68:	1d20      	adds	r0, r4, #4
   18c6a:	f004 fa10 	bl	1d08e <le16toh>
   18c6e:	462a      	mov	r2, r5
   18c70:	9000      	str	r0, [sp, #0]
   18c72:	2104      	movs	r1, #4
   18c74:	482d      	ldr	r0, [pc, #180]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18c76:	4b35      	ldr	r3, [pc, #212]	; (18d4c <host_hci_dbg_event_disp+0x7e4>)
   18c78:	f004 fad6 	bl	1d228 <log_printf>
   18c7c:	1d65      	adds	r5, r4, #5
   18c7e:	340d      	adds	r4, #13
                       le16toh(evdata + 1));
            for (i = 0; i < BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN; ++i) {
                BLE_HS_LOG(DEBUG, "%02x ", evdata[3 + i]);
   18c80:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   18c84:	9300      	str	r3, [sp, #0]
   18c86:	4829      	ldr	r0, [pc, #164]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18c88:	4b2a      	ldr	r3, [pc, #168]	; (18d34 <host_hci_dbg_event_disp+0x7cc>)
   18c8a:	2104      	movs	r1, #4
   18c8c:	2200      	movs	r2, #0
   18c8e:	f004 facb 	bl	1d228 <log_printf>
    case BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT:
        status = evdata[0];
        if (status == BLE_ERR_SUCCESS) {
            BLE_HS_LOG(DEBUG, "LE Remote Used Features. handle=%u feat=",
                       le16toh(evdata + 1));
            for (i = 0; i < BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN; ++i) {
   18c92:	42a5      	cmp	r5, r4
   18c94:	d1f4      	bne.n	18c80 <host_hci_dbg_event_disp+0x718>
                BLE_HS_LOG(DEBUG, "%02x ", evdata[3 + i]);
            }
            BLE_HS_LOG(DEBUG, "\n");
   18c96:	4825      	ldr	r0, [pc, #148]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18c98:	4b2d      	ldr	r3, [pc, #180]	; (18d50 <host_hci_dbg_event_disp+0x7e8>)
   18c9a:	2104      	movs	r1, #4
   18c9c:	2200      	movs	r2, #0
   18c9e:	e024      	b.n	18cea <host_hci_dbg_event_disp+0x782>
        } else {
            BLE_HS_LOG(DEBUG, "LE Remote Used Features. FAIL (status=%u)\n",
   18ca0:	9500      	str	r5, [sp, #0]
   18ca2:	4822      	ldr	r0, [pc, #136]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18ca4:	4b2b      	ldr	r3, [pc, #172]	; (18d54 <host_hci_dbg_event_disp+0x7ec>)
   18ca6:	2104      	movs	r1, #4
   18ca8:	2200      	movs	r2, #0
   18caa:	e031      	b.n	18d10 <host_hci_dbg_event_disp+0x7a8>
                       status);
        }
        break;

    case BLE_HCI_LE_SUBEV_LT_KEY_REQ:
            BLE_HS_LOG(DEBUG, "LE LTK Req. handle=%u rand=%lx%lx encdiv=%u\n",
   18cac:	f004 f9ef 	bl	1d08e <le16toh>
   18cb0:	4607      	mov	r7, r0
   18cb2:	f104 0009 	add.w	r0, r4, #9
   18cb6:	f004 f9ef 	bl	1d098 <le32toh>
   18cba:	4606      	mov	r6, r0
   18cbc:	1d60      	adds	r0, r4, #5
   18cbe:	f004 f9eb 	bl	1d098 <le32toh>
   18cc2:	4605      	mov	r5, r0
   18cc4:	f104 000d 	add.w	r0, r4, #13
   18cc8:	f004 f9e1 	bl	1d08e <le16toh>
   18ccc:	4b22      	ldr	r3, [pc, #136]	; (18d58 <host_hci_dbg_event_disp+0x7f0>)
   18cce:	9003      	str	r0, [sp, #12]
   18cd0:	4816      	ldr	r0, [pc, #88]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18cd2:	9700      	str	r7, [sp, #0]
   18cd4:	9601      	str	r6, [sp, #4]
   18cd6:	9502      	str	r5, [sp, #8]
   18cd8:	2104      	movs	r1, #4
   18cda:	2200      	movs	r2, #0
   18cdc:	f004 faa4 	bl	1d228 <log_printf>
   18ce0:	e021      	b.n	18d26 <host_hci_dbg_event_disp+0x7be>
                       le16toh(evdata), le32toh(evdata + 6),
                       le32toh(evdata + 2), le16toh(evdata + 10));
        break;

    default:
        BLE_HS_LOG(DEBUG, "\tUnknown LE event\n");
   18ce2:	4812      	ldr	r0, [pc, #72]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18ce4:	4b1d      	ldr	r3, [pc, #116]	; (18d5c <host_hci_dbg_event_disp+0x7f4>)
   18ce6:	2104      	movs	r1, #4
   18ce8:	2200      	movs	r2, #0
   18cea:	f004 fa9d 	bl	1d228 <log_printf>
   18cee:	e01a      	b.n	18d26 <host_hci_dbg_event_disp+0x7be>
static void
host_hci_dbg_auth_pyld_tmo_disp(uint8_t *evdata, uint8_t len)
{
    uint16_t handle;

    if (len != sizeof(uint16_t)) {
   18cf0:	2e02      	cmp	r6, #2
   18cf2:	d005      	beq.n	18d00 <host_hci_dbg_event_disp+0x798>
        BLE_HS_LOG(DEBUG, "ERR: AuthPyldTmoEvent bad length %u\n", len);
   18cf4:	9600      	str	r6, [sp, #0]
   18cf6:	480d      	ldr	r0, [pc, #52]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18cf8:	4b19      	ldr	r3, [pc, #100]	; (18d60 <host_hci_dbg_event_disp+0x7f8>)
   18cfa:	2104      	movs	r1, #4
   18cfc:	2200      	movs	r2, #0
   18cfe:	e007      	b.n	18d10 <host_hci_dbg_event_disp+0x7a8>
        return;

    }

    handle = le16toh(evdata);
   18d00:	3002      	adds	r0, #2
   18d02:	f004 f9c4 	bl	1d08e <le16toh>
    BLE_HS_LOG(DEBUG, "AuthPyldTmo: handle=%u\n", handle);
   18d06:	4b17      	ldr	r3, [pc, #92]	; (18d64 <host_hci_dbg_event_disp+0x7fc>)
   18d08:	9000      	str	r0, [sp, #0]
   18d0a:	4808      	ldr	r0, [pc, #32]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18d0c:	2104      	movs	r1, #4
   18d0e:	2200      	movs	r2, #0
   18d10:	f004 fa8a 	bl	1d228 <log_printf>
   18d14:	e007      	b.n	18d26 <host_hci_dbg_event_disp+0x7be>
        break;
    case BLE_HCI_EVCODE_AUTH_PYLD_TMO:
        host_hci_dbg_auth_pyld_tmo_disp(evdata, len);
        break;
    default:
        BLE_HS_LOG(DEBUG, "Unknown event 0x%x len=%u\n", evcode, len);
   18d16:	e88d 0048 	stmia.w	sp, {r3, r6}
   18d1a:	4804      	ldr	r0, [pc, #16]	; (18d2c <host_hci_dbg_event_disp+0x7c4>)
   18d1c:	4b12      	ldr	r3, [pc, #72]	; (18d68 <host_hci_dbg_event_disp+0x800>)
   18d1e:	2104      	movs	r1, #4
   18d20:	2200      	movs	r2, #0
   18d22:	f004 fa81 	bl	1d228 <log_printf>
        break;
    }
}
   18d26:	b015      	add	sp, #84	; 0x54
   18d28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   18d2c:	20003b9c 	.word	0x20003b9c
   18d30:	00020352 	.word	0x00020352
   18d34:	0001fa89 	.word	0x0001fa89
   18d38:	000203b7 	.word	0x000203b7
   18d3c:	000203bb 	.word	0x000203bb
   18d40:	00020403 	.word	0x00020403
   18d44:	00020434 	.word	0x00020434
   18d48:	00020494 	.word	0x00020494
   18d4c:	000204f5 	.word	0x000204f5
   18d50:	0001fdec 	.word	0x0001fdec
   18d54:	0002051e 	.word	0x0002051e
   18d58:	00020549 	.word	0x00020549
   18d5c:	00020576 	.word	0x00020576
   18d60:	00020589 	.word	0x00020589
   18d64:	000205ae 	.word	0x000205ae
   18d68:	000205c6 	.word	0x000205c6

00018d6c <host_hci_rx_le_adv_rpt>:
    return 0;
}

static int
host_hci_rx_le_adv_rpt(uint8_t subevent, uint8_t *data, int len)
{
   18d6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t num_reports;
    int data_len;
    int off;
    int i;

    if (len < BLE_HCI_LE_ADV_RPT_MIN_LEN) {
   18d70:	2a0b      	cmp	r2, #11
    return 0;
}

static int
host_hci_rx_le_adv_rpt(uint8_t subevent, uint8_t *data, int len)
{
   18d72:	b089      	sub	sp, #36	; 0x24
   18d74:	4689      	mov	r9, r1
    uint8_t num_reports;
    int data_len;
    int off;
    int i;

    if (len < BLE_HCI_LE_ADV_RPT_MIN_LEN) {
   18d76:	dd59      	ble.n	18e2c <host_hci_rx_le_adv_rpt+0xc0>
        return BLE_HS_ECONTROLLER;
    }

    num_reports = data[1];
   18d78:	f891 8001 	ldrb.w	r8, [r1, #1]
    if (num_reports < BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN ||
   18d7c:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   18d80:	2b18      	cmp	r3, #24
   18d82:	d851      	bhi.n	18e28 <host_hci_rx_le_adv_rpt+0xbc>

    off = 2 +       /* Subevent code and num reports. */
          (1 +      /* Event type. */
           1 +      /* Address type. */
           6        /* Address. */
          ) * num_reports;
   18d84:	fa0f f488 	sxth.w	r4, r8
   18d88:	00e0      	lsls	r0, r4, #3
        num_reports > BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX) {

        return BLE_HS_EBADDATA;
    }

    off = 2 +       /* Subevent code and num reports. */
   18d8a:	1c86      	adds	r6, r0, #2
          (1 +      /* Event type. */
           1 +      /* Address type. */
           6        /* Address. */
          ) * num_reports;
    if (off + num_reports >= len) {
   18d8c:	eb06 0108 	add.w	r1, r6, r8
   18d90:	4291      	cmp	r1, r2
   18d92:	da4b      	bge.n	18e2c <host_hci_rx_le_adv_rpt+0xc0>
   18d94:	2300      	movs	r3, #0
   18d96:	461e      	mov	r6, r3
   18d98:	eb09 0700 	add.w	r7, r9, r0
   18d9c:	18fd      	adds	r5, r7, r3
        return BLE_HS_ECONTROLLER;
    }

    data_len = 0;
    for (i = 0; i < num_reports; i++) {
   18d9e:	3301      	adds	r3, #1
        data_len += data[off];
   18da0:	78ad      	ldrb	r5, [r5, #2]
    if (off + num_reports >= len) {
        return BLE_HS_ECONTROLLER;
    }

    data_len = 0;
    for (i = 0; i < num_reports; i++) {
   18da2:	4543      	cmp	r3, r8
        data_len += data[off];
   18da4:	442e      	add	r6, r5
    if (off + num_reports >= len) {
        return BLE_HS_ECONTROLLER;
    }

    data_len = 0;
    for (i = 0; i < num_reports; i++) {
   18da6:	dbf7      	blt.n	18d98 <host_hci_rx_le_adv_rpt+0x2c>
        data_len += data[off];
        off++;
    }

    off += data_len;
   18da8:	440e      	add	r6, r1

    /* Check if RSSI fields fit in the packet. */
    if (off + num_reports > len) {
   18daa:	eb06 0308 	add.w	r3, r6, r8
   18dae:	4293      	cmp	r3, r2
   18db0:	dc3c      	bgt.n	18e2c <host_hci_rx_le_adv_rpt+0xc0>
    if (rc != 0) {
        return rc;
    }

    /* Direct address fields not present in a standard advertising report. */
    desc.direct_addr_type = BLE_GAP_ADDR_TYPE_NONE;
   18db2:	23fe      	movs	r3, #254	; 0xfe
    memset(desc.direct_addr, 0, sizeof desc.direct_addr);
   18db4:	f10d 0019 	add.w	r0, sp, #25
   18db8:	2100      	movs	r1, #0
   18dba:	2206      	movs	r2, #6
    if (rc != 0) {
        return rc;
    }

    /* Direct address fields not present in a standard advertising report. */
    desc.direct_addr_type = BLE_GAP_ADDR_TYPE_NONE;
   18dbc:	f88d 3018 	strb.w	r3, [sp, #24]

        off = 2 + suboff * num_reports + i;
        desc.addr_type = data[off];
        suboff++;

        off = 2 + suboff * num_reports + i * 6;
   18dc0:	ea4f 0a44 	mov.w	sl, r4, lsl #1
        return rc;
    }

    /* Direct address fields not present in a standard advertising report. */
    desc.direct_addr_type = BLE_GAP_ADDR_TYPE_NONE;
    memset(desc.direct_addr, 0, sizeof desc.direct_addr);
   18dc4:	f7f0 f925 	bl	9012 <memset>

        off = 2 + suboff * num_reports + i;
        desc.length_data = data[off];
        suboff++;

        off = 2 + suboff * num_reports + data_off;
   18dc8:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   18dcc:	1ca5      	adds	r5, r4, #2
    /* Direct address fields not present in a standard advertising report. */
    desc.direct_addr_type = BLE_GAP_ADDR_TYPE_NONE;
    memset(desc.direct_addr, 0, sizeof desc.direct_addr);

    data_off = 0;
    for (i = 0; i < num_reports; i++) {
   18dce:	2400      	movs	r4, #0

    /* Direct address fields not present in a standard advertising report. */
    desc.direct_addr_type = BLE_GAP_ADDR_TYPE_NONE;
    memset(desc.direct_addr, 0, sizeof desc.direct_addr);

    data_off = 0;
   18dd0:	46a3      	mov	fp, r4
   18dd2:	eb09 0304 	add.w	r3, r9, r4
    for (i = 0; i < num_reports; i++) {
        suboff = 0;

        off = 2 + suboff * num_reports + i;
        desc.event_type = data[off];
   18dd6:	789b      	ldrb	r3, [r3, #2]
   18dd8:	f88d 3004 	strb.w	r3, [sp, #4]
   18ddc:	eb04 0308 	add.w	r3, r4, r8
   18de0:	444b      	add	r3, r9
        suboff++;

        off = 2 + suboff * num_reports + i;
        desc.addr_type = data[off];
   18de2:	789b      	ldrb	r3, [r3, #2]
   18de4:	f88d 3005 	strb.w	r3, [sp, #5]
   18de8:	2306      	movs	r3, #6
   18dea:	fb03 a304 	mla	r3, r3, r4, sl
        suboff++;

        off = 2 + suboff * num_reports + i * 6;
        memcpy(desc.addr, data + off, 6);
   18dee:	444b      	add	r3, r9
   18df0:	f853 0f02 	ldr.w	r0, [r3, #2]!
   18df4:	9002      	str	r0, [sp, #8]
   18df6:	889b      	ldrh	r3, [r3, #4]
   18df8:	f8ad 300c 	strh.w	r3, [sp, #12]
   18dfc:	193b      	adds	r3, r7, r4
        data_off += desc.length_data;

        off = rssi_off + 1 * i;
        desc.rssi = data[off];

        ble_gap_rx_adv_report(&desc);
   18dfe:	a801      	add	r0, sp, #4
        off = 2 + suboff * num_reports + i * 6;
        memcpy(desc.addr, data + off, 6);
        suboff += 6;

        off = 2 + suboff * num_reports + i;
        desc.length_data = data[off];
   18e00:	789a      	ldrb	r2, [r3, #2]
   18e02:	f88d 2006 	strb.w	r2, [sp, #6]
        suboff++;

        off = 2 + suboff * num_reports + data_off;
   18e06:	eb05 030b 	add.w	r3, r5, fp
        desc.data = data + off;
   18e0a:	444b      	add	r3, r9
   18e0c:	9304      	str	r3, [sp, #16]
   18e0e:	eb09 0306 	add.w	r3, r9, r6
        data_off += desc.length_data;
   18e12:	4493      	add	fp, r2

        off = rssi_off + 1 * i;
        desc.rssi = data[off];
   18e14:	5d1b      	ldrb	r3, [r3, r4]
   18e16:	f88d 3007 	strb.w	r3, [sp, #7]
    /* Direct address fields not present in a standard advertising report. */
    desc.direct_addr_type = BLE_GAP_ADDR_TYPE_NONE;
    memset(desc.direct_addr, 0, sizeof desc.direct_addr);

    data_off = 0;
    for (i = 0; i < num_reports; i++) {
   18e1a:	3401      	adds	r4, #1
        data_off += desc.length_data;

        off = rssi_off + 1 * i;
        desc.rssi = data[off];

        ble_gap_rx_adv_report(&desc);
   18e1c:	f7f8 fe1c 	bl	11a58 <ble_gap_rx_adv_report>
    /* Direct address fields not present in a standard advertising report. */
    desc.direct_addr_type = BLE_GAP_ADDR_TYPE_NONE;
    memset(desc.direct_addr, 0, sizeof desc.direct_addr);

    data_off = 0;
    for (i = 0; i < num_reports; i++) {
   18e20:	4544      	cmp	r4, r8
   18e22:	dbd6      	blt.n	18dd2 <host_hci_rx_le_adv_rpt+0x66>
        desc.rssi = data[off];

        ble_gap_rx_adv_report(&desc);
    }

    return 0;
   18e24:	2000      	movs	r0, #0
   18e26:	e002      	b.n	18e2e <host_hci_rx_le_adv_rpt+0xc2>

    num_reports = data[1];
    if (num_reports < BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN ||
        num_reports > BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX) {

        return BLE_HS_EBADDATA;
   18e28:	200a      	movs	r0, #10
   18e2a:	e000      	b.n	18e2e <host_hci_rx_le_adv_rpt+0xc2>
    int data_len;
    int off;
    int i;

    if (len < BLE_HCI_LE_ADV_RPT_MIN_LEN) {
        return BLE_HS_ECONTROLLER;
   18e2c:	200c      	movs	r0, #12

        ble_gap_rx_adv_report(&desc);
    }

    return 0;
}
   18e2e:	b009      	add	sp, #36	; 0x24
   18e30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00018e34 <host_hci_rx_le_meta>:
{
    const struct host_hci_le_event_dispatch_entry *entry;
    uint8_t subevent;
    int rc;

    if (len < BLE_HCI_EVENT_HDR_LEN + BLE_HCI_LE_MIN_LEN) {
   18e34:	2a02      	cmp	r2, #2
    return 0;
}

static int
host_hci_rx_le_meta(uint8_t event_code, uint8_t *data, int len)
{
   18e36:	b530      	push	{r4, r5, lr}
    const struct host_hci_le_event_dispatch_entry *entry;
    uint8_t subevent;
    int rc;

    if (len < BLE_HCI_EVENT_HDR_LEN + BLE_HCI_LE_MIN_LEN) {
   18e38:	dd13      	ble.n	18e62 <host_hci_rx_le_meta+0x2e>
        /* XXX: Increment stat. */
        return BLE_HS_ECONTROLLER;
    }

    subevent = data[2];
   18e3a:	7888      	ldrb	r0, [r1, #2]
   18e3c:	2300      	movs	r3, #0
   18e3e:	4c0a      	ldr	r4, [pc, #40]	; (18e68 <host_hci_rx_le_meta+0x34>)
   18e40:	18e5      	adds	r5, r4, r3
   18e42:	3308      	adds	r3, #8
   18e44:	441c      	add	r4, r3
    const struct host_hci_le_event_dispatch_entry *entry;
    int i;

    for (i = 0; i < HOST_HCI_LE_EVENT_DISPATCH_SZ; i++) {
        entry = host_hci_le_event_dispatch + i;
        if (entry->hmd_subevent == event_code) {
   18e46:	f814 4c08 	ldrb.w	r4, [r4, #-8]
   18e4a:	4284      	cmp	r4, r0
   18e4c:	d105      	bne.n	18e5a <host_hci_rx_le_meta+0x26>
    }

    subevent = data[2];
    entry = host_hci_le_dispatch_entry_find(subevent);
    if (entry != NULL) {
        rc = entry->hmd_fn(subevent, data + BLE_HCI_EVENT_HDR_LEN,
   18e4e:	686b      	ldr	r3, [r5, #4]
   18e50:	3102      	adds	r1, #2
   18e52:	3a02      	subs	r2, #2
            return rc;
        }
    }

    return 0;
}
   18e54:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    }

    subevent = data[2];
    entry = host_hci_le_dispatch_entry_find(subevent);
    if (entry != NULL) {
        rc = entry->hmd_fn(subevent, data + BLE_HCI_EVENT_HDR_LEN,
   18e58:	4718      	bx	r3
host_hci_le_dispatch_entry_find(uint8_t event_code)
{
    const struct host_hci_le_event_dispatch_entry *entry;
    int i;

    for (i = 0; i < HOST_HCI_LE_EVENT_DISPATCH_SZ; i++) {
   18e5a:	2b38      	cmp	r3, #56	; 0x38
   18e5c:	d1ef      	bne.n	18e3e <host_hci_rx_le_meta+0xa>
        if (rc != 0) {
            return rc;
        }
    }

    return 0;
   18e5e:	2000      	movs	r0, #0
   18e60:	bd30      	pop	{r4, r5, pc}
    uint8_t subevent;
    int rc;

    if (len < BLE_HCI_EVENT_HDR_LEN + BLE_HCI_LE_MIN_LEN) {
        /* XXX: Increment stat. */
        return BLE_HS_ECONTROLLER;
   18e62:	200c      	movs	r0, #12
            return rc;
        }
    }

    return 0;
}
   18e64:	bd30      	pop	{r4, r5, pc}
   18e66:	bf00      	nop
   18e68:	00020650 	.word	0x00020650

00018e6c <host_hci_rx_le_dir_adv_rpt>:
    return 0;
}

static int
host_hci_rx_le_dir_adv_rpt(uint8_t subevent, uint8_t *data, int len)
{
   18e6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint8_t num_reports;
    int suboff;
    int off;
    int i;

    if (len < BLE_HCI_LE_ADV_DIRECT_RPT_LEN) {
   18e70:	2a11      	cmp	r2, #17
    return 0;
}

static int
host_hci_rx_le_dir_adv_rpt(uint8_t subevent, uint8_t *data, int len)
{
   18e72:	b089      	sub	sp, #36	; 0x24
   18e74:	460e      	mov	r6, r1
    uint8_t num_reports;
    int suboff;
    int off;
    int i;

    if (len < BLE_HCI_LE_ADV_DIRECT_RPT_LEN) {
   18e76:	dd3f      	ble.n	18ef8 <host_hci_rx_le_dir_adv_rpt+0x8c>
        return BLE_HS_ECONTROLLER;
    }

    num_reports = data[1];
   18e78:	784f      	ldrb	r7, [r1, #1]
    if (len != 2 + num_reports * BLE_HCI_LE_ADV_DIRECT_RPT_SUB_LEN) {
   18e7a:	2302      	movs	r3, #2
   18e7c:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   18e80:	429a      	cmp	r2, r3
   18e82:	d139      	bne.n	18ef8 <host_hci_rx_le_dir_adv_rpt+0x8c>
        return BLE_HS_ECONTROLLER;
    }

    /* Data fields not present in a direct advertising report. */
    desc.data = NULL;
   18e84:	2300      	movs	r3, #0

        off = 2 + suboff * num_reports + i;
        desc.addr_type = data[off];
        suboff++;

        off = 2 + suboff * num_reports + i * 6;
   18e86:	b23d      	sxth	r5, r7
    if (len != 2 + num_reports * BLE_HCI_LE_ADV_DIRECT_RPT_SUB_LEN) {
        return BLE_HS_ECONTROLLER;
    }

    /* Data fields not present in a direct advertising report. */
    desc.data = NULL;
   18e88:	9304      	str	r3, [sp, #16]
    desc.fields = NULL;
   18e8a:	9305      	str	r3, [sp, #20]

        off = 2 + suboff * num_reports + i;
        desc.addr_type = data[off];
        suboff++;

        off = 2 + suboff * num_reports + i * 6;
   18e8c:	ea4f 0845 	mov.w	r8, r5, lsl #1
        memcpy(desc.addr, data + off, 6);
        suboff += 6;

        off = 2 + suboff * num_reports + i;
   18e90:	ea4f 09c5 	mov.w	r9, r5, lsl #3

        off = 2 + suboff * num_reports + i * 6;
        memcpy(desc.direct_addr, data + off, 6);
        suboff += 6;

        off = 2 + suboff * num_reports + i;
   18e94:	2301      	movs	r3, #1
   18e96:	ebc5 1505 	rsb	r5, r5, r5, lsl #4
   18e9a:	1c5c      	adds	r4, r3, #1
   18e9c:	3b01      	subs	r3, #1

    /* Data fields not present in a direct advertising report. */
    desc.data = NULL;
    desc.fields = NULL;

    for (i = 0; i < num_reports; i++) {
   18e9e:	42bb      	cmp	r3, r7
   18ea0:	da28      	bge.n	18ef4 <host_hci_rx_le_dir_adv_rpt+0x88>
        suboff = 0;

        off = 2 + suboff * num_reports + i;
        desc.event_type = data[off];
   18ea2:	5d33      	ldrb	r3, [r6, r4]
   18ea4:	f88d 3004 	strb.w	r3, [sp, #4]
   18ea8:	19f3      	adds	r3, r6, r7
   18eaa:	2206      	movs	r2, #6
        suboff++;

        off = 2 + suboff * num_reports + i;
        desc.addr_type = data[off];
   18eac:	5d1b      	ldrb	r3, [r3, r4]
   18eae:	f88d 3005 	strb.w	r3, [sp, #5]
   18eb2:	4362      	muls	r2, r4
   18eb4:	eb02 0308 	add.w	r3, r2, r8
        suboff++;

        off = 2 + suboff * num_reports + i * 6;
        memcpy(desc.addr, data + off, 6);
   18eb8:	4433      	add	r3, r6
   18eba:	443a      	add	r2, r7
   18ebc:	f853 0d0a 	ldr.w	r0, [r3, #-10]!
   18ec0:	9002      	str	r0, [sp, #8]
   18ec2:	889b      	ldrh	r3, [r3, #4]
   18ec4:	f8ad 300c 	strh.w	r3, [sp, #12]
   18ec8:	eb06 0309 	add.w	r3, r6, r9

        off = 2 + suboff * num_reports + i;
        desc.rssi = data[off];
        suboff++;

        ble_gap_rx_adv_report(&desc);
   18ecc:	a801      	add	r0, sp, #4
        off = 2 + suboff * num_reports + i * 6;
        memcpy(desc.addr, data + off, 6);
        suboff += 6;

        off = 2 + suboff * num_reports + i;
        desc.direct_addr_type = data[off];
   18ece:	5d19      	ldrb	r1, [r3, r4]
   18ed0:	f88d 1018 	strb.w	r1, [sp, #24]
        suboff++;

        off = 2 + suboff * num_reports + i * 6;
        memcpy(desc.direct_addr, data + off, 6);
   18ed4:	4413      	add	r3, r2
   18ed6:	f853 2d0a 	ldr.w	r2, [r3, #-10]!
   18eda:	f8cd 2019 	str.w	r2, [sp, #25]
   18ede:	889b      	ldrh	r3, [r3, #4]
   18ee0:	f8ad 301d 	strh.w	r3, [sp, #29]
   18ee4:	1973      	adds	r3, r6, r5
        suboff += 6;

        off = 2 + suboff * num_reports + i;
        desc.rssi = data[off];
   18ee6:	5d1b      	ldrb	r3, [r3, r4]
   18ee8:	f88d 3007 	strb.w	r3, [sp, #7]
        suboff++;

        ble_gap_rx_adv_report(&desc);
   18eec:	f7f8 fdb4 	bl	11a58 <ble_gap_rx_adv_report>
   18ef0:	4623      	mov	r3, r4
   18ef2:	e7d2      	b.n	18e9a <host_hci_rx_le_dir_adv_rpt+0x2e>
    }

    return 0;
   18ef4:	2000      	movs	r0, #0
   18ef6:	e000      	b.n	18efa <host_hci_rx_le_dir_adv_rpt+0x8e>
    int suboff;
    int off;
    int i;

    if (len < BLE_HCI_LE_ADV_DIRECT_RPT_LEN) {
        return BLE_HS_ECONTROLLER;
   18ef8:	200c      	movs	r0, #12

        ble_gap_rx_adv_report(&desc);
    }

    return 0;
}
   18efa:	b009      	add	sp, #36	; 0x24
   18efc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00018f00 <host_hci_rx_num_completed_pkts>:
    uint16_t handle;
    uint8_t num_handles;
    int off;
    int i;

    if (len < BLE_HCI_EVENT_HDR_LEN + BLE_HCI_EVENT_NUM_COMP_PKTS_HDR_LEN) {
   18f00:	2a02      	cmp	r2, #2
    return 0;
}

static int
host_hci_rx_num_completed_pkts(uint8_t event_code, uint8_t *data, int len)
{
   18f02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint16_t handle;
    uint8_t num_handles;
    int off;
    int i;

    if (len < BLE_HCI_EVENT_HDR_LEN + BLE_HCI_EVENT_NUM_COMP_PKTS_HDR_LEN) {
   18f04:	dd15      	ble.n	18f32 <host_hci_rx_num_completed_pkts+0x32>
        return BLE_HS_ECONTROLLER;
    }

    off = BLE_HCI_EVENT_HDR_LEN;
    num_handles = data[off];
   18f06:	788e      	ldrb	r6, [r1, #2]
    if (len < BLE_HCI_EVENT_NUM_COMP_PKTS_HDR_LEN +
   18f08:	ebb2 0f86 	cmp.w	r2, r6, lsl #2
   18f0c:	dd11      	ble.n	18f32 <host_hci_rx_num_completed_pkts+0x32>
    }
    off++;

    for (i = 0; i < num_handles; i++) {
        handle = le16toh(data + off + 2 * i);
        num_pkts = le16toh(data + off + 2 * num_handles + 2 * i);
   18f0e:	2702      	movs	r7, #2
   18f10:	1ccd      	adds	r5, r1, #3
   18f12:	fb07 1106 	mla	r1, r7, r6, r1
   18f16:	1ccc      	adds	r4, r1, #3
              num_handles * BLE_HCI_EVENT_NUM_COMP_PKTS_ENT_LEN) {
        return BLE_HS_ECONTROLLER;
    }
    off++;

    for (i = 0; i < num_handles; i++) {
   18f18:	42a5      	cmp	r5, r4
   18f1a:	d008      	beq.n	18f2e <host_hci_rx_num_completed_pkts+0x2e>
        handle = le16toh(data + off + 2 * i);
   18f1c:	4628      	mov	r0, r5
   18f1e:	f004 f8b6 	bl	1d08e <le16toh>
        num_pkts = le16toh(data + off + 2 * num_handles + 2 * i);
   18f22:	fb07 5006 	mla	r0, r7, r6, r5
   18f26:	f004 f8b2 	bl	1d08e <le16toh>
   18f2a:	3502      	adds	r5, #2
   18f2c:	e7f4      	b.n	18f18 <host_hci_rx_num_completed_pkts+0x18>
        /* XXX: Do something with these values. */
        (void)handle;
        (void)num_pkts;
    }

    return 0;
   18f2e:	2000      	movs	r0, #0
   18f30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint8_t num_handles;
    int off;
    int i;

    if (len < BLE_HCI_EVENT_HDR_LEN + BLE_HCI_EVENT_NUM_COMP_PKTS_HDR_LEN) {
        return BLE_HS_ECONTROLLER;
   18f32:	200c      	movs	r0, #12
        (void)handle;
        (void)num_pkts;
    }

    return 0;
}
   18f34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00018f36 <host_hci_rx_le_conn_parm_req>:
static int
host_hci_rx_le_conn_parm_req(uint8_t subevent, uint8_t *data, int len)
{
    struct hci_le_conn_param_req evt;

    if (len < BLE_HCI_LE_REM_CONN_PARM_REQ_LEN) {
   18f36:	2a0a      	cmp	r2, #10
    return 0;
}

static int
host_hci_rx_le_conn_parm_req(uint8_t subevent, uint8_t *data, int len)
{
   18f38:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   18f3a:	460c      	mov	r4, r1
    struct hci_le_conn_param_req evt;

    if (len < BLE_HCI_LE_REM_CONN_PARM_REQ_LEN) {
   18f3c:	dd3a      	ble.n	18fb4 <host_hci_rx_le_conn_parm_req+0x7e>
        return BLE_HS_ECONTROLLER;
    }

    evt.subevent_code = data[0];
   18f3e:	4608      	mov	r0, r1
   18f40:	f810 3b01 	ldrb.w	r3, [r0], #1
   18f44:	f88d 3004 	strb.w	r3, [sp, #4]
    evt.connection_handle = le16toh(data + 1);
   18f48:	f004 f8a1 	bl	1d08e <le16toh>
   18f4c:	f8ad 0006 	strh.w	r0, [sp, #6]
    evt.itvl_min = le16toh(data + 3);
   18f50:	1ce0      	adds	r0, r4, #3
   18f52:	f004 f89c 	bl	1d08e <le16toh>
   18f56:	f8ad 0008 	strh.w	r0, [sp, #8]
    evt.itvl_max = le16toh(data + 5);
   18f5a:	1d60      	adds	r0, r4, #5
   18f5c:	f004 f897 	bl	1d08e <le16toh>
   18f60:	f8ad 000a 	strh.w	r0, [sp, #10]
    evt.latency = le16toh(data + 7);
   18f64:	1de0      	adds	r0, r4, #7
   18f66:	f004 f892 	bl	1d08e <le16toh>
   18f6a:	f8ad 000c 	strh.w	r0, [sp, #12]
    evt.timeout = le16toh(data + 9);
   18f6e:	f104 0009 	add.w	r0, r4, #9
   18f72:	f004 f88c 	bl	1d08e <le16toh>

    if (evt.itvl_min < BLE_HCI_CONN_ITVL_MIN ||
   18f76:	f8bd 2008 	ldrh.w	r2, [sp, #8]
    evt.subevent_code = data[0];
    evt.connection_handle = le16toh(data + 1);
    evt.itvl_min = le16toh(data + 3);
    evt.itvl_max = le16toh(data + 5);
    evt.latency = le16toh(data + 7);
    evt.timeout = le16toh(data + 9);
   18f7a:	f8ad 000e 	strh.w	r0, [sp, #14]

    if (evt.itvl_min < BLE_HCI_CONN_ITVL_MIN ||
   18f7e:	2a05      	cmp	r2, #5
   18f80:	d916      	bls.n	18fb0 <host_hci_rx_le_conn_parm_req+0x7a>
        evt.itvl_max > BLE_HCI_CONN_ITVL_MAX ||
   18f82:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    evt.itvl_min = le16toh(data + 3);
    evt.itvl_max = le16toh(data + 5);
    evt.latency = le16toh(data + 7);
    evt.timeout = le16toh(data + 9);

    if (evt.itvl_min < BLE_HCI_CONN_ITVL_MIN ||
   18f86:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   18f8a:	d811      	bhi.n	18fb0 <host_hci_rx_le_conn_parm_req+0x7a>
        evt.itvl_max > BLE_HCI_CONN_ITVL_MAX ||
   18f8c:	429a      	cmp	r2, r3
   18f8e:	d80f      	bhi.n	18fb0 <host_hci_rx_le_conn_parm_req+0x7a>
        evt.itvl_min > evt.itvl_max) {

        return BLE_HS_EBADDATA;
    }
    if (evt.latency < BLE_HCI_CONN_LATENCY_MIN ||
   18f90:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   18f94:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   18f98:	d20a      	bcs.n	18fb0 <host_hci_rx_le_conn_parm_req+0x7a>
        evt.latency > BLE_HCI_CONN_LATENCY_MAX) {

        return BLE_HS_EBADDATA;
    }
    if (evt.timeout < BLE_HCI_CONN_SPVN_TIMEOUT_MIN ||
   18f9a:	380a      	subs	r0, #10
   18f9c:	b280      	uxth	r0, r0
   18f9e:	f640 4376 	movw	r3, #3190	; 0xc76
   18fa2:	4298      	cmp	r0, r3
   18fa4:	d804      	bhi.n	18fb0 <host_hci_rx_le_conn_parm_req+0x7a>
        evt.timeout > BLE_HCI_CONN_SPVN_TIMEOUT_MAX) {

        return BLE_HS_EBADDATA;
    }

    ble_gap_rx_param_req(&evt);
   18fa6:	a801      	add	r0, sp, #4
   18fa8:	f7f9 f8a8 	bl	120fc <ble_gap_rx_param_req>

    return 0;
   18fac:	2000      	movs	r0, #0
   18fae:	e002      	b.n	18fb6 <host_hci_rx_le_conn_parm_req+0x80>

    if (evt.itvl_min < BLE_HCI_CONN_ITVL_MIN ||
        evt.itvl_max > BLE_HCI_CONN_ITVL_MAX ||
        evt.itvl_min > evt.itvl_max) {

        return BLE_HS_EBADDATA;
   18fb0:	200a      	movs	r0, #10
   18fb2:	e000      	b.n	18fb6 <host_hci_rx_le_conn_parm_req+0x80>
host_hci_rx_le_conn_parm_req(uint8_t subevent, uint8_t *data, int len)
{
    struct hci_le_conn_param_req evt;

    if (len < BLE_HCI_LE_REM_CONN_PARM_REQ_LEN) {
        return BLE_HS_ECONTROLLER;
   18fb4:	200c      	movs	r0, #12
    }

    ble_gap_rx_param_req(&evt);

    return 0;
}
   18fb6:	b004      	add	sp, #16
   18fb8:	bd10      	pop	{r4, pc}

00018fba <host_hci_rx_le_lt_key_req>:
static int
host_hci_rx_le_lt_key_req(uint8_t subevent, uint8_t *data, int len)
{
    struct hci_le_lt_key_req evt;

    if (len < BLE_HCI_LE_LT_KEY_REQ_LEN) {
   18fba:	2a0c      	cmp	r2, #12
    return 0;
}

static int
host_hci_rx_le_lt_key_req(uint8_t subevent, uint8_t *data, int len)
{
   18fbc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   18fbe:	460c      	mov	r4, r1
    struct hci_le_lt_key_req evt;

    if (len < BLE_HCI_LE_LT_KEY_REQ_LEN) {
   18fc0:	dd18      	ble.n	18ff4 <host_hci_rx_le_lt_key_req+0x3a>
        return BLE_HS_ECONTROLLER;
    }

    evt.subevent_code = data[0];
   18fc2:	4608      	mov	r0, r1
   18fc4:	f810 3b01 	ldrb.w	r3, [r0], #1
   18fc8:	f88d 300c 	strb.w	r3, [sp, #12]
    evt.connection_handle = le16toh(data + 1);
   18fcc:	f004 f85f 	bl	1d08e <le16toh>
   18fd0:	f8ad 0008 	strh.w	r0, [sp, #8]
    evt.random_number = le64toh(data + 3);
   18fd4:	1ce0      	adds	r0, r4, #3
   18fd6:	f004 f86a 	bl	1d0ae <le64toh>
   18fda:	e9cd 0100 	strd	r0, r1, [sp]
    evt.encrypted_diversifier = le16toh(data + 11);
   18fde:	f104 000b 	add.w	r0, r4, #11
   18fe2:	f004 f854 	bl	1d08e <le16toh>
   18fe6:	f8ad 000a 	strh.w	r0, [sp, #10]

    ble_sm_ltk_req_rx(&evt);
   18fea:	4668      	mov	r0, sp
   18fec:	f7fd ffc4 	bl	16f78 <ble_sm_ltk_req_rx>
   18ff0:	2000      	movs	r0, #0
   18ff2:	e000      	b.n	18ff6 <host_hci_rx_le_lt_key_req+0x3c>
host_hci_rx_le_lt_key_req(uint8_t subevent, uint8_t *data, int len)
{
    struct hci_le_lt_key_req evt;

    if (len < BLE_HCI_LE_LT_KEY_REQ_LEN) {
        return BLE_HS_ECONTROLLER;
   18ff4:	200c      	movs	r0, #12
    evt.encrypted_diversifier = le16toh(data + 11);

    ble_sm_ltk_req_rx(&evt);

    return 0;
}
   18ff6:	b004      	add	sp, #16
   18ff8:	bd10      	pop	{r4, pc}

00018ffa <host_hci_rx_le_conn_upd_complete>:
static int
host_hci_rx_le_conn_upd_complete(uint8_t subevent, uint8_t *data, int len)
{
    struct hci_le_conn_upd_complete evt;

    if (len < BLE_HCI_LE_CONN_UPD_LEN) {
   18ffa:	2a09      	cmp	r2, #9
    return 0;
}

static int
host_hci_rx_le_conn_upd_complete(uint8_t subevent, uint8_t *data, int len)
{
   18ffc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   18ffe:	460c      	mov	r4, r1
    struct hci_le_conn_upd_complete evt;

    if (len < BLE_HCI_LE_CONN_UPD_LEN) {
   19000:	dd37      	ble.n	19072 <host_hci_rx_le_conn_upd_complete+0x78>
        return BLE_HS_ECONTROLLER;
    }

    evt.subevent_code = data[0];
   19002:	780b      	ldrb	r3, [r1, #0]
   19004:	f88d 3004 	strb.w	r3, [sp, #4]
    evt.status = data[1];
    evt.connection_handle = le16toh(data + 2);
   19008:	1c88      	adds	r0, r1, #2
    if (len < BLE_HCI_LE_CONN_UPD_LEN) {
        return BLE_HS_ECONTROLLER;
    }

    evt.subevent_code = data[0];
    evt.status = data[1];
   1900a:	784b      	ldrb	r3, [r1, #1]
   1900c:	f88d 3005 	strb.w	r3, [sp, #5]
    evt.connection_handle = le16toh(data + 2);
   19010:	f004 f83d 	bl	1d08e <le16toh>
   19014:	f8ad 0006 	strh.w	r0, [sp, #6]
    evt.conn_itvl = le16toh(data + 4);
   19018:	1d20      	adds	r0, r4, #4
   1901a:	f004 f838 	bl	1d08e <le16toh>
   1901e:	f8ad 0008 	strh.w	r0, [sp, #8]
    evt.conn_latency = le16toh(data + 6);
   19022:	1da0      	adds	r0, r4, #6
   19024:	f004 f833 	bl	1d08e <le16toh>
   19028:	f8ad 000a 	strh.w	r0, [sp, #10]
    evt.supervision_timeout = le16toh(data + 8);
   1902c:	f104 0008 	add.w	r0, r4, #8
   19030:	f004 f82d 	bl	1d08e <le16toh>

    if (evt.status == 0) {
   19034:	f89d 3005 	ldrb.w	r3, [sp, #5]
    evt.subevent_code = data[0];
    evt.status = data[1];
    evt.connection_handle = le16toh(data + 2);
    evt.conn_itvl = le16toh(data + 4);
    evt.conn_latency = le16toh(data + 6);
    evt.supervision_timeout = le16toh(data + 8);
   19038:	f8ad 000c 	strh.w	r0, [sp, #12]

    if (evt.status == 0) {
   1903c:	b993      	cbnz	r3, 19064 <host_hci_rx_le_conn_upd_complete+0x6a>
        if (evt.conn_itvl < BLE_HCI_CONN_ITVL_MIN ||
   1903e:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   19042:	3b06      	subs	r3, #6
   19044:	b29b      	uxth	r3, r3
   19046:	f640 427a 	movw	r2, #3194	; 0xc7a
   1904a:	4293      	cmp	r3, r2
   1904c:	d80f      	bhi.n	1906e <host_hci_rx_le_conn_upd_complete+0x74>
            evt.conn_itvl > BLE_HCI_CONN_ITVL_MAX) {

            return BLE_HS_EBADDATA;
        }
        if (evt.conn_latency < BLE_HCI_CONN_LATENCY_MIN ||
   1904e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   19052:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   19056:	d20a      	bcs.n	1906e <host_hci_rx_le_conn_upd_complete+0x74>
            evt.conn_latency > BLE_HCI_CONN_LATENCY_MAX) {

            return BLE_HS_EBADDATA;
        }
        if (evt.supervision_timeout < BLE_HCI_CONN_SPVN_TIMEOUT_MIN ||
   19058:	380a      	subs	r0, #10
   1905a:	b280      	uxth	r0, r0
   1905c:	f640 4376 	movw	r3, #3190	; 0xc76
   19060:	4298      	cmp	r0, r3
   19062:	d804      	bhi.n	1906e <host_hci_rx_le_conn_upd_complete+0x74>

            return BLE_HS_EBADDATA;
        }
    }

    ble_gap_rx_update_complete(&evt);
   19064:	a801      	add	r0, sp, #4
   19066:	f7f8 fcc3 	bl	119f0 <ble_gap_rx_update_complete>

    return 0;
   1906a:	2000      	movs	r0, #0
   1906c:	e002      	b.n	19074 <host_hci_rx_le_conn_upd_complete+0x7a>

    if (evt.status == 0) {
        if (evt.conn_itvl < BLE_HCI_CONN_ITVL_MIN ||
            evt.conn_itvl > BLE_HCI_CONN_ITVL_MAX) {

            return BLE_HS_EBADDATA;
   1906e:	200a      	movs	r0, #10
   19070:	e000      	b.n	19074 <host_hci_rx_le_conn_upd_complete+0x7a>
host_hci_rx_le_conn_upd_complete(uint8_t subevent, uint8_t *data, int len)
{
    struct hci_le_conn_upd_complete evt;

    if (len < BLE_HCI_LE_CONN_UPD_LEN) {
        return BLE_HS_ECONTROLLER;
   19072:	200c      	movs	r0, #12
    }

    ble_gap_rx_update_complete(&evt);

    return 0;
}
   19074:	b004      	add	sp, #16
   19076:	bd10      	pop	{r4, pc}

00019078 <host_hci_rx_le_conn_complete>:
    return 0;
}

static int
host_hci_rx_le_conn_complete(uint8_t subevent, uint8_t *data, int len)
{
   19078:	b530      	push	{r4, r5, lr}
    struct hci_le_conn_complete evt;
    int extended_offset = 0;
    int rc;

    if (len < BLE_HCI_LE_CONN_COMPLETE_LEN) {
   1907a:	2a12      	cmp	r2, #18
    return 0;
}

static int
host_hci_rx_le_conn_complete(uint8_t subevent, uint8_t *data, int len)
{
   1907c:	b089      	sub	sp, #36	; 0x24
   1907e:	4605      	mov	r5, r0
   19080:	460c      	mov	r4, r1
    struct hci_le_conn_complete evt;
    int extended_offset = 0;
    int rc;

    if (len < BLE_HCI_LE_CONN_COMPLETE_LEN) {
   19082:	dd63      	ble.n	1914c <host_hci_rx_le_conn_complete+0xd4>
        return BLE_HS_ECONTROLLER;
    }

    /* this code processes two different events that are really similar */
    if ((subevent == BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE) &&
   19084:	280a      	cmp	r0, #10
   19086:	d101      	bne.n	1908c <host_hci_rx_le_conn_complete+0x14>
   19088:	2a1e      	cmp	r2, #30
   1908a:	dd5f      	ble.n	1914c <host_hci_rx_le_conn_complete+0xd4>
        ( len < BLE_HCI_LE_ENH_CONN_COMPLETE_LEN)) {
        return BLE_HS_ECONTROLLER;
    }

    evt.subevent_code = data[0];
   1908c:	7823      	ldrb	r3, [r4, #0]
   1908e:	f88d 3000 	strb.w	r3, [sp]
    evt.status = data[1];
    evt.connection_handle = le16toh(data + 2);
   19092:	1ca0      	adds	r0, r4, #2
        ( len < BLE_HCI_LE_ENH_CONN_COMPLETE_LEN)) {
        return BLE_HS_ECONTROLLER;
    }

    evt.subevent_code = data[0];
    evt.status = data[1];
   19094:	7863      	ldrb	r3, [r4, #1]
   19096:	f88d 3001 	strb.w	r3, [sp, #1]
    evt.connection_handle = le16toh(data + 2);
   1909a:	f003 fff8 	bl	1d08e <le16toh>
    evt.role = data[4];
   1909e:	7923      	ldrb	r3, [r4, #4]
   190a0:	f88d 3004 	strb.w	r3, [sp, #4]
    evt.peer_addr_type = data[5];
   190a4:	7963      	ldrb	r3, [r4, #5]
   190a6:	f88d 3005 	strb.w	r3, [sp, #5]
    memcpy(evt.peer_addr, data + 6, BLE_DEV_ADDR_LEN);
   190aa:	4623      	mov	r3, r4

    /* enhanced connection event has the same information with these
     * extra fields stuffed into the middle */
    if (subevent == BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE) {
   190ac:	2d0a      	cmp	r5, #10
    evt.subevent_code = data[0];
    evt.status = data[1];
    evt.connection_handle = le16toh(data + 2);
    evt.role = data[4];
    evt.peer_addr_type = data[5];
    memcpy(evt.peer_addr, data + 6, BLE_DEV_ADDR_LEN);
   190ae:	f853 2f06 	ldr.w	r2, [r3, #6]!
        return BLE_HS_ECONTROLLER;
    }

    evt.subevent_code = data[0];
    evt.status = data[1];
    evt.connection_handle = le16toh(data + 2);
   190b2:	f8ad 0002 	strh.w	r0, [sp, #2]
    evt.role = data[4];
    evt.peer_addr_type = data[5];
    memcpy(evt.peer_addr, data + 6, BLE_DEV_ADDR_LEN);
   190b6:	889b      	ldrh	r3, [r3, #4]
   190b8:	f8cd 2006 	str.w	r2, [sp, #6]
   190bc:	f8ad 300a 	strh.w	r3, [sp, #10]

    /* enhanced connection event has the same information with these
     * extra fields stuffed into the middle */
    if (subevent == BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE) {
   190c0:	d111      	bne.n	190e6 <host_hci_rx_le_conn_complete+0x6e>
        memcpy(evt.local_rpa, data + 12, BLE_DEV_ADDR_LEN);
   190c2:	4623      	mov	r3, r4
        memcpy(evt.peer_rpa, data + 18, BLE_DEV_ADDR_LEN);
        extended_offset = 12;
   190c4:	250c      	movs	r5, #12
    memcpy(evt.peer_addr, data + 6, BLE_DEV_ADDR_LEN);

    /* enhanced connection event has the same information with these
     * extra fields stuffed into the middle */
    if (subevent == BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE) {
        memcpy(evt.local_rpa, data + 12, BLE_DEV_ADDR_LEN);
   190c6:	f853 2f0c 	ldr.w	r2, [r3, #12]!
   190ca:	f8cd 2013 	str.w	r2, [sp, #19]
   190ce:	889b      	ldrh	r3, [r3, #4]
   190d0:	f8ad 3017 	strh.w	r3, [sp, #23]
        memcpy(evt.peer_rpa, data + 18, BLE_DEV_ADDR_LEN);
   190d4:	4623      	mov	r3, r4
   190d6:	f853 2f12 	ldr.w	r2, [r3, #18]!
   190da:	f8cd 2019 	str.w	r2, [sp, #25]
   190de:	889b      	ldrh	r3, [r3, #4]
   190e0:	f8ad 301d 	strh.w	r3, [sp, #29]
   190e4:	e00c      	b.n	19100 <host_hci_rx_le_conn_complete+0x88>
        extended_offset = 12;
    } else {
        memset(evt.local_rpa, 0, BLE_DEV_ADDR_LEN);
   190e6:	2100      	movs	r1, #0
   190e8:	2206      	movs	r2, #6
   190ea:	f10d 0013 	add.w	r0, sp, #19
   190ee:	f7ef ff90 	bl	9012 <memset>
        memset(evt.peer_rpa, 0, BLE_DEV_ADDR_LEN);
   190f2:	f10d 0019 	add.w	r0, sp, #25
   190f6:	2100      	movs	r1, #0
   190f8:	2206      	movs	r2, #6
   190fa:	f7ef ff8a 	bl	9012 <memset>

static int
host_hci_rx_le_conn_complete(uint8_t subevent, uint8_t *data, int len)
{
    struct hci_le_conn_complete evt;
    int extended_offset = 0;
   190fe:	2500      	movs	r5, #0
    } else {
        memset(evt.local_rpa, 0, BLE_DEV_ADDR_LEN);
        memset(evt.peer_rpa, 0, BLE_DEV_ADDR_LEN);
    }

    evt.conn_itvl = le16toh(data + 12 + extended_offset);
   19100:	f105 000c 	add.w	r0, r5, #12
   19104:	4420      	add	r0, r4
   19106:	f003 ffc2 	bl	1d08e <le16toh>
   1910a:	f8ad 000c 	strh.w	r0, [sp, #12]
    evt.conn_latency = le16toh(data + 14 + extended_offset);
   1910e:	f105 000e 	add.w	r0, r5, #14
   19112:	4420      	add	r0, r4
   19114:	f003 ffbb 	bl	1d08e <le16toh>
   19118:	f8ad 000e 	strh.w	r0, [sp, #14]
    evt.supervision_timeout = le16toh(data + 16 + extended_offset);
   1911c:	f105 0010 	add.w	r0, r5, #16
   19120:	4420      	add	r0, r4
    evt.master_clk_acc = data[18 + extended_offset];
   19122:	442c      	add	r4, r5
        memset(evt.peer_rpa, 0, BLE_DEV_ADDR_LEN);
    }

    evt.conn_itvl = le16toh(data + 12 + extended_offset);
    evt.conn_latency = le16toh(data + 14 + extended_offset);
    evt.supervision_timeout = le16toh(data + 16 + extended_offset);
   19124:	f003 ffb3 	bl	1d08e <le16toh>
    evt.master_clk_acc = data[18 + extended_offset];
   19128:	7ca3      	ldrb	r3, [r4, #18]
   1912a:	f88d 3012 	strb.w	r3, [sp, #18]

    if (evt.status == 0) {
   1912e:	f89d 3001 	ldrb.w	r3, [sp, #1]
        memset(evt.peer_rpa, 0, BLE_DEV_ADDR_LEN);
    }

    evt.conn_itvl = le16toh(data + 12 + extended_offset);
    evt.conn_latency = le16toh(data + 14 + extended_offset);
    evt.supervision_timeout = le16toh(data + 16 + extended_offset);
   19132:	f8ad 0010 	strh.w	r0, [sp, #16]
    evt.master_clk_acc = data[18 + extended_offset];

    if (evt.status == 0) {
   19136:	b91b      	cbnz	r3, 19140 <host_hci_rx_le_conn_complete+0xc8>
        if (evt.role != BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER &&
   19138:	f89d 3004 	ldrb.w	r3, [sp, #4]
   1913c:	2b01      	cmp	r3, #1
   1913e:	d803      	bhi.n	19148 <host_hci_rx_le_conn_complete+0xd0>

            return BLE_HS_EBADDATA;
        }
    }

    rc = ble_gap_rx_conn_complete(&evt);
   19140:	4668      	mov	r0, sp
   19142:	f7f8 fcc3 	bl	11acc <ble_gap_rx_conn_complete>
   19146:	e002      	b.n	1914e <host_hci_rx_le_conn_complete+0xd6>

    if (evt.status == 0) {
        if (evt.role != BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER &&
            evt.role != BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE) {

            return BLE_HS_EBADDATA;
   19148:	200a      	movs	r0, #10
   1914a:	e000      	b.n	1914e <host_hci_rx_le_conn_complete+0xd6>
    struct hci_le_conn_complete evt;
    int extended_offset = 0;
    int rc;

    if (len < BLE_HCI_LE_CONN_COMPLETE_LEN) {
        return BLE_HS_ECONTROLLER;
   1914c:	200c      	movs	r0, #12
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1914e:	b009      	add	sp, #36	; 0x24
   19150:	bd30      	pop	{r4, r5, pc}

00019152 <host_hci_rx_enc_key_refresh>:
static int
host_hci_rx_enc_key_refresh(uint8_t event_code, uint8_t *data, int len)
{
    struct hci_encrypt_key_refresh evt;

    if (len < BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN) {
   19152:	2a02      	cmp	r2, #2
    return 0;
}

static int
host_hci_rx_enc_key_refresh(uint8_t event_code, uint8_t *data, int len)
{
   19154:	b507      	push	{r0, r1, r2, lr}
    struct hci_encrypt_key_refresh evt;

    if (len < BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN) {
   19156:	dd0c      	ble.n	19172 <host_hci_rx_enc_key_refresh+0x20>
        return BLE_HS_ECONTROLLER;
    }

    evt.status = data[2];
   19158:	788b      	ldrb	r3, [r1, #2]
   1915a:	f88d 3004 	strb.w	r3, [sp, #4]
    evt.connection_handle = le16toh(data + 3);
   1915e:	1cc8      	adds	r0, r1, #3
   19160:	f003 ff95 	bl	1d08e <le16toh>
   19164:	f8ad 0006 	strh.w	r0, [sp, #6]

    ble_sm_enc_key_refresh_rx(&evt);
   19168:	a801      	add	r0, sp, #4
   1916a:	f7fd feff 	bl	16f6c <ble_sm_enc_key_refresh_rx>
   1916e:	2000      	movs	r0, #0
   19170:	e000      	b.n	19174 <host_hci_rx_enc_key_refresh+0x22>
host_hci_rx_enc_key_refresh(uint8_t event_code, uint8_t *data, int len)
{
    struct hci_encrypt_key_refresh evt;

    if (len < BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN) {
        return BLE_HS_ECONTROLLER;
   19172:	200c      	movs	r0, #12
    evt.connection_handle = le16toh(data + 3);

    ble_sm_enc_key_refresh_rx(&evt);

    return 0;
}
   19174:	b003      	add	sp, #12
   19176:	f85d fb04 	ldr.w	pc, [sp], #4

0001917a <host_hci_rx_encrypt_change>:
static int
host_hci_rx_encrypt_change(uint8_t event_code, uint8_t *data, int len)
{
    struct hci_encrypt_change evt;

    if (len < BLE_HCI_EVENT_ENCRYPT_CHG_LEN) {
   1917a:	2a03      	cmp	r2, #3
    return 0;
}

static int
host_hci_rx_encrypt_change(uint8_t event_code, uint8_t *data, int len)
{
   1917c:	b513      	push	{r0, r1, r4, lr}
   1917e:	460c      	mov	r4, r1
    struct hci_encrypt_change evt;

    if (len < BLE_HCI_EVENT_ENCRYPT_CHG_LEN) {
   19180:	dd0f      	ble.n	191a2 <host_hci_rx_encrypt_change+0x28>
        return BLE_HS_ECONTROLLER;
    }

    evt.status = data[2];
   19182:	788b      	ldrb	r3, [r1, #2]
   19184:	f88d 3004 	strb.w	r3, [sp, #4]
    evt.connection_handle = le16toh(data + 3);
   19188:	1cc8      	adds	r0, r1, #3
   1918a:	f003 ff80 	bl	1d08e <le16toh>
    evt.encryption_enabled = data[5];
   1918e:	7963      	ldrb	r3, [r4, #5]
    if (len < BLE_HCI_EVENT_ENCRYPT_CHG_LEN) {
        return BLE_HS_ECONTROLLER;
    }

    evt.status = data[2];
    evt.connection_handle = le16toh(data + 3);
   19190:	f8ad 0006 	strh.w	r0, [sp, #6]
    evt.encryption_enabled = data[5];

    ble_sm_enc_change_rx(&evt);
   19194:	a801      	add	r0, sp, #4
        return BLE_HS_ECONTROLLER;
    }

    evt.status = data[2];
    evt.connection_handle = le16toh(data + 3);
    evt.encryption_enabled = data[5];
   19196:	f88d 3005 	strb.w	r3, [sp, #5]

    ble_sm_enc_change_rx(&evt);
   1919a:	f7fd fedf 	bl	16f5c <ble_sm_enc_change_rx>
   1919e:	2000      	movs	r0, #0
   191a0:	e000      	b.n	191a4 <host_hci_rx_encrypt_change+0x2a>
host_hci_rx_encrypt_change(uint8_t event_code, uint8_t *data, int len)
{
    struct hci_encrypt_change evt;

    if (len < BLE_HCI_EVENT_ENCRYPT_CHG_LEN) {
        return BLE_HS_ECONTROLLER;
   191a2:	200c      	movs	r0, #12
    evt.encryption_enabled = data[5];

    ble_sm_enc_change_rx(&evt);

    return 0;
}
   191a4:	b002      	add	sp, #8
   191a6:	bd10      	pop	{r4, pc}

000191a8 <host_hci_rx_disconn_complete>:
static int
host_hci_rx_disconn_complete(uint8_t event_code, uint8_t *data, int len)
{
    struct hci_disconn_complete evt;

    if (len < BLE_HCI_EVENT_DISCONN_COMPLETE_LEN) {
   191a8:	2a03      	cmp	r2, #3
    return NULL;
}

static int
host_hci_rx_disconn_complete(uint8_t event_code, uint8_t *data, int len)
{
   191aa:	b513      	push	{r0, r1, r4, lr}
   191ac:	460c      	mov	r4, r1
    struct hci_disconn_complete evt;

    if (len < BLE_HCI_EVENT_DISCONN_COMPLETE_LEN) {
   191ae:	dd0f      	ble.n	191d0 <host_hci_rx_disconn_complete+0x28>
        return BLE_HS_ECONTROLLER;
    }

    evt.status = data[2];
   191b0:	788b      	ldrb	r3, [r1, #2]
   191b2:	f88d 3006 	strb.w	r3, [sp, #6]
    evt.connection_handle = le16toh(data + 3);
   191b6:	1cc8      	adds	r0, r1, #3
   191b8:	f003 ff69 	bl	1d08e <le16toh>
    evt.reason = data[5];
   191bc:	7963      	ldrb	r3, [r4, #5]
    if (len < BLE_HCI_EVENT_DISCONN_COMPLETE_LEN) {
        return BLE_HS_ECONTROLLER;
    }

    evt.status = data[2];
    evt.connection_handle = le16toh(data + 3);
   191be:	f8ad 0004 	strh.w	r0, [sp, #4]
    evt.reason = data[5];

    ble_gap_rx_disconn_complete(&evt);
   191c2:	a801      	add	r0, sp, #4
        return BLE_HS_ECONTROLLER;
    }

    evt.status = data[2];
    evt.connection_handle = le16toh(data + 3);
    evt.reason = data[5];
   191c4:	f88d 3007 	strb.w	r3, [sp, #7]

    ble_gap_rx_disconn_complete(&evt);
   191c8:	f7f8 fbec 	bl	119a4 <ble_gap_rx_disconn_complete>
   191cc:	2000      	movs	r0, #0
   191ce:	e000      	b.n	191d2 <host_hci_rx_disconn_complete+0x2a>
host_hci_rx_disconn_complete(uint8_t event_code, uint8_t *data, int len)
{
    struct hci_disconn_complete evt;

    if (len < BLE_HCI_EVENT_DISCONN_COMPLETE_LEN) {
        return BLE_HS_ECONTROLLER;
   191d0:	200c      	movs	r0, #12
    evt.reason = data[5];

    ble_gap_rx_disconn_complete(&evt);

    return 0;
}
   191d2:	b002      	add	sp, #8
   191d4:	bd10      	pop	{r4, pc}
	...

000191d8 <host_hci_set_buf_size>:
}

int
host_hci_set_buf_size(uint16_t pktlen, uint8_t max_pkts)
{
    if (pktlen == 0 || max_pkts == 0) {
   191d8:	b130      	cbz	r0, 191e8 <host_hci_set_buf_size+0x10>
   191da:	b129      	cbz	r1, 191e8 <host_hci_set_buf_size+0x10>
        return BLE_HS_EINVAL;
    }

    host_hci_buffer_sz = pktlen;
   191dc:	4b03      	ldr	r3, [pc, #12]	; (191ec <host_hci_set_buf_size+0x14>)
   191de:	8018      	strh	r0, [r3, #0]
    host_hci_max_pkts = max_pkts;
   191e0:	4b03      	ldr	r3, [pc, #12]	; (191f0 <host_hci_set_buf_size+0x18>)

    return 0;
   191e2:	2000      	movs	r0, #0
    if (pktlen == 0 || max_pkts == 0) {
        return BLE_HS_EINVAL;
    }

    host_hci_buffer_sz = pktlen;
    host_hci_max_pkts = max_pkts;
   191e4:	7019      	strb	r1, [r3, #0]

    return 0;
   191e6:	4770      	bx	lr

int
host_hci_set_buf_size(uint16_t pktlen, uint8_t max_pkts)
{
    if (pktlen == 0 || max_pkts == 0) {
        return BLE_HS_EINVAL;
   191e8:	2003      	movs	r0, #3

    host_hci_buffer_sz = pktlen;
    host_hci_max_pkts = max_pkts;

    return 0;
}
   191ea:	4770      	bx	lr
   191ec:	200023ba 	.word	0x200023ba
   191f0:	200023b8 	.word	0x200023b8

000191f4 <host_hci_event_rx>:

int
host_hci_event_rx(uint8_t *data)
{
   191f4:	b570      	push	{r4, r5, r6, lr}
    uint8_t param_len;
    int event_len;
    int rc;

    /* Count events received */
    STATS_INC(ble_hs_stats, hci_event);
   191f6:	4c0f      	ldr	r4, [pc, #60]	; (19234 <host_hci_event_rx+0x40>)
   191f8:	69a3      	ldr	r3, [r4, #24]
    return 0;
}

int
host_hci_event_rx(uint8_t *data)
{
   191fa:	4606      	mov	r6, r0
    uint8_t param_len;
    int event_len;
    int rc;

    /* Count events received */
    STATS_INC(ble_hs_stats, hci_event);
   191fc:	3301      	adds	r3, #1
   191fe:	61a3      	str	r3, [r4, #24]

    /* Display to console */
    host_hci_dbg_event_disp(data);
   19200:	f7ff f9b2 	bl	18568 <host_hci_dbg_event_disp>

    /* Process the event */
    event_code = data[0];
   19204:	7830      	ldrb	r0, [r6, #0]
    param_len = data[1];
   19206:	7872      	ldrb	r2, [r6, #1]
   19208:	2300      	movs	r3, #0
   1920a:	4d0b      	ldr	r5, [pc, #44]	; (19238 <host_hci_event_rx+0x44>)
   1920c:	18e9      	adds	r1, r5, r3
   1920e:	3308      	adds	r3, #8
   19210:	441d      	add	r5, r3
    const struct host_hci_event_dispatch_entry *entry;
    int i;

    for (i = 0; i < HOST_HCI_EVENT_DISPATCH_SZ; i++) {
        entry = host_hci_event_dispatch + i;
        if (entry->hed_event_code == event_code) {
   19212:	f815 5c08 	ldrb.w	r5, [r5, #-8]
   19216:	4285      	cmp	r5, r0
   19218:	d105      	bne.n	19226 <host_hci_event_rx+0x32>
    entry = host_hci_dispatch_entry_find(event_code);
    if (entry == NULL) {
        STATS_INC(ble_hs_stats, hci_invalid_ack);
        rc = BLE_HS_ENOTSUP;
    } else {
        rc = entry->hed_fn(event_code, data, event_len);
   1921a:	684b      	ldr	r3, [r1, #4]
   1921c:	3202      	adds	r2, #2
   1921e:	4631      	mov	r1, r6
    }

    return rc;
}
   19220:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    entry = host_hci_dispatch_entry_find(event_code);
    if (entry == NULL) {
        STATS_INC(ble_hs_stats, hci_invalid_ack);
        rc = BLE_HS_ENOTSUP;
    } else {
        rc = entry->hed_fn(event_code, data, event_len);
   19224:	4718      	bx	r3
host_hci_dispatch_entry_find(uint8_t event_code)
{
    const struct host_hci_event_dispatch_entry *entry;
    int i;

    for (i = 0; i < HOST_HCI_EVENT_DISPATCH_SZ; i++) {
   19226:	2b28      	cmp	r3, #40	; 0x28
   19228:	d1ef      	bne.n	1920a <host_hci_event_rx+0x16>

    event_len = param_len + 2;

    entry = host_hci_dispatch_entry_find(event_code);
    if (entry == NULL) {
        STATS_INC(ble_hs_stats, hci_invalid_ack);
   1922a:	69e3      	ldr	r3, [r4, #28]
   1922c:	3301      	adds	r3, #1
   1922e:	61e3      	str	r3, [r4, #28]
    } else {
        rc = entry->hed_fn(event_code, data, event_len);
    }

    return rc;
}
   19230:	2008      	movs	r0, #8
   19232:	bd70      	pop	{r4, r5, r6, pc}
   19234:	20003b1c 	.word	0x20003b1c
   19238:	00020688 	.word	0x00020688

0001923c <host_hci_os_event_proc>:

int
host_hci_os_event_proc(struct os_event *ev)
{
   1923c:	b538      	push	{r3, r4, r5, lr}
   1923e:	4604      	mov	r4, r0
    os_error_t err;
    int rc;

    rc = host_hci_event_rx(ev->ev_arg);
   19240:	6840      	ldr	r0, [r0, #4]
   19242:	f7ff ffd7 	bl	191f4 <host_hci_event_rx>

    /* Free the command buffer */
    err = os_memblock_put(&g_hci_evt_pool, ev->ev_arg);
   19246:	6861      	ldr	r1, [r4, #4]
host_hci_os_event_proc(struct os_event *ev)
{
    os_error_t err;
    int rc;

    rc = host_hci_event_rx(ev->ev_arg);
   19248:	4605      	mov	r5, r0

    /* Free the command buffer */
    err = os_memblock_put(&g_hci_evt_pool, ev->ev_arg);
   1924a:	4804      	ldr	r0, [pc, #16]	; (1925c <host_hci_os_event_proc+0x20>)
   1924c:	f7f1 f8e8 	bl	a420 <os_memblock_put>
    BLE_HS_DBG_ASSERT_EVAL(err == OS_OK);

    /* Free the event */
    err = os_memblock_put(&g_hci_os_event_pool, ev);
   19250:	4621      	mov	r1, r4
   19252:	4803      	ldr	r0, [pc, #12]	; (19260 <host_hci_os_event_proc+0x24>)
   19254:	f7f1 f8e4 	bl	a420 <os_memblock_put>
    BLE_HS_DBG_ASSERT_EVAL(err == OS_OK);

    return rc;
}
   19258:	4628      	mov	r0, r5
   1925a:	bd38      	pop	{r3, r4, r5, pc}
   1925c:	20003b5c 	.word	0x20003b5c
   19260:	20003b40 	.word	0x20003b40

00019264 <ble_hci_transport_ctlr_event_send>:

/* XXX: For now, put this here */
int
ble_hci_transport_ctlr_event_send(uint8_t *hci_ev)
{
   19264:	b538      	push	{r3, r4, r5, lr}
    os_error_t err;
    int enqueue;

    BLE_HS_DBG_ASSERT(hci_ev != NULL);

    switch (hci_ev[0]) {
   19266:	7803      	ldrb	r3, [r0, #0]
   19268:	3b0e      	subs	r3, #14
   1926a:	2b01      	cmp	r3, #1
}

/* XXX: For now, put this here */
int
ble_hci_transport_ctlr_event_send(uint8_t *hci_ev)
{
   1926c:	4605      	mov	r5, r0
    os_error_t err;
    int enqueue;

    BLE_HS_DBG_ASSERT(hci_ev != NULL);

    switch (hci_ev[0]) {
   1926e:	d808      	bhi.n	19282 <ble_hci_transport_ctlr_event_send+0x1e>
    case BLE_HCI_EVCODE_COMMAND_COMPLETE:
    case BLE_HCI_EVCODE_COMMAND_STATUS:
        if (hci_ev[3] == 0 && hci_ev[4] == 0) {
   19270:	78c3      	ldrb	r3, [r0, #3]
   19272:	b90b      	cbnz	r3, 19278 <ble_hci_transport_ctlr_event_send+0x14>
   19274:	7903      	ldrb	r3, [r0, #4]
   19276:	b123      	cbz	r3, 19282 <ble_hci_transport_ctlr_event_send+0x1e>
            enqueue = 1;
        } else {
            ble_hci_cmd_rx_ack(hci_ev);
   19278:	4628      	mov	r0, r5
   1927a:	f7fb f9db 	bl	14634 <ble_hci_cmd_rx_ack>
        ev->ev_type = BLE_HOST_HCI_EVENT_CTLR_EVENT;
        ev->ev_arg = hci_ev;
        ble_hs_event_enqueue(ev);
    }

    return 0;
   1927e:	2000      	movs	r0, #0
   19280:	bd38      	pop	{r3, r4, r5, pc}
        break;
    }

    if (enqueue) {
        /* Get an event structure off the queue */
        ev = (struct os_event *)os_memblock_get(&g_hci_os_event_pool);
   19282:	480a      	ldr	r0, [pc, #40]	; (192ac <ble_hci_transport_ctlr_event_send+0x48>)
   19284:	f7f1 f8b8 	bl	a3f8 <os_memblock_get>
        if (!ev) {
   19288:	4603      	mov	r3, r0
   1928a:	b930      	cbnz	r0, 1929a <ble_hci_transport_ctlr_event_send+0x36>
            err = os_memblock_put(&g_hci_evt_pool, hci_ev);
   1928c:	4629      	mov	r1, r5
   1928e:	4808      	ldr	r0, [pc, #32]	; (192b0 <ble_hci_transport_ctlr_event_send+0x4c>)
   19290:	f7f1 f8c6 	bl	a420 <os_memblock_put>
            BLE_HS_DBG_ASSERT_EVAL(err == OS_OK);
            return -1;
   19294:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   19298:	bd38      	pop	{r3, r4, r5, pc}
        }

        /* Fill out the event and post to host task. */
        ev->ev_queued = 0;
   1929a:	2400      	movs	r4, #0
        ev->ev_type = BLE_HOST_HCI_EVENT_CTLR_EVENT;
   1929c:	2210      	movs	r2, #16
            BLE_HS_DBG_ASSERT_EVAL(err == OS_OK);
            return -1;
        }

        /* Fill out the event and post to host task. */
        ev->ev_queued = 0;
   1929e:	701c      	strb	r4, [r3, #0]
        ev->ev_type = BLE_HOST_HCI_EVENT_CTLR_EVENT;
   192a0:	705a      	strb	r2, [r3, #1]
        ev->ev_arg = hci_ev;
   192a2:	605d      	str	r5, [r3, #4]
        ble_hs_event_enqueue(ev);
   192a4:	f7fb fad8 	bl	14858 <ble_hs_event_enqueue>
   192a8:	e7e9      	b.n	1927e <ble_hci_transport_ctlr_event_send+0x1a>
   192aa:	bf00      	nop
   192ac:	20003b40 	.word	0x20003b40
   192b0:	20003b5c 	.word	0x20003b5c

000192b4 <host_hci_data_rx>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
host_hci_data_rx(struct os_mbuf *om)
{
   192b4:	b570      	push	{r4, r5, r6, lr}
   192b6:	b088      	sub	sp, #32
    ble_l2cap_rx_fn *rx_cb;
    struct os_mbuf *rx_buf;
    uint16_t handle;
    int rc;

    rc = ble_hci_util_data_hdr_strip(om, &hci_hdr);
   192b8:	a905      	add	r1, sp, #20
 *
 * @return                      0 on success; nonzero on failure.
 */
int
host_hci_data_rx(struct os_mbuf *om)
{
   192ba:	4605      	mov	r5, r0
    ble_l2cap_rx_fn *rx_cb;
    struct os_mbuf *rx_buf;
    uint16_t handle;
    int rc;

    rc = ble_hci_util_data_hdr_strip(om, &hci_hdr);
   192bc:	f7fb fa13 	bl	146e6 <ble_hci_util_data_hdr_strip>
    if (rc != 0) {
   192c0:	4604      	mov	r4, r0
   192c2:	2800      	cmp	r0, #0
   192c4:	d140      	bne.n	19348 <host_hci_data_rx+0x94>
        goto err;
    }

#if (BLETEST_THROUGHPUT_TEST == 0)
    BLE_HS_LOG(DEBUG, "host_hci_data_rx(): handle=%u pb=%x len=%u data=",
   192c6:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   192ca:	4823      	ldr	r0, [pc, #140]	; (19358 <host_hci_data_rx+0xa4>)
   192cc:	f3c3 020b 	ubfx	r2, r3, #0, #12
   192d0:	f3c3 3301 	ubfx	r3, r3, #12, #2
   192d4:	9301      	str	r3, [sp, #4]
   192d6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   192da:	9200      	str	r2, [sp, #0]
   192dc:	2104      	movs	r1, #4
   192de:	4622      	mov	r2, r4
   192e0:	9302      	str	r3, [sp, #8]
   192e2:	4b1e      	ldr	r3, [pc, #120]	; (1935c <host_hci_data_rx+0xa8>)
   192e4:	f003 ffa0 	bl	1d228 <log_printf>
               BLE_HCI_DATA_HANDLE(hci_hdr.hdh_handle_pb_bc), 
               BLE_HCI_DATA_PB(hci_hdr.hdh_handle_pb_bc), 
               hci_hdr.hdh_len);
    ble_hs_log_mbuf(om);
   192e8:	4628      	mov	r0, r5
   192ea:	f7fc f8db 	bl	154a4 <ble_hs_log_mbuf>
    BLE_HS_LOG(DEBUG, "\n");
   192ee:	4622      	mov	r2, r4
   192f0:	4b1b      	ldr	r3, [pc, #108]	; (19360 <host_hci_data_rx+0xac>)
   192f2:	4819      	ldr	r0, [pc, #100]	; (19358 <host_hci_data_rx+0xa4>)
   192f4:	2104      	movs	r1, #4
   192f6:	f003 ff97 	bl	1d228 <log_printf>
#endif

    if (hci_hdr.hdh_len != OS_MBUF_PKTHDR(om)->omp_len) {
   192fa:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   192fe:	8a2b      	ldrh	r3, [r5, #16]
   19300:	429a      	cmp	r2, r3
   19302:	d120      	bne.n	19346 <host_hci_data_rx+0x92>
        rc = BLE_HS_EBADDATA;
        goto err;
    }

    handle = BLE_HCI_DATA_HANDLE(hci_hdr.hdh_handle_pb_bc);
   19304:	f8bd 6014 	ldrh.w	r6, [sp, #20]
   19308:	f3c6 060b 	ubfx	r6, r6, #0, #12

    ble_hs_lock();
   1930c:	f7fb fa1a 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(handle);
   19310:	4630      	mov	r0, r6
   19312:	f7fb ffbf 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   19316:	b148      	cbz	r0, 1932c <host_hci_data_rx+0x78>
        rc = BLE_HS_ENOTCONN;
    } else {
        rc = ble_l2cap_rx(conn, &hci_hdr, om, &rx_cb, &rx_buf);
   19318:	ab07      	add	r3, sp, #28
   1931a:	9300      	str	r3, [sp, #0]
   1931c:	462a      	mov	r2, r5
   1931e:	a905      	add	r1, sp, #20
   19320:	ab06      	add	r3, sp, #24
   19322:	f7fc fad3 	bl	158cc <ble_l2cap_rx>
        om = NULL;
   19326:	2500      	movs	r5, #0

    conn = ble_hs_conn_find(handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
    } else {
        rc = ble_l2cap_rx(conn, &hci_hdr, om, &rx_cb, &rx_buf);
   19328:	4604      	mov	r4, r0
   1932a:	e000      	b.n	1932e <host_hci_data_rx+0x7a>

    ble_hs_lock();

    conn = ble_hs_conn_find(handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
   1932c:	2407      	movs	r4, #7
    } else {
        rc = ble_l2cap_rx(conn, &hci_hdr, om, &rx_cb, &rx_buf);
        om = NULL;
    }

    ble_hs_unlock();
   1932e:	f7fb fa11 	bl	14754 <ble_hs_unlock>

    switch (rc) {
   19332:	b114      	cbz	r4, 1933a <host_hci_data_rx+0x86>
   19334:	2c01      	cmp	r4, #1
   19336:	d00c      	beq.n	19352 <host_hci_data_rx+0x9e>
   19338:	e006      	b.n	19348 <host_hci_data_rx+0x94>
    case 0:
        /* Final fragment received. */
        BLE_HS_DBG_ASSERT(rx_cb != NULL);
        BLE_HS_DBG_ASSERT(rx_buf != NULL);
        rc = rx_cb(handle, &rx_buf);
   1933a:	4630      	mov	r0, r6
   1933c:	a907      	add	r1, sp, #28
   1933e:	9b06      	ldr	r3, [sp, #24]
   19340:	4798      	blx	r3
        os_mbuf_free_chain(rx_buf);
   19342:	9807      	ldr	r0, [sp, #28]
   19344:	e001      	b.n	1934a <host_hci_data_rx+0x96>
    ble_hs_log_mbuf(om);
    BLE_HS_LOG(DEBUG, "\n");
#endif

    if (hci_hdr.hdh_len != OS_MBUF_PKTHDR(om)->omp_len) {
        rc = BLE_HS_EBADDATA;
   19346:	240a      	movs	r4, #10
    }

    return 0;

err:
    os_mbuf_free_chain(om);
   19348:	4628      	mov	r0, r5
   1934a:	f7f0 fe08 	bl	9f5e <os_mbuf_free_chain>
    return rc;
   1934e:	4620      	mov	r0, r4
   19350:	e000      	b.n	19354 <host_hci_data_rx+0xa0>

    default:
        goto err;
    }

    return 0;
   19352:	2000      	movs	r0, #0

err:
    os_mbuf_free_chain(om);
    return rc;
}
   19354:	b008      	add	sp, #32
   19356:	bd70      	pop	{r4, r5, r6, pc}
   19358:	20003b9c 	.word	0x20003b9c
   1935c:	000205e1 	.word	0x000205e1
   19360:	0001fdec 	.word	0x0001fdec

00019364 <host_hci_split_frag>:
 *                                  the original mbuf.
 *                              Other BLE host core return code on error.
 */
int
host_hci_split_frag(struct os_mbuf *om, struct os_mbuf **out_frag)
{
   19364:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19366:	4604      	mov	r4, r0
    struct os_mbuf *frag;
    int rc;

    if (OS_MBUF_PKTLEN(om) <= host_hci_buffer_sz) {
   19368:	4d0f      	ldr	r5, [pc, #60]	; (193a8 <host_hci_split_frag+0x44>)
   1936a:	8a23      	ldrh	r3, [r4, #16]
   1936c:	8828      	ldrh	r0, [r5, #0]
   1936e:	4283      	cmp	r3, r0
 *                                  the original mbuf.
 *                              Other BLE host core return code on error.
 */
int
host_hci_split_frag(struct os_mbuf *om, struct os_mbuf **out_frag)
{
   19370:	460f      	mov	r7, r1
    struct os_mbuf *frag;
    int rc;

    if (OS_MBUF_PKTLEN(om) <= host_hci_buffer_sz) {
   19372:	d802      	bhi.n	1937a <host_hci_split_frag+0x16>
        /* Final fragment. */
        *out_frag = om;
   19374:	600c      	str	r4, [r1, #0]
        return BLE_HS_EDONE;
   19376:	200e      	movs	r0, #14
   19378:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    frag = os_msys_get_pkthdr(host_hci_buffer_sz, 0);
   1937a:	2100      	movs	r1, #0
   1937c:	f7f0 fdd9 	bl	9f32 <os_msys_get_pkthdr>
    if (frag == NULL) {
   19380:	4606      	mov	r6, r0
   19382:	b160      	cbz	r0, 1939e <host_hci_split_frag+0x3a>
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    /* Move data from the front of the packet into the fragment mbuf. */
    rc = os_mbuf_appendfrom(frag, om, 0, host_hci_buffer_sz);
   19384:	4621      	mov	r1, r4
   19386:	2200      	movs	r2, #0
   19388:	882b      	ldrh	r3, [r5, #0]
   1938a:	f7f0 fe4e 	bl	a02a <os_mbuf_appendfrom>
    if (rc != 0) {
   1938e:	b930      	cbnz	r0, 1939e <host_hci_split_frag+0x3a>
        rc = BLE_HS_ENOMEM;
        goto err;
    }
    os_mbuf_adj(om, host_hci_buffer_sz);
   19390:	4620      	mov	r0, r4
   19392:	8829      	ldrh	r1, [r5, #0]
   19394:	f7f0 fe93 	bl	a0be <os_mbuf_adj>

    /* More fragments to follow. */
    *out_frag = frag;
   19398:	603e      	str	r6, [r7, #0]
    return BLE_HS_EAGAIN;
   1939a:	2001      	movs	r0, #1
   1939c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

err:
    os_mbuf_free_chain(frag);
   1939e:	4630      	mov	r0, r6
   193a0:	f7f0 fddd 	bl	9f5e <os_mbuf_free_chain>
    return rc;
   193a4:	2006      	movs	r0, #6
}
   193a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   193a8:	200023ba 	.word	0x200023ba

000193ac <host_hci_data_tx>:
 * XXX: Ensure the controller has sufficient buffer capacity for the outgoing
 * fragments.
 */
int
host_hci_data_tx(struct ble_hs_conn *connection, struct os_mbuf *om)
{
   193ac:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   193b0:	4606      	mov	r6, r0
   193b2:	460f      	mov	r7, r1

    /* The first fragment uses the first-non-flush packet boundary value.
     * After sending the first fragment, pb gets set appropriately for all
     * subsequent fragments in this packet.
     */
    pb = BLE_HCI_PB_FIRST_NON_FLUSH;
   193b4:	2500      	movs	r5, #0

    /* Send fragments until the entire packet has been sent. */
    done = 0;
    while (!done) {
        rc = host_hci_split_frag(om, &frag);
   193b6:	4638      	mov	r0, r7
   193b8:	a902      	add	r1, sp, #8
   193ba:	f7ff ffd3 	bl	19364 <host_hci_split_frag>
        switch (rc) {
   193be:	2801      	cmp	r0, #1
    pb = BLE_HCI_PB_FIRST_NON_FLUSH;

    /* Send fragments until the entire packet has been sent. */
    done = 0;
    while (!done) {
        rc = host_hci_split_frag(om, &frag);
   193c0:	4604      	mov	r4, r0
        switch (rc) {
   193c2:	d004      	beq.n	193ce <host_hci_data_tx+0x22>
   193c4:	280e      	cmp	r0, #14
   193c6:	d148      	bne.n	1945a <host_hci_data_tx+0xae>
        case BLE_HS_EDONE:
            /* This is the final fragment. */
            done = 1;
   193c8:	f04f 0801 	mov.w	r8, #1
   193cc:	e001      	b.n	193d2 <host_hci_data_tx+0x26>

    /* Send fragments until the entire packet has been sent. */
    done = 0;
    while (!done) {
        rc = host_hci_split_frag(om, &frag);
        switch (rc) {
   193ce:	f04f 0800 	mov.w	r8, #0

        default:
            goto err;
        }

        frag = host_hci_data_hdr_prepend(frag, connection->bhc_handle, pb);
   193d2:	9c02      	ldr	r4, [sp, #8]
   193d4:	f8b6 a004 	ldrh.w	sl, [r6, #4]
host_hci_data_hdr_prepend(struct os_mbuf *om, uint16_t handle, uint8_t pb_flag)
{
    struct hci_data_hdr hci_hdr;

    hci_hdr.hdh_handle_pb_bc = host_hci_handle_pb_bc_join(handle, pb_flag, 0);
    htole16(&hci_hdr.hdh_len, OS_MBUF_PKTHDR(om)->omp_len);
   193d8:	8a21      	ldrh	r1, [r4, #16]
static struct os_mbuf *
host_hci_data_hdr_prepend(struct os_mbuf *om, uint16_t handle, uint8_t pb_flag)
{
    struct hci_data_hdr hci_hdr;

    hci_hdr.hdh_handle_pb_bc = host_hci_handle_pb_bc_join(handle, pb_flag, 0);
   193da:	f10d 0910 	add.w	r9, sp, #16
    htole16(&hci_hdr.hdh_len, OS_MBUF_PKTHDR(om)->omp_len);
   193de:	f10d 000e 	add.w	r0, sp, #14
{
    BLE_HS_DBG_ASSERT(handle <= 0x0fff);
    BLE_HS_DBG_ASSERT(pb <= 0x03);
    BLE_HS_DBG_ASSERT(bc <= 0x03);

    return (handle  << 0)   |
   193e2:	ea4a 3505 	orr.w	r5, sl, r5, lsl #12
static struct os_mbuf *
host_hci_data_hdr_prepend(struct os_mbuf *om, uint16_t handle, uint8_t pb_flag)
{
    struct hci_data_hdr hci_hdr;

    hci_hdr.hdh_handle_pb_bc = host_hci_handle_pb_bc_join(handle, pb_flag, 0);
   193e6:	f829 5d04 	strh.w	r5, [r9, #-4]!
    htole16(&hci_hdr.hdh_len, OS_MBUF_PKTHDR(om)->omp_len);
   193ea:	f003 fe35 	bl	1d058 <htole16>

    om = os_mbuf_prepend(om, sizeof hci_hdr);
   193ee:	4620      	mov	r0, r4
   193f0:	2104      	movs	r1, #4
   193f2:	f7f0 fedc 	bl	a1ae <os_mbuf_prepend>
    if (om == NULL) {
   193f6:	4604      	mov	r4, r0
   193f8:	b180      	cbz	r0, 1941c <host_hci_data_tx+0x70>
        return NULL;
    }

    memcpy(om->om_data, &hci_hdr, sizeof hci_hdr);
   193fa:	6803      	ldr	r3, [r0, #0]
   193fc:	f8d9 0000 	ldr.w	r0, [r9]
   19400:	6018      	str	r0, [r3, #0]

    BLE_HS_LOG(DEBUG, "host tx hci data; handle=%d length=%d\n", handle,
   19402:	f10d 000e 	add.w	r0, sp, #14
   19406:	f003 fe42 	bl	1d08e <le16toh>
   1940a:	f8cd a000 	str.w	sl, [sp]
   1940e:	9001      	str	r0, [sp, #4]
   19410:	2104      	movs	r1, #4
   19412:	4815      	ldr	r0, [pc, #84]	; (19468 <host_hci_data_tx+0xbc>)
   19414:	4b15      	ldr	r3, [pc, #84]	; (1946c <host_hci_data_tx+0xc0>)
   19416:	2200      	movs	r2, #0
   19418:	f003 ff06 	bl	1d228 <log_printf>

        default:
            goto err;
        }

        frag = host_hci_data_hdr_prepend(frag, connection->bhc_handle, pb);
   1941c:	9402      	str	r4, [sp, #8]
        if (frag == NULL) {
   1941e:	b1dc      	cbz	r4, 19458 <host_hci_data_tx+0xac>
            rc = BLE_HS_ENOMEM;
            goto err;
        }
        pb = BLE_HCI_PB_MIDDLE;

        BLE_HS_LOG(DEBUG, "host_hci_data_tx(): ");
   19420:	2104      	movs	r1, #4
   19422:	2200      	movs	r2, #0
   19424:	4b12      	ldr	r3, [pc, #72]	; (19470 <host_hci_data_tx+0xc4>)
   19426:	4810      	ldr	r0, [pc, #64]	; (19468 <host_hci_data_tx+0xbc>)
   19428:	f003 fefe 	bl	1d228 <log_printf>
        ble_hs_log_mbuf(frag);
   1942c:	9802      	ldr	r0, [sp, #8]
   1942e:	f7fc f839 	bl	154a4 <ble_hs_log_mbuf>
        BLE_HS_LOG(DEBUG, "\n");
   19432:	480d      	ldr	r0, [pc, #52]	; (19468 <host_hci_data_tx+0xbc>)
   19434:	4b0f      	ldr	r3, [pc, #60]	; (19474 <host_hci_data_tx+0xc8>)
   19436:	2104      	movs	r1, #4
   19438:	2200      	movs	r2, #0
   1943a:	f003 fef5 	bl	1d228 <log_printf>

        rc = ble_hs_tx_data(frag);
   1943e:	9802      	ldr	r0, [sp, #8]
   19440:	f7fb fa50 	bl	148e4 <ble_hs_tx_data>
        if (rc != 0) {
   19444:	4604      	mov	r4, r0
   19446:	b940      	cbnz	r0, 1945a <host_hci_data_tx+0xae>
            goto err;
        }

        connection->bhc_outstanding_pkts++;
   19448:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
   1944a:	3301      	adds	r3, #1
   1944c:	85b3      	strh	r3, [r6, #44]	; 0x2c
        frag = host_hci_data_hdr_prepend(frag, connection->bhc_handle, pb);
        if (frag == NULL) {
            rc = BLE_HS_ENOMEM;
            goto err;
        }
        pb = BLE_HCI_PB_MIDDLE;
   1944e:	2501      	movs	r5, #1
     */
    pb = BLE_HCI_PB_FIRST_NON_FLUSH;

    /* Send fragments until the entire packet has been sent. */
    done = 0;
    while (!done) {
   19450:	f1b8 0f00 	cmp.w	r8, #0
   19454:	d0af      	beq.n	193b6 <host_hci_data_tx+0xa>
   19456:	e003      	b.n	19460 <host_hci_data_tx+0xb4>
            goto err;
        }

        frag = host_hci_data_hdr_prepend(frag, connection->bhc_handle, pb);
        if (frag == NULL) {
            rc = BLE_HS_ENOMEM;
   19458:	2406      	movs	r4, #6
    return 0;

err:
    BLE_HS_DBG_ASSERT(rc != 0);

    os_mbuf_free_chain(om);
   1945a:	4638      	mov	r0, r7
   1945c:	f7f0 fd7f 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   19460:	4620      	mov	r0, r4
   19462:	b004      	add	sp, #16
   19464:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   19468:	20003b9c 	.word	0x20003b9c
   1946c:	00020612 	.word	0x00020612
   19470:	00020639 	.word	0x00020639
   19474:	0001fdec 	.word	0x0001fdec

00019478 <host_hci_cmd_body_le_conn_update>:
}

static int
host_hci_cmd_body_le_conn_update(const struct hci_conn_update *hcu,
                                 uint8_t *dst)
{
   19478:	b538      	push	{r3, r4, r5, lr}
   1947a:	4604      	mov	r4, r0
   1947c:	460d      	mov	r5, r1
    /* XXX: add parameter checking later */
    htole16(dst + 0, hcu->handle);
   1947e:	4608      	mov	r0, r1
   19480:	8821      	ldrh	r1, [r4, #0]
   19482:	f003 fde9 	bl	1d058 <htole16>
    htole16(dst + 2, hcu->conn_itvl_min);
   19486:	1ca8      	adds	r0, r5, #2
   19488:	8861      	ldrh	r1, [r4, #2]
   1948a:	f003 fde5 	bl	1d058 <htole16>
    htole16(dst + 4, hcu->conn_itvl_max);
   1948e:	1d28      	adds	r0, r5, #4
   19490:	88a1      	ldrh	r1, [r4, #4]
   19492:	f003 fde1 	bl	1d058 <htole16>
    htole16(dst + 6, hcu->conn_latency);
   19496:	1da8      	adds	r0, r5, #6
   19498:	88e1      	ldrh	r1, [r4, #6]
   1949a:	f003 fddd 	bl	1d058 <htole16>
    htole16(dst + 8, hcu->supervision_timeout);
   1949e:	f105 0008 	add.w	r0, r5, #8
   194a2:	8921      	ldrh	r1, [r4, #8]
   194a4:	f003 fdd8 	bl	1d058 <htole16>
    htole16(dst + 10, hcu->min_ce_len);
   194a8:	f105 000a 	add.w	r0, r5, #10
   194ac:	8961      	ldrh	r1, [r4, #10]
   194ae:	f003 fdd3 	bl	1d058 <htole16>
    htole16(dst + 12, hcu->max_ce_len);
   194b2:	f105 000c 	add.w	r0, r5, #12
   194b6:	89a1      	ldrh	r1, [r4, #12]
   194b8:	f003 fdce 	bl	1d058 <htole16>

    return 0;
}
   194bc:	2000      	movs	r0, #0
   194be:	bd38      	pop	{r3, r4, r5, pc}

000194c0 <host_hci_cmd_send>:
    u8ptr[2] = len;
}

int
host_hci_cmd_send(uint8_t ogf, uint8_t ocf, uint8_t len, const void *cmddata)
{
   194c0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    int rc;

    htole16(host_hci_cmd_buf, ogf << 10 | ocf);
   194c4:	4d1e      	ldr	r5, [pc, #120]	; (19540 <host_hci_cmd_send+0x80>)
    u8ptr[2] = len;
}

int
host_hci_cmd_send(uint8_t ogf, uint8_t ocf, uint8_t len, const void *cmddata)
{
   194c6:	460e      	mov	r6, r1
    int rc;

    htole16(host_hci_cmd_buf, ogf << 10 | ocf);
   194c8:	ea41 2180 	orr.w	r1, r1, r0, lsl #10
    u8ptr[2] = len;
}

int
host_hci_cmd_send(uint8_t ogf, uint8_t ocf, uint8_t len, const void *cmddata)
{
   194cc:	4614      	mov	r4, r2
   194ce:	4607      	mov	r7, r0
    int rc;

    htole16(host_hci_cmd_buf, ogf << 10 | ocf);
   194d0:	b289      	uxth	r1, r1
   194d2:	4628      	mov	r0, r5
    u8ptr[2] = len;
}

int
host_hci_cmd_send(uint8_t ogf, uint8_t ocf, uint8_t len, const void *cmddata)
{
   194d4:	4698      	mov	r8, r3
    int rc;

    htole16(host_hci_cmd_buf, ogf << 10 | ocf);
   194d6:	f003 fdbf 	bl	1d058 <htole16>
    host_hci_cmd_buf[2] = len;
   194da:	70ac      	strb	r4, [r5, #2]
    if (len != 0) {
   194dc:	b124      	cbz	r4, 194e8 <host_hci_cmd_send+0x28>
        memcpy(host_hci_cmd_buf + BLE_HCI_CMD_HDR_LEN, cmddata, len);
   194de:	1ce8      	adds	r0, r5, #3
   194e0:	4641      	mov	r1, r8
   194e2:	4622      	mov	r2, r4
   194e4:	f7ef fd8a 	bl	8ffc <memcpy>
    }

    BLE_HS_LOG(DEBUG, "host_hci_cmd_send: ogf=0x%02x ocf=0x%02x len=%d\n",
   194e8:	2200      	movs	r2, #0
   194ea:	4b16      	ldr	r3, [pc, #88]	; (19544 <host_hci_cmd_send+0x84>)
   194ec:	4816      	ldr	r0, [pc, #88]	; (19548 <host_hci_cmd_send+0x88>)
   194ee:	9700      	str	r7, [sp, #0]
   194f0:	2104      	movs	r1, #4
   194f2:	9601      	str	r6, [sp, #4]
   194f4:	9402      	str	r4, [sp, #8]
   194f6:	f003 fe97 	bl	1d228 <log_printf>
               ogf, ocf, len);
    ble_hs_log_flat_buf(host_hci_cmd_buf, len + BLE_HCI_CMD_HDR_LEN);
   194fa:	4811      	ldr	r0, [pc, #68]	; (19540 <host_hci_cmd_send+0x80>)
   194fc:	1ce1      	adds	r1, r4, #3
   194fe:	f7fb fff1 	bl	154e4 <ble_hs_log_flat_buf>
    BLE_HS_LOG(DEBUG, "\n");
   19502:	4811      	ldr	r0, [pc, #68]	; (19548 <host_hci_cmd_send+0x88>)
   19504:	4b11      	ldr	r3, [pc, #68]	; (1954c <host_hci_cmd_send+0x8c>)
   19506:	2104      	movs	r1, #4
   19508:	2200      	movs	r2, #0
   1950a:	f003 fe8d 	bl	1d228 <log_printf>
    ble_hs_test_hci_txed(cmdbuf);
    return 0;
#else
    int rc;

    rc = ble_hci_transport_host_cmd_send(cmdbuf);
   1950e:	480c      	ldr	r0, [pc, #48]	; (19540 <host_hci_cmd_send+0x80>)
   19510:	f7f5 fe1a 	bl	f148 <ble_hci_transport_host_cmd_send>
    switch (rc) {
   19514:	b158      	cbz	r0, 1952e <host_hci_cmd_send+0x6e>

    case BLE_ERR_MEM_CAPACITY:
        return BLE_HS_ENOMEM_EVT;

    default:
        return BLE_HS_EUNKNOWN;
   19516:	2807      	cmp	r0, #7
   19518:	bf0c      	ite	eq
   1951a:	2414      	moveq	r4, #20
   1951c:	2411      	movne	r4, #17
    rc = host_hci_cmd_transport(host_hci_cmd_buf);

    if (rc == 0) {
        STATS_INC(ble_hs_stats, hci_cmd);
    } else {
        BLE_HS_LOG(DEBUG, "host_hci_cmd_send failure; rc=%d\n", rc);
   1951e:	9400      	str	r4, [sp, #0]
   19520:	4809      	ldr	r0, [pc, #36]	; (19548 <host_hci_cmd_send+0x88>)
   19522:	4b0b      	ldr	r3, [pc, #44]	; (19550 <host_hci_cmd_send+0x90>)
   19524:	2104      	movs	r1, #4
   19526:	2200      	movs	r2, #0
   19528:	f003 fe7e 	bl	1d228 <log_printf>
   1952c:	e004      	b.n	19538 <host_hci_cmd_send+0x78>
    ble_hs_log_flat_buf(host_hci_cmd_buf, len + BLE_HCI_CMD_HDR_LEN);
    BLE_HS_LOG(DEBUG, "\n");
    rc = host_hci_cmd_transport(host_hci_cmd_buf);

    if (rc == 0) {
        STATS_INC(ble_hs_stats, hci_cmd);
   1952e:	4a09      	ldr	r2, [pc, #36]	; (19554 <host_hci_cmd_send+0x94>)
   19530:	6953      	ldr	r3, [r2, #20]
   19532:	3301      	adds	r3, #1
   19534:	6153      	str	r3, [r2, #20]
    int rc;

    rc = ble_hci_transport_host_cmd_send(cmdbuf);
    switch (rc) {
    case 0:
        return 0;
   19536:	4604      	mov	r4, r0
    } else {
        BLE_HS_LOG(DEBUG, "host_hci_cmd_send failure; rc=%d\n", rc);
    }

    return rc;
}
   19538:	4620      	mov	r0, r4
   1953a:	b004      	add	sp, #16
   1953c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19540:	20003c10 	.word	0x20003c10
   19544:	000206b0 	.word	0x000206b0
   19548:	20003b9c 	.word	0x20003b9c
   1954c:	0001fdec 	.word	0x0001fdec
   19550:	000206e1 	.word	0x000206e1
   19554:	20003b1c 	.word	0x20003b1c

00019558 <host_hci_cmd_send_buf>:

int
host_hci_cmd_send_buf(void *buf)
{
   19558:	b510      	push	{r4, lr}
   1955a:	4604      	mov	r4, r0
    uint8_t len;
    int rc;

    u8ptr = buf;

    opcode = le16toh(u8ptr + 0);
   1955c:	f003 fd97 	bl	1d08e <le16toh>
   19560:	4601      	mov	r1, r0
    len = u8ptr[2];

    rc = host_hci_cmd_send(BLE_HCI_OGF(opcode), BLE_HCI_OCF(opcode), len,
   19562:	78a2      	ldrb	r2, [r4, #2]
   19564:	1ce3      	adds	r3, r4, #3
   19566:	f3c0 2085 	ubfx	r0, r0, #10, #6
   1956a:	b2c9      	uxtb	r1, r1
                           u8ptr + BLE_HCI_CMD_HDR_LEN);
    return rc;
}
   1956c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    u8ptr = buf;

    opcode = le16toh(u8ptr + 0);
    len = u8ptr[2];

    rc = host_hci_cmd_send(BLE_HCI_OGF(opcode), BLE_HCI_OCF(opcode), len,
   19570:	f7ff bfa6 	b.w	194c0 <host_hci_cmd_send>

00019574 <host_hci_cmd_build_le_set_adv_params>:
}

int
host_hci_cmd_build_le_set_adv_params(const struct hci_adv_params *adv,
                                     uint8_t *dst, int dst_len)
{
   19574:	b538      	push	{r3, r4, r5, lr}
   19576:	4604      	mov	r4, r0
   19578:	460d      	mov	r5, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1957a:	4608      	mov	r0, r1
   1957c:	f242 0106 	movw	r1, #8198	; 0x2006
   19580:	f003 fd6a 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19584:	230f      	movs	r3, #15
   19586:	70ab      	strb	r3, [r5, #2]
    uint16_t itvl;

    BLE_HS_DBG_ASSERT(adv != NULL);

    /* Make sure parameters are valid */
    if ((adv->adv_itvl_min > adv->adv_itvl_max) ||
   19588:	88e1      	ldrh	r1, [r4, #6]
   1958a:	8923      	ldrh	r3, [r4, #8]
   1958c:	428b      	cmp	r3, r1
   1958e:	d337      	bcc.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
   19590:	78a3      	ldrb	r3, [r4, #2]
   19592:	2b03      	cmp	r3, #3
   19594:	d834      	bhi.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
        (adv->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) ||
   19596:	78e3      	ldrb	r3, [r4, #3]
   19598:	2b01      	cmp	r3, #1
   1959a:	d831      	bhi.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
        (adv->peer_addr_type > BLE_HCI_ADV_PEER_ADDR_MAX) ||
   1959c:	7923      	ldrb	r3, [r4, #4]
   1959e:	2b03      	cmp	r3, #3
   195a0:	d82e      	bhi.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
        (adv->adv_filter_policy > BLE_HCI_ADV_FILT_MAX) ||
        (adv->adv_type > BLE_HCI_ADV_TYPE_MAX) ||
   195a2:	7823      	ldrb	r3, [r4, #0]

    /* Make sure parameters are valid */
    if ((adv->adv_itvl_min > adv->adv_itvl_max) ||
        (adv->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) ||
        (adv->peer_addr_type > BLE_HCI_ADV_PEER_ADDR_MAX) ||
        (adv->adv_filter_policy > BLE_HCI_ADV_FILT_MAX) ||
   195a4:	2b04      	cmp	r3, #4
   195a6:	d82b      	bhi.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
        (adv->adv_type > BLE_HCI_ADV_TYPE_MAX) ||
        (adv->adv_channel_map == 0) ||
   195a8:	7862      	ldrb	r2, [r4, #1]
    /* Make sure parameters are valid */
    if ((adv->adv_itvl_min > adv->adv_itvl_max) ||
        (adv->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) ||
        (adv->peer_addr_type > BLE_HCI_ADV_PEER_ADDR_MAX) ||
        (adv->adv_filter_policy > BLE_HCI_ADV_FILT_MAX) ||
        (adv->adv_type > BLE_HCI_ADV_TYPE_MAX) ||
   195aa:	b34a      	cbz	r2, 19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
        (adv->adv_channel_map == 0) ||
   195ac:	f012 0ff8 	tst.w	r2, #248	; 0xf8
   195b0:	d126      	bne.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
        /* These parameters are not valid */
        return -1;
    }

    /* Make sure interval is valid for advertising type. */
    if ((adv->adv_type == BLE_HCI_ADV_TYPE_ADV_NONCONN_IND) ||
   195b2:	1e9a      	subs	r2, r3, #2
   195b4:	2a01      	cmp	r2, #1
   195b6:	d903      	bls.n	195c0 <host_hci_cmd_build_le_set_adv_params+0x4c>
    } else {
        itvl = BLE_HCI_ADV_ITVL_MIN;
    }

    /* Do not check if high duty-cycle directed */
    if (adv->adv_type != BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
   195b8:	2b01      	cmp	r3, #1
   195ba:	d007      	beq.n	195cc <host_hci_cmd_build_le_set_adv_params+0x58>
    /* Make sure interval is valid for advertising type. */
    if ((adv->adv_type == BLE_HCI_ADV_TYPE_ADV_NONCONN_IND) ||
        (adv->adv_type == BLE_HCI_ADV_TYPE_ADV_SCAN_IND)) {
        itvl = BLE_HCI_ADV_ITVL_NONCONN_MIN;
    } else {
        itvl = BLE_HCI_ADV_ITVL_MIN;
   195bc:	2320      	movs	r3, #32
   195be:	e000      	b.n	195c2 <host_hci_cmd_build_le_set_adv_params+0x4e>
    }

    /* Make sure interval is valid for advertising type. */
    if ((adv->adv_type == BLE_HCI_ADV_TYPE_ADV_NONCONN_IND) ||
        (adv->adv_type == BLE_HCI_ADV_TYPE_ADV_SCAN_IND)) {
        itvl = BLE_HCI_ADV_ITVL_NONCONN_MIN;
   195c0:	23a0      	movs	r3, #160	; 0xa0
        itvl = BLE_HCI_ADV_ITVL_MIN;
    }

    /* Do not check if high duty-cycle directed */
    if (adv->adv_type != BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
        if ((adv->adv_itvl_min < itvl) ||
   195c2:	4299      	cmp	r1, r3
   195c4:	d31c      	bcc.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
   195c6:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   195ca:	d819      	bhi.n	19600 <host_hci_cmd_build_le_set_adv_params+0x8c>
            (adv->adv_itvl_min > BLE_HCI_ADV_ITVL_MAX)) {
            return -1;
        }
    }

    htole16(dst, adv->adv_itvl_min);
   195cc:	1ce8      	adds	r0, r5, #3
   195ce:	f003 fd43 	bl	1d058 <htole16>
    htole16(dst + 2, adv->adv_itvl_max);
   195d2:	1d68      	adds	r0, r5, #5
   195d4:	8921      	ldrh	r1, [r4, #8]
   195d6:	f003 fd3f 	bl	1d058 <htole16>
    dst[4] = adv->adv_type;
   195da:	7823      	ldrb	r3, [r4, #0]
   195dc:	71eb      	strb	r3, [r5, #7]
    dst[5] = adv->own_addr_type;
   195de:	78a3      	ldrb	r3, [r4, #2]
   195e0:	722b      	strb	r3, [r5, #8]
    dst[6] = adv->peer_addr_type;
   195e2:	78e3      	ldrb	r3, [r4, #3]
   195e4:	726b      	strb	r3, [r5, #9]
    memcpy(dst + 7, adv->peer_addr, BLE_DEV_ADDR_LEN);
   195e6:	4623      	mov	r3, r4
    rc = host_hci_cmd_body_le_set_adv_params(adv, dst);
    if (rc != 0) {
        return rc;
    }

    return 0;
   195e8:	2000      	movs	r0, #0
    htole16(dst, adv->adv_itvl_min);
    htole16(dst + 2, adv->adv_itvl_max);
    dst[4] = adv->adv_type;
    dst[5] = adv->own_addr_type;
    dst[6] = adv->peer_addr_type;
    memcpy(dst + 7, adv->peer_addr, BLE_DEV_ADDR_LEN);
   195ea:	f853 2f0a 	ldr.w	r2, [r3, #10]!
   195ee:	f8c5 200a 	str.w	r2, [r5, #10]
   195f2:	889b      	ldrh	r3, [r3, #4]
   195f4:	81eb      	strh	r3, [r5, #14]
    dst[13] = adv->adv_channel_map;
   195f6:	7863      	ldrb	r3, [r4, #1]
   195f8:	742b      	strb	r3, [r5, #16]
    dst[14] = adv->adv_filter_policy;
   195fa:	7923      	ldrb	r3, [r4, #4]
   195fc:	746b      	strb	r3, [r5, #17]
   195fe:	bd38      	pop	{r3, r4, r5, pc}
        itvl = BLE_HCI_ADV_ITVL_MIN;
    }

    /* Do not check if high duty-cycle directed */
    if (adv->adv_type != BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD) {
        if ((adv->adv_itvl_min < itvl) ||
   19600:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   19604:	bd38      	pop	{r3, r4, r5, pc}

00019606 <host_hci_cmd_build_le_set_adv_data>:
 * @return int
 */
int
host_hci_cmd_build_le_set_adv_data(const uint8_t *data, uint8_t len,
                                   uint8_t *dst, int dst_len)
{
   19606:	b570      	push	{r4, r5, r6, lr}
   19608:	4614      	mov	r4, r2
   1960a:	4606      	mov	r6, r0
   1960c:	460d      	mov	r5, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1960e:	4610      	mov	r0, r2
   19610:	f242 0108 	movw	r1, #8200	; 0x2008
   19614:	f003 fd20 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19618:	2320      	movs	r3, #32
   1961a:	70a3      	strb	r3, [r4, #2]
static int
host_hci_cmd_body_le_set_adv_data(const uint8_t *data, uint8_t len,
                                  uint8_t *dst)
{
    /* Check for valid parameters */
    if (((data == NULL) && (len != 0)) || (len > BLE_HCI_MAX_ADV_DATA_LEN)) {
   1961c:	b90e      	cbnz	r6, 19622 <host_hci_cmd_build_le_set_adv_data+0x1c>
   1961e:	b97d      	cbnz	r5, 19640 <host_hci_cmd_build_le_set_adv_data+0x3a>
   19620:	e001      	b.n	19626 <host_hci_cmd_build_le_set_adv_data+0x20>
   19622:	2d1f      	cmp	r5, #31
   19624:	d80c      	bhi.n	19640 <host_hci_cmd_build_le_set_adv_data+0x3a>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    memset(dst, 0, BLE_HCI_SET_ADV_DATA_LEN);
   19626:	1ce0      	adds	r0, r4, #3
   19628:	2100      	movs	r1, #0
   1962a:	2220      	movs	r2, #32
   1962c:	f7ef fcf1 	bl	9012 <memset>
    dst[0] = len;
   19630:	70e5      	strb	r5, [r4, #3]
    memcpy(dst + 1, data, len);
   19632:	1d20      	adds	r0, r4, #4
   19634:	4631      	mov	r1, r6
   19636:	462a      	mov	r2, r5
   19638:	f7ef fce0 	bl	8ffc <memcpy>
    rc = host_hci_cmd_body_le_set_adv_data(data, len, dst);
    if (rc != 0) {
        return rc;
    }

    return 0;
   1963c:	2000      	movs	r0, #0
   1963e:	bd70      	pop	{r4, r5, r6, pc}
static int
host_hci_cmd_body_le_set_adv_data(const uint8_t *data, uint8_t len,
                                  uint8_t *dst)
{
    /* Check for valid parameters */
    if (((data == NULL) && (len != 0)) || (len > BLE_HCI_MAX_ADV_DATA_LEN)) {
   19640:	2012      	movs	r0, #18
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   19642:	bd70      	pop	{r4, r5, r6, pc}

00019644 <host_hci_cmd_build_le_set_scan_rsp_data>:
}

int
host_hci_cmd_build_le_set_scan_rsp_data(const uint8_t *data, uint8_t len,
                                        uint8_t *dst, int dst_len)
{
   19644:	b570      	push	{r4, r5, r6, lr}
   19646:	4614      	mov	r4, r2
   19648:	4606      	mov	r6, r0
   1964a:	460d      	mov	r5, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1964c:	4610      	mov	r0, r2
   1964e:	f242 0109 	movw	r1, #8201	; 0x2009
   19652:	f003 fd01 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19656:	2320      	movs	r3, #32
   19658:	70a3      	strb	r3, [r4, #2]
static int
host_hci_cmd_body_le_set_scan_rsp_data(const uint8_t *data, uint8_t len,
                                       uint8_t *dst)
{
    /* Check for valid parameters */
    if (((data == NULL) && (len != 0)) ||
   1965a:	b90e      	cbnz	r6, 19660 <host_hci_cmd_build_le_set_scan_rsp_data+0x1c>
   1965c:	b97d      	cbnz	r5, 1967e <host_hci_cmd_build_le_set_scan_rsp_data+0x3a>
   1965e:	e001      	b.n	19664 <host_hci_cmd_build_le_set_scan_rsp_data+0x20>
   19660:	2d1f      	cmp	r5, #31
   19662:	d80c      	bhi.n	1967e <host_hci_cmd_build_le_set_scan_rsp_data+0x3a>
         (len > BLE_HCI_MAX_SCAN_RSP_DATA_LEN)) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    memset(dst, 0, BLE_HCI_SET_SCAN_RSP_DATA_LEN);
   19664:	1ce0      	adds	r0, r4, #3
   19666:	2100      	movs	r1, #0
   19668:	2220      	movs	r2, #32
   1966a:	f7ef fcd2 	bl	9012 <memset>
    dst[0] = len;
   1966e:	70e5      	strb	r5, [r4, #3]
    memcpy(dst + 1, data, len);
   19670:	1d20      	adds	r0, r4, #4
   19672:	4631      	mov	r1, r6
   19674:	462a      	mov	r2, r5
   19676:	f7ef fcc1 	bl	8ffc <memcpy>
    rc = host_hci_cmd_body_le_set_scan_rsp_data(data, len, dst);
    if (rc != 0) {
        return rc;
    }

    return 0;
   1967a:	2000      	movs	r0, #0
   1967c:	bd70      	pop	{r4, r5, r6, pc}
static int
host_hci_cmd_body_le_set_scan_rsp_data(const uint8_t *data, uint8_t len,
                                       uint8_t *dst)
{
    /* Check for valid parameters */
    if (((data == NULL) && (len != 0)) ||
   1967e:	2012      	movs	r0, #18
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   19680:	bd70      	pop	{r4, r5, r6, pc}

00019682 <host_hci_cmd_build_set_event_mask>:
}

void
host_hci_cmd_build_set_event_mask(uint64_t event_mask,
                                  uint8_t *dst, int dst_len)
{
   19682:	b5d0      	push	{r4, r6, r7, lr}
   19684:	4614      	mov	r4, r2
   19686:	4606      	mov	r6, r0
   19688:	460f      	mov	r7, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1968a:	4610      	mov	r0, r2
   1968c:	f640 4101 	movw	r1, #3073	; 0xc01
   19690:	f003 fce2 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19694:	2308      	movs	r3, #8
   19696:	70a3      	strb	r3, [r4, #2]
}

static void
host_hci_cmd_body_set_event_mask(uint64_t event_mask, uint8_t *dst)
{
    htole64(dst, event_mask);
   19698:	1ce0      	adds	r0, r4, #3
   1969a:	4632      	mov	r2, r6
   1969c:	463b      	mov	r3, r7
                       BLE_HCI_OCF_CB_SET_EVENT_MASK,
                       BLE_HCI_SET_EVENT_MASK_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    host_hci_cmd_body_set_event_mask(event_mask, dst);
}
   1969e:	e8bd 40d0 	ldmia.w	sp!, {r4, r6, r7, lr}
}

static void
host_hci_cmd_body_set_event_mask(uint64_t event_mask, uint8_t *dst)
{
    htole64(dst, event_mask);
   196a2:	f003 bce5 	b.w	1d070 <htole64>

000196a6 <host_hci_cmd_build_set_event_mask2>:
}

void
host_hci_cmd_build_set_event_mask2(uint64_t event_mask,
                                   uint8_t *dst, int dst_len)
{
   196a6:	b5d0      	push	{r4, r6, r7, lr}
   196a8:	4614      	mov	r4, r2
   196aa:	4606      	mov	r6, r0
   196ac:	460f      	mov	r7, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   196ae:	4610      	mov	r0, r2
   196b0:	f640 4163 	movw	r1, #3171	; 0xc63
   196b4:	f003 fcd0 	bl	1d058 <htole16>
    u8ptr[2] = len;
   196b8:	2308      	movs	r3, #8
   196ba:	70a3      	strb	r3, [r4, #2]
}

static void
host_hci_cmd_body_set_event_mask(uint64_t event_mask, uint8_t *dst)
{
    htole64(dst, event_mask);
   196bc:	1ce0      	adds	r0, r4, #3
   196be:	4632      	mov	r2, r6
   196c0:	463b      	mov	r3, r7
                       BLE_HCI_OCF_CB_SET_EVENT_MASK2,
                       BLE_HCI_SET_EVENT_MASK_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    host_hci_cmd_body_set_event_mask(event_mask, dst);
}
   196c2:	e8bd 40d0 	ldmia.w	sp!, {r4, r6, r7, lr}
}

static void
host_hci_cmd_body_set_event_mask(uint64_t event_mask, uint8_t *dst)
{
    htole64(dst, event_mask);
   196c6:	f003 bcd3 	b.w	1d070 <htole64>

000196ca <host_hci_cmd_build_disconnect>:
}

void
host_hci_cmd_build_disconnect(uint16_t handle, uint8_t reason,
                              uint8_t *dst, int dst_len)
{
   196ca:	b570      	push	{r4, r5, r6, lr}
   196cc:	4614      	mov	r4, r2
   196ce:	4606      	mov	r6, r0
   196d0:	460d      	mov	r5, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   196d2:	4610      	mov	r0, r2
   196d4:	f240 4106 	movw	r1, #1030	; 0x406
   196d8:	f003 fcbe 	bl	1d058 <htole16>
    u8ptr[2] = len;
   196dc:	2303      	movs	r3, #3
   196de:	70a3      	strb	r3, [r4, #2]
}

static void
host_hci_cmd_body_disconnect(uint16_t handle, uint8_t reason, uint8_t *dst)
{
    htole16(dst + 0, handle);
   196e0:	18e0      	adds	r0, r4, r3
   196e2:	4631      	mov	r1, r6
   196e4:	f003 fcb8 	bl	1d058 <htole16>
    dst[2] = reason;
   196e8:	7165      	strb	r5, [r4, #5]
   196ea:	bd70      	pop	{r4, r5, r6, pc}

000196ec <host_hci_cmd_build_le_set_event_mask>:
}

void
host_hci_cmd_build_le_set_event_mask(uint64_t event_mask,
                                     uint8_t *dst, int dst_len)
{
   196ec:	b5d0      	push	{r4, r6, r7, lr}
   196ee:	4614      	mov	r4, r2
   196f0:	4606      	mov	r6, r0
   196f2:	460f      	mov	r7, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   196f4:	4610      	mov	r0, r2
   196f6:	f242 0101 	movw	r1, #8193	; 0x2001
   196fa:	f003 fcad 	bl	1d058 <htole16>
    u8ptr[2] = len;
   196fe:	2308      	movs	r3, #8
   19700:	70a3      	strb	r3, [r4, #2]
}

static void
host_hci_cmd_body_le_set_event_mask(uint64_t event_mask, uint8_t *dst)
{
    htole64(dst, event_mask);
   19702:	1ce0      	adds	r0, r4, #3
   19704:	4632      	mov	r2, r6
   19706:	463b      	mov	r3, r7
                       BLE_HCI_OCF_LE_SET_EVENT_MASK,
                       BLE_HCI_SET_LE_EVENT_MASK_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    host_hci_cmd_body_le_set_event_mask(event_mask, dst);
}
   19708:	e8bd 40d0 	ldmia.w	sp!, {r4, r6, r7, lr}
}

static void
host_hci_cmd_body_le_set_event_mask(uint64_t event_mask, uint8_t *dst)
{
    htole64(dst, event_mask);
   1970c:	f003 bcb0 	b.w	1d070 <htole64>

00019710 <host_hci_cmd_build_le_read_buffer_size>:
 *
 * @return int
 */
void
host_hci_cmd_build_le_read_buffer_size(uint8_t *dst, int dst_len)
{
   19710:	b510      	push	{r4, lr}
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19712:	f242 0102 	movw	r1, #8194	; 0x2002
 *
 * @return int
 */
void
host_hci_cmd_build_le_read_buffer_size(uint8_t *dst, int dst_len)
{
   19716:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19718:	f003 fc9e 	bl	1d058 <htole16>
    u8ptr[2] = len;
   1971c:	2300      	movs	r3, #0
   1971e:	70a3      	strb	r3, [r4, #2]
   19720:	bd10      	pop	{r4, pc}

00019722 <host_hci_cmd_build_le_read_loc_supp_feat>:
/**
 * OGF=LE, OCF=0x0003
 */
void
host_hci_cmd_build_le_read_loc_supp_feat(uint8_t *dst, uint8_t dst_len)
{
   19722:	b510      	push	{r4, lr}
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19724:	f242 0103 	movw	r1, #8195	; 0x2003
/**
 * OGF=LE, OCF=0x0003
 */
void
host_hci_cmd_build_le_read_loc_supp_feat(uint8_t *dst, uint8_t dst_len)
{
   19728:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1972a:	f003 fc95 	bl	1d058 <htole16>
    u8ptr[2] = len;
   1972e:	2300      	movs	r3, #0
   19730:	70a3      	strb	r3, [r4, #2]
   19732:	bd10      	pop	{r4, pc}

00019734 <host_hci_cmd_build_le_set_adv_enable>:
}

void
host_hci_cmd_build_le_set_adv_enable(uint8_t enable, uint8_t *dst,
                                     int dst_len)
{
   19734:	b538      	push	{r3, r4, r5, lr}
   19736:	460c      	mov	r4, r1
   19738:	4605      	mov	r5, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1973a:	4608      	mov	r0, r1
   1973c:	f242 010a 	movw	r1, #8202	; 0x200a
   19740:	f003 fc8a 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19744:	2301      	movs	r3, #1
   19746:	70a3      	strb	r3, [r4, #2]
}

static void
host_hci_cmd_body_le_set_adv_enable(uint8_t enable, uint8_t *dst)
{
    dst[0] = enable;
   19748:	70e5      	strb	r5, [r4, #3]
   1974a:	bd38      	pop	{r3, r4, r5, pc}

0001974c <host_hci_cmd_build_le_set_scan_enable>:
}

void
host_hci_cmd_build_le_set_scan_enable(uint8_t enable, uint8_t filter_dups,
                                      uint8_t *dst, uint8_t dst_len)
{
   1974c:	b570      	push	{r4, r5, r6, lr}
   1974e:	4614      	mov	r4, r2
   19750:	4606      	mov	r6, r0
   19752:	460d      	mov	r5, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19754:	4610      	mov	r0, r2
   19756:	f242 010c 	movw	r1, #8204	; 0x200c
   1975a:	f003 fc7d 	bl	1d058 <htole16>
    u8ptr[2] = len;
   1975e:	2302      	movs	r3, #2
   19760:	70a3      	strb	r3, [r4, #2]

static void
host_hci_cmd_body_le_set_scan_enable(uint8_t enable, uint8_t filter_dups,
                                     uint8_t *dst)
{
    dst[0] = enable;
   19762:	70e6      	strb	r6, [r4, #3]
    dst[1] = filter_dups;
   19764:	7125      	strb	r5, [r4, #4]
   19766:	bd70      	pop	{r4, r5, r6, pc}

00019768 <host_hci_cmd_build_reset>:
    return 0;
}

void
host_hci_cmd_build_reset(uint8_t *dst, int dst_len)
{
   19768:	b510      	push	{r4, lr}
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1976a:	f640 4103 	movw	r1, #3075	; 0xc03
    return 0;
}

void
host_hci_cmd_build_reset(uint8_t *dst, int dst_len)
{
   1976e:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19770:	f003 fc72 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19774:	2300      	movs	r3, #0
   19776:	70a3      	strb	r3, [r4, #2]
   19778:	bd10      	pop	{r4, pc}

0001977a <host_hci_cmd_build_read_adv_pwr>:
    return rc;
}

void
host_hci_cmd_build_read_adv_pwr(uint8_t *dst, int dst_len)
{
   1977a:	b510      	push	{r4, lr}
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1977c:	f242 0107 	movw	r1, #8199	; 0x2007
    return rc;
}

void
host_hci_cmd_build_read_adv_pwr(uint8_t *dst, int dst_len)
{
   19780:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19782:	f003 fc69 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19786:	2300      	movs	r3, #0
   19788:	70a3      	strb	r3, [r4, #2]
   1978a:	bd10      	pop	{r4, pc}

0001978c <host_hci_cmd_build_le_create_conn_cancel>:
    return rc;
}

void
host_hci_cmd_build_le_create_conn_cancel(uint8_t *dst, int dst_len)
{
   1978c:	b510      	push	{r4, lr}
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1978e:	f242 010e 	movw	r1, #8206	; 0x200e
    return rc;
}

void
host_hci_cmd_build_le_create_conn_cancel(uint8_t *dst, int dst_len)
{
   19792:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19794:	f003 fc60 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19798:	2300      	movs	r3, #0
   1979a:	70a3      	strb	r3, [r4, #2]
   1979c:	bd10      	pop	{r4, pc}

0001979e <host_hci_cmd_build_le_conn_update>:
}

int
host_hci_cmd_build_le_conn_update(const struct hci_conn_update *hcu,
                                  uint8_t *dst, int dst_len)
{
   1979e:	b538      	push	{r3, r4, r5, lr}
   197a0:	460c      	mov	r4, r1
   197a2:	4605      	mov	r5, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   197a4:	4608      	mov	r0, r1
   197a6:	f242 0113 	movw	r1, #8211	; 0x2013
   197aa:	f003 fc55 	bl	1d058 <htole16>
    u8ptr[2] = len;
   197ae:	230e      	movs	r3, #14
   197b0:	70a3      	strb	r3, [r4, #2]

    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CONN_UPDATE,
                       BLE_HCI_CONN_UPDATE_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    rc = host_hci_cmd_body_le_conn_update(hcu, dst);
   197b2:	4628      	mov	r0, r5
   197b4:	1ce1      	adds	r1, r4, #3
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   197b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CONN_UPDATE,
                       BLE_HCI_CONN_UPDATE_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    rc = host_hci_cmd_body_le_conn_update(hcu, dst);
   197ba:	f7ff be5d 	b.w	19478 <host_hci_cmd_body_le_conn_update>

000197be <host_hci_cmd_build_le_lt_key_req_reply>:
 * @return int
 */
void
host_hci_cmd_build_le_lt_key_req_reply(const struct hci_lt_key_req_reply *hkr,
                                       uint8_t *dst, int dst_len)
{
   197be:	b570      	push	{r4, r5, r6, lr}
   197c0:	460c      	mov	r4, r1
   197c2:	4606      	mov	r6, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   197c4:	4608      	mov	r0, r1
   197c6:	f242 011a 	movw	r1, #8218	; 0x201a
   197ca:	f003 fc45 	bl	1d058 <htole16>

static void
host_hci_cmd_body_le_lt_key_req_reply(const struct hci_lt_key_req_reply *hkr,
                                      uint8_t *dst)
{
    htole16(dst + 0, hkr->conn_handle);
   197ce:	4635      	mov	r5, r6

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
    u8ptr[2] = len;
   197d0:	2312      	movs	r3, #18
   197d2:	70a3      	strb	r3, [r4, #2]

static void
host_hci_cmd_body_le_lt_key_req_reply(const struct hci_lt_key_req_reply *hkr,
                                      uint8_t *dst)
{
    htole16(dst + 0, hkr->conn_handle);
   197d4:	1ce0      	adds	r0, r4, #3
   197d6:	f835 1b02 	ldrh.w	r1, [r5], #2
   197da:	f003 fc3d 	bl	1d058 <htole16>
    memcpy(dst + 2, hkr->long_term_key, sizeof hkr->long_term_key);
   197de:	3405      	adds	r4, #5
   197e0:	3612      	adds	r6, #18
   197e2:	f855 3b04 	ldr.w	r3, [r5], #4
   197e6:	f844 3b04 	str.w	r3, [r4], #4
   197ea:	42b5      	cmp	r5, r6
   197ec:	d1f9      	bne.n	197e2 <host_hci_cmd_build_le_lt_key_req_reply+0x24>
    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY,
                       BLE_HCI_LT_KEY_REQ_REPLY_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    host_hci_cmd_body_le_lt_key_req_reply(hkr, dst);
}
   197ee:	bd70      	pop	{r4, r5, r6, pc}

000197f0 <host_hci_cmd_build_le_lt_key_req_neg_reply>:

void
host_hci_cmd_build_le_lt_key_req_neg_reply(uint16_t conn_handle,
                                           uint8_t *dst, int dst_len)
{
   197f0:	b538      	push	{r3, r4, r5, lr}
   197f2:	460c      	mov	r4, r1
   197f4:	4605      	mov	r5, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   197f6:	4608      	mov	r0, r1
   197f8:	f242 011b 	movw	r1, #8219	; 0x201b
   197fc:	f003 fc2c 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19800:	2302      	movs	r3, #2
   19802:	70a3      	strb	r3, [r4, #2]

    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY,
                       BLE_HCI_LT_KEY_REQ_NEG_REPLY_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    htole16(dst + 0, conn_handle);
   19804:	1ce0      	adds	r0, r4, #3
   19806:	4629      	mov	r1, r5
}
   19808:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY,
                       BLE_HCI_LT_KEY_REQ_NEG_REPLY_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    htole16(dst + 0, conn_handle);
   1980c:	f003 bc24 	b.w	1d058 <htole16>

00019810 <host_hci_cmd_build_le_conn_param_reply>:
}

void
host_hci_cmd_build_le_conn_param_reply(const struct hci_conn_param_reply *hcr,
                                       uint8_t *dst, int dst_len)
{
   19810:	b538      	push	{r3, r4, r5, lr}
   19812:	460c      	mov	r4, r1
   19814:	4605      	mov	r5, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19816:	4608      	mov	r0, r1
   19818:	f242 0120 	movw	r1, #8224	; 0x2020
   1981c:	f003 fc1c 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19820:	230e      	movs	r3, #14
   19822:	70a3      	strb	r3, [r4, #2]

static void
host_hci_cmd_body_le_conn_param_reply(const struct hci_conn_param_reply *hcr,
                                      uint8_t *dst)
{
    htole16(dst + 0, hcr->handle);
   19824:	1ce0      	adds	r0, r4, #3
   19826:	8829      	ldrh	r1, [r5, #0]
   19828:	f003 fc16 	bl	1d058 <htole16>
    htole16(dst + 2, hcr->conn_itvl_min);
   1982c:	1d60      	adds	r0, r4, #5
   1982e:	8869      	ldrh	r1, [r5, #2]
   19830:	f003 fc12 	bl	1d058 <htole16>
    htole16(dst + 4, hcr->conn_itvl_max);
   19834:	1de0      	adds	r0, r4, #7
   19836:	88a9      	ldrh	r1, [r5, #4]
   19838:	f003 fc0e 	bl	1d058 <htole16>
    htole16(dst + 6, hcr->conn_latency);
   1983c:	f104 0009 	add.w	r0, r4, #9
   19840:	88e9      	ldrh	r1, [r5, #6]
   19842:	f003 fc09 	bl	1d058 <htole16>
    htole16(dst + 8, hcr->supervision_timeout);
   19846:	f104 000b 	add.w	r0, r4, #11
   1984a:	8929      	ldrh	r1, [r5, #8]
   1984c:	f003 fc04 	bl	1d058 <htole16>
    htole16(dst + 10, hcr->min_ce_len);
   19850:	f104 000d 	add.w	r0, r4, #13
   19854:	8969      	ldrh	r1, [r5, #10]
   19856:	f003 fbff 	bl	1d058 <htole16>
    htole16(dst + 12, hcr->max_ce_len);
   1985a:	f104 000f 	add.w	r0, r4, #15
   1985e:	89a9      	ldrh	r1, [r5, #12]
    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REM_CONN_PARAM_RR,
                       BLE_HCI_CONN_PARAM_REPLY_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    host_hci_cmd_body_le_conn_param_reply(hcr, dst);
}
   19860:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    htole16(dst + 2, hcr->conn_itvl_min);
    htole16(dst + 4, hcr->conn_itvl_max);
    htole16(dst + 6, hcr->conn_latency);
    htole16(dst + 8, hcr->supervision_timeout);
    htole16(dst + 10, hcr->min_ce_len);
    htole16(dst + 12, hcr->max_ce_len);
   19864:	f003 bbf8 	b.w	1d058 <htole16>

00019868 <host_hci_cmd_build_le_conn_param_neg_reply>:


void
host_hci_cmd_build_le_conn_param_neg_reply(
    const struct hci_conn_param_neg_reply *hcn, uint8_t *dst, int dst_len)
{
   19868:	b538      	push	{r3, r4, r5, lr}
   1986a:	460c      	mov	r4, r1
   1986c:	4605      	mov	r5, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1986e:	4608      	mov	r0, r1
   19870:	f242 0121 	movw	r1, #8225	; 0x2021
   19874:	f003 fbf0 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19878:	2303      	movs	r3, #3
   1987a:	70a3      	strb	r3, [r4, #2]

static void
host_hci_cmd_body_le_conn_param_neg_reply(
    const struct hci_conn_param_neg_reply *hcn, uint8_t *dst)
{
    htole16(dst + 0, hcn->handle);
   1987c:	18e0      	adds	r0, r4, r3
   1987e:	8829      	ldrh	r1, [r5, #0]
   19880:	f003 fbea 	bl	1d058 <htole16>
    dst[2] = hcn->reason;
   19884:	78ab      	ldrb	r3, [r5, #2]
   19886:	7163      	strb	r3, [r4, #5]
   19888:	bd38      	pop	{r3, r4, r5, pc}

0001988a <host_hci_cmd_build_le_rand>:
 *
 * @return int
 */
void
host_hci_cmd_build_le_rand(uint8_t *dst, int dst_len)
{
   1988a:	b510      	push	{r4, lr}
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   1988c:	f242 0118 	movw	r1, #8216	; 0x2018
 *
 * @return int
 */
void
host_hci_cmd_build_le_rand(uint8_t *dst, int dst_len)
{
   19890:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19892:	f003 fbe1 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19896:	2300      	movs	r3, #0
   19898:	70a3      	strb	r3, [r4, #2]
   1989a:	bd10      	pop	{r4, pc}

0001989c <host_hci_cmd_build_le_start_encrypt>:
 * OGF=0x08 OCF=0x0019
 */
void
host_hci_cmd_build_le_start_encrypt(const struct hci_start_encrypt *cmd,
                                    uint8_t *dst, int dst_len)
{
   1989c:	b538      	push	{r3, r4, r5, lr}
   1989e:	460d      	mov	r5, r1
   198a0:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   198a2:	4608      	mov	r0, r1
   198a4:	f242 0119 	movw	r1, #8217	; 0x2019
   198a8:	f003 fbd6 	bl	1d058 <htole16>
    u8ptr[2] = len;
   198ac:	231c      	movs	r3, #28
   198ae:	70ab      	strb	r3, [r5, #2]

static void
host_hci_cmd_body_le_start_encrypt(const struct hci_start_encrypt *cmd,
                                   uint8_t *dst)
{
    htole16(dst + 0, cmd->connection_handle);
   198b0:	8821      	ldrh	r1, [r4, #0]
   198b2:	1ce8      	adds	r0, r5, #3
   198b4:	f003 fbd0 	bl	1d058 <htole16>
    htole64(dst + 2, cmd->random_number);
   198b8:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
   198bc:	1d68      	adds	r0, r5, #5
   198be:	f003 fbd7 	bl	1d070 <htole64>
    htole16(dst + 10, cmd->encrypted_diversifier);
    memcpy(dst + 12, cmd->long_term_key, sizeof cmd->long_term_key);
   198c2:	3410      	adds	r4, #16
host_hci_cmd_body_le_start_encrypt(const struct hci_start_encrypt *cmd,
                                   uint8_t *dst)
{
    htole16(dst + 0, cmd->connection_handle);
    htole64(dst + 2, cmd->random_number);
    htole16(dst + 10, cmd->encrypted_diversifier);
   198c4:	f834 1c0e 	ldrh.w	r1, [r4, #-14]
   198c8:	f105 000d 	add.w	r0, r5, #13
   198cc:	f003 fbc4 	bl	1d058 <htole16>
    memcpy(dst + 12, cmd->long_term_key, sizeof cmd->long_term_key);
   198d0:	350f      	adds	r5, #15
   198d2:	f104 0310 	add.w	r3, r4, #16
   198d6:	f854 2b04 	ldr.w	r2, [r4], #4
   198da:	f845 2b04 	str.w	r2, [r5], #4
   198de:	429c      	cmp	r4, r3
   198e0:	d1f9      	bne.n	198d6 <host_hci_cmd_build_le_start_encrypt+0x3a>
    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_START_ENCRYPT,
                       BLE_HCI_LE_START_ENCRYPT_LEN, dst);
    dst += BLE_HCI_CMD_HDR_LEN;

    host_hci_cmd_body_le_start_encrypt(cmd, dst);
}
   198e2:	bd38      	pop	{r3, r4, r5, pc}

000198e4 <host_hci_cmd_build_add_to_resolv_list>:
int
host_hci_cmd_build_add_to_resolv_list(
    const struct hci_add_dev_to_resolving_list *padd,
    uint8_t *dst,
    int dst_len)
{
   198e4:	b570      	push	{r4, r5, r6, lr}
   198e6:	4605      	mov	r5, r0
   198e8:	460c      	mov	r4, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   198ea:	4608      	mov	r0, r1
   198ec:	f242 0127 	movw	r1, #8231	; 0x2027
   198f0:	f003 fbb2 	bl	1d058 <htole16>
    u8ptr[2] = len;
   198f4:	2327      	movs	r3, #39	; 0x27
   198f6:	70a3      	strb	r3, [r4, #2]
        dst_len >= BLE_HCI_CMD_HDR_LEN + BLE_HCI_ADD_TO_RESOLV_LIST_LEN);

    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ADD_RESOLV_LIST,
                       BLE_HCI_ADD_TO_RESOLV_LIST_LEN, dst);

    rc = host_hci_cmd_body_add_to_resolv_list(
   198f8:	782b      	ldrb	r3, [r5, #0]
host_hci_cmd_body_add_to_resolv_list(uint8_t addr_type, const uint8_t *addr,
                                     const uint8_t *peer_irk,
                                     const uint8_t *local_irk,
                                     uint8_t *dst)
{
    if (addr_type > BLE_ADDR_TYPE_RANDOM) {
   198fa:	2b01      	cmp	r3, #1
   198fc:	d81d      	bhi.n	1993a <host_hci_cmd_build_add_to_resolv_list+0x56>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    dst[0] = addr_type;
   198fe:	70e3      	strb	r3, [r4, #3]
    memcpy(dst + 1, addr, BLE_DEV_ADDR_LEN);
   19900:	462b      	mov	r3, r5
    memcpy(dst + 1 + 6, peer_irk , 16);
   19902:	f105 0027 	add.w	r0, r5, #39	; 0x27
    if (addr_type > BLE_ADDR_TYPE_RANDOM) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    dst[0] = addr_type;
    memcpy(dst + 1, addr, BLE_DEV_ADDR_LEN);
   19906:	f853 2f01 	ldr.w	r2, [r3, #1]!
   1990a:	6062      	str	r2, [r4, #4]
   1990c:	889b      	ldrh	r3, [r3, #4]
   1990e:	8123      	strh	r3, [r4, #8]
    memcpy(dst + 1 + 6, peer_irk , 16);
   19910:	f105 0317 	add.w	r3, r5, #23
   19914:	f104 020a 	add.w	r2, r4, #10
   19918:	4619      	mov	r1, r3
   1991a:	f853 6b04 	ldr.w	r6, [r3], #4
   1991e:	f842 6b04 	str.w	r6, [r2], #4
   19922:	4283      	cmp	r3, r0
   19924:	d1f9      	bne.n	1991a <host_hci_cmd_build_add_to_resolv_list+0x36>
    memcpy(dst + 1 + 6 + 16, local_irk , 16);
   19926:	3507      	adds	r5, #7
   19928:	341a      	adds	r4, #26
   1992a:	f855 3b04 	ldr.w	r3, [r5], #4
   1992e:	f844 3b04 	str.w	r3, [r4], #4
   19932:	428d      	cmp	r5, r1
   19934:	d1f9      	bne.n	1992a <host_hci_cmd_build_add_to_resolv_list+0x46>
        dst + BLE_HCI_CMD_HDR_LEN);
    if (rc != 0) {
        return rc;
    }

    return 0;
   19936:	2000      	movs	r0, #0
   19938:	bd70      	pop	{r4, r5, r6, pc}
                                     const uint8_t *peer_irk,
                                     const uint8_t *local_irk,
                                     uint8_t *dst)
{
    if (addr_type > BLE_ADDR_TYPE_RANDOM) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
   1993a:	2012      	movs	r0, #18
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1993c:	bd70      	pop	{r4, r5, r6, pc}

0001993e <host_hci_cmd_build_clear_resolv_list>:
    return 0;
}

int
host_hci_cmd_build_clear_resolv_list(uint8_t *dst, int dst_len)
{
   1993e:	b510      	push	{r4, lr}
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19940:	f242 0129 	movw	r1, #8233	; 0x2029
    return 0;
}

int
host_hci_cmd_build_clear_resolv_list(uint8_t *dst, int dst_len)
{
   19944:	4604      	mov	r4, r0
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19946:	f003 fb87 	bl	1d058 <htole16>
    u8ptr[2] = len;
   1994a:	2000      	movs	r0, #0
   1994c:	70a0      	strb	r0, [r4, #2]

    host_hci_write_hdr(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLR_RESOLV_LIST,
                       0, dst);

    return 0;
}
   1994e:	bd10      	pop	{r4, pc}

00019950 <host_hci_cmd_build_set_addr_res_en>:
/*
 * OGF=0x08 OCF=0x002d
 */
int
host_hci_cmd_build_set_addr_res_en(uint8_t enable, uint8_t *dst, int dst_len)
{
   19950:	b538      	push	{r3, r4, r5, lr}
   19952:	4605      	mov	r5, r0
   19954:	460c      	mov	r4, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19956:	4608      	mov	r0, r1
   19958:	f242 012d 	movw	r1, #8237	; 0x202d
   1995c:	f003 fb7c 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19960:	2301      	movs	r3, #1
}

static int
host_hci_cmd_body_set_addr_res_en(uint8_t enable, uint8_t *dst)
{
    if (enable > 1) {
   19962:	429d      	cmp	r5, r3

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
    u8ptr[2] = len;
   19964:	70a3      	strb	r3, [r4, #2]
{
    if (enable > 1) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    dst[0] = enable;
   19966:	bf9a      	itte	ls
   19968:	70e5      	strbls	r5, [r4, #3]

    rc = host_hci_cmd_body_set_addr_res_en(enable, dst + BLE_HCI_CMD_HDR_LEN);
    if (rc != 0) {
        return rc;
    }
    return 0;
   1996a:	2000      	movls	r0, #0

static int
host_hci_cmd_body_set_addr_res_en(uint8_t enable, uint8_t *dst)
{
    if (enable > 1) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
   1996c:	2012      	movhi	r0, #18
    rc = host_hci_cmd_body_set_addr_res_en(enable, dst + BLE_HCI_CMD_HDR_LEN);
    if (rc != 0) {
        return rc;
    }
    return 0;
}
   1996e:	bd38      	pop	{r3, r4, r5, pc}

00019970 <host_hci_cmd_build_set_resolv_priv_addr_timeout>:
 * OGF=0x08 OCF=0x002e
 */
int
host_hci_cmd_build_set_resolv_priv_addr_timeout(uint16_t timeout, uint8_t *dst,
                                                int dst_len)
{
   19970:	b538      	push	{r3, r4, r5, lr}
   19972:	4605      	mov	r5, r0
   19974:	460c      	mov	r4, r1
    uint8_t *u8ptr;

    u8ptr = buf;

    opcode = (ogf << 10) | ocf;
    htole16(u8ptr, opcode);
   19976:	4608      	mov	r0, r1
   19978:	f242 012e 	movw	r1, #8238	; 0x202e
   1997c:	f003 fb6c 	bl	1d058 <htole16>
    u8ptr[2] = len;
   19980:	2302      	movs	r3, #2
   19982:	70a3      	strb	r3, [r4, #2]
}

static int
host_hci_cmd_body_set_resolv_priv_addr_timeout(uint16_t timeout, uint8_t *dst)
{
    if (timeout == 0 || timeout > 0xA1B8) {
   19984:	1e6b      	subs	r3, r5, #1
   19986:	b29b      	uxth	r3, r3
   19988:	f24a 12b7 	movw	r2, #41399	; 0xa1b7
   1998c:	4293      	cmp	r3, r2
   1998e:	d805      	bhi.n	1999c <host_hci_cmd_build_set_resolv_priv_addr_timeout+0x2c>
        return BLE_ERR_INV_HCI_CMD_PARMS;
    }

    htole16(dst, timeout);
   19990:	1ce0      	adds	r0, r4, #3
   19992:	4629      	mov	r1, r5
   19994:	f003 fb60 	bl	1d058 <htole16>
    rc = host_hci_cmd_body_set_resolv_priv_addr_timeout(
        timeout, dst + BLE_HCI_CMD_HDR_LEN);
    if (rc != 0) {
        return rc;
    }
    return 0;
   19998:	2000      	movs	r0, #0
   1999a:	bd38      	pop	{r3, r4, r5, pc}

static int
host_hci_cmd_body_set_resolv_priv_addr_timeout(uint16_t timeout, uint8_t *dst)
{
    if (timeout == 0 || timeout > 0xA1B8) {
        return BLE_ERR_INV_HCI_CMD_PARMS;
   1999c:	2012      	movs	r0, #18
        timeout, dst + BLE_HCI_CMD_HDR_LEN);
    if (rc != 0) {
        return rc;
    }
    return 0;
}
   1999e:	bd38      	pop	{r3, r4, r5, pc}

000199a0 <ble_att_rx>:
    return mtu;
}

static int
ble_att_rx(uint16_t conn_handle, struct os_mbuf **om)
{
   199a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   199a2:	4605      	mov	r5, r0
   199a4:	460c      	mov	r4, r1
    const struct ble_att_rx_dispatch_entry *entry;
    uint8_t op;
    int rc;

    rc = os_mbuf_copydata(*om, 0, 1, &op);
   199a6:	6808      	ldr	r0, [r1, #0]
   199a8:	2201      	movs	r2, #1
   199aa:	2100      	movs	r1, #0
   199ac:	f10d 0307 	add.w	r3, sp, #7
   199b0:	f7f0 fb5e 	bl	a070 <os_mbuf_copydata>
    if (rc != 0) {
   199b4:	2800      	cmp	r0, #0
   199b6:	f040 8109 	bne.w	19bcc <ble_att_rx+0x22c>
        return BLE_HS_EMSGSIZE;
    }

    entry = ble_att_rx_dispatch_entry_find(op);
   199ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
   199be:	4986      	ldr	r1, [pc, #536]	; (19bd8 <ble_att_rx+0x238>)
   199c0:	180a      	adds	r2, r1, r0
    const struct ble_att_rx_dispatch_entry *entry;
    int i;

    for (i = 0; i < BLE_ATT_RX_DISPATCH_SZ; i++) {
        entry = ble_att_rx_dispatch + i;
        if (entry->bde_op == op) {
   199c2:	5c41      	ldrb	r1, [r0, r1]
   199c4:	4299      	cmp	r1, r3
   199c6:	d157      	bne.n	19a78 <ble_att_rx+0xd8>
}

static void
ble_att_inc_rx_stat(uint8_t att_op)
{
    switch (att_op) {
   199c8:	3b01      	subs	r3, #1
   199ca:	2b51      	cmp	r3, #81	; 0x51
   199cc:	f200 80f9 	bhi.w	19bc2 <ble_att_rx+0x222>
   199d0:	e8df f013 	tbh	[pc, r3, lsl #1]
   199d4:	005e0059 	.word	0x005e0059
   199d8:	00680063 	.word	0x00680063
   199dc:	0072006d 	.word	0x0072006d
   199e0:	007c0077 	.word	0x007c0077
   199e4:	00860081 	.word	0x00860081
   199e8:	0090008b 	.word	0x0090008b
   199ec:	009a0095 	.word	0x009a0095
   199f0:	00a4009f 	.word	0x00a4009f
   199f4:	00b200ab 	.word	0x00b200ab
   199f8:	00f700b9 	.word	0x00f700b9
   199fc:	00c000f7 	.word	0x00c000f7
   19a00:	00ce00c7 	.word	0x00ce00c7
   19a04:	00f700d5 	.word	0x00f700d5
   19a08:	00f700dc 	.word	0x00f700dc
   19a0c:	00ea00e3 	.word	0x00ea00e3
   19a10:	00f700f7 	.word	0x00f700f7
   19a14:	00f700f7 	.word	0x00f700f7
   19a18:	00f700f7 	.word	0x00f700f7
   19a1c:	00f700f7 	.word	0x00f700f7
   19a20:	00f700f7 	.word	0x00f700f7
   19a24:	00f700f7 	.word	0x00f700f7
   19a28:	00f700f7 	.word	0x00f700f7
   19a2c:	00f700f7 	.word	0x00f700f7
   19a30:	00f700f7 	.word	0x00f700f7
   19a34:	00f700f7 	.word	0x00f700f7
   19a38:	00f700f7 	.word	0x00f700f7
   19a3c:	00f700f7 	.word	0x00f700f7
   19a40:	00f700f7 	.word	0x00f700f7
   19a44:	00f700f7 	.word	0x00f700f7
   19a48:	00f700f7 	.word	0x00f700f7
   19a4c:	00f700f7 	.word	0x00f700f7
   19a50:	00f700f7 	.word	0x00f700f7
   19a54:	00f700f7 	.word	0x00f700f7
   19a58:	00f700f7 	.word	0x00f700f7
   19a5c:	00f700f7 	.word	0x00f700f7
   19a60:	00f700f7 	.word	0x00f700f7
   19a64:	00f700f7 	.word	0x00f700f7
   19a68:	00f700f7 	.word	0x00f700f7
   19a6c:	00f700f7 	.word	0x00f700f7
   19a70:	00f700f7 	.word	0x00f700f7
   19a74:	00f100f7 	.word	0x00f100f7
   19a78:	f100 0008 	add.w	r0, r0, #8
        entry = ble_att_rx_dispatch + i;
        if (entry->bde_op == op) {
            return entry;
        }

        if (entry->bde_op > op) {
   19a7c:	f200 80a8 	bhi.w	19bd0 <ble_att_rx+0x230>
ble_att_rx_dispatch_entry_find(uint8_t op)
{
    const struct ble_att_rx_dispatch_entry *entry;
    int i;

    for (i = 0; i < BLE_ATT_RX_DISPATCH_SZ; i++) {
   19a80:	28d8      	cmp	r0, #216	; 0xd8
   19a82:	d19c      	bne.n	199be <ble_att_rx+0x1e>
   19a84:	e0a4      	b.n	19bd0 <ble_att_rx+0x230>
static void
ble_att_inc_rx_stat(uint8_t att_op)
{
    switch (att_op) {
    case BLE_ATT_OP_ERROR_RSP:
        STATS_INC(ble_att_stats, error_rsp_rx);
   19a86:	4955      	ldr	r1, [pc, #340]	; (19bdc <ble_att_rx+0x23c>)
   19a88:	68cb      	ldr	r3, [r1, #12]
   19a8a:	3301      	adds	r3, #1
   19a8c:	60cb      	str	r3, [r1, #12]
   19a8e:	e098      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_MTU_REQ:
        STATS_INC(ble_att_stats, mtu_req_rx);
   19a90:	4952      	ldr	r1, [pc, #328]	; (19bdc <ble_att_rx+0x23c>)
   19a92:	694b      	ldr	r3, [r1, #20]
   19a94:	3301      	adds	r3, #1
   19a96:	614b      	str	r3, [r1, #20]
   19a98:	e093      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_MTU_RSP:
        STATS_INC(ble_att_stats, mtu_rsp_rx);
   19a9a:	4950      	ldr	r1, [pc, #320]	; (19bdc <ble_att_rx+0x23c>)
   19a9c:	69cb      	ldr	r3, [r1, #28]
   19a9e:	3301      	adds	r3, #1
   19aa0:	61cb      	str	r3, [r1, #28]
   19aa2:	e08e      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_FIND_INFO_REQ:
        STATS_INC(ble_att_stats, find_info_req_rx);
   19aa4:	494d      	ldr	r1, [pc, #308]	; (19bdc <ble_att_rx+0x23c>)
   19aa6:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   19aa8:	3301      	adds	r3, #1
   19aaa:	624b      	str	r3, [r1, #36]	; 0x24
   19aac:	e089      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_FIND_INFO_RSP:
        STATS_INC(ble_att_stats, find_info_rsp_rx);
   19aae:	494b      	ldr	r1, [pc, #300]	; (19bdc <ble_att_rx+0x23c>)
   19ab0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   19ab2:	3301      	adds	r3, #1
   19ab4:	62cb      	str	r3, [r1, #44]	; 0x2c
   19ab6:	e084      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_FIND_TYPE_VALUE_REQ:
        STATS_INC(ble_att_stats, find_type_value_req_rx);
   19ab8:	4948      	ldr	r1, [pc, #288]	; (19bdc <ble_att_rx+0x23c>)
   19aba:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   19abc:	3301      	adds	r3, #1
   19abe:	634b      	str	r3, [r1, #52]	; 0x34
   19ac0:	e07f      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_FIND_TYPE_VALUE_RSP:
        STATS_INC(ble_att_stats, find_type_value_rsp_rx);
   19ac2:	4946      	ldr	r1, [pc, #280]	; (19bdc <ble_att_rx+0x23c>)
   19ac4:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   19ac6:	3301      	adds	r3, #1
   19ac8:	63cb      	str	r3, [r1, #60]	; 0x3c
   19aca:	e07a      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_TYPE_REQ:
        STATS_INC(ble_att_stats, read_type_req_rx);
   19acc:	4943      	ldr	r1, [pc, #268]	; (19bdc <ble_att_rx+0x23c>)
   19ace:	6c4b      	ldr	r3, [r1, #68]	; 0x44
   19ad0:	3301      	adds	r3, #1
   19ad2:	644b      	str	r3, [r1, #68]	; 0x44
   19ad4:	e075      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_TYPE_RSP:
        STATS_INC(ble_att_stats, read_type_rsp_rx);
   19ad6:	4941      	ldr	r1, [pc, #260]	; (19bdc <ble_att_rx+0x23c>)
   19ad8:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
   19ada:	3301      	adds	r3, #1
   19adc:	64cb      	str	r3, [r1, #76]	; 0x4c
   19ade:	e070      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_REQ:
        STATS_INC(ble_att_stats, read_req_rx);
   19ae0:	493e      	ldr	r1, [pc, #248]	; (19bdc <ble_att_rx+0x23c>)
   19ae2:	6d4b      	ldr	r3, [r1, #84]	; 0x54
   19ae4:	3301      	adds	r3, #1
   19ae6:	654b      	str	r3, [r1, #84]	; 0x54
   19ae8:	e06b      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_RSP:
        STATS_INC(ble_att_stats, read_rsp_rx);
   19aea:	493c      	ldr	r1, [pc, #240]	; (19bdc <ble_att_rx+0x23c>)
   19aec:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
   19aee:	3301      	adds	r3, #1
   19af0:	65cb      	str	r3, [r1, #92]	; 0x5c
   19af2:	e066      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_BLOB_REQ:
        STATS_INC(ble_att_stats, read_blob_req_rx);
   19af4:	4939      	ldr	r1, [pc, #228]	; (19bdc <ble_att_rx+0x23c>)
   19af6:	6e4b      	ldr	r3, [r1, #100]	; 0x64
   19af8:	3301      	adds	r3, #1
   19afa:	664b      	str	r3, [r1, #100]	; 0x64
   19afc:	e061      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_BLOB_RSP:
        STATS_INC(ble_att_stats, read_blob_rsp_rx);
   19afe:	4937      	ldr	r1, [pc, #220]	; (19bdc <ble_att_rx+0x23c>)
   19b00:	6ecb      	ldr	r3, [r1, #108]	; 0x6c
   19b02:	3301      	adds	r3, #1
   19b04:	66cb      	str	r3, [r1, #108]	; 0x6c
   19b06:	e05c      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_MULT_REQ:
        STATS_INC(ble_att_stats, read_mult_req_rx);
   19b08:	4934      	ldr	r1, [pc, #208]	; (19bdc <ble_att_rx+0x23c>)
   19b0a:	6f4b      	ldr	r3, [r1, #116]	; 0x74
   19b0c:	3301      	adds	r3, #1
   19b0e:	674b      	str	r3, [r1, #116]	; 0x74
   19b10:	e057      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_MULT_RSP:
        STATS_INC(ble_att_stats, read_mult_rsp_rx);
   19b12:	4932      	ldr	r1, [pc, #200]	; (19bdc <ble_att_rx+0x23c>)
   19b14:	6fcb      	ldr	r3, [r1, #124]	; 0x7c
   19b16:	3301      	adds	r3, #1
   19b18:	67cb      	str	r3, [r1, #124]	; 0x7c
   19b1a:	e052      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_GROUP_TYPE_REQ:
        STATS_INC(ble_att_stats, read_group_type_req_rx);
   19b1c:	492f      	ldr	r1, [pc, #188]	; (19bdc <ble_att_rx+0x23c>)
   19b1e:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
   19b22:	3301      	adds	r3, #1
   19b24:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
   19b28:	e04b      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_READ_GROUP_TYPE_RSP:
        STATS_INC(ble_att_stats, read_group_type_rsp_rx);
   19b2a:	492c      	ldr	r1, [pc, #176]	; (19bdc <ble_att_rx+0x23c>)
   19b2c:	f8d1 308c 	ldr.w	r3, [r1, #140]	; 0x8c
   19b30:	3301      	adds	r3, #1
   19b32:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
   19b36:	e044      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_WRITE_REQ:
        STATS_INC(ble_att_stats, write_req_rx);
   19b38:	4928      	ldr	r1, [pc, #160]	; (19bdc <ble_att_rx+0x23c>)
   19b3a:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
   19b3e:	3301      	adds	r3, #1
   19b40:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
   19b44:	e03d      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_WRITE_RSP:
        STATS_INC(ble_att_stats, write_rsp_rx);
   19b46:	4925      	ldr	r1, [pc, #148]	; (19bdc <ble_att_rx+0x23c>)
   19b48:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
   19b4c:	3301      	adds	r3, #1
   19b4e:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
   19b52:	e036      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_PREP_WRITE_REQ:
        STATS_INC(ble_att_stats, prep_write_req_rx);
   19b54:	4921      	ldr	r1, [pc, #132]	; (19bdc <ble_att_rx+0x23c>)
   19b56:	f8d1 30a4 	ldr.w	r3, [r1, #164]	; 0xa4
   19b5a:	3301      	adds	r3, #1
   19b5c:	f8c1 30a4 	str.w	r3, [r1, #164]	; 0xa4
   19b60:	e02f      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_PREP_WRITE_RSP:
        STATS_INC(ble_att_stats, prep_write_rsp_rx);
   19b62:	491e      	ldr	r1, [pc, #120]	; (19bdc <ble_att_rx+0x23c>)
   19b64:	f8d1 30ac 	ldr.w	r3, [r1, #172]	; 0xac
   19b68:	3301      	adds	r3, #1
   19b6a:	f8c1 30ac 	str.w	r3, [r1, #172]	; 0xac
   19b6e:	e028      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_EXEC_WRITE_REQ:
        STATS_INC(ble_att_stats, exec_write_req_rx);
   19b70:	491a      	ldr	r1, [pc, #104]	; (19bdc <ble_att_rx+0x23c>)
   19b72:	f8d1 30b4 	ldr.w	r3, [r1, #180]	; 0xb4
   19b76:	3301      	adds	r3, #1
   19b78:	f8c1 30b4 	str.w	r3, [r1, #180]	; 0xb4
   19b7c:	e021      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_EXEC_WRITE_RSP:
        STATS_INC(ble_att_stats, exec_write_rsp_rx);
   19b7e:	4917      	ldr	r1, [pc, #92]	; (19bdc <ble_att_rx+0x23c>)
   19b80:	f8d1 30bc 	ldr.w	r3, [r1, #188]	; 0xbc
   19b84:	3301      	adds	r3, #1
   19b86:	f8c1 30bc 	str.w	r3, [r1, #188]	; 0xbc
   19b8a:	e01a      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_NOTIFY_REQ:
        STATS_INC(ble_att_stats, notify_req_rx);
   19b8c:	4913      	ldr	r1, [pc, #76]	; (19bdc <ble_att_rx+0x23c>)
   19b8e:	f8d1 30c4 	ldr.w	r3, [r1, #196]	; 0xc4
   19b92:	3301      	adds	r3, #1
   19b94:	f8c1 30c4 	str.w	r3, [r1, #196]	; 0xc4
   19b98:	e013      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_INDICATE_REQ:
        STATS_INC(ble_att_stats, indicate_req_rx);
   19b9a:	4910      	ldr	r1, [pc, #64]	; (19bdc <ble_att_rx+0x23c>)
   19b9c:	f8d1 30cc 	ldr.w	r3, [r1, #204]	; 0xcc
   19ba0:	3301      	adds	r3, #1
   19ba2:	f8c1 30cc 	str.w	r3, [r1, #204]	; 0xcc
   19ba6:	e00c      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_INDICATE_RSP:
        STATS_INC(ble_att_stats, indicate_rsp_rx);
   19ba8:	490c      	ldr	r1, [pc, #48]	; (19bdc <ble_att_rx+0x23c>)
   19baa:	f8d1 30d4 	ldr.w	r3, [r1, #212]	; 0xd4
   19bae:	3301      	adds	r3, #1
   19bb0:	f8c1 30d4 	str.w	r3, [r1, #212]	; 0xd4
   19bb4:	e005      	b.n	19bc2 <ble_att_rx+0x222>
        break;

    case BLE_ATT_OP_WRITE_CMD:
        STATS_INC(ble_att_stats, write_cmd_rx);
   19bb6:	4909      	ldr	r1, [pc, #36]	; (19bdc <ble_att_rx+0x23c>)
   19bb8:	f8d1 30dc 	ldr.w	r3, [r1, #220]	; 0xdc
   19bbc:	3301      	adds	r3, #1
   19bbe:	f8c1 30dc 	str.w	r3, [r1, #220]	; 0xdc
        return BLE_HS_EINVAL;
    }

    ble_att_inc_rx_stat(op);

    rc = entry->bde_fn(conn_handle, om);
   19bc2:	6853      	ldr	r3, [r2, #4]
   19bc4:	4628      	mov	r0, r5
   19bc6:	4621      	mov	r1, r4
   19bc8:	4798      	blx	r3
   19bca:	e002      	b.n	19bd2 <ble_att_rx+0x232>
    uint8_t op;
    int rc;

    rc = os_mbuf_copydata(*om, 0, 1, &op);
    if (rc != 0) {
        return BLE_HS_EMSGSIZE;
   19bcc:	2004      	movs	r0, #4
   19bce:	e000      	b.n	19bd2 <ble_att_rx+0x232>
    }

    entry = ble_att_rx_dispatch_entry_find(op);
    if (entry == NULL) {
        return BLE_HS_EINVAL;
   19bd0:	2003      	movs	r0, #3
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   19bd2:	b003      	add	sp, #12
   19bd4:	bd30      	pop	{r4, r5, pc}
   19bd6:	bf00      	nop
   19bd8:	00020704 	.word	0x00020704
   19bdc:	20003d14 	.word	0x20003d14

00019be0 <ble_att_conn_chan_find>:
}

int
ble_att_conn_chan_find(uint16_t conn_handle, struct ble_hs_conn **out_conn,
                       struct ble_l2cap_chan **out_chan)
{
   19be0:	b510      	push	{r4, lr}
   19be2:	460c      	mov	r4, r1
   19be4:	4613      	mov	r3, r2
    int rc;

    rc = ble_hs_misc_conn_chan_find_reqd(conn_handle, BLE_L2CAP_CID_ATT,
   19be6:	2104      	movs	r1, #4
   19be8:	4622      	mov	r2, r4
                                         out_conn, out_chan);
    return rc;
}
   19bea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
ble_att_conn_chan_find(uint16_t conn_handle, struct ble_hs_conn **out_conn,
                       struct ble_l2cap_chan **out_chan)
{
    int rc;

    rc = ble_hs_misc_conn_chan_find_reqd(conn_handle, BLE_L2CAP_CID_ATT,
   19bee:	f7fb bccc 	b.w	1558a <ble_hs_misc_conn_chan_find_reqd>
	...

00019bf4 <ble_att_inc_tx_stat>:
}

void
ble_att_inc_tx_stat(uint8_t att_op)
{
    switch (att_op) {
   19bf4:	3801      	subs	r0, #1
   19bf6:	2851      	cmp	r0, #81	; 0x51
   19bf8:	f200 80f4 	bhi.w	19de4 <ble_att_inc_tx_stat+0x1f0>
   19bfc:	e8df f010 	tbh	[pc, r0, lsl #1]
   19c00:	00570052 	.word	0x00570052
   19c04:	0061005c 	.word	0x0061005c
   19c08:	006b0066 	.word	0x006b0066
   19c0c:	00750070 	.word	0x00750070
   19c10:	007f007a 	.word	0x007f007a
   19c14:	00890084 	.word	0x00890084
   19c18:	0093008e 	.word	0x0093008e
   19c1c:	009f0098 	.word	0x009f0098
   19c20:	00ad00a6 	.word	0x00ad00a6
   19c24:	00f200b4 	.word	0x00f200b4
   19c28:	00bb00f2 	.word	0x00bb00f2
   19c2c:	00c900c2 	.word	0x00c900c2
   19c30:	00f200d0 	.word	0x00f200d0
   19c34:	00f200d7 	.word	0x00f200d7
   19c38:	00e500de 	.word	0x00e500de
   19c3c:	00f200f2 	.word	0x00f200f2
   19c40:	00f200f2 	.word	0x00f200f2
   19c44:	00f200f2 	.word	0x00f200f2
   19c48:	00f200f2 	.word	0x00f200f2
   19c4c:	00f200f2 	.word	0x00f200f2
   19c50:	00f200f2 	.word	0x00f200f2
   19c54:	00f200f2 	.word	0x00f200f2
   19c58:	00f200f2 	.word	0x00f200f2
   19c5c:	00f200f2 	.word	0x00f200f2
   19c60:	00f200f2 	.word	0x00f200f2
   19c64:	00f200f2 	.word	0x00f200f2
   19c68:	00f200f2 	.word	0x00f200f2
   19c6c:	00f200f2 	.word	0x00f200f2
   19c70:	00f200f2 	.word	0x00f200f2
   19c74:	00f200f2 	.word	0x00f200f2
   19c78:	00f200f2 	.word	0x00f200f2
   19c7c:	00f200f2 	.word	0x00f200f2
   19c80:	00f200f2 	.word	0x00f200f2
   19c84:	00f200f2 	.word	0x00f200f2
   19c88:	00f200f2 	.word	0x00f200f2
   19c8c:	00f200f2 	.word	0x00f200f2
   19c90:	00f200f2 	.word	0x00f200f2
   19c94:	00f200f2 	.word	0x00f200f2
   19c98:	00f200f2 	.word	0x00f200f2
   19c9c:	00f200f2 	.word	0x00f200f2
   19ca0:	00ec00f2 	.word	0x00ec00f2
    case BLE_ATT_OP_ERROR_RSP:
        STATS_INC(ble_att_stats, error_rsp_tx);
   19ca4:	4a50      	ldr	r2, [pc, #320]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19ca6:	6913      	ldr	r3, [r2, #16]
   19ca8:	3301      	adds	r3, #1
   19caa:	6113      	str	r3, [r2, #16]
        break;
   19cac:	4770      	bx	lr

    case BLE_ATT_OP_MTU_REQ:
        STATS_INC(ble_att_stats, mtu_req_tx);
   19cae:	4a4e      	ldr	r2, [pc, #312]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19cb0:	6993      	ldr	r3, [r2, #24]
   19cb2:	3301      	adds	r3, #1
   19cb4:	6193      	str	r3, [r2, #24]
        break;
   19cb6:	4770      	bx	lr

    case BLE_ATT_OP_MTU_RSP:
        STATS_INC(ble_att_stats, mtu_rsp_tx);
   19cb8:	4a4b      	ldr	r2, [pc, #300]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19cba:	6a13      	ldr	r3, [r2, #32]
   19cbc:	3301      	adds	r3, #1
   19cbe:	6213      	str	r3, [r2, #32]
        break;
   19cc0:	4770      	bx	lr

    case BLE_ATT_OP_FIND_INFO_REQ:
        STATS_INC(ble_att_stats, find_info_req_tx);
   19cc2:	4a49      	ldr	r2, [pc, #292]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19cc4:	6a93      	ldr	r3, [r2, #40]	; 0x28
   19cc6:	3301      	adds	r3, #1
   19cc8:	6293      	str	r3, [r2, #40]	; 0x28
        break;
   19cca:	4770      	bx	lr

    case BLE_ATT_OP_FIND_INFO_RSP:
        STATS_INC(ble_att_stats, find_info_rsp_tx);
   19ccc:	4a46      	ldr	r2, [pc, #280]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19cce:	6b13      	ldr	r3, [r2, #48]	; 0x30
   19cd0:	3301      	adds	r3, #1
   19cd2:	6313      	str	r3, [r2, #48]	; 0x30
        break;
   19cd4:	4770      	bx	lr

    case BLE_ATT_OP_FIND_TYPE_VALUE_REQ:
        STATS_INC(ble_att_stats, find_type_value_req_tx);
   19cd6:	4a44      	ldr	r2, [pc, #272]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19cd8:	6b93      	ldr	r3, [r2, #56]	; 0x38
   19cda:	3301      	adds	r3, #1
   19cdc:	6393      	str	r3, [r2, #56]	; 0x38
        break;
   19cde:	4770      	bx	lr

    case BLE_ATT_OP_FIND_TYPE_VALUE_RSP:
        STATS_INC(ble_att_stats, find_type_value_rsp_tx);
   19ce0:	4a41      	ldr	r2, [pc, #260]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19ce2:	6c13      	ldr	r3, [r2, #64]	; 0x40
   19ce4:	3301      	adds	r3, #1
   19ce6:	6413      	str	r3, [r2, #64]	; 0x40
        break;
   19ce8:	4770      	bx	lr

    case BLE_ATT_OP_READ_TYPE_REQ:
        STATS_INC(ble_att_stats, read_type_req_tx);
   19cea:	4a3f      	ldr	r2, [pc, #252]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19cec:	6c93      	ldr	r3, [r2, #72]	; 0x48
   19cee:	3301      	adds	r3, #1
   19cf0:	6493      	str	r3, [r2, #72]	; 0x48
        break;
   19cf2:	4770      	bx	lr

    case BLE_ATT_OP_READ_TYPE_RSP:
        STATS_INC(ble_att_stats, read_type_rsp_tx);
   19cf4:	4a3c      	ldr	r2, [pc, #240]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19cf6:	6d13      	ldr	r3, [r2, #80]	; 0x50
   19cf8:	3301      	adds	r3, #1
   19cfa:	6513      	str	r3, [r2, #80]	; 0x50
        break;
   19cfc:	4770      	bx	lr

    case BLE_ATT_OP_READ_REQ:
        STATS_INC(ble_att_stats, read_req_tx);
   19cfe:	4a3a      	ldr	r2, [pc, #232]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d00:	6d93      	ldr	r3, [r2, #88]	; 0x58
   19d02:	3301      	adds	r3, #1
   19d04:	6593      	str	r3, [r2, #88]	; 0x58
        break;
   19d06:	4770      	bx	lr

    case BLE_ATT_OP_READ_RSP:
        STATS_INC(ble_att_stats, read_rsp_tx);
   19d08:	4a37      	ldr	r2, [pc, #220]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d0a:	6e13      	ldr	r3, [r2, #96]	; 0x60
   19d0c:	3301      	adds	r3, #1
   19d0e:	6613      	str	r3, [r2, #96]	; 0x60
        break;
   19d10:	4770      	bx	lr

    case BLE_ATT_OP_READ_BLOB_REQ:
        STATS_INC(ble_att_stats, read_blob_req_tx);
   19d12:	4a35      	ldr	r2, [pc, #212]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d14:	6e93      	ldr	r3, [r2, #104]	; 0x68
   19d16:	3301      	adds	r3, #1
   19d18:	6693      	str	r3, [r2, #104]	; 0x68
        break;
   19d1a:	4770      	bx	lr

    case BLE_ATT_OP_READ_BLOB_RSP:
        STATS_INC(ble_att_stats, read_blob_rsp_tx);
   19d1c:	4a32      	ldr	r2, [pc, #200]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d1e:	6f13      	ldr	r3, [r2, #112]	; 0x70
   19d20:	3301      	adds	r3, #1
   19d22:	6713      	str	r3, [r2, #112]	; 0x70
        break;
   19d24:	4770      	bx	lr

    case BLE_ATT_OP_READ_MULT_REQ:
        STATS_INC(ble_att_stats, read_mult_req_tx);
   19d26:	4a30      	ldr	r2, [pc, #192]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d28:	6f93      	ldr	r3, [r2, #120]	; 0x78
   19d2a:	3301      	adds	r3, #1
   19d2c:	6793      	str	r3, [r2, #120]	; 0x78
        break;
   19d2e:	4770      	bx	lr

    case BLE_ATT_OP_READ_MULT_RSP:
        STATS_INC(ble_att_stats, read_mult_rsp_tx);
   19d30:	4a2d      	ldr	r2, [pc, #180]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d32:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   19d36:	3301      	adds	r3, #1
   19d38:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
        break;
   19d3c:	4770      	bx	lr

    case BLE_ATT_OP_READ_GROUP_TYPE_REQ:
        STATS_INC(ble_att_stats, read_group_type_req_tx);
   19d3e:	4a2a      	ldr	r2, [pc, #168]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d40:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   19d44:	3301      	adds	r3, #1
   19d46:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
        break;
   19d4a:	4770      	bx	lr

    case BLE_ATT_OP_READ_GROUP_TYPE_RSP:
        STATS_INC(ble_att_stats, read_group_type_rsp_tx);
   19d4c:	4a26      	ldr	r2, [pc, #152]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d4e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
   19d52:	3301      	adds	r3, #1
   19d54:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        break;
   19d58:	4770      	bx	lr

    case BLE_ATT_OP_WRITE_REQ:
        STATS_INC(ble_att_stats, write_req_tx);
   19d5a:	4a23      	ldr	r2, [pc, #140]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d5c:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
   19d60:	3301      	adds	r3, #1
   19d62:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
        break;
   19d66:	4770      	bx	lr

    case BLE_ATT_OP_WRITE_RSP:
        STATS_INC(ble_att_stats, write_rsp_tx);
   19d68:	4a1f      	ldr	r2, [pc, #124]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d6a:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
   19d6e:	3301      	adds	r3, #1
   19d70:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
        break;
   19d74:	4770      	bx	lr

    case BLE_ATT_OP_PREP_WRITE_REQ:
        STATS_INC(ble_att_stats, prep_write_req_tx);
   19d76:	4a1c      	ldr	r2, [pc, #112]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d78:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
   19d7c:	3301      	adds	r3, #1
   19d7e:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
        break;
   19d82:	4770      	bx	lr

    case BLE_ATT_OP_PREP_WRITE_RSP:
        STATS_INC(ble_att_stats, prep_write_rsp_tx);
   19d84:	4a18      	ldr	r2, [pc, #96]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d86:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
   19d8a:	3301      	adds	r3, #1
   19d8c:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
        break;
   19d90:	4770      	bx	lr

    case BLE_ATT_OP_EXEC_WRITE_REQ:
        STATS_INC(ble_att_stats, exec_write_req_tx);
   19d92:	4a15      	ldr	r2, [pc, #84]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19d94:	f8d2 30b8 	ldr.w	r3, [r2, #184]	; 0xb8
   19d98:	3301      	adds	r3, #1
   19d9a:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
        break;
   19d9e:	4770      	bx	lr

    case BLE_ATT_OP_EXEC_WRITE_RSP:
        STATS_INC(ble_att_stats, exec_write_rsp_tx);
   19da0:	4a11      	ldr	r2, [pc, #68]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19da2:	f8d2 30c0 	ldr.w	r3, [r2, #192]	; 0xc0
   19da6:	3301      	adds	r3, #1
   19da8:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
        break;
   19dac:	4770      	bx	lr

    case BLE_ATT_OP_NOTIFY_REQ:
        STATS_INC(ble_att_stats, notify_req_tx);
   19dae:	4a0e      	ldr	r2, [pc, #56]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19db0:	f8d2 30c8 	ldr.w	r3, [r2, #200]	; 0xc8
   19db4:	3301      	adds	r3, #1
   19db6:	f8c2 30c8 	str.w	r3, [r2, #200]	; 0xc8
        break;
   19dba:	4770      	bx	lr

    case BLE_ATT_OP_INDICATE_REQ:
        STATS_INC(ble_att_stats, indicate_req_tx);
   19dbc:	4a0a      	ldr	r2, [pc, #40]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19dbe:	f8d2 30d0 	ldr.w	r3, [r2, #208]	; 0xd0
   19dc2:	3301      	adds	r3, #1
   19dc4:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
        break;
   19dc8:	4770      	bx	lr

    case BLE_ATT_OP_INDICATE_RSP:
        STATS_INC(ble_att_stats, indicate_rsp_tx);
   19dca:	4a07      	ldr	r2, [pc, #28]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19dcc:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
   19dd0:	3301      	adds	r3, #1
   19dd2:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
        break;
   19dd6:	4770      	bx	lr

    case BLE_ATT_OP_WRITE_CMD:
        STATS_INC(ble_att_stats, write_cmd_tx);
   19dd8:	4a03      	ldr	r2, [pc, #12]	; (19de8 <ble_att_inc_tx_stat+0x1f4>)
   19dda:	f8d2 30e0 	ldr.w	r3, [r2, #224]	; 0xe0
   19dde:	3301      	adds	r3, #1
   19de0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
   19de4:	4770      	bx	lr
   19de6:	bf00      	nop
   19de8:	20003d14 	.word	0x20003d14

00019dec <ble_att_get_flat_buf>:
uint8_t *
ble_att_get_flat_buf(void)
{
    BLE_HS_DBG_ASSERT(ble_hs_is_parent_task());
    return ble_att_flat_buf;
}
   19dec:	4800      	ldr	r0, [pc, #0]	; (19df0 <ble_att_get_flat_buf+0x4>)
   19dee:	4770      	bx	lr
   19df0:	20000e00 	.word	0x20000e00

00019df4 <ble_att_mtu>:

uint16_t
ble_att_mtu(uint16_t conn_handle)
{
   19df4:	b513      	push	{r0, r1, r4, lr}
   19df6:	4604      	mov	r4, r0
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    uint16_t mtu;

    ble_hs_lock();
   19df8:	f7fa fca4 	bl	14744 <ble_hs_lock>

    ble_att_conn_chan_find(conn_handle, &conn, &chan);
   19dfc:	4620      	mov	r0, r4
   19dfe:	a901      	add	r1, sp, #4
   19e00:	466a      	mov	r2, sp
   19e02:	f7ff feed 	bl	19be0 <ble_att_conn_chan_find>
    if (chan != NULL) {
   19e06:	9800      	ldr	r0, [sp, #0]
   19e08:	b108      	cbz	r0, 19e0e <ble_att_mtu+0x1a>
        mtu = ble_l2cap_chan_mtu(chan);
   19e0a:	f7fb fd25 	bl	15858 <ble_l2cap_chan_mtu>
    } else {
        mtu = 0;
   19e0e:	4604      	mov	r4, r0
    }

    ble_hs_unlock();
   19e10:	f7fa fca0 	bl	14754 <ble_hs_unlock>

    return mtu;
}
   19e14:	4620      	mov	r0, r4
   19e16:	b002      	add	sp, #8
   19e18:	bd10      	pop	{r4, pc}

00019e1a <ble_att_set_peer_mtu>:

void
ble_att_set_peer_mtu(struct ble_l2cap_chan *chan, uint16_t peer_mtu)
{
    if (peer_mtu < BLE_ATT_MTU_DFLT) {
        peer_mtu = BLE_ATT_MTU_DFLT;
   19e1a:	2916      	cmp	r1, #22
   19e1c:	bf98      	it	ls
   19e1e:	2117      	movls	r1, #23
    }

    chan->blc_peer_mtu = peer_mtu;
   19e20:	8101      	strh	r1, [r0, #8]
   19e22:	4770      	bx	lr

00019e24 <ble_att_create_chan>:
    return 0;
}

struct ble_l2cap_chan *
ble_att_create_chan(void)
{
   19e24:	b508      	push	{r3, lr}
    struct ble_l2cap_chan *chan;

    chan = ble_l2cap_chan_alloc();
   19e26:	f7fb fcf3 	bl	15810 <ble_l2cap_chan_alloc>
    if (chan == NULL) {
   19e2a:	b140      	cbz	r0, 19e3e <ble_att_create_chan+0x1a>
        return NULL;
    }

    chan->blc_cid = BLE_L2CAP_CID_ATT;
   19e2c:	2304      	movs	r3, #4
   19e2e:	8083      	strh	r3, [r0, #4]
    chan->blc_my_mtu = ble_att_preferred_mtu;
   19e30:	4b03      	ldr	r3, [pc, #12]	; (19e40 <ble_att_create_chan+0x1c>)
   19e32:	881b      	ldrh	r3, [r3, #0]
   19e34:	80c3      	strh	r3, [r0, #6]
    chan->blc_default_mtu = BLE_ATT_MTU_DFLT;
   19e36:	2317      	movs	r3, #23
   19e38:	8143      	strh	r3, [r0, #10]
    chan->blc_rx_fn = ble_att_rx;
   19e3a:	4b02      	ldr	r3, [pc, #8]	; (19e44 <ble_att_create_chan+0x20>)
   19e3c:	6183      	str	r3, [r0, #24]

    return chan;
}
   19e3e:	bd08      	pop	{r3, pc}
   19e40:	200023bc 	.word	0x200023bc
   19e44:	000199a1 	.word	0x000199a1

00019e48 <ble_att_init>:

int
ble_att_init(void)
{
   19e48:	b507      	push	{r0, r1, r2, lr}
    int rc;

    ble_att_preferred_mtu = BLE_ATT_MTU_PREFERRED_DFLT;
   19e4a:	4b09      	ldr	r3, [pc, #36]	; (19e70 <ble_att_init+0x28>)

    rc = stats_init_and_reg(
   19e4c:	4809      	ldr	r0, [pc, #36]	; (19e74 <ble_att_init+0x2c>)
int
ble_att_init(void)
{
    int rc;

    ble_att_preferred_mtu = BLE_ATT_MTU_PREFERRED_DFLT;
   19e4e:	22f0      	movs	r2, #240	; 0xf0
   19e50:	801a      	strh	r2, [r3, #0]

    rc = stats_init_and_reg(
   19e52:	2300      	movs	r3, #0
   19e54:	4a08      	ldr	r2, [pc, #32]	; (19e78 <ble_att_init+0x30>)
   19e56:	9201      	str	r2, [sp, #4]
   19e58:	9300      	str	r3, [sp, #0]
   19e5a:	2104      	movs	r1, #4
   19e5c:	2236      	movs	r2, #54	; 0x36
   19e5e:	f003 fa75 	bl	1d34c <stats_init_and_reg>
        STATS_HDR(ble_att_stats), STATS_SIZE_INIT_PARMS(ble_att_stats,
        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_att_stats), "ble_att");
    if (rc != 0) {
   19e62:	2800      	cmp	r0, #0
        return BLE_HS_EOS;
    }

    return 0;
}
   19e64:	bf14      	ite	ne
   19e66:	200b      	movne	r0, #11
   19e68:	2000      	moveq	r0, #0
   19e6a:	b003      	add	sp, #12
   19e6c:	f85d fb04 	ldr.w	pc, [sp], #4
   19e70:	200023bc 	.word	0x200023bc
   19e74:	20003d14 	.word	0x20003d14
   19e78:	000207dc 	.word	0x000207dc

00019e7c <ble_att_clt_tx_req>:
    return 0;
}

static int
ble_att_clt_tx_req(uint16_t conn_handle, struct os_mbuf *txom)
{
   19e7c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    uint16_t mtu;
    int extra_len;
    int rc;

    BLE_HS_DBG_ASSERT_EVAL(txom->om_len >= 1);
    ble_att_inc_tx_stat(txom->om_data[0]);
   19e7e:	680b      	ldr	r3, [r1, #0]
    return 0;
}

static int
ble_att_clt_tx_req(uint16_t conn_handle, struct os_mbuf *txom)
{
   19e80:	4605      	mov	r5, r0
    uint16_t mtu;
    int extra_len;
    int rc;

    BLE_HS_DBG_ASSERT_EVAL(txom->om_len >= 1);
    ble_att_inc_tx_stat(txom->om_data[0]);
   19e82:	7818      	ldrb	r0, [r3, #0]
    return 0;
}

static int
ble_att_clt_tx_req(uint16_t conn_handle, struct os_mbuf *txom)
{
   19e84:	460c      	mov	r4, r1
    uint16_t mtu;
    int extra_len;
    int rc;

    BLE_HS_DBG_ASSERT_EVAL(txom->om_len >= 1);
    ble_att_inc_tx_stat(txom->om_data[0]);
   19e86:	f7ff feb5 	bl	19bf4 <ble_att_inc_tx_stat>

    ble_hs_lock();
   19e8a:	f7fa fc5b 	bl	14744 <ble_hs_lock>

    rc = ble_att_conn_chan_find(conn_handle, &conn, &chan);
   19e8e:	4628      	mov	r0, r5
   19e90:	a901      	add	r1, sp, #4
   19e92:	466a      	mov	r2, sp
   19e94:	f7ff fea4 	bl	19be0 <ble_att_conn_chan_find>
    if (rc == 0) {
   19e98:	4605      	mov	r5, r0
   19e9a:	b988      	cbnz	r0, 19ec0 <ble_att_clt_tx_req+0x44>
        /* Reduce the size of the transmission to fit the connection's ATT
         * MTU.
         */
        total_len = OS_MBUF_PKTLEN(txom);
        mtu = ble_l2cap_chan_mtu(chan);
   19e9c:	9800      	ldr	r0, [sp, #0]
    rc = ble_att_conn_chan_find(conn_handle, &conn, &chan);
    if (rc == 0) {
        /* Reduce the size of the transmission to fit the connection's ATT
         * MTU.
         */
        total_len = OS_MBUF_PKTLEN(txom);
   19e9e:	8a25      	ldrh	r5, [r4, #16]
        mtu = ble_l2cap_chan_mtu(chan);
   19ea0:	f7fb fcda 	bl	15858 <ble_l2cap_chan_mtu>
        extra_len = total_len - mtu;
   19ea4:	1a29      	subs	r1, r5, r0
        if (extra_len > 0) {
   19ea6:	2900      	cmp	r1, #0
   19ea8:	dd03      	ble.n	19eb2 <ble_att_clt_tx_req+0x36>
            os_mbuf_adj(txom, -extra_len);
   19eaa:	4620      	mov	r0, r4
   19eac:	4249      	negs	r1, r1
   19eae:	f7f0 f906 	bl	a0be <os_mbuf_adj>
        }

        rc = ble_l2cap_tx(conn, chan, txom);
   19eb2:	4622      	mov	r2, r4
   19eb4:	9801      	ldr	r0, [sp, #4]
   19eb6:	9900      	ldr	r1, [sp, #0]
   19eb8:	f7fb fd82 	bl	159c0 <ble_l2cap_tx>
        txom = NULL;
   19ebc:	2400      	movs	r4, #0
        extra_len = total_len - mtu;
        if (extra_len > 0) {
            os_mbuf_adj(txom, -extra_len);
        }

        rc = ble_l2cap_tx(conn, chan, txom);
   19ebe:	4605      	mov	r5, r0
        txom = NULL;
    }

    ble_hs_unlock();
   19ec0:	f7fa fc48 	bl	14754 <ble_hs_unlock>

    os_mbuf_free_chain(txom);
   19ec4:	4620      	mov	r0, r4
   19ec6:	f7f0 f84a 	bl	9f5e <os_mbuf_free_chain>
    return rc;
}
   19eca:	4628      	mov	r0, r5
   19ecc:	b003      	add	sp, #12
   19ece:	bd30      	pop	{r4, r5, pc}

00019ed0 <ble_att_clt_copy_attr_to_flatbuf>:
}

static int
ble_att_clt_copy_attr_to_flatbuf(const struct os_mbuf *om, void **out_attr_val,
                                 uint16_t *out_attr_len)
{
   19ed0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t *flat_buf;
    uint16_t attr_len;

    /* Make sure the attribute value isn't too big. */
    attr_len = OS_MBUF_PKTLEN(om);
   19ed4:	8a04      	ldrh	r4, [r0, #16]
    if (attr_len > BLE_ATT_ATTR_MAX_LEN) {
   19ed6:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
}

static int
ble_att_clt_copy_attr_to_flatbuf(const struct os_mbuf *om, void **out_attr_val,
                                 uint16_t *out_attr_len)
{
   19eda:	4680      	mov	r8, r0
   19edc:	460e      	mov	r6, r1
   19ede:	4615      	mov	r5, r2
    uint8_t *flat_buf;
    uint16_t attr_len;

    /* Make sure the attribute value isn't too big. */
    attr_len = OS_MBUF_PKTLEN(om);
    if (attr_len > BLE_ATT_ATTR_MAX_LEN) {
   19ee0:	d905      	bls.n	19eee <ble_att_clt_copy_attr_to_flatbuf+0x1e>
        *out_attr_len = 0;
   19ee2:	2300      	movs	r3, #0
   19ee4:	8013      	strh	r3, [r2, #0]
        *out_attr_val = NULL;
        return BLE_HS_EBADDATA;
   19ee6:	200a      	movs	r0, #10

    /* Make sure the attribute value isn't too big. */
    attr_len = OS_MBUF_PKTLEN(om);
    if (attr_len > BLE_ATT_ATTR_MAX_LEN) {
        *out_attr_len = 0;
        *out_attr_val = NULL;
   19ee8:	600b      	str	r3, [r1, #0]
        return BLE_HS_EBADDATA;
   19eea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /* Copy the attribute data into the global ATT flat buffer. */
    flat_buf = ble_att_get_flat_buf();
   19eee:	f7ff ff7d 	bl	19dec <ble_att_get_flat_buf>
   19ef2:	4607      	mov	r7, r0
    os_mbuf_copydata(om, 0, attr_len, flat_buf);
   19ef4:	2100      	movs	r1, #0
   19ef6:	4640      	mov	r0, r8
   19ef8:	4622      	mov	r2, r4
   19efa:	463b      	mov	r3, r7
   19efc:	f7f0 f8b8 	bl	a070 <os_mbuf_copydata>
    *out_attr_val = flat_buf;
   19f00:	6037      	str	r7, [r6, #0]
    *out_attr_len = attr_len;
    return 0;
   19f02:	2000      	movs	r0, #0

    /* Copy the attribute data into the global ATT flat buffer. */
    flat_buf = ble_att_get_flat_buf();
    os_mbuf_copydata(om, 0, attr_len, flat_buf);
    *out_attr_val = flat_buf;
    *out_attr_len = attr_len;
   19f04:	802c      	strh	r4, [r5, #0]
    return 0;
}
   19f06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00019f0a <ble_att_clt_init_req>:
#include "host/ble_uuid.h"
#include "ble_hs_priv.h"

static int
ble_att_clt_init_req(uint16_t initial_sz, struct os_mbuf **out_txom)
{
   19f0a:	b538      	push	{r3, r4, r5, lr}
   19f0c:	460c      	mov	r4, r1
   19f0e:	4605      	mov	r5, r0
    void *buf;
    int rc;

    *out_txom = ble_hs_misc_pkthdr();
   19f10:	f7fb fb00 	bl	15514 <ble_hs_misc_pkthdr>
   19f14:	6020      	str	r0, [r4, #0]
    if (*out_txom == NULL) {
   19f16:	b930      	cbnz	r0, 19f26 <ble_att_clt_init_req+0x1c>
    BLE_HS_DBG_ASSERT(buf == (*out_txom)->om_data);

    return 0;

err:
    os_mbuf_free_chain(*out_txom);
   19f18:	6820      	ldr	r0, [r4, #0]
   19f1a:	f7f0 f820 	bl	9f5e <os_mbuf_free_chain>
    *out_txom = NULL;
   19f1e:	2300      	movs	r3, #0
   19f20:	6023      	str	r3, [r4, #0]
   19f22:	2006      	movs	r0, #6
   19f24:	bd38      	pop	{r3, r4, r5, pc}
    if (*out_txom == NULL) {
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    buf = os_mbuf_extend(*out_txom, initial_sz);
   19f26:	4629      	mov	r1, r5
   19f28:	f7f0 f9a2 	bl	a270 <os_mbuf_extend>
    if (buf == NULL) {
   19f2c:	2800      	cmp	r0, #0
   19f2e:	d0f3      	beq.n	19f18 <ble_att_clt_init_req+0xe>
    }

    /* The caller expects the initial buffer to be at the start of the mbuf. */
    BLE_HS_DBG_ASSERT(buf == (*out_txom)->om_data);

    return 0;
   19f30:	2000      	movs	r0, #0

err:
    os_mbuf_free_chain(*out_txom);
    *out_txom = NULL;
    return rc;
}
   19f32:	bd38      	pop	{r3, r4, r5, pc}

00019f34 <ble_att_clt_append_blob.isra.2>:
ble_att_clt_append_blob(uint16_t conn_handle, struct os_mbuf *txom,
                        const void *blob, int blob_len)
{
    int rc;

    if (blob_len < 0) {
   19f34:	2a00      	cmp	r2, #0
   19f36:	db03      	blt.n	19f40 <ble_att_clt_append_blob.isra.2+0xc>
        return BLE_HS_EINVAL;
    }
    if (blob_len == 0) {
   19f38:	d004      	beq.n	19f44 <ble_att_clt_append_blob.isra.2+0x10>
        return 0;
    }

    rc = os_mbuf_append(txom, blob, blob_len);
   19f3a:	b292      	uxth	r2, r2
   19f3c:	f7f0 b818 	b.w	9f70 <os_mbuf_append>
                        const void *blob, int blob_len)
{
    int rc;

    if (blob_len < 0) {
        return BLE_HS_EINVAL;
   19f40:	2003      	movs	r0, #3
   19f42:	4770      	bx	lr
    }
    if (blob_len == 0) {
        return 0;
   19f44:	4610      	mov	r0, r2
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   19f46:	4770      	bx	lr

00019f48 <ble_att_clt_rx_error>:
 * $error response                                                           *
 *****************************************************************************/

int
ble_att_clt_rx_error(uint16_t conn_handle, struct os_mbuf **rxom)
{
   19f48:	b570      	push	{r4, r5, r6, lr}
   19f4a:	4605      	mov	r5, r0
   19f4c:	b086      	sub	sp, #24
    struct ble_att_error_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_ERROR_RSP_SZ);
   19f4e:	4608      	mov	r0, r1
 * $error response                                                           *
 *****************************************************************************/

int
ble_att_clt_rx_error(uint16_t conn_handle, struct os_mbuf **rxom)
{
   19f50:	460e      	mov	r6, r1
    struct ble_att_error_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_ERROR_RSP_SZ);
   19f52:	2105      	movs	r1, #5
   19f54:	f7fb faf0 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   19f58:	4604      	mov	r4, r0
   19f5a:	b9f8      	cbnz	r0, 19f9c <ble_att_clt_rx_error+0x54>
        return rc;
    }

    ble_att_error_rsp_parse((*rxom)->om_data, (*rxom)->om_len, &rsp);
   19f5c:	6833      	ldr	r3, [r6, #0]
   19f5e:	aa05      	add	r2, sp, #20
   19f60:	6818      	ldr	r0, [r3, #0]
   19f62:	88d9      	ldrh	r1, [r3, #6]
   19f64:	f000 fe8c 	bl	1ac80 <ble_att_error_rsp_parse>
    BLE_ATT_LOG_CMD(0, "error rsp", conn_handle, ble_att_error_rsp_log, &rsp);
   19f68:	4b0e      	ldr	r3, [pc, #56]	; (19fa4 <ble_att_clt_rx_error+0x5c>)
   19f6a:	9300      	str	r3, [sp, #0]
   19f6c:	4b0e      	ldr	r3, [pc, #56]	; (19fa8 <ble_att_clt_rx_error+0x60>)
   19f6e:	9301      	str	r3, [sp, #4]
   19f70:	4b0e      	ldr	r3, [pc, #56]	; (19fac <ble_att_clt_rx_error+0x64>)
   19f72:	9302      	str	r3, [sp, #8]
   19f74:	2104      	movs	r1, #4
   19f76:	4622      	mov	r2, r4
   19f78:	4b0d      	ldr	r3, [pc, #52]	; (19fb0 <ble_att_clt_rx_error+0x68>)
   19f7a:	480e      	ldr	r0, [pc, #56]	; (19fb4 <ble_att_clt_rx_error+0x6c>)
   19f7c:	9503      	str	r5, [sp, #12]
   19f7e:	f003 f953 	bl	1d228 <log_printf>
   19f82:	a805      	add	r0, sp, #20
   19f84:	f000 fe8e 	bl	1aca4 <ble_att_error_rsp_log>
   19f88:	480a      	ldr	r0, [pc, #40]	; (19fb4 <ble_att_clt_rx_error+0x6c>)
   19f8a:	4b0b      	ldr	r3, [pc, #44]	; (19fb8 <ble_att_clt_rx_error+0x70>)
   19f8c:	2104      	movs	r1, #4
   19f8e:	4622      	mov	r2, r4
   19f90:	f003 f94a 	bl	1d228 <log_printf>

    ble_gattc_rx_err(conn_handle, &rsp);
   19f94:	4628      	mov	r0, r5
   19f96:	a905      	add	r1, sp, #20
   19f98:	f7f9 f9c6 	bl	13328 <ble_gattc_rx_err>

    return 0;
}
   19f9c:	4620      	mov	r0, r4
   19f9e:	b006      	add	sp, #24
   19fa0:	bd70      	pop	{r4, r5, r6, pc}
   19fa2:	bf00      	nop
   19fa4:	0001fbda 	.word	0x0001fbda
   19fa8:	000207e0 	.word	0x000207e0
   19fac:	000207e4 	.word	0x000207e4
   19fb0:	0001fbbc 	.word	0x0001fbbc
   19fb4:	20003b9c 	.word	0x20003b9c
   19fb8:	0001fdec 	.word	0x0001fdec

00019fbc <ble_att_clt_rx_mtu>:
    return rc;
}

int
ble_att_clt_rx_mtu(uint16_t conn_handle, struct os_mbuf **rxom)
{
   19fbc:	b570      	push	{r4, r5, r6, lr}
   19fbe:	4606      	mov	r6, r0
   19fc0:	b086      	sub	sp, #24
    uint16_t mtu;
    int rc;

    mtu = 0;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_MTU_CMD_SZ);
   19fc2:	4608      	mov	r0, r1
    return rc;
}

int
ble_att_clt_rx_mtu(uint16_t conn_handle, struct os_mbuf **rxom)
{
   19fc4:	460d      	mov	r5, r1
    uint16_t mtu;
    int rc;

    mtu = 0;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_MTU_CMD_SZ);
   19fc6:	2103      	movs	r1, #3
   19fc8:	f7fb fab6 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc == 0) {
   19fcc:	4604      	mov	r4, r0
   19fce:	2800      	cmp	r0, #0
   19fd0:	d132      	bne.n	1a038 <ble_att_clt_rx_mtu+0x7c>
        ble_att_mtu_cmd_parse((*rxom)->om_data, (*rxom)->om_len, &cmd);
   19fd2:	682b      	ldr	r3, [r5, #0]
   19fd4:	aa04      	add	r2, sp, #16
   19fd6:	6818      	ldr	r0, [r3, #0]
   19fd8:	88d9      	ldrh	r1, [r3, #6]
   19fda:	f000 fe79 	bl	1acd0 <ble_att_mtu_cmd_parse>
        BLE_ATT_LOG_CMD(0, "mtu rsp", conn_handle, ble_att_mtu_cmd_log, &cmd);
   19fde:	4b1b      	ldr	r3, [pc, #108]	; (1a04c <ble_att_clt_rx_mtu+0x90>)
   19fe0:	9300      	str	r3, [sp, #0]
   19fe2:	4b1b      	ldr	r3, [pc, #108]	; (1a050 <ble_att_clt_rx_mtu+0x94>)
   19fe4:	9301      	str	r3, [sp, #4]
   19fe6:	4b1b      	ldr	r3, [pc, #108]	; (1a054 <ble_att_clt_rx_mtu+0x98>)
   19fe8:	9302      	str	r3, [sp, #8]
   19fea:	4622      	mov	r2, r4
   19fec:	2104      	movs	r1, #4
   19fee:	4b1a      	ldr	r3, [pc, #104]	; (1a058 <ble_att_clt_rx_mtu+0x9c>)
   19ff0:	481a      	ldr	r0, [pc, #104]	; (1a05c <ble_att_clt_rx_mtu+0xa0>)
   19ff2:	9603      	str	r6, [sp, #12]
   19ff4:	f003 f918 	bl	1d228 <log_printf>
   19ff8:	a804      	add	r0, sp, #16
   19ffa:	f000 fe73 	bl	1ace4 <ble_att_mtu_cmd_log>
   19ffe:	4622      	mov	r2, r4
   1a000:	4816      	ldr	r0, [pc, #88]	; (1a05c <ble_att_clt_rx_mtu+0xa0>)
   1a002:	4b17      	ldr	r3, [pc, #92]	; (1a060 <ble_att_clt_rx_mtu+0xa4>)
   1a004:	2104      	movs	r1, #4
   1a006:	f003 f90f 	bl	1d228 <log_printf>

        ble_hs_lock();
   1a00a:	f7fa fb9b 	bl	14744 <ble_hs_lock>

        rc = ble_att_conn_chan_find(conn_handle, NULL, &chan);
   1a00e:	4621      	mov	r1, r4
   1a010:	4630      	mov	r0, r6
   1a012:	aa05      	add	r2, sp, #20
   1a014:	f7ff fde4 	bl	19be0 <ble_att_conn_chan_find>
        if (rc == 0) {
   1a018:	4604      	mov	r4, r0
   1a01a:	b948      	cbnz	r0, 1a030 <ble_att_clt_rx_mtu+0x74>
            ble_att_set_peer_mtu(chan, cmd.bamc_mtu);
   1a01c:	9805      	ldr	r0, [sp, #20]
   1a01e:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   1a022:	f7ff fefa 	bl	19e1a <ble_att_set_peer_mtu>
            mtu = ble_l2cap_chan_mtu(chan);
   1a026:	9805      	ldr	r0, [sp, #20]
   1a028:	f7fb fc16 	bl	15858 <ble_l2cap_chan_mtu>
   1a02c:	4605      	mov	r5, r0
   1a02e:	e000      	b.n	1a032 <ble_att_clt_rx_mtu+0x76>
    struct ble_att_mtu_cmd cmd;
    struct ble_l2cap_chan *chan;
    uint16_t mtu;
    int rc;

    mtu = 0;
   1a030:	2500      	movs	r5, #0
        if (rc == 0) {
            ble_att_set_peer_mtu(chan, cmd.bamc_mtu);
            mtu = ble_l2cap_chan_mtu(chan);
        }

        ble_hs_unlock();
   1a032:	f7fa fb8f 	bl	14754 <ble_hs_unlock>
   1a036:	e000      	b.n	1a03a <ble_att_clt_rx_mtu+0x7e>
    struct ble_att_mtu_cmd cmd;
    struct ble_l2cap_chan *chan;
    uint16_t mtu;
    int rc;

    mtu = 0;
   1a038:	2500      	movs	r5, #0
        }

        ble_hs_unlock();
    }

    ble_gattc_rx_mtu(conn_handle, rc, mtu);
   1a03a:	4630      	mov	r0, r6
   1a03c:	4621      	mov	r1, r4
   1a03e:	462a      	mov	r2, r5
   1a040:	f7f9 f98c 	bl	1335c <ble_gattc_rx_mtu>
    return rc;
}
   1a044:	4620      	mov	r0, r4
   1a046:	b006      	add	sp, #24
   1a048:	bd70      	pop	{r4, r5, r6, pc}
   1a04a:	bf00      	nop
   1a04c:	0001fbda 	.word	0x0001fbda
   1a050:	000207e0 	.word	0x000207e0
   1a054:	000207f6 	.word	0x000207f6
   1a058:	0001fbbc 	.word	0x0001fbbc
   1a05c:	20003b9c 	.word	0x20003b9c
   1a060:	0001fdec 	.word	0x0001fdec

0001a064 <ble_att_clt_tx_find_info>:
}

int
ble_att_clt_tx_find_info(uint16_t conn_handle,
                         const struct ble_att_find_info_req *req)
{
   1a064:	b530      	push	{r4, r5, lr}
   1a066:	b087      	sub	sp, #28
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "find info req", conn_handle,
   1a068:	4b17      	ldr	r3, [pc, #92]	; (1a0c8 <ble_att_clt_tx_find_info+0x64>)
   1a06a:	9300      	str	r3, [sp, #0]
   1a06c:	4b17      	ldr	r3, [pc, #92]	; (1a0cc <ble_att_clt_tx_find_info+0x68>)
   1a06e:	9301      	str	r3, [sp, #4]
   1a070:	4b17      	ldr	r3, [pc, #92]	; (1a0d0 <ble_att_clt_tx_find_info+0x6c>)
   1a072:	9302      	str	r3, [sp, #8]
}

int
ble_att_clt_tx_find_info(uint16_t conn_handle,
                         const struct ble_att_find_info_req *req)
{
   1a074:	460c      	mov	r4, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "find info req", conn_handle,
   1a076:	2200      	movs	r2, #0
   1a078:	2104      	movs	r1, #4
   1a07a:	4b16      	ldr	r3, [pc, #88]	; (1a0d4 <ble_att_clt_tx_find_info+0x70>)
   1a07c:	9003      	str	r0, [sp, #12]
}

int
ble_att_clt_tx_find_info(uint16_t conn_handle,
                         const struct ble_att_find_info_req *req)
{
   1a07e:	4605      	mov	r5, r0
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "find info req", conn_handle,
   1a080:	4815      	ldr	r0, [pc, #84]	; (1a0d8 <ble_att_clt_tx_find_info+0x74>)
   1a082:	f003 f8d1 	bl	1d228 <log_printf>
   1a086:	4620      	mov	r0, r4
   1a088:	f000 fe4c 	bl	1ad24 <ble_att_find_info_req_log>
   1a08c:	4b13      	ldr	r3, [pc, #76]	; (1a0dc <ble_att_clt_tx_find_info+0x78>)
   1a08e:	4812      	ldr	r0, [pc, #72]	; (1a0d8 <ble_att_clt_tx_find_info+0x74>)
   1a090:	2104      	movs	r1, #4
   1a092:	2200      	movs	r2, #0
   1a094:	f003 f8c8 	bl	1d228 <log_printf>
                    ble_att_find_info_req_log, req);

    if (req->bafq_start_handle == 0 ||
   1a098:	8823      	ldrh	r3, [r4, #0]
   1a09a:	b193      	cbz	r3, 1a0c2 <ble_att_clt_tx_find_info+0x5e>
   1a09c:	8862      	ldrh	r2, [r4, #2]
   1a09e:	429a      	cmp	r2, r3
   1a0a0:	d30f      	bcc.n	1a0c2 <ble_att_clt_tx_find_info+0x5e>
                                struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    rc = ble_att_clt_init_req(BLE_ATT_FIND_INFO_REQ_SZ, &txom);
   1a0a2:	2005      	movs	r0, #5
   1a0a4:	a905      	add	r1, sp, #20
   1a0a6:	f7ff ff30 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1a0aa:	b958      	cbnz	r0, 1a0c4 <ble_att_clt_tx_find_info+0x60>
        return rc;
    }

    ble_att_find_info_req_write(txom->om_data, txom->om_len, req);
   1a0ac:	9b05      	ldr	r3, [sp, #20]
   1a0ae:	4622      	mov	r2, r4
   1a0b0:	6818      	ldr	r0, [r3, #0]
   1a0b2:	88d9      	ldrh	r1, [r3, #6]
   1a0b4:	f000 fe2d 	bl	1ad12 <ble_att_find_info_req_write>
    rc = ble_att_clt_build_find_info_req(req, &txom);
    if (rc != 0) {
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1a0b8:	4628      	mov	r0, r5
   1a0ba:	9905      	ldr	r1, [sp, #20]
   1a0bc:	f7ff fede 	bl	19e7c <ble_att_clt_tx_req>
   1a0c0:	e000      	b.n	1a0c4 <ble_att_clt_tx_find_info+0x60>
                    ble_att_find_info_req_log, req);

    if (req->bafq_start_handle == 0 ||
        req->bafq_start_handle > req->bafq_end_handle) {

        return BLE_HS_EINVAL;
   1a0c2:	2003      	movs	r0, #3
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1a0c4:	b007      	add	sp, #28
   1a0c6:	bd30      	pop	{r4, r5, pc}
   1a0c8:	0001fe60 	.word	0x0001fe60
   1a0cc:	000207e0 	.word	0x000207e0
   1a0d0:	000207fe 	.word	0x000207fe
   1a0d4:	0001fbbc 	.word	0x0001fbbc
   1a0d8:	20003b9c 	.word	0x20003b9c
   1a0dc:	0001fdec 	.word	0x0001fdec

0001a0e0 <ble_att_clt_rx_find_info>:
    return 0;
}

int
ble_att_clt_rx_find_info(uint16_t conn_handle, struct os_mbuf **om)
{
   1a0e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a0e4:	4607      	mov	r7, r0
   1a0e6:	b08a      	sub	sp, #40	; 0x28

    struct ble_att_find_info_idata idata;
    struct ble_att_find_info_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(om, BLE_ATT_FIND_INFO_RSP_BASE_SZ);
   1a0e8:	4608      	mov	r0, r1
    return 0;
}

int
ble_att_clt_rx_find_info(uint16_t conn_handle, struct os_mbuf **om)
{
   1a0ea:	460c      	mov	r4, r1

    struct ble_att_find_info_idata idata;
    struct ble_att_find_info_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(om, BLE_ATT_FIND_INFO_RSP_BASE_SZ);
   1a0ec:	2102      	movs	r1, #2
   1a0ee:	f7fb fa23 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   1a0f2:	4605      	mov	r5, r0
   1a0f4:	2800      	cmp	r0, #0
   1a0f6:	d159      	bne.n	1a1ac <ble_att_clt_rx_find_info+0xcc>
        goto done;
    }

    ble_att_find_info_rsp_parse((*om)->om_data, (*om)->om_len, &rsp);
   1a0f8:	6823      	ldr	r3, [r4, #0]
   1a0fa:	aa04      	add	r2, sp, #16
   1a0fc:	6818      	ldr	r0, [r3, #0]
   1a0fe:	88d9      	ldrh	r1, [r3, #6]
   1a100:	f000 fe22 	bl	1ad48 <ble_att_find_info_rsp_parse>
    BLE_ATT_LOG_CMD(0, "find info rsp", conn_handle, ble_att_find_info_rsp_log,
   1a104:	4b2d      	ldr	r3, [pc, #180]	; (1a1bc <ble_att_clt_rx_find_info+0xdc>)
   1a106:	9300      	str	r3, [sp, #0]
   1a108:	4b2d      	ldr	r3, [pc, #180]	; (1a1c0 <ble_att_clt_rx_find_info+0xe0>)
   1a10a:	9301      	str	r3, [sp, #4]
   1a10c:	4b2d      	ldr	r3, [pc, #180]	; (1a1c4 <ble_att_clt_rx_find_info+0xe4>)
   1a10e:	9302      	str	r3, [sp, #8]
   1a110:	2104      	movs	r1, #4
   1a112:	462a      	mov	r2, r5
   1a114:	4b2c      	ldr	r3, [pc, #176]	; (1a1c8 <ble_att_clt_rx_find_info+0xe8>)
   1a116:	482d      	ldr	r0, [pc, #180]	; (1a1cc <ble_att_clt_rx_find_info+0xec>)
   1a118:	9703      	str	r7, [sp, #12]
   1a11a:	f003 f885 	bl	1d228 <log_printf>
   1a11e:	a804      	add	r0, sp, #16
   1a120:	f000 fe1a 	bl	1ad58 <ble_att_find_info_rsp_log>
   1a124:	4829      	ldr	r0, [pc, #164]	; (1a1cc <ble_att_clt_rx_find_info+0xec>)
   1a126:	4b2a      	ldr	r3, [pc, #168]	; (1a1d0 <ble_att_clt_rx_find_info+0xf0>)
   1a128:	2104      	movs	r1, #4
   1a12a:	462a      	mov	r2, r5
   1a12c:	f003 f87c 	bl	1d228 <log_printf>
                    &rsp);

    /* Strip the response base from the front of the mbuf. */
    os_mbuf_adj((*om), BLE_ATT_FIND_INFO_RSP_BASE_SZ);
   1a130:	6820      	ldr	r0, [r4, #0]
   1a132:	2102      	movs	r1, #2
   1a134:	f7ef ffc3 	bl	a0be <os_mbuf_adj>

    while (OS_MBUF_PKTLEN(*om) > 0) {
   1a138:	6823      	ldr	r3, [r4, #0]
   1a13a:	8a1b      	ldrh	r3, [r3, #16]
   1a13c:	b3b3      	cbz	r3, 1a1ac <ble_att_clt_rx_find_info+0xcc>
        rc = ble_att_clt_parse_find_info_entry(om, rsp.bafp_format, &idata);
   1a13e:	f89d 6010 	ldrb.w	r6, [sp, #16]
{
    uint16_t uuid16;
    int entry_len;
    int rc;

    switch (rsp_format) {
   1a142:	2e01      	cmp	r6, #1
   1a144:	d004      	beq.n	1a150 <ble_att_clt_rx_find_info+0x70>
   1a146:	2e02      	cmp	r6, #2
   1a148:	d12e      	bne.n	1a1a8 <ble_att_clt_rx_find_info+0xc8>
    case BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT:
        entry_len = 2 + 2;
        break;

    case BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT:
        entry_len = 2 + 16;
   1a14a:	f04f 0812 	mov.w	r8, #18
   1a14e:	e001      	b.n	1a154 <ble_att_clt_rx_find_info+0x74>
    int entry_len;
    int rc;

    switch (rsp_format) {
    case BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT:
        entry_len = 2 + 2;
   1a150:	f04f 0804 	mov.w	r8, #4

    default:
        return BLE_HS_EBADDATA;
    }

    rc = ble_hs_misc_pullup_base(rxom, entry_len);
   1a154:	4620      	mov	r0, r4
   1a156:	4641      	mov	r1, r8
   1a158:	f7fb f9ee 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   1a15c:	bb28      	cbnz	r0, 1a1aa <ble_att_clt_rx_find_info+0xca>
        return rc;
    }

    idata->attr_handle = le16toh((*rxom)->om_data);
   1a15e:	6823      	ldr	r3, [r4, #0]
   1a160:	6818      	ldr	r0, [r3, #0]
   1a162:	f002 ff94 	bl	1d08e <le16toh>

    switch (rsp_format) {
   1a166:	2e01      	cmp	r6, #1
    rc = ble_hs_misc_pullup_base(rxom, entry_len);
    if (rc != 0) {
        return rc;
    }

    idata->attr_handle = le16toh((*rxom)->om_data);
   1a168:	f8ad 0014 	strh.w	r0, [sp, #20]

    switch (rsp_format) {
   1a16c:	d009      	beq.n	1a182 <ble_att_clt_rx_find_info+0xa2>
   1a16e:	2e02      	cmp	r6, #2
   1a170:	d111      	bne.n	1a196 <ble_att_clt_rx_find_info+0xb6>
            return BLE_HS_EBADDATA;
        }
        break;

    case BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT:
        rc = os_mbuf_copydata(*rxom, 2, 16, idata->uuid128);
   1a172:	6820      	ldr	r0, [r4, #0]
   1a174:	4631      	mov	r1, r6
   1a176:	2210      	movs	r2, #16
   1a178:	f10d 0316 	add.w	r3, sp, #22
   1a17c:	f7ef ff78 	bl	a070 <os_mbuf_copydata>
   1a180:	e008      	b.n	1a194 <ble_att_clt_rx_find_info+0xb4>

    idata->attr_handle = le16toh((*rxom)->om_data);

    switch (rsp_format) {
    case BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT:
        uuid16 = le16toh((*rxom)->om_data + 2);
   1a182:	6823      	ldr	r3, [r4, #0]
   1a184:	6818      	ldr	r0, [r3, #0]
   1a186:	3002      	adds	r0, #2
   1a188:	f002 ff81 	bl	1d08e <le16toh>
        rc = ble_uuid_16_to_128(uuid16, idata->uuid128);
   1a18c:	f10d 0116 	add.w	r1, sp, #22
   1a190:	f7fe f998 	bl	184c4 <ble_uuid_16_to_128>
        if (rc != 0) {
   1a194:	b940      	cbnz	r0, 1a1a8 <ble_att_clt_rx_find_info+0xc8>
    default:
        BLE_HS_DBG_ASSERT(0);
        break;
    }

    os_mbuf_adj(*rxom, entry_len);
   1a196:	6820      	ldr	r0, [r4, #0]
   1a198:	4641      	mov	r1, r8
   1a19a:	f7ef ff90 	bl	a0be <os_mbuf_adj>
        if (rc != 0) {
            goto done;
        }

        /* Hand find-info entry to GATT. */
        ble_gattc_rx_find_info_idata(conn_handle, &idata);
   1a19e:	4638      	mov	r0, r7
   1a1a0:	a905      	add	r1, sp, #20
   1a1a2:	f7f9 f8ee 	bl	13382 <ble_gattc_rx_find_info_idata>
   1a1a6:	e7c7      	b.n	1a138 <ble_att_clt_rx_find_info+0x58>
    case BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT:
        entry_len = 2 + 16;
        break;

    default:
        return BLE_HS_EBADDATA;
   1a1a8:	200a      	movs	r0, #10
    case BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT:
        entry_len = 2 + 2;
        break;

    case BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT:
        entry_len = 2 + 16;
   1a1aa:	4605      	mov	r5, r0

    rc = 0;

done:
    /* Notify GATT that response processing is done. */
    ble_gattc_rx_find_info_complete(conn_handle, rc);
   1a1ac:	4638      	mov	r0, r7
   1a1ae:	4629      	mov	r1, r5
   1a1b0:	f7f9 f918 	bl	133e4 <ble_gattc_rx_find_info_complete>
    return rc;
}
   1a1b4:	4628      	mov	r0, r5
   1a1b6:	b00a      	add	sp, #40	; 0x28
   1a1b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a1bc:	0001fbda 	.word	0x0001fbda
   1a1c0:	000207e0 	.word	0x000207e0
   1a1c4:	0002080c 	.word	0x0002080c
   1a1c8:	0001fbbc 	.word	0x0001fbbc
   1a1cc:	20003b9c 	.word	0x20003b9c
   1a1d0:	0001fdec 	.word	0x0001fdec

0001a1d4 <ble_att_clt_tx_find_type_value>:

int
ble_att_clt_tx_find_type_value(uint16_t conn_handle,
                               const struct ble_att_find_type_value_req *req,
                               const void *attribute_value, int value_len)
{
   1a1d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a1d6:	b087      	sub	sp, #28
   1a1d8:	461e      	mov	r6, r3
#if !NIMBLE_OPT(ATT_CLT_FIND_TYPE)
    return BLE_HS_ENOTSUP;
#endif

    BLE_ATT_LOG_CMD(1, "find type value req", conn_handle,
   1a1da:	4b1e      	ldr	r3, [pc, #120]	; (1a254 <ble_att_clt_tx_find_type_value+0x80>)
   1a1dc:	9300      	str	r3, [sp, #0]
   1a1de:	4b1e      	ldr	r3, [pc, #120]	; (1a258 <ble_att_clt_tx_find_type_value+0x84>)
   1a1e0:	9301      	str	r3, [sp, #4]
   1a1e2:	4b1e      	ldr	r3, [pc, #120]	; (1a25c <ble_att_clt_tx_find_type_value+0x88>)
   1a1e4:	9302      	str	r3, [sp, #8]

int
ble_att_clt_tx_find_type_value(uint16_t conn_handle,
                               const struct ble_att_find_type_value_req *req,
                               const void *attribute_value, int value_len)
{
   1a1e6:	460c      	mov	r4, r1
#if !NIMBLE_OPT(ATT_CLT_FIND_TYPE)
    return BLE_HS_ENOTSUP;
#endif

    BLE_ATT_LOG_CMD(1, "find type value req", conn_handle,
   1a1e8:	4b1d      	ldr	r3, [pc, #116]	; (1a260 <ble_att_clt_tx_find_type_value+0x8c>)
   1a1ea:	9003      	str	r0, [sp, #12]
   1a1ec:	2104      	movs	r1, #4

int
ble_att_clt_tx_find_type_value(uint16_t conn_handle,
                               const struct ble_att_find_type_value_req *req,
                               const void *attribute_value, int value_len)
{
   1a1ee:	4605      	mov	r5, r0
   1a1f0:	4617      	mov	r7, r2
#if !NIMBLE_OPT(ATT_CLT_FIND_TYPE)
    return BLE_HS_ENOTSUP;
#endif

    BLE_ATT_LOG_CMD(1, "find type value req", conn_handle,
   1a1f2:	481c      	ldr	r0, [pc, #112]	; (1a264 <ble_att_clt_tx_find_type_value+0x90>)
   1a1f4:	2200      	movs	r2, #0
   1a1f6:	f003 f817 	bl	1d228 <log_printf>
   1a1fa:	4620      	mov	r0, r4
   1a1fc:	f000 fdd2 	bl	1ada4 <ble_att_find_type_value_req_log>
   1a200:	4b19      	ldr	r3, [pc, #100]	; (1a268 <ble_att_clt_tx_find_type_value+0x94>)
   1a202:	4818      	ldr	r0, [pc, #96]	; (1a264 <ble_att_clt_tx_find_type_value+0x90>)
   1a204:	2104      	movs	r1, #4
   1a206:	2200      	movs	r2, #0
   1a208:	f003 f80e 	bl	1d228 <log_printf>
                    ble_att_find_type_value_req_log, req);

    struct os_mbuf *txom;
    int rc;

    if (req->bavq_start_handle == 0 ||
   1a20c:	8823      	ldrh	r3, [r4, #0]
   1a20e:	b1c3      	cbz	r3, 1a242 <ble_att_clt_tx_find_type_value+0x6e>
   1a210:	8862      	ldrh	r2, [r4, #2]
   1a212:	429a      	cmp	r2, r3
   1a214:	d315      	bcc.n	1a242 <ble_att_clt_tx_find_type_value+0x6e>
    const void *attribute_value, int value_len,
    struct os_mbuf **out_txom)
{
    int rc;

    rc = ble_att_clt_init_req(BLE_ATT_FIND_TYPE_VALUE_REQ_BASE_SZ, out_txom);
   1a216:	2007      	movs	r0, #7
   1a218:	a905      	add	r1, sp, #20
   1a21a:	f7ff fe76 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1a21e:	b9b0      	cbnz	r0, 1a24e <ble_att_clt_tx_find_type_value+0x7a>
        return rc;
    }

    ble_att_find_type_value_req_write((*out_txom)->om_data,
   1a220:	9b05      	ldr	r3, [sp, #20]
   1a222:	4622      	mov	r2, r4
   1a224:	6818      	ldr	r0, [r3, #0]
   1a226:	88d9      	ldrh	r1, [r3, #6]
   1a228:	f000 fdb0 	bl	1ad8c <ble_att_find_type_value_req_write>
                                      (*out_txom)->om_len,
                                      req);
    rc = os_mbuf_append(*out_txom, attribute_value, value_len);
   1a22c:	9805      	ldr	r0, [sp, #20]
   1a22e:	4639      	mov	r1, r7
   1a230:	b2b2      	uxth	r2, r6
   1a232:	f7ef fe9d 	bl	9f70 <os_mbuf_append>
    if (rc != 0) {
   1a236:	b130      	cbz	r0, 1a246 <ble_att_clt_tx_find_type_value+0x72>
        os_mbuf_free_chain(*out_txom);
   1a238:	9805      	ldr	r0, [sp, #20]
   1a23a:	f7ef fe90 	bl	9f5e <os_mbuf_free_chain>
        return BLE_HS_ENOMEM;
   1a23e:	2006      	movs	r0, #6
   1a240:	e005      	b.n	1a24e <ble_att_clt_tx_find_type_value+0x7a>
    int rc;

    if (req->bavq_start_handle == 0 ||
        req->bavq_start_handle > req->bavq_end_handle) {

        return BLE_HS_EINVAL;
   1a242:	2003      	movs	r0, #3
   1a244:	e003      	b.n	1a24e <ble_att_clt_tx_find_type_value+0x7a>
                                               &txom);
    if (rc != 0) {
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1a246:	4628      	mov	r0, r5
   1a248:	9905      	ldr	r1, [sp, #20]
   1a24a:	f7ff fe17 	bl	19e7c <ble_att_clt_tx_req>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1a24e:	b007      	add	sp, #28
   1a250:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a252:	bf00      	nop
   1a254:	0001fe60 	.word	0x0001fe60
   1a258:	000207e0 	.word	0x000207e0
   1a25c:	0002081a 	.word	0x0002081a
   1a260:	0001fbbc 	.word	0x0001fbbc
   1a264:	20003b9c 	.word	0x20003b9c
   1a268:	0001fdec 	.word	0x0001fdec

0001a26c <ble_att_clt_rx_find_type_value>:
    return 0;
}

int
ble_att_clt_rx_find_type_value(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a26c:	b530      	push	{r4, r5, lr}
   1a26e:	b087      	sub	sp, #28
#endif

    struct ble_att_find_type_value_hinfo hinfo;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "find type value rsp", conn_handle);
   1a270:	4b17      	ldr	r3, [pc, #92]	; (1a2d0 <ble_att_clt_rx_find_type_value+0x64>)
   1a272:	9300      	str	r3, [sp, #0]
   1a274:	4b17      	ldr	r3, [pc, #92]	; (1a2d4 <ble_att_clt_rx_find_type_value+0x68>)
   1a276:	9301      	str	r3, [sp, #4]
   1a278:	4b17      	ldr	r3, [pc, #92]	; (1a2d8 <ble_att_clt_rx_find_type_value+0x6c>)
   1a27a:	9302      	str	r3, [sp, #8]
    return 0;
}

int
ble_att_clt_rx_find_type_value(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a27c:	460d      	mov	r5, r1
#endif

    struct ble_att_find_type_value_hinfo hinfo;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "find type value rsp", conn_handle);
   1a27e:	9003      	str	r0, [sp, #12]
   1a280:	2104      	movs	r1, #4
   1a282:	2200      	movs	r2, #0
   1a284:	4b15      	ldr	r3, [pc, #84]	; (1a2dc <ble_att_clt_rx_find_type_value+0x70>)
    return 0;
}

int
ble_att_clt_rx_find_type_value(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a286:	4604      	mov	r4, r0
#endif

    struct ble_att_find_type_value_hinfo hinfo;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "find type value rsp", conn_handle);
   1a288:	4815      	ldr	r0, [pc, #84]	; (1a2e0 <ble_att_clt_rx_find_type_value+0x74>)
   1a28a:	f002 ffcd 	bl	1d228 <log_printf>
   1a28e:	4814      	ldr	r0, [pc, #80]	; (1a2e0 <ble_att_clt_rx_find_type_value+0x74>)
   1a290:	4b14      	ldr	r3, [pc, #80]	; (1a2e4 <ble_att_clt_rx_find_type_value+0x78>)
   1a292:	2104      	movs	r1, #4
   1a294:	2200      	movs	r2, #0
   1a296:	f002 ffc7 	bl	1d228 <log_printf>

    /* Reponse consists of a one-byte opcode (already verified) and a variable
     * length Handles-Information-List field.  Strip the opcode from the
     * response.
     */
    os_mbuf_adj(*rxom, BLE_ATT_FIND_TYPE_VALUE_RSP_BASE_SZ);
   1a29a:	6828      	ldr	r0, [r5, #0]
   1a29c:	2101      	movs	r1, #1
        if (rc != 0) {
            break;
        }

        ble_gattc_rx_find_type_value_hinfo(conn_handle, &hinfo);
        os_mbuf_adj(*rxom, BLE_ATT_FIND_TYPE_VALUE_HINFO_BASE_SZ);
   1a29e:	f7ef ff0e 	bl	a0be <os_mbuf_adj>
     */
    os_mbuf_adj(*rxom, BLE_ATT_FIND_TYPE_VALUE_RSP_BASE_SZ);

    /* Parse the Handles-Information-List field, passing each entry to GATT. */
    rc = 0;
    while (OS_MBUF_PKTLEN(*rxom) > 0) {
   1a2a2:	6828      	ldr	r0, [r5, #0]
   1a2a4:	8a01      	ldrh	r1, [r0, #16]
   1a2a6:	b169      	cbz	r1, 1a2c4 <ble_att_clt_rx_find_type_value+0x58>
ble_att_clt_parse_find_type_value_hinfo(
    struct os_mbuf **om, struct ble_att_find_type_value_hinfo *dst)
{
    int rc;

    rc = os_mbuf_copydata(*om, 0, BLE_ATT_FIND_TYPE_VALUE_HINFO_BASE_SZ, dst);
   1a2a8:	2100      	movs	r1, #0
   1a2aa:	2204      	movs	r2, #4
   1a2ac:	ab05      	add	r3, sp, #20
   1a2ae:	f7ef fedf 	bl	a070 <os_mbuf_copydata>
    if (rc != 0) {
   1a2b2:	b930      	cbnz	r0, 1a2c2 <ble_att_clt_rx_find_type_value+0x56>
        rc = ble_att_clt_parse_find_type_value_hinfo(rxom, &hinfo);
        if (rc != 0) {
            break;
        }

        ble_gattc_rx_find_type_value_hinfo(conn_handle, &hinfo);
   1a2b4:	4620      	mov	r0, r4
   1a2b6:	a905      	add	r1, sp, #20
   1a2b8:	f7f9 f8bb 	bl	13432 <ble_gattc_rx_find_type_value_hinfo>
        os_mbuf_adj(*rxom, BLE_ATT_FIND_TYPE_VALUE_HINFO_BASE_SZ);
   1a2bc:	6828      	ldr	r0, [r5, #0]
   1a2be:	2104      	movs	r1, #4
   1a2c0:	e7ed      	b.n	1a29e <ble_att_clt_rx_find_type_value+0x32>
{
    int rc;

    rc = os_mbuf_copydata(*om, 0, BLE_ATT_FIND_TYPE_VALUE_HINFO_BASE_SZ, dst);
    if (rc != 0) {
        return BLE_HS_EBADDATA;
   1a2c2:	210a      	movs	r1, #10
        ble_gattc_rx_find_type_value_hinfo(conn_handle, &hinfo);
        os_mbuf_adj(*rxom, BLE_ATT_FIND_TYPE_VALUE_HINFO_BASE_SZ);
    }

    /* Notify GATT client that the full response has been parsed. */
    ble_gattc_rx_find_type_value_complete(conn_handle, rc);
   1a2c4:	4620      	mov	r0, r4
   1a2c6:	f7f9 f8e9 	bl	1349c <ble_gattc_rx_find_type_value_complete>

    return 0;
}
   1a2ca:	2000      	movs	r0, #0
   1a2cc:	b007      	add	sp, #28
   1a2ce:	bd30      	pop	{r4, r5, pc}
   1a2d0:	0001fbda 	.word	0x0001fbda
   1a2d4:	000207e0 	.word	0x000207e0
   1a2d8:	0002082e 	.word	0x0002082e
   1a2dc:	0001fbbc 	.word	0x0001fbbc
   1a2e0:	20003b9c 	.word	0x20003b9c
   1a2e4:	0001fdec 	.word	0x0001fdec

0001a2e8 <ble_att_clt_tx_read_type>:

int
ble_att_clt_tx_read_type(uint16_t conn_handle,
                         const struct ble_att_read_type_req *req,
                         const void *uuid128)
{
   1a2e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a2ea:	b087      	sub	sp, #28
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read type req", conn_handle,
   1a2ec:	4b22      	ldr	r3, [pc, #136]	; (1a378 <ble_att_clt_tx_read_type+0x90>)
   1a2ee:	9300      	str	r3, [sp, #0]
   1a2f0:	4b22      	ldr	r3, [pc, #136]	; (1a37c <ble_att_clt_tx_read_type+0x94>)
   1a2f2:	9301      	str	r3, [sp, #4]
   1a2f4:	4b22      	ldr	r3, [pc, #136]	; (1a380 <ble_att_clt_tx_read_type+0x98>)
   1a2f6:	9302      	str	r3, [sp, #8]

int
ble_att_clt_tx_read_type(uint16_t conn_handle,
                         const struct ble_att_read_type_req *req,
                         const void *uuid128)
{
   1a2f8:	460d      	mov	r5, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read type req", conn_handle,
   1a2fa:	4b22      	ldr	r3, [pc, #136]	; (1a384 <ble_att_clt_tx_read_type+0x9c>)
   1a2fc:	9003      	str	r0, [sp, #12]
   1a2fe:	2104      	movs	r1, #4

int
ble_att_clt_tx_read_type(uint16_t conn_handle,
                         const struct ble_att_read_type_req *req,
                         const void *uuid128)
{
   1a300:	4606      	mov	r6, r0
   1a302:	4617      	mov	r7, r2
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read type req", conn_handle,
   1a304:	4820      	ldr	r0, [pc, #128]	; (1a388 <ble_att_clt_tx_read_type+0xa0>)
   1a306:	2200      	movs	r2, #0
   1a308:	f002 ff8e 	bl	1d228 <log_printf>
   1a30c:	4628      	mov	r0, r5
   1a30e:	f000 fd6d 	bl	1adec <ble_att_read_type_req_log>
   1a312:	4b1e      	ldr	r3, [pc, #120]	; (1a38c <ble_att_clt_tx_read_type+0xa4>)
   1a314:	481c      	ldr	r0, [pc, #112]	; (1a388 <ble_att_clt_tx_read_type+0xa0>)
   1a316:	2104      	movs	r1, #4
   1a318:	2200      	movs	r2, #0
   1a31a:	f002 ff85 	bl	1d228 <log_printf>
                    ble_att_read_type_req_log, req);

    if (req->batq_start_handle == 0 ||
   1a31e:	882b      	ldrh	r3, [r5, #0]
   1a320:	b1eb      	cbz	r3, 1a35e <ble_att_clt_tx_read_type+0x76>
   1a322:	886a      	ldrh	r2, [r5, #2]
   1a324:	429a      	cmp	r2, r3
   1a326:	d31a      	bcc.n	1a35e <ble_att_clt_tx_read_type+0x76>
                                const void *uuid128, struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1a328:	a906      	add	r1, sp, #24
   1a32a:	2300      	movs	r3, #0
   1a32c:	f841 3d04 	str.w	r3, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_READ_TYPE_REQ_BASE_SZ, &txom);
   1a330:	2005      	movs	r0, #5
   1a332:	f7ff fdea 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1a336:	4604      	mov	r4, r0
   1a338:	b9b0      	cbnz	r0, 1a368 <ble_att_clt_tx_read_type+0x80>
        goto done;
    }

    ble_att_read_type_req_write(txom->om_data, txom->om_len, req);
   1a33a:	9b05      	ldr	r3, [sp, #20]
   1a33c:	462a      	mov	r2, r5
   1a33e:	6818      	ldr	r0, [r3, #0]
   1a340:	88d9      	ldrh	r1, [r3, #6]
   1a342:	f000 fd4a 	bl	1adda <ble_att_read_type_req_write>

    rc = ble_uuid_append(txom, uuid128);
   1a346:	9805      	ldr	r0, [sp, #20]
   1a348:	4639      	mov	r1, r7
   1a34a:	f7fe f8d3 	bl	184f4 <ble_uuid_append>
    if (rc != 0) {
   1a34e:	4604      	mov	r4, r0
   1a350:	b948      	cbnz	r0, 1a366 <ble_att_clt_tx_read_type+0x7e>
    if (rc != 0) {
        os_mbuf_free_chain(txom);
        txom = NULL;
    }

    *out_txom = txom;
   1a352:	9905      	ldr	r1, [sp, #20]

        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_read_type_req(req, uuid128, &txom);
    if (rc != 0) {
   1a354:	b92c      	cbnz	r4, 1a362 <ble_att_clt_tx_read_type+0x7a>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1a356:	4630      	mov	r0, r6
   1a358:	f7ff fd90 	bl	19e7c <ble_att_clt_tx_req>
   1a35c:	e00a      	b.n	1a374 <ble_att_clt_tx_read_type+0x8c>
                    ble_att_read_type_req_log, req);

    if (req->batq_start_handle == 0 ||
        req->batq_start_handle > req->batq_end_handle) {

        return BLE_HS_EINVAL;
   1a35e:	2003      	movs	r0, #3
   1a360:	e008      	b.n	1a374 <ble_att_clt_tx_read_type+0x8c>
   1a362:	4620      	mov	r0, r4
   1a364:	e006      	b.n	1a374 <ble_att_clt_tx_read_type+0x8c>

    ble_att_read_type_req_write(txom->om_data, txom->om_len, req);

    rc = ble_uuid_append(txom, uuid128);
    if (rc != 0) {
        rc = BLE_HS_ENOMEM;
   1a366:	2406      	movs	r4, #6
        goto done;
    }

done:
    if (rc != 0) {
        os_mbuf_free_chain(txom);
   1a368:	9805      	ldr	r0, [sp, #20]
   1a36a:	f7ef fdf8 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1a36e:	2300      	movs	r3, #0
   1a370:	9305      	str	r3, [sp, #20]
   1a372:	e7ee      	b.n	1a352 <ble_att_clt_tx_read_type+0x6a>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1a374:	b007      	add	sp, #28
   1a376:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a378:	0001fe60 	.word	0x0001fe60
   1a37c:	000207e0 	.word	0x000207e0
   1a380:	00020842 	.word	0x00020842
   1a384:	0001fbbc 	.word	0x0001fbbc
   1a388:	20003b9c 	.word	0x20003b9c
   1a38c:	0001fdec 	.word	0x0001fdec

0001a390 <ble_att_clt_rx_read_type>:
    return 0;
}

int
ble_att_clt_rx_read_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a390:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a392:	4607      	mov	r7, r0
   1a394:	b089      	sub	sp, #36	; 0x24

    struct ble_att_read_type_adata adata;
    struct ble_att_read_type_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_READ_TYPE_RSP_BASE_SZ);
   1a396:	4608      	mov	r0, r1
    return 0;
}

int
ble_att_clt_rx_read_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a398:	460c      	mov	r4, r1

    struct ble_att_read_type_adata adata;
    struct ble_att_read_type_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_READ_TYPE_RSP_BASE_SZ);
   1a39a:	2102      	movs	r1, #2
   1a39c:	f7fb f8cc 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   1a3a0:	4605      	mov	r5, r0
   1a3a2:	2800      	cmp	r0, #0
   1a3a4:	d13e      	bne.n	1a424 <ble_att_clt_rx_read_type+0x94>
        goto done;
    }

    ble_att_read_type_rsp_parse((*rxom)->om_data, (*rxom)->om_len, &rsp);
   1a3a6:	6823      	ldr	r3, [r4, #0]
   1a3a8:	aa04      	add	r2, sp, #16
   1a3aa:	6818      	ldr	r0, [r3, #0]
   1a3ac:	88d9      	ldrh	r1, [r3, #6]
   1a3ae:	f000 fd2f 	bl	1ae10 <ble_att_read_type_rsp_parse>
    BLE_ATT_LOG_CMD(0, "read type rsp", conn_handle, ble_att_read_type_rsp_log,
   1a3b2:	4b20      	ldr	r3, [pc, #128]	; (1a434 <ble_att_clt_rx_read_type+0xa4>)
   1a3b4:	9300      	str	r3, [sp, #0]
   1a3b6:	4b20      	ldr	r3, [pc, #128]	; (1a438 <ble_att_clt_rx_read_type+0xa8>)
   1a3b8:	9301      	str	r3, [sp, #4]
   1a3ba:	4b20      	ldr	r3, [pc, #128]	; (1a43c <ble_att_clt_rx_read_type+0xac>)
   1a3bc:	9302      	str	r3, [sp, #8]
   1a3be:	2104      	movs	r1, #4
   1a3c0:	462a      	mov	r2, r5
   1a3c2:	4b1f      	ldr	r3, [pc, #124]	; (1a440 <ble_att_clt_rx_read_type+0xb0>)
   1a3c4:	481f      	ldr	r0, [pc, #124]	; (1a444 <ble_att_clt_rx_read_type+0xb4>)
   1a3c6:	9703      	str	r7, [sp, #12]
   1a3c8:	f002 ff2e 	bl	1d228 <log_printf>
   1a3cc:	a804      	add	r0, sp, #16
   1a3ce:	f000 fd27 	bl	1ae20 <ble_att_read_type_rsp_log>
   1a3d2:	481c      	ldr	r0, [pc, #112]	; (1a444 <ble_att_clt_rx_read_type+0xb4>)
   1a3d4:	4b1c      	ldr	r3, [pc, #112]	; (1a448 <ble_att_clt_rx_read_type+0xb8>)
   1a3d6:	2104      	movs	r1, #4
   1a3d8:	462a      	mov	r2, r5
   1a3da:	f002 ff25 	bl	1d228 <log_printf>
                    &rsp);

    /* Strip the response base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_READ_TYPE_RSP_BASE_SZ);
   1a3de:	6820      	ldr	r0, [r4, #0]
   1a3e0:	2102      	movs	r1, #2
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_type_adata(conn_handle, &adata);
        os_mbuf_adj(*rxom, rsp.batp_length);
   1a3e2:	f7ef fe6c 	bl	a0be <os_mbuf_adj>

    /* Strip the response base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_READ_TYPE_RSP_BASE_SZ);

    /* Parse the Attribute Data List field, passing each entry to the GATT. */
    while (OS_MBUF_PKTLEN(*rxom) > 0) {
   1a3e6:	6823      	ldr	r3, [r4, #0]
   1a3e8:	8a1b      	ldrh	r3, [r3, #16]
   1a3ea:	b1db      	cbz	r3, 1a424 <ble_att_clt_rx_read_type+0x94>
        rc = ble_att_clt_parse_read_type_adata(rxom, rsp.batp_length, &adata);
   1a3ec:	f89d 6010 	ldrb.w	r6, [sp, #16]
ble_att_clt_parse_read_type_adata(struct os_mbuf **om, int data_len,
                                  struct ble_att_read_type_adata *adata)
{
    int rc;

    rc = ble_hs_misc_pullup_base(om, data_len);
   1a3f0:	4620      	mov	r0, r4
   1a3f2:	4631      	mov	r1, r6
   1a3f4:	f7fb f8a0 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   1a3f8:	b998      	cbnz	r0, 1a422 <ble_att_clt_rx_read_type+0x92>
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
   1a3fa:	6823      	ldr	r3, [r4, #0]
   1a3fc:	6818      	ldr	r0, [r3, #0]
   1a3fe:	f002 fe46 	bl	1d08e <le16toh>
    adata->value_len = data_len - BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
    adata->value = (*om)->om_data + BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
   1a402:	6823      	ldr	r3, [r4, #0]
    rc = ble_hs_misc_pullup_base(om, data_len);
    if (rc != 0) {
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
   1a404:	f8ad 0014 	strh.w	r0, [sp, #20]
    adata->value_len = data_len - BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
    adata->value = (*om)->om_data + BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
   1a408:	681b      	ldr	r3, [r3, #0]
        rc = ble_att_clt_parse_read_type_adata(rxom, rsp.batp_length, &adata);
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_type_adata(conn_handle, &adata);
   1a40a:	4638      	mov	r0, r7
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
    adata->value_len = data_len - BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
    adata->value = (*om)->om_data + BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
   1a40c:	3302      	adds	r3, #2
        rc = ble_att_clt_parse_read_type_adata(rxom, rsp.batp_length, &adata);
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_type_adata(conn_handle, &adata);
   1a40e:	a905      	add	r1, sp, #20
    if (rc != 0) {
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
    adata->value_len = data_len - BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
   1a410:	3e02      	subs	r6, #2
   1a412:	9606      	str	r6, [sp, #24]
    adata->value = (*om)->om_data + BLE_ATT_READ_TYPE_ADATA_BASE_SZ;
   1a414:	9307      	str	r3, [sp, #28]
        rc = ble_att_clt_parse_read_type_adata(rxom, rsp.batp_length, &adata);
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_type_adata(conn_handle, &adata);
   1a416:	f7f9 f871 	bl	134fc <ble_gattc_rx_read_type_adata>
        os_mbuf_adj(*rxom, rsp.batp_length);
   1a41a:	6820      	ldr	r0, [r4, #0]
   1a41c:	f89d 1010 	ldrb.w	r1, [sp, #16]
   1a420:	e7df      	b.n	1a3e2 <ble_att_clt_rx_read_type+0x52>
                                  struct ble_att_read_type_adata *adata)
{
    int rc;

    rc = ble_hs_misc_pullup_base(om, data_len);
    if (rc != 0) {
   1a422:	4605      	mov	r5, r0
        os_mbuf_adj(*rxom, rsp.batp_length);
    }

done:
    /* Notify GATT that the response is done being parsed. */
    ble_gattc_rx_read_type_complete(conn_handle, rc);
   1a424:	4638      	mov	r0, r7
   1a426:	4629      	mov	r1, r5
   1a428:	f7f9 f87e 	bl	13528 <ble_gattc_rx_read_type_complete>
    return rc;

}
   1a42c:	4628      	mov	r0, r5
   1a42e:	b009      	add	sp, #36	; 0x24
   1a430:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a432:	bf00      	nop
   1a434:	0001fbda 	.word	0x0001fbda
   1a438:	000207e0 	.word	0x000207e0
   1a43c:	00020850 	.word	0x00020850
   1a440:	0001fbbc 	.word	0x0001fbbc
   1a444:	20003b9c 	.word	0x20003b9c
   1a448:	0001fdec 	.word	0x0001fdec

0001a44c <ble_att_clt_tx_read>:
    return rc;
}

int
ble_att_clt_tx_read(uint16_t conn_handle, const struct ble_att_read_req *req)
{
   1a44c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a44e:	b087      	sub	sp, #28
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read req", conn_handle,
   1a450:	4b1c      	ldr	r3, [pc, #112]	; (1a4c4 <ble_att_clt_tx_read+0x78>)
   1a452:	9300      	str	r3, [sp, #0]
   1a454:	4b1c      	ldr	r3, [pc, #112]	; (1a4c8 <ble_att_clt_tx_read+0x7c>)
   1a456:	9301      	str	r3, [sp, #4]
   1a458:	4b1c      	ldr	r3, [pc, #112]	; (1a4cc <ble_att_clt_tx_read+0x80>)
   1a45a:	9302      	str	r3, [sp, #8]
    return rc;
}

int
ble_att_clt_tx_read(uint16_t conn_handle, const struct ble_att_read_req *req)
{
   1a45c:	460d      	mov	r5, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read req", conn_handle,
   1a45e:	2200      	movs	r2, #0
   1a460:	2104      	movs	r1, #4
   1a462:	4b1b      	ldr	r3, [pc, #108]	; (1a4d0 <ble_att_clt_tx_read+0x84>)
   1a464:	9003      	str	r0, [sp, #12]
    return rc;
}

int
ble_att_clt_tx_read(uint16_t conn_handle, const struct ble_att_read_req *req)
{
   1a466:	4607      	mov	r7, r0
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read req", conn_handle,
   1a468:	481a      	ldr	r0, [pc, #104]	; (1a4d4 <ble_att_clt_tx_read+0x88>)
   1a46a:	f002 fedd 	bl	1d228 <log_printf>
   1a46e:	4628      	mov	r0, r5
   1a470:	f000 fcf0 	bl	1ae54 <ble_att_read_req_log>
   1a474:	4b18      	ldr	r3, [pc, #96]	; (1a4d8 <ble_att_clt_tx_read+0x8c>)
   1a476:	4817      	ldr	r0, [pc, #92]	; (1a4d4 <ble_att_clt_tx_read+0x88>)
   1a478:	2104      	movs	r1, #4
   1a47a:	2200      	movs	r2, #0
   1a47c:	f002 fed4 	bl	1d228 <log_printf>
                    ble_att_read_req_log, req);

    if (req->barq_handle == 0) {
   1a480:	882b      	ldrh	r3, [r5, #0]
   1a482:	b1a3      	cbz	r3, 1a4ae <ble_att_clt_tx_read+0x62>
                           struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1a484:	a906      	add	r1, sp, #24
   1a486:	2600      	movs	r6, #0
   1a488:	f841 6d04 	str.w	r6, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_READ_REQ_SZ, &txom);
   1a48c:	2003      	movs	r0, #3
   1a48e:	f7ff fd3c 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1a492:	4604      	mov	r4, r0
   1a494:	b978      	cbnz	r0, 1a4b6 <ble_att_clt_tx_read+0x6a>
        goto done;
    }

    ble_att_read_req_write(txom->om_data, txom->om_len, req);
   1a496:	9b05      	ldr	r3, [sp, #20]
   1a498:	462a      	mov	r2, r5
   1a49a:	6818      	ldr	r0, [r3, #0]
   1a49c:	88d9      	ldrh	r1, [r3, #6]
   1a49e:	f000 fcd3 	bl	1ae48 <ble_att_read_req_write>
    if (rc != 0) {
        os_mbuf_free_chain(txom);
        txom = NULL;
    }

    *out_txom = txom;
   1a4a2:	9905      	ldr	r1, [sp, #20]
    if (req->barq_handle == 0) {
        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_read_req(req, &txom);
    if (rc != 0) {
   1a4a4:	b92c      	cbnz	r4, 1a4b2 <ble_att_clt_tx_read+0x66>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1a4a6:	4638      	mov	r0, r7
   1a4a8:	f7ff fce8 	bl	19e7c <ble_att_clt_tx_req>
   1a4ac:	e008      	b.n	1a4c0 <ble_att_clt_tx_read+0x74>

    BLE_ATT_LOG_CMD(1, "read req", conn_handle,
                    ble_att_read_req_log, req);

    if (req->barq_handle == 0) {
        return BLE_HS_EINVAL;
   1a4ae:	2003      	movs	r0, #3
   1a4b0:	e006      	b.n	1a4c0 <ble_att_clt_tx_read+0x74>
   1a4b2:	4620      	mov	r0, r4
   1a4b4:	e004      	b.n	1a4c0 <ble_att_clt_tx_read+0x74>

    ble_att_read_req_write(txom->om_data, txom->om_len, req);

done:
    if (rc != 0) {
        os_mbuf_free_chain(txom);
   1a4b6:	9805      	ldr	r0, [sp, #20]
   1a4b8:	f7ef fd51 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1a4bc:	9605      	str	r6, [sp, #20]
   1a4be:	e7f0      	b.n	1a4a2 <ble_att_clt_tx_read+0x56>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1a4c0:	b007      	add	sp, #28
   1a4c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a4c4:	0001fe60 	.word	0x0001fe60
   1a4c8:	000207e0 	.word	0x000207e0
   1a4cc:	0002085e 	.word	0x0002085e
   1a4d0:	0001fbbc 	.word	0x0001fbbc
   1a4d4:	20003b9c 	.word	0x20003b9c
   1a4d8:	0001fdec 	.word	0x0001fdec

0001a4dc <ble_att_clt_rx_read>:

int
ble_att_clt_rx_read(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a4dc:	b570      	push	{r4, r5, r6, lr}
   1a4de:	b086      	sub	sp, #24

    uint16_t value_len;
    void *value;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read rsp", conn_handle);
   1a4e0:	4b15      	ldr	r3, [pc, #84]	; (1a538 <ble_att_clt_rx_read+0x5c>)
   1a4e2:	4e16      	ldr	r6, [pc, #88]	; (1a53c <ble_att_clt_rx_read+0x60>)
   1a4e4:	9300      	str	r3, [sp, #0]
   1a4e6:	4b16      	ldr	r3, [pc, #88]	; (1a540 <ble_att_clt_rx_read+0x64>)
   1a4e8:	9301      	str	r3, [sp, #4]
   1a4ea:	4b16      	ldr	r3, [pc, #88]	; (1a544 <ble_att_clt_rx_read+0x68>)
   1a4ec:	9302      	str	r3, [sp, #8]
    return 0;
}

int
ble_att_clt_rx_read(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a4ee:	460c      	mov	r4, r1
   1a4f0:	4605      	mov	r5, r0

    uint16_t value_len;
    void *value;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read rsp", conn_handle);
   1a4f2:	9003      	str	r0, [sp, #12]
   1a4f4:	2104      	movs	r1, #4
   1a4f6:	4630      	mov	r0, r6
   1a4f8:	2200      	movs	r2, #0
   1a4fa:	4b13      	ldr	r3, [pc, #76]	; (1a548 <ble_att_clt_rx_read+0x6c>)
   1a4fc:	f002 fe94 	bl	1d228 <log_printf>
   1a500:	4b12      	ldr	r3, [pc, #72]	; (1a54c <ble_att_clt_rx_read+0x70>)
   1a502:	4630      	mov	r0, r6
   1a504:	2200      	movs	r2, #0
   1a506:	2104      	movs	r1, #4
   1a508:	f002 fe8e 	bl	1d228 <log_printf>

    /* Reponse consists of a one-byte opcode (already verified) and a variable
     * length Attribute Value field.  Strip the opcode from the response.
     */
    os_mbuf_adj(*rxom, BLE_ATT_READ_RSP_BASE_SZ);
   1a50c:	6820      	ldr	r0, [r4, #0]
   1a50e:	2101      	movs	r1, #1
   1a510:	f7ef fdd5 	bl	a0be <os_mbuf_adj>

    /* Copy the attribute data into the global ATT flat buffer. */
    rc = ble_att_clt_copy_attr_to_flatbuf(*rxom, &value, &value_len);
   1a514:	a905      	add	r1, sp, #20
   1a516:	f10d 0212 	add.w	r2, sp, #18
   1a51a:	6820      	ldr	r0, [r4, #0]
   1a51c:	f7ff fcd8 	bl	19ed0 <ble_att_clt_copy_attr_to_flatbuf>
   1a520:	4604      	mov	r4, r0

    /* Pass the Attribute Value field to GATT. */
    ble_gattc_rx_read_rsp(conn_handle, rc, value, value_len);
   1a522:	4621      	mov	r1, r4
   1a524:	4628      	mov	r0, r5
   1a526:	9a05      	ldr	r2, [sp, #20]
   1a528:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1a52c:	f7f9 f888 	bl	13640 <ble_gattc_rx_read_rsp>
    return rc;
}
   1a530:	4620      	mov	r0, r4
   1a532:	b006      	add	sp, #24
   1a534:	bd70      	pop	{r4, r5, r6, pc}
   1a536:	bf00      	nop
   1a538:	0001fbda 	.word	0x0001fbda
   1a53c:	20003b9c 	.word	0x20003b9c
   1a540:	000207e0 	.word	0x000207e0
   1a544:	00020867 	.word	0x00020867
   1a548:	0001fbbc 	.word	0x0001fbbc
   1a54c:	0001fdec 	.word	0x0001fdec

0001a550 <ble_att_clt_tx_read_blob>:
}

int
ble_att_clt_tx_read_blob(uint16_t conn_handle,
                         const struct ble_att_read_blob_req *req)
{
   1a550:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a552:	b087      	sub	sp, #28
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read blob req", conn_handle,
   1a554:	4b1c      	ldr	r3, [pc, #112]	; (1a5c8 <ble_att_clt_tx_read_blob+0x78>)
   1a556:	9300      	str	r3, [sp, #0]
   1a558:	4b1c      	ldr	r3, [pc, #112]	; (1a5cc <ble_att_clt_tx_read_blob+0x7c>)
   1a55a:	9301      	str	r3, [sp, #4]
   1a55c:	4b1c      	ldr	r3, [pc, #112]	; (1a5d0 <ble_att_clt_tx_read_blob+0x80>)
   1a55e:	9302      	str	r3, [sp, #8]
}

int
ble_att_clt_tx_read_blob(uint16_t conn_handle,
                         const struct ble_att_read_blob_req *req)
{
   1a560:	460d      	mov	r5, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read blob req", conn_handle,
   1a562:	2200      	movs	r2, #0
   1a564:	2104      	movs	r1, #4
   1a566:	4b1b      	ldr	r3, [pc, #108]	; (1a5d4 <ble_att_clt_tx_read_blob+0x84>)
   1a568:	9003      	str	r0, [sp, #12]
}

int
ble_att_clt_tx_read_blob(uint16_t conn_handle,
                         const struct ble_att_read_blob_req *req)
{
   1a56a:	4607      	mov	r7, r0
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "read blob req", conn_handle,
   1a56c:	481a      	ldr	r0, [pc, #104]	; (1a5d8 <ble_att_clt_tx_read_blob+0x88>)
   1a56e:	f002 fe5b 	bl	1d228 <log_printf>
   1a572:	4628      	mov	r0, r5
   1a574:	f000 fc8e 	bl	1ae94 <ble_att_read_blob_req_log>
   1a578:	4b18      	ldr	r3, [pc, #96]	; (1a5dc <ble_att_clt_tx_read_blob+0x8c>)
   1a57a:	4817      	ldr	r0, [pc, #92]	; (1a5d8 <ble_att_clt_tx_read_blob+0x88>)
   1a57c:	2104      	movs	r1, #4
   1a57e:	2200      	movs	r2, #0
   1a580:	f002 fe52 	bl	1d228 <log_printf>
                    ble_att_read_blob_req_log, req);

    if (req->babq_handle == 0) {
   1a584:	882b      	ldrh	r3, [r5, #0]
   1a586:	b1a3      	cbz	r3, 1a5b2 <ble_att_clt_tx_read_blob+0x62>
                                struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1a588:	a906      	add	r1, sp, #24
   1a58a:	2600      	movs	r6, #0
   1a58c:	f841 6d04 	str.w	r6, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_READ_BLOB_REQ_SZ, &txom);
   1a590:	2005      	movs	r0, #5
   1a592:	f7ff fcba 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1a596:	4604      	mov	r4, r0
   1a598:	b978      	cbnz	r0, 1a5ba <ble_att_clt_tx_read_blob+0x6a>
        goto done;
    }

    ble_att_read_blob_req_write(txom->om_data, txom->om_len, req);
   1a59a:	9b05      	ldr	r3, [sp, #20]
   1a59c:	462a      	mov	r2, r5
   1a59e:	6818      	ldr	r0, [r3, #0]
   1a5a0:	88d9      	ldrh	r1, [r3, #6]
   1a5a2:	f000 fc6e 	bl	1ae82 <ble_att_read_blob_req_write>
    if (rc != 0) {
        os_mbuf_free_chain(txom);
        txom = NULL;
    }

    *out_txom = txom;
   1a5a6:	9905      	ldr	r1, [sp, #20]
    if (req->babq_handle == 0) {
        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_read_blob_req(req, &txom);
    if (rc != 0) {
   1a5a8:	b92c      	cbnz	r4, 1a5b6 <ble_att_clt_tx_read_blob+0x66>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1a5aa:	4638      	mov	r0, r7
   1a5ac:	f7ff fc66 	bl	19e7c <ble_att_clt_tx_req>
   1a5b0:	e008      	b.n	1a5c4 <ble_att_clt_tx_read_blob+0x74>

    BLE_ATT_LOG_CMD(1, "read blob req", conn_handle,
                    ble_att_read_blob_req_log, req);

    if (req->babq_handle == 0) {
        return BLE_HS_EINVAL;
   1a5b2:	2003      	movs	r0, #3
   1a5b4:	e006      	b.n	1a5c4 <ble_att_clt_tx_read_blob+0x74>
   1a5b6:	4620      	mov	r0, r4
   1a5b8:	e004      	b.n	1a5c4 <ble_att_clt_tx_read_blob+0x74>

    ble_att_read_blob_req_write(txom->om_data, txom->om_len, req);

done:
    if (rc != 0) {
        os_mbuf_free_chain(txom);
   1a5ba:	9805      	ldr	r0, [sp, #20]
   1a5bc:	f7ef fccf 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1a5c0:	9605      	str	r6, [sp, #20]
   1a5c2:	e7f0      	b.n	1a5a6 <ble_att_clt_tx_read_blob+0x56>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1a5c4:	b007      	add	sp, #28
   1a5c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a5c8:	0001fe60 	.word	0x0001fe60
   1a5cc:	000207e0 	.word	0x000207e0
   1a5d0:	00020870 	.word	0x00020870
   1a5d4:	0001fbbc 	.word	0x0001fbbc
   1a5d8:	20003b9c 	.word	0x20003b9c
   1a5dc:	0001fdec 	.word	0x0001fdec

0001a5e0 <ble_att_clt_rx_read_blob>:

int
ble_att_clt_rx_read_blob(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a5e0:	b570      	push	{r4, r5, r6, lr}
   1a5e2:	b086      	sub	sp, #24

    uint16_t value_len;
    void *value;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read blob rsp", conn_handle);
   1a5e4:	4b15      	ldr	r3, [pc, #84]	; (1a63c <ble_att_clt_rx_read_blob+0x5c>)
   1a5e6:	4e16      	ldr	r6, [pc, #88]	; (1a640 <ble_att_clt_rx_read_blob+0x60>)
   1a5e8:	9300      	str	r3, [sp, #0]
   1a5ea:	4b16      	ldr	r3, [pc, #88]	; (1a644 <ble_att_clt_rx_read_blob+0x64>)
   1a5ec:	9301      	str	r3, [sp, #4]
   1a5ee:	4b16      	ldr	r3, [pc, #88]	; (1a648 <ble_att_clt_rx_read_blob+0x68>)
   1a5f0:	9302      	str	r3, [sp, #8]
    return 0;
}

int
ble_att_clt_rx_read_blob(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a5f2:	460c      	mov	r4, r1
   1a5f4:	4605      	mov	r5, r0

    uint16_t value_len;
    void *value;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read blob rsp", conn_handle);
   1a5f6:	9003      	str	r0, [sp, #12]
   1a5f8:	2104      	movs	r1, #4
   1a5fa:	4630      	mov	r0, r6
   1a5fc:	2200      	movs	r2, #0
   1a5fe:	4b13      	ldr	r3, [pc, #76]	; (1a64c <ble_att_clt_rx_read_blob+0x6c>)
   1a600:	f002 fe12 	bl	1d228 <log_printf>
   1a604:	4b12      	ldr	r3, [pc, #72]	; (1a650 <ble_att_clt_rx_read_blob+0x70>)
   1a606:	4630      	mov	r0, r6
   1a608:	2200      	movs	r2, #0
   1a60a:	2104      	movs	r1, #4
   1a60c:	f002 fe0c 	bl	1d228 <log_printf>

    /* Reponse consists of a one-byte opcode (already verified) and a variable
     * length Attribute Value field.  Strip the opcode from the response.
     */
    os_mbuf_adj(*rxom, BLE_ATT_READ_BLOB_RSP_BASE_SZ);
   1a610:	6820      	ldr	r0, [r4, #0]
   1a612:	2101      	movs	r1, #1
   1a614:	f7ef fd53 	bl	a0be <os_mbuf_adj>

    /* Copy the attribute data into the global ATT flat buffer. */
    rc = ble_att_clt_copy_attr_to_flatbuf(*rxom, &value, &value_len);
   1a618:	a905      	add	r1, sp, #20
   1a61a:	f10d 0212 	add.w	r2, sp, #18
   1a61e:	6820      	ldr	r0, [r4, #0]
   1a620:	f7ff fc56 	bl	19ed0 <ble_att_clt_copy_attr_to_flatbuf>
   1a624:	4604      	mov	r4, r0

    /* Pass the Attribute Value field to GATT. */
    ble_gattc_rx_read_blob_rsp(conn_handle, rc, value, value_len);
   1a626:	4621      	mov	r1, r4
   1a628:	4628      	mov	r0, r5
   1a62a:	9a05      	ldr	r2, [sp, #20]
   1a62c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1a630:	f7f9 f822 	bl	13678 <ble_gattc_rx_read_blob_rsp>
    return rc;
}
   1a634:	4620      	mov	r0, r4
   1a636:	b006      	add	sp, #24
   1a638:	bd70      	pop	{r4, r5, r6, pc}
   1a63a:	bf00      	nop
   1a63c:	0001fbda 	.word	0x0001fbda
   1a640:	20003b9c 	.word	0x20003b9c
   1a644:	000207e0 	.word	0x000207e0
   1a648:	0002087e 	.word	0x0002087e
   1a64c:	0001fbbc 	.word	0x0001fbbc
   1a650:	0001fdec 	.word	0x0001fdec

0001a654 <ble_att_clt_rx_read_mult>:
    return 0;
}

int
ble_att_clt_rx_read_mult(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a654:	b570      	push	{r4, r5, r6, lr}
   1a656:	b086      	sub	sp, #24

    uint16_t value_len;
    void *value;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult rsp", conn_handle);
   1a658:	4b15      	ldr	r3, [pc, #84]	; (1a6b0 <ble_att_clt_rx_read_mult+0x5c>)
   1a65a:	4e16      	ldr	r6, [pc, #88]	; (1a6b4 <ble_att_clt_rx_read_mult+0x60>)
   1a65c:	9300      	str	r3, [sp, #0]
   1a65e:	4b16      	ldr	r3, [pc, #88]	; (1a6b8 <ble_att_clt_rx_read_mult+0x64>)
   1a660:	9301      	str	r3, [sp, #4]
   1a662:	4b16      	ldr	r3, [pc, #88]	; (1a6bc <ble_att_clt_rx_read_mult+0x68>)
   1a664:	9302      	str	r3, [sp, #8]
    return 0;
}

int
ble_att_clt_rx_read_mult(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a666:	460c      	mov	r4, r1
   1a668:	4605      	mov	r5, r0

    uint16_t value_len;
    void *value;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult rsp", conn_handle);
   1a66a:	9003      	str	r0, [sp, #12]
   1a66c:	2104      	movs	r1, #4
   1a66e:	4630      	mov	r0, r6
   1a670:	2200      	movs	r2, #0
   1a672:	4b13      	ldr	r3, [pc, #76]	; (1a6c0 <ble_att_clt_rx_read_mult+0x6c>)
   1a674:	f002 fdd8 	bl	1d228 <log_printf>
   1a678:	4b12      	ldr	r3, [pc, #72]	; (1a6c4 <ble_att_clt_rx_read_mult+0x70>)
   1a67a:	4630      	mov	r0, r6
   1a67c:	2200      	movs	r2, #0
   1a67e:	2104      	movs	r1, #4
   1a680:	f002 fdd2 	bl	1d228 <log_printf>

    /* Reponse consists of a one-byte opcode (already verified) and a variable
     * length Attribute Value field.  Strip the opcode from the response.
     */
    os_mbuf_adj(*rxom, BLE_ATT_READ_MULT_RSP_BASE_SZ);
   1a684:	6820      	ldr	r0, [r4, #0]
   1a686:	2101      	movs	r1, #1
   1a688:	f7ef fd19 	bl	a0be <os_mbuf_adj>

    /* Copy the attribute data into the global ATT flat buffer. */
    rc = ble_att_clt_copy_attr_to_flatbuf(*rxom, &value, &value_len);
   1a68c:	a905      	add	r1, sp, #20
   1a68e:	f10d 0212 	add.w	r2, sp, #18
   1a692:	6820      	ldr	r0, [r4, #0]
   1a694:	f7ff fc1c 	bl	19ed0 <ble_att_clt_copy_attr_to_flatbuf>
   1a698:	4604      	mov	r4, r0

    /* Pass the Attribute Value field to GATT. */
    ble_gattc_rx_read_mult_rsp(conn_handle, rc, value, value_len);
   1a69a:	4621      	mov	r1, r4
   1a69c:	4628      	mov	r0, r5
   1a69e:	9a05      	ldr	r2, [sp, #20]
   1a6a0:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1a6a4:	f7f8 fffd 	bl	136a2 <ble_gattc_rx_read_mult_rsp>
    return rc;
}
   1a6a8:	4620      	mov	r0, r4
   1a6aa:	b006      	add	sp, #24
   1a6ac:	bd70      	pop	{r4, r5, r6, pc}
   1a6ae:	bf00      	nop
   1a6b0:	0001fbda 	.word	0x0001fbda
   1a6b4:	20003b9c 	.word	0x20003b9c
   1a6b8:	000207e0 	.word	0x000207e0
   1a6bc:	0002089a 	.word	0x0002089a
   1a6c0:	0001fbbc 	.word	0x0001fbbc
   1a6c4:	0001fdec 	.word	0x0001fdec

0001a6c8 <ble_att_clt_tx_read_group_type>:

int
ble_att_clt_tx_read_group_type(uint16_t conn_handle,
                               const struct ble_att_read_group_type_req *req,
                               const void *uuid128)
{
   1a6c8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a6ca:	b087      	sub	sp, #28
    struct os_mbuf *txom;
    int rc;

    txom = NULL;

    BLE_ATT_LOG_CMD(1, "read group type req", conn_handle,
   1a6cc:	4b21      	ldr	r3, [pc, #132]	; (1a754 <ble_att_clt_tx_read_group_type+0x8c>)
   1a6ce:	9300      	str	r3, [sp, #0]
   1a6d0:	4b21      	ldr	r3, [pc, #132]	; (1a758 <ble_att_clt_tx_read_group_type+0x90>)
   1a6d2:	9301      	str	r3, [sp, #4]
   1a6d4:	4b21      	ldr	r3, [pc, #132]	; (1a75c <ble_att_clt_tx_read_group_type+0x94>)
   1a6d6:	9302      	str	r3, [sp, #8]

int
ble_att_clt_tx_read_group_type(uint16_t conn_handle,
                               const struct ble_att_read_group_type_req *req,
                               const void *uuid128)
{
   1a6d8:	460d      	mov	r5, r1
    struct os_mbuf *txom;
    int rc;

    txom = NULL;

    BLE_ATT_LOG_CMD(1, "read group type req", conn_handle,
   1a6da:	4b21      	ldr	r3, [pc, #132]	; (1a760 <ble_att_clt_tx_read_group_type+0x98>)
   1a6dc:	9003      	str	r0, [sp, #12]
   1a6de:	2104      	movs	r1, #4

int
ble_att_clt_tx_read_group_type(uint16_t conn_handle,
                               const struct ble_att_read_group_type_req *req,
                               const void *uuid128)
{
   1a6e0:	4606      	mov	r6, r0
   1a6e2:	4617      	mov	r7, r2
    struct os_mbuf *txom;
    int rc;

    txom = NULL;

    BLE_ATT_LOG_CMD(1, "read group type req", conn_handle,
   1a6e4:	481f      	ldr	r0, [pc, #124]	; (1a764 <ble_att_clt_tx_read_group_type+0x9c>)
   1a6e6:	2200      	movs	r2, #0
   1a6e8:	f002 fd9e 	bl	1d228 <log_printf>
   1a6ec:	4628      	mov	r0, r5
   1a6ee:	f000 fbf7 	bl	1aee0 <ble_att_read_group_type_req_log>
   1a6f2:	4b1d      	ldr	r3, [pc, #116]	; (1a768 <ble_att_clt_tx_read_group_type+0xa0>)
   1a6f4:	481b      	ldr	r0, [pc, #108]	; (1a764 <ble_att_clt_tx_read_group_type+0x9c>)
   1a6f6:	2104      	movs	r1, #4
   1a6f8:	2200      	movs	r2, #0
   1a6fa:	f002 fd95 	bl	1d228 <log_printf>
                    ble_att_read_group_type_req_log, req);

    if (req->bagq_start_handle == 0 ||
   1a6fe:	882b      	ldrh	r3, [r5, #0]
   1a700:	b313      	cbz	r3, 1a748 <ble_att_clt_tx_read_group_type+0x80>
   1a702:	886a      	ldrh	r2, [r5, #2]
   1a704:	429a      	cmp	r2, r3
   1a706:	d31f      	bcc.n	1a748 <ble_att_clt_tx_read_group_type+0x80>
    struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1a708:	a906      	add	r1, sp, #24
   1a70a:	2300      	movs	r3, #0
   1a70c:	f841 3d04 	str.w	r3, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_READ_GROUP_TYPE_REQ_BASE_SZ, &txom);
   1a710:	2005      	movs	r0, #5
   1a712:	f7ff fbfa 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1a716:	4604      	mov	r4, r0
   1a718:	b958      	cbnz	r0, 1a732 <ble_att_clt_tx_read_group_type+0x6a>
        goto done;
    }

    ble_att_read_group_type_req_write(txom->om_data, txom->om_len, req);
   1a71a:	9b05      	ldr	r3, [sp, #20]
   1a71c:	462a      	mov	r2, r5
   1a71e:	6818      	ldr	r0, [r3, #0]
   1a720:	88d9      	ldrh	r1, [r3, #6]
   1a722:	f000 fbd4 	bl	1aece <ble_att_read_group_type_req_write>

    rc = ble_uuid_append(txom, uuid128);
   1a726:	9805      	ldr	r0, [sp, #20]
   1a728:	4639      	mov	r1, r7
   1a72a:	f7fd fee3 	bl	184f4 <ble_uuid_append>
    if (rc != 0) {
        goto done;
    }

done:
    if (rc != 0) {
   1a72e:	4604      	mov	r4, r0
   1a730:	b120      	cbz	r0, 1a73c <ble_att_clt_tx_read_group_type+0x74>
        os_mbuf_free_chain(txom);
   1a732:	9805      	ldr	r0, [sp, #20]
   1a734:	f7ef fc13 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1a738:	2300      	movs	r3, #0
   1a73a:	9305      	str	r3, [sp, #20]
    }

    *out_txom = txom;
   1a73c:	9905      	ldr	r1, [sp, #20]

        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_read_group_type_req(req, uuid128, &txom);
    if (rc != 0) {
   1a73e:	b92c      	cbnz	r4, 1a74c <ble_att_clt_tx_read_group_type+0x84>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1a740:	4630      	mov	r0, r6
   1a742:	f7ff fb9b 	bl	19e7c <ble_att_clt_tx_req>
   1a746:	e002      	b.n	1a74e <ble_att_clt_tx_read_group_type+0x86>
                    ble_att_read_group_type_req_log, req);

    if (req->bagq_start_handle == 0 ||
        req->bagq_start_handle > req->bagq_end_handle) {

        return BLE_HS_EINVAL;
   1a748:	2003      	movs	r0, #3
   1a74a:	e000      	b.n	1a74e <ble_att_clt_tx_read_group_type+0x86>
   1a74c:	4620      	mov	r0, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1a74e:	b007      	add	sp, #28
   1a750:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a752:	bf00      	nop
   1a754:	0001fe60 	.word	0x0001fe60
   1a758:	000207e0 	.word	0x000207e0
   1a75c:	000208a8 	.word	0x000208a8
   1a760:	0001fbbc 	.word	0x0001fbbc
   1a764:	20003b9c 	.word	0x20003b9c
   1a768:	0001fdec 	.word	0x0001fdec

0001a76c <ble_att_clt_rx_read_group_type>:
    return 0;
}

int
ble_att_clt_rx_read_group_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a76c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a76e:	4607      	mov	r7, r0
   1a770:	b089      	sub	sp, #36	; 0x24

    struct ble_att_read_group_type_adata adata;
    struct ble_att_read_group_type_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_READ_GROUP_TYPE_RSP_BASE_SZ);
   1a772:	4608      	mov	r0, r1
    return 0;
}

int
ble_att_clt_rx_read_group_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a774:	460c      	mov	r4, r1

    struct ble_att_read_group_type_adata adata;
    struct ble_att_read_group_type_rsp rsp;
    int rc;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_READ_GROUP_TYPE_RSP_BASE_SZ);
   1a776:	2102      	movs	r1, #2
   1a778:	f7fa fede 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   1a77c:	4605      	mov	r5, r0
   1a77e:	2800      	cmp	r0, #0
   1a780:	d148      	bne.n	1a814 <ble_att_clt_rx_read_group_type+0xa8>
        goto done;
    }

    ble_att_read_group_type_rsp_parse((*rxom)->om_data, (*rxom)->om_len, &rsp);
   1a782:	6823      	ldr	r3, [r4, #0]
   1a784:	aa04      	add	r2, sp, #16
   1a786:	6818      	ldr	r0, [r3, #0]
   1a788:	88d9      	ldrh	r1, [r3, #6]
   1a78a:	f000 fbbb 	bl	1af04 <ble_att_read_group_type_rsp_parse>
    BLE_ATT_LOG_CMD(0, "read group type rsp", conn_handle,
   1a78e:	4b25      	ldr	r3, [pc, #148]	; (1a824 <ble_att_clt_rx_read_group_type+0xb8>)
   1a790:	9300      	str	r3, [sp, #0]
   1a792:	4b25      	ldr	r3, [pc, #148]	; (1a828 <ble_att_clt_rx_read_group_type+0xbc>)
   1a794:	9301      	str	r3, [sp, #4]
   1a796:	4b25      	ldr	r3, [pc, #148]	; (1a82c <ble_att_clt_rx_read_group_type+0xc0>)
   1a798:	9302      	str	r3, [sp, #8]
   1a79a:	2104      	movs	r1, #4
   1a79c:	462a      	mov	r2, r5
   1a79e:	4b24      	ldr	r3, [pc, #144]	; (1a830 <ble_att_clt_rx_read_group_type+0xc4>)
   1a7a0:	4824      	ldr	r0, [pc, #144]	; (1a834 <ble_att_clt_rx_read_group_type+0xc8>)
   1a7a2:	9703      	str	r7, [sp, #12]
   1a7a4:	f002 fd40 	bl	1d228 <log_printf>
   1a7a8:	a804      	add	r0, sp, #16
   1a7aa:	f000 fbb3 	bl	1af14 <ble_att_read_group_type_rsp_log>
   1a7ae:	4821      	ldr	r0, [pc, #132]	; (1a834 <ble_att_clt_rx_read_group_type+0xc8>)
   1a7b0:	4b21      	ldr	r3, [pc, #132]	; (1a838 <ble_att_clt_rx_read_group_type+0xcc>)
   1a7b2:	2104      	movs	r1, #4
   1a7b4:	462a      	mov	r2, r5
   1a7b6:	f002 fd37 	bl	1d228 <log_printf>
                    ble_att_read_group_type_rsp_log, &rsp);

    /* Strip the base from the front of the response. */
    os_mbuf_adj(*rxom, BLE_ATT_READ_GROUP_TYPE_RSP_BASE_SZ);
   1a7ba:	6820      	ldr	r0, [r4, #0]
   1a7bc:	2102      	movs	r1, #2
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_group_type_adata(conn_handle, &adata);
        os_mbuf_adj(*rxom, rsp.bagp_length);
   1a7be:	f7ef fc7e 	bl	a0be <os_mbuf_adj>

    /* Strip the base from the front of the response. */
    os_mbuf_adj(*rxom, BLE_ATT_READ_GROUP_TYPE_RSP_BASE_SZ);

    /* Parse the Attribute Data List field, passing each entry to GATT. */
    while (OS_MBUF_PKTLEN(*rxom) > 0) {
   1a7c2:	6823      	ldr	r3, [r4, #0]
   1a7c4:	8a1b      	ldrh	r3, [r3, #16]
   1a7c6:	b32b      	cbz	r3, 1a814 <ble_att_clt_rx_read_group_type+0xa8>
        rc = ble_att_clt_parse_read_group_type_adata(rxom, rsp.bagp_length,
   1a7c8:	f89d 6010 	ldrb.w	r6, [sp, #16]
    struct os_mbuf **om, int data_len,
    struct ble_att_read_group_type_adata *adata)
{
    int rc;

    if (data_len < BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ + 1) {
   1a7cc:	2e04      	cmp	r6, #4
   1a7ce:	dd1f      	ble.n	1a810 <ble_att_clt_rx_read_group_type+0xa4>
        return BLE_HS_EMSGSIZE;
    }

    rc = ble_hs_misc_pullup_base(om, data_len);
   1a7d0:	4620      	mov	r0, r4
   1a7d2:	4631      	mov	r1, r6
   1a7d4:	f7fa feb0 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   1a7d8:	b9d8      	cbnz	r0, 1a812 <ble_att_clt_rx_read_group_type+0xa6>
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
   1a7da:	6823      	ldr	r3, [r4, #0]
   1a7dc:	6818      	ldr	r0, [r3, #0]
   1a7de:	f002 fc56 	bl	1d08e <le16toh>
    adata->end_group_handle = le16toh((*om)->om_data + 2);
   1a7e2:	6823      	ldr	r3, [r4, #0]
    rc = ble_hs_misc_pullup_base(om, data_len);
    if (rc != 0) {
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
   1a7e4:	f8ad 0014 	strh.w	r0, [sp, #20]
    adata->end_group_handle = le16toh((*om)->om_data + 2);
   1a7e8:	6818      	ldr	r0, [r3, #0]
   1a7ea:	3002      	adds	r0, #2
   1a7ec:	f002 fc4f 	bl	1d08e <le16toh>
    adata->value_len = data_len - BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
    adata->value = (*om)->om_data + BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
   1a7f0:	6823      	ldr	r3, [r4, #0]
    if (rc != 0) {
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
    adata->end_group_handle = le16toh((*om)->om_data + 2);
   1a7f2:	f8ad 0016 	strh.w	r0, [sp, #22]
    adata->value_len = data_len - BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
    adata->value = (*om)->om_data + BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
   1a7f6:	681b      	ldr	r3, [r3, #0]
                                                     &adata);
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_group_type_adata(conn_handle, &adata);
   1a7f8:	4638      	mov	r0, r7
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
    adata->end_group_handle = le16toh((*om)->om_data + 2);
    adata->value_len = data_len - BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
    adata->value = (*om)->om_data + BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
   1a7fa:	3304      	adds	r3, #4
                                                     &adata);
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_group_type_adata(conn_handle, &adata);
   1a7fc:	a905      	add	r1, sp, #20
        return rc;
    }

    adata->att_handle = le16toh((*om)->om_data + 0);
    adata->end_group_handle = le16toh((*om)->om_data + 2);
    adata->value_len = data_len - BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
   1a7fe:	3e04      	subs	r6, #4
   1a800:	9606      	str	r6, [sp, #24]
    adata->value = (*om)->om_data + BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ;
   1a802:	9307      	str	r3, [sp, #28]
                                                     &adata);
        if (rc != 0) {
            goto done;
        }

        ble_gattc_rx_read_group_type_adata(conn_handle, &adata);
   1a804:	f7f8 fea6 	bl	13554 <ble_gattc_rx_read_group_type_adata>
        os_mbuf_adj(*rxom, rsp.bagp_length);
   1a808:	6820      	ldr	r0, [r4, #0]
   1a80a:	f89d 1010 	ldrb.w	r1, [sp, #16]
   1a80e:	e7d6      	b.n	1a7be <ble_att_clt_rx_read_group_type+0x52>
    struct ble_att_read_group_type_adata *adata)
{
    int rc;

    if (data_len < BLE_ATT_READ_GROUP_TYPE_ADATA_BASE_SZ + 1) {
        return BLE_HS_EMSGSIZE;
   1a810:	2004      	movs	r0, #4
    return 0;
}

int
ble_att_clt_rx_read_group_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a812:	4605      	mov	r5, r0
        os_mbuf_adj(*rxom, rsp.bagp_length);
    }

done:
    /* Notify GATT that the response is done being parsed. */
    ble_gattc_rx_read_group_type_complete(conn_handle, rc);
   1a814:	4638      	mov	r0, r7
   1a816:	4629      	mov	r1, r5
   1a818:	f7f8 fee0 	bl	135dc <ble_gattc_rx_read_group_type_complete>
    return rc;
}
   1a81c:	4628      	mov	r0, r5
   1a81e:	b009      	add	sp, #36	; 0x24
   1a820:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a822:	bf00      	nop
   1a824:	0001fbda 	.word	0x0001fbda
   1a828:	000207e0 	.word	0x000207e0
   1a82c:	000208bc 	.word	0x000208bc
   1a830:	0001fbbc 	.word	0x0001fbbc
   1a834:	20003b9c 	.word	0x20003b9c
   1a838:	0001fdec 	.word	0x0001fdec

0001a83c <ble_att_clt_rx_write>:
    return rc;
}

int
ble_att_clt_rx_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a83c:	b530      	push	{r4, r5, lr}
   1a83e:	b085      	sub	sp, #20
#if !NIMBLE_OPT(ATT_CLT_WRITE)
    return BLE_HS_ENOTSUP;
#endif

    BLE_ATT_LOG_EMPTY_CMD(0, "write rsp", conn_handle);
   1a840:	4b0d      	ldr	r3, [pc, #52]	; (1a878 <ble_att_clt_rx_write+0x3c>)
   1a842:	4d0e      	ldr	r5, [pc, #56]	; (1a87c <ble_att_clt_rx_write+0x40>)
   1a844:	9300      	str	r3, [sp, #0]
   1a846:	4b0e      	ldr	r3, [pc, #56]	; (1a880 <ble_att_clt_rx_write+0x44>)
   1a848:	9301      	str	r3, [sp, #4]
   1a84a:	4b0e      	ldr	r3, [pc, #56]	; (1a884 <ble_att_clt_rx_write+0x48>)
   1a84c:	9302      	str	r3, [sp, #8]
    return rc;
}

int
ble_att_clt_rx_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a84e:	4604      	mov	r4, r0
#if !NIMBLE_OPT(ATT_CLT_WRITE)
    return BLE_HS_ENOTSUP;
#endif

    BLE_ATT_LOG_EMPTY_CMD(0, "write rsp", conn_handle);
   1a850:	9003      	str	r0, [sp, #12]
   1a852:	2104      	movs	r1, #4
   1a854:	4628      	mov	r0, r5
   1a856:	2200      	movs	r2, #0
   1a858:	4b0b      	ldr	r3, [pc, #44]	; (1a888 <ble_att_clt_rx_write+0x4c>)
   1a85a:	f002 fce5 	bl	1d228 <log_printf>
   1a85e:	4628      	mov	r0, r5
   1a860:	2104      	movs	r1, #4
   1a862:	2200      	movs	r2, #0
   1a864:	4b09      	ldr	r3, [pc, #36]	; (1a88c <ble_att_clt_rx_write+0x50>)
   1a866:	f002 fcdf 	bl	1d228 <log_printf>

    /* No payload. */
    ble_gattc_rx_write_rsp(conn_handle);
   1a86a:	4620      	mov	r0, r4
   1a86c:	f7f8 ff31 	bl	136d2 <ble_gattc_rx_write_rsp>
    return 0;
}
   1a870:	2000      	movs	r0, #0
   1a872:	b005      	add	sp, #20
   1a874:	bd30      	pop	{r4, r5, pc}
   1a876:	bf00      	nop
   1a878:	0001fbda 	.word	0x0001fbda
   1a87c:	20003b9c 	.word	0x20003b9c
   1a880:	000207e0 	.word	0x000207e0
   1a884:	0002090c 	.word	0x0002090c
   1a888:	0001fbbc 	.word	0x0001fbbc
   1a88c:	0001fdec 	.word	0x0001fdec

0001a890 <ble_att_clt_tx_prep_write>:

int
ble_att_clt_tx_prep_write(uint16_t conn_handle,
                          const struct ble_att_prep_write_cmd *req,
                          const void *value, uint16_t value_len)
{
   1a890:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a894:	b086      	sub	sp, #24
   1a896:	461f      	mov	r7, r3
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "prep write req", conn_handle,
   1a898:	4b26      	ldr	r3, [pc, #152]	; (1a934 <ble_att_clt_tx_prep_write+0xa4>)
   1a89a:	9300      	str	r3, [sp, #0]
   1a89c:	4b26      	ldr	r3, [pc, #152]	; (1a938 <ble_att_clt_tx_prep_write+0xa8>)
   1a89e:	9301      	str	r3, [sp, #4]
   1a8a0:	4b26      	ldr	r3, [pc, #152]	; (1a93c <ble_att_clt_tx_prep_write+0xac>)
   1a8a2:	9302      	str	r3, [sp, #8]

int
ble_att_clt_tx_prep_write(uint16_t conn_handle,
                          const struct ble_att_prep_write_cmd *req,
                          const void *value, uint16_t value_len)
{
   1a8a4:	460d      	mov	r5, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "prep write req", conn_handle,
   1a8a6:	4b26      	ldr	r3, [pc, #152]	; (1a940 <ble_att_clt_tx_prep_write+0xb0>)
   1a8a8:	9003      	str	r0, [sp, #12]
   1a8aa:	2104      	movs	r1, #4

int
ble_att_clt_tx_prep_write(uint16_t conn_handle,
                          const struct ble_att_prep_write_cmd *req,
                          const void *value, uint16_t value_len)
{
   1a8ac:	4606      	mov	r6, r0
   1a8ae:	4690      	mov	r8, r2
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "prep write req", conn_handle,
   1a8b0:	4824      	ldr	r0, [pc, #144]	; (1a944 <ble_att_clt_tx_prep_write+0xb4>)
   1a8b2:	2200      	movs	r2, #0
   1a8b4:	f002 fcb8 	bl	1d228 <log_printf>
   1a8b8:	4628      	mov	r0, r5
   1a8ba:	f000 fb73 	bl	1afa4 <ble_att_prep_write_cmd_log>
   1a8be:	4b22      	ldr	r3, [pc, #136]	; (1a948 <ble_att_clt_tx_prep_write+0xb8>)
   1a8c0:	4820      	ldr	r0, [pc, #128]	; (1a944 <ble_att_clt_tx_prep_write+0xb4>)
   1a8c2:	2104      	movs	r1, #4
   1a8c4:	2200      	movs	r2, #0
   1a8c6:	f002 fcaf 	bl	1d228 <log_printf>
                    ble_att_prep_write_cmd_log, req);

    if (req->bapc_handle == 0) {
   1a8ca:	882b      	ldrh	r3, [r5, #0]
   1a8cc:	b90b      	cbnz	r3, 1a8d2 <ble_att_clt_tx_prep_write+0x42>
        return BLE_HS_EINVAL;
   1a8ce:	2003      	movs	r0, #3
   1a8d0:	e02c      	b.n	1a92c <ble_att_clt_tx_prep_write+0x9c>
    }

    if (req->bapc_offset + value_len > BLE_ATT_ATTR_MAX_LEN) {
   1a8d2:	886b      	ldrh	r3, [r5, #2]
   1a8d4:	443b      	add	r3, r7
   1a8d6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1a8da:	dcf8      	bgt.n	1a8ce <ble_att_clt_tx_prep_write+0x3e>
        return BLE_HS_EINVAL;
    }

    if (value_len >
        ble_att_mtu(conn_handle) - BLE_ATT_PREP_WRITE_CMD_BASE_SZ) {
   1a8dc:	4630      	mov	r0, r6
   1a8de:	f7ff fa89 	bl	19df4 <ble_att_mtu>

    if (req->bapc_offset + value_len > BLE_ATT_ATTR_MAX_LEN) {
        return BLE_HS_EINVAL;
    }

    if (value_len >
   1a8e2:	3804      	subs	r0, #4
   1a8e4:	42b8      	cmp	r0, r7
   1a8e6:	ddf2      	ble.n	1a8ce <ble_att_clt_tx_prep_write+0x3e>
                                 struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1a8e8:	a906      	add	r1, sp, #24
   1a8ea:	2300      	movs	r3, #0
   1a8ec:	f841 3d04 	str.w	r3, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_PREP_WRITE_CMD_BASE_SZ, &txom);
   1a8f0:	2005      	movs	r0, #5
   1a8f2:	f7ff fb0a 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1a8f6:	4604      	mov	r4, r0
   1a8f8:	b960      	cbnz	r0, 1a914 <ble_att_clt_tx_prep_write+0x84>
        goto done;
    }

    ble_att_prep_write_req_write(txom->om_data, txom->om_len, req);
   1a8fa:	9b05      	ldr	r3, [sp, #20]
   1a8fc:	462a      	mov	r2, r5
   1a8fe:	6818      	ldr	r0, [r3, #0]
   1a900:	88d9      	ldrh	r1, [r3, #6]
   1a902:	f000 fb36 	bl	1af72 <ble_att_prep_write_req_write>

    rc = ble_att_clt_append_blob(conn_handle, txom, value, value_len);
   1a906:	9805      	ldr	r0, [sp, #20]
   1a908:	4641      	mov	r1, r8
   1a90a:	463a      	mov	r2, r7
   1a90c:	f7ff fb12 	bl	19f34 <ble_att_clt_append_blob.isra.2>
    if (rc != 0) {
        goto done;
    }

done:
    if (rc != 0) {
   1a910:	4604      	mov	r4, r0
   1a912:	b120      	cbz	r0, 1a91e <ble_att_clt_tx_prep_write+0x8e>
        os_mbuf_free_chain(txom);
   1a914:	9805      	ldr	r0, [sp, #20]
   1a916:	f7ef fb22 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1a91a:	2300      	movs	r3, #0
   1a91c:	9305      	str	r3, [sp, #20]
    }

    *out_txom = txom;
   1a91e:	9905      	ldr	r1, [sp, #20]
        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_prep_write_req(conn_handle, req, value, value_len,
                                          &txom);
    if (rc != 0) {
   1a920:	b91c      	cbnz	r4, 1a92a <ble_att_clt_tx_prep_write+0x9a>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1a922:	4630      	mov	r0, r6
   1a924:	f7ff faaa 	bl	19e7c <ble_att_clt_tx_req>
   1a928:	e000      	b.n	1a92c <ble_att_clt_tx_prep_write+0x9c>
   1a92a:	4620      	mov	r0, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1a92c:	b006      	add	sp, #24
   1a92e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a932:	bf00      	nop
   1a934:	0001fe60 	.word	0x0001fe60
   1a938:	000207e0 	.word	0x000207e0
   1a93c:	000208da 	.word	0x000208da
   1a940:	0001fbbc 	.word	0x0001fbbc
   1a944:	20003b9c 	.word	0x20003b9c
   1a948:	0001fdec 	.word	0x0001fdec

0001a94c <ble_att_clt_rx_prep_write>:

int
ble_att_clt_rx_prep_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a94c:	b570      	push	{r4, r5, r6, lr}
   1a94e:	b088      	sub	sp, #32
    uint16_t value_len;
    void *value;
    int rc;

    /* Initialize some values in case of early error. */
    memset(&rsp, 0, sizeof rsp);
   1a950:	2300      	movs	r3, #0
    return 0;
}

int
ble_att_clt_rx_prep_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1a952:	4606      	mov	r6, r0
   1a954:	460d      	mov	r5, r1
    /* Initialize some values in case of early error. */
    memset(&rsp, 0, sizeof rsp);
    value = NULL;
    value_len = 0;

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ);
   1a956:	4608      	mov	r0, r1
   1a958:	2105      	movs	r1, #5
    uint16_t value_len;
    void *value;
    int rc;

    /* Initialize some values in case of early error. */
    memset(&rsp, 0, sizeof rsp);
   1a95a:	9306      	str	r3, [sp, #24]
    value = NULL;
   1a95c:	9307      	str	r3, [sp, #28]
    value_len = 0;
   1a95e:	f8ad 3016 	strh.w	r3, [sp, #22]

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ);
   1a962:	f7fa fde9 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc != 0) {
   1a966:	4604      	mov	r4, r0
   1a968:	bb30      	cbnz	r0, 1a9b8 <ble_att_clt_rx_prep_write+0x6c>
        goto done;
    }

    ble_att_prep_write_rsp_parse((*rxom)->om_data, (*rxom)->om_len, &rsp);
   1a96a:	682b      	ldr	r3, [r5, #0]
   1a96c:	aa06      	add	r2, sp, #24
   1a96e:	6818      	ldr	r0, [r3, #0]
   1a970:	88d9      	ldrh	r1, [r3, #6]
   1a972:	f000 fb07 	bl	1af84 <ble_att_prep_write_rsp_parse>
    BLE_ATT_LOG_CMD(0, "prep write rsp", conn_handle,
   1a976:	4b16      	ldr	r3, [pc, #88]	; (1a9d0 <ble_att_clt_rx_prep_write+0x84>)
   1a978:	9300      	str	r3, [sp, #0]
   1a97a:	4b16      	ldr	r3, [pc, #88]	; (1a9d4 <ble_att_clt_rx_prep_write+0x88>)
   1a97c:	9301      	str	r3, [sp, #4]
   1a97e:	4b16      	ldr	r3, [pc, #88]	; (1a9d8 <ble_att_clt_rx_prep_write+0x8c>)
   1a980:	9302      	str	r3, [sp, #8]
   1a982:	4622      	mov	r2, r4
   1a984:	2104      	movs	r1, #4
   1a986:	4b15      	ldr	r3, [pc, #84]	; (1a9dc <ble_att_clt_rx_prep_write+0x90>)
   1a988:	4815      	ldr	r0, [pc, #84]	; (1a9e0 <ble_att_clt_rx_prep_write+0x94>)
   1a98a:	9603      	str	r6, [sp, #12]
   1a98c:	f002 fc4c 	bl	1d228 <log_printf>
   1a990:	a806      	add	r0, sp, #24
   1a992:	f000 fb07 	bl	1afa4 <ble_att_prep_write_cmd_log>
   1a996:	4622      	mov	r2, r4
   1a998:	4b12      	ldr	r3, [pc, #72]	; (1a9e4 <ble_att_clt_rx_prep_write+0x98>)
   1a99a:	4811      	ldr	r0, [pc, #68]	; (1a9e0 <ble_att_clt_rx_prep_write+0x94>)
   1a99c:	2104      	movs	r1, #4
   1a99e:	f002 fc43 	bl	1d228 <log_printf>
                    ble_att_prep_write_cmd_log, &rsp);

    /* Strip the base from the front of the response. */
    os_mbuf_adj(*rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ);
   1a9a2:	6828      	ldr	r0, [r5, #0]
   1a9a4:	2105      	movs	r1, #5
   1a9a6:	f7ef fb8a 	bl	a0be <os_mbuf_adj>

    /* Copy the attribute data into the global ATT flat buffer. */
    rc = ble_att_clt_copy_attr_to_flatbuf(*rxom, &value, &value_len);
   1a9aa:	6828      	ldr	r0, [r5, #0]
   1a9ac:	a907      	add	r1, sp, #28
   1a9ae:	f10d 0216 	add.w	r2, sp, #22
   1a9b2:	f7ff fa8d 	bl	19ed0 <ble_att_clt_copy_attr_to_flatbuf>
   1a9b6:	4604      	mov	r4, r0

done:
    /* Notify GATT client that the full response has been parsed. */
    ble_gattc_rx_prep_write_rsp(conn_handle, rc, &rsp, value, value_len);
   1a9b8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1a9bc:	9300      	str	r3, [sp, #0]
   1a9be:	4630      	mov	r0, r6
   1a9c0:	4621      	mov	r1, r4
   1a9c2:	aa06      	add	r2, sp, #24
   1a9c4:	9b07      	ldr	r3, [sp, #28]
   1a9c6:	f7f8 fe95 	bl	136f4 <ble_gattc_rx_prep_write_rsp>
    return rc;
}
   1a9ca:	4620      	mov	r0, r4
   1a9cc:	b008      	add	sp, #32
   1a9ce:	bd70      	pop	{r4, r5, r6, pc}
   1a9d0:	0001fbda 	.word	0x0001fbda
   1a9d4:	000207e0 	.word	0x000207e0
   1a9d8:	000208e9 	.word	0x000208e9
   1a9dc:	0001fbbc 	.word	0x0001fbbc
   1a9e0:	20003b9c 	.word	0x20003b9c
   1a9e4:	0001fdec 	.word	0x0001fdec

0001a9e8 <ble_att_clt_tx_exec_write>:
}

int
ble_att_clt_tx_exec_write(uint16_t conn_handle,
                          const struct ble_att_exec_write_req *req)
{
   1a9e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a9ea:	b087      	sub	sp, #28
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "exec write req", conn_handle,
   1a9ec:	4b1d      	ldr	r3, [pc, #116]	; (1aa64 <ble_att_clt_tx_exec_write+0x7c>)
   1a9ee:	9300      	str	r3, [sp, #0]
   1a9f0:	4b1d      	ldr	r3, [pc, #116]	; (1aa68 <ble_att_clt_tx_exec_write+0x80>)
   1a9f2:	9301      	str	r3, [sp, #4]
   1a9f4:	4b1d      	ldr	r3, [pc, #116]	; (1aa6c <ble_att_clt_tx_exec_write+0x84>)
   1a9f6:	9302      	str	r3, [sp, #8]
}

int
ble_att_clt_tx_exec_write(uint16_t conn_handle,
                          const struct ble_att_exec_write_req *req)
{
   1a9f8:	460e      	mov	r6, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "exec write req", conn_handle,
   1a9fa:	2200      	movs	r2, #0
   1a9fc:	2104      	movs	r1, #4
   1a9fe:	4b1c      	ldr	r3, [pc, #112]	; (1aa70 <ble_att_clt_tx_exec_write+0x88>)
   1aa00:	9003      	str	r0, [sp, #12]
}

int
ble_att_clt_tx_exec_write(uint16_t conn_handle,
                          const struct ble_att_exec_write_req *req)
{
   1aa02:	4607      	mov	r7, r0
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "exec write req", conn_handle,
   1aa04:	481b      	ldr	r0, [pc, #108]	; (1aa74 <ble_att_clt_tx_exec_write+0x8c>)
   1aa06:	f002 fc0f 	bl	1d228 <log_printf>
   1aa0a:	4630      	mov	r0, r6
   1aa0c:	f000 fae4 	bl	1afd8 <ble_att_exec_write_req_log>
   1aa10:	4818      	ldr	r0, [pc, #96]	; (1aa74 <ble_att_clt_tx_exec_write+0x8c>)
   1aa12:	4b19      	ldr	r3, [pc, #100]	; (1aa78 <ble_att_clt_tx_exec_write+0x90>)
   1aa14:	2104      	movs	r1, #4
   1aa16:	2200      	movs	r2, #0
   1aa18:	f002 fc06 	bl	1d228 <log_printf>
                    ble_att_exec_write_req_log, req);

    if ((req->baeq_flags & BLE_ATT_EXEC_WRITE_F_RESERVED) != 0) {
   1aa1c:	7835      	ldrb	r5, [r6, #0]
   1aa1e:	f015 05fe 	ands.w	r5, r5, #254	; 0xfe
   1aa22:	d113      	bne.n	1aa4c <ble_att_clt_tx_exec_write+0x64>
                                 struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1aa24:	a906      	add	r1, sp, #24

    rc = ble_att_clt_init_req(BLE_ATT_EXEC_WRITE_REQ_SZ, &txom);
   1aa26:	2002      	movs	r0, #2
                                 struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1aa28:	f841 5d04 	str.w	r5, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_EXEC_WRITE_REQ_SZ, &txom);
   1aa2c:	f7ff fa6d 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1aa30:	4604      	mov	r4, r0
   1aa32:	b978      	cbnz	r0, 1aa54 <ble_att_clt_tx_exec_write+0x6c>
        goto done;
    }

    ble_att_exec_write_req_write(txom->om_data, txom->om_len, req);
   1aa34:	9b05      	ldr	r3, [sp, #20]
   1aa36:	4632      	mov	r2, r6
   1aa38:	6818      	ldr	r0, [r3, #0]
   1aa3a:	88d9      	ldrh	r1, [r3, #6]
   1aa3c:	f000 fac7 	bl	1afce <ble_att_exec_write_req_write>
    if (rc != 0) {
        os_mbuf_free_chain(txom);
        txom = NULL;
    }

    *out_txom = txom;
   1aa40:	9905      	ldr	r1, [sp, #20]
    if ((req->baeq_flags & BLE_ATT_EXEC_WRITE_F_RESERVED) != 0) {
        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_exec_write_req(req, &txom);
    if (rc != 0) {
   1aa42:	b92c      	cbnz	r4, 1aa50 <ble_att_clt_tx_exec_write+0x68>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1aa44:	4638      	mov	r0, r7
   1aa46:	f7ff fa19 	bl	19e7c <ble_att_clt_tx_req>
   1aa4a:	e008      	b.n	1aa5e <ble_att_clt_tx_exec_write+0x76>

    BLE_ATT_LOG_CMD(1, "exec write req", conn_handle,
                    ble_att_exec_write_req_log, req);

    if ((req->baeq_flags & BLE_ATT_EXEC_WRITE_F_RESERVED) != 0) {
        return BLE_HS_EINVAL;
   1aa4c:	2003      	movs	r0, #3
   1aa4e:	e006      	b.n	1aa5e <ble_att_clt_tx_exec_write+0x76>
   1aa50:	4620      	mov	r0, r4
   1aa52:	e004      	b.n	1aa5e <ble_att_clt_tx_exec_write+0x76>

    ble_att_exec_write_req_write(txom->om_data, txom->om_len, req);

done:
    if (rc != 0) {
        os_mbuf_free_chain(txom);
   1aa54:	9805      	ldr	r0, [sp, #20]
   1aa56:	f7ef fa82 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1aa5a:	9505      	str	r5, [sp, #20]
   1aa5c:	e7f0      	b.n	1aa40 <ble_att_clt_tx_exec_write+0x58>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1aa5e:	b007      	add	sp, #28
   1aa60:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1aa62:	bf00      	nop
   1aa64:	0001fe60 	.word	0x0001fe60
   1aa68:	000207e0 	.word	0x000207e0
   1aa6c:	000208f8 	.word	0x000208f8
   1aa70:	0001fbbc 	.word	0x0001fbbc
   1aa74:	20003b9c 	.word	0x20003b9c
   1aa78:	0001fdec 	.word	0x0001fdec

0001aa7c <ble_att_clt_rx_exec_write>:

int
ble_att_clt_rx_exec_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1aa7c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    return BLE_HS_ENOTSUP;
#endif

    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "exec write rsp", conn_handle);
   1aa7e:	4b13      	ldr	r3, [pc, #76]	; (1aacc <ble_att_clt_rx_exec_write+0x50>)
   1aa80:	9300      	str	r3, [sp, #0]
   1aa82:	4b13      	ldr	r3, [pc, #76]	; (1aad0 <ble_att_clt_rx_exec_write+0x54>)
   1aa84:	9301      	str	r3, [sp, #4]
   1aa86:	4b13      	ldr	r3, [pc, #76]	; (1aad4 <ble_att_clt_rx_exec_write+0x58>)
   1aa88:	9302      	str	r3, [sp, #8]
    return 0;
}

int
ble_att_clt_rx_exec_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1aa8a:	460e      	mov	r6, r1
    return BLE_HS_ENOTSUP;
#endif

    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "exec write rsp", conn_handle);
   1aa8c:	9003      	str	r0, [sp, #12]
   1aa8e:	2104      	movs	r1, #4
   1aa90:	2200      	movs	r2, #0
   1aa92:	4b11      	ldr	r3, [pc, #68]	; (1aad8 <ble_att_clt_rx_exec_write+0x5c>)
    return 0;
}

int
ble_att_clt_rx_exec_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1aa94:	4605      	mov	r5, r0
    return BLE_HS_ENOTSUP;
#endif

    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "exec write rsp", conn_handle);
   1aa96:	4811      	ldr	r0, [pc, #68]	; (1aadc <ble_att_clt_rx_exec_write+0x60>)
   1aa98:	f002 fbc6 	bl	1d228 <log_printf>
   1aa9c:	480f      	ldr	r0, [pc, #60]	; (1aadc <ble_att_clt_rx_exec_write+0x60>)
   1aa9e:	4b10      	ldr	r3, [pc, #64]	; (1aae0 <ble_att_clt_rx_exec_write+0x64>)
   1aaa0:	2104      	movs	r1, #4
   1aaa2:	2200      	movs	r2, #0
   1aaa4:	f002 fbc0 	bl	1d228 <log_printf>

    rc = ble_hs_misc_pullup_base(rxom, BLE_ATT_EXEC_WRITE_RSP_SZ);
   1aaa8:	4630      	mov	r0, r6
   1aaaa:	2101      	movs	r1, #1
   1aaac:	f7fa fd44 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc == 0) {
   1aab0:	4604      	mov	r4, r0
   1aab2:	b920      	cbnz	r0, 1aabe <ble_att_clt_rx_exec_write+0x42>
        ble_att_exec_write_rsp_parse((*rxom)->om_data, (*rxom)->om_len);
   1aab4:	6833      	ldr	r3, [r6, #0]
   1aab6:	6818      	ldr	r0, [r3, #0]
   1aab8:	88d9      	ldrh	r1, [r3, #6]
   1aaba:	f000 fa9d 	bl	1aff8 <ble_att_exec_write_rsp_parse>
    }

    ble_gattc_rx_exec_write_rsp(conn_handle, rc);
   1aabe:	4628      	mov	r0, r5
   1aac0:	4621      	mov	r1, r4
   1aac2:	f7f8 fe35 	bl	13730 <ble_gattc_rx_exec_write_rsp>
    return rc;
}
   1aac6:	4620      	mov	r0, r4
   1aac8:	b004      	add	sp, #16
   1aaca:	bd70      	pop	{r4, r5, r6, pc}
   1aacc:	0001fbda 	.word	0x0001fbda
   1aad0:	000207e0 	.word	0x000207e0
   1aad4:	00020907 	.word	0x00020907
   1aad8:	0001fbbc 	.word	0x0001fbbc
   1aadc:	20003b9c 	.word	0x20003b9c
   1aae0:	0001fdec 	.word	0x0001fdec

0001aae4 <ble_att_clt_tx_notify>:

int
ble_att_clt_tx_notify(uint16_t conn_handle,
                      const struct ble_att_notify_req *req,
                      const void *value, uint16_t value_len)
{
   1aae4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1aae8:	b086      	sub	sp, #24
   1aaea:	461f      	mov	r7, r3
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "notify req", conn_handle, ble_att_notify_req_log, req);
   1aaec:	4b20      	ldr	r3, [pc, #128]	; (1ab70 <ble_att_clt_tx_notify+0x8c>)
   1aaee:	9300      	str	r3, [sp, #0]
   1aaf0:	4b20      	ldr	r3, [pc, #128]	; (1ab74 <ble_att_clt_tx_notify+0x90>)
   1aaf2:	9301      	str	r3, [sp, #4]
   1aaf4:	4b20      	ldr	r3, [pc, #128]	; (1ab78 <ble_att_clt_tx_notify+0x94>)
   1aaf6:	9302      	str	r3, [sp, #8]

int
ble_att_clt_tx_notify(uint16_t conn_handle,
                      const struct ble_att_notify_req *req,
                      const void *value, uint16_t value_len)
{
   1aaf8:	460d      	mov	r5, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "notify req", conn_handle, ble_att_notify_req_log, req);
   1aafa:	4b20      	ldr	r3, [pc, #128]	; (1ab7c <ble_att_clt_tx_notify+0x98>)
   1aafc:	9003      	str	r0, [sp, #12]
   1aafe:	2104      	movs	r1, #4

int
ble_att_clt_tx_notify(uint16_t conn_handle,
                      const struct ble_att_notify_req *req,
                      const void *value, uint16_t value_len)
{
   1ab00:	4606      	mov	r6, r0
   1ab02:	4690      	mov	r8, r2
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "notify req", conn_handle, ble_att_notify_req_log, req);
   1ab04:	481e      	ldr	r0, [pc, #120]	; (1ab80 <ble_att_clt_tx_notify+0x9c>)
   1ab06:	2200      	movs	r2, #0
   1ab08:	f002 fb8e 	bl	1d228 <log_printf>
   1ab0c:	4628      	mov	r0, r5
   1ab0e:	f000 fa81 	bl	1b014 <ble_att_notify_req_log>
   1ab12:	4b1c      	ldr	r3, [pc, #112]	; (1ab84 <ble_att_clt_tx_notify+0xa0>)
   1ab14:	481a      	ldr	r0, [pc, #104]	; (1ab80 <ble_att_clt_tx_notify+0x9c>)
   1ab16:	2104      	movs	r1, #4
   1ab18:	2200      	movs	r2, #0
   1ab1a:	f002 fb85 	bl	1d228 <log_printf>

    if (req->banq_handle == 0) {
   1ab1e:	882b      	ldrh	r3, [r5, #0]
   1ab20:	b303      	cbz	r3, 1ab64 <ble_att_clt_tx_notify+0x80>
                             struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1ab22:	a906      	add	r1, sp, #24
   1ab24:	2300      	movs	r3, #0
   1ab26:	f841 3d04 	str.w	r3, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_NOTIFY_REQ_BASE_SZ, &txom);
   1ab2a:	2003      	movs	r0, #3
   1ab2c:	f7ff f9ed 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1ab30:	4604      	mov	r4, r0
   1ab32:	b960      	cbnz	r0, 1ab4e <ble_att_clt_tx_notify+0x6a>
        goto done;
    }

    ble_att_notify_req_write(txom->om_data, txom->om_len, req);
   1ab34:	9b05      	ldr	r3, [sp, #20]
   1ab36:	462a      	mov	r2, r5
   1ab38:	6818      	ldr	r0, [r3, #0]
   1ab3a:	88d9      	ldrh	r1, [r3, #6]
   1ab3c:	f000 fa64 	bl	1b008 <ble_att_notify_req_write>

    rc = ble_att_clt_append_blob(conn_handle, txom, value, value_len);
   1ab40:	9805      	ldr	r0, [sp, #20]
   1ab42:	4641      	mov	r1, r8
   1ab44:	463a      	mov	r2, r7
   1ab46:	f7ff f9f5 	bl	19f34 <ble_att_clt_append_blob.isra.2>
    if (rc != 0) {
        goto done;
    }

done:
    if (rc != 0) {
   1ab4a:	4604      	mov	r4, r0
   1ab4c:	b120      	cbz	r0, 1ab58 <ble_att_clt_tx_notify+0x74>
        os_mbuf_free_chain(txom);
   1ab4e:	9805      	ldr	r0, [sp, #20]
   1ab50:	f7ef fa05 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1ab54:	2300      	movs	r3, #0
   1ab56:	9305      	str	r3, [sp, #20]
    }

    *out_txom = txom;
   1ab58:	9905      	ldr	r1, [sp, #20]
        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_notify_req(conn_handle, req, value, value_len,
                                      &txom);
    if (rc != 0) {
   1ab5a:	b92c      	cbnz	r4, 1ab68 <ble_att_clt_tx_notify+0x84>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1ab5c:	4630      	mov	r0, r6
   1ab5e:	f7ff f98d 	bl	19e7c <ble_att_clt_tx_req>
   1ab62:	e002      	b.n	1ab6a <ble_att_clt_tx_notify+0x86>
    int rc;

    BLE_ATT_LOG_CMD(1, "notify req", conn_handle, ble_att_notify_req_log, req);

    if (req->banq_handle == 0) {
        return BLE_HS_EINVAL;
   1ab64:	2003      	movs	r0, #3
   1ab66:	e000      	b.n	1ab6a <ble_att_clt_tx_notify+0x86>
   1ab68:	4620      	mov	r0, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1ab6a:	b006      	add	sp, #24
   1ab6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ab70:	0001fe60 	.word	0x0001fe60
   1ab74:	000207e0 	.word	0x000207e0
   1ab78:	00020916 	.word	0x00020916
   1ab7c:	0001fbbc 	.word	0x0001fbbc
   1ab80:	20003b9c 	.word	0x20003b9c
   1ab84:	0001fdec 	.word	0x0001fdec

0001ab88 <ble_att_clt_tx_indicate>:

int
ble_att_clt_tx_indicate(uint16_t conn_handle,
                        const struct ble_att_indicate_req *req,
                        const void *value, uint16_t value_len)
{
   1ab88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ab8c:	b086      	sub	sp, #24
   1ab8e:	461f      	mov	r7, r3
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "indicate req", conn_handle, ble_att_indicate_req_log,
   1ab90:	4b20      	ldr	r3, [pc, #128]	; (1ac14 <ble_att_clt_tx_indicate+0x8c>)
   1ab92:	9300      	str	r3, [sp, #0]
   1ab94:	4b20      	ldr	r3, [pc, #128]	; (1ac18 <ble_att_clt_tx_indicate+0x90>)
   1ab96:	9301      	str	r3, [sp, #4]
   1ab98:	4b20      	ldr	r3, [pc, #128]	; (1ac1c <ble_att_clt_tx_indicate+0x94>)
   1ab9a:	9302      	str	r3, [sp, #8]

int
ble_att_clt_tx_indicate(uint16_t conn_handle,
                        const struct ble_att_indicate_req *req,
                        const void *value, uint16_t value_len)
{
   1ab9c:	460d      	mov	r5, r1
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "indicate req", conn_handle, ble_att_indicate_req_log,
   1ab9e:	4b20      	ldr	r3, [pc, #128]	; (1ac20 <ble_att_clt_tx_indicate+0x98>)
   1aba0:	9003      	str	r0, [sp, #12]
   1aba2:	2104      	movs	r1, #4

int
ble_att_clt_tx_indicate(uint16_t conn_handle,
                        const struct ble_att_indicate_req *req,
                        const void *value, uint16_t value_len)
{
   1aba4:	4606      	mov	r6, r0
   1aba6:	4690      	mov	r8, r2
#endif

    struct os_mbuf *txom;
    int rc;

    BLE_ATT_LOG_CMD(1, "indicate req", conn_handle, ble_att_indicate_req_log,
   1aba8:	481e      	ldr	r0, [pc, #120]	; (1ac24 <ble_att_clt_tx_indicate+0x9c>)
   1abaa:	2200      	movs	r2, #0
   1abac:	f002 fb3c 	bl	1d228 <log_printf>
   1abb0:	4628      	mov	r0, r5
   1abb2:	f000 fa49 	bl	1b048 <ble_att_indicate_req_log>
   1abb6:	4b1c      	ldr	r3, [pc, #112]	; (1ac28 <ble_att_clt_tx_indicate+0xa0>)
   1abb8:	481a      	ldr	r0, [pc, #104]	; (1ac24 <ble_att_clt_tx_indicate+0x9c>)
   1abba:	2104      	movs	r1, #4
   1abbc:	2200      	movs	r2, #0
   1abbe:	f002 fb33 	bl	1d228 <log_printf>
                    req);

    if (req->baiq_handle == 0) {
   1abc2:	882b      	ldrh	r3, [r5, #0]
   1abc4:	b303      	cbz	r3, 1ac08 <ble_att_clt_tx_indicate+0x80>
                               struct os_mbuf **out_txom)
{
    struct os_mbuf *txom;
    int rc;

    txom = NULL;
   1abc6:	a906      	add	r1, sp, #24
   1abc8:	2300      	movs	r3, #0
   1abca:	f841 3d04 	str.w	r3, [r1, #-4]!

    rc = ble_att_clt_init_req(BLE_ATT_INDICATE_REQ_BASE_SZ, &txom);
   1abce:	2003      	movs	r0, #3
   1abd0:	f7ff f99b 	bl	19f0a <ble_att_clt_init_req>
    if (rc != 0) {
   1abd4:	4604      	mov	r4, r0
   1abd6:	b960      	cbnz	r0, 1abf2 <ble_att_clt_tx_indicate+0x6a>
        goto done;
    }

    ble_att_indicate_req_write(txom->om_data, txom->om_len, req);
   1abd8:	9b05      	ldr	r3, [sp, #20]
   1abda:	462a      	mov	r2, r5
   1abdc:	6818      	ldr	r0, [r3, #0]
   1abde:	88d9      	ldrh	r1, [r3, #6]
   1abe0:	f000 fa2c 	bl	1b03c <ble_att_indicate_req_write>

    rc = ble_att_clt_append_blob(conn_handle, txom, value, value_len);
   1abe4:	9805      	ldr	r0, [sp, #20]
   1abe6:	4641      	mov	r1, r8
   1abe8:	463a      	mov	r2, r7
   1abea:	f7ff f9a3 	bl	19f34 <ble_att_clt_append_blob.isra.2>
    if (rc != 0) {
        goto done;
    }

done:
    if (rc != 0) {
   1abee:	4604      	mov	r4, r0
   1abf0:	b120      	cbz	r0, 1abfc <ble_att_clt_tx_indicate+0x74>
        os_mbuf_free_chain(txom);
   1abf2:	9805      	ldr	r0, [sp, #20]
   1abf4:	f7ef f9b3 	bl	9f5e <os_mbuf_free_chain>
        txom = NULL;
   1abf8:	2300      	movs	r3, #0
   1abfa:	9305      	str	r3, [sp, #20]
    }

    *out_txom = txom;
   1abfc:	9905      	ldr	r1, [sp, #20]
        return BLE_HS_EINVAL;
    }

    rc = ble_att_clt_build_indicate_req(conn_handle, req, value, value_len,
                                        &txom);
    if (rc != 0) {
   1abfe:	b92c      	cbnz	r4, 1ac0c <ble_att_clt_tx_indicate+0x84>
        return rc;
    }

    rc = ble_att_clt_tx_req(conn_handle, txom);
   1ac00:	4630      	mov	r0, r6
   1ac02:	f7ff f93b 	bl	19e7c <ble_att_clt_tx_req>
   1ac06:	e002      	b.n	1ac0e <ble_att_clt_tx_indicate+0x86>

    BLE_ATT_LOG_CMD(1, "indicate req", conn_handle, ble_att_indicate_req_log,
                    req);

    if (req->baiq_handle == 0) {
        return BLE_HS_EINVAL;
   1ac08:	2003      	movs	r0, #3
   1ac0a:	e000      	b.n	1ac0e <ble_att_clt_tx_indicate+0x86>
   1ac0c:	4620      	mov	r0, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1ac0e:	b006      	add	sp, #24
   1ac10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ac14:	0001fe60 	.word	0x0001fe60
   1ac18:	000207e0 	.word	0x000207e0
   1ac1c:	00020921 	.word	0x00020921
   1ac20:	0001fbbc 	.word	0x0001fbbc
   1ac24:	20003b9c 	.word	0x20003b9c
   1ac28:	0001fdec 	.word	0x0001fdec

0001ac2c <ble_att_clt_rx_indicate>:

int
ble_att_clt_rx_indicate(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1ac2c:	b530      	push	{r4, r5, lr}
   1ac2e:	b085      	sub	sp, #20
#if !NIMBLE_OPT(ATT_CLT_INDICATE)
    return BLE_HS_ENOTSUP;
#endif

    BLE_ATT_LOG_EMPTY_CMD(0, "indicate rsp", conn_handle);
   1ac30:	4b0d      	ldr	r3, [pc, #52]	; (1ac68 <ble_att_clt_rx_indicate+0x3c>)
   1ac32:	4d0e      	ldr	r5, [pc, #56]	; (1ac6c <ble_att_clt_rx_indicate+0x40>)
   1ac34:	9300      	str	r3, [sp, #0]
   1ac36:	4b0e      	ldr	r3, [pc, #56]	; (1ac70 <ble_att_clt_rx_indicate+0x44>)
   1ac38:	9301      	str	r3, [sp, #4]
   1ac3a:	4b0e      	ldr	r3, [pc, #56]	; (1ac74 <ble_att_clt_rx_indicate+0x48>)
   1ac3c:	9302      	str	r3, [sp, #8]
    return 0;
}

int
ble_att_clt_rx_indicate(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1ac3e:	4604      	mov	r4, r0
#if !NIMBLE_OPT(ATT_CLT_INDICATE)
    return BLE_HS_ENOTSUP;
#endif

    BLE_ATT_LOG_EMPTY_CMD(0, "indicate rsp", conn_handle);
   1ac40:	9003      	str	r0, [sp, #12]
   1ac42:	2104      	movs	r1, #4
   1ac44:	4628      	mov	r0, r5
   1ac46:	2200      	movs	r2, #0
   1ac48:	4b0b      	ldr	r3, [pc, #44]	; (1ac78 <ble_att_clt_rx_indicate+0x4c>)
   1ac4a:	f002 faed 	bl	1d228 <log_printf>
   1ac4e:	4628      	mov	r0, r5
   1ac50:	2104      	movs	r1, #4
   1ac52:	2200      	movs	r2, #0
   1ac54:	4b09      	ldr	r3, [pc, #36]	; (1ac7c <ble_att_clt_rx_indicate+0x50>)
   1ac56:	f002 fae7 	bl	1d228 <log_printf>

    /* No payload. */
    ble_gattc_rx_indicate_rsp(conn_handle);
   1ac5a:	4620      	mov	r0, r4
   1ac5c:	f7f8 fd7e 	bl	1375c <ble_gattc_rx_indicate_rsp>
    return 0;
}
   1ac60:	2000      	movs	r0, #0
   1ac62:	b005      	add	sp, #20
   1ac64:	bd30      	pop	{r4, r5, pc}
   1ac66:	bf00      	nop
   1ac68:	0001fbda 	.word	0x0001fbda
   1ac6c:	20003b9c 	.word	0x20003b9c
   1ac70:	000207e0 	.word	0x000207e0
   1ac74:	0002092e 	.word	0x0002092e
   1ac78:	0001fbbc 	.word	0x0001fbbc
   1ac7c:	0001fdec 	.word	0x0001fdec

0001ac80 <ble_att_error_rsp_parse>:

static void
ble_att_error_rsp_swap(struct ble_att_error_rsp *dst,
                       const struct ble_att_error_rsp *src)
{
    dst->baep_req_op = src->baep_req_op;
   1ac80:	7843      	ldrb	r3, [r0, #1]
   1ac82:	7013      	strb	r3, [r2, #0]
    dst->baep_handle = TOFROMLE16(src->baep_handle);
   1ac84:	8843      	ldrh	r3, [r0, #2]
   1ac86:	f8a2 3001 	strh.w	r3, [r2, #1]
    dst->baep_error_code = src->baep_error_code;
   1ac8a:	7903      	ldrb	r3, [r0, #4]
   1ac8c:	70d3      	strb	r3, [r2, #3]
   1ac8e:	4770      	bx	lr

0001ac90 <ble_att_error_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1ac90:	2301      	movs	r3, #1
   1ac92:	7003      	strb	r3, [r0, #0]

static void
ble_att_error_rsp_swap(struct ble_att_error_rsp *dst,
                       const struct ble_att_error_rsp *src)
{
    dst->baep_req_op = src->baep_req_op;
   1ac94:	7813      	ldrb	r3, [r2, #0]
   1ac96:	7043      	strb	r3, [r0, #1]
    dst->baep_handle = TOFROMLE16(src->baep_handle);
   1ac98:	f8b2 3001 	ldrh.w	r3, [r2, #1]
   1ac9c:	8043      	strh	r3, [r0, #2]
    dst->baep_error_code = src->baep_error_code;
   1ac9e:	78d3      	ldrb	r3, [r2, #3]
   1aca0:	7103      	strb	r3, [r0, #4]
   1aca2:	4770      	bx	lr

0001aca4 <ble_att_error_rsp_log>:
    ble_att_error_rsp_swap(dst, src);
}

void
ble_att_error_rsp_log(const struct ble_att_error_rsp *cmd)
{
   1aca4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    BLE_HS_LOG(DEBUG, "req_op=%d handle=0x%04x error_code=%d",
   1aca6:	7803      	ldrb	r3, [r0, #0]
   1aca8:	9300      	str	r3, [sp, #0]
   1acaa:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1acae:	9301      	str	r3, [sp, #4]
   1acb0:	78c3      	ldrb	r3, [r0, #3]
   1acb2:	9302      	str	r3, [sp, #8]
   1acb4:	4804      	ldr	r0, [pc, #16]	; (1acc8 <ble_att_error_rsp_log+0x24>)
   1acb6:	4b05      	ldr	r3, [pc, #20]	; (1accc <ble_att_error_rsp_log+0x28>)
   1acb8:	2104      	movs	r1, #4
   1acba:	2200      	movs	r2, #0
   1acbc:	f002 fab4 	bl	1d228 <log_printf>
               cmd->baep_req_op, cmd->baep_handle, cmd->baep_error_code);
}
   1acc0:	b005      	add	sp, #20
   1acc2:	f85d fb04 	ldr.w	pc, [sp], #4
   1acc6:	bf00      	nop
   1acc8:	20003b9c 	.word	0x20003b9c
   1accc:	0002093b 	.word	0x0002093b

0001acd0 <ble_att_mtu_cmd_parse>:

static void
ble_att_mtu_cmd_swap(struct ble_att_mtu_cmd *dst,
                     const struct ble_att_mtu_cmd *src)
{
    dst->bamc_mtu = TOFROMLE16(src->bamc_mtu);
   1acd0:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1acd4:	8013      	strh	r3, [r2, #0]
   1acd6:	4770      	bx	lr

0001acd8 <ble_att_mtu_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1acd8:	2303      	movs	r3, #3
   1acda:	7003      	strb	r3, [r0, #0]

static void
ble_att_mtu_cmd_swap(struct ble_att_mtu_cmd *dst,
                     const struct ble_att_mtu_cmd *src)
{
    dst->bamc_mtu = TOFROMLE16(src->bamc_mtu);
   1acdc:	8813      	ldrh	r3, [r2, #0]
   1acde:	f8a0 3001 	strh.w	r3, [r0, #1]
   1ace2:	4770      	bx	lr

0001ace4 <ble_att_mtu_cmd_log>:
    ble_att_mtu_cmd_swap(dst, src);
}

void
ble_att_mtu_cmd_log(const struct ble_att_mtu_cmd *cmd)
{
   1ace4:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "mtu=%d", cmd->bamc_mtu);
   1ace6:	8803      	ldrh	r3, [r0, #0]
   1ace8:	9300      	str	r3, [sp, #0]
   1acea:	4804      	ldr	r0, [pc, #16]	; (1acfc <ble_att_mtu_cmd_log+0x18>)
   1acec:	4b04      	ldr	r3, [pc, #16]	; (1ad00 <ble_att_mtu_cmd_log+0x1c>)
   1acee:	2104      	movs	r1, #4
   1acf0:	2200      	movs	r2, #0
   1acf2:	f002 fa99 	bl	1d228 <log_printf>
}
   1acf6:	b003      	add	sp, #12
   1acf8:	f85d fb04 	ldr.w	pc, [sp], #4
   1acfc:	20003b9c 	.word	0x20003b9c
   1ad00:	00020961 	.word	0x00020961

0001ad04 <ble_att_find_info_req_parse>:

static void
ble_att_find_info_req_swap(struct ble_att_find_info_req *dst,
                           const struct ble_att_find_info_req *src)
{
    dst->bafq_start_handle = TOFROMLE16(src->bafq_start_handle);
   1ad04:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1ad08:	8013      	strh	r3, [r2, #0]
    dst->bafq_end_handle = TOFROMLE16(src->bafq_end_handle);
   1ad0a:	f8b0 3003 	ldrh.w	r3, [r0, #3]
   1ad0e:	8053      	strh	r3, [r2, #2]
   1ad10:	4770      	bx	lr

0001ad12 <ble_att_find_info_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1ad12:	2304      	movs	r3, #4
   1ad14:	7003      	strb	r3, [r0, #0]

static void
ble_att_find_info_req_swap(struct ble_att_find_info_req *dst,
                           const struct ble_att_find_info_req *src)
{
    dst->bafq_start_handle = TOFROMLE16(src->bafq_start_handle);
   1ad16:	8813      	ldrh	r3, [r2, #0]
   1ad18:	f8a0 3001 	strh.w	r3, [r0, #1]
    dst->bafq_end_handle = TOFROMLE16(src->bafq_end_handle);
   1ad1c:	8853      	ldrh	r3, [r2, #2]
   1ad1e:	f8a0 3003 	strh.w	r3, [r0, #3]
   1ad22:	4770      	bx	lr

0001ad24 <ble_att_find_info_req_log>:
    ble_att_find_info_req_swap(dst, src);
}

void
ble_att_find_info_req_log(const struct ble_att_find_info_req *cmd)
{
   1ad24:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "start_handle=0x%04x end_handle=0x%04x",
   1ad26:	8803      	ldrh	r3, [r0, #0]
   1ad28:	9300      	str	r3, [sp, #0]
   1ad2a:	8843      	ldrh	r3, [r0, #2]
   1ad2c:	9301      	str	r3, [sp, #4]
   1ad2e:	4804      	ldr	r0, [pc, #16]	; (1ad40 <ble_att_find_info_req_log+0x1c>)
   1ad30:	4b04      	ldr	r3, [pc, #16]	; (1ad44 <ble_att_find_info_req_log+0x20>)
   1ad32:	2104      	movs	r1, #4
   1ad34:	2200      	movs	r2, #0
   1ad36:	f002 fa77 	bl	1d228 <log_printf>
               cmd->bafq_start_handle, cmd->bafq_end_handle);
}
   1ad3a:	b003      	add	sp, #12
   1ad3c:	f85d fb04 	ldr.w	pc, [sp], #4
   1ad40:	20003b9c 	.word	0x20003b9c
   1ad44:	00020968 	.word	0x00020968

0001ad48 <ble_att_find_info_rsp_parse>:

static void
ble_att_find_info_rsp_swap(struct ble_att_find_info_rsp *dst,
                           const struct ble_att_find_info_rsp *src)
{
    dst->bafp_format = src->bafp_format;
   1ad48:	7843      	ldrb	r3, [r0, #1]
   1ad4a:	7013      	strb	r3, [r2, #0]
   1ad4c:	4770      	bx	lr

0001ad4e <ble_att_find_info_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1ad4e:	2305      	movs	r3, #5
   1ad50:	7003      	strb	r3, [r0, #0]

static void
ble_att_find_info_rsp_swap(struct ble_att_find_info_rsp *dst,
                           const struct ble_att_find_info_rsp *src)
{
    dst->bafp_format = src->bafp_format;
   1ad52:	7813      	ldrb	r3, [r2, #0]
   1ad54:	7043      	strb	r3, [r0, #1]
   1ad56:	4770      	bx	lr

0001ad58 <ble_att_find_info_rsp_log>:
    ble_att_find_info_rsp_swap(dst, src);
}

void
ble_att_find_info_rsp_log(const struct ble_att_find_info_rsp *cmd)
{
   1ad58:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "format=%d", cmd->bafp_format);
   1ad5a:	7803      	ldrb	r3, [r0, #0]
   1ad5c:	9300      	str	r3, [sp, #0]
   1ad5e:	4804      	ldr	r0, [pc, #16]	; (1ad70 <ble_att_find_info_rsp_log+0x18>)
   1ad60:	4b04      	ldr	r3, [pc, #16]	; (1ad74 <ble_att_find_info_rsp_log+0x1c>)
   1ad62:	2104      	movs	r1, #4
   1ad64:	2200      	movs	r2, #0
   1ad66:	f002 fa5f 	bl	1d228 <log_printf>
}
   1ad6a:	b003      	add	sp, #12
   1ad6c:	f85d fb04 	ldr.w	pc, [sp], #4
   1ad70:	20003b9c 	.word	0x20003b9c
   1ad74:	0002098e 	.word	0x0002098e

0001ad78 <ble_att_find_type_value_req_parse>:

static void
ble_att_find_type_value_req_swap(struct ble_att_find_type_value_req *dst,
                                 const struct ble_att_find_type_value_req *src)
{
    dst->bavq_start_handle = TOFROMLE16(src->bavq_start_handle);
   1ad78:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1ad7c:	8013      	strh	r3, [r2, #0]
    dst->bavq_end_handle = TOFROMLE16(src->bavq_end_handle);
   1ad7e:	f8b0 3003 	ldrh.w	r3, [r0, #3]
   1ad82:	8053      	strh	r3, [r2, #2]
    dst->bavq_attr_type = TOFROMLE16(src->bavq_attr_type);
   1ad84:	f8b0 3005 	ldrh.w	r3, [r0, #5]
   1ad88:	8093      	strh	r3, [r2, #4]
   1ad8a:	4770      	bx	lr

0001ad8c <ble_att_find_type_value_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1ad8c:	2306      	movs	r3, #6
   1ad8e:	7003      	strb	r3, [r0, #0]

static void
ble_att_find_type_value_req_swap(struct ble_att_find_type_value_req *dst,
                                 const struct ble_att_find_type_value_req *src)
{
    dst->bavq_start_handle = TOFROMLE16(src->bavq_start_handle);
   1ad90:	8813      	ldrh	r3, [r2, #0]
   1ad92:	f8a0 3001 	strh.w	r3, [r0, #1]
    dst->bavq_end_handle = TOFROMLE16(src->bavq_end_handle);
   1ad96:	8853      	ldrh	r3, [r2, #2]
   1ad98:	f8a0 3003 	strh.w	r3, [r0, #3]
    dst->bavq_attr_type = TOFROMLE16(src->bavq_attr_type);
   1ad9c:	8893      	ldrh	r3, [r2, #4]
   1ad9e:	f8a0 3005 	strh.w	r3, [r0, #5]
   1ada2:	4770      	bx	lr

0001ada4 <ble_att_find_type_value_req_log>:
    ble_att_find_type_value_req_swap(dst, src);
}

void
ble_att_find_type_value_req_log(const struct ble_att_find_type_value_req *cmd)
{
   1ada4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    BLE_HS_LOG(DEBUG, "start_handle=0x%04x end_handle=0x%04x attr_type=%d",
   1ada6:	8803      	ldrh	r3, [r0, #0]
   1ada8:	9300      	str	r3, [sp, #0]
   1adaa:	8843      	ldrh	r3, [r0, #2]
   1adac:	9301      	str	r3, [sp, #4]
   1adae:	8883      	ldrh	r3, [r0, #4]
   1adb0:	9302      	str	r3, [sp, #8]
   1adb2:	4804      	ldr	r0, [pc, #16]	; (1adc4 <ble_att_find_type_value_req_log+0x20>)
   1adb4:	4b04      	ldr	r3, [pc, #16]	; (1adc8 <ble_att_find_type_value_req_log+0x24>)
   1adb6:	2104      	movs	r1, #4
   1adb8:	2200      	movs	r2, #0
   1adba:	f002 fa35 	bl	1d228 <log_printf>
               cmd->bavq_start_handle, cmd->bavq_end_handle,
               cmd->bavq_attr_type);
}
   1adbe:	b005      	add	sp, #20
   1adc0:	f85d fb04 	ldr.w	pc, [sp], #4
   1adc4:	20003b9c 	.word	0x20003b9c
   1adc8:	00020998 	.word	0x00020998

0001adcc <ble_att_read_type_req_parse>:

static void
ble_att_read_type_req_swap(struct ble_att_read_type_req *dst,
                           const struct ble_att_read_type_req *src)
{
    dst->batq_start_handle = TOFROMLE16(src->batq_start_handle);
   1adcc:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1add0:	8013      	strh	r3, [r2, #0]
    dst->batq_end_handle = TOFROMLE16(src->batq_end_handle);
   1add2:	f8b0 3003 	ldrh.w	r3, [r0, #3]
   1add6:	8053      	strh	r3, [r2, #2]
   1add8:	4770      	bx	lr

0001adda <ble_att_read_type_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1adda:	2308      	movs	r3, #8
   1addc:	7003      	strb	r3, [r0, #0]

static void
ble_att_read_type_req_swap(struct ble_att_read_type_req *dst,
                           const struct ble_att_read_type_req *src)
{
    dst->batq_start_handle = TOFROMLE16(src->batq_start_handle);
   1adde:	8813      	ldrh	r3, [r2, #0]
   1ade0:	f8a0 3001 	strh.w	r3, [r0, #1]
    dst->batq_end_handle = TOFROMLE16(src->batq_end_handle);
   1ade4:	8853      	ldrh	r3, [r2, #2]
   1ade6:	f8a0 3003 	strh.w	r3, [r0, #3]
   1adea:	4770      	bx	lr

0001adec <ble_att_read_type_req_log>:
    ble_att_read_type_req_swap(dst, src);
}

void
ble_att_read_type_req_log(const struct ble_att_read_type_req *cmd)
{
   1adec:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "start_handle=0x%04x end_handle=0x%04x",
   1adee:	8803      	ldrh	r3, [r0, #0]
   1adf0:	9300      	str	r3, [sp, #0]
   1adf2:	8843      	ldrh	r3, [r0, #2]
   1adf4:	9301      	str	r3, [sp, #4]
   1adf6:	4804      	ldr	r0, [pc, #16]	; (1ae08 <ble_att_read_type_req_log+0x1c>)
   1adf8:	4b04      	ldr	r3, [pc, #16]	; (1ae0c <ble_att_read_type_req_log+0x20>)
   1adfa:	2104      	movs	r1, #4
   1adfc:	2200      	movs	r2, #0
   1adfe:	f002 fa13 	bl	1d228 <log_printf>
               cmd->batq_start_handle, cmd->batq_end_handle);
}
   1ae02:	b003      	add	sp, #12
   1ae04:	f85d fb04 	ldr.w	pc, [sp], #4
   1ae08:	20003b9c 	.word	0x20003b9c
   1ae0c:	00020968 	.word	0x00020968

0001ae10 <ble_att_read_type_rsp_parse>:

static void
ble_att_read_type_rsp_swap(struct ble_att_read_type_rsp *dst,
                           const struct ble_att_read_type_rsp *src)
{
    dst->batp_length = src->batp_length;
   1ae10:	7843      	ldrb	r3, [r0, #1]
   1ae12:	7013      	strb	r3, [r2, #0]
   1ae14:	4770      	bx	lr

0001ae16 <ble_att_read_type_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1ae16:	2309      	movs	r3, #9
   1ae18:	7003      	strb	r3, [r0, #0]

static void
ble_att_read_type_rsp_swap(struct ble_att_read_type_rsp *dst,
                           const struct ble_att_read_type_rsp *src)
{
    dst->batp_length = src->batp_length;
   1ae1a:	7813      	ldrb	r3, [r2, #0]
   1ae1c:	7043      	strb	r3, [r0, #1]
   1ae1e:	4770      	bx	lr

0001ae20 <ble_att_read_type_rsp_log>:
    ble_att_read_type_rsp_swap(dst, src);
}

void
ble_att_read_type_rsp_log(const struct ble_att_read_type_rsp *cmd)
{
   1ae20:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "length=%d", cmd->batp_length);
   1ae22:	7803      	ldrb	r3, [r0, #0]
   1ae24:	9300      	str	r3, [sp, #0]
   1ae26:	4804      	ldr	r0, [pc, #16]	; (1ae38 <ble_att_read_type_rsp_log+0x18>)
   1ae28:	4b04      	ldr	r3, [pc, #16]	; (1ae3c <ble_att_read_type_rsp_log+0x1c>)
   1ae2a:	2104      	movs	r1, #4
   1ae2c:	2200      	movs	r2, #0
   1ae2e:	f002 f9fb 	bl	1d228 <log_printf>
}
   1ae32:	b003      	add	sp, #12
   1ae34:	f85d fb04 	ldr.w	pc, [sp], #4
   1ae38:	20003b9c 	.word	0x20003b9c
   1ae3c:	000209cb 	.word	0x000209cb

0001ae40 <ble_att_read_req_parse>:

static void
ble_att_read_req_swap(struct ble_att_read_req *dst,
                      const struct ble_att_read_req *src)
{
    dst->barq_handle = TOFROMLE16(src->barq_handle);
   1ae40:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1ae44:	8013      	strh	r3, [r2, #0]
   1ae46:	4770      	bx	lr

0001ae48 <ble_att_read_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1ae48:	230a      	movs	r3, #10
   1ae4a:	7003      	strb	r3, [r0, #0]

static void
ble_att_read_req_swap(struct ble_att_read_req *dst,
                      const struct ble_att_read_req *src)
{
    dst->barq_handle = TOFROMLE16(src->barq_handle);
   1ae4c:	8813      	ldrh	r3, [r2, #0]
   1ae4e:	f8a0 3001 	strh.w	r3, [r0, #1]
   1ae52:	4770      	bx	lr

0001ae54 <ble_att_read_req_log>:
    ble_att_read_req_swap(dst, src);
}

void
ble_att_read_req_log(const struct ble_att_read_req *cmd)
{
   1ae54:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "handle=0x%04x", cmd->barq_handle);
   1ae56:	8803      	ldrh	r3, [r0, #0]
   1ae58:	9300      	str	r3, [sp, #0]
   1ae5a:	4804      	ldr	r0, [pc, #16]	; (1ae6c <ble_att_read_req_log+0x18>)
   1ae5c:	4b04      	ldr	r3, [pc, #16]	; (1ae70 <ble_att_read_req_log+0x1c>)
   1ae5e:	2104      	movs	r1, #4
   1ae60:	2200      	movs	r2, #0
   1ae62:	f002 f9e1 	bl	1d228 <log_printf>
}
   1ae66:	b003      	add	sp, #12
   1ae68:	f85d fb04 	ldr.w	pc, [sp], #4
   1ae6c:	20003b9c 	.word	0x20003b9c
   1ae70:	00020980 	.word	0x00020980

0001ae74 <ble_att_read_blob_req_parse>:

static void
ble_att_read_blob_req_swap(struct ble_att_read_blob_req *dst,
                           const struct ble_att_read_blob_req *src)
{
    dst->babq_handle = TOFROMLE16(src->babq_handle);
   1ae74:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1ae78:	8013      	strh	r3, [r2, #0]
    dst->babq_offset = TOFROMLE16(src->babq_offset);
   1ae7a:	f8b0 3003 	ldrh.w	r3, [r0, #3]
   1ae7e:	8053      	strh	r3, [r2, #2]
   1ae80:	4770      	bx	lr

0001ae82 <ble_att_read_blob_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1ae82:	230c      	movs	r3, #12
   1ae84:	7003      	strb	r3, [r0, #0]

static void
ble_att_read_blob_req_swap(struct ble_att_read_blob_req *dst,
                           const struct ble_att_read_blob_req *src)
{
    dst->babq_handle = TOFROMLE16(src->babq_handle);
   1ae86:	8813      	ldrh	r3, [r2, #0]
   1ae88:	f8a0 3001 	strh.w	r3, [r0, #1]
    dst->babq_offset = TOFROMLE16(src->babq_offset);
   1ae8c:	8853      	ldrh	r3, [r2, #2]
   1ae8e:	f8a0 3003 	strh.w	r3, [r0, #3]
   1ae92:	4770      	bx	lr

0001ae94 <ble_att_read_blob_req_log>:
    ble_att_read_blob_req_swap(dst, src);
}

void
ble_att_read_blob_req_log(const struct ble_att_read_blob_req *cmd)
{
   1ae94:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "handle=0x%04x offset=%d", cmd->babq_handle,
   1ae96:	8803      	ldrh	r3, [r0, #0]
   1ae98:	9300      	str	r3, [sp, #0]
   1ae9a:	8843      	ldrh	r3, [r0, #2]
   1ae9c:	9301      	str	r3, [sp, #4]
   1ae9e:	4804      	ldr	r0, [pc, #16]	; (1aeb0 <ble_att_read_blob_req_log+0x1c>)
   1aea0:	4b04      	ldr	r3, [pc, #16]	; (1aeb4 <ble_att_read_blob_req_log+0x20>)
   1aea2:	2104      	movs	r1, #4
   1aea4:	2200      	movs	r2, #0
   1aea6:	f002 f9bf 	bl	1d228 <log_printf>
               cmd->babq_offset);
}
   1aeaa:	b003      	add	sp, #12
   1aeac:	f85d fb04 	ldr.w	pc, [sp], #4
   1aeb0:	20003b9c 	.word	0x20003b9c
   1aeb4:	000209d5 	.word	0x000209d5

0001aeb8 <ble_att_read_mult_req_parse>:

void
ble_att_read_mult_req_parse(const void *payload, int len)
{
   1aeb8:	4770      	bx	lr

0001aeba <ble_att_read_mult_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1aeba:	230f      	movs	r3, #15
   1aebc:	7003      	strb	r3, [r0, #0]
   1aebe:	4770      	bx	lr

0001aec0 <ble_att_read_group_type_req_parse>:

static void
ble_att_read_group_type_req_swap(struct ble_att_read_group_type_req *dst,
                                 const struct ble_att_read_group_type_req *src)
{
    dst->bagq_start_handle = TOFROMLE16(src->bagq_start_handle);
   1aec0:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1aec4:	8013      	strh	r3, [r2, #0]
    dst->bagq_end_handle = TOFROMLE16(src->bagq_end_handle);
   1aec6:	f8b0 3003 	ldrh.w	r3, [r0, #3]
   1aeca:	8053      	strh	r3, [r2, #2]
   1aecc:	4770      	bx	lr

0001aece <ble_att_read_group_type_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1aece:	2310      	movs	r3, #16
   1aed0:	7003      	strb	r3, [r0, #0]

static void
ble_att_read_group_type_req_swap(struct ble_att_read_group_type_req *dst,
                                 const struct ble_att_read_group_type_req *src)
{
    dst->bagq_start_handle = TOFROMLE16(src->bagq_start_handle);
   1aed2:	8813      	ldrh	r3, [r2, #0]
   1aed4:	f8a0 3001 	strh.w	r3, [r0, #1]
    dst->bagq_end_handle = TOFROMLE16(src->bagq_end_handle);
   1aed8:	8853      	ldrh	r3, [r2, #2]
   1aeda:	f8a0 3003 	strh.w	r3, [r0, #3]
   1aede:	4770      	bx	lr

0001aee0 <ble_att_read_group_type_req_log>:
    ble_att_read_group_type_req_swap(dst, src);
}

void
ble_att_read_group_type_req_log(const struct ble_att_read_group_type_req *cmd)
{
   1aee0:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "start_handle=0x%04x end_handle=0x%04x",
   1aee2:	8803      	ldrh	r3, [r0, #0]
   1aee4:	9300      	str	r3, [sp, #0]
   1aee6:	8843      	ldrh	r3, [r0, #2]
   1aee8:	9301      	str	r3, [sp, #4]
   1aeea:	4804      	ldr	r0, [pc, #16]	; (1aefc <ble_att_read_group_type_req_log+0x1c>)
   1aeec:	4b04      	ldr	r3, [pc, #16]	; (1af00 <ble_att_read_group_type_req_log+0x20>)
   1aeee:	2104      	movs	r1, #4
   1aef0:	2200      	movs	r2, #0
   1aef2:	f002 f999 	bl	1d228 <log_printf>
               cmd->bagq_start_handle, cmd->bagq_end_handle);
}
   1aef6:	b003      	add	sp, #12
   1aef8:	f85d fb04 	ldr.w	pc, [sp], #4
   1aefc:	20003b9c 	.word	0x20003b9c
   1af00:	00020968 	.word	0x00020968

0001af04 <ble_att_read_group_type_rsp_parse>:

static void
ble_att_read_group_type_rsp_swap(struct ble_att_read_group_type_rsp *dst,
                                 const struct ble_att_read_group_type_rsp *src)
{
    dst->bagp_length = src->bagp_length;
   1af04:	7843      	ldrb	r3, [r0, #1]
   1af06:	7013      	strb	r3, [r2, #0]
   1af08:	4770      	bx	lr

0001af0a <ble_att_read_group_type_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1af0a:	2311      	movs	r3, #17
   1af0c:	7003      	strb	r3, [r0, #0]

static void
ble_att_read_group_type_rsp_swap(struct ble_att_read_group_type_rsp *dst,
                                 const struct ble_att_read_group_type_rsp *src)
{
    dst->bagp_length = src->bagp_length;
   1af0e:	7813      	ldrb	r3, [r2, #0]
   1af10:	7043      	strb	r3, [r0, #1]
   1af12:	4770      	bx	lr

0001af14 <ble_att_read_group_type_rsp_log>:
    ble_att_read_group_type_rsp_swap(dst, src);
}

void
ble_att_read_group_type_rsp_log(const struct ble_att_read_group_type_rsp *cmd)
{
   1af14:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "length=%d", cmd->bagp_length);
   1af16:	7803      	ldrb	r3, [r0, #0]
   1af18:	9300      	str	r3, [sp, #0]
   1af1a:	4804      	ldr	r0, [pc, #16]	; (1af2c <ble_att_read_group_type_rsp_log+0x18>)
   1af1c:	4b04      	ldr	r3, [pc, #16]	; (1af30 <ble_att_read_group_type_rsp_log+0x1c>)
   1af1e:	2104      	movs	r1, #4
   1af20:	2200      	movs	r2, #0
   1af22:	f002 f981 	bl	1d228 <log_printf>
}
   1af26:	b003      	add	sp, #12
   1af28:	f85d fb04 	ldr.w	pc, [sp], #4
   1af2c:	20003b9c 	.word	0x20003b9c
   1af30:	000209cb 	.word	0x000209cb

0001af34 <ble_att_write_req_parse>:

static void
ble_att_write_req_swap(struct ble_att_write_req *dst,
                       const struct ble_att_write_req *src)
{
    dst->bawq_handle = TOFROMLE16(src->bawq_handle);
   1af34:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1af38:	8013      	strh	r3, [r2, #0]
   1af3a:	4770      	bx	lr

0001af3c <ble_att_write_cmd_parse>:
   1af3c:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1af40:	8013      	strh	r3, [r2, #0]
   1af42:	4770      	bx	lr

0001af44 <ble_att_write_cmd_log>:
    ble_att_write_req_swap(dst, src);
}

void
ble_att_write_cmd_log(const struct ble_att_write_req *cmd)
{
   1af44:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "handle=0x%04x", cmd->bawq_handle);
   1af46:	8803      	ldrh	r3, [r0, #0]
   1af48:	9300      	str	r3, [sp, #0]
   1af4a:	4804      	ldr	r0, [pc, #16]	; (1af5c <ble_att_write_cmd_log+0x18>)
   1af4c:	4b04      	ldr	r3, [pc, #16]	; (1af60 <ble_att_write_cmd_log+0x1c>)
   1af4e:	2104      	movs	r1, #4
   1af50:	2200      	movs	r2, #0
   1af52:	f002 f969 	bl	1d228 <log_printf>
}
   1af56:	b003      	add	sp, #12
   1af58:	f85d fb04 	ldr.w	pc, [sp], #4
   1af5c:	20003b9c 	.word	0x20003b9c
   1af60:	00020980 	.word	0x00020980

0001af64 <ble_att_prep_write_req_parse>:

static void
ble_att_prep_write_cmd_swap(struct ble_att_prep_write_cmd *dst,
                            const struct ble_att_prep_write_cmd *src)
{
    dst->bapc_handle = TOFROMLE16(src->bapc_handle);
   1af64:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1af68:	8013      	strh	r3, [r2, #0]
    dst->bapc_offset = TOFROMLE16(src->bapc_offset);
   1af6a:	f8b0 3003 	ldrh.w	r3, [r0, #3]
   1af6e:	8053      	strh	r3, [r2, #2]
   1af70:	4770      	bx	lr

0001af72 <ble_att_prep_write_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1af72:	2316      	movs	r3, #22
   1af74:	7003      	strb	r3, [r0, #0]

static void
ble_att_prep_write_cmd_swap(struct ble_att_prep_write_cmd *dst,
                            const struct ble_att_prep_write_cmd *src)
{
    dst->bapc_handle = TOFROMLE16(src->bapc_handle);
   1af76:	8813      	ldrh	r3, [r2, #0]
   1af78:	f8a0 3001 	strh.w	r3, [r0, #1]
    dst->bapc_offset = TOFROMLE16(src->bapc_offset);
   1af7c:	8853      	ldrh	r3, [r2, #2]
   1af7e:	f8a0 3003 	strh.w	r3, [r0, #3]
   1af82:	4770      	bx	lr

0001af84 <ble_att_prep_write_rsp_parse>:

static void
ble_att_prep_write_cmd_swap(struct ble_att_prep_write_cmd *dst,
                            const struct ble_att_prep_write_cmd *src)
{
    dst->bapc_handle = TOFROMLE16(src->bapc_handle);
   1af84:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1af88:	8013      	strh	r3, [r2, #0]
    dst->bapc_offset = TOFROMLE16(src->bapc_offset);
   1af8a:	f8b0 3003 	ldrh.w	r3, [r0, #3]
   1af8e:	8053      	strh	r3, [r2, #2]
   1af90:	4770      	bx	lr

0001af92 <ble_att_prep_write_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1af92:	2317      	movs	r3, #23
   1af94:	7003      	strb	r3, [r0, #0]

static void
ble_att_prep_write_cmd_swap(struct ble_att_prep_write_cmd *dst,
                            const struct ble_att_prep_write_cmd *src)
{
    dst->bapc_handle = TOFROMLE16(src->bapc_handle);
   1af96:	8813      	ldrh	r3, [r2, #0]
   1af98:	f8a0 3001 	strh.w	r3, [r0, #1]
    dst->bapc_offset = TOFROMLE16(src->bapc_offset);
   1af9c:	8853      	ldrh	r3, [r2, #2]
   1af9e:	f8a0 3003 	strh.w	r3, [r0, #3]
   1afa2:	4770      	bx	lr

0001afa4 <ble_att_prep_write_cmd_log>:
    ble_att_prep_write_cmd_swap(dst, src);
}

void
ble_att_prep_write_cmd_log(const struct ble_att_prep_write_cmd *cmd)
{
   1afa4:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "handle=0x%04x offset=%d", cmd->bapc_handle,
   1afa6:	8803      	ldrh	r3, [r0, #0]
   1afa8:	9300      	str	r3, [sp, #0]
   1afaa:	8843      	ldrh	r3, [r0, #2]
   1afac:	9301      	str	r3, [sp, #4]
   1afae:	4804      	ldr	r0, [pc, #16]	; (1afc0 <ble_att_prep_write_cmd_log+0x1c>)
   1afb0:	4b04      	ldr	r3, [pc, #16]	; (1afc4 <ble_att_prep_write_cmd_log+0x20>)
   1afb2:	2104      	movs	r1, #4
   1afb4:	2200      	movs	r2, #0
   1afb6:	f002 f937 	bl	1d228 <log_printf>
               cmd->bapc_offset);
}
   1afba:	b003      	add	sp, #12
   1afbc:	f85d fb04 	ldr.w	pc, [sp], #4
   1afc0:	20003b9c 	.word	0x20003b9c
   1afc4:	000209d5 	.word	0x000209d5

0001afc8 <ble_att_exec_write_req_parse>:

static void
ble_att_exec_write_req_swap(struct ble_att_exec_write_req *dst,
                            const struct ble_att_exec_write_req *src)
{
    dst->baeq_flags = src->baeq_flags;
   1afc8:	7843      	ldrb	r3, [r0, #1]
   1afca:	7013      	strb	r3, [r2, #0]
   1afcc:	4770      	bx	lr

0001afce <ble_att_exec_write_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1afce:	2318      	movs	r3, #24
   1afd0:	7003      	strb	r3, [r0, #0]

static void
ble_att_exec_write_req_swap(struct ble_att_exec_write_req *dst,
                            const struct ble_att_exec_write_req *src)
{
    dst->baeq_flags = src->baeq_flags;
   1afd2:	7813      	ldrb	r3, [r2, #0]
   1afd4:	7043      	strb	r3, [r0, #1]
   1afd6:	4770      	bx	lr

0001afd8 <ble_att_exec_write_req_log>:
    ble_att_exec_write_req_swap(dst, src);
}

void
ble_att_exec_write_req_log(const struct ble_att_exec_write_req *cmd)
{
   1afd8:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "flags=0x%02x", cmd->baeq_flags);
   1afda:	7803      	ldrb	r3, [r0, #0]
   1afdc:	9300      	str	r3, [sp, #0]
   1afde:	4804      	ldr	r0, [pc, #16]	; (1aff0 <ble_att_exec_write_req_log+0x18>)
   1afe0:	4b04      	ldr	r3, [pc, #16]	; (1aff4 <ble_att_exec_write_req_log+0x1c>)
   1afe2:	2104      	movs	r1, #4
   1afe4:	2200      	movs	r2, #0
   1afe6:	f002 f91f 	bl	1d228 <log_printf>
}
   1afea:	b003      	add	sp, #12
   1afec:	f85d fb04 	ldr.w	pc, [sp], #4
   1aff0:	20003b9c 	.word	0x20003b9c
   1aff4:	000209ed 	.word	0x000209ed

0001aff8 <ble_att_exec_write_rsp_parse>:

void
ble_att_exec_write_rsp_parse(const void *payload, int len)
{
   1aff8:	4770      	bx	lr

0001affa <ble_att_exec_write_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1affa:	2319      	movs	r3, #25
   1affc:	7003      	strb	r3, [r0, #0]
   1affe:	4770      	bx	lr

0001b000 <ble_att_notify_req_parse>:

static void
ble_att_notify_req_swap(struct ble_att_notify_req *dst,
                        const struct ble_att_notify_req *src)
{
    dst->banq_handle = TOFROMLE16(src->banq_handle);
   1b000:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1b004:	8013      	strh	r3, [r2, #0]
   1b006:	4770      	bx	lr

0001b008 <ble_att_notify_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1b008:	231b      	movs	r3, #27
   1b00a:	7003      	strb	r3, [r0, #0]

static void
ble_att_notify_req_swap(struct ble_att_notify_req *dst,
                        const struct ble_att_notify_req *src)
{
    dst->banq_handle = TOFROMLE16(src->banq_handle);
   1b00c:	8813      	ldrh	r3, [r2, #0]
   1b00e:	f8a0 3001 	strh.w	r3, [r0, #1]
   1b012:	4770      	bx	lr

0001b014 <ble_att_notify_req_log>:
    ble_att_notify_req_swap(dst, src);
}

void
ble_att_notify_req_log(const struct ble_att_notify_req *cmd)
{
   1b014:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "handle=0x%04x", cmd->banq_handle);
   1b016:	8803      	ldrh	r3, [r0, #0]
   1b018:	9300      	str	r3, [sp, #0]
   1b01a:	4804      	ldr	r0, [pc, #16]	; (1b02c <ble_att_notify_req_log+0x18>)
   1b01c:	4b04      	ldr	r3, [pc, #16]	; (1b030 <ble_att_notify_req_log+0x1c>)
   1b01e:	2104      	movs	r1, #4
   1b020:	2200      	movs	r2, #0
   1b022:	f002 f901 	bl	1d228 <log_printf>
}
   1b026:	b003      	add	sp, #12
   1b028:	f85d fb04 	ldr.w	pc, [sp], #4
   1b02c:	20003b9c 	.word	0x20003b9c
   1b030:	00020980 	.word	0x00020980

0001b034 <ble_att_indicate_req_parse>:

static void
ble_att_indicate_req_swap(struct ble_att_indicate_req *dst,
                          const struct ble_att_indicate_req *src)
{
    dst->baiq_handle = TOFROMLE16(src->baiq_handle);
   1b034:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   1b038:	8013      	strh	r3, [r2, #0]
   1b03a:	4770      	bx	lr

0001b03c <ble_att_indicate_req_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1b03c:	231d      	movs	r3, #29
   1b03e:	7003      	strb	r3, [r0, #0]

static void
ble_att_indicate_req_swap(struct ble_att_indicate_req *dst,
                          const struct ble_att_indicate_req *src)
{
    dst->baiq_handle = TOFROMLE16(src->baiq_handle);
   1b040:	8813      	ldrh	r3, [r2, #0]
   1b042:	f8a0 3001 	strh.w	r3, [r0, #1]
   1b046:	4770      	bx	lr

0001b048 <ble_att_indicate_req_log>:
    ble_att_indicate_req_swap(dst, src);
}

void
ble_att_indicate_req_log(const struct ble_att_indicate_req *cmd)
{
   1b048:	b507      	push	{r0, r1, r2, lr}
    BLE_HS_LOG(DEBUG, "handle=0x%04x", cmd->baiq_handle);
   1b04a:	8803      	ldrh	r3, [r0, #0]
   1b04c:	9300      	str	r3, [sp, #0]
   1b04e:	4804      	ldr	r0, [pc, #16]	; (1b060 <ble_att_indicate_req_log+0x18>)
   1b050:	4b04      	ldr	r3, [pc, #16]	; (1b064 <ble_att_indicate_req_log+0x1c>)
   1b052:	2104      	movs	r1, #4
   1b054:	2200      	movs	r2, #0
   1b056:	f002 f8e7 	bl	1d228 <log_printf>
}
   1b05a:	b003      	add	sp, #12
   1b05c:	f85d fb04 	ldr.w	pc, [sp], #4
   1b060:	20003b9c 	.word	0x20003b9c
   1b064:	00020980 	.word	0x00020980

0001b068 <ble_att_indicate_rsp_write>:
    uint8_t *u8ptr;

    BLE_HS_DBG_ASSERT(actual_len >= min_len);

    u8ptr = payload;
    u8ptr[0] = op;
   1b068:	231e      	movs	r3, #30
   1b06a:	7003      	strb	r3, [r0, #0]
   1b06c:	4770      	bx	lr

0001b06e <ble_att_svr_pullup_req_base>:
}

static int
ble_att_svr_pullup_req_base(struct os_mbuf **om, int base_len,
                            uint8_t *out_att_err)
{
   1b06e:	b510      	push	{r4, lr}
   1b070:	4614      	mov	r4, r2
    uint8_t att_err;
    int rc;

    rc = ble_hs_misc_pullup_base(om, base_len);
   1b072:	f7fa fa61 	bl	15538 <ble_hs_misc_pullup_base>
    if (rc == BLE_HS_ENOMEM) {
        att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
    } else {
        att_err = 0;
   1b076:	2806      	cmp	r0, #6
   1b078:	bf0c      	ite	eq
   1b07a:	2311      	moveq	r3, #17
   1b07c:	2300      	movne	r3, #0
    }

    if (out_att_err != NULL) {
   1b07e:	b104      	cbz	r4, 1b082 <ble_att_svr_pullup_req_base+0x14>
        *out_att_err = att_err;
   1b080:	7023      	strb	r3, [r4, #0]
    }

    return rc;
}
   1b082:	bd10      	pop	{r4, pc}

0001b084 <ble_att_svr_tx_rsp>:
 *                                  field.
 */
static int
ble_att_svr_tx_rsp(uint16_t conn_handle, int rc, struct os_mbuf *txom,
                   uint8_t att_op, uint8_t err_status, uint16_t err_handle)
{
   1b084:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1b088:	b088      	sub	sp, #32
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    int do_tx;

    if (rc == BLE_HS_ENOTCONN) {
   1b08a:	2907      	cmp	r1, #7
 *                                  field.
 */
static int
ble_att_svr_tx_rsp(uint16_t conn_handle, int rc, struct os_mbuf *txom,
                   uint8_t att_op, uint8_t err_status, uint16_t err_handle)
{
   1b08c:	4606      	mov	r6, r0
   1b08e:	460c      	mov	r4, r1
   1b090:	4615      	mov	r5, r2
   1b092:	4699      	mov	r9, r3
   1b094:	f89d 7040 	ldrb.w	r7, [sp, #64]	; 0x40
    struct ble_l2cap_chan *chan;
    struct ble_hs_conn *conn;
    int do_tx;

    if (rc == BLE_HS_ENOTCONN) {
   1b098:	d05f      	beq.n	1b15a <ble_att_svr_tx_rsp+0xd6>
        /* No connection; tx is not possible. */
        do_tx = 0;
    } else if (rc != 0 && err_status == 0) {
   1b09a:	b109      	cbz	r1, 1b0a0 <ble_att_svr_tx_rsp+0x1c>
   1b09c:	2f00      	cmp	r7, #0
   1b09e:	d05c      	beq.n	1b15a <ble_att_svr_tx_rsp+0xd6>
    } else {
        do_tx = 1;
    }

    if (do_tx) {
        ble_hs_lock();
   1b0a0:	f7f9 fb50 	bl	14744 <ble_hs_lock>

        ble_att_conn_chan_find(conn_handle, &conn, &chan);
   1b0a4:	4630      	mov	r0, r6
   1b0a6:	a906      	add	r1, sp, #24
   1b0a8:	aa05      	add	r2, sp, #20
   1b0aa:	f7fe fd99 	bl	19be0 <ble_att_conn_chan_find>
        if (chan == NULL) {
   1b0ae:	9b05      	ldr	r3, [sp, #20]
   1b0b0:	b16b      	cbz	r3, 1b0ce <ble_att_svr_tx_rsp+0x4a>
            rc = BLE_HS_ENOTCONN;
        } else {
            if (rc == 0) {
   1b0b2:	b994      	cbnz	r4, 1b0da <ble_att_svr_tx_rsp+0x56>
                BLE_HS_DBG_ASSERT(txom != NULL);
                ble_att_inc_tx_stat(txom->om_data[0]);
   1b0b4:	682b      	ldr	r3, [r5, #0]
   1b0b6:	7818      	ldrb	r0, [r3, #0]
   1b0b8:	f7fe fd9c 	bl	19bf4 <ble_att_inc_tx_stat>
                rc = ble_l2cap_tx(conn, chan, txom);
   1b0bc:	9806      	ldr	r0, [sp, #24]
   1b0be:	9905      	ldr	r1, [sp, #20]
   1b0c0:	462a      	mov	r2, r5
   1b0c2:	f7fa fc7d 	bl	159c0 <ble_l2cap_tx>
                txom = NULL;
                if (rc != 0) {
   1b0c6:	4604      	mov	r4, r0
   1b0c8:	b928      	cbnz	r0, 1b0d6 <ble_att_svr_tx_rsp+0x52>
        } else {
            if (rc == 0) {
                BLE_HS_DBG_ASSERT(txom != NULL);
                ble_att_inc_tx_stat(txom->om_data[0]);
                rc = ble_l2cap_tx(conn, chan, txom);
                txom = NULL;
   1b0ca:	4605      	mov	r5, r0
   1b0cc:	e000      	b.n	1b0d0 <ble_att_svr_tx_rsp+0x4c>
    if (do_tx) {
        ble_hs_lock();

        ble_att_conn_chan_find(conn_handle, &conn, &chan);
        if (chan == NULL) {
            rc = BLE_HS_ENOTCONN;
   1b0ce:	2407      	movs	r4, #7
                ble_att_svr_tx_error_rsp(conn, chan, att_op,
                                         err_handle, err_status);
            }
        }

        ble_hs_unlock();
   1b0d0:	f7f9 fb40 	bl	14754 <ble_hs_unlock>
   1b0d4:	e041      	b.n	1b15a <ble_att_svr_tx_rsp+0xd6>
                BLE_HS_DBG_ASSERT(txom != NULL);
                ble_att_inc_tx_stat(txom->om_data[0]);
                rc = ble_l2cap_tx(conn, chan, txom);
                txom = NULL;
                if (rc != 0) {
                    err_status = BLE_ATT_ERR_UNLIKELY;
   1b0d6:	270e      	movs	r7, #14
        } else {
            if (rc == 0) {
                BLE_HS_DBG_ASSERT(txom != NULL);
                ble_att_inc_tx_stat(txom->om_data[0]);
                rc = ble_l2cap_tx(conn, chan, txom);
                txom = NULL;
   1b0d8:	2500      	movs	r5, #0
                    err_status = BLE_ATT_ERR_UNLIKELY;
                }
            }

            if (rc != 0) {
                STATS_INC(ble_att_stats, error_rsp_tx);
   1b0da:	4a23      	ldr	r2, [pc, #140]	; (1b168 <ble_att_svr_tx_rsp+0xe4>)
                ble_att_svr_tx_error_rsp(conn, chan, att_op,
   1b0dc:	f8dd 8018 	ldr.w	r8, [sp, #24]
                    err_status = BLE_ATT_ERR_UNLIKELY;
                }
            }

            if (rc != 0) {
                STATS_INC(ble_att_stats, error_rsp_tx);
   1b0e0:	6913      	ldr	r3, [r2, #16]
                ble_att_svr_tx_error_rsp(conn, chan, att_op,
   1b0e2:	f8dd a014 	ldr.w	sl, [sp, #20]
                    err_status = BLE_ATT_ERR_UNLIKELY;
                }
            }

            if (rc != 0) {
                STATS_INC(ble_att_stats, error_rsp_tx);
   1b0e6:	3301      	adds	r3, #1
   1b0e8:	6113      	str	r3, [r2, #16]
    void *dst;
    int rc;

    BLE_HS_DBG_ASSERT(error_code != 0);

    txom = ble_hs_misc_pkthdr();
   1b0ea:	f7fa fa13 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1b0ee:	4606      	mov	r6, r0
   1b0f0:	b370      	cbz	r0, 1b150 <ble_att_svr_tx_rsp+0xcc>
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    dst = os_mbuf_extend(txom, BLE_ATT_ERROR_RSP_SZ);
   1b0f2:	2105      	movs	r1, #5
   1b0f4:	f7ef f8bc 	bl	a270 <os_mbuf_extend>
    if (dst == NULL) {
   1b0f8:	b358      	cbz	r0, 1b152 <ble_att_svr_tx_rsp+0xce>
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    rsp.baep_req_op = req_op;
    rsp.baep_handle = handle;
   1b0fa:	f8bd 3044 	ldrh.w	r3, [sp, #68]	; 0x44
   1b0fe:	f8ad 301d 	strh.w	r3, [sp, #29]
    rsp.baep_error_code = error_code;

    ble_att_error_rsp_write(dst, BLE_ATT_ERROR_RSP_SZ, &rsp);
   1b102:	2105      	movs	r1, #5
   1b104:	aa07      	add	r2, sp, #28
    if (dst == NULL) {
        rc = BLE_HS_ENOMEM;
        goto err;
    }

    rsp.baep_req_op = req_op;
   1b106:	f88d 901c 	strb.w	r9, [sp, #28]
    rsp.baep_handle = handle;
    rsp.baep_error_code = error_code;
   1b10a:	f88d 701f 	strb.w	r7, [sp, #31]

    ble_att_error_rsp_write(dst, BLE_ATT_ERROR_RSP_SZ, &rsp);
   1b10e:	f7ff fdbf 	bl	1ac90 <ble_att_error_rsp_write>
    BLE_ATT_LOG_CMD(1, "error rsp", conn->bhc_handle,
   1b112:	4b16      	ldr	r3, [pc, #88]	; (1b16c <ble_att_svr_tx_rsp+0xe8>)
   1b114:	9300      	str	r3, [sp, #0]
   1b116:	4b16      	ldr	r3, [pc, #88]	; (1b170 <ble_att_svr_tx_rsp+0xec>)
   1b118:	9301      	str	r3, [sp, #4]
   1b11a:	4b16      	ldr	r3, [pc, #88]	; (1b174 <ble_att_svr_tx_rsp+0xf0>)
   1b11c:	9302      	str	r3, [sp, #8]
   1b11e:	f8b8 3004 	ldrh.w	r3, [r8, #4]
   1b122:	9303      	str	r3, [sp, #12]
   1b124:	2104      	movs	r1, #4
   1b126:	2200      	movs	r2, #0
   1b128:	4b13      	ldr	r3, [pc, #76]	; (1b178 <ble_att_svr_tx_rsp+0xf4>)
   1b12a:	4814      	ldr	r0, [pc, #80]	; (1b17c <ble_att_svr_tx_rsp+0xf8>)
   1b12c:	f002 f87c 	bl	1d228 <log_printf>
   1b130:	a807      	add	r0, sp, #28
   1b132:	f7ff fdb7 	bl	1aca4 <ble_att_error_rsp_log>
   1b136:	4811      	ldr	r0, [pc, #68]	; (1b17c <ble_att_svr_tx_rsp+0xf8>)
   1b138:	4b11      	ldr	r3, [pc, #68]	; (1b180 <ble_att_svr_tx_rsp+0xfc>)
   1b13a:	2104      	movs	r1, #4
   1b13c:	2200      	movs	r2, #0
   1b13e:	f002 f873 	bl	1d228 <log_printf>
                    ble_att_error_rsp_log, &rsp);

    rc = ble_l2cap_tx(conn, chan, txom);
   1b142:	4640      	mov	r0, r8
   1b144:	4651      	mov	r1, sl
   1b146:	4632      	mov	r2, r6
   1b148:	f7fa fc3a 	bl	159c0 <ble_l2cap_tx>
    txom = NULL;
    if (rc != 0) {
   1b14c:	2800      	cmp	r0, #0
   1b14e:	d0bf      	beq.n	1b0d0 <ble_att_svr_tx_rsp+0x4c>
    ble_att_error_rsp_write(dst, BLE_ATT_ERROR_RSP_SZ, &rsp);
    BLE_ATT_LOG_CMD(1, "error rsp", conn->bhc_handle,
                    ble_att_error_rsp_log, &rsp);

    rc = ble_l2cap_tx(conn, chan, txom);
    txom = NULL;
   1b150:	2600      	movs	r6, #0
    }

    return 0;

err:
    os_mbuf_free_chain(txom);
   1b152:	4630      	mov	r0, r6
   1b154:	f7ee ff03 	bl	9f5e <os_mbuf_free_chain>
   1b158:	e7ba      	b.n	1b0d0 <ble_att_svr_tx_rsp+0x4c>
        }

        ble_hs_unlock();
    }

    os_mbuf_free_chain(txom);
   1b15a:	4628      	mov	r0, r5
   1b15c:	f7ee feff 	bl	9f5e <os_mbuf_free_chain>

    return rc;
}
   1b160:	4620      	mov	r0, r4
   1b162:	b008      	add	sp, #32
   1b164:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1b168:	20003d14 	.word	0x20003d14
   1b16c:	0001fe60 	.word	0x0001fe60
   1b170:	000207e0 	.word	0x000207e0
   1b174:	000207e4 	.word	0x000207e4
   1b178:	0001fbbc 	.word	0x0001fbbc
   1b17c:	20003b9c 	.word	0x20003b9c
   1b180:	0001fdec 	.word	0x0001fdec

0001b184 <ble_att_svr_read_group_type_entry_write>:
ble_att_svr_read_group_type_entry_write(struct os_mbuf *om, uint16_t mtu,
                                        uint16_t start_group_handle,
                                        uint16_t end_group_handle,
                                        uint16_t service_uuid16,
                                        uint8_t *service_uuid128)
{
   1b184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b186:	f8bd 5018 	ldrh.w	r5, [sp, #24]
   1b18a:	461e      	mov	r6, r3
    int len;

    if (service_uuid16 != 0) {
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_16;
    } else {
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_128;
   1b18c:	2d00      	cmp	r5, #0
    }
    if (OS_MBUF_PKTLEN(om) + len > mtu) {
   1b18e:	8a03      	ldrh	r3, [r0, #16]
    int len;

    if (service_uuid16 != 0) {
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_16;
    } else {
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_128;
   1b190:	bf14      	ite	ne
   1b192:	2406      	movne	r4, #6
   1b194:	2414      	moveq	r4, #20
    }
    if (OS_MBUF_PKTLEN(om) + len > mtu) {
   1b196:	4423      	add	r3, r4
   1b198:	428b      	cmp	r3, r1
ble_att_svr_read_group_type_entry_write(struct os_mbuf *om, uint16_t mtu,
                                        uint16_t start_group_handle,
                                        uint16_t end_group_handle,
                                        uint16_t service_uuid16,
                                        uint8_t *service_uuid128)
{
   1b19a:	4617      	mov	r7, r2
    if (service_uuid16 != 0) {
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_16;
    } else {
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_128;
    }
    if (OS_MBUF_PKTLEN(om) + len > mtu) {
   1b19c:	dc1c      	bgt.n	1b1d8 <ble_att_svr_read_group_type_entry_write+0x54>
        return BLE_HS_EMSGSIZE;
    }

    buf = os_mbuf_extend(om, len);
   1b19e:	4621      	mov	r1, r4
   1b1a0:	f7ef f866 	bl	a270 <os_mbuf_extend>
    if (buf == NULL) {
   1b1a4:	4604      	mov	r4, r0
   1b1a6:	b1c8      	cbz	r0, 1b1dc <ble_att_svr_read_group_type_entry_write+0x58>
        return BLE_HS_ENOMEM;
    }

    htole16(buf + 0, start_group_handle);
   1b1a8:	4639      	mov	r1, r7
   1b1aa:	f001 ff55 	bl	1d058 <htole16>
    htole16(buf + 2, end_group_handle);
   1b1ae:	1ca0      	adds	r0, r4, #2
   1b1b0:	4631      	mov	r1, r6
   1b1b2:	f001 ff51 	bl	1d058 <htole16>
   1b1b6:	1d20      	adds	r0, r4, #4
    if (service_uuid16 != 0) {
   1b1b8:	b11d      	cbz	r5, 1b1c2 <ble_att_svr_read_group_type_entry_write+0x3e>
        htole16(buf + 4, service_uuid16);
   1b1ba:	4629      	mov	r1, r5
   1b1bc:	f001 ff4c 	bl	1d058 <htole16>
   1b1c0:	e008      	b.n	1b1d4 <ble_att_svr_read_group_type_entry_write+0x50>
    } else {
        memcpy(buf + 4, service_uuid128, 16);
   1b1c2:	9b07      	ldr	r3, [sp, #28]
   1b1c4:	f103 0210 	add.w	r2, r3, #16
   1b1c8:	f853 1b04 	ldr.w	r1, [r3], #4
   1b1cc:	f840 1b04 	str.w	r1, [r0], #4
   1b1d0:	4293      	cmp	r3, r2
   1b1d2:	d1f9      	bne.n	1b1c8 <ble_att_svr_read_group_type_entry_write+0x44>
    }

    return 0;
   1b1d4:	2000      	movs	r0, #0
   1b1d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_16;
    } else {
        len = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_128;
    }
    if (OS_MBUF_PKTLEN(om) + len > mtu) {
        return BLE_HS_EMSGSIZE;
   1b1d8:	2004      	movs	r0, #4
   1b1da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    buf = os_mbuf_extend(om, len);
    if (buf == NULL) {
        return BLE_HS_ENOMEM;
   1b1dc:	2006      	movs	r0, #6
    } else {
        memcpy(buf + 4, service_uuid128, 16);
    }

    return 0;
}
   1b1de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001b1e0 <ble_att_svr_fill_type_value_no_match>:
 */
static int
ble_att_svr_fill_type_value_no_match(struct os_mbuf *om, uint16_t *first,
                                     uint16_t *prev, int mtu,
                                     uint8_t *out_att_err)
{
   1b1e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1b1e2:	460f      	mov	r7, r1
    uint16_t u16;
    int rsp_sz;
    int rc;

    /* If there is no current group, then there is nothing to do. */
    if (*first == 0) {
   1b1e4:	8809      	ldrh	r1, [r1, #0]
 */
static int
ble_att_svr_fill_type_value_no_match(struct os_mbuf *om, uint16_t *first,
                                     uint16_t *prev, int mtu,
                                     uint8_t *out_att_err)
{
   1b1e6:	4605      	mov	r5, r0
   1b1e8:	4616      	mov	r6, r2
    uint16_t u16;
    int rsp_sz;
    int rc;

    /* If there is no current group, then there is nothing to do. */
    if (*first == 0) {
   1b1ea:	b319      	cbz	r1, 1b234 <ble_att_svr_fill_type_value_no_match+0x54>
        return BLE_HS_EAGAIN;
    }

    rsp_sz = OS_MBUF_PKTHDR(om)->omp_len + 4;
   1b1ec:	8a02      	ldrh	r2, [r0, #16]
   1b1ee:	3204      	adds	r2, #4
    if (rsp_sz > mtu) {
   1b1f0:	429a      	cmp	r2, r3
   1b1f2:	dc21      	bgt.n	1b238 <ble_att_svr_fill_type_value_no_match+0x58>
        return 0;
    }

    u16 = *first;
   1b1f4:	ac02      	add	r4, sp, #8
   1b1f6:	f824 1d02 	strh.w	r1, [r4, #-2]!
    htole16(&u16, u16);
   1b1fa:	4620      	mov	r0, r4
   1b1fc:	f001 ff2c 	bl	1d058 <htole16>
    rc = os_mbuf_append(om, &u16, 2);
   1b200:	4628      	mov	r0, r5
   1b202:	4621      	mov	r1, r4
   1b204:	2202      	movs	r2, #2
   1b206:	f7ee feb3 	bl	9f70 <os_mbuf_append>
    if (rc != 0) {
   1b20a:	b120      	cbz	r0, 1b216 <ble_att_svr_fill_type_value_no_match+0x36>
        *out_att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1b20c:	9b08      	ldr	r3, [sp, #32]
   1b20e:	2211      	movs	r2, #17
   1b210:	701a      	strb	r2, [r3, #0]
        return BLE_HS_ENOMEM;
   1b212:	2006      	movs	r0, #6
   1b214:	e011      	b.n	1b23a <ble_att_svr_fill_type_value_no_match+0x5a>
    }

    u16 = *prev;
   1b216:	8831      	ldrh	r1, [r6, #0]
   1b218:	f8ad 1006 	strh.w	r1, [sp, #6]
    htole16(&u16, u16);
   1b21c:	4620      	mov	r0, r4
   1b21e:	f001 ff1b 	bl	1d058 <htole16>
    rc = os_mbuf_append(om, &u16, 2);
   1b222:	4628      	mov	r0, r5
   1b224:	4621      	mov	r1, r4
   1b226:	2202      	movs	r2, #2
   1b228:	f7ee fea2 	bl	9f70 <os_mbuf_append>
    if (rc != 0) {
   1b22c:	2800      	cmp	r0, #0
   1b22e:	d1ed      	bne.n	1b20c <ble_att_svr_fill_type_value_no_match+0x2c>
        *out_att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        return BLE_HS_ENOMEM;
    }

    *first = 0;
   1b230:	8038      	strh	r0, [r7, #0]
    *prev = 0;
   1b232:	8030      	strh	r0, [r6, #0]
    int rsp_sz;
    int rc;

    /* If there is no current group, then there is nothing to do. */
    if (*first == 0) {
        return BLE_HS_EAGAIN;
   1b234:	2001      	movs	r0, #1
   1b236:	e000      	b.n	1b23a <ble_att_svr_fill_type_value_no_match+0x5a>
    }

    rsp_sz = OS_MBUF_PKTHDR(om)->omp_len + 4;
    if (rsp_sz > mtu) {
        return 0;
   1b238:	2000      	movs	r0, #0

    *first = 0;
    *prev = 0;

    return BLE_HS_EAGAIN;
}
   1b23a:	b003      	add	sp, #12
   1b23c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0001b240 <ble_att_svr_prep_free>:
    return rc;
}

static void
ble_att_svr_prep_free(struct ble_att_prep_entry *entry)
{
   1b240:	b510      	push	{r4, lr}
   1b242:	4604      	mov	r4, r0
    os_mbuf_free_chain(entry->bape_value);
   1b244:	6880      	ldr	r0, [r0, #8]
   1b246:	f7ee fe8a 	bl	9f5e <os_mbuf_free_chain>
    os_memblock_put(&ble_att_svr_prep_entry_pool, entry);
   1b24a:	4621      	mov	r1, r4
   1b24c:	4802      	ldr	r0, [pc, #8]	; (1b258 <ble_att_svr_prep_free+0x18>)
}
   1b24e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static void
ble_att_svr_prep_free(struct ble_att_prep_entry *entry)
{
    os_mbuf_free_chain(entry->bape_value);
    os_memblock_put(&ble_att_svr_prep_entry_pool, entry);
   1b252:	f7ef b8e5 	b.w	a420 <os_memblock_put>
   1b256:	bf00      	nop
   1b258:	200023e0 	.word	0x200023e0

0001b25c <ble_att_svr_check_security.isra.1>:
        return 0;
    }
}

static int
ble_att_svr_check_security(uint16_t conn_handle, int is_read,
   1b25c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b260:	4607      	mov	r7, r0
   1b262:	461e      	mov	r6, r3
    int author;
    int authen;
    int enc;
    int rc;

    if (is_read) {
   1b264:	b149      	cbz	r1, 1b27a <ble_att_svr_check_security.isra.1+0x1e>
        enc = entry->ha_flags & BLE_ATT_F_READ_ENC;
   1b266:	f002 0804 	and.w	r8, r2, #4
        authen = entry->ha_flags & BLE_ATT_F_READ_AUTHEN;
   1b26a:	f002 0408 	and.w	r4, r2, #8
    int authen;
    int enc;
    int rc;

    if (is_read) {
        enc = entry->ha_flags & BLE_ATT_F_READ_ENC;
   1b26e:	fa5f f888 	uxtb.w	r8, r8
        authen = entry->ha_flags & BLE_ATT_F_READ_AUTHEN;
   1b272:	b2e4      	uxtb	r4, r4
        author = entry->ha_flags & BLE_ATT_F_READ_AUTHOR;
   1b274:	f002 0210 	and.w	r2, r2, #16
   1b278:	e008      	b.n	1b28c <ble_att_svr_check_security.isra.1+0x30>
    } else {
        enc = entry->ha_flags & BLE_ATT_F_WRITE_ENC;
   1b27a:	f002 0820 	and.w	r8, r2, #32
        authen = entry->ha_flags & BLE_ATT_F_WRITE_AUTHEN;
   1b27e:	f002 0440 	and.w	r4, r2, #64	; 0x40
    if (is_read) {
        enc = entry->ha_flags & BLE_ATT_F_READ_ENC;
        authen = entry->ha_flags & BLE_ATT_F_READ_AUTHEN;
        author = entry->ha_flags & BLE_ATT_F_READ_AUTHOR;
    } else {
        enc = entry->ha_flags & BLE_ATT_F_WRITE_ENC;
   1b282:	fa5f f888 	uxtb.w	r8, r8
        authen = entry->ha_flags & BLE_ATT_F_WRITE_AUTHEN;
   1b286:	b2e4      	uxtb	r4, r4
        author = entry->ha_flags & BLE_ATT_F_WRITE_AUTHOR;
   1b288:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1b28c:	b2d2      	uxtb	r2, r2
    }

    /* Bail early if this operation doesn't require security. */
    if (!enc && !authen && !author) {
   1b28e:	f1b8 0f00 	cmp.w	r8, #0
   1b292:	d104      	bne.n	1b29e <ble_att_svr_check_security.isra.1+0x42>
   1b294:	b91c      	cbnz	r4, 1b29e <ble_att_svr_check_security.isra.1+0x42>
   1b296:	b912      	cbnz	r2, 1b29e <ble_att_svr_check_security.isra.1+0x42>
        return 0;
   1b298:	2000      	movs	r0, #0
   1b29a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
ble_att_svr_get_sec_state(uint16_t conn_handle,
                          struct ble_gap_sec_state *out_sec_state)
{
    struct ble_hs_conn *conn;

    ble_hs_lock();
   1b29e:	f7f9 fa51 	bl	14744 <ble_hs_lock>
    conn = ble_hs_conn_find(conn_handle);
   1b2a2:	4638      	mov	r0, r7
   1b2a4:	f7f9 fff6 	bl	15294 <ble_hs_conn_find>
    if (conn != NULL) {
   1b2a8:	4607      	mov	r7, r0
   1b2aa:	b100      	cbz	r0, 1b2ae <ble_att_svr_check_security.isra.1+0x52>
        *out_sec_state = conn->bhc_sec_state;
   1b2ac:	6c45      	ldr	r5, [r0, #68]	; 0x44
    }
    ble_hs_unlock();
   1b2ae:	f7f9 fa51 	bl	14754 <ble_hs_unlock>

    if (conn == NULL) {
   1b2b2:	b917      	cbnz	r7, 1b2ba <ble_att_svr_check_security.isra.1+0x5e>
        return BLE_HS_ENOTCONN;
   1b2b4:	2007      	movs	r0, #7
   1b2b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    rc = ble_att_svr_get_sec_state(conn_handle, &sec_state);
    if (rc != 0) {
        return rc;
    }

    if (enc && !sec_state.encrypted) {
   1b2ba:	f1b8 0f00 	cmp.w	r8, #0
   1b2be:	d007      	beq.n	1b2d0 <ble_att_svr_check_security.isra.1+0x74>
   1b2c0:	07ea      	lsls	r2, r5, #31
   1b2c2:	d405      	bmi.n	1b2d0 <ble_att_svr_check_security.isra.1+0x74>
        /* XXX: Check security database; if required key present, respond with
         * insufficient encryption error code.
         */
        *out_att_err = BLE_ATT_ERR_INSUFFICIENT_AUTHEN;
   1b2c4:	2305      	movs	r3, #5
   1b2c6:	7033      	strb	r3, [r6, #0]
        return BLE_HS_ATT_ERR(*out_att_err);
   1b2c8:	f240 1005 	movw	r0, #261	; 0x105
   1b2cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    if (authen && !sec_state.authenticated) {
   1b2d0:	2c00      	cmp	r4, #0
   1b2d2:	d0e1      	beq.n	1b298 <ble_att_svr_check_security.isra.1+0x3c>
   1b2d4:	07ab      	lsls	r3, r5, #30
   1b2d6:	d5f5      	bpl.n	1b2c4 <ble_att_svr_check_security.isra.1+0x68>
   1b2d8:	e7de      	b.n	1b298 <ble_att_svr_check_security.isra.1+0x3c>

0001b2da <ble_att_svr_write>:
}

static int
ble_att_svr_write(uint16_t conn_handle, struct ble_att_svr_entry *entry,
                  struct ble_att_svr_access_ctxt *ctxt, uint8_t *out_att_err)
{
   1b2da:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b2dc:	461d      	mov	r5, r3
    uint8_t att_err;
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {
   1b2de:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b2e2:	4298      	cmp	r0, r3
}

static int
ble_att_svr_write(uint16_t conn_handle, struct ble_att_svr_entry *entry,
                  struct ble_att_svr_access_ctxt *ctxt, uint8_t *out_att_err)
{
   1b2e4:	b085      	sub	sp, #20
   1b2e6:	4606      	mov	r6, r0
   1b2e8:	460c      	mov	r4, r1
   1b2ea:	4617      	mov	r7, r2
    uint8_t att_err;
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {
   1b2ec:	d10d      	bne.n	1b30a <ble_att_svr_write+0x30>
            goto err;
        }
    }

    BLE_HS_DBG_ASSERT(entry->ha_cb != NULL);
    rc = entry->ha_cb(conn_handle, entry->ha_handle_id,
   1b2ee:	69e3      	ldr	r3, [r4, #28]
   1b2f0:	9700      	str	r7, [sp, #0]
   1b2f2:	9301      	str	r3, [sp, #4]
   1b2f4:	8ae1      	ldrh	r1, [r4, #22]
   1b2f6:	69a7      	ldr	r7, [r4, #24]
   1b2f8:	4630      	mov	r0, r6
   1b2fa:	1d22      	adds	r2, r4, #4
   1b2fc:	2302      	movs	r3, #2
   1b2fe:	47b8      	blx	r7
                      entry->ha_uuid, BLE_ATT_ACCESS_OP_WRITE, ctxt,
                      entry->ha_cb_arg);
    if (rc != 0) {
   1b300:	b1b0      	cbz	r0, 1b330 <ble_att_svr_write+0x56>
        att_err = rc;
   1b302:	f88d 000f 	strb.w	r0, [sp, #15]
        rc = BLE_HS_EAPP;
   1b306:	2009      	movs	r0, #9
        goto err;
   1b308:	e00e      	b.n	1b328 <ble_att_svr_write+0x4e>
    int rc;

    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());

    if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {
        if (!(entry->ha_flags & BLE_ATT_F_WRITE)) {
   1b30a:	7d0a      	ldrb	r2, [r1, #20]
   1b30c:	0793      	lsls	r3, r2, #30
   1b30e:	d404      	bmi.n	1b31a <ble_att_svr_write+0x40>
            att_err = BLE_ATT_ERR_WRITE_NOT_PERMITTED;
   1b310:	2303      	movs	r3, #3
   1b312:	f88d 300f 	strb.w	r3, [sp, #15]
            rc = BLE_HS_ENOTSUP;
   1b316:	2008      	movs	r0, #8
            goto err;
   1b318:	e006      	b.n	1b328 <ble_att_svr_write+0x4e>
        }

        rc = ble_att_svr_check_security(conn_handle, 0, entry, &att_err);
   1b31a:	2100      	movs	r1, #0
   1b31c:	f10d 030f 	add.w	r3, sp, #15
   1b320:	f7ff ff9c 	bl	1b25c <ble_att_svr_check_security.isra.1>
        if (rc != 0) {
   1b324:	2800      	cmp	r0, #0
   1b326:	d0e2      	beq.n	1b2ee <ble_att_svr_write+0x14>
    }

    return 0;

err:
    if (out_att_err != NULL) {
   1b328:	b115      	cbz	r5, 1b330 <ble_att_svr_write+0x56>
        *out_att_err = att_err;
   1b32a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b32e:	702b      	strb	r3, [r5, #0]
    }
    return rc;
}
   1b330:	b005      	add	sp, #20
   1b332:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b334 <ble_att_svr_read>:
static int
ble_att_svr_read(uint16_t conn_handle,
                 struct ble_att_svr_entry *entry,
                 struct ble_att_svr_access_ctxt *ctxt,
                 uint8_t *out_att_err)
{
   1b334:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b336:	b085      	sub	sp, #20
   1b338:	461f      	mov	r7, r3
    uint8_t att_err;
    int rc;

    att_err = 0;    /* Silence gcc warning. */
   1b33a:	2300      	movs	r3, #0
   1b33c:	f88d 300f 	strb.w	r3, [sp, #15]

    if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {
   1b340:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b344:	4298      	cmp	r0, r3
static int
ble_att_svr_read(uint16_t conn_handle,
                 struct ble_att_svr_entry *entry,
                 struct ble_att_svr_access_ctxt *ctxt,
                 uint8_t *out_att_err)
{
   1b346:	4605      	mov	r5, r0
   1b348:	460c      	mov	r4, r1
   1b34a:	4616      	mov	r6, r2
    uint8_t att_err;
    int rc;

    att_err = 0;    /* Silence gcc warning. */

    if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {
   1b34c:	d10b      	bne.n	1b366 <ble_att_svr_read+0x32>
    }

    /* Give the application access to the ATT flat buffer in case it needs
     * to generate the read response dynamically.
     */
    ctxt->read.buf = ble_att_get_flat_buf();
   1b34e:	f7fe fd4d 	bl	19dec <ble_att_get_flat_buf>
static uint16_t
ble_att_max_read_len(uint16_t conn_handle)
{
    uint16_t mtu;

    if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
   1b352:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b356:	429d      	cmp	r5, r3
    }

    /* Give the application access to the ATT flat buffer in case it needs
     * to generate the read response dynamically.
     */
    ctxt->read.buf = ble_att_get_flat_buf();
   1b358:	6070      	str	r0, [r6, #4]
    ctxt->read.data = ctxt->read.buf;
   1b35a:	60b0      	str	r0, [r6, #8]
static uint16_t
ble_att_max_read_len(uint16_t conn_handle)
{
    uint16_t mtu;

    if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
   1b35c:	d012      	beq.n	1b384 <ble_att_svr_read+0x50>
        /* The application is reading from itself; no MTU. */
        mtu = BLE_ATT_MTU_MAX;
    } else {
        mtu = ble_att_mtu(conn_handle);
   1b35e:	4628      	mov	r0, r5
   1b360:	f7fe fd48 	bl	19df4 <ble_att_mtu>
   1b364:	e00f      	b.n	1b386 <ble_att_svr_read+0x52>
    int rc;

    att_err = 0;    /* Silence gcc warning. */

    if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {
        if (!(entry->ha_flags & BLE_ATT_F_READ)) {
   1b366:	7d0a      	ldrb	r2, [r1, #20]
   1b368:	07d3      	lsls	r3, r2, #31
   1b36a:	d404      	bmi.n	1b376 <ble_att_svr_read+0x42>
            att_err = BLE_ATT_ERR_READ_NOT_PERMITTED;
   1b36c:	2302      	movs	r3, #2
   1b36e:	f88d 300f 	strb.w	r3, [sp, #15]
            rc = BLE_HS_ENOTSUP;
   1b372:	2008      	movs	r0, #8
            goto err;
   1b374:	e016      	b.n	1b3a4 <ble_att_svr_read+0x70>
        }

        rc = ble_att_svr_check_security(conn_handle, 1, entry, &att_err);
   1b376:	2101      	movs	r1, #1
   1b378:	f10d 030f 	add.w	r3, sp, #15
   1b37c:	f7ff ff6e 	bl	1b25c <ble_att_svr_check_security.isra.1>
        if (rc != 0) {
   1b380:	b980      	cbnz	r0, 1b3a4 <ble_att_svr_read+0x70>
   1b382:	e7e4      	b.n	1b34e <ble_att_svr_read+0x1a>
{
    uint16_t mtu;

    if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
        /* The application is reading from itself; no MTU. */
        mtu = BLE_ATT_MTU_MAX;
   1b384:	20f0      	movs	r0, #240	; 0xf0
        mtu = ble_att_mtu(conn_handle);
    }

    /* Subtract one to account for the att-read-response header. */
    BLE_HS_DBG_ASSERT(mtu > 0);
    return mtu - 1;
   1b386:	3801      	subs	r0, #1
    /* Give the application access to the ATT flat buffer in case it needs
     * to generate the read response dynamically.
     */
    ctxt->read.buf = ble_att_get_flat_buf();
    ctxt->read.data = ctxt->read.buf;
    ctxt->read.max_data_len = ble_att_max_read_len(conn_handle);
   1b388:	8070      	strh	r0, [r6, #2]

    BLE_HS_DBG_ASSERT(entry->ha_cb != NULL);
    rc = entry->ha_cb(conn_handle, entry->ha_handle_id,
   1b38a:	69e3      	ldr	r3, [r4, #28]
   1b38c:	9600      	str	r6, [sp, #0]
   1b38e:	9301      	str	r3, [sp, #4]
   1b390:	8ae1      	ldrh	r1, [r4, #22]
   1b392:	69a6      	ldr	r6, [r4, #24]
   1b394:	4628      	mov	r0, r5
   1b396:	1d22      	adds	r2, r4, #4
   1b398:	2301      	movs	r3, #1
   1b39a:	47b0      	blx	r6
                      entry->ha_uuid, BLE_ATT_ACCESS_OP_READ, ctxt,
                      entry->ha_cb_arg);
    if (rc != 0) {
   1b39c:	b130      	cbz	r0, 1b3ac <ble_att_svr_read+0x78>
        att_err = rc;
   1b39e:	f88d 000f 	strb.w	r0, [sp, #15]
        rc = BLE_HS_EAPP;
   1b3a2:	2009      	movs	r0, #9
    }

    return 0;

err:
    if (out_att_err != NULL) {
   1b3a4:	b117      	cbz	r7, 1b3ac <ble_att_svr_read+0x78>
        *out_att_err = att_err;
   1b3a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b3aa:	703b      	strb	r3, [r7, #0]
    }
    return rc;
}
   1b3ac:	b005      	add	sp, #20
   1b3ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b3b0 <ble_att_svr_register>:
 * @return 0 on success, non-zero error code on failure.
 */
int
ble_att_svr_register(const uint8_t *uuid, uint8_t flags, uint16_t *handle_id,
                     ble_att_svr_access_fn *cb, void *cb_arg)
{
   1b3b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b3b4:	4606      	mov	r6, r0
static struct ble_att_svr_entry *
ble_att_svr_entry_alloc(void)
{
    struct ble_att_svr_entry *entry;

    entry = os_memblock_get(&ble_att_svr_entry_pool);
   1b3b6:	4818      	ldr	r0, [pc, #96]	; (1b418 <ble_att_svr_register+0x68>)
 * @return 0 on success, non-zero error code on failure.
 */
int
ble_att_svr_register(const uint8_t *uuid, uint8_t flags, uint16_t *handle_id,
                     ble_att_svr_access_fn *cb, void *cb_arg)
{
   1b3b8:	4688      	mov	r8, r1
   1b3ba:	4615      	mov	r5, r2
   1b3bc:	461f      	mov	r7, r3
static struct ble_att_svr_entry *
ble_att_svr_entry_alloc(void)
{
    struct ble_att_svr_entry *entry;

    entry = os_memblock_get(&ble_att_svr_entry_pool);
   1b3be:	f7ef f81b 	bl	a3f8 <os_memblock_get>
    if (entry != NULL) {
   1b3c2:	4604      	mov	r4, r0
   1b3c4:	b310      	cbz	r0, 1b40c <ble_att_svr_register+0x5c>
        memset(entry, 0, sizeof *entry);
   1b3c6:	2220      	movs	r2, #32
   1b3c8:	2100      	movs	r1, #0
   1b3ca:	f7ed fe22 	bl	9012 <memset>
    entry = ble_att_svr_entry_alloc();
    if (entry == NULL) {
        return BLE_HS_ENOMEM;
    }

    memcpy(&entry->ha_uuid, uuid, sizeof entry->ha_uuid);
   1b3ce:	4630      	mov	r0, r6
   1b3d0:	1d23      	adds	r3, r4, #4
   1b3d2:	f106 0210 	add.w	r2, r6, #16
   1b3d6:	f850 1b04 	ldr.w	r1, [r0], #4
   1b3da:	f843 1b04 	str.w	r1, [r3], #4
   1b3de:	4290      	cmp	r0, r2
   1b3e0:	d1f9      	bne.n	1b3d6 <ble_att_svr_register+0x26>
static uint16_t
ble_att_svr_next_id(void)
{
    /* Rollover is fatal. */
    BLE_HS_DBG_ASSERT(ble_att_svr_id != UINT16_MAX);
    return ++ble_att_svr_id;
   1b3e2:	4a0e      	ldr	r2, [pc, #56]	; (1b41c <ble_att_svr_register+0x6c>)
    if (entry == NULL) {
        return BLE_HS_ENOMEM;
    }

    memcpy(&entry->ha_uuid, uuid, sizeof entry->ha_uuid);
    entry->ha_flags = flags;
   1b3e4:	f884 8014 	strb.w	r8, [r4, #20]
static uint16_t
ble_att_svr_next_id(void)
{
    /* Rollover is fatal. */
    BLE_HS_DBG_ASSERT(ble_att_svr_id != UINT16_MAX);
    return ++ble_att_svr_id;
   1b3e8:	8813      	ldrh	r3, [r2, #0]
    }

    memcpy(&entry->ha_uuid, uuid, sizeof entry->ha_uuid);
    entry->ha_flags = flags;
    entry->ha_handle_id = ble_att_svr_next_id();
    entry->ha_cb = cb;
   1b3ea:	61a7      	str	r7, [r4, #24]
static uint16_t
ble_att_svr_next_id(void)
{
    /* Rollover is fatal. */
    BLE_HS_DBG_ASSERT(ble_att_svr_id != UINT16_MAX);
    return ++ble_att_svr_id;
   1b3ec:	3301      	adds	r3, #1
   1b3ee:	b29b      	uxth	r3, r3
   1b3f0:	8013      	strh	r3, [r2, #0]

    memcpy(&entry->ha_uuid, uuid, sizeof entry->ha_uuid);
    entry->ha_flags = flags;
    entry->ha_handle_id = ble_att_svr_next_id();
    entry->ha_cb = cb;
    entry->ha_cb_arg = cb_arg;
   1b3f2:	9a06      	ldr	r2, [sp, #24]
   1b3f4:	61e2      	str	r2, [r4, #28]

    STAILQ_INSERT_TAIL(&ble_att_svr_list, entry, ha_next);
   1b3f6:	4a0a      	ldr	r2, [pc, #40]	; (1b420 <ble_att_svr_register+0x70>)
        return BLE_HS_ENOMEM;
    }

    memcpy(&entry->ha_uuid, uuid, sizeof entry->ha_uuid);
    entry->ha_flags = flags;
    entry->ha_handle_id = ble_att_svr_next_id();
   1b3f8:	82e3      	strh	r3, [r4, #22]
    entry->ha_cb = cb;
    entry->ha_cb_arg = cb_arg;

    STAILQ_INSERT_TAIL(&ble_att_svr_list, entry, ha_next);
   1b3fa:	6851      	ldr	r1, [r2, #4]
   1b3fc:	2000      	movs	r0, #0
   1b3fe:	6020      	str	r0, [r4, #0]
   1b400:	600c      	str	r4, [r1, #0]
   1b402:	6054      	str	r4, [r2, #4]

    if (handle_id != NULL) {
   1b404:	b12d      	cbz	r5, 1b412 <ble_att_svr_register+0x62>
        *handle_id = entry->ha_handle_id;
   1b406:	802b      	strh	r3, [r5, #0]
   1b408:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
    struct ble_att_svr_entry *entry;

    entry = ble_att_svr_entry_alloc();
    if (entry == NULL) {
        return BLE_HS_ENOMEM;
   1b40c:	2006      	movs	r0, #6
   1b40e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    if (handle_id != NULL) {
        *handle_id = entry->ha_handle_id;
    }

    return 0;
   1b412:	4628      	mov	r0, r5
}
   1b414:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1b418:	200023c0 	.word	0x200023c0
   1b41c:	200023dc 	.word	0x200023dc
   1b420:	20002400 	.word	0x20002400

0001b424 <ble_att_svr_register_uuid16>:

int
ble_att_svr_register_uuid16(uint16_t uuid16, uint8_t flags,
                            uint16_t *handle_id, ble_att_svr_access_fn *cb,
                            void *cb_arg)
{
   1b424:	b570      	push	{r4, r5, r6, lr}
   1b426:	b086      	sub	sp, #24
   1b428:	460e      	mov	r6, r1
    uint8_t uuid128[16];
    int rc;

    rc = ble_uuid_16_to_128(uuid16, uuid128);
   1b42a:	a902      	add	r1, sp, #8

int
ble_att_svr_register_uuid16(uint16_t uuid16, uint8_t flags,
                            uint16_t *handle_id, ble_att_svr_access_fn *cb,
                            void *cb_arg)
{
   1b42c:	4615      	mov	r5, r2
   1b42e:	461c      	mov	r4, r3
    uint8_t uuid128[16];
    int rc;

    rc = ble_uuid_16_to_128(uuid16, uuid128);
   1b430:	f7fd f848 	bl	184c4 <ble_uuid_16_to_128>
    if (rc != 0) {
   1b434:	b938      	cbnz	r0, 1b446 <ble_att_svr_register_uuid16+0x22>
        return rc;
    }

    rc = ble_att_svr_register(uuid128, flags, handle_id, cb, cb_arg);
   1b436:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b438:	9300      	str	r3, [sp, #0]
   1b43a:	a802      	add	r0, sp, #8
   1b43c:	4631      	mov	r1, r6
   1b43e:	462a      	mov	r2, r5
   1b440:	4623      	mov	r3, r4
   1b442:	f7ff ffb5 	bl	1b3b0 <ble_att_svr_register>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1b446:	b006      	add	sp, #24
   1b448:	bd70      	pop	{r4, r5, r6, pc}
	...

0001b44c <ble_att_svr_prev_handle>:

uint16_t
ble_att_svr_prev_handle(void)
{
    return ble_att_svr_id;
}
   1b44c:	4b01      	ldr	r3, [pc, #4]	; (1b454 <ble_att_svr_prev_handle+0x8>)
   1b44e:	8818      	ldrh	r0, [r3, #0]
   1b450:	4770      	bx	lr
   1b452:	bf00      	nop
   1b454:	200023dc 	.word	0x200023dc

0001b458 <ble_att_svr_find_by_handle>:
struct ble_att_svr_entry *
ble_att_svr_find_by_handle(uint16_t handle_id)
{
    struct ble_att_svr_entry *entry;

    for (entry = STAILQ_FIRST(&ble_att_svr_list);
   1b458:	4b03      	ldr	r3, [pc, #12]	; (1b468 <ble_att_svr_find_by_handle+0x10>)
         entry != NULL;
         entry = STAILQ_NEXT(entry, ha_next)) {
   1b45a:	681b      	ldr	r3, [r3, #0]
struct ble_att_svr_entry *
ble_att_svr_find_by_handle(uint16_t handle_id)
{
    struct ble_att_svr_entry *entry;

    for (entry = STAILQ_FIRST(&ble_att_svr_list);
   1b45c:	b113      	cbz	r3, 1b464 <ble_att_svr_find_by_handle+0xc>
         entry != NULL;
         entry = STAILQ_NEXT(entry, ha_next)) {

        if (entry->ha_handle_id == handle_id) {
   1b45e:	8ada      	ldrh	r2, [r3, #22]
   1b460:	4282      	cmp	r2, r0
   1b462:	d1fa      	bne.n	1b45a <ble_att_svr_find_by_handle+0x2>
            return entry;
        }
    }

    return NULL;
}
   1b464:	4618      	mov	r0, r3
   1b466:	4770      	bx	lr
   1b468:	20002400 	.word	0x20002400

0001b46c <ble_att_svr_write_handle>:

static int
ble_att_svr_write_handle(uint16_t conn_handle, uint16_t attr_handle,
                         struct ble_att_svr_access_ctxt *ctxt,
                         uint8_t *out_att_err)
{
   1b46c:	b570      	push	{r4, r5, r6, lr}
   1b46e:	4606      	mov	r6, r0
    struct ble_att_svr_entry *entry;
    int rc;

    entry = ble_att_svr_find_by_handle(attr_handle);
   1b470:	4608      	mov	r0, r1

static int
ble_att_svr_write_handle(uint16_t conn_handle, uint16_t attr_handle,
                         struct ble_att_svr_access_ctxt *ctxt,
                         uint8_t *out_att_err)
{
   1b472:	4615      	mov	r5, r2
   1b474:	461c      	mov	r4, r3
    struct ble_att_svr_entry *entry;
    int rc;

    entry = ble_att_svr_find_by_handle(attr_handle);
   1b476:	f7ff ffef 	bl	1b458 <ble_att_svr_find_by_handle>
    if (entry == NULL) {
   1b47a:	4601      	mov	r1, r0
   1b47c:	b130      	cbz	r0, 1b48c <ble_att_svr_write_handle+0x20>
        *out_att_err = BLE_ATT_ERR_INVALID_HANDLE;
        return BLE_HS_ENOENT;
    }

    rc = ble_att_svr_write(conn_handle, entry, ctxt, out_att_err);
   1b47e:	4630      	mov	r0, r6
   1b480:	462a      	mov	r2, r5
   1b482:	4623      	mov	r3, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1b484:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if (entry == NULL) {
        *out_att_err = BLE_ATT_ERR_INVALID_HANDLE;
        return BLE_HS_ENOENT;
    }

    rc = ble_att_svr_write(conn_handle, entry, ctxt, out_att_err);
   1b488:	f7ff bf27 	b.w	1b2da <ble_att_svr_write>
    struct ble_att_svr_entry *entry;
    int rc;

    entry = ble_att_svr_find_by_handle(attr_handle);
    if (entry == NULL) {
        *out_att_err = BLE_ATT_ERR_INVALID_HANDLE;
   1b48c:	2301      	movs	r3, #1
   1b48e:	7023      	strb	r3, [r4, #0]
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1b490:	2005      	movs	r0, #5
   1b492:	bd70      	pop	{r4, r5, r6, pc}

0001b494 <ble_att_svr_find_by_uuid>:
 * @return                      0 on success; BLE_HS_ENOENT on not found.
 */
struct ble_att_svr_entry *
ble_att_svr_find_by_uuid(struct ble_att_svr_entry *prev, const uint8_t *uuid,
                         uint16_t end_handle)
{
   1b494:	b570      	push	{r4, r5, r6, lr}
   1b496:	460e      	mov	r6, r1
   1b498:	4615      	mov	r5, r2
    struct ble_att_svr_entry *entry;

    if (prev == NULL) {
   1b49a:	b910      	cbnz	r0, 1b4a2 <ble_att_svr_find_by_uuid+0xe>
        entry = STAILQ_FIRST(&ble_att_svr_list);
   1b49c:	4b0a      	ldr	r3, [pc, #40]	; (1b4c8 <ble_att_svr_find_by_uuid+0x34>)
   1b49e:	681c      	ldr	r4, [r3, #0]
   1b4a0:	e00b      	b.n	1b4ba <ble_att_svr_find_by_uuid+0x26>
    } else {
        entry = STAILQ_NEXT(prev, ha_next);
   1b4a2:	6804      	ldr	r4, [r0, #0]
   1b4a4:	e009      	b.n	1b4ba <ble_att_svr_find_by_uuid+0x26>
    }

    for (;
         entry != NULL && entry->ha_handle_id <= end_handle;
   1b4a6:	8ae3      	ldrh	r3, [r4, #22]
   1b4a8:	42ab      	cmp	r3, r5
   1b4aa:	d808      	bhi.n	1b4be <ble_att_svr_find_by_uuid+0x2a>
         entry = STAILQ_NEXT(entry, ha_next)) {

        if (memcmp(entry->ha_uuid, uuid, sizeof entry->ha_uuid) == 0) {
   1b4ac:	1d20      	adds	r0, r4, #4
   1b4ae:	4631      	mov	r1, r6
   1b4b0:	2210      	movs	r2, #16
   1b4b2:	f7ed fd95 	bl	8fe0 <memcmp>
   1b4b6:	b120      	cbz	r0, 1b4c2 <ble_att_svr_find_by_uuid+0x2e>
        entry = STAILQ_NEXT(prev, ha_next);
    }

    for (;
         entry != NULL && entry->ha_handle_id <= end_handle;
         entry = STAILQ_NEXT(entry, ha_next)) {
   1b4b8:	6824      	ldr	r4, [r4, #0]
        entry = STAILQ_FIRST(&ble_att_svr_list);
    } else {
        entry = STAILQ_NEXT(prev, ha_next);
    }

    for (;
   1b4ba:	2c00      	cmp	r4, #0
   1b4bc:	d1f3      	bne.n	1b4a6 <ble_att_svr_find_by_uuid+0x12>
        if (memcmp(entry->ha_uuid, uuid, sizeof entry->ha_uuid) == 0) {
            return entry;
        }
    }

    return NULL;
   1b4be:	2000      	movs	r0, #0
   1b4c0:	bd70      	pop	{r4, r5, r6, pc}
   1b4c2:	4620      	mov	r0, r4
   1b4c4:	bd70      	pop	{r4, r5, r6, pc}
   1b4c6:	bf00      	nop
   1b4c8:	20002400 	.word	0x20002400

0001b4cc <ble_att_svr_read_handle>:

int
ble_att_svr_read_handle(uint16_t conn_handle, uint16_t attr_handle,
                        struct ble_att_svr_access_ctxt *ctxt,
                        uint8_t *out_att_err)
{
   1b4cc:	b570      	push	{r4, r5, r6, lr}
   1b4ce:	4606      	mov	r6, r0
    struct ble_att_svr_entry *entry;
    int rc;

    entry = ble_att_svr_find_by_handle(attr_handle);
   1b4d0:	4608      	mov	r0, r1

int
ble_att_svr_read_handle(uint16_t conn_handle, uint16_t attr_handle,
                        struct ble_att_svr_access_ctxt *ctxt,
                        uint8_t *out_att_err)
{
   1b4d2:	4615      	mov	r5, r2
   1b4d4:	461c      	mov	r4, r3
    struct ble_att_svr_entry *entry;
    int rc;

    entry = ble_att_svr_find_by_handle(attr_handle);
   1b4d6:	f7ff ffbf 	bl	1b458 <ble_att_svr_find_by_handle>
    if (entry == NULL) {
   1b4da:	4601      	mov	r1, r0
   1b4dc:	b918      	cbnz	r0, 1b4e6 <ble_att_svr_read_handle+0x1a>
        if (out_att_err != NULL) {
   1b4de:	b14c      	cbz	r4, 1b4f4 <ble_att_svr_read_handle+0x28>
            *out_att_err = BLE_ATT_ERR_INVALID_HANDLE;
   1b4e0:	2301      	movs	r3, #1
   1b4e2:	7023      	strb	r3, [r4, #0]
   1b4e4:	e006      	b.n	1b4f4 <ble_att_svr_read_handle+0x28>
        }
        return BLE_HS_ENOENT;
    }

    rc = ble_att_svr_read(conn_handle, entry, ctxt, out_att_err);
   1b4e6:	4630      	mov	r0, r6
   1b4e8:	462a      	mov	r2, r5
   1b4ea:	4623      	mov	r3, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1b4ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            *out_att_err = BLE_ATT_ERR_INVALID_HANDLE;
        }
        return BLE_HS_ENOENT;
    }

    rc = ble_att_svr_read(conn_handle, entry, ctxt, out_att_err);
   1b4f0:	f7ff bf20 	b.w	1b334 <ble_att_svr_read>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1b4f4:	2005      	movs	r0, #5
   1b4f6:	bd70      	pop	{r4, r5, r6, pc}

0001b4f8 <ble_att_svr_rx_mtu>:
    return rc;
}

int
ble_att_svr_rx_mtu(uint16_t conn_handle, struct os_mbuf **om)
{
   1b4f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1b4fc:	b089      	sub	sp, #36	; 0x24
   1b4fe:	4605      	mov	r5, r0
   1b500:	460e      	mov	r6, r1
    uint8_t att_err;
    int rc;

    txom = NULL;

    rc = ble_att_svr_pullup_req_base(om, BLE_ATT_MTU_CMD_SZ, &att_err);
   1b502:	4608      	mov	r0, r1
   1b504:	f10d 0213 	add.w	r2, sp, #19
   1b508:	2103      	movs	r1, #3
   1b50a:	f7ff fdb0 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1b50e:	4604      	mov	r4, r0
   1b510:	2800      	cmp	r0, #0
   1b512:	d157      	bne.n	1b5c4 <ble_att_svr_rx_mtu+0xcc>
        goto done;
    }

    ble_att_mtu_cmd_parse((*om)->om_data, (*om)->om_len, &cmd);
   1b514:	6833      	ldr	r3, [r6, #0]
    BLE_ATT_LOG_CMD(0, "mtu req", conn_handle, ble_att_mtu_cmd_log, &cmd);
   1b516:	4e3f      	ldr	r6, [pc, #252]	; (1b614 <ble_att_svr_rx_mtu+0x11c>)
    rc = ble_att_svr_pullup_req_base(om, BLE_ATT_MTU_CMD_SZ, &att_err);
    if (rc != 0) {
        goto done;
    }

    ble_att_mtu_cmd_parse((*om)->om_data, (*om)->om_len, &cmd);
   1b518:	6818      	ldr	r0, [r3, #0]
   1b51a:	88d9      	ldrh	r1, [r3, #6]
   1b51c:	aa05      	add	r2, sp, #20
   1b51e:	f7ff fbd7 	bl	1acd0 <ble_att_mtu_cmd_parse>
    BLE_ATT_LOG_CMD(0, "mtu req", conn_handle, ble_att_mtu_cmd_log, &cmd);
   1b522:	4b3d      	ldr	r3, [pc, #244]	; (1b618 <ble_att_svr_rx_mtu+0x120>)
   1b524:	9300      	str	r3, [sp, #0]
   1b526:	4b3d      	ldr	r3, [pc, #244]	; (1b61c <ble_att_svr_rx_mtu+0x124>)
   1b528:	9302      	str	r3, [sp, #8]
   1b52a:	4622      	mov	r2, r4
   1b52c:	2104      	movs	r1, #4
   1b52e:	4b3c      	ldr	r3, [pc, #240]	; (1b620 <ble_att_svr_rx_mtu+0x128>)
   1b530:	483c      	ldr	r0, [pc, #240]	; (1b624 <ble_att_svr_rx_mtu+0x12c>)
   1b532:	9601      	str	r6, [sp, #4]
   1b534:	9503      	str	r5, [sp, #12]
   1b536:	f001 fe77 	bl	1d228 <log_printf>
   1b53a:	a805      	add	r0, sp, #20
   1b53c:	f7ff fbd2 	bl	1ace4 <ble_att_mtu_cmd_log>
   1b540:	4622      	mov	r2, r4
   1b542:	4838      	ldr	r0, [pc, #224]	; (1b624 <ble_att_svr_rx_mtu+0x12c>)
   1b544:	4b38      	ldr	r3, [pc, #224]	; (1b628 <ble_att_svr_rx_mtu+0x130>)
   1b546:	2104      	movs	r1, #4
   1b548:	f001 fe6e 	bl	1d228 <log_printf>
    struct os_mbuf *txom;
    uint16_t mtu;
    void *dst;
    int rc;

    *att_err = 0; /* Silence unnecessary warning. */
   1b54c:	f88d 4013 	strb.w	r4, [sp, #19]
    txom = NULL;

    ble_hs_lock();
   1b550:	f7f9 f8f8 	bl	14744 <ble_hs_lock>
    rc = ble_att_conn_chan_find(conn_handle, NULL, &chan);
   1b554:	4621      	mov	r1, r4
   1b556:	4628      	mov	r0, r5
   1b558:	aa07      	add	r2, sp, #28
   1b55a:	f7fe fb41 	bl	19be0 <ble_att_conn_chan_find>
   1b55e:	4637      	mov	r7, r6
    if (rc == 0) {
   1b560:	4604      	mov	r4, r0
   1b562:	b910      	cbnz	r0, 1b56a <ble_att_svr_rx_mtu+0x72>
        mtu = chan->blc_my_mtu;
   1b564:	9b07      	ldr	r3, [sp, #28]
   1b566:	f8b3 9006 	ldrh.w	r9, [r3, #6]
    }
    ble_hs_unlock();
   1b56a:	f7f9 f8f3 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   1b56e:	bb4c      	cbnz	r4, 1b5c4 <ble_att_svr_rx_mtu+0xcc>
        goto done;
    }

    txom = ble_hs_misc_pkthdr();
   1b570:	f7f9 ffd0 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1b574:	4680      	mov	r8, r0
   1b576:	b118      	cbz	r0, 1b580 <ble_att_svr_rx_mtu+0x88>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    dst = os_mbuf_extend(txom, BLE_ATT_MTU_CMD_SZ);
   1b578:	2103      	movs	r1, #3
   1b57a:	f7ee fe79 	bl	a270 <os_mbuf_extend>
    if (dst == NULL) {
   1b57e:	b920      	cbnz	r0, 1b58a <ble_att_svr_rx_mtu+0x92>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1b580:	2311      	movs	r3, #17
   1b582:	f88d 3013 	strb.w	r3, [sp, #19]
        rc = BLE_HS_ENOMEM;
   1b586:	2406      	movs	r4, #6
   1b588:	e01e      	b.n	1b5c8 <ble_att_svr_rx_mtu+0xd0>
        goto done;
    }

    cmd.bamc_mtu = mtu;
   1b58a:	ae08      	add	r6, sp, #32

    ble_att_mtu_rsp_write(dst, BLE_ATT_MTU_CMD_SZ, &cmd);
   1b58c:	2103      	movs	r1, #3
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    cmd.bamc_mtu = mtu;
   1b58e:	f826 9d08 	strh.w	r9, [r6, #-8]!

    ble_att_mtu_rsp_write(dst, BLE_ATT_MTU_CMD_SZ, &cmd);
   1b592:	4632      	mov	r2, r6
   1b594:	f7ff fba0 	bl	1acd8 <ble_att_mtu_rsp_write>
    BLE_ATT_LOG_CMD(1, "mtu rsp", conn_handle, ble_att_mtu_cmd_log, &cmd);
   1b598:	4b24      	ldr	r3, [pc, #144]	; (1b62c <ble_att_svr_rx_mtu+0x134>)
   1b59a:	9503      	str	r5, [sp, #12]
   1b59c:	e88d 0088 	stmia.w	sp, {r3, r7}
   1b5a0:	4b23      	ldr	r3, [pc, #140]	; (1b630 <ble_att_svr_rx_mtu+0x138>)
   1b5a2:	9302      	str	r3, [sp, #8]
   1b5a4:	4622      	mov	r2, r4
   1b5a6:	2104      	movs	r1, #4
   1b5a8:	4b1d      	ldr	r3, [pc, #116]	; (1b620 <ble_att_svr_rx_mtu+0x128>)
   1b5aa:	481e      	ldr	r0, [pc, #120]	; (1b624 <ble_att_svr_rx_mtu+0x12c>)
   1b5ac:	f001 fe3c 	bl	1d228 <log_printf>
   1b5b0:	4630      	mov	r0, r6
   1b5b2:	f7ff fb97 	bl	1ace4 <ble_att_mtu_cmd_log>
   1b5b6:	481b      	ldr	r0, [pc, #108]	; (1b624 <ble_att_svr_rx_mtu+0x12c>)
   1b5b8:	4b1b      	ldr	r3, [pc, #108]	; (1b628 <ble_att_svr_rx_mtu+0x130>)
   1b5ba:	2104      	movs	r1, #4
   1b5bc:	4622      	mov	r2, r4
   1b5be:	f001 fe33 	bl	1d228 <log_printf>
   1b5c2:	e001      	b.n	1b5c8 <ble_att_svr_rx_mtu+0xd0>
    struct ble_hs_conn *conn;
    struct os_mbuf *txom;
    uint8_t att_err;
    int rc;

    txom = NULL;
   1b5c4:	f04f 0800 	mov.w	r8, #0
    }

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_MTU_REQ,
   1b5c8:	f89d 3013 	ldrb.w	r3, [sp, #19]
   1b5cc:	9300      	str	r3, [sp, #0]
   1b5ce:	2300      	movs	r3, #0
   1b5d0:	9301      	str	r3, [sp, #4]
   1b5d2:	4621      	mov	r1, r4
   1b5d4:	4628      	mov	r0, r5
   1b5d6:	4642      	mov	r2, r8
   1b5d8:	2302      	movs	r3, #2
   1b5da:	f7ff fd53 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, 0);
    if (rc == 0) {
   1b5de:	4604      	mov	r4, r0
   1b5e0:	b998      	cbnz	r0, 1b60a <ble_att_svr_rx_mtu+0x112>
        ble_hs_lock();
   1b5e2:	f7f9 f8af 	bl	14744 <ble_hs_lock>
        ble_att_conn_chan_find(conn_handle, &conn, &chan);
   1b5e6:	4628      	mov	r0, r5
   1b5e8:	a907      	add	r1, sp, #28
   1b5ea:	aa06      	add	r2, sp, #24
   1b5ec:	f7fe faf8 	bl	19be0 <ble_att_conn_chan_find>
        if (chan != NULL) {
   1b5f0:	9806      	ldr	r0, [sp, #24]
   1b5f2:	b140      	cbz	r0, 1b606 <ble_att_svr_rx_mtu+0x10e>
            ble_att_set_peer_mtu(chan, cmd.bamc_mtu);
   1b5f4:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1b5f8:	f7fe fc0f 	bl	19e1a <ble_att_set_peer_mtu>
            chan->blc_flags |= BLE_L2CAP_CHAN_F_TXED_MTU;
   1b5fc:	9a06      	ldr	r2, [sp, #24]
   1b5fe:	7b13      	ldrb	r3, [r2, #12]
   1b600:	f043 0301 	orr.w	r3, r3, #1
   1b604:	7313      	strb	r3, [r2, #12]
        }
        ble_hs_unlock();
   1b606:	f7f9 f8a5 	bl	14754 <ble_hs_unlock>
    }
    return rc;
}
   1b60a:	4620      	mov	r0, r4
   1b60c:	b009      	add	sp, #36	; 0x24
   1b60e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1b612:	bf00      	nop
   1b614:	000207e0 	.word	0x000207e0
   1b618:	0001fbda 	.word	0x0001fbda
   1b61c:	000207ee 	.word	0x000207ee
   1b620:	0001fbbc 	.word	0x0001fbbc
   1b624:	20003b9c 	.word	0x20003b9c
   1b628:	0001fdec 	.word	0x0001fdec
   1b62c:	0001fe60 	.word	0x0001fe60
   1b630:	000207f6 	.word	0x000207f6

0001b634 <ble_att_svr_rx_find_info>:
    return rc;
}

int
ble_att_svr_rx_find_info(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1b634:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b638:	b089      	sub	sp, #36	; 0x24
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
   1b63a:	aa08      	add	r2, sp, #32
   1b63c:	2500      	movs	r5, #0
    return rc;
}

int
ble_att_svr_rx_find_info(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1b63e:	4680      	mov	r8, r0
   1b640:	460e      	mov	r6, r1
    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_FIND_INFO_REQ_SZ, &att_err);
   1b642:	4608      	mov	r0, r1
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
   1b644:	f802 5d05 	strb.w	r5, [r2, #-5]!
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_FIND_INFO_REQ_SZ, &att_err);
   1b648:	2105      	movs	r1, #5
   1b64a:	f7ff fd10 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1b64e:	4604      	mov	r4, r0
   1b650:	2800      	cmp	r0, #0
   1b652:	f040 80ae 	bne.w	1b7b2 <ble_att_svr_rx_find_info+0x17e>
        err_handle = 0;
        goto done;
    }

    ble_att_find_info_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1b656:	6833      	ldr	r3, [r6, #0]
    BLE_ATT_LOG_CMD(0, "find info req", conn_handle, ble_att_find_info_req_log,
   1b658:	4e5f      	ldr	r6, [pc, #380]	; (1b7d8 <ble_att_svr_rx_find_info+0x1a4>)
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_find_info_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1b65a:	6818      	ldr	r0, [r3, #0]
   1b65c:	88d9      	ldrh	r1, [r3, #6]
   1b65e:	aa07      	add	r2, sp, #28
   1b660:	f7ff fb50 	bl	1ad04 <ble_att_find_info_req_parse>
    BLE_ATT_LOG_CMD(0, "find info req", conn_handle, ble_att_find_info_req_log,
   1b664:	4b5d      	ldr	r3, [pc, #372]	; (1b7dc <ble_att_svr_rx_find_info+0x1a8>)
   1b666:	9300      	str	r3, [sp, #0]
   1b668:	4b5d      	ldr	r3, [pc, #372]	; (1b7e0 <ble_att_svr_rx_find_info+0x1ac>)
   1b66a:	9302      	str	r3, [sp, #8]
   1b66c:	2104      	movs	r1, #4
   1b66e:	4622      	mov	r2, r4
   1b670:	4b5c      	ldr	r3, [pc, #368]	; (1b7e4 <ble_att_svr_rx_find_info+0x1b0>)
   1b672:	485d      	ldr	r0, [pc, #372]	; (1b7e8 <ble_att_svr_rx_find_info+0x1b4>)
   1b674:	9601      	str	r6, [sp, #4]
   1b676:	f8cd 800c 	str.w	r8, [sp, #12]
   1b67a:	f001 fdd5 	bl	1d228 <log_printf>
   1b67e:	a807      	add	r0, sp, #28
   1b680:	f7ff fb50 	bl	1ad24 <ble_att_find_info_req_log>
   1b684:	4622      	mov	r2, r4
   1b686:	4b59      	ldr	r3, [pc, #356]	; (1b7ec <ble_att_svr_rx_find_info+0x1b8>)
   1b688:	4857      	ldr	r0, [pc, #348]	; (1b7e8 <ble_att_svr_rx_find_info+0x1b4>)
   1b68a:	2104      	movs	r1, #4
   1b68c:	f001 fdcc 	bl	1d228 <log_printf>
                    &req);

    /* Tx error response if start handle is greater than end handle or is equal
     * to 0 (Vol. 3, Part F, 3.4.3.1).
     */
    if (req.bafq_start_handle > req.bafq_end_handle ||
   1b690:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   1b694:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   1b698:	429a      	cmp	r2, r3
   1b69a:	d300      	bcc.n	1b69e <ble_att_svr_rx_find_info+0x6a>
   1b69c:	b92b      	cbnz	r3, 1b6aa <ble_att_svr_rx_find_info+0x76>
        req.bafq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
   1b69e:	2201      	movs	r2, #1
   1b6a0:	f88d 201b 	strb.w	r2, [sp, #27]
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1b6a4:	2500      	movs	r5, #0
    if (req.bafq_start_handle > req.bafq_end_handle ||
        req.bafq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
        err_handle = req.bafq_start_handle;
        rc = BLE_HS_EBADDATA;
   1b6a6:	240a      	movs	r4, #10
        goto done;
   1b6a8:	e084      	b.n	1b7b4 <ble_att_svr_rx_find_info+0x180>
    void *buf;
    int rc;

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
   1b6aa:	4640      	mov	r0, r8
   1b6ac:	f7fe fba2 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   1b6b0:	4682      	mov	sl, r0
   1b6b2:	2800      	cmp	r0, #0
   1b6b4:	d078      	beq.n	1b7a8 <ble_att_svr_rx_find_info+0x174>
        rc = BLE_HS_ENOTCONN;
        goto done;
    }

    txom = ble_hs_misc_pkthdr();
   1b6b6:	f7f9 ff2d 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1b6ba:	4605      	mov	r5, r0
   1b6bc:	b118      	cbz	r0, 1b6c6 <ble_att_svr_rx_find_info+0x92>
    }

    /* Write the response base at the start of the buffer.  The format field is
     * unknown at this point; it will be filled in later.
     */
    buf = os_mbuf_extend(txom, BLE_ATT_FIND_INFO_RSP_BASE_SZ);
   1b6be:	2102      	movs	r1, #2
   1b6c0:	f7ee fdd6 	bl	a270 <os_mbuf_extend>
    if (buf == NULL) {
   1b6c4:	b920      	cbnz	r0, 1b6d0 <ble_att_svr_rx_find_info+0x9c>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1b6c6:	2311      	movs	r3, #17
   1b6c8:	f88d 301b 	strb.w	r3, [sp, #27]
        rc = BLE_HS_ENOMEM;
   1b6cc:	2406      	movs	r4, #6
   1b6ce:	e06d      	b.n	1b7ac <ble_att_svr_rx_find_info+0x178>
        goto done;
    }

    ble_att_find_info_rsp_write(buf, BLE_ATT_FIND_INFO_RSP_BASE_SZ, &rsp);
   1b6d0:	2102      	movs	r1, #2
   1b6d2:	aa06      	add	r2, sp, #24
   1b6d4:	f7ff fb3b 	bl	1ad4e <ble_att_find_info_rsp_write>
    BLE_ATT_LOG_CMD(1, "find info rsp", conn_handle, ble_att_find_info_rsp_log,
   1b6d8:	4b45      	ldr	r3, [pc, #276]	; (1b7f0 <ble_att_svr_rx_find_info+0x1bc>)
   1b6da:	4843      	ldr	r0, [pc, #268]	; (1b7e8 <ble_att_svr_rx_find_info+0x1b4>)
   1b6dc:	f8cd 800c 	str.w	r8, [sp, #12]
   1b6e0:	e88d 0048 	stmia.w	sp, {r3, r6}
   1b6e4:	4b43      	ldr	r3, [pc, #268]	; (1b7f4 <ble_att_svr_rx_find_info+0x1c0>)
   1b6e6:	9302      	str	r3, [sp, #8]
   1b6e8:	2104      	movs	r1, #4
   1b6ea:	4622      	mov	r2, r4
   1b6ec:	4b3d      	ldr	r3, [pc, #244]	; (1b7e4 <ble_att_svr_rx_find_info+0x1b0>)
   1b6ee:	f001 fd9b 	bl	1d228 <log_printf>
   1b6f2:	a806      	add	r0, sp, #24
   1b6f4:	f7ff fb30 	bl	1ad58 <ble_att_find_info_rsp_log>
   1b6f8:	4b3c      	ldr	r3, [pc, #240]	; (1b7ec <ble_att_svr_rx_find_info+0x1b8>)
   1b6fa:	483b      	ldr	r0, [pc, #236]	; (1b7e8 <ble_att_svr_rx_find_info+0x1b4>)
   1b6fc:	2104      	movs	r1, #4
   1b6fe:	4622      	mov	r2, r4
   1b700:	f001 fd92 	bl	1d228 <log_printf>
                    &rsp);

    /* Write the variable length Information Data field, populating the format
     * field as appropriate.
     */
    rc = ble_att_svr_fill_info(req, txom, mtu, txom->om_data + 1);
   1b704:	682f      	ldr	r7, [r5, #0]

    *format = 0;
    num_entries = 0;
    rc = 0;

    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b706:	4b3c      	ldr	r3, [pc, #240]	; (1b7f8 <ble_att_svr_rx_find_info+0x1c4>)
    uint8_t *buf;
    int num_entries;
    int entry_sz;
    int rc;

    *format = 0;
   1b708:	707c      	strb	r4, [r7, #1]
    num_entries = 0;
    rc = 0;

    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b70a:	681e      	ldr	r6, [r3, #0]
    int num_entries;
    int entry_sz;
    int rc;

    *format = 0;
    num_entries = 0;
   1b70c:	46a1      	mov	r9, r4
    rc = 0;

    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b70e:	2e00      	cmp	r6, #0
   1b710:	d05d      	beq.n	1b7ce <ble_att_svr_rx_find_info+0x19a>
        if (ha->ha_handle_id > req->bafq_end_handle) {
   1b712:	8af3      	ldrh	r3, [r6, #22]
   1b714:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   1b718:	429a      	cmp	r2, r3
   1b71a:	d358      	bcc.n	1b7ce <ble_att_svr_rx_find_info+0x19a>
            rc = 0;
            goto done;
        }
        if (ha->ha_handle_id >= req->bafq_start_handle) {
   1b71c:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   1b720:	429a      	cmp	r2, r3
   1b722:	d83a      	bhi.n	1b79a <ble_att_svr_rx_find_info+0x166>
            uuid16 = ble_uuid_128_to_16(ha->ha_uuid);
   1b724:	f106 0b04 	add.w	fp, r6, #4
   1b728:	4658      	mov	r0, fp
   1b72a:	f7fc feb5 	bl	18498 <ble_uuid_128_to_16>
   1b72e:	787b      	ldrb	r3, [r7, #1]

            if (uuid16 != 0) {
   1b730:	9004      	str	r0, [sp, #16]
   1b732:	b138      	cbz	r0, 1b744 <ble_att_svr_rx_find_info+0x110>
                if (*format == 0) {
   1b734:	b913      	cbnz	r3, 1b73c <ble_att_svr_rx_find_info+0x108>
                    *format = BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT;
   1b736:	2301      	movs	r3, #1
   1b738:	707b      	strb	r3, [r7, #1]
   1b73a:	e001      	b.n	1b740 <ble_att_svr_rx_find_info+0x10c>
                } else if (*format != BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT) {
   1b73c:	2b01      	cmp	r3, #1
   1b73e:	d146      	bne.n	1b7ce <ble_att_svr_rx_find_info+0x19a>
                    rc = 0;
                    goto done;
                }

                entry_sz = 4;
   1b740:	2104      	movs	r1, #4
   1b742:	e006      	b.n	1b752 <ble_att_svr_rx_find_info+0x11e>
            } else {
                if (*format == 0) {
   1b744:	b913      	cbnz	r3, 1b74c <ble_att_svr_rx_find_info+0x118>
                    *format = BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT;
   1b746:	2302      	movs	r3, #2
   1b748:	707b      	strb	r3, [r7, #1]
   1b74a:	e001      	b.n	1b750 <ble_att_svr_rx_find_info+0x11c>
                } else if (*format != BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT) {
   1b74c:	2b02      	cmp	r3, #2
   1b74e:	d13e      	bne.n	1b7ce <ble_att_svr_rx_find_info+0x19a>
                    rc = 0;
                    goto done;
                }
                entry_sz = 18;
   1b750:	2112      	movs	r1, #18
            }

            if (OS_MBUF_PKTLEN(om) + entry_sz > mtu) {
   1b752:	8a2b      	ldrh	r3, [r5, #16]
   1b754:	440b      	add	r3, r1
   1b756:	4553      	cmp	r3, sl
   1b758:	dc39      	bgt.n	1b7ce <ble_att_svr_rx_find_info+0x19a>
                rc = 0;
                goto done;
            }

            buf = os_mbuf_extend(om, entry_sz);
   1b75a:	4628      	mov	r0, r5
   1b75c:	f7ee fd88 	bl	a270 <os_mbuf_extend>
            if (buf == NULL) {
   1b760:	9005      	str	r0, [sp, #20]
   1b762:	b1e0      	cbz	r0, 1b79e <ble_att_svr_rx_find_info+0x16a>
                rc = BLE_HS_ENOMEM;
                goto done;
            }

            htole16(buf + 0, ha->ha_handle_id);
   1b764:	8af1      	ldrh	r1, [r6, #22]
   1b766:	f001 fc77 	bl	1d058 <htole16>

            switch (*format) {
   1b76a:	787b      	ldrb	r3, [r7, #1]
   1b76c:	9a05      	ldr	r2, [sp, #20]
   1b76e:	2b01      	cmp	r3, #1
   1b770:	d006      	beq.n	1b780 <ble_att_svr_rx_find_info+0x14c>
   1b772:	2b02      	cmp	r3, #2
   1b774:	d10f      	bne.n	1b796 <ble_att_svr_rx_find_info+0x162>
            case BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT:
                htole16(buf + 2, uuid16);
                break;

            case BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT:
                memcpy(buf + 2, ha->ha_uuid, sizeof ha->ha_uuid);
   1b776:	465b      	mov	r3, fp
   1b778:	3202      	adds	r2, #2
   1b77a:	f10b 0110 	add.w	r1, fp, #16
   1b77e:	e004      	b.n	1b78a <ble_att_svr_rx_find_info+0x156>

            htole16(buf + 0, ha->ha_handle_id);

            switch (*format) {
            case BLE_ATT_FIND_INFO_RSP_FORMAT_16BIT:
                htole16(buf + 2, uuid16);
   1b780:	1c90      	adds	r0, r2, #2
   1b782:	9904      	ldr	r1, [sp, #16]
   1b784:	f001 fc68 	bl	1d058 <htole16>
   1b788:	e005      	b.n	1b796 <ble_att_svr_rx_find_info+0x162>
                break;

            case BLE_ATT_FIND_INFO_RSP_FORMAT_128BIT:
                memcpy(buf + 2, ha->ha_uuid, sizeof ha->ha_uuid);
   1b78a:	f853 0b04 	ldr.w	r0, [r3], #4
   1b78e:	f842 0b04 	str.w	r0, [r2], #4
   1b792:	428b      	cmp	r3, r1
   1b794:	d1f9      	bne.n	1b78a <ble_att_svr_rx_find_info+0x156>
            default:
                BLE_HS_DBG_ASSERT(0);
                break;
            }

            num_entries++;
   1b796:	f109 0901 	add.w	r9, r9, #1

    *format = 0;
    num_entries = 0;
    rc = 0;

    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b79a:	6836      	ldr	r6, [r6, #0]
   1b79c:	e7b7      	b.n	1b70e <ble_att_svr_rx_find_info+0xda>
    /* Write the variable length Information Data field, populating the format
     * field as appropriate.
     */
    rc = ble_att_svr_fill_info(req, txom, mtu, txom->om_data + 1);
    if (rc != 0) {
        *att_err = BLE_ATT_ERR_ATTR_NOT_FOUND;
   1b79e:	230a      	movs	r3, #10
   1b7a0:	f88d 301b 	strb.w	r3, [sp, #27]
        rc = BLE_HS_ENOENT;
   1b7a4:	2405      	movs	r4, #5
   1b7a6:	e001      	b.n	1b7ac <ble_att_svr_rx_find_info+0x178>

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
    if (mtu == 0) {
        rc = BLE_HS_ENOTCONN;
   1b7a8:	2407      	movs	r4, #7
    struct os_mbuf *txom;
    uint16_t mtu;
    void *buf;
    int rc;

    txom = NULL;
   1b7aa:	4605      	mov	r5, r0
        goto done;
    }

    rc = ble_att_svr_build_find_info_rsp(conn_handle, &req, &txom, &att_err);
    if (rc != 0) {
        err_handle = req.bafq_start_handle;
   1b7ac:	f8bd 301c 	ldrh.w	r3, [sp, #28]
        goto done;
   1b7b0:	e000      	b.n	1b7b4 <ble_att_svr_rx_find_info+0x180>
    att_err = 0;
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_FIND_INFO_REQ_SZ, &att_err);
    if (rc != 0) {
        err_handle = 0;
   1b7b2:	462b      	mov	r3, r5
    }

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_FIND_INFO_REQ,
   1b7b4:	f89d 201b 	ldrb.w	r2, [sp, #27]
   1b7b8:	4640      	mov	r0, r8
   1b7ba:	e88d 000c 	stmia.w	sp, {r2, r3}
   1b7be:	4621      	mov	r1, r4
   1b7c0:	462a      	mov	r2, r5
   1b7c2:	2304      	movs	r3, #4
   1b7c4:	f7ff fc5e 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);
    return rc;
}
   1b7c8:	b009      	add	sp, #36	; 0x24
   1b7ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            num_entries++;
        }
    }

done:
    if (rc == 0 && num_entries == 0) {
   1b7ce:	f1b9 0f00 	cmp.w	r9, #0
   1b7d2:	d0e4      	beq.n	1b79e <ble_att_svr_rx_find_info+0x16a>
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;
   1b7d4:	2300      	movs	r3, #0
   1b7d6:	e7ed      	b.n	1b7b4 <ble_att_svr_rx_find_info+0x180>
   1b7d8:	000207e0 	.word	0x000207e0
   1b7dc:	0001fbda 	.word	0x0001fbda
   1b7e0:	000207fe 	.word	0x000207fe
   1b7e4:	0001fbbc 	.word	0x0001fbbc
   1b7e8:	20003b9c 	.word	0x20003b9c
   1b7ec:	0001fdec 	.word	0x0001fdec
   1b7f0:	0001fe60 	.word	0x0001fe60
   1b7f4:	0002080c 	.word	0x0002080c
   1b7f8:	20002400 	.word	0x20002400

0001b7fc <ble_att_svr_rx_find_type_value>:
    return rc;
}

int
ble_att_svr_rx_find_type_value(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1b7fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b800:	b08f      	sub	sp, #60	; 0x3c
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
   1b802:	ae0e      	add	r6, sp, #56	; 0x38
   1b804:	2500      	movs	r5, #0
   1b806:	f806 5d1d 	strb.w	r5, [r6, #-29]!
    return rc;
}

int
ble_att_svr_rx_find_type_value(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1b80a:	4607      	mov	r7, r0
   1b80c:	4688      	mov	r8, r1
    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_FIND_TYPE_VALUE_REQ_BASE_SZ,
   1b80e:	4608      	mov	r0, r1
   1b810:	4632      	mov	r2, r6
   1b812:	2107      	movs	r1, #7
   1b814:	f7ff fc2b 	bl	1b06e <ble_att_svr_pullup_req_base>
                                     &att_err);
    if (rc != 0) {
   1b818:	4604      	mov	r4, r0
   1b81a:	2800      	cmp	r0, #0
   1b81c:	f040 80a2 	bne.w	1b964 <ble_att_svr_rx_find_type_value+0x168>
        err_handle = 0;
        goto done;
    }

    ble_att_find_type_value_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1b820:	f8d8 3000 	ldr.w	r3, [r8]
    BLE_ATT_LOG_CMD(0, "find type value req", conn_handle,
   1b824:	4d6e      	ldr	r5, [pc, #440]	; (1b9e0 <ble_att_svr_rx_find_type_value+0x1e4>)
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_find_type_value_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1b826:	6818      	ldr	r0, [r3, #0]
   1b828:	88d9      	ldrh	r1, [r3, #6]
   1b82a:	aa08      	add	r2, sp, #32
   1b82c:	f7ff faa4 	bl	1ad78 <ble_att_find_type_value_req_parse>
    BLE_ATT_LOG_CMD(0, "find type value req", conn_handle,
   1b830:	4b6c      	ldr	r3, [pc, #432]	; (1b9e4 <ble_att_svr_rx_find_type_value+0x1e8>)
   1b832:	9300      	str	r3, [sp, #0]
   1b834:	4b6c      	ldr	r3, [pc, #432]	; (1b9e8 <ble_att_svr_rx_find_type_value+0x1ec>)
   1b836:	9302      	str	r3, [sp, #8]
   1b838:	2104      	movs	r1, #4
   1b83a:	4622      	mov	r2, r4
   1b83c:	4b6b      	ldr	r3, [pc, #428]	; (1b9ec <ble_att_svr_rx_find_type_value+0x1f0>)
   1b83e:	486c      	ldr	r0, [pc, #432]	; (1b9f0 <ble_att_svr_rx_find_type_value+0x1f4>)
   1b840:	9501      	str	r5, [sp, #4]
   1b842:	9703      	str	r7, [sp, #12]
   1b844:	f001 fcf0 	bl	1d228 <log_printf>
   1b848:	a808      	add	r0, sp, #32
   1b84a:	f7ff faab 	bl	1ada4 <ble_att_find_type_value_req_log>
   1b84e:	4622      	mov	r2, r4
   1b850:	4b68      	ldr	r3, [pc, #416]	; (1b9f4 <ble_att_svr_rx_find_type_value+0x1f8>)
   1b852:	4867      	ldr	r0, [pc, #412]	; (1b9f0 <ble_att_svr_rx_find_type_value+0x1f4>)
   1b854:	2104      	movs	r1, #4
   1b856:	f001 fce7 	bl	1d228 <log_printf>
                    ble_att_find_type_value_req_log, &req);

    /* Tx error response if start handle is greater than end handle or is equal
     * to 0 (Vol. 3, Part F, 3.4.3.3).
     */
    if (req.bavq_start_handle > req.bavq_end_handle ||
   1b85a:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   1b85e:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
   1b862:	9505      	str	r5, [sp, #20]
   1b864:	429a      	cmp	r2, r3
   1b866:	d300      	bcc.n	1b86a <ble_att_svr_rx_find_type_value+0x6e>
   1b868:	b92b      	cbnz	r3, 1b876 <ble_att_svr_rx_find_type_value+0x7a>
        req.bavq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
   1b86a:	2201      	movs	r2, #1
   1b86c:	f88d 201b 	strb.w	r2, [sp, #27]
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1b870:	2500      	movs	r5, #0
    if (req.bavq_start_handle > req.bavq_end_handle ||
        req.bavq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
        err_handle = req.bavq_start_handle;
        rc = BLE_HS_EBADDATA;
   1b872:	240a      	movs	r4, #10
        goto done;
   1b874:	e077      	b.n	1b966 <ble_att_svr_rx_find_type_value+0x16a>
    }

    rc = ble_att_svr_build_find_type_value_rsp(conn_handle, &req, *rxom,
   1b876:	f8d8 a000 	ldr.w	sl, [r8]
    struct os_mbuf *txom;
    uint16_t mtu;
    uint8_t *buf;
    int rc;

    txom = ble_hs_misc_pkthdr();
   1b87a:	f7f9 fe4b 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1b87e:	4605      	mov	r5, r0
   1b880:	b920      	cbnz	r0, 1b88c <ble_att_svr_rx_find_type_value+0x90>
        *out_att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1b882:	2311      	movs	r3, #17
   1b884:	f88d 301b 	strb.w	r3, [sp, #27]
        rc = BLE_HS_ENOMEM;
   1b888:	2406      	movs	r4, #6
   1b88a:	e0a6      	b.n	1b9da <ble_att_svr_rx_find_type_value+0x1de>
        goto done;
    }

    /* Write the response base at the start of the buffer. */
    buf = os_mbuf_extend(txom, BLE_ATT_FIND_TYPE_VALUE_RSP_BASE_SZ);
   1b88c:	2101      	movs	r1, #1
   1b88e:	f7ee fcef 	bl	a270 <os_mbuf_extend>
    if (buf == NULL) {
   1b892:	2800      	cmp	r0, #0
   1b894:	d0f5      	beq.n	1b882 <ble_att_svr_rx_find_type_value+0x86>
        *out_att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }
    buf[0] = BLE_ATT_OP_FIND_TYPE_VALUE_RSP;
   1b896:	f04f 0b07 	mov.w	fp, #7
   1b89a:	f880 b000 	strb.w	fp, [r0]

    /* Write the variable length Information Data field. */
    mtu = ble_att_mtu(conn_handle);
   1b89e:	4638      	mov	r0, r7
   1b8a0:	f7fe faa8 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   1b8a4:	4680      	mov	r8, r0
   1b8a6:	2800      	cmp	r0, #0
   1b8a8:	f000 8096 	beq.w	1b9d8 <ble_att_svr_rx_find_type_value+0x1dc>

    /* Iterate through the attribute list, keeping track of the current
     * matching group.  For each attribute entry, determine if data needs to be
     * written to the response.
     */
    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b8ac:	4b52      	ldr	r3, [pc, #328]	; (1b9f8 <ble_att_svr_rx_find_type_value+0x1fc>)
    uint16_t prev;
    int any_entries;
    int match;
    int rc;

    first = 0;
   1b8ae:	f8ad 401c 	strh.w	r4, [sp, #28]

    /* Iterate through the attribute list, keeping track of the current
     * matching group.  For each attribute entry, determine if data needs to be
     * written to the response.
     */
    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b8b2:	f8d3 b000 	ldr.w	fp, [r3]
    int any_entries;
    int match;
    int rc;

    first = 0;
    prev = 0;
   1b8b6:	f8ad 401e 	strh.w	r4, [sp, #30]

    /* Iterate through the attribute list, keeping track of the current
     * matching group.  For each attribute entry, determine if data needs to be
     * written to the response.
     */
    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b8ba:	f1bb 0f00 	cmp.w	fp, #0
   1b8be:	d026      	beq.n	1b90e <ble_att_svr_rx_find_type_value+0x112>
        match = 0;

        if (ha->ha_handle_id > req->bavq_end_handle) {
   1b8c0:	f8bb 3016 	ldrh.w	r3, [fp, #22]
   1b8c4:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
   1b8c8:	429a      	cmp	r2, r3
   1b8ca:	d320      	bcc.n	1b90e <ble_att_svr_rx_find_type_value+0x112>
            break;
        }

        if (ha->ha_handle_id >= req->bavq_start_handle) {
   1b8cc:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   1b8d0:	429a      	cmp	r2, r3
   1b8d2:	d855      	bhi.n	1b980 <ble_att_svr_rx_find_type_value+0x184>
            /* Compare the attribute type and value to the request fields to
             * determine if this attribute matches.
             */
            uuid16 = ble_uuid_128_to_16(ha->ha_uuid);
   1b8d4:	f10b 0004 	add.w	r0, fp, #4
   1b8d8:	f7fc fdde 	bl	18498 <ble_uuid_128_to_16>
            if (uuid16 == req->bavq_attr_type) {
   1b8dc:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   1b8e0:	4283      	cmp	r3, r0
   1b8e2:	d14d      	bne.n	1b980 <ble_att_svr_rx_find_type_value+0x184>
                ctxt.read.offset = 0;
   1b8e4:	aa0e      	add	r2, sp, #56	; 0x38
   1b8e6:	2300      	movs	r3, #0
   1b8e8:	f822 3d10 	strh.w	r3, [r2, #-16]!
                rc = ble_att_svr_read(conn_handle, ha, &ctxt, out_att_err);
   1b8ec:	4638      	mov	r0, r7
   1b8ee:	4659      	mov	r1, fp
   1b8f0:	4633      	mov	r3, r6
   1b8f2:	f7ff fd1f 	bl	1b334 <ble_att_svr_read>
                if (rc != 0) {
   1b8f6:	4604      	mov	r4, r0
   1b8f8:	b9a8      	cbnz	r0, 1b926 <ble_att_svr_rx_find_type_value+0x12a>
                    goto done;
                }
                rc = os_mbuf_memcmp(rxom, BLE_ATT_FIND_TYPE_VALUE_REQ_BASE_SZ,
   1b8fa:	4650      	mov	r0, sl
   1b8fc:	2107      	movs	r1, #7
   1b8fe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1b900:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   1b904:	f7ee fc26 	bl	a154 <os_mbuf_memcmp>
                                    ctxt.read.data, ctxt.read.len);
                if (rc == 0) {
   1b908:	2800      	cmp	r0, #0
   1b90a:	d047      	beq.n	1b99c <ble_att_svr_rx_find_type_value+0x1a0>
   1b90c:	e038      	b.n	1b980 <ble_att_svr_rx_find_type_value+0x184>
    }

    /* Process one last non-matching ID in case a group was in progress when
     * the end of the attribute list was reached.
     */
    rc = ble_att_svr_fill_type_value_no_match(txom, &first, &prev, mtu,
   1b90e:	9600      	str	r6, [sp, #0]
   1b910:	4628      	mov	r0, r5
   1b912:	a907      	add	r1, sp, #28
   1b914:	f10d 021e 	add.w	r2, sp, #30
   1b918:	4643      	mov	r3, r8
   1b91a:	f7ff fc61 	bl	1b1e0 <ble_att_svr_fill_type_value_no_match>
                                              out_att_err);
    if (rc == BLE_HS_EAGAIN) {
        rc = 0;
   1b91e:	2801      	cmp	r0, #1
   1b920:	bf14      	ite	ne
   1b922:	4604      	movne	r4, r0
   1b924:	2400      	moveq	r4, #0
    }

done:
    any_entries = OS_MBUF_PKTHDR(txom)->omp_len >
   1b926:	8a2b      	ldrh	r3, [r5, #16]
                  BLE_ATT_FIND_TYPE_VALUE_RSP_BASE_SZ;
    if (rc == 0 && !any_entries) {
   1b928:	2c00      	cmp	r4, #0
   1b92a:	d156      	bne.n	1b9da <ble_att_svr_rx_find_type_value+0x1de>
   1b92c:	2b01      	cmp	r3, #1
   1b92e:	d914      	bls.n	1b95a <ble_att_svr_rx_find_type_value+0x15e>
                                     out_att_err);
    if (rc != 0) {
        goto done;
    }

    BLE_ATT_LOG_EMPTY_CMD(1, "find type value rsp", conn_handle);
   1b930:	4b32      	ldr	r3, [pc, #200]	; (1b9fc <ble_att_svr_rx_find_type_value+0x200>)
   1b932:	9300      	str	r3, [sp, #0]
   1b934:	9b05      	ldr	r3, [sp, #20]
   1b936:	9301      	str	r3, [sp, #4]
   1b938:	4b31      	ldr	r3, [pc, #196]	; (1ba00 <ble_att_svr_rx_find_type_value+0x204>)
   1b93a:	9302      	str	r3, [sp, #8]
   1b93c:	482c      	ldr	r0, [pc, #176]	; (1b9f0 <ble_att_svr_rx_find_type_value+0x1f4>)
   1b93e:	4b2b      	ldr	r3, [pc, #172]	; (1b9ec <ble_att_svr_rx_find_type_value+0x1f0>)
   1b940:	9703      	str	r7, [sp, #12]
   1b942:	2104      	movs	r1, #4
   1b944:	4622      	mov	r2, r4
   1b946:	f001 fc6f 	bl	1d228 <log_printf>
   1b94a:	4b2a      	ldr	r3, [pc, #168]	; (1b9f4 <ble_att_svr_rx_find_type_value+0x1f8>)
   1b94c:	4828      	ldr	r0, [pc, #160]	; (1b9f0 <ble_att_svr_rx_find_type_value+0x1f4>)
   1b94e:	2104      	movs	r1, #4
   1b950:	4622      	mov	r2, r4
   1b952:	f001 fc69 	bl	1d228 <log_printf>
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;
   1b956:	4623      	mov	r3, r4
   1b958:	e005      	b.n	1b966 <ble_att_svr_rx_find_type_value+0x16a>

done:
    any_entries = OS_MBUF_PKTHDR(txom)->omp_len >
                  BLE_ATT_FIND_TYPE_VALUE_RSP_BASE_SZ;
    if (rc == 0 && !any_entries) {
        *out_att_err = BLE_ATT_ERR_ATTR_NOT_FOUND;
   1b95a:	230a      	movs	r3, #10
   1b95c:	f88d 301b 	strb.w	r3, [sp, #27]
        return BLE_HS_ENOENT;
   1b960:	2405      	movs	r4, #5
   1b962:	e03a      	b.n	1b9da <ble_att_svr_rx_find_type_value+0x1de>
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_FIND_TYPE_VALUE_REQ_BASE_SZ,
                                     &att_err);
    if (rc != 0) {
        err_handle = 0;
   1b964:	462b      	mov	r3, r5
    }

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom,
   1b966:	f89d 201b 	ldrb.w	r2, [sp, #27]
   1b96a:	4638      	mov	r0, r7
   1b96c:	e88d 000c 	stmia.w	sp, {r2, r3}
   1b970:	4621      	mov	r1, r4
   1b972:	462a      	mov	r2, r5
   1b974:	2306      	movs	r3, #6
   1b976:	f7ff fb85 	bl	1b084 <ble_att_svr_tx_rsp>
                            BLE_ATT_OP_FIND_TYPE_VALUE_REQ, att_err,
                            err_handle);
    return rc;
}
   1b97a:	b00f      	add	sp, #60	; 0x3c
   1b97c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (match) {
            rc = ble_att_svr_fill_type_value_match(txom, &first, &prev,
                                                   ha->ha_handle_id, mtu,
                                                   out_att_err);
        } else {
            rc = ble_att_svr_fill_type_value_no_match(txom, &first, &prev,
   1b980:	9600      	str	r6, [sp, #0]
   1b982:	4628      	mov	r0, r5
   1b984:	a907      	add	r1, sp, #28
   1b986:	f10d 021e 	add.w	r2, sp, #30
   1b98a:	4643      	mov	r3, r8
   1b98c:	f7ff fc28 	bl	1b1e0 <ble_att_svr_fill_type_value_no_match>
   1b990:	4604      	mov	r4, r0
                                                      mtu, out_att_err);
        }

        if (rc != BLE_HS_EAGAIN) {
   1b992:	2c01      	cmp	r4, #1
   1b994:	d1c7      	bne.n	1b926 <ble_att_svr_rx_find_type_value+0x12a>

    /* Iterate through the attribute list, keeping track of the current
     * matching group.  For each attribute entry, determine if data needs to be
     * written to the response.
     */
    STAILQ_FOREACH(ha, &ble_att_svr_list, ha_next) {
   1b996:	f8db b000 	ldr.w	fp, [fp]
   1b99a:	e78e      	b.n	1b8ba <ble_att_svr_rx_find_type_value+0xbe>
    int rc;

    /* If this is the start of a group, record it as the first ID and keep
     * searching.
     */
    if (*first == 0) {
   1b99c:	f8bd 301c 	ldrh.w	r3, [sp, #28]
                }
            }
        }

        if (match) {
            rc = ble_att_svr_fill_type_value_match(txom, &first, &prev,
   1b9a0:	f8bb 9016 	ldrh.w	r9, [fp, #22]
    int rc;

    /* If this is the start of a group, record it as the first ID and keep
     * searching.
     */
    if (*first == 0) {
   1b9a4:	b913      	cbnz	r3, 1b9ac <ble_att_svr_rx_find_type_value+0x1b0>
        *first = handle_id;
   1b9a6:	f8ad 901c 	strh.w	r9, [sp, #28]
   1b9aa:	e004      	b.n	1b9b6 <ble_att_svr_rx_find_type_value+0x1ba>
        *prev = handle_id;
        return BLE_HS_EAGAIN;
    }

    /* If this is the continuation of a group, keep searching. */
    if (handle_id == *prev + 1) {
   1b9ac:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   1b9b0:	3301      	adds	r3, #1
   1b9b2:	4599      	cmp	r9, r3
   1b9b4:	d102      	bne.n	1b9bc <ble_att_svr_rx_find_type_value+0x1c0>
        *prev = handle_id;
   1b9b6:	f8ad 901e 	strh.w	r9, [sp, #30]
   1b9ba:	e7ec      	b.n	1b996 <ble_att_svr_rx_find_type_value+0x19a>

    /* Otherwise, this handle is not a part of the previous group.  Write the
     * previous group to the response, and remember this ID as the start of the
     * next group.
     */
    rc = ble_att_svr_fill_type_value_no_match(om, first, prev, mtu,
   1b9bc:	9600      	str	r6, [sp, #0]
   1b9be:	4628      	mov	r0, r5
   1b9c0:	a907      	add	r1, sp, #28
   1b9c2:	f10d 021e 	add.w	r2, sp, #30
   1b9c6:	4643      	mov	r3, r8
   1b9c8:	f7ff fc0a 	bl	1b1e0 <ble_att_svr_fill_type_value_no_match>
                                              out_att_err);
    *first = handle_id;
   1b9cc:	f8ad 901c 	strh.w	r9, [sp, #28]

    /* Otherwise, this handle is not a part of the previous group.  Write the
     * previous group to the response, and remember this ID as the start of the
     * next group.
     */
    rc = ble_att_svr_fill_type_value_no_match(om, first, prev, mtu,
   1b9d0:	4604      	mov	r4, r0
                                              out_att_err);
    *first = handle_id;
    *prev = handle_id;
   1b9d2:	f8ad 901e 	strh.w	r9, [sp, #30]
   1b9d6:	e7dc      	b.n	1b992 <ble_att_svr_rx_find_type_value+0x196>
    buf[0] = BLE_ATT_OP_FIND_TYPE_VALUE_RSP;

    /* Write the variable length Information Data field. */
    mtu = ble_att_mtu(conn_handle);
    if (mtu == 0) {
        rc = BLE_HS_ENOTCONN;
   1b9d8:	465c      	mov	r4, fp
    }

    rc = ble_att_svr_build_find_type_value_rsp(conn_handle, &req, *rxom,
                                               &txom, &att_err);
    if (rc != 0) {
        err_handle = req.bavq_start_handle;
   1b9da:	f8bd 3020 	ldrh.w	r3, [sp, #32]
        goto done;
   1b9de:	e7c2      	b.n	1b966 <ble_att_svr_rx_find_type_value+0x16a>
   1b9e0:	000207e0 	.word	0x000207e0
   1b9e4:	0001fbda 	.word	0x0001fbda
   1b9e8:	0002081a 	.word	0x0002081a
   1b9ec:	0001fbbc 	.word	0x0001fbbc
   1b9f0:	20003b9c 	.word	0x20003b9c
   1b9f4:	0001fdec 	.word	0x0001fdec
   1b9f8:	20002400 	.word	0x20002400
   1b9fc:	0001fe60 	.word	0x0001fe60
   1ba00:	0002082e 	.word	0x0002082e

0001ba04 <ble_att_svr_rx_read_type>:
    return rc;
}

int
ble_att_svr_rx_read_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1ba04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;

    pktlen = OS_MBUF_PKTLEN(*rxom);
   1ba08:	680b      	ldr	r3, [r1, #0]
    return rc;
}

int
ble_att_svr_rx_read_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1ba0a:	460e      	mov	r6, r1
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;

    pktlen = OS_MBUF_PKTLEN(*rxom);
   1ba0c:	8a19      	ldrh	r1, [r3, #16]
    if (pktlen != BLE_ATT_READ_TYPE_REQ_SZ_16 &&
   1ba0e:	2907      	cmp	r1, #7
    return rc;
}

int
ble_att_svr_rx_read_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1ba10:	b091      	sub	sp, #68	; 0x44
   1ba12:	4680      	mov	r8, r0

    /* Initialize some values in case of early error. */
    txom = NULL;

    pktlen = OS_MBUF_PKTLEN(*rxom);
    if (pktlen != BLE_ATT_READ_TYPE_REQ_SZ_16 &&
   1ba14:	d002      	beq.n	1ba1c <ble_att_svr_rx_read_type+0x18>
   1ba16:	2915      	cmp	r1, #21
   1ba18:	f040 8109 	bne.w	1bc2e <ble_att_svr_rx_read_type+0x22a>

        /* Malformed packet; discard. */
        return BLE_HS_EBADDATA;
    }

    rc = ble_att_svr_pullup_req_base(rxom, pktlen, &att_err);
   1ba1c:	4630      	mov	r0, r6
   1ba1e:	f10d 021b 	add.w	r2, sp, #27
   1ba22:	f7ff fb24 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1ba26:	4604      	mov	r4, r0
   1ba28:	2800      	cmp	r0, #0
   1ba2a:	f040 80f3 	bne.w	1bc14 <ble_att_svr_rx_read_type+0x210>
        err_handle = 0;
        goto done;
    }

    ble_att_read_type_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1ba2e:	6833      	ldr	r3, [r6, #0]
    BLE_ATT_LOG_CMD(0, "read type req", conn_handle, ble_att_read_type_req_log,
   1ba30:	4f81      	ldr	r7, [pc, #516]	; (1bc38 <ble_att_svr_rx_read_type+0x234>)
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_read_type_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1ba32:	6818      	ldr	r0, [r3, #0]
   1ba34:	88d9      	ldrh	r1, [r3, #6]
   1ba36:	aa07      	add	r2, sp, #28
   1ba38:	f7ff f9c8 	bl	1adcc <ble_att_read_type_req_parse>
    BLE_ATT_LOG_CMD(0, "read type req", conn_handle, ble_att_read_type_req_log,
   1ba3c:	4b7f      	ldr	r3, [pc, #508]	; (1bc3c <ble_att_svr_rx_read_type+0x238>)
   1ba3e:	9300      	str	r3, [sp, #0]
   1ba40:	4b7f      	ldr	r3, [pc, #508]	; (1bc40 <ble_att_svr_rx_read_type+0x23c>)
   1ba42:	9302      	str	r3, [sp, #8]
   1ba44:	2104      	movs	r1, #4
   1ba46:	4622      	mov	r2, r4
   1ba48:	4b7e      	ldr	r3, [pc, #504]	; (1bc44 <ble_att_svr_rx_read_type+0x240>)
   1ba4a:	487f      	ldr	r0, [pc, #508]	; (1bc48 <ble_att_svr_rx_read_type+0x244>)
   1ba4c:	9701      	str	r7, [sp, #4]
   1ba4e:	f8cd 800c 	str.w	r8, [sp, #12]
   1ba52:	f001 fbe9 	bl	1d228 <log_printf>
   1ba56:	a807      	add	r0, sp, #28
   1ba58:	f7ff f9c8 	bl	1adec <ble_att_read_type_req_log>
   1ba5c:	4b7b      	ldr	r3, [pc, #492]	; (1bc4c <ble_att_svr_rx_read_type+0x248>)
   1ba5e:	487a      	ldr	r0, [pc, #488]	; (1bc48 <ble_att_svr_rx_read_type+0x244>)
   1ba60:	2104      	movs	r1, #4
   1ba62:	4622      	mov	r2, r4
   1ba64:	f001 fbe0 	bl	1d228 <log_printf>
                    &req);

    if (req.batq_start_handle > req.batq_end_handle ||
   1ba68:	f8bd 501c 	ldrh.w	r5, [sp, #28]
   1ba6c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   1ba70:	9705      	str	r7, [sp, #20]
   1ba72:	42ab      	cmp	r3, r5
   1ba74:	d300      	bcc.n	1ba78 <ble_att_svr_rx_read_type+0x74>
   1ba76:	b92d      	cbnz	r5, 1ba84 <ble_att_svr_rx_read_type+0x80>
        req.batq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
   1ba78:	2301      	movs	r3, #1
   1ba7a:	f88d 301b 	strb.w	r3, [sp, #27]
    uint8_t uuid128[16];
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1ba7e:	2700      	movs	r7, #0
    if (req.batq_start_handle > req.batq_end_handle ||
        req.batq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
        err_handle = req.batq_start_handle;
        rc = BLE_HS_EBADDATA;
   1ba80:	240a      	movs	r4, #10
        goto done;
   1ba82:	e0c9      	b.n	1bc18 <ble_att_svr_rx_read_type+0x214>
    }

    switch ((*rxom)->om_len) {
   1ba84:	6833      	ldr	r3, [r6, #0]
   1ba86:	88da      	ldrh	r2, [r3, #6]
   1ba88:	2a07      	cmp	r2, #7
   1ba8a:	d006      	beq.n	1ba9a <ble_att_svr_rx_read_type+0x96>
   1ba8c:	2a15      	cmp	r2, #21
   1ba8e:	d117      	bne.n	1bac0 <ble_att_svr_rx_read_type+0xbc>
            goto done;
        }
        break;

    case BLE_ATT_READ_TYPE_REQ_SZ_128:
        memcpy(uuid128, (*rxom)->om_data + 5, 16);
   1ba90:	681a      	ldr	r2, [r3, #0]
   1ba92:	ad08      	add	r5, sp, #32
   1ba94:	1d53      	adds	r3, r2, #5
   1ba96:	3215      	adds	r2, #21
   1ba98:	e009      	b.n	1baae <ble_att_svr_rx_read_type+0xaa>
        goto done;
    }

    switch ((*rxom)->om_len) {
    case BLE_ATT_READ_TYPE_REQ_SZ_16:
        uuid16 = le16toh((*rxom)->om_data + 5);
   1ba9a:	6818      	ldr	r0, [r3, #0]
   1ba9c:	3005      	adds	r0, #5
   1ba9e:	f001 faf6 	bl	1d08e <le16toh>
        rc = ble_uuid_16_to_128(uuid16, uuid128);
   1baa2:	a908      	add	r1, sp, #32
   1baa4:	f7fc fd0e 	bl	184c4 <ble_uuid_16_to_128>
        if (rc != 0) {
   1baa8:	b188      	cbz	r0, 1bace <ble_att_svr_rx_read_type+0xca>
            att_err = BLE_ATT_ERR_ATTR_NOT_FOUND;
   1baaa:	230a      	movs	r3, #10
   1baac:	e009      	b.n	1bac2 <ble_att_svr_rx_read_type+0xbe>
            goto done;
        }
        break;

    case BLE_ATT_READ_TYPE_REQ_SZ_128:
        memcpy(uuid128, (*rxom)->om_data + 5, 16);
   1baae:	6818      	ldr	r0, [r3, #0]
   1bab0:	6859      	ldr	r1, [r3, #4]
   1bab2:	462c      	mov	r4, r5
   1bab4:	c403      	stmia	r4!, {r0, r1}
   1bab6:	3308      	adds	r3, #8
   1bab8:	4293      	cmp	r3, r2
   1baba:	4625      	mov	r5, r4
   1babc:	d1f7      	bne.n	1baae <ble_att_svr_rx_read_type+0xaa>
   1babe:	e006      	b.n	1bace <ble_att_svr_rx_read_type+0xca>
        break;

    default:
        att_err = BLE_ATT_ERR_INVALID_PDU;
   1bac0:	2304      	movs	r3, #4
        err_handle = 0;
   1bac2:	4625      	mov	r5, r4
    uint8_t uuid128[16];
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1bac4:	4627      	mov	r7, r4
    case BLE_ATT_READ_TYPE_REQ_SZ_128:
        memcpy(uuid128, (*rxom)->om_data + 5, 16);
        break;

    default:
        att_err = BLE_ATT_ERR_INVALID_PDU;
   1bac6:	f88d 301b 	strb.w	r3, [sp, #27]
        err_handle = 0;
        rc = BLE_HS_EMSGSIZE;
   1baca:	461c      	mov	r4, r3
        goto done;
   1bacc:	e0a4      	b.n	1bc18 <ble_att_svr_rx_read_type+0x214>
    int txomlen;
    int prev_attr_len;
    int attr_len;
    int rc;

    *att_err = 0;    /* Silence unnecessary warning. */
   1bace:	2600      	movs	r6, #0

    *err_handle = req->batq_start_handle;
    entry_written = 0;
    prev_attr_len = 0;

    mtu = ble_att_mtu(conn_handle);
   1bad0:	4640      	mov	r0, r8
    int txomlen;
    int prev_attr_len;
    int attr_len;
    int rc;

    *att_err = 0;    /* Silence unnecessary warning. */
   1bad2:	f88d 601b 	strb.w	r6, [sp, #27]

    *err_handle = req->batq_start_handle;
   1bad6:	f8bd 501c 	ldrh.w	r5, [sp, #28]
    entry_written = 0;
    prev_attr_len = 0;

    mtu = ble_att_mtu(conn_handle);
   1bada:	f7fe f98b 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   1bade:	4604      	mov	r4, r0
   1bae0:	2800      	cmp	r0, #0
   1bae2:	f000 8091 	beq.w	1bc08 <ble_att_svr_rx_read_type+0x204>
        return BLE_HS_ENOTCONN;
    }

    txom = ble_hs_misc_pkthdr();
   1bae6:	f7f9 fd15 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1baea:	4607      	mov	r7, r0
   1baec:	b928      	cbnz	r0, 1bafa <ble_att_svr_rx_read_type+0xf6>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1baee:	2311      	movs	r3, #17
   1baf0:	f88d 301b 	strb.w	r3, [sp, #27]
   1baf4:	2500      	movs	r5, #0
   1baf6:	2006      	movs	r0, #6
   1baf8:	e056      	b.n	1bba8 <ble_att_svr_rx_read_type+0x1a4>
    }

    /* Allocate space for the respose base, but don't fill in the fields.  They
     * get filled in at the end, when we know the value of the length field.
     */
    dptr = os_mbuf_extend(txom, BLE_ATT_READ_TYPE_RSP_BASE_SZ);
   1bafa:	2102      	movs	r1, #2
   1bafc:	f7ee fbb8 	bl	a270 <os_mbuf_extend>
    if (dptr == NULL) {
   1bb00:	2800      	cmp	r0, #0
   1bb02:	d0f4      	beq.n	1baee <ble_att_svr_rx_read_type+0xea>
   1bb04:	46b2      	mov	sl, r6
   1bb06:	46b3      	mov	fp, r6
    }

    /* Find all matching attributes, writing a record for each. */
    entry = NULL;
    while (1) {
        entry = ble_att_svr_find_by_uuid(entry, uuid128, req->batq_end_handle);
   1bb08:	4658      	mov	r0, fp
   1bb0a:	a908      	add	r1, sp, #32
   1bb0c:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   1bb10:	f7ff fcc0 	bl	1b494 <ble_att_svr_find_by_uuid>
        if (entry == NULL) {
   1bb14:	4683      	mov	fp, r0
   1bb16:	2800      	cmp	r0, #0
   1bb18:	d040      	beq.n	1bb9c <ble_att_svr_rx_read_type+0x198>
            rc = BLE_HS_ENOENT;
            break;
        }

        if (entry->ha_handle_id >= req->batq_start_handle) {
   1bb1a:	8ac2      	ldrh	r2, [r0, #22]
   1bb1c:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   1bb20:	429a      	cmp	r2, r3
   1bb22:	d3f1      	bcc.n	1bb08 <ble_att_svr_rx_read_type+0x104>
            ctxt.read.offset = 0;
   1bb24:	aa10      	add	r2, sp, #64	; 0x40
   1bb26:	2300      	movs	r3, #0
   1bb28:	f822 3d10 	strh.w	r3, [r2, #-16]!
            rc = ble_att_svr_read(conn_handle, entry, &ctxt, att_err);
   1bb2c:	4640      	mov	r0, r8
   1bb2e:	4659      	mov	r1, fp
   1bb30:	f10d 031b 	add.w	r3, sp, #27
   1bb34:	f7ff fbfe 	bl	1b334 <ble_att_svr_read>
            if (rc != 0) {
   1bb38:	b110      	cbz	r0, 1bb40 <ble_att_svr_rx_read_type+0x13c>
                *err_handle = entry->ha_handle_id;
   1bb3a:	f8bb 5016 	ldrh.w	r5, [fp, #22]
   1bb3e:	e030      	b.n	1bba2 <ble_att_svr_rx_read_type+0x19e>
                goto done;
            }

            if (ctxt.read.len > mtu - 4) {
   1bb40:	f8bd 903c 	ldrh.w	r9, [sp, #60]	; 0x3c
   1bb44:	1ee2      	subs	r2, r4, #3
   1bb46:	454a      	cmp	r2, r9
                attr_len = mtu - 4;
   1bb48:	bfd8      	it	le
   1bb4a:	f1a4 0904 	suble.w	r9, r4, #4
            } else {
                attr_len = ctxt.read.len;
            }

            if (prev_attr_len == 0) {
   1bb4e:	b10e      	cbz	r6, 1bb54 <ble_att_svr_rx_read_type+0x150>
                prev_attr_len = attr_len;
            } else if (prev_attr_len != attr_len) {
   1bb50:	454e      	cmp	r6, r9
   1bb52:	d126      	bne.n	1bba2 <ble_att_svr_rx_read_type+0x19e>
                break;
            }

            txomlen = OS_MBUF_PKTHDR(txom)->omp_len + 2 + attr_len;
   1bb54:	8a3a      	ldrh	r2, [r7, #16]
   1bb56:	3202      	adds	r2, #2
   1bb58:	444a      	add	r2, r9
            if (txomlen > mtu) {
   1bb5a:	42a2      	cmp	r2, r4
   1bb5c:	dc20      	bgt.n	1bba0 <ble_att_svr_rx_read_type+0x19c>
                break;
            }

            dptr = os_mbuf_extend(txom, 2 + attr_len);
   1bb5e:	f109 0102 	add.w	r1, r9, #2
   1bb62:	4638      	mov	r0, r7
   1bb64:	b289      	uxth	r1, r1
   1bb66:	f7ee fb83 	bl	a270 <os_mbuf_extend>
            if (dptr == NULL) {
   1bb6a:	4606      	mov	r6, r0
   1bb6c:	b948      	cbnz	r0, 1bb82 <ble_att_svr_rx_read_type+0x17e>
                *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1bb6e:	2311      	movs	r3, #17
            if (txomlen > mtu) {
                break;
            }

            dptr = os_mbuf_extend(txom, 2 + attr_len);
            if (dptr == NULL) {
   1bb70:	464e      	mov	r6, r9
                *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1bb72:	f88d 301b 	strb.w	r3, [sp, #27]
                *err_handle = entry->ha_handle_id;
   1bb76:	f8bb 5016 	ldrh.w	r5, [fp, #22]
            entry_written = 1;
        }
    }

done:
    if (!entry_written) {
   1bb7a:	f1ba 0f00 	cmp.w	sl, #0
   1bb7e:	d046      	beq.n	1bc0e <ble_att_svr_rx_read_type+0x20a>
   1bb80:	e01c      	b.n	1bbbc <ble_att_svr_rx_read_type+0x1b8>
                *err_handle = entry->ha_handle_id;
                rc = BLE_HS_ENOMEM;
                goto done;
            }

            htole16(dptr + 0, entry->ha_handle_id);
   1bb82:	f8bb 1016 	ldrh.w	r1, [fp, #22]
   1bb86:	f001 fa67 	bl	1d058 <htole16>
            memcpy(dptr + 2, ctxt.read.data, attr_len);
   1bb8a:	1cb0      	adds	r0, r6, #2
   1bb8c:	990e      	ldr	r1, [sp, #56]	; 0x38
   1bb8e:	464a      	mov	r2, r9
   1bb90:	f7ed fa34 	bl	8ffc <memcpy>
   1bb94:	464e      	mov	r6, r9
            entry_written = 1;
   1bb96:	f04f 0a01 	mov.w	sl, #1
   1bb9a:	e7b5      	b.n	1bb08 <ble_att_svr_rx_read_type+0x104>
    /* Find all matching attributes, writing a record for each. */
    entry = NULL;
    while (1) {
        entry = ble_att_svr_find_by_uuid(entry, uuid128, req->batq_end_handle);
        if (entry == NULL) {
            rc = BLE_HS_ENOENT;
   1bb9c:	2005      	movs	r0, #5
   1bb9e:	e000      	b.n	1bba2 <ble_att_svr_rx_read_type+0x19e>
            } else if (prev_attr_len != attr_len) {
                break;
            }

            txomlen = OS_MBUF_PKTHDR(txom)->omp_len + 2 + attr_len;
            if (txomlen > mtu) {
   1bba0:	464e      	mov	r6, r9
            entry_written = 1;
        }
    }

done:
    if (!entry_written) {
   1bba2:	f1ba 0f00 	cmp.w	sl, #0
   1bba6:	d109      	bne.n	1bbbc <ble_att_svr_rx_read_type+0x1b8>
        /* No matching attributes. */
        if (*att_err == 0) {
   1bba8:	f89d 301b 	ldrb.w	r3, [sp, #27]
   1bbac:	b913      	cbnz	r3, 1bbb4 <ble_att_svr_rx_read_type+0x1b0>
            *att_err = BLE_ATT_ERR_ATTR_NOT_FOUND;
   1bbae:	230a      	movs	r3, #10
   1bbb0:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        if (rc == 0) {
            rc = BLE_HS_ENOENT;
   1bbb4:	2800      	cmp	r0, #0
   1bbb6:	bf08      	it	eq
   1bbb8:	2005      	moveq	r0, #5
   1bbba:	e029      	b.n	1bc10 <ble_att_svr_rx_read_type+0x20c>
        /* Send what we can, even if an error was encountered. */
        rc = 0;
        *att_err = 0;

        /* Fill the response base. */
        rsp.batp_length = BLE_ATT_READ_TYPE_ADATA_BASE_SZ + prev_attr_len;
   1bbbc:	f10d 0a40 	add.w	sl, sp, #64	; 0x40
   1bbc0:	3602      	adds	r6, #2
            rc = BLE_HS_ENOENT;
        }
    } else {
        /* Send what we can, even if an error was encountered. */
        rc = 0;
        *att_err = 0;
   1bbc2:	2400      	movs	r4, #0

        /* Fill the response base. */
        rsp.batp_length = BLE_ATT_READ_TYPE_ADATA_BASE_SZ + prev_attr_len;
   1bbc4:	f80a 6d28 	strb.w	r6, [sl, #-40]!
            rc = BLE_HS_ENOENT;
        }
    } else {
        /* Send what we can, even if an error was encountered. */
        rc = 0;
        *att_err = 0;
   1bbc8:	f88d 401b 	strb.w	r4, [sp, #27]

        /* Fill the response base. */
        rsp.batp_length = BLE_ATT_READ_TYPE_ADATA_BASE_SZ + prev_attr_len;
        ble_att_read_type_rsp_write(txom->om_data, txom->om_len, &rsp);
   1bbcc:	6838      	ldr	r0, [r7, #0]
   1bbce:	88f9      	ldrh	r1, [r7, #6]
   1bbd0:	4652      	mov	r2, sl
   1bbd2:	f7ff f920 	bl	1ae16 <ble_att_read_type_rsp_write>
        BLE_ATT_LOG_CMD(1, "read type rsp", conn_handle,
   1bbd6:	4b1e      	ldr	r3, [pc, #120]	; (1bc50 <ble_att_svr_rx_read_type+0x24c>)
   1bbd8:	9300      	str	r3, [sp, #0]
   1bbda:	9b05      	ldr	r3, [sp, #20]
   1bbdc:	9301      	str	r3, [sp, #4]
   1bbde:	4b1d      	ldr	r3, [pc, #116]	; (1bc54 <ble_att_svr_rx_read_type+0x250>)
   1bbe0:	9302      	str	r3, [sp, #8]
   1bbe2:	2104      	movs	r1, #4
   1bbe4:	4622      	mov	r2, r4
   1bbe6:	4b17      	ldr	r3, [pc, #92]	; (1bc44 <ble_att_svr_rx_read_type+0x240>)
   1bbe8:	4817      	ldr	r0, [pc, #92]	; (1bc48 <ble_att_svr_rx_read_type+0x244>)
   1bbea:	f8cd 800c 	str.w	r8, [sp, #12]
   1bbee:	f001 fb1b 	bl	1d228 <log_printf>
   1bbf2:	4650      	mov	r0, sl
   1bbf4:	f7ff f914 	bl	1ae20 <ble_att_read_type_rsp_log>
   1bbf8:	4813      	ldr	r0, [pc, #76]	; (1bc48 <ble_att_svr_rx_read_type+0x244>)
   1bbfa:	4b14      	ldr	r3, [pc, #80]	; (1bc4c <ble_att_svr_rx_read_type+0x248>)
   1bbfc:	2104      	movs	r1, #4
   1bbfe:	4622      	mov	r2, r4
   1bc00:	f001 fb12 	bl	1d228 <log_printf>
        if (rc == 0) {
            rc = BLE_HS_ENOENT;
        }
    } else {
        /* Send what we can, even if an error was encountered. */
        rc = 0;
   1bc04:	4620      	mov	r0, r4
   1bc06:	e003      	b.n	1bc10 <ble_att_svr_rx_read_type+0x20c>
    uint8_t uuid128[16];
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1bc08:	4607      	mov	r7, r0
    entry_written = 0;
    prev_attr_len = 0;

    mtu = ble_att_mtu(conn_handle);
    if (mtu == 0) {
        return BLE_HS_ENOTCONN;
   1bc0a:	2007      	movs	r0, #7
   1bc0c:	e000      	b.n	1bc10 <ble_att_svr_rx_read_type+0x20c>

            dptr = os_mbuf_extend(txom, 2 + attr_len);
            if (dptr == NULL) {
                *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
                *err_handle = entry->ha_handle_id;
                rc = BLE_HS_ENOMEM;
   1bc0e:	2006      	movs	r0, #6
                                         &txom, &att_err, &err_handle);
    if (rc != 0) {
        goto done;
    }

    rc = 0;
   1bc10:	4604      	mov	r4, r0
   1bc12:	e001      	b.n	1bc18 <ble_att_svr_rx_read_type+0x214>
        return BLE_HS_EBADDATA;
    }

    rc = ble_att_svr_pullup_req_base(rxom, pktlen, &att_err);
    if (rc != 0) {
        err_handle = 0;
   1bc14:	2500      	movs	r5, #0
    uint8_t uuid128[16];
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1bc16:	462f      	mov	r7, r5
    }

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_READ_TYPE_REQ,
   1bc18:	f89d 301b 	ldrb.w	r3, [sp, #27]
   1bc1c:	4640      	mov	r0, r8
   1bc1e:	e88d 0028 	stmia.w	sp, {r3, r5}
   1bc22:	4621      	mov	r1, r4
   1bc24:	463a      	mov	r2, r7
   1bc26:	2308      	movs	r3, #8
   1bc28:	f7ff fa2c 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);
    return rc;
   1bc2c:	e000      	b.n	1bc30 <ble_att_svr_rx_read_type+0x22c>
    pktlen = OS_MBUF_PKTLEN(*rxom);
    if (pktlen != BLE_ATT_READ_TYPE_REQ_SZ_16 &&
        pktlen != BLE_ATT_READ_TYPE_REQ_SZ_128) {

        /* Malformed packet; discard. */
        return BLE_HS_EBADDATA;
   1bc2e:	200a      	movs	r0, #10

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_READ_TYPE_REQ,
                            att_err, err_handle);
    return rc;
}
   1bc30:	b011      	add	sp, #68	; 0x44
   1bc32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1bc36:	bf00      	nop
   1bc38:	000207e0 	.word	0x000207e0
   1bc3c:	0001fbda 	.word	0x0001fbda
   1bc40:	00020842 	.word	0x00020842
   1bc44:	0001fbbc 	.word	0x0001fbbc
   1bc48:	20003b9c 	.word	0x20003b9c
   1bc4c:	0001fdec 	.word	0x0001fdec
   1bc50:	0001fe60 	.word	0x0001fe60
   1bc54:	00020850 	.word	0x00020850

0001bc58 <ble_att_svr_rx_read>:
    return rc;
}

int
ble_att_svr_rx_read(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1bc58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1bc5c:	b08a      	sub	sp, #40	; 0x28
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
   1bc5e:	ae0a      	add	r6, sp, #40	; 0x28
   1bc60:	2500      	movs	r5, #0
   1bc62:	f806 5d16 	strb.w	r5, [r6, #-22]!
    return rc;
}

int
ble_att_svr_rx_read(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1bc66:	4607      	mov	r7, r0
   1bc68:	4688      	mov	r8, r1
    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_READ_REQ_SZ, &att_err);
   1bc6a:	4608      	mov	r0, r1
   1bc6c:	4632      	mov	r2, r6
   1bc6e:	2103      	movs	r1, #3
   1bc70:	f7ff f9fd 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1bc74:	4604      	mov	r4, r0
   1bc76:	2800      	cmp	r0, #0
   1bc78:	d169      	bne.n	1bd4e <ble_att_svr_rx_read+0xf6>
        err_handle = 0;
        goto done;
    }

    ble_att_read_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1bc7a:	f8d8 3000 	ldr.w	r3, [r8]
    BLE_ATT_LOG_CMD(0, "read req", conn_handle, ble_att_read_req_log, &req);
   1bc7e:	f8df 8108 	ldr.w	r8, [pc, #264]	; 1bd88 <ble_att_svr_rx_read+0x130>
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_read_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1bc82:	6818      	ldr	r0, [r3, #0]
   1bc84:	88d9      	ldrh	r1, [r3, #6]
   1bc86:	aa05      	add	r2, sp, #20
   1bc88:	f7ff f8da 	bl	1ae40 <ble_att_read_req_parse>
    BLE_ATT_LOG_CMD(0, "read req", conn_handle, ble_att_read_req_log, &req);
   1bc8c:	4b37      	ldr	r3, [pc, #220]	; (1bd6c <ble_att_svr_rx_read+0x114>)
   1bc8e:	9300      	str	r3, [sp, #0]
   1bc90:	4b37      	ldr	r3, [pc, #220]	; (1bd70 <ble_att_svr_rx_read+0x118>)
   1bc92:	9302      	str	r3, [sp, #8]
   1bc94:	4622      	mov	r2, r4
   1bc96:	2104      	movs	r1, #4
   1bc98:	4b36      	ldr	r3, [pc, #216]	; (1bd74 <ble_att_svr_rx_read+0x11c>)
   1bc9a:	4837      	ldr	r0, [pc, #220]	; (1bd78 <ble_att_svr_rx_read+0x120>)
   1bc9c:	f8cd 8004 	str.w	r8, [sp, #4]
   1bca0:	9703      	str	r7, [sp, #12]
   1bca2:	f001 fac1 	bl	1d228 <log_printf>
   1bca6:	a805      	add	r0, sp, #20
   1bca8:	f7ff f8d4 	bl	1ae54 <ble_att_read_req_log>
   1bcac:	4622      	mov	r2, r4
   1bcae:	4832      	ldr	r0, [pc, #200]	; (1bd78 <ble_att_svr_rx_read+0x120>)
   1bcb0:	4b32      	ldr	r3, [pc, #200]	; (1bd7c <ble_att_svr_rx_read+0x124>)
   1bcb2:	2104      	movs	r1, #4
   1bcb4:	f001 fab8 	bl	1d228 <log_printf>

    ctxt.read.offset = 0;
    rc = ble_att_svr_read_handle(conn_handle, req.barq_handle, &ctxt,
   1bcb8:	4638      	mov	r0, r7
   1bcba:	f8bd 1014 	ldrh.w	r1, [sp, #20]
    }

    ble_att_read_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
    BLE_ATT_LOG_CMD(0, "read req", conn_handle, ble_att_read_req_log, &req);

    ctxt.read.offset = 0;
   1bcbe:	f8ad 4018 	strh.w	r4, [sp, #24]
    rc = ble_att_svr_read_handle(conn_handle, req.barq_handle, &ctxt,
   1bcc2:	aa06      	add	r2, sp, #24
   1bcc4:	4633      	mov	r3, r6
   1bcc6:	f7ff fc01 	bl	1b4cc <ble_att_svr_read_handle>
                                 &att_err);
    if (rc != 0) {
   1bcca:	4604      	mov	r4, r0
   1bccc:	2800      	cmp	r0, #0
   1bcce:	d13b      	bne.n	1bd48 <ble_att_svr_rx_read+0xf0>
    uint8_t op;
    int rc;

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
   1bcd0:	4638      	mov	r0, r7
    if (rc != 0) {
        err_handle = req.barq_handle;
        goto done;
    }

    rc = ble_att_svr_build_read_rsp(conn_handle, ctxt.read.data, ctxt.read.len,
   1bcd2:	f8dd a020 	ldr.w	sl, [sp, #32]
   1bcd6:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
    uint8_t op;
    int rc;

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
   1bcda:	f7fe f88b 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   1bcde:	4606      	mov	r6, r0
   1bce0:	b380      	cbz	r0, 1bd44 <ble_att_svr_rx_read+0xec>
        rc = BLE_HS_ENOTCONN;
        goto done;
    }

    txom = ble_hs_misc_pkthdr();
   1bce2:	f7f9 fc17 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1bce6:	4605      	mov	r5, r0
   1bce8:	b1a0      	cbz	r0, 1bd14 <ble_att_svr_rx_read+0xbc>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    op = BLE_ATT_OP_READ_RSP;
   1bcea:	a90a      	add	r1, sp, #40	; 0x28
   1bcec:	230b      	movs	r3, #11
   1bcee:	f801 3d15 	strb.w	r3, [r1, #-21]!
    rc = os_mbuf_append(txom, &op, 1);
   1bcf2:	2201      	movs	r2, #1
   1bcf4:	f7ee f93c 	bl	9f70 <os_mbuf_append>
    if (rc != 0) {
   1bcf8:	b960      	cbnz	r0, 1bd14 <ble_att_svr_rx_read+0xbc>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    /* Vol. 3, part F, 3.2.9; don't send more than ATT_MTU-1 bytes of data. */
    if (attr_len > mtu - 1) {
   1bcfa:	454e      	cmp	r6, r9
        data_len = mtu - 1;
   1bcfc:	bfdc      	itt	le
   1bcfe:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
   1bd02:	fa1f f986 	uxthle.w	r9, r6
    } else {
        data_len = attr_len;
    }

    rc = os_mbuf_append(txom, attr_data, data_len);
   1bd06:	4628      	mov	r0, r5
   1bd08:	4651      	mov	r1, sl
   1bd0a:	464a      	mov	r2, r9
   1bd0c:	f7ee f930 	bl	9f70 <os_mbuf_append>
    if (rc != 0) {
   1bd10:	4606      	mov	r6, r0
   1bd12:	b120      	cbz	r0, 1bd1e <ble_att_svr_rx_read+0xc6>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1bd14:	2311      	movs	r3, #17
   1bd16:	f88d 3012 	strb.w	r3, [sp, #18]
        rc = BLE_HS_ENOMEM;
   1bd1a:	2406      	movs	r4, #6
   1bd1c:	e014      	b.n	1bd48 <ble_att_svr_rx_read+0xf0>
        goto done;
    }

    BLE_ATT_LOG_EMPTY_CMD(1, "read rsp", conn_handle);
   1bd1e:	4b18      	ldr	r3, [pc, #96]	; (1bd80 <ble_att_svr_rx_read+0x128>)
   1bd20:	9703      	str	r7, [sp, #12]
   1bd22:	e88d 0108 	stmia.w	sp, {r3, r8}
   1bd26:	4b17      	ldr	r3, [pc, #92]	; (1bd84 <ble_att_svr_rx_read+0x12c>)
   1bd28:	9302      	str	r3, [sp, #8]
   1bd2a:	4632      	mov	r2, r6
   1bd2c:	4812      	ldr	r0, [pc, #72]	; (1bd78 <ble_att_svr_rx_read+0x120>)
   1bd2e:	4b11      	ldr	r3, [pc, #68]	; (1bd74 <ble_att_svr_rx_read+0x11c>)
   1bd30:	2104      	movs	r1, #4
   1bd32:	f001 fa79 	bl	1d228 <log_printf>
   1bd36:	4810      	ldr	r0, [pc, #64]	; (1bd78 <ble_att_svr_rx_read+0x120>)
   1bd38:	4b10      	ldr	r3, [pc, #64]	; (1bd7c <ble_att_svr_rx_read+0x124>)
   1bd3a:	2104      	movs	r1, #4
   1bd3c:	4632      	mov	r2, r6
   1bd3e:	f001 fa73 	bl	1d228 <log_printf>
   1bd42:	e005      	b.n	1bd50 <ble_att_svr_rx_read+0xf8>

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
    if (mtu == 0) {
        rc = BLE_HS_ENOTCONN;
   1bd44:	2407      	movs	r4, #7
    uint16_t data_len;
    uint16_t mtu;
    uint8_t op;
    int rc;

    txom = NULL;
   1bd46:	4605      	mov	r5, r0
    }

    rc = ble_att_svr_build_read_rsp(conn_handle, ctxt.read.data, ctxt.read.len,
                                    &txom, &att_err);
    if (rc != 0) {
        err_handle = req.barq_handle;
   1bd48:	f8bd 6014 	ldrh.w	r6, [sp, #20]
        goto done;
   1bd4c:	e000      	b.n	1bd50 <ble_att_svr_rx_read+0xf8>
    att_err = 0;
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_READ_REQ_SZ, &att_err);
    if (rc != 0) {
        err_handle = 0;
   1bd4e:	462e      	mov	r6, r5
    }

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_READ_REQ,
   1bd50:	f89d 3012 	ldrb.w	r3, [sp, #18]
   1bd54:	4638      	mov	r0, r7
   1bd56:	e88d 0048 	stmia.w	sp, {r3, r6}
   1bd5a:	4621      	mov	r1, r4
   1bd5c:	462a      	mov	r2, r5
   1bd5e:	230a      	movs	r3, #10
   1bd60:	f7ff f990 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);
    return rc;
}
   1bd64:	b00a      	add	sp, #40	; 0x28
   1bd66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1bd6a:	bf00      	nop
   1bd6c:	0001fbda 	.word	0x0001fbda
   1bd70:	0002085e 	.word	0x0002085e
   1bd74:	0001fbbc 	.word	0x0001fbbc
   1bd78:	20003b9c 	.word	0x20003b9c
   1bd7c:	0001fdec 	.word	0x0001fdec
   1bd80:	0001fe60 	.word	0x0001fe60
   1bd84:	00020867 	.word	0x00020867
   1bd88:	000207e0 	.word	0x000207e0

0001bd8c <ble_att_svr_rx_read_blob>:
    return rc;
}

int
ble_att_svr_rx_read_blob(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1bd8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1bd90:	b08a      	sub	sp, #40	; 0x28
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
   1bd92:	2500      	movs	r5, #0
    return rc;
}

int
ble_att_svr_rx_read_blob(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1bd94:	4680      	mov	r8, r0
   1bd96:	460c      	mov	r4, r1
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
   1bd98:	f88d 5012 	strb.w	r5, [sp, #18]
    err_handle = 0;

    mtu = ble_att_mtu(conn_handle);
   1bd9c:	f7fe f82a 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   1bda0:	4607      	mov	r7, r0
   1bda2:	2800      	cmp	r0, #0
   1bda4:	d07c      	beq.n	1bea0 <ble_att_svr_rx_read_blob+0x114>
        rc = BLE_HS_ENOTCONN;
        goto done;
    }

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_READ_BLOB_REQ_SZ, &att_err);
   1bda6:	4620      	mov	r0, r4
   1bda8:	2105      	movs	r1, #5
   1bdaa:	f10d 0212 	add.w	r2, sp, #18
   1bdae:	f7ff f95e 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1bdb2:	4606      	mov	r6, r0
   1bdb4:	2800      	cmp	r0, #0
   1bdb6:	d175      	bne.n	1bea4 <ble_att_svr_rx_read_blob+0x118>
        err_handle = 0;
        goto done;
    }

    ble_att_read_blob_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1bdb8:	6823      	ldr	r3, [r4, #0]
    BLE_ATT_LOG_CMD(0, "read blob req", conn_handle, ble_att_read_blob_req_log,
   1bdba:	4c41      	ldr	r4, [pc, #260]	; (1bec0 <ble_att_svr_rx_read_blob+0x134>)
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_read_blob_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1bdbc:	6818      	ldr	r0, [r3, #0]
   1bdbe:	88d9      	ldrh	r1, [r3, #6]
   1bdc0:	aa05      	add	r2, sp, #20
   1bdc2:	f7ff f857 	bl	1ae74 <ble_att_read_blob_req_parse>
    BLE_ATT_LOG_CMD(0, "read blob req", conn_handle, ble_att_read_blob_req_log,
   1bdc6:	4b3f      	ldr	r3, [pc, #252]	; (1bec4 <ble_att_svr_rx_read_blob+0x138>)
   1bdc8:	9300      	str	r3, [sp, #0]
   1bdca:	4b3f      	ldr	r3, [pc, #252]	; (1bec8 <ble_att_svr_rx_read_blob+0x13c>)
   1bdcc:	9302      	str	r3, [sp, #8]
   1bdce:	4632      	mov	r2, r6
   1bdd0:	2104      	movs	r1, #4
   1bdd2:	4b3e      	ldr	r3, [pc, #248]	; (1becc <ble_att_svr_rx_read_blob+0x140>)
   1bdd4:	483e      	ldr	r0, [pc, #248]	; (1bed0 <ble_att_svr_rx_read_blob+0x144>)
   1bdd6:	9401      	str	r4, [sp, #4]
   1bdd8:	f8cd 800c 	str.w	r8, [sp, #12]
   1bddc:	f001 fa24 	bl	1d228 <log_printf>
   1bde0:	a805      	add	r0, sp, #20
   1bde2:	f7ff f857 	bl	1ae94 <ble_att_read_blob_req_log>
   1bde6:	4632      	mov	r2, r6
   1bde8:	4839      	ldr	r0, [pc, #228]	; (1bed0 <ble_att_svr_rx_read_blob+0x144>)
   1bdea:	4b3a      	ldr	r3, [pc, #232]	; (1bed4 <ble_att_svr_rx_read_blob+0x148>)
   1bdec:	2104      	movs	r1, #4
   1bdee:	f001 fa1b 	bl	1d228 <log_printf>
                    &req);

    ctxt.read.offset = req.babq_offset;
   1bdf2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1bdf6:	f8ad 3018 	strh.w	r3, [sp, #24]
    rc = ble_att_svr_read_handle(conn_handle, req.babq_handle, &ctxt,
   1bdfa:	4640      	mov	r0, r8
   1bdfc:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1be00:	aa06      	add	r2, sp, #24
   1be02:	f10d 0312 	add.w	r3, sp, #18
   1be06:	f7ff fb61 	bl	1b4cc <ble_att_svr_read_handle>
   1be0a:	46a1      	mov	r9, r4
                                 &att_err);
    if (rc != 0) {
   1be0c:	4606      	mov	r6, r0
   1be0e:	b9c8      	cbnz	r0, 1be44 <ble_att_svr_rx_read_blob+0xb8>
        err_handle = req.babq_handle;
        goto done;
    }

    if (ctxt.read.offset + ctxt.read.len <= mtu - 3) {
   1be10:	f8bd 4024 	ldrh.w	r4, [sp, #36]	; 0x24
   1be14:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   1be18:	1eba      	subs	r2, r7, #2
   1be1a:	4423      	add	r3, r4
   1be1c:	429a      	cmp	r2, r3
   1be1e:	dd07      	ble.n	1be30 <ble_att_svr_rx_read_blob+0xa4>
        att_err = BLE_ATT_ERR_ATTR_NOT_LONG;
   1be20:	230b      	movs	r3, #11
   1be22:	f88d 3012 	strb.w	r3, [sp, #18]
    uint16_t mtu;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1be26:	4605      	mov	r5, r0
        goto done;
    }

    if (ctxt.read.offset + ctxt.read.len <= mtu - 3) {
        att_err = BLE_ATT_ERR_ATTR_NOT_LONG;
        err_handle = req.babq_handle;
   1be28:	f8bd 3014 	ldrh.w	r3, [sp, #20]
        rc = BLE_HS_ENOTSUP;
   1be2c:	2608      	movs	r6, #8
        goto done;
   1be2e:	e03a      	b.n	1bea6 <ble_att_svr_rx_read_blob+0x11a>
    }

    rc = ble_att_svr_build_read_blob_rsp(ctxt.read.data, ctxt.read.len, mtu,
   1be30:	f8dd a020 	ldr.w	sl, [sp, #32]
    struct os_mbuf *txom;
    uint16_t data_len;
    uint8_t op;
    int rc;

    txom = ble_hs_misc_pkthdr();
   1be34:	f7f9 fb6e 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1be38:	4605      	mov	r5, r0
   1be3a:	b930      	cbnz	r0, 1be4a <ble_att_svr_rx_read_blob+0xbe>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1be3c:	2311      	movs	r3, #17
   1be3e:	f88d 3012 	strb.w	r3, [sp, #18]
        rc = BLE_HS_ENOMEM;
   1be42:	2606      	movs	r6, #6
    }

    rc = ble_att_svr_build_read_blob_rsp(ctxt.read.data, ctxt.read.len, mtu,
                                         &txom, &att_err);
    if (rc != 0) {
        err_handle = req.babq_handle;
   1be44:	f8bd 3014 	ldrh.w	r3, [sp, #20]
        goto done;
   1be48:	e02d      	b.n	1bea6 <ble_att_svr_rx_read_blob+0x11a>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    op = BLE_ATT_OP_READ_BLOB_RSP;
   1be4a:	a90a      	add	r1, sp, #40	; 0x28
   1be4c:	230d      	movs	r3, #13
   1be4e:	f801 3d15 	strb.w	r3, [r1, #-21]!
    rc = os_mbuf_append(txom, &op, 1);
   1be52:	2201      	movs	r2, #1
   1be54:	f7ee f88c 	bl	9f70 <os_mbuf_append>
    if (rc != 0) {
   1be58:	2800      	cmp	r0, #0
   1be5a:	d1ef      	bne.n	1be3c <ble_att_svr_rx_read_blob+0xb0>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    /* Vol. 3, part F, 3.2.9; don't send more than ATT_MTU-1 bytes of data. */
    if (attr_len > mtu - 1) {
   1be5c:	42a7      	cmp	r7, r4
        data_len = mtu - 1;
   1be5e:	bfdc      	itt	le
   1be60:	f107 34ff 	addle.w	r4, r7, #4294967295	; 0xffffffff
   1be64:	b2a4      	uxthle	r4, r4
    } else {
        data_len = attr_len;
    }

    rc = os_mbuf_append(txom, attr_data, data_len);
   1be66:	4622      	mov	r2, r4
   1be68:	4628      	mov	r0, r5
   1be6a:	4651      	mov	r1, sl
   1be6c:	f7ee f880 	bl	9f70 <os_mbuf_append>
    if (rc != 0) {
   1be70:	4604      	mov	r4, r0
   1be72:	2800      	cmp	r0, #0
   1be74:	d1e2      	bne.n	1be3c <ble_att_svr_rx_read_blob+0xb0>
                                         &txom, &att_err);
    if (rc != 0) {
        err_handle = req.babq_handle;
        goto done;
    }
    BLE_ATT_LOG_EMPTY_CMD(1, "read blob rsp", conn_handle);
   1be76:	4b18      	ldr	r3, [pc, #96]	; (1bed8 <ble_att_svr_rx_read_blob+0x14c>)
   1be78:	4815      	ldr	r0, [pc, #84]	; (1bed0 <ble_att_svr_rx_read_blob+0x144>)
   1be7a:	f8cd 800c 	str.w	r8, [sp, #12]
   1be7e:	e88d 0208 	stmia.w	sp, {r3, r9}
   1be82:	4b16      	ldr	r3, [pc, #88]	; (1bedc <ble_att_svr_rx_read_blob+0x150>)
   1be84:	9302      	str	r3, [sp, #8]
   1be86:	2104      	movs	r1, #4
   1be88:	4622      	mov	r2, r4
   1be8a:	4b10      	ldr	r3, [pc, #64]	; (1becc <ble_att_svr_rx_read_blob+0x140>)
   1be8c:	f001 f9cc 	bl	1d228 <log_printf>
   1be90:	4b10      	ldr	r3, [pc, #64]	; (1bed4 <ble_att_svr_rx_read_blob+0x148>)
   1be92:	480f      	ldr	r0, [pc, #60]	; (1bed0 <ble_att_svr_rx_read_blob+0x144>)
   1be94:	2104      	movs	r1, #4
   1be96:	4622      	mov	r2, r4
   1be98:	f001 f9c6 	bl	1d228 <log_printf>
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;
   1be9c:	4623      	mov	r3, r4
   1be9e:	e002      	b.n	1bea6 <ble_att_svr_rx_read_blob+0x11a>
    uint16_t mtu;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1bea0:	4605      	mov	r5, r0
    att_err = 0;
    err_handle = 0;

    mtu = ble_att_mtu(conn_handle);
    if (mtu == 0) {
        rc = BLE_HS_ENOTCONN;
   1bea2:	2607      	movs	r6, #7
        goto done;
    }

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_READ_BLOB_REQ_SZ, &att_err);
    if (rc != 0) {
        err_handle = 0;
   1bea4:	462b      	mov	r3, r5
    BLE_ATT_LOG_EMPTY_CMD(1, "read blob rsp", conn_handle);

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_READ_BLOB_REQ,
   1bea6:	f89d 2012 	ldrb.w	r2, [sp, #18]
   1beaa:	4640      	mov	r0, r8
   1beac:	e88d 000c 	stmia.w	sp, {r2, r3}
   1beb0:	4631      	mov	r1, r6
   1beb2:	462a      	mov	r2, r5
   1beb4:	230c      	movs	r3, #12
   1beb6:	f7ff f8e5 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);
    return rc;
}
   1beba:	b00a      	add	sp, #40	; 0x28
   1bebc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1bec0:	000207e0 	.word	0x000207e0
   1bec4:	0001fbda 	.word	0x0001fbda
   1bec8:	00020870 	.word	0x00020870
   1becc:	0001fbbc 	.word	0x0001fbbc
   1bed0:	20003b9c 	.word	0x20003b9c
   1bed4:	0001fdec 	.word	0x0001fdec
   1bed8:	0001fe60 	.word	0x0001fe60
   1bedc:	0002087e 	.word	0x0002087e

0001bee0 <ble_att_svr_rx_read_mult>:
    return rc;
}

int
ble_att_svr_rx_read_mult(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1bee0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bee4:	b08b      	sub	sp, #44	; 0x2c
    struct os_mbuf *txom;
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult req", conn_handle);
   1bee6:	4b54      	ldr	r3, [pc, #336]	; (1c038 <ble_att_svr_rx_read_mult+0x158>)
   1bee8:	9300      	str	r3, [sp, #0]
   1beea:	4d54      	ldr	r5, [pc, #336]	; (1c03c <ble_att_svr_rx_read_mult+0x15c>)
   1beec:	4b54      	ldr	r3, [pc, #336]	; (1c040 <ble_att_svr_rx_read_mult+0x160>)
   1beee:	9302      	str	r3, [sp, #8]
    return rc;
}

int
ble_att_svr_rx_read_mult(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1bef0:	460e      	mov	r6, r1
    struct os_mbuf *txom;
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult req", conn_handle);
   1bef2:	9003      	str	r0, [sp, #12]
   1bef4:	2104      	movs	r1, #4
   1bef6:	2200      	movs	r2, #0
   1bef8:	4b52      	ldr	r3, [pc, #328]	; (1c044 <ble_att_svr_rx_read_mult+0x164>)
   1befa:	9501      	str	r5, [sp, #4]

    /* Initialize some values in case of early error. */
    txom = NULL;
    err_handle = 0;
    att_err = 0;
   1befc:	f10d 0928 	add.w	r9, sp, #40	; 0x28
    return rc;
}

int
ble_att_svr_rx_read_mult(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1bf00:	4680      	mov	r8, r0
    struct os_mbuf *txom;
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult req", conn_handle);
   1bf02:	4851      	ldr	r0, [pc, #324]	; (1c048 <ble_att_svr_rx_read_mult+0x168>)
   1bf04:	f001 f990 	bl	1d228 <log_printf>

    /* Initialize some values in case of early error. */
    txom = NULL;
    err_handle = 0;
    att_err = 0;
   1bf08:	2400      	movs	r4, #0
    struct os_mbuf *txom;
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult req", conn_handle);
   1bf0a:	484f      	ldr	r0, [pc, #316]	; (1c048 <ble_att_svr_rx_read_mult+0x168>)
   1bf0c:	4b4f      	ldr	r3, [pc, #316]	; (1c04c <ble_att_svr_rx_read_mult+0x16c>)
   1bf0e:	2104      	movs	r1, #4
   1bf10:	2200      	movs	r2, #0
   1bf12:	f001 f989 	bl	1d228 <log_printf>

    /* Initialize some values in case of early error. */
    txom = NULL;
    err_handle = 0;
    att_err = 0;
   1bf16:	f809 4d11 	strb.w	r4, [r9, #-17]!

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_READ_MULT_REQ_BASE_SZ,
   1bf1a:	2101      	movs	r1, #1
   1bf1c:	4630      	mov	r0, r6
   1bf1e:	464a      	mov	r2, r9
   1bf20:	f7ff f8a5 	bl	1b06e <ble_att_svr_pullup_req_base>
   1bf24:	46aa      	mov	sl, r5
                                     &att_err);
    if (rc != 0) {
   1bf26:	4601      	mov	r1, r0
   1bf28:	2800      	cmp	r0, #0
   1bf2a:	d178      	bne.n	1c01e <ble_att_svr_rx_read_mult+0x13e>
        err_handle = 0;
        goto done;
    }

    ble_att_read_mult_req_parse((*rxom)->om_data, (*rxom)->om_len);
   1bf2c:	6833      	ldr	r3, [r6, #0]
   1bf2e:	6818      	ldr	r0, [r3, #0]
   1bf30:	88d9      	ldrh	r1, [r3, #6]
   1bf32:	f7fe ffc1 	bl	1aeb8 <ble_att_read_mult_req_parse>

    /* Strip opcode from request. */
    os_mbuf_adj(*rxom, BLE_ATT_READ_MULT_REQ_BASE_SZ);
   1bf36:	6830      	ldr	r0, [r6, #0]
   1bf38:	2101      	movs	r1, #1
   1bf3a:	f7ee f8c0 	bl	a0be <os_mbuf_adj>
    uint8_t *dptr;
    int rc;

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
   1bf3e:	4640      	mov	r0, r8
   1bf40:	f7fd ff58 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   1bf44:	4605      	mov	r5, r0
   1bf46:	2800      	cmp	r0, #0
   1bf48:	d062      	beq.n	1c010 <ble_att_svr_rx_read_mult+0x130>
        rc = BLE_HS_ENOTCONN;
        goto done;
    }

    txom = ble_hs_misc_pkthdr();
   1bf4a:	f7f9 fae3 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1bf4e:	4607      	mov	r7, r0
   1bf50:	b920      	cbnz	r0, 1bf5c <ble_att_svr_rx_read_mult+0x7c>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1bf52:	2311      	movs	r3, #17
   1bf54:	f88d 3017 	strb.w	r3, [sp, #23]
        *err_handle = 0;
   1bf58:	4604      	mov	r4, r0
   1bf5a:	e00f      	b.n	1bf7c <ble_att_svr_rx_read_mult+0x9c>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    dptr = os_mbuf_extend(txom, BLE_ATT_READ_MULT_RSP_BASE_SZ);
   1bf5c:	2101      	movs	r1, #1
   1bf5e:	f7ee f987 	bl	a270 <os_mbuf_extend>
    if (dptr == NULL) {
   1bf62:	4604      	mov	r4, r0
   1bf64:	b138      	cbz	r0, 1bf76 <ble_att_svr_rx_read_mult+0x96>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        *err_handle = 0;
        rc = BLE_HS_ENOMEM;
        goto done;
    }
    ble_att_read_mult_rsp_write(dptr, BLE_ATT_READ_MULT_RSP_BASE_SZ);
   1bf66:	2101      	movs	r1, #1
   1bf68:	f7fe ffa7 	bl	1aeba <ble_att_read_mult_rsp_write>

    tx_space = mtu - OS_MBUF_PKTLEN(txom);
   1bf6c:	8a3c      	ldrh	r4, [r7, #16]
   1bf6e:	1b2c      	subs	r4, r5, r4
   1bf70:	fa1f fb84 	uxth.w	fp, r4
   1bf74:	e032      	b.n	1bfdc <ble_att_svr_rx_read_mult+0xfc>
            chunk_sz = ctxt.read.len;
        }

        rc = os_mbuf_append(txom, ctxt.read.data, chunk_sz);
        if (rc != 0) {
            *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1bf76:	2311      	movs	r3, #17
   1bf78:	f88d 3017 	strb.w	r3, [sp, #23]
            *err_handle = handle;
            rc = BLE_HS_ENOMEM;
   1bf7c:	2506      	movs	r5, #6
   1bf7e:	e04c      	b.n	1c01a <ble_att_svr_rx_read_mult+0x13a>

    /* Iterate through requested handles, reading the corresponding attribute
     * for each.  Stop when there are no more handles to process, or the
     * response is full.
     */
    while (OS_MBUF_PKTLEN(*rxom) >= 2 && tx_space > 0) {
   1bf80:	f1bb 0f00 	cmp.w	fp, #0
   1bf84:	d02e      	beq.n	1bfe4 <ble_att_svr_rx_read_mult+0x104>
        /* Ensure the full 16-bit handle is contiguous at the start of the
         * mbuf.
         */
        rc = ble_att_svr_pullup_req_base(rxom, 2, att_err);
   1bf86:	4630      	mov	r0, r6
   1bf88:	2102      	movs	r1, #2
   1bf8a:	464a      	mov	r2, r9
   1bf8c:	f7ff f86f 	bl	1b06e <ble_att_svr_pullup_req_base>
        if (rc != 0) {
   1bf90:	4605      	mov	r5, r0
   1bf92:	2800      	cmp	r0, #0
   1bf94:	d140      	bne.n	1c018 <ble_att_svr_rx_read_mult+0x138>
        }

        /* Extract the 16-bit handle and strip it from the front of the
         * mbuf.
         */
        handle = le16toh((*rxom)->om_data);
   1bf96:	6833      	ldr	r3, [r6, #0]
   1bf98:	6818      	ldr	r0, [r3, #0]
   1bf9a:	f001 f878 	bl	1d08e <le16toh>
        os_mbuf_adj(*rxom, 2);
   1bf9e:	2102      	movs	r1, #2
        }

        /* Extract the 16-bit handle and strip it from the front of the
         * mbuf.
         */
        handle = le16toh((*rxom)->om_data);
   1bfa0:	4604      	mov	r4, r0
        os_mbuf_adj(*rxom, 2);
   1bfa2:	6830      	ldr	r0, [r6, #0]
   1bfa4:	f7ee f88b 	bl	a0be <os_mbuf_adj>

        ctxt.read.offset = 0;
   1bfa8:	aa0a      	add	r2, sp, #40	; 0x28
        rc = ble_att_svr_read_handle(conn_handle, handle, &ctxt, att_err);
   1bfaa:	4640      	mov	r0, r8
         * mbuf.
         */
        handle = le16toh((*rxom)->om_data);
        os_mbuf_adj(*rxom, 2);

        ctxt.read.offset = 0;
   1bfac:	f822 5d10 	strh.w	r5, [r2, #-16]!
        rc = ble_att_svr_read_handle(conn_handle, handle, &ctxt, att_err);
   1bfb0:	4621      	mov	r1, r4
   1bfb2:	464b      	mov	r3, r9
   1bfb4:	f7ff fa8a 	bl	1b4cc <ble_att_svr_read_handle>
        if (rc != 0) {
   1bfb8:	4605      	mov	r5, r0
   1bfba:	bb70      	cbnz	r0, 1c01a <ble_att_svr_rx_read_mult+0x13a>
            *err_handle = handle;
            goto done;
        }

        if (ctxt.read.len > tx_space) {
   1bfbc:	f8bd 5024 	ldrh.w	r5, [sp, #36]	; 0x24
            chunk_sz = tx_space;
        } else {
            chunk_sz = ctxt.read.len;
        }

        rc = os_mbuf_append(txom, ctxt.read.data, chunk_sz);
   1bfc0:	9908      	ldr	r1, [sp, #32]
   1bfc2:	455d      	cmp	r5, fp
   1bfc4:	bf28      	it	cs
   1bfc6:	465d      	movcs	r5, fp
   1bfc8:	4638      	mov	r0, r7
   1bfca:	462a      	mov	r2, r5
   1bfcc:	f7ed ffd0 	bl	9f70 <os_mbuf_append>
        if (rc != 0) {
   1bfd0:	2800      	cmp	r0, #0
   1bfd2:	d1d0      	bne.n	1bf76 <ble_att_svr_rx_read_mult+0x96>
            *err_handle = handle;
            rc = BLE_HS_ENOMEM;
            goto done;
        }

        tx_space -= chunk_sz;
   1bfd4:	ebc5 0b0b 	rsb	fp, r5, fp
   1bfd8:	fa1f fb8b 	uxth.w	fp, fp

    /* Iterate through requested handles, reading the corresponding attribute
     * for each.  Stop when there are no more handles to process, or the
     * response is full.
     */
    while (OS_MBUF_PKTLEN(*rxom) >= 2 && tx_space > 0) {
   1bfdc:	6833      	ldr	r3, [r6, #0]
   1bfde:	8a1b      	ldrh	r3, [r3, #16]
   1bfe0:	2b01      	cmp	r3, #1
   1bfe2:	d8cd      	bhi.n	1bf80 <ble_att_svr_rx_read_mult+0xa0>
        }

        tx_space -= chunk_sz;
    }

    BLE_ATT_LOG_EMPTY_CMD(1, "read mult rsp", conn_handle);
   1bfe4:	4b1a      	ldr	r3, [pc, #104]	; (1c050 <ble_att_svr_rx_read_mult+0x170>)
   1bfe6:	4818      	ldr	r0, [pc, #96]	; (1c048 <ble_att_svr_rx_read_mult+0x168>)
   1bfe8:	f8cd 800c 	str.w	r8, [sp, #12]
   1bfec:	e88d 0408 	stmia.w	sp, {r3, sl}
   1bff0:	4b18      	ldr	r3, [pc, #96]	; (1c054 <ble_att_svr_rx_read_mult+0x174>)
   1bff2:	9302      	str	r3, [sp, #8]
   1bff4:	2104      	movs	r1, #4
   1bff6:	2200      	movs	r2, #0
   1bff8:	4b12      	ldr	r3, [pc, #72]	; (1c044 <ble_att_svr_rx_read_mult+0x164>)
   1bffa:	f001 f915 	bl	1d228 <log_printf>
    rc = 0;
   1bffe:	2500      	movs	r5, #0
        }

        tx_space -= chunk_sz;
    }

    BLE_ATT_LOG_EMPTY_CMD(1, "read mult rsp", conn_handle);
   1c000:	4811      	ldr	r0, [pc, #68]	; (1c048 <ble_att_svr_rx_read_mult+0x168>)
   1c002:	4b12      	ldr	r3, [pc, #72]	; (1c04c <ble_att_svr_rx_read_mult+0x16c>)
   1c004:	2104      	movs	r1, #4
   1c006:	2200      	movs	r2, #0
   1c008:	f001 f90e 	bl	1d228 <log_printf>

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult req", conn_handle);

    /* Initialize some values in case of early error. */
    txom = NULL;
    err_handle = 0;
   1c00c:	462c      	mov	r4, r5
   1c00e:	e004      	b.n	1c01a <ble_att_svr_rx_read_mult+0x13a>
   1c010:	4604      	mov	r4, r0

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
    if (mtu == 0) {
        rc = BLE_HS_ENOTCONN;
   1c012:	2507      	movs	r5, #7
    uint16_t handle;
    uint16_t mtu;
    uint8_t *dptr;
    int rc;

    txom = NULL;
   1c014:	4607      	mov	r7, r0
   1c016:	e000      	b.n	1c01a <ble_att_svr_rx_read_mult+0x13a>
        /* Ensure the full 16-bit handle is contiguous at the start of the
         * mbuf.
         */
        rc = ble_att_svr_pullup_req_base(rxom, 2, att_err);
        if (rc != 0) {
            *err_handle = 0;
   1c018:	2400      	movs	r4, #0
                                         &err_handle);
    if (rc != 0) {
        goto done;
    }

    rc = 0;
   1c01a:	4629      	mov	r1, r5
   1c01c:	e000      	b.n	1c020 <ble_att_svr_rx_read_mult+0x140>
    int rc;

    BLE_ATT_LOG_EMPTY_CMD(0, "read mult req", conn_handle);

    /* Initialize some values in case of early error. */
    txom = NULL;
   1c01e:	4627      	mov	r7, r4
    }

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_READ_MULT_REQ,
   1c020:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1c024:	4640      	mov	r0, r8
   1c026:	e88d 0018 	stmia.w	sp, {r3, r4}
   1c02a:	463a      	mov	r2, r7
   1c02c:	230e      	movs	r3, #14
   1c02e:	f7ff f829 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);
    return rc;
}
   1c032:	b00b      	add	sp, #44	; 0x2c
   1c034:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c038:	0001fbda 	.word	0x0001fbda
   1c03c:	000207e0 	.word	0x000207e0
   1c040:	000209fa 	.word	0x000209fa
   1c044:	0001fbbc 	.word	0x0001fbbc
   1c048:	20003b9c 	.word	0x20003b9c
   1c04c:	0001fdec 	.word	0x0001fdec
   1c050:	0001fe60 	.word	0x0001fe60
   1c054:	0002089a 	.word	0x0002089a

0001c058 <ble_att_svr_rx_read_group_type>:
    return rc;
}

int
ble_att_svr_rx_read_group_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c058:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;

    pktlen = OS_MBUF_PKTLEN(*rxom);
   1c05c:	680b      	ldr	r3, [r1, #0]
    return rc;
}

int
ble_att_svr_rx_read_group_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c05e:	460d      	mov	r5, r1
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;

    pktlen = OS_MBUF_PKTLEN(*rxom);
   1c060:	8a19      	ldrh	r1, [r3, #16]
    if (pktlen != BLE_ATT_READ_GROUP_TYPE_REQ_SZ_16 &&
   1c062:	2907      	cmp	r1, #7
    return rc;
}

int
ble_att_svr_rx_read_group_type(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c064:	b097      	sub	sp, #92	; 0x5c
   1c066:	4680      	mov	r8, r0

    /* Initialize some values in case of early error. */
    txom = NULL;

    pktlen = OS_MBUF_PKTLEN(*rxom);
    if (pktlen != BLE_ATT_READ_GROUP_TYPE_REQ_SZ_16 &&
   1c068:	d002      	beq.n	1c070 <ble_att_svr_rx_read_group_type+0x18>
   1c06a:	2915      	cmp	r1, #21
   1c06c:	f040 811f 	bne.w	1c2ae <ble_att_svr_rx_read_group_type+0x256>

        /* Malformed request; discard. */
        return BLE_HS_EBADDATA;
    }

    rc = ble_att_svr_pullup_req_base(rxom, pktlen, &att_err);
   1c070:	4628      	mov	r0, r5
   1c072:	f10d 0223 	add.w	r2, sp, #35	; 0x23
   1c076:	f7fe fffa 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1c07a:	4604      	mov	r4, r0
   1c07c:	2800      	cmp	r0, #0
   1c07e:	f040 8109 	bne.w	1c294 <ble_att_svr_rx_read_group_type+0x23c>
        err_handle = 0;
        goto done;
    }

    ble_att_read_group_type_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c082:	682b      	ldr	r3, [r5, #0]
    BLE_ATT_LOG_CMD(0, "read group type req", conn_handle,
   1c084:	4f9c      	ldr	r7, [pc, #624]	; (1c2f8 <ble_att_svr_rx_read_group_type+0x2a0>)
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_read_group_type_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c086:	6818      	ldr	r0, [r3, #0]
   1c088:	88d9      	ldrh	r1, [r3, #6]
   1c08a:	aa09      	add	r2, sp, #36	; 0x24
   1c08c:	f7fe ff18 	bl	1aec0 <ble_att_read_group_type_req_parse>
    BLE_ATT_LOG_CMD(0, "read group type req", conn_handle,
   1c090:	4b9a      	ldr	r3, [pc, #616]	; (1c2fc <ble_att_svr_rx_read_group_type+0x2a4>)
   1c092:	9300      	str	r3, [sp, #0]
   1c094:	4b9a      	ldr	r3, [pc, #616]	; (1c300 <ble_att_svr_rx_read_group_type+0x2a8>)
   1c096:	9302      	str	r3, [sp, #8]
   1c098:	2104      	movs	r1, #4
   1c09a:	4622      	mov	r2, r4
   1c09c:	4b99      	ldr	r3, [pc, #612]	; (1c304 <ble_att_svr_rx_read_group_type+0x2ac>)
   1c09e:	489a      	ldr	r0, [pc, #616]	; (1c308 <ble_att_svr_rx_read_group_type+0x2b0>)
   1c0a0:	9701      	str	r7, [sp, #4]
   1c0a2:	f8cd 800c 	str.w	r8, [sp, #12]
   1c0a6:	f001 f8bf 	bl	1d228 <log_printf>
   1c0aa:	a809      	add	r0, sp, #36	; 0x24
   1c0ac:	f7fe ff18 	bl	1aee0 <ble_att_read_group_type_req_log>
   1c0b0:	4b96      	ldr	r3, [pc, #600]	; (1c30c <ble_att_svr_rx_read_group_type+0x2b4>)
   1c0b2:	4895      	ldr	r0, [pc, #596]	; (1c308 <ble_att_svr_rx_read_group_type+0x2b0>)
   1c0b4:	2104      	movs	r1, #4
   1c0b6:	4622      	mov	r2, r4
   1c0b8:	f001 f8b6 	bl	1d228 <log_printf>
                    ble_att_read_group_type_req_log, &req);

    if (req.bagq_start_handle > req.bagq_end_handle ||
   1c0bc:	f8bd 6024 	ldrh.w	r6, [sp, #36]	; 0x24
   1c0c0:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
   1c0c4:	9706      	str	r7, [sp, #24]
   1c0c6:	42b3      	cmp	r3, r6
   1c0c8:	d300      	bcc.n	1c0cc <ble_att_svr_rx_read_group_type+0x74>
   1c0ca:	b92e      	cbnz	r6, 1c0d8 <ble_att_svr_rx_read_group_type+0x80>
        req.bagq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
   1c0cc:	2301      	movs	r3, #1
   1c0ce:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint16_t pktlen;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1c0d2:	2700      	movs	r7, #0
    if (req.bagq_start_handle > req.bagq_end_handle ||
        req.bagq_start_handle == 0) {

        att_err = BLE_ATT_ERR_INVALID_HANDLE;
        err_handle = req.bagq_start_handle;
        rc = BLE_HS_EBADDATA;
   1c0d4:	240a      	movs	r4, #10
        goto done;
   1c0d6:	e0df      	b.n	1c298 <ble_att_svr_rx_read_group_type+0x240>
    }

    rc = ble_uuid_extract(*rxom, BLE_ATT_READ_GROUP_TYPE_REQ_BASE_SZ,
   1c0d8:	6828      	ldr	r0, [r5, #0]
   1c0da:	2105      	movs	r1, #5
   1c0dc:	aa0a      	add	r2, sp, #40	; 0x28
   1c0de:	f7fc fa24 	bl	1852a <ble_uuid_extract>
                          uuid128);
    if (rc != 0) {
   1c0e2:	4605      	mov	r5, r0
   1c0e4:	b128      	cbz	r0, 1c0f2 <ble_att_svr_rx_read_group_type+0x9a>
        att_err = BLE_ATT_ERR_INVALID_PDU;
   1c0e6:	2304      	movs	r3, #4
   1c0e8:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
        err_handle = req.bagq_start_handle;
   1c0ec:	f8bd 6024 	ldrh.w	r6, [sp, #36]	; 0x24
   1c0f0:	e7ef      	b.n	1c0d2 <ble_att_svr_rx_read_group_type+0x7a>
static int
ble_att_svr_is_valid_group_type(uint8_t *uuid128)
{
    uint16_t uuid16;

    uuid16 = ble_uuid_128_to_16(uuid128);
   1c0f2:	a80a      	add	r0, sp, #40	; 0x28
   1c0f4:	f7fc f9d0 	bl	18498 <ble_uuid_128_to_16>

    return uuid16 == BLE_ATT_UUID_PRIMARY_SERVICE ||
   1c0f8:	f5a0 5020 	sub.w	r0, r0, #10240	; 0x2800
        err_handle = req.bagq_start_handle;
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    if (!ble_att_svr_is_valid_group_type(uuid128)) {
   1c0fc:	b280      	uxth	r0, r0
   1c0fe:	2801      	cmp	r0, #1
   1c100:	f8bd 6024 	ldrh.w	r6, [sp, #36]	; 0x24
   1c104:	d904      	bls.n	1c110 <ble_att_svr_rx_read_group_type+0xb8>
        att_err = BLE_ATT_ERR_UNSUPPORTED_GROUP;
   1c106:	2310      	movs	r3, #16
   1c108:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint16_t pktlen;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1c10c:	4627      	mov	r7, r4
   1c10e:	e055      	b.n	1c1bc <ble_att_svr_rx_read_group_type+0x164>
    *att_err = 0;
    *err_handle = req->bagq_start_handle;

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
   1c110:	4640      	mov	r0, r8
    /* Silence warnings. */
    rsp_buf = NULL;
    service_uuid16 = 0;
    end_group_handle = 0;

    *att_err = 0;
   1c112:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
    *err_handle = req->bagq_start_handle;

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
   1c116:	f7fd fe6d 	bl	19df4 <ble_att_mtu>
    if (mtu == 0) {
   1c11a:	4681      	mov	r9, r0
   1c11c:	2800      	cmp	r0, #0
   1c11e:	f000 80e1 	beq.w	1c2e4 <ble_att_svr_rx_read_group_type+0x28c>
        rc = BLE_HS_ENOTCONN;
        goto done;
    }

    txom = ble_hs_misc_pkthdr();
   1c122:	f7f9 f9f7 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1c126:	4607      	mov	r7, r0
   1c128:	b120      	cbz	r0, 1c134 <ble_att_svr_rx_read_group_type+0xdc>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    /* Reserve space for the response base. */
    rsp_buf = os_mbuf_extend(txom, BLE_ATT_READ_GROUP_TYPE_RSP_BASE_SZ);
   1c12a:	2102      	movs	r1, #2
   1c12c:	f7ee f8a0 	bl	a270 <os_mbuf_extend>
    if (rsp_buf == NULL) {
   1c130:	9005      	str	r0, [sp, #20]
   1c132:	b920      	cbnz	r0, 1c13e <ble_att_svr_rx_read_group_type+0xe6>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1c134:	2311      	movs	r3, #17
   1c136:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
        rc = BLE_HS_ENOMEM;
   1c13a:	2406      	movs	r4, #6
   1c13c:	e0ac      	b.n	1c298 <ble_att_svr_rx_read_group_type+0x240>
        goto done;
    }

    start_group_handle = 0;
    rsp.bagp_length = 0;
    STAILQ_FOREACH(entry, &ble_att_svr_list, ha_next) {
   1c13e:	4b74      	ldr	r3, [pc, #464]	; (1c310 <ble_att_svr_rx_read_group_type+0x2b8>)
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    start_group_handle = 0;
    rsp.bagp_length = 0;
   1c140:	f88d 5020 	strb.w	r5, [sp, #32]
    STAILQ_FOREACH(entry, &ble_att_svr_list, ha_next) {
   1c144:	f8d3 a000 	ldr.w	sl, [r3]
    int rc;

    /* Silence warnings. */
    rsp_buf = NULL;
    service_uuid16 = 0;
    end_group_handle = 0;
   1c148:	462c      	mov	r4, r5
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    start_group_handle = 0;
   1c14a:	462a      	mov	r2, r5
   1c14c:	e00d      	b.n	1c16a <ble_att_svr_rx_read_group_type+0x112>
static int
ble_att_svr_is_valid_group_type(uint8_t *uuid128)
{
    uint16_t uuid16;

    uuid16 = ble_uuid_128_to_16(uuid128);
   1c14e:	4658      	mov	r0, fp
   1c150:	9207      	str	r2, [sp, #28]
   1c152:	f7fc f9a1 	bl	18498 <ble_uuid_128_to_16>

    return uuid16 == BLE_ATT_UUID_PRIMARY_SERVICE ||
   1c156:	f5a0 5020 	sub.w	r0, r0, #10240	; 0x2800
            goto done;
        }

        if (start_group_handle != 0) {
            /* We have already found the start of a group. */
            if (!ble_att_svr_is_valid_group_type(entry->ha_uuid)) {
   1c15a:	b280      	uxth	r0, r0
   1c15c:	2801      	cmp	r0, #1
   1c15e:	9a07      	ldr	r2, [sp, #28]
   1c160:	d92e      	bls.n	1c1c0 <ble_att_svr_rx_read_group_type+0x168>
                /* This attribute is part of the current group. */
                end_group_handle = entry->ha_handle_id;
   1c162:	f8ba 4016 	ldrh.w	r4, [sl, #22]
        goto done;
    }

    start_group_handle = 0;
    rsp.bagp_length = 0;
    STAILQ_FOREACH(entry, &ble_att_svr_list, ha_next) {
   1c166:	f8da a000 	ldr.w	sl, [sl]
   1c16a:	f1ba 0f00 	cmp.w	sl, #0
   1c16e:	d03a      	beq.n	1c1e6 <ble_att_svr_rx_read_group_type+0x18e>
        if (entry->ha_handle_id < req->bagq_start_handle) {
   1c170:	f8ba 3016 	ldrh.w	r3, [sl, #22]
   1c174:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
   1c178:	4299      	cmp	r1, r3
   1c17a:	d8f4      	bhi.n	1c166 <ble_att_svr_rx_read_group_type+0x10e>
            continue;
        }
        if (entry->ha_handle_id > req->bagq_end_handle) {
   1c17c:	f8bd 1026 	ldrh.w	r1, [sp, #38]	; 0x26
   1c180:	4299      	cmp	r1, r3
   1c182:	f0c0 80b2 	bcc.w	1c2ea <ble_att_svr_rx_read_group_type+0x292>
   1c186:	f10a 0b04 	add.w	fp, sl, #4
            /* The full input range has been searched. */
            rc = 0;
            goto done;
        }

        if (start_group_handle != 0) {
   1c18a:	2a00      	cmp	r2, #0
   1c18c:	d1df      	bne.n	1c14e <ble_att_svr_rx_read_group_type+0xf6>
            }
        }

        if (start_group_handle == 0) {
            /* We are looking for the start of a group. */
            if (memcmp(entry->ha_uuid, group_uuid128, 16) == 0) {
   1c18e:	4658      	mov	r0, fp
   1c190:	a90a      	add	r1, sp, #40	; 0x28
   1c192:	2210      	movs	r2, #16
   1c194:	f7ec ff24 	bl	8fe0 <memcmp>
   1c198:	4603      	mov	r3, r0
   1c19a:	2800      	cmp	r0, #0
   1c19c:	f040 80a0 	bne.w	1c2e0 <ble_att_svr_rx_read_group_type+0x288>
                         uint8_t *uuid128)
{
    struct ble_att_svr_access_ctxt ctxt;
    int rc;

    ctxt.read.offset = 0;
   1c1a0:	aa16      	add	r2, sp, #88	; 0x58
    rc = ble_att_svr_read(BLE_HS_CONN_HANDLE_NONE, entry, &ctxt, NULL);
   1c1a2:	f64f 70ff 	movw	r0, #65535	; 0xffff
                         uint8_t *uuid128)
{
    struct ble_att_svr_access_ctxt ctxt;
    int rc;

    ctxt.read.offset = 0;
   1c1a6:	f822 3d10 	strh.w	r3, [r2, #-16]!
    rc = ble_att_svr_read(BLE_HS_CONN_HANDLE_NONE, entry, &ctxt, NULL);
   1c1aa:	4651      	mov	r1, sl
   1c1ac:	f7ff f8c2 	bl	1b334 <ble_att_svr_read>
    if (rc != 0) {
   1c1b0:	b358      	cbz	r0, 1c20a <ble_att_svr_rx_read_group_type+0x1b2>
                /* Found a group start.  Read the group UUID. */
                rc = ble_att_svr_service_uuid(entry, &service_uuid16,
                                              service_uuid128);
                if (rc != 0) {
                    *err_handle = entry->ha_handle_id;
                    *att_err = BLE_ATT_ERR_UNLIKELY;
   1c1b2:	230e      	movs	r3, #14
            if (memcmp(entry->ha_uuid, group_uuid128, 16) == 0) {
                /* Found a group start.  Read the group UUID. */
                rc = ble_att_svr_service_uuid(entry, &service_uuid16,
                                              service_uuid128);
                if (rc != 0) {
                    *err_handle = entry->ha_handle_id;
   1c1b4:	f8ba 6016 	ldrh.w	r6, [sl, #22]
                    *att_err = BLE_ATT_ERR_UNLIKELY;
   1c1b8:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
                    rc = BLE_HS_ENOTSUP;
   1c1bc:	2408      	movs	r4, #8
   1c1be:	e06b      	b.n	1c298 <ble_att_svr_rx_read_group_type+0x240>
                end_group_handle = entry->ha_handle_id;
            } else {
                /* This attribute marks the end of the group.  Write an entry
                 * representing the group to the response.
                 */
                rc = ble_att_svr_read_group_type_entry_write(
   1c1c0:	ab0e      	add	r3, sp, #56	; 0x38
   1c1c2:	9301      	str	r3, [sp, #4]
   1c1c4:	9500      	str	r5, [sp, #0]
   1c1c6:	4623      	mov	r3, r4
   1c1c8:	4638      	mov	r0, r7
   1c1ca:	4649      	mov	r1, r9
   1c1cc:	f7fe ffda 	bl	1b184 <ble_att_svr_read_group_type_entry_write>
                    txom, mtu, start_group_handle, end_group_handle,
                    service_uuid16, service_uuid128);
                start_group_handle = 0;
                end_group_handle = 0;
                if (rc != 0) {
   1c1d0:	4604      	mov	r4, r0
   1c1d2:	2800      	cmp	r0, #0
   1c1d4:	d0db      	beq.n	1c18e <ble_att_svr_rx_read_group_type+0x136>
                    *err_handle = entry->ha_handle_id;
                    if (rc == BLE_HS_ENOMEM) {
   1c1d6:	2806      	cmp	r0, #6
                    txom, mtu, start_group_handle, end_group_handle,
                    service_uuid16, service_uuid128);
                start_group_handle = 0;
                end_group_handle = 0;
                if (rc != 0) {
                    *err_handle = entry->ha_handle_id;
   1c1d8:	f8ba 6016 	ldrh.w	r6, [sl, #22]
                    if (rc == BLE_HS_ENOMEM) {
   1c1dc:	d13a      	bne.n	1c254 <ble_att_svr_rx_read_group_type+0x1fc>
                        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1c1de:	2311      	movs	r3, #17
   1c1e0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
   1c1e4:	e058      	b.n	1c298 <ble_att_svr_rx_read_group_type+0x240>

    rc = 0;

done:
    if (rc == 0) {
        if (start_group_handle != 0) {
   1c1e6:	b35a      	cbz	r2, 1c240 <ble_att_svr_rx_read_group_type+0x1e8>
            if (entry == NULL) {
                /* We have reached the end of the attribute list.  Indicate an
                 * end handle of 0xffff so that the client knows there are no
                 * more attributes without needing to send a follow-up request.
                 */
                end_group_handle = 0xffff;
   1c1e8:	f64f 74ff 	movw	r4, #65535	; 0xffff
            }

            rc = ble_att_svr_read_group_type_entry_write(
   1c1ec:	ab0e      	add	r3, sp, #56	; 0x38
   1c1ee:	9301      	str	r3, [sp, #4]
   1c1f0:	9500      	str	r5, [sp, #0]
   1c1f2:	4623      	mov	r3, r4
   1c1f4:	4638      	mov	r0, r7
   1c1f6:	4649      	mov	r1, r9
   1c1f8:	f7fe ffc4 	bl	1b184 <ble_att_svr_read_group_type_entry_write>
                txom, mtu, start_group_handle, end_group_handle,
                service_uuid16, service_uuid128);
            if (rc == BLE_HS_ENOMEM) {
   1c1fc:	2806      	cmp	r0, #6
                 * more attributes without needing to send a follow-up request.
                 */
                end_group_handle = 0xffff;
            }

            rc = ble_att_svr_read_group_type_entry_write(
   1c1fe:	4604      	mov	r4, r0
                txom, mtu, start_group_handle, end_group_handle,
                service_uuid16, service_uuid128);
            if (rc == BLE_HS_ENOMEM) {
   1c200:	d11f      	bne.n	1c242 <ble_att_svr_rx_read_group_type+0x1ea>
                *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1c202:	2311      	movs	r3, #17
   1c204:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
   1c208:	e01b      	b.n	1c242 <ble_att_svr_rx_read_group_type+0x1ea>
    rc = ble_att_svr_read(BLE_HS_CONN_HANDLE_NONE, entry, &ctxt, NULL);
    if (rc != 0) {
        return rc;
    }

    switch (ctxt.read.len) {
   1c20a:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
   1c20e:	2b02      	cmp	r3, #2
   1c210:	d04f      	beq.n	1c2b2 <ble_att_svr_rx_read_group_type+0x25a>
   1c212:	2b10      	cmp	r3, #16
   1c214:	d1cd      	bne.n	1c1b2 <ble_att_svr_rx_read_group_type+0x15a>
    case 16:
        *uuid16 = 0;
        memcpy(uuid128, ctxt.read.data, 16);
   1c216:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1c218:	ac0e      	add	r4, sp, #56	; 0x38
   1c21a:	f103 0510 	add.w	r5, r3, #16
   1c21e:	6818      	ldr	r0, [r3, #0]
   1c220:	6859      	ldr	r1, [r3, #4]
   1c222:	4622      	mov	r2, r4
   1c224:	c203      	stmia	r2!, {r0, r1}
   1c226:	3308      	adds	r3, #8
   1c228:	42ab      	cmp	r3, r5
   1c22a:	4614      	mov	r4, r2
   1c22c:	d1f7      	bne.n	1c21e <ble_att_svr_rx_read_group_type+0x1c6>
        return rc;
    }

    switch (ctxt.read.len) {
    case 16:
        *uuid16 = 0;
   1c22e:	2500      	movs	r5, #0

                /* Make sure the group UUID lengths are consistent.  If this
                 * group has a different length UUID, then cut the response
                 * short.
                 */
                switch (rsp.bagp_length) {
   1c230:	f89d 3020 	ldrb.w	r3, [sp, #32]
   1c234:	2b06      	cmp	r3, #6
   1c236:	d04b      	beq.n	1c2d0 <ble_att_svr_rx_read_group_type+0x278>
   1c238:	2b14      	cmp	r3, #20
   1c23a:	d04b      	beq.n	1c2d4 <ble_att_svr_rx_read_group_type+0x27c>
   1c23c:	2b00      	cmp	r3, #0
   1c23e:	d040      	beq.n	1c2c2 <ble_att_svr_rx_read_group_type+0x26a>
   1c240:	2400      	movs	r4, #0
            if (rc == BLE_HS_ENOMEM) {
                *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
            }
        }

        if (OS_MBUF_PKTLEN(txom) <= BLE_ATT_READ_GROUP_TYPE_RSP_BASE_SZ) {
   1c242:	8a3b      	ldrh	r3, [r7, #16]
   1c244:	2b02      	cmp	r3, #2
   1c246:	d804      	bhi.n	1c252 <ble_att_svr_rx_read_group_type+0x1fa>
            *att_err = BLE_ATT_ERR_ATTR_NOT_FOUND;
   1c248:	230a      	movs	r3, #10
   1c24a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
            rc = BLE_HS_ENOENT;
   1c24e:	2405      	movs	r4, #5
   1c250:	e022      	b.n	1c298 <ble_att_svr_rx_read_group_type+0x240>
        }
    }

    if (rc == 0 || rc == BLE_HS_EMSGSIZE) {
   1c252:	b10c      	cbz	r4, 1c258 <ble_att_svr_rx_read_group_type+0x200>
   1c254:	2c04      	cmp	r4, #4
   1c256:	d11f      	bne.n	1c298 <ble_att_svr_rx_read_group_type+0x240>
        ble_att_read_group_type_rsp_write(rsp_buf,
   1c258:	9805      	ldr	r0, [sp, #20]
   1c25a:	2102      	movs	r1, #2
   1c25c:	aa08      	add	r2, sp, #32
   1c25e:	f7fe fe54 	bl	1af0a <ble_att_read_group_type_rsp_write>
                                          BLE_ATT_READ_GROUP_TYPE_RSP_BASE_SZ,
                                          &rsp);
        BLE_ATT_LOG_CMD(1, "read group type rsp", conn_handle,
   1c262:	4b2c      	ldr	r3, [pc, #176]	; (1c314 <ble_att_svr_rx_read_group_type+0x2bc>)
   1c264:	9300      	str	r3, [sp, #0]
   1c266:	9b06      	ldr	r3, [sp, #24]
   1c268:	9301      	str	r3, [sp, #4]
   1c26a:	4b2b      	ldr	r3, [pc, #172]	; (1c318 <ble_att_svr_rx_read_group_type+0x2c0>)
   1c26c:	9302      	str	r3, [sp, #8]
   1c26e:	2104      	movs	r1, #4
   1c270:	2200      	movs	r2, #0
   1c272:	4b24      	ldr	r3, [pc, #144]	; (1c304 <ble_att_svr_rx_read_group_type+0x2ac>)
   1c274:	4824      	ldr	r0, [pc, #144]	; (1c308 <ble_att_svr_rx_read_group_type+0x2b0>)
   1c276:	f8cd 800c 	str.w	r8, [sp, #12]
   1c27a:	f000 ffd5 	bl	1d228 <log_printf>
   1c27e:	a808      	add	r0, sp, #32
   1c280:	f7fe fe48 	bl	1af14 <ble_att_read_group_type_rsp_log>
   1c284:	4820      	ldr	r0, [pc, #128]	; (1c308 <ble_att_svr_rx_read_group_type+0x2b0>)
   1c286:	4b21      	ldr	r3, [pc, #132]	; (1c30c <ble_att_svr_rx_read_group_type+0x2b4>)
   1c288:	2104      	movs	r1, #4
   1c28a:	2200      	movs	r2, #0
   1c28c:	f000 ffcc 	bl	1d228 <log_printf>
                        ble_att_read_group_type_rsp_log, &rsp);
        rc = 0;
   1c290:	2400      	movs	r4, #0
   1c292:	e001      	b.n	1c298 <ble_att_svr_rx_read_group_type+0x240>
        return BLE_HS_EBADDATA;
    }

    rc = ble_att_svr_pullup_req_base(rxom, pktlen, &att_err);
    if (rc != 0) {
        err_handle = 0;
   1c294:	2600      	movs	r6, #0
    uint16_t pktlen;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1c296:	4637      	mov	r7, r6
    }

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom,
   1c298:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   1c29c:	4640      	mov	r0, r8
   1c29e:	e88d 0048 	stmia.w	sp, {r3, r6}
   1c2a2:	4621      	mov	r1, r4
   1c2a4:	463a      	mov	r2, r7
   1c2a6:	2310      	movs	r3, #16
   1c2a8:	f7fe feec 	bl	1b084 <ble_att_svr_tx_rsp>
                            BLE_ATT_OP_READ_GROUP_TYPE_REQ, att_err,
                            err_handle);
    return rc;
   1c2ac:	e021      	b.n	1c2f2 <ble_att_svr_rx_read_group_type+0x29a>
    pktlen = OS_MBUF_PKTLEN(*rxom);
    if (pktlen != BLE_ATT_READ_GROUP_TYPE_REQ_SZ_16 &&
        pktlen != BLE_ATT_READ_GROUP_TYPE_REQ_SZ_128) {

        /* Malformed request; discard. */
        return BLE_HS_EBADDATA;
   1c2ae:	200a      	movs	r0, #10
   1c2b0:	e01f      	b.n	1c2f2 <ble_att_svr_rx_read_group_type+0x29a>
        *uuid16 = 0;
        memcpy(uuid128, ctxt.read.data, 16);
        return 0;

    case 2:
        *uuid16 = le16toh(ctxt.read.data);
   1c2b2:	9814      	ldr	r0, [sp, #80]	; 0x50
   1c2b4:	f000 feeb 	bl	1d08e <le16toh>
        if (*uuid16 == 0) {
   1c2b8:	4605      	mov	r5, r0
   1c2ba:	2800      	cmp	r0, #0
   1c2bc:	f43f af79 	beq.w	1c1b2 <ble_att_svr_rx_read_group_type+0x15a>
   1c2c0:	e7b6      	b.n	1c230 <ble_att_svr_rx_read_group_type+0x1d8>
                 * group has a different length UUID, then cut the response
                 * short.
                 */
                switch (rsp.bagp_length) {
                case 0:
                    if (service_uuid16 != 0) {
   1c2c2:	b10d      	cbz	r5, 1c2c8 <ble_att_svr_rx_read_group_type+0x270>
                        rsp.bagp_length = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_16;
   1c2c4:	2306      	movs	r3, #6
   1c2c6:	e000      	b.n	1c2ca <ble_att_svr_rx_read_group_type+0x272>
                    } else {
                        rsp.bagp_length = BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_128;
   1c2c8:	2314      	movs	r3, #20
   1c2ca:	f88d 3020 	strb.w	r3, [sp, #32]
   1c2ce:	e003      	b.n	1c2d8 <ble_att_svr_rx_read_group_type+0x280>
                    }
                    break;

                case BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_16:
                    if (service_uuid16 == 0) {
   1c2d0:	b915      	cbnz	r5, 1c2d8 <ble_att_svr_rx_read_group_type+0x280>
   1c2d2:	e7b5      	b.n	1c240 <ble_att_svr_rx_read_group_type+0x1e8>
                        goto done;
                    }
                    break;

                case BLE_ATT_READ_GROUP_TYPE_ADATA_SZ_128:
                    if (service_uuid16 != 0) {
   1c2d4:	2d00      	cmp	r5, #0
   1c2d6:	d1b3      	bne.n	1c240 <ble_att_svr_rx_read_group_type+0x1e8>
                default:
                    BLE_HS_DBG_ASSERT(0);
                    goto done;
                }

                start_group_handle = entry->ha_handle_id;
   1c2d8:	f8ba 2016 	ldrh.w	r2, [sl, #22]
                end_group_handle = entry->ha_handle_id;
   1c2dc:	4614      	mov	r4, r2
   1c2de:	e742      	b.n	1c166 <ble_att_svr_rx_read_group_type+0x10e>
            }
        }

        if (start_group_handle == 0) {
            /* We are looking for the start of a group. */
            if (memcmp(entry->ha_uuid, group_uuid128, 16) == 0) {
   1c2e0:	2200      	movs	r2, #0
   1c2e2:	e740      	b.n	1c166 <ble_att_svr_rx_read_group_type+0x10e>

    txom = NULL;

    mtu = ble_att_mtu(conn_handle);
    if (mtu == 0) {
        rc = BLE_HS_ENOTCONN;
   1c2e4:	2407      	movs	r4, #7
    end_group_handle = 0;

    *att_err = 0;
    *err_handle = req->bagq_start_handle;

    txom = NULL;
   1c2e6:	4607      	mov	r7, r0
   1c2e8:	e7d6      	b.n	1c298 <ble_att_svr_rx_read_group_type+0x240>

    rc = 0;

done:
    if (rc == 0) {
        if (start_group_handle != 0) {
   1c2ea:	2a00      	cmp	r2, #0
   1c2ec:	f47f af7e 	bne.w	1c1ec <ble_att_svr_rx_read_group_type+0x194>
   1c2f0:	e7a6      	b.n	1c240 <ble_att_svr_rx_read_group_type+0x1e8>
done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom,
                            BLE_ATT_OP_READ_GROUP_TYPE_REQ, att_err,
                            err_handle);
    return rc;
}
   1c2f2:	b017      	add	sp, #92	; 0x5c
   1c2f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c2f8:	000207e0 	.word	0x000207e0
   1c2fc:	0001fbda 	.word	0x0001fbda
   1c300:	000208a8 	.word	0x000208a8
   1c304:	0001fbbc 	.word	0x0001fbbc
   1c308:	20003b9c 	.word	0x20003b9c
   1c30c:	0001fdec 	.word	0x0001fdec
   1c310:	20002400 	.word	0x20002400
   1c314:	0001fe60 	.word	0x0001fe60
   1c318:	000208bc 	.word	0x000208bc

0001c31c <ble_att_svr_rx_write>:
    return rc;
}

int
ble_att_svr_rx_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c31c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1c320:	b08b      	sub	sp, #44	; 0x2c
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
   1c322:	af0a      	add	r7, sp, #40	; 0x28
   1c324:	2500      	movs	r5, #0
   1c326:	f807 5d15 	strb.w	r5, [r7, #-21]!
    return rc;
}

int
ble_att_svr_rx_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c32a:	4606      	mov	r6, r0
   1c32c:	4688      	mov	r8, r1
    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_WRITE_REQ_BASE_SZ,
   1c32e:	4608      	mov	r0, r1
   1c330:	463a      	mov	r2, r7
   1c332:	2103      	movs	r1, #3
   1c334:	f7fe fe9b 	bl	1b06e <ble_att_svr_pullup_req_base>
                                     &att_err);
    if (rc != 0) {
   1c338:	4604      	mov	r4, r0
   1c33a:	2800      	cmp	r0, #0
   1c33c:	d160      	bne.n	1c400 <ble_att_svr_rx_write+0xe4>
        err_handle = 0;
        goto done;
    }

    ble_att_write_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c33e:	f8d8 3000 	ldr.w	r3, [r8]
    BLE_ATT_LOG_CMD(0, "write req", conn_handle,
   1c342:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 1c438 <ble_att_svr_rx_write+0x11c>
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_write_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c346:	6818      	ldr	r0, [r3, #0]
   1c348:	88d9      	ldrh	r1, [r3, #6]
   1c34a:	aa05      	add	r2, sp, #20
   1c34c:	f7fe fdf2 	bl	1af34 <ble_att_write_req_parse>
    BLE_ATT_LOG_CMD(0, "write req", conn_handle,
   1c350:	4b32      	ldr	r3, [pc, #200]	; (1c41c <ble_att_svr_rx_write+0x100>)
   1c352:	9300      	str	r3, [sp, #0]
   1c354:	4b32      	ldr	r3, [pc, #200]	; (1c420 <ble_att_svr_rx_write+0x104>)
   1c356:	9302      	str	r3, [sp, #8]
   1c358:	4622      	mov	r2, r4
   1c35a:	2104      	movs	r1, #4
   1c35c:	4b31      	ldr	r3, [pc, #196]	; (1c424 <ble_att_svr_rx_write+0x108>)
   1c35e:	4832      	ldr	r0, [pc, #200]	; (1c428 <ble_att_svr_rx_write+0x10c>)
   1c360:	f8cd 9004 	str.w	r9, [sp, #4]
   1c364:	9603      	str	r6, [sp, #12]
   1c366:	f000 ff5f 	bl	1d228 <log_printf>
   1c36a:	a805      	add	r0, sp, #20
   1c36c:	f7fe fdea 	bl	1af44 <ble_att_write_cmd_log>
   1c370:	4622      	mov	r2, r4
   1c372:	4b2e      	ldr	r3, [pc, #184]	; (1c42c <ble_att_svr_rx_write+0x110>)
   1c374:	482c      	ldr	r0, [pc, #176]	; (1c428 <ble_att_svr_rx_write+0x10c>)
   1c376:	2104      	movs	r1, #4
   1c378:	f000 ff56 	bl	1d228 <log_printf>
                    ble_att_write_cmd_log, &req);

    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_WRITE_REQ_BASE_SZ);
   1c37c:	2103      	movs	r1, #3
   1c37e:	f8d8 0000 	ldr.w	r0, [r8]
   1c382:	f7ed fe9c 	bl	a0be <os_mbuf_adj>

    buf = ble_att_get_flat_buf();
   1c386:	f7fd fd31 	bl	19dec <ble_att_get_flat_buf>
   1c38a:	4603      	mov	r3, r0
    ctxt.write.len = OS_MBUF_PKTLEN(*rxom);
   1c38c:	f8d8 0000 	ldr.w	r0, [r8]
    ctxt.write.data = buf;
   1c390:	9306      	str	r3, [sp, #24]

    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_WRITE_REQ_BASE_SZ);

    buf = ble_att_get_flat_buf();
    ctxt.write.len = OS_MBUF_PKTLEN(*rxom);
   1c392:	8a02      	ldrh	r2, [r0, #16]
   1c394:	9208      	str	r2, [sp, #32]
    ctxt.write.data = buf;
    os_mbuf_copydata(*rxom, 0, ctxt.write.len, buf);
   1c396:	4621      	mov	r1, r4
   1c398:	f7ed fe6a 	bl	a070 <os_mbuf_copydata>

    rc = ble_att_svr_write_handle(conn_handle, req.bawq_handle, &ctxt,
   1c39c:	4630      	mov	r0, r6
   1c39e:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1c3a2:	aa06      	add	r2, sp, #24
   1c3a4:	463b      	mov	r3, r7
   1c3a6:	f7ff f861 	bl	1b46c <ble_att_svr_write_handle>
                                  &att_err);
    if (rc != 0) {
   1c3aa:	4604      	mov	r4, r0
   1c3ac:	b110      	cbz	r0, 1c3b4 <ble_att_svr_rx_write+0x98>
        err_handle = req.bawq_handle;
   1c3ae:	f8bd 3014 	ldrh.w	r3, [sp, #20]
        goto done;
   1c3b2:	e026      	b.n	1c402 <ble_att_svr_rx_write+0xe6>
{
    struct os_mbuf *txom;
    uint8_t *dst;
    int rc;

    txom = ble_hs_misc_pkthdr();
   1c3b4:	f7f9 f8ae 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1c3b8:	4605      	mov	r5, r0
   1c3ba:	b930      	cbnz	r0, 1c3ca <ble_att_svr_rx_write+0xae>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1c3bc:	2311      	movs	r3, #17
   1c3be:	f88d 3013 	strb.w	r3, [sp, #19]
    }

    rc = ble_att_svr_build_write_rsp(&txom, &att_err);
    if (rc != 0) {
        err_handle = req.bawq_handle;
        goto done;
   1c3c2:	2406      	movs	r4, #6
        goto done;
    }

    rc = ble_att_svr_build_write_rsp(&txom, &att_err);
    if (rc != 0) {
        err_handle = req.bawq_handle;
   1c3c4:	f8bd 3014 	ldrh.w	r3, [sp, #20]
        goto done;
   1c3c8:	e01b      	b.n	1c402 <ble_att_svr_rx_write+0xe6>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    dst = os_mbuf_extend(txom, BLE_ATT_WRITE_RSP_SZ);
   1c3ca:	2101      	movs	r1, #1
   1c3cc:	f7ed ff50 	bl	a270 <os_mbuf_extend>
    if (dst == NULL) {
   1c3d0:	2800      	cmp	r0, #0
   1c3d2:	d0f3      	beq.n	1c3bc <ble_att_svr_rx_write+0xa0>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    *dst = BLE_ATT_OP_WRITE_RSP;
   1c3d4:	2313      	movs	r3, #19
   1c3d6:	7003      	strb	r3, [r0, #0]
    rc = ble_att_svr_build_write_rsp(&txom, &att_err);
    if (rc != 0) {
        err_handle = req.bawq_handle;
        goto done;
    }
    BLE_ATT_LOG_EMPTY_CMD(1, "write rsp", conn_handle);
   1c3d8:	4b15      	ldr	r3, [pc, #84]	; (1c430 <ble_att_svr_rx_write+0x114>)
   1c3da:	4813      	ldr	r0, [pc, #76]	; (1c428 <ble_att_svr_rx_write+0x10c>)
   1c3dc:	9603      	str	r6, [sp, #12]
   1c3de:	e88d 0208 	stmia.w	sp, {r3, r9}
   1c3e2:	4b14      	ldr	r3, [pc, #80]	; (1c434 <ble_att_svr_rx_write+0x118>)
   1c3e4:	9302      	str	r3, [sp, #8]
   1c3e6:	2104      	movs	r1, #4
   1c3e8:	4622      	mov	r2, r4
   1c3ea:	4b0e      	ldr	r3, [pc, #56]	; (1c424 <ble_att_svr_rx_write+0x108>)
   1c3ec:	f000 ff1c 	bl	1d228 <log_printf>
   1c3f0:	4b0e      	ldr	r3, [pc, #56]	; (1c42c <ble_att_svr_rx_write+0x110>)
   1c3f2:	480d      	ldr	r0, [pc, #52]	; (1c428 <ble_att_svr_rx_write+0x10c>)
   1c3f4:	2104      	movs	r1, #4
   1c3f6:	4622      	mov	r2, r4
   1c3f8:	f000 ff16 	bl	1d228 <log_printf>
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
    att_err = 0;
    err_handle = 0;
   1c3fc:	4623      	mov	r3, r4
   1c3fe:	e000      	b.n	1c402 <ble_att_svr_rx_write+0xe6>

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_WRITE_REQ_BASE_SZ,
                                     &att_err);
    if (rc != 0) {
        err_handle = 0;
   1c400:	462b      	mov	r3, r5
    BLE_ATT_LOG_EMPTY_CMD(1, "write rsp", conn_handle);

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_WRITE_REQ,
   1c402:	f89d 2013 	ldrb.w	r2, [sp, #19]
   1c406:	4630      	mov	r0, r6
   1c408:	e88d 000c 	stmia.w	sp, {r2, r3}
   1c40c:	4621      	mov	r1, r4
   1c40e:	462a      	mov	r2, r5
   1c410:	2312      	movs	r3, #18
   1c412:	f7fe fe37 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);
    return rc;
}
   1c416:	b00b      	add	sp, #44	; 0x2c
   1c418:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1c41c:	0001fbda 	.word	0x0001fbda
   1c420:	000208fd 	.word	0x000208fd
   1c424:	0001fbbc 	.word	0x0001fbbc
   1c428:	20003b9c 	.word	0x20003b9c
   1c42c:	0001fdec 	.word	0x0001fdec
   1c430:	0001fe60 	.word	0x0001fe60
   1c434:	0002090c 	.word	0x0002090c
   1c438:	000207e0 	.word	0x000207e0

0001c43c <ble_att_svr_rx_write_no_rsp>:

int
ble_att_svr_rx_write_no_rsp(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c43c:	b570      	push	{r4, r5, r6, lr}
   1c43e:	b08a      	sub	sp, #40	; 0x28
   1c440:	4606      	mov	r6, r0
   1c442:	460d      	mov	r5, r1
    struct ble_att_write_req req;
    uint8_t att_err;
    void *buf;
    int rc;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_WRITE_REQ_BASE_SZ,
   1c444:	4608      	mov	r0, r1
   1c446:	f10d 0213 	add.w	r2, sp, #19
   1c44a:	2103      	movs	r1, #3
   1c44c:	f7fe fe0f 	bl	1b06e <ble_att_svr_pullup_req_base>
                                     &att_err);
    if (rc != 0) {
   1c450:	4604      	mov	r4, r0
   1c452:	2800      	cmp	r0, #0
   1c454:	d131      	bne.n	1c4ba <ble_att_svr_rx_write_no_rsp+0x7e>
        return rc;
    }

    ble_att_write_cmd_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c456:	682b      	ldr	r3, [r5, #0]
   1c458:	aa05      	add	r2, sp, #20
   1c45a:	6818      	ldr	r0, [r3, #0]
   1c45c:	88d9      	ldrh	r1, [r3, #6]
   1c45e:	f7fe fd6d 	bl	1af3c <ble_att_write_cmd_parse>
    BLE_ATT_LOG_CMD(0, "write cmd", conn_handle,
   1c462:	4b17      	ldr	r3, [pc, #92]	; (1c4c0 <ble_att_svr_rx_write_no_rsp+0x84>)
   1c464:	9300      	str	r3, [sp, #0]
   1c466:	4b17      	ldr	r3, [pc, #92]	; (1c4c4 <ble_att_svr_rx_write_no_rsp+0x88>)
   1c468:	9301      	str	r3, [sp, #4]
   1c46a:	4b17      	ldr	r3, [pc, #92]	; (1c4c8 <ble_att_svr_rx_write_no_rsp+0x8c>)
   1c46c:	9302      	str	r3, [sp, #8]
   1c46e:	2104      	movs	r1, #4
   1c470:	4622      	mov	r2, r4
   1c472:	4b16      	ldr	r3, [pc, #88]	; (1c4cc <ble_att_svr_rx_write_no_rsp+0x90>)
   1c474:	4816      	ldr	r0, [pc, #88]	; (1c4d0 <ble_att_svr_rx_write_no_rsp+0x94>)
   1c476:	9603      	str	r6, [sp, #12]
   1c478:	f000 fed6 	bl	1d228 <log_printf>
   1c47c:	a805      	add	r0, sp, #20
   1c47e:	f7fe fd61 	bl	1af44 <ble_att_write_cmd_log>
   1c482:	4622      	mov	r2, r4
   1c484:	4b13      	ldr	r3, [pc, #76]	; (1c4d4 <ble_att_svr_rx_write_no_rsp+0x98>)
   1c486:	4812      	ldr	r0, [pc, #72]	; (1c4d0 <ble_att_svr_rx_write_no_rsp+0x94>)
   1c488:	2104      	movs	r1, #4
   1c48a:	f000 fecd 	bl	1d228 <log_printf>
                    ble_att_write_cmd_log, &req);

    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_WRITE_REQ_BASE_SZ);
   1c48e:	2103      	movs	r1, #3
   1c490:	6828      	ldr	r0, [r5, #0]
   1c492:	f7ed fe14 	bl	a0be <os_mbuf_adj>

    buf = ble_att_get_flat_buf();
   1c496:	f7fd fca9 	bl	19dec <ble_att_get_flat_buf>
   1c49a:	4603      	mov	r3, r0
    ctxt.write.len = OS_MBUF_PKTLEN(*rxom);
   1c49c:	6828      	ldr	r0, [r5, #0]
    ctxt.write.data = buf;
   1c49e:	9306      	str	r3, [sp, #24]

    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_WRITE_REQ_BASE_SZ);

    buf = ble_att_get_flat_buf();
    ctxt.write.len = OS_MBUF_PKTLEN(*rxom);
   1c4a0:	8a02      	ldrh	r2, [r0, #16]
   1c4a2:	9208      	str	r2, [sp, #32]
    ctxt.write.data = buf;
    os_mbuf_copydata(*rxom, 0, ctxt.write.len, buf);
   1c4a4:	4621      	mov	r1, r4
   1c4a6:	f7ed fde3 	bl	a070 <os_mbuf_copydata>

    rc = ble_att_svr_write_handle(conn_handle, req.bawq_handle, &ctxt,
   1c4aa:	4630      	mov	r0, r6
   1c4ac:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1c4b0:	aa06      	add	r2, sp, #24
   1c4b2:	f10d 0313 	add.w	r3, sp, #19
   1c4b6:	f7fe ffd9 	bl	1b46c <ble_att_svr_write_handle>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
   1c4ba:	b00a      	add	sp, #40	; 0x28
   1c4bc:	bd70      	pop	{r4, r5, r6, pc}
   1c4be:	bf00      	nop
   1c4c0:	0001fbda 	.word	0x0001fbda
   1c4c4:	000207e0 	.word	0x000207e0
   1c4c8:	000208d0 	.word	0x000208d0
   1c4cc:	0001fbbc 	.word	0x0001fbbc
   1c4d0:	20003b9c 	.word	0x20003b9c
   1c4d4:	0001fdec 	.word	0x0001fdec

0001c4d8 <ble_att_svr_prep_clear>:
    return prev;
}

void
ble_att_svr_prep_clear(struct ble_att_prep_entry_list *prep_list)
{
   1c4d8:	b510      	push	{r4, lr}
   1c4da:	4604      	mov	r4, r0
    struct ble_att_prep_entry *entry;

    while ((entry = SLIST_FIRST(prep_list)) != NULL) {
   1c4dc:	6820      	ldr	r0, [r4, #0]
   1c4de:	b120      	cbz	r0, 1c4ea <ble_att_svr_prep_clear+0x12>
        SLIST_REMOVE_HEAD(prep_list, bape_next);
   1c4e0:	6803      	ldr	r3, [r0, #0]
   1c4e2:	6023      	str	r3, [r4, #0]
        ble_att_svr_prep_free(entry);
   1c4e4:	f7fe feac 	bl	1b240 <ble_att_svr_prep_free>
   1c4e8:	e7f8      	b.n	1c4dc <ble_att_svr_prep_clear+0x4>
    }
}
   1c4ea:	bd10      	pop	{r4, pc}

0001c4ec <ble_att_svr_rx_prep_write>:
    return 0;
}

int
ble_att_svr_rx_prep_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c4ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c4f0:	b087      	sub	sp, #28
    int rc;

    /* Initialize some values in case of early error. */
    prep_entry = NULL;
    txom = NULL;
    att_err = 0;
   1c4f2:	aa06      	add	r2, sp, #24
   1c4f4:	2400      	movs	r4, #0
    return 0;
}

int
ble_att_svr_rx_prep_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c4f6:	4681      	mov	r9, r0
   1c4f8:	460f      	mov	r7, r1
    prep_entry = NULL;
    txom = NULL;
    att_err = 0;
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ,
   1c4fa:	4608      	mov	r0, r1
    int rc;

    /* Initialize some values in case of early error. */
    prep_entry = NULL;
    txom = NULL;
    att_err = 0;
   1c4fc:	f802 4d05 	strb.w	r4, [r2, #-5]!
    err_handle = 0;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ,
   1c500:	2105      	movs	r1, #5
   1c502:	f7fe fdb4 	bl	1b06e <ble_att_svr_pullup_req_base>
                                     &att_err);
    if (rc != 0) {
   1c506:	4606      	mov	r6, r0
   1c508:	2800      	cmp	r0, #0
   1c50a:	f040 80e7 	bne.w	1c6dc <ble_att_svr_rx_prep_write+0x1f0>
        err_handle = 0;
        goto done;
    }

    ble_att_prep_write_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c50e:	683b      	ldr	r3, [r7, #0]
    BLE_ATT_LOG_CMD(0, "prep write req", conn_handle,
   1c510:	4d74      	ldr	r5, [pc, #464]	; (1c6e4 <ble_att_svr_rx_prep_write+0x1f8>)
    if (rc != 0) {
        err_handle = 0;
        goto done;
    }

    ble_att_prep_write_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c512:	6818      	ldr	r0, [r3, #0]
   1c514:	88d9      	ldrh	r1, [r3, #6]
   1c516:	aa05      	add	r2, sp, #20
   1c518:	f7fe fd24 	bl	1af64 <ble_att_prep_write_req_parse>
    BLE_ATT_LOG_CMD(0, "prep write req", conn_handle,
   1c51c:	4b72      	ldr	r3, [pc, #456]	; (1c6e8 <ble_att_svr_rx_prep_write+0x1fc>)
   1c51e:	9300      	str	r3, [sp, #0]
   1c520:	4b72      	ldr	r3, [pc, #456]	; (1c6ec <ble_att_svr_rx_prep_write+0x200>)
   1c522:	9302      	str	r3, [sp, #8]
   1c524:	2104      	movs	r1, #4
   1c526:	4632      	mov	r2, r6
   1c528:	4b71      	ldr	r3, [pc, #452]	; (1c6f0 <ble_att_svr_rx_prep_write+0x204>)
   1c52a:	4872      	ldr	r0, [pc, #456]	; (1c6f4 <ble_att_svr_rx_prep_write+0x208>)
   1c52c:	9501      	str	r5, [sp, #4]
   1c52e:	f8cd 900c 	str.w	r9, [sp, #12]
   1c532:	f000 fe79 	bl	1d228 <log_printf>
   1c536:	a805      	add	r0, sp, #20
   1c538:	f7fe fd34 	bl	1afa4 <ble_att_prep_write_cmd_log>
   1c53c:	4632      	mov	r2, r6
   1c53e:	4b6e      	ldr	r3, [pc, #440]	; (1c6f8 <ble_att_svr_rx_prep_write+0x20c>)
   1c540:	486c      	ldr	r0, [pc, #432]	; (1c6f4 <ble_att_svr_rx_prep_write+0x208>)
   1c542:	2104      	movs	r1, #4
   1c544:	f000 fe70 	bl	1d228 <log_printf>
                    ble_att_prep_write_cmd_log, &req);

    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ);
   1c548:	6838      	ldr	r0, [r7, #0]
   1c54a:	2105      	movs	r1, #5
   1c54c:	f7ed fdb7 	bl	a0be <os_mbuf_adj>

    attr_entry = ble_att_svr_find_by_handle(req.bapc_handle);
   1c550:	f8bd 4014 	ldrh.w	r4, [sp, #20]
   1c554:	4620      	mov	r0, r4
   1c556:	f7fe ff7f 	bl	1b458 <ble_att_svr_find_by_handle>
   1c55a:	46aa      	mov	sl, r5
    if (attr_entry == NULL) {
   1c55c:	b928      	cbnz	r0, 1c56a <ble_att_svr_rx_prep_write+0x7e>
        rc = BLE_HS_ENOENT;
        att_err = BLE_ATT_ERR_INVALID_HANDLE;
   1c55e:	2301      	movs	r3, #1
   1c560:	f88d 3013 	strb.w	r3, [sp, #19]
    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ);

    attr_entry = ble_att_svr_find_by_handle(req.bapc_handle);
    if (attr_entry == NULL) {
        rc = BLE_HS_ENOENT;
   1c564:	2605      	movs	r6, #5
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    prep_entry = NULL;
   1c566:	4683      	mov	fp, r0
    attr_entry = ble_att_svr_find_by_handle(req.bapc_handle);
    if (attr_entry == NULL) {
        rc = BLE_HS_ENOENT;
        att_err = BLE_ATT_ERR_INVALID_HANDLE;
        err_handle = req.bapc_handle;
        goto done;
   1c568:	e055      	b.n	1c616 <ble_att_svr_rx_prep_write+0x12a>
static struct ble_att_prep_entry *
ble_att_svr_prep_alloc(void)
{
    struct ble_att_prep_entry *entry;

    entry = os_memblock_get(&ble_att_svr_prep_entry_pool);
   1c56a:	4864      	ldr	r0, [pc, #400]	; (1c6fc <ble_att_svr_rx_prep_write+0x210>)
   1c56c:	f7ed ff44 	bl	a3f8 <os_memblock_get>
    if (entry == NULL) {
   1c570:	4683      	mov	fp, r0
   1c572:	2800      	cmp	r0, #0
   1c574:	d07a      	beq.n	1c66c <ble_att_svr_rx_prep_write+0x180>
        return NULL;
    }

    memset(entry, 0, sizeof *entry);
   1c576:	4631      	mov	r1, r6
   1c578:	220c      	movs	r2, #12
   1c57a:	f7ec fd4a 	bl	9012 <memset>
    entry->bape_value = ble_hs_misc_pkthdr();
   1c57e:	f7f8 ffc9 	bl	15514 <ble_hs_misc_pkthdr>
   1c582:	f8cb 0008 	str.w	r0, [fp, #8]
    if (entry->bape_value == NULL) {
   1c586:	b918      	cbnz	r0, 1c590 <ble_att_svr_rx_prep_write+0xa4>
        ble_att_svr_prep_free(entry);
   1c588:	4658      	mov	r0, fp
   1c58a:	f7fe fe59 	bl	1b240 <ble_att_svr_prep_free>
   1c58e:	e06d      	b.n	1c66c <ble_att_svr_rx_prep_write+0x180>
        att_err = BLE_ATT_ERR_PREPARE_QUEUE_FULL;
        err_handle = req.bapc_handle;
        rc = BLE_HS_ENOMEM;
        goto done;
    }
    prep_entry->bape_handle = req.bapc_handle;
   1c590:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1c594:	f8ab 3004 	strh.w	r3, [fp, #4]
    prep_entry->bape_offset = req.bapc_offset;
   1c598:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1c59c:	f8ab 3006 	strh.w	r3, [fp, #6]

    ble_hs_lock();
   1c5a0:	f7f8 f8d0 	bl	14744 <ble_hs_lock>

    conn = ble_hs_conn_find(conn_handle);
   1c5a4:	4648      	mov	r0, r9
   1c5a6:	f7f8 fe75 	bl	15294 <ble_hs_conn_find>
    if (conn == NULL) {
   1c5aa:	2800      	cmp	r0, #0
   1c5ac:	d077      	beq.n	1c69e <ble_att_svr_rx_prep_write+0x1b2>
   1c5ae:	6b02      	ldr	r2, [r0, #48]	; 0x30
        rc = BLE_HS_ENOTCONN;
    } else {
        prep_prev = ble_att_svr_prep_find_prev(&conn->bhc_att_svr,
   1c5b0:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1c5b4:	f8bd 4016 	ldrh.w	r4, [sp, #22]
{
    struct ble_att_prep_entry *entry;
    struct ble_att_prep_entry *prev;

    prev = NULL;
    SLIST_FOREACH(entry, &basc->basc_prep_list, bape_next) {
   1c5b8:	4613      	mov	r3, r2
                           uint16_t offset)
{
    struct ble_att_prep_entry *entry;
    struct ble_att_prep_entry *prev;

    prev = NULL;
   1c5ba:	46b0      	mov	r8, r6
    SLIST_FOREACH(entry, &basc->basc_prep_list, bape_next) {
   1c5bc:	b113      	cbz	r3, 1c5c4 <ble_att_svr_rx_prep_write+0xd8>
        if (entry->bape_handle > handle) {
   1c5be:	889d      	ldrh	r5, [r3, #4]
   1c5c0:	428d      	cmp	r5, r1
   1c5c2:	d95c      	bls.n	1c67e <ble_att_svr_rx_prep_write+0x192>
        rc = BLE_HS_ENOTCONN;
    } else {
        prep_prev = ble_att_svr_prep_find_prev(&conn->bhc_att_svr,
                                               req.bapc_handle,
                                               req.bapc_offset);
        if (prep_prev == NULL) {
   1c5c4:	f1b8 0f00 	cmp.w	r8, #0
   1c5c8:	d160      	bne.n	1c68c <ble_att_svr_rx_prep_write+0x1a0>
            SLIST_INSERT_HEAD(&conn->bhc_att_svr.basc_prep_list, prep_entry,
   1c5ca:	f8cb 2000 	str.w	r2, [fp]
   1c5ce:	f8c0 b030 	str.w	fp, [r0, #48]	; 0x30
        } else {
            SLIST_INSERT_AFTER(prep_prev, prep_entry, bape_next);
        }

        /* Append attribute value from request onto prep mbuf. */
        for (srcom = *rxom;
   1c5d2:	683c      	ldr	r4, [r7, #0]
   1c5d4:	b16c      	cbz	r4, 1c5f2 <ble_att_svr_rx_prep_write+0x106>
             srcom != NULL;
             srcom = SLIST_NEXT(srcom, om_next)) {

            rc = os_mbuf_append(prep_entry->bape_value, srcom->om_data,
   1c5d6:	f8db 0008 	ldr.w	r0, [fp, #8]
   1c5da:	6821      	ldr	r1, [r4, #0]
   1c5dc:	88e2      	ldrh	r2, [r4, #6]
   1c5de:	f7ed fcc7 	bl	9f70 <os_mbuf_append>
                                srcom->om_len);
            if (rc != 0) {
   1c5e2:	2800      	cmp	r0, #0
   1c5e4:	d059      	beq.n	1c69a <ble_att_svr_rx_prep_write+0x1ae>
                att_err = BLE_ATT_ERR_PREPARE_QUEUE_FULL;
   1c5e6:	2309      	movs	r3, #9
                err_handle = req.bapc_handle;
   1c5e8:	f8bd 4014 	ldrh.w	r4, [sp, #20]
             srcom = SLIST_NEXT(srcom, om_next)) {

            rc = os_mbuf_append(prep_entry->bape_value, srcom->om_data,
                                srcom->om_len);
            if (rc != 0) {
                att_err = BLE_ATT_ERR_PREPARE_QUEUE_FULL;
   1c5ec:	f88d 3013 	strb.w	r3, [sp, #19]
        /* Append attribute value from request onto prep mbuf. */
        for (srcom = *rxom;
             srcom != NULL;
             srcom = SLIST_NEXT(srcom, om_next)) {

            rc = os_mbuf_append(prep_entry->bape_value, srcom->om_data,
   1c5f0:	4606      	mov	r6, r0
                break;
            }
        }
    }

    ble_hs_unlock();
   1c5f2:	f7f8 f8af 	bl	14754 <ble_hs_unlock>

    if (rc != 0) {
   1c5f6:	2e00      	cmp	r6, #0
   1c5f8:	d171      	bne.n	1c6de <ble_att_svr_rx_prep_write+0x1f2>
    }

    /* The receive buffer now contains the attribute value.  Repurpose this
     * buffer for the response.  Prepend a response header.
     */
    *rxom = os_mbuf_prepend(*rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ);
   1c5fa:	6838      	ldr	r0, [r7, #0]
   1c5fc:	2105      	movs	r1, #5
   1c5fe:	f7ed fdd6 	bl	a1ae <os_mbuf_prepend>
   1c602:	4605      	mov	r5, r0
   1c604:	6038      	str	r0, [r7, #0]
    if (*rxom == NULL) {
   1c606:	2800      	cmp	r0, #0
   1c608:	d14c      	bne.n	1c6a4 <ble_att_svr_rx_prep_write+0x1b8>
        att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1c60a:	2311      	movs	r3, #17
        err_handle = req.bapc_handle;
   1c60c:	f8bd 4014 	ldrh.w	r4, [sp, #20]
    /* The receive buffer now contains the attribute value.  Repurpose this
     * buffer for the response.  Prepend a response header.
     */
    *rxom = os_mbuf_prepend(*rxom, BLE_ATT_PREP_WRITE_CMD_BASE_SZ);
    if (*rxom == NULL) {
        att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1c610:	f88d 3013 	strb.w	r3, [sp, #19]
        err_handle = req.bapc_handle;
        rc = BLE_HS_ENOMEM;
   1c614:	2606      	movs	r6, #6

    rc = 0;

done:
    if (rc != 0 && rc != BLE_HS_ENOTCONN) {
        ble_hs_lock();
   1c616:	f7f8 f895 	bl	14744 <ble_hs_lock>

        conn = ble_hs_conn_find(conn_handle);
   1c61a:	4648      	mov	r0, r9
   1c61c:	f7f8 fe3a 	bl	15294 <ble_hs_conn_find>
        if (conn == NULL) {
   1c620:	b188      	cbz	r0, 1c646 <ble_att_svr_rx_prep_write+0x15a>
            rc = BLE_HS_ENOTCONN;
        } else {
            if (prep_entry != NULL) {
   1c622:	f1bb 0f00 	cmp.w	fp, #0
   1c626:	d00f      	beq.n	1c648 <ble_att_svr_rx_prep_write+0x15c>
                if (prep_prev == NULL) {
   1c628:	f1b8 0f00 	cmp.w	r8, #0
   1c62c:	d103      	bne.n	1c636 <ble_att_svr_rx_prep_write+0x14a>
                    SLIST_REMOVE_HEAD(&conn->bhc_att_svr.basc_prep_list,
   1c62e:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1c630:	681b      	ldr	r3, [r3, #0]
   1c632:	6303      	str	r3, [r0, #48]	; 0x30
   1c634:	e003      	b.n	1c63e <ble_att_svr_rx_prep_write+0x152>
                                      bape_next);
                } else {
                    SLIST_NEXT(prep_prev, bape_next) =
                        SLIST_NEXT(prep_entry, bape_next);
   1c636:	f8db 3000 	ldr.w	r3, [fp]
            if (prep_entry != NULL) {
                if (prep_prev == NULL) {
                    SLIST_REMOVE_HEAD(&conn->bhc_att_svr.basc_prep_list,
                                      bape_next);
                } else {
                    SLIST_NEXT(prep_prev, bape_next) =
   1c63a:	f8c8 3000 	str.w	r3, [r8]
                        SLIST_NEXT(prep_entry, bape_next);
                }

                ble_att_svr_prep_free(prep_entry);
   1c63e:	4658      	mov	r0, fp
   1c640:	f7fe fdfe 	bl	1b240 <ble_att_svr_prep_free>
   1c644:	e000      	b.n	1c648 <ble_att_svr_rx_prep_write+0x15c>
    if (rc != 0 && rc != BLE_HS_ENOTCONN) {
        ble_hs_lock();

        conn = ble_hs_conn_find(conn_handle);
        if (conn == NULL) {
            rc = BLE_HS_ENOTCONN;
   1c646:	2607      	movs	r6, #7

                ble_att_svr_prep_free(prep_entry);
            }
        }

        ble_hs_unlock();
   1c648:	f7f8 f884 	bl	14754 <ble_hs_unlock>
   1c64c:	2500      	movs	r5, #0
    }

    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_PREP_WRITE_REQ,
   1c64e:	f89d 3013 	ldrb.w	r3, [sp, #19]
   1c652:	4648      	mov	r0, r9
   1c654:	e88d 0018 	stmia.w	sp, {r3, r4}
   1c658:	4631      	mov	r1, r6
   1c65a:	462a      	mov	r2, r5
   1c65c:	2316      	movs	r3, #22
   1c65e:	f7fe fd11 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);

    /* Make sure the receive buffer doesn't get freed since we are using it for
     * the response.
     */
    *rxom = NULL;
   1c662:	2300      	movs	r3, #0
   1c664:	603b      	str	r3, [r7, #0]
    return rc;
}
   1c666:	b007      	add	sp, #28
   1c668:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto done;
    }

    prep_entry = ble_att_svr_prep_alloc();
    if (prep_entry == NULL) {
        att_err = BLE_ATT_ERR_PREPARE_QUEUE_FULL;
   1c66c:	2309      	movs	r3, #9
   1c66e:	f88d 3013 	strb.w	r3, [sp, #19]
        err_handle = req.bapc_handle;
   1c672:	f8bd 4014 	ldrh.w	r4, [sp, #20]
        rc = BLE_HS_ENOMEM;
   1c676:	2606      	movs	r6, #6
        goto done;
   1c678:	f04f 0b00 	mov.w	fp, #0
   1c67c:	e7cb      	b.n	1c616 <ble_att_svr_rx_prep_write+0x12a>
    SLIST_FOREACH(entry, &basc->basc_prep_list, bape_next) {
        if (entry->bape_handle > handle) {
            break;
        }

        if (entry->bape_handle == handle && entry->bape_offset > offset) {
   1c67e:	d102      	bne.n	1c686 <ble_att_svr_rx_prep_write+0x19a>
   1c680:	88dd      	ldrh	r5, [r3, #6]
   1c682:	42a5      	cmp	r5, r4
   1c684:	d89e      	bhi.n	1c5c4 <ble_att_svr_rx_prep_write+0xd8>
{
    struct ble_att_prep_entry *entry;
    struct ble_att_prep_entry *prev;

    prev = NULL;
    SLIST_FOREACH(entry, &basc->basc_prep_list, bape_next) {
   1c686:	4698      	mov	r8, r3
   1c688:	681b      	ldr	r3, [r3, #0]
   1c68a:	e797      	b.n	1c5bc <ble_att_svr_rx_prep_write+0xd0>
                                               req.bapc_offset);
        if (prep_prev == NULL) {
            SLIST_INSERT_HEAD(&conn->bhc_att_svr.basc_prep_list, prep_entry,
                              bape_next);
        } else {
            SLIST_INSERT_AFTER(prep_prev, prep_entry, bape_next);
   1c68c:	f8d8 3000 	ldr.w	r3, [r8]
   1c690:	f8cb 3000 	str.w	r3, [fp]
   1c694:	f8c8 b000 	str.w	fp, [r8]
   1c698:	e79b      	b.n	1c5d2 <ble_att_svr_rx_prep_write+0xe6>
        }

        /* Append attribute value from request onto prep mbuf. */
        for (srcom = *rxom;
             srcom != NULL;
             srcom = SLIST_NEXT(srcom, om_next)) {
   1c69a:	68e4      	ldr	r4, [r4, #12]
   1c69c:	e79a      	b.n	1c5d4 <ble_att_svr_rx_prep_write+0xe8>

    ble_hs_lock();

    conn = ble_hs_conn_find(conn_handle);
    if (conn == NULL) {
        rc = BLE_HS_ENOTCONN;
   1c69e:	2607      	movs	r6, #7

    /* Initialize some values in case of early error. */
    prep_entry = NULL;
    txom = NULL;
    att_err = 0;
    err_handle = 0;
   1c6a0:	4604      	mov	r4, r0
   1c6a2:	e7a6      	b.n	1c5f2 <ble_att_svr_rx_prep_write+0x106>
        rc = BLE_HS_ENOMEM;
        goto done;
    }
    txom = *rxom;

    ble_att_prep_write_rsp_write(txom->om_data, BLE_ATT_PREP_WRITE_CMD_BASE_SZ,
   1c6a4:	aa05      	add	r2, sp, #20
   1c6a6:	6800      	ldr	r0, [r0, #0]
   1c6a8:	2105      	movs	r1, #5
   1c6aa:	f7fe fc72 	bl	1af92 <ble_att_prep_write_rsp_write>
                                 &req);
    BLE_ATT_LOG_CMD(1, "prep write rsp", conn_handle,
   1c6ae:	4b14      	ldr	r3, [pc, #80]	; (1c700 <ble_att_svr_rx_prep_write+0x214>)
   1c6b0:	f8cd 900c 	str.w	r9, [sp, #12]
   1c6b4:	e88d 0408 	stmia.w	sp, {r3, sl}
   1c6b8:	4b12      	ldr	r3, [pc, #72]	; (1c704 <ble_att_svr_rx_prep_write+0x218>)
   1c6ba:	9302      	str	r3, [sp, #8]
   1c6bc:	4632      	mov	r2, r6
   1c6be:	2104      	movs	r1, #4
   1c6c0:	4b0b      	ldr	r3, [pc, #44]	; (1c6f0 <ble_att_svr_rx_prep_write+0x204>)
   1c6c2:	480c      	ldr	r0, [pc, #48]	; (1c6f4 <ble_att_svr_rx_prep_write+0x208>)
   1c6c4:	f000 fdb0 	bl	1d228 <log_printf>
   1c6c8:	a805      	add	r0, sp, #20
   1c6ca:	f7fe fc6b 	bl	1afa4 <ble_att_prep_write_cmd_log>
   1c6ce:	4809      	ldr	r0, [pc, #36]	; (1c6f4 <ble_att_svr_rx_prep_write+0x208>)
   1c6d0:	4b09      	ldr	r3, [pc, #36]	; (1c6f8 <ble_att_svr_rx_prep_write+0x20c>)
   1c6d2:	2104      	movs	r1, #4
   1c6d4:	4632      	mov	r2, r6
   1c6d6:	f000 fda7 	bl	1d228 <log_printf>
   1c6da:	e7b8      	b.n	1c64e <ble_att_svr_rx_prep_write+0x162>
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    prep_entry = NULL;
   1c6dc:	46a3      	mov	fp, r4
                    ble_att_prep_write_cmd_log, &req);

    rc = 0;

done:
    if (rc != 0 && rc != BLE_HS_ENOTCONN) {
   1c6de:	2e07      	cmp	r6, #7
   1c6e0:	d199      	bne.n	1c616 <ble_att_svr_rx_prep_write+0x12a>
   1c6e2:	e7b3      	b.n	1c64c <ble_att_svr_rx_prep_write+0x160>
   1c6e4:	000207e0 	.word	0x000207e0
   1c6e8:	0001fbda 	.word	0x0001fbda
   1c6ec:	000208da 	.word	0x000208da
   1c6f0:	0001fbbc 	.word	0x0001fbbc
   1c6f4:	20003b9c 	.word	0x20003b9c
   1c6f8:	0001fdec 	.word	0x0001fdec
   1c6fc:	200023e0 	.word	0x200023e0
   1c700:	0001fe60 	.word	0x0001fe60
   1c704:	000208e9 	.word	0x000208e9

0001c708 <ble_att_svr_rx_exec_write>:
    return rc;
}

int
ble_att_svr_rx_exec_write(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c70c:	b08b      	sub	sp, #44	; 0x2c
   1c70e:	4680      	mov	r8, r0
   1c710:	460c      	mov	r4, r1
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_EXEC_WRITE_REQ_SZ,
   1c712:	4608      	mov	r0, r1
   1c714:	f10d 0212 	add.w	r2, sp, #18
   1c718:	2102      	movs	r1, #2
   1c71a:	f7fe fca8 	bl	1b06e <ble_att_svr_pullup_req_base>
                                     &att_err);
    if (rc != 0) {
   1c71e:	4606      	mov	r6, r0
   1c720:	2800      	cmp	r0, #0
   1c722:	f040 80a0 	bne.w	1c866 <ble_att_svr_rx_exec_write+0x15e>
        err_handle = 0;
        goto done;
    }

    ble_att_exec_write_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c726:	6823      	ldr	r3, [r4, #0]
   1c728:	aa04      	add	r2, sp, #16
   1c72a:	6818      	ldr	r0, [r3, #0]
   1c72c:	88d9      	ldrh	r1, [r3, #6]
   1c72e:	f7fe fc4b 	bl	1afc8 <ble_att_exec_write_req_parse>
    BLE_ATT_LOG_CMD(0, "exec write req", conn_handle,
   1c732:	4b56      	ldr	r3, [pc, #344]	; (1c88c <ble_att_svr_rx_exec_write+0x184>)
   1c734:	9300      	str	r3, [sp, #0]
   1c736:	4b56      	ldr	r3, [pc, #344]	; (1c890 <ble_att_svr_rx_exec_write+0x188>)
   1c738:	9301      	str	r3, [sp, #4]
   1c73a:	4b56      	ldr	r3, [pc, #344]	; (1c894 <ble_att_svr_rx_exec_write+0x18c>)
   1c73c:	9302      	str	r3, [sp, #8]
   1c73e:	2104      	movs	r1, #4
   1c740:	4632      	mov	r2, r6
   1c742:	4b55      	ldr	r3, [pc, #340]	; (1c898 <ble_att_svr_rx_exec_write+0x190>)
   1c744:	4855      	ldr	r0, [pc, #340]	; (1c89c <ble_att_svr_rx_exec_write+0x194>)
   1c746:	f8cd 800c 	str.w	r8, [sp, #12]
   1c74a:	f000 fd6d 	bl	1d228 <log_printf>
   1c74e:	a804      	add	r0, sp, #16
   1c750:	f7fe fc42 	bl	1afd8 <ble_att_exec_write_req_log>
   1c754:	4851      	ldr	r0, [pc, #324]	; (1c89c <ble_att_svr_rx_exec_write+0x194>)
   1c756:	4b52      	ldr	r3, [pc, #328]	; (1c8a0 <ble_att_svr_rx_exec_write+0x198>)
   1c758:	2104      	movs	r1, #4
   1c75a:	4632      	mov	r2, r6
   1c75c:	f000 fd64 	bl	1d228 <log_printf>
{
    struct os_mbuf *txom;
    uint8_t *dst;
    int rc;

    txom = ble_hs_misc_pkthdr();
   1c760:	f7f8 fed8 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1c764:	4681      	mov	r9, r0
   1c766:	b920      	cbnz	r0, 1c772 <ble_att_svr_rx_exec_write+0x6a>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
   1c768:	2311      	movs	r3, #17
   1c76a:	f88d 3012 	strb.w	r3, [sp, #18]
   1c76e:	2606      	movs	r6, #6
   1c770:	e07b      	b.n	1c86a <ble_att_svr_rx_exec_write+0x162>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    dst = os_mbuf_extend(txom, BLE_ATT_EXEC_WRITE_RSP_SZ);
   1c772:	2101      	movs	r1, #1
   1c774:	f7ed fd7c 	bl	a270 <os_mbuf_extend>
    if (dst == NULL) {
   1c778:	2800      	cmp	r0, #0
   1c77a:	d0f5      	beq.n	1c768 <ble_att_svr_rx_exec_write+0x60>
        *att_err = BLE_ATT_ERR_INSUFFICIENT_RES;
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_att_exec_write_rsp_write(dst, BLE_ATT_EXEC_WRITE_RSP_SZ);
   1c77c:	2101      	movs	r1, #1
   1c77e:	f7fe fc3c 	bl	1affa <ble_att_exec_write_rsp_write>

    rc = 0;

done:
    if (rc == 0) {
        ble_hs_lock();
   1c782:	f7f7 ffdf 	bl	14744 <ble_hs_lock>
        conn = ble_hs_conn_find(conn_handle);
   1c786:	4640      	mov	r0, r8
   1c788:	f7f8 fd84 	bl	15294 <ble_hs_conn_find>
        if (conn == NULL) {
   1c78c:	4604      	mov	r4, r0
   1c78e:	b118      	cbz	r0, 1c798 <ble_att_svr_rx_exec_write+0x90>
            /* Extract the list of prepared writes from the connection so
             * that they can be processed after the mutex is unlocked.  They
             * aren't processed now because attribute writes involve executing
             * an application callback.
             */
            prep_list = conn->bhc_att_svr.basc_prep_list;
   1c790:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1c792:	9305      	str	r3, [sp, #20]
            SLIST_INIT(&conn->bhc_att_svr.basc_prep_list);
   1c794:	6306      	str	r6, [r0, #48]	; 0x30
   1c796:	e000      	b.n	1c79a <ble_att_svr_rx_exec_write+0x92>
done:
    if (rc == 0) {
        ble_hs_lock();
        conn = ble_hs_conn_find(conn_handle);
        if (conn == NULL) {
            rc = BLE_HS_ENOTCONN;
   1c798:	2607      	movs	r6, #7
             * an application callback.
             */
            prep_list = conn->bhc_att_svr.basc_prep_list;
            SLIST_INIT(&conn->bhc_att_svr.basc_prep_list);
        }
        ble_hs_unlock();
   1c79a:	f7f7 ffdb 	bl	14754 <ble_hs_unlock>

        if (conn != NULL) {
   1c79e:	2c00      	cmp	r4, #0
   1c7a0:	d054      	beq.n	1c84c <ble_att_svr_rx_exec_write+0x144>
            if (req.baeq_flags & BLE_ATT_EXEC_WRITE_F_CONFIRM) {
   1c7a2:	f89d 4010 	ldrb.w	r4, [sp, #16]
   1c7a6:	f014 0401 	ands.w	r4, r4, #1
   1c7aa:	d04c      	beq.n	1c846 <ble_att_svr_rx_exec_write+0x13e>
    struct ble_att_prep_entry *entry;
    struct ble_att_prep_entry *prev;
    int cur_len;

    prev = NULL;
    SLIST_FOREACH(entry, prep_list, bape_next) {
   1c7ac:	9d05      	ldr	r5, [sp, #20]
{
    struct ble_att_prep_entry *entry;
    struct ble_att_prep_entry *prev;
    int cur_len;

    prev = NULL;
   1c7ae:	2300      	movs	r3, #0
    SLIST_FOREACH(entry, prep_list, bape_next) {
   1c7b0:	2d00      	cmp	r5, #0
   1c7b2:	d05e      	beq.n	1c872 <ble_att_svr_rx_exec_write+0x16a>
   1c7b4:	88ea      	ldrh	r2, [r5, #6]
        if (prev == NULL || prev->bape_handle != entry->bape_handle) {
   1c7b6:	b11b      	cbz	r3, 1c7c0 <ble_att_svr_rx_exec_write+0xb8>
   1c7b8:	889c      	ldrh	r4, [r3, #4]
   1c7ba:	88a9      	ldrh	r1, [r5, #4]
   1c7bc:	42a1      	cmp	r1, r4
   1c7be:	d002      	beq.n	1c7c6 <ble_att_svr_rx_exec_write+0xbe>
            /* Ensure attribute write starts at offset 0. */
            if (entry->bape_offset != 0) {
   1c7c0:	b13a      	cbz	r2, 1c7d2 <ble_att_svr_rx_exec_write+0xca>
                *err_handle = entry->bape_handle;
   1c7c2:	88ac      	ldrh	r4, [r5, #4]
   1c7c4:	e053      	b.n	1c86e <ble_att_svr_rx_exec_write+0x166>
                return BLE_ATT_ERR_INVALID_OFFSET;
            }
        } else {
            /* Ensure entry continues where previous left off. */
            if (prev->bape_offset + OS_MBUF_PKTLEN(prev->bape_value) !=
   1c7c6:	88d9      	ldrh	r1, [r3, #6]
   1c7c8:	689b      	ldr	r3, [r3, #8]
   1c7ca:	8a1b      	ldrh	r3, [r3, #16]
   1c7cc:	440b      	add	r3, r1
   1c7ce:	4293      	cmp	r3, r2
   1c7d0:	d14d      	bne.n	1c86e <ble_att_svr_rx_exec_write+0x166>
                *err_handle = entry->bape_handle;
                return BLE_ATT_ERR_INVALID_OFFSET;
            }
        }

        cur_len = entry->bape_offset + OS_MBUF_PKTLEN(entry->bape_value);
   1c7d2:	68ab      	ldr	r3, [r5, #8]
   1c7d4:	8a1b      	ldrh	r3, [r3, #16]
   1c7d6:	4413      	add	r3, r2
        if (cur_len > BLE_ATT_ATTR_MAX_LEN) {
   1c7d8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1c7dc:	dd02      	ble.n	1c7e4 <ble_att_svr_rx_exec_write+0xdc>
            *err_handle = entry->bape_handle;
   1c7de:	88ac      	ldrh	r4, [r5, #4]
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
   1c7e0:	230d      	movs	r3, #13
   1c7e2:	e02b      	b.n	1c83c <ble_att_svr_rx_exec_write+0x134>
    struct ble_att_prep_entry *entry;
    struct ble_att_prep_entry *prev;
    int cur_len;

    prev = NULL;
    SLIST_FOREACH(entry, prep_list, bape_next) {
   1c7e4:	462b      	mov	r3, r5
   1c7e6:	682d      	ldr	r5, [r5, #0]
   1c7e8:	e7e2      	b.n	1c7b0 <ble_att_svr_rx_exec_write+0xa8>
                              flat_buf + buf_off);
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
        buf_off += OS_MBUF_PKTLEN(entry->bape_value);

        /* If this is the last entry for this attribute, perform the write. */
        if (next == NULL || entry->bape_handle != next->bape_handle) {
   1c7ea:	f8bb 3004 	ldrh.w	r3, [fp, #4]
   1c7ee:	429c      	cmp	r4, r3
   1c7f0:	d112      	bne.n	1c818 <ble_att_svr_rx_exec_write+0x110>

    /* Contents are valid; perform the writes. */
    buf_off = 0;
    entry = SLIST_FIRST(prep_list);
    while (entry != NULL) {
        next = SLIST_NEXT(entry, bape_next);
   1c7f2:	465f      	mov	r7, fp
    flat_buf = ble_att_get_flat_buf();

    /* Contents are valid; perform the writes. */
    buf_off = 0;
    entry = SLIST_FIRST(prep_list);
    while (entry != NULL) {
   1c7f4:	2f00      	cmp	r7, #0
   1c7f6:	d043      	beq.n	1c880 <ble_att_svr_rx_exec_write+0x178>
        next = SLIST_NEXT(entry, bape_next);

        rc = os_mbuf_copydata(entry->bape_value, 0,
   1c7f8:	68b8      	ldr	r0, [r7, #8]

    /* Contents are valid; perform the writes. */
    buf_off = 0;
    entry = SLIST_FIRST(prep_list);
    while (entry != NULL) {
        next = SLIST_NEXT(entry, bape_next);
   1c7fa:	f8d7 b000 	ldr.w	fp, [r7]

        rc = os_mbuf_copydata(entry->bape_value, 0,
   1c7fe:	8a02      	ldrh	r2, [r0, #16]
   1c800:	eb0a 0305 	add.w	r3, sl, r5
   1c804:	2100      	movs	r1, #0
   1c806:	f7ed fc33 	bl	a070 <os_mbuf_copydata>
                              OS_MBUF_PKTLEN(entry->bape_value),
                              flat_buf + buf_off);
        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
        buf_off += OS_MBUF_PKTLEN(entry->bape_value);
   1c80a:	68bb      	ldr	r3, [r7, #8]
   1c80c:	88bc      	ldrh	r4, [r7, #4]
   1c80e:	8a1b      	ldrh	r3, [r3, #16]
   1c810:	441d      	add	r5, r3

        /* If this is the last entry for this attribute, perform the write. */
        if (next == NULL || entry->bape_handle != next->bape_handle) {
   1c812:	f1bb 0f00 	cmp.w	fp, #0
   1c816:	d1e8      	bne.n	1c7ea <ble_att_svr_rx_exec_write+0xe2>
            attr = ble_att_svr_find_by_handle(entry->bape_handle);
   1c818:	4620      	mov	r0, r4
   1c81a:	f7fe fe1d 	bl	1b458 <ble_att_svr_find_by_handle>
            if (attr == NULL) {
   1c81e:	4601      	mov	r1, r0
   1c820:	b388      	cbz	r0, 1c886 <ble_att_svr_rx_exec_write+0x17e>
                return BLE_ATT_ERR_INVALID_HANDLE;
            }

            ctxt.write.data = flat_buf;
            ctxt.write.len = buf_off;
            rc = ble_att_svr_write(conn_handle, attr, &ctxt, &att_err);
   1c822:	4640      	mov	r0, r8
   1c824:	aa06      	add	r2, sp, #24
   1c826:	f10d 0313 	add.w	r3, sp, #19
            if (attr == NULL) {
                *err_handle = entry->bape_handle;
                return BLE_ATT_ERR_INVALID_HANDLE;
            }

            ctxt.write.data = flat_buf;
   1c82a:	f8cd a018 	str.w	sl, [sp, #24]
            ctxt.write.len = buf_off;
   1c82e:	9508      	str	r5, [sp, #32]
            rc = ble_att_svr_write(conn_handle, attr, &ctxt, &att_err);
   1c830:	f7fe fd53 	bl	1b2da <ble_att_svr_write>
            if (rc != 0) {
   1c834:	b310      	cbz	r0, 1c87c <ble_att_svr_rx_exec_write+0x174>
                *err_handle = entry->bape_handle;
   1c836:	88bc      	ldrh	r4, [r7, #4]
                return att_err;
   1c838:	f89d 3013 	ldrb.w	r3, [sp, #19]
        ble_hs_unlock();

        if (conn != NULL) {
            if (req.baeq_flags & BLE_ATT_EXEC_WRITE_F_CONFIRM) {
                /* Perform attribute writes. */
                att_err = ble_att_svr_prep_write(conn_handle, &prep_list,
   1c83c:	f88d 3012 	strb.w	r3, [sp, #18]
                                                 &err_handle);
                if (att_err != 0) {
                    rc = BLE_HS_EAPP;
   1c840:	2b00      	cmp	r3, #0
   1c842:	bf18      	it	ne
   1c844:	2609      	movne	r6, #9
                }
            }

            /* Free the prep entries. */
            ble_att_svr_prep_clear(&prep_list);
   1c846:	a805      	add	r0, sp, #20
   1c848:	f7ff fe46 	bl	1c4d8 <ble_att_svr_prep_clear>
        }
    }

    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_EXEC_WRITE_REQ,
   1c84c:	f89d 3012 	ldrb.w	r3, [sp, #18]
   1c850:	4640      	mov	r0, r8
   1c852:	e88d 0018 	stmia.w	sp, {r3, r4}
   1c856:	4631      	mov	r1, r6
   1c858:	464a      	mov	r2, r9
   1c85a:	2318      	movs	r3, #24
   1c85c:	f7fe fc12 	bl	1b084 <ble_att_svr_tx_rsp>
                            att_err, err_handle);
    return rc;
}
   1c860:	b00b      	add	sp, #44	; 0x2c
   1c862:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint16_t err_handle;
    uint8_t att_err;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1c866:	f04f 0900 	mov.w	r9, #0
            if (req.baeq_flags & BLE_ATT_EXEC_WRITE_F_CONFIRM) {
                /* Perform attribute writes. */
                att_err = ble_att_svr_prep_write(conn_handle, &prep_list,
                                                 &err_handle);
                if (att_err != 0) {
                    rc = BLE_HS_EAPP;
   1c86a:	2400      	movs	r4, #0
   1c86c:	e7ee      	b.n	1c84c <ble_att_svr_rx_exec_write+0x144>
            /* Ensure entry continues where previous left off. */
            if (prev->bape_offset + OS_MBUF_PKTLEN(prev->bape_value) !=
                entry->bape_offset) {

                *err_handle = entry->bape_handle;
                return BLE_ATT_ERR_INVALID_OFFSET;
   1c86e:	2307      	movs	r3, #7
   1c870:	e7e4      	b.n	1c83c <ble_att_svr_rx_exec_write+0x134>
    rc = ble_att_svr_prep_validate(prep_list, err_handle);
    if (rc != 0) {
        return rc;
    }

    flat_buf = ble_att_get_flat_buf();
   1c872:	f7fd fabb 	bl	19dec <ble_att_get_flat_buf>

    /* Contents are valid; perform the writes. */
    buf_off = 0;
    entry = SLIST_FIRST(prep_list);
   1c876:	9f05      	ldr	r7, [sp, #20]
    rc = ble_att_svr_prep_validate(prep_list, err_handle);
    if (rc != 0) {
        return rc;
    }

    flat_buf = ble_att_get_flat_buf();
   1c878:	4682      	mov	sl, r0
   1c87a:	e7bb      	b.n	1c7f4 <ble_att_svr_rx_exec_write+0xec>
            if (rc != 0) {
                *err_handle = entry->bape_handle;
                return att_err;
            }

            buf_off = 0;
   1c87c:	4605      	mov	r5, r0
   1c87e:	e7b8      	b.n	1c7f2 <ble_att_svr_rx_exec_write+0xea>
    uint8_t *flat_buf;
    uint8_t att_err;
    int buf_off;
    int rc;

    *err_handle = 0; /* Silence unnecessary warning. */
   1c880:	463c      	mov	r4, r7
        }

        entry = next;
    }

    return 0;
   1c882:	463b      	mov	r3, r7
   1c884:	e7da      	b.n	1c83c <ble_att_svr_rx_exec_write+0x134>
        /* If this is the last entry for this attribute, perform the write. */
        if (next == NULL || entry->bape_handle != next->bape_handle) {
            attr = ble_att_svr_find_by_handle(entry->bape_handle);
            if (attr == NULL) {
                *err_handle = entry->bape_handle;
                return BLE_ATT_ERR_INVALID_HANDLE;
   1c886:	2301      	movs	r3, #1
   1c888:	e7d8      	b.n	1c83c <ble_att_svr_rx_exec_write+0x134>
   1c88a:	bf00      	nop
   1c88c:	0001fbda 	.word	0x0001fbda
   1c890:	000207e0 	.word	0x000207e0
   1c894:	000208f8 	.word	0x000208f8
   1c898:	0001fbbc 	.word	0x0001fbbc
   1c89c:	20003b9c 	.word	0x20003b9c
   1c8a0:	0001fdec 	.word	0x0001fdec

0001c8a4 <ble_att_svr_rx_notify>:
    return rc;
}

int
ble_att_svr_rx_notify(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c8a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct ble_att_notify_req req;
    uint16_t attr_len;
    void *attr_data;
    int rc;

    if (OS_MBUF_PKTLEN(*rxom) < BLE_ATT_NOTIFY_REQ_BASE_SZ) {
   1c8a6:	680b      	ldr	r3, [r1, #0]
   1c8a8:	8a1b      	ldrh	r3, [r3, #16]
   1c8aa:	2b02      	cmp	r3, #2
    return rc;
}

int
ble_att_svr_rx_notify(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c8ac:	b087      	sub	sp, #28
   1c8ae:	4607      	mov	r7, r0
   1c8b0:	460d      	mov	r5, r1
    struct ble_att_notify_req req;
    uint16_t attr_len;
    void *attr_data;
    int rc;

    if (OS_MBUF_PKTLEN(*rxom) < BLE_ATT_NOTIFY_REQ_BASE_SZ) {
   1c8b2:	d801      	bhi.n	1c8b8 <ble_att_svr_rx_notify+0x14>
        return BLE_HS_EBADDATA;
   1c8b4:	200a      	movs	r0, #10
   1c8b6:	e040      	b.n	1c93a <ble_att_svr_rx_notify+0x96>
    }

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_NOTIFY_REQ_BASE_SZ, NULL);
   1c8b8:	4608      	mov	r0, r1
   1c8ba:	2200      	movs	r2, #0
   1c8bc:	2103      	movs	r1, #3
   1c8be:	f7fe fbd6 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1c8c2:	4604      	mov	r4, r0
   1c8c4:	2800      	cmp	r0, #0
   1c8c6:	d137      	bne.n	1c938 <ble_att_svr_rx_notify+0x94>
        return BLE_HS_ENOMEM;
    }

    ble_att_notify_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c8c8:	682b      	ldr	r3, [r5, #0]
   1c8ca:	aa05      	add	r2, sp, #20
   1c8cc:	6818      	ldr	r0, [r3, #0]
   1c8ce:	88d9      	ldrh	r1, [r3, #6]
   1c8d0:	f7fe fb96 	bl	1b000 <ble_att_notify_req_parse>
    BLE_ATT_LOG_CMD(0, "notify req", conn_handle,
   1c8d4:	4b1a      	ldr	r3, [pc, #104]	; (1c940 <ble_att_svr_rx_notify+0x9c>)
   1c8d6:	9300      	str	r3, [sp, #0]
   1c8d8:	4b1a      	ldr	r3, [pc, #104]	; (1c944 <ble_att_svr_rx_notify+0xa0>)
   1c8da:	9301      	str	r3, [sp, #4]
   1c8dc:	4b1a      	ldr	r3, [pc, #104]	; (1c948 <ble_att_svr_rx_notify+0xa4>)
   1c8de:	9302      	str	r3, [sp, #8]
   1c8e0:	2104      	movs	r1, #4
   1c8e2:	4622      	mov	r2, r4
   1c8e4:	4b19      	ldr	r3, [pc, #100]	; (1c94c <ble_att_svr_rx_notify+0xa8>)
   1c8e6:	481a      	ldr	r0, [pc, #104]	; (1c950 <ble_att_svr_rx_notify+0xac>)
   1c8e8:	9703      	str	r7, [sp, #12]
   1c8ea:	f000 fc9d 	bl	1d228 <log_printf>
   1c8ee:	a805      	add	r0, sp, #20
   1c8f0:	f7fe fb90 	bl	1b014 <ble_att_notify_req_log>
   1c8f4:	4b17      	ldr	r3, [pc, #92]	; (1c954 <ble_att_svr_rx_notify+0xb0>)
   1c8f6:	4816      	ldr	r0, [pc, #88]	; (1c950 <ble_att_svr_rx_notify+0xac>)
   1c8f8:	2104      	movs	r1, #4
   1c8fa:	4622      	mov	r2, r4
   1c8fc:	f000 fc94 	bl	1d228 <log_printf>
                    ble_att_notify_req_log, &req);

    if (req.banq_handle == 0) {
   1c900:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1c904:	2b00      	cmp	r3, #0
   1c906:	d0d5      	beq.n	1c8b4 <ble_att_svr_rx_notify+0x10>
        return BLE_HS_EBADDATA;
    }

    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_NOTIFY_REQ_BASE_SZ);
   1c908:	6828      	ldr	r0, [r5, #0]
   1c90a:	2103      	movs	r1, #3
   1c90c:	f7ed fbd7 	bl	a0be <os_mbuf_adj>

    attr_data = ble_att_get_flat_buf();
   1c910:	f7fd fa6c 	bl	19dec <ble_att_get_flat_buf>
   1c914:	4606      	mov	r6, r0
    attr_len = OS_MBUF_PKTLEN(*rxom);
   1c916:	6828      	ldr	r0, [r5, #0]
   1c918:	8a05      	ldrh	r5, [r0, #16]
    os_mbuf_copydata(*rxom, 0, attr_len, attr_data);
   1c91a:	4621      	mov	r1, r4
   1c91c:	462a      	mov	r2, r5
   1c91e:	4633      	mov	r3, r6
   1c920:	f7ed fba6 	bl	a070 <os_mbuf_copydata>

    ble_gap_notify_rx_event(conn_handle, req.banq_handle, attr_data, attr_len, 0);
   1c924:	4638      	mov	r0, r7
   1c926:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1c92a:	9400      	str	r4, [sp, #0]
   1c92c:	4632      	mov	r2, r6
   1c92e:	462b      	mov	r3, r5
   1c930:	f7f5 fd19 	bl	12366 <ble_gap_notify_rx_event>

    return 0;
   1c934:	4620      	mov	r0, r4
   1c936:	e000      	b.n	1c93a <ble_att_svr_rx_notify+0x96>
        return BLE_HS_EBADDATA;
    }

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_NOTIFY_REQ_BASE_SZ, NULL);
    if (rc != 0) {
        return BLE_HS_ENOMEM;
   1c938:	2006      	movs	r0, #6
    os_mbuf_copydata(*rxom, 0, attr_len, attr_data);

    ble_gap_notify_rx_event(conn_handle, req.banq_handle, attr_data, attr_len, 0);

    return 0;
}
   1c93a:	b007      	add	sp, #28
   1c93c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c93e:	bf00      	nop
   1c940:	0001fbda 	.word	0x0001fbda
   1c944:	000207e0 	.word	0x000207e0
   1c948:	00020916 	.word	0x00020916
   1c94c:	0001fbbc 	.word	0x0001fbbc
   1c950:	20003b9c 	.word	0x20003b9c
   1c954:	0001fdec 	.word	0x0001fdec

0001c958 <ble_att_svr_rx_indicate>:
    return rc;
}

int
ble_att_svr_rx_indicate(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c958:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;

    if (OS_MBUF_PKTLEN(*rxom) < BLE_ATT_INDICATE_REQ_BASE_SZ) {
   1c95c:	680b      	ldr	r3, [r1, #0]
   1c95e:	8a1b      	ldrh	r3, [r3, #16]
   1c960:	2b02      	cmp	r3, #2
    return rc;
}

int
ble_att_svr_rx_indicate(uint16_t conn_handle, struct os_mbuf **rxom)
{
   1c962:	b087      	sub	sp, #28
   1c964:	4606      	mov	r6, r0
   1c966:	460d      	mov	r5, r1
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;

    if (OS_MBUF_PKTLEN(*rxom) < BLE_ATT_INDICATE_REQ_BASE_SZ) {
   1c968:	d802      	bhi.n	1c970 <ble_att_svr_rx_indicate+0x18>
    uint16_t attr_len;
    void *attr_data;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1c96a:	2500      	movs	r5, #0

    if (OS_MBUF_PKTLEN(*rxom) < BLE_ATT_INDICATE_REQ_BASE_SZ) {
        rc = BLE_HS_EBADDATA;
   1c96c:	240a      	movs	r4, #10
   1c96e:	e05f      	b.n	1ca30 <ble_att_svr_rx_indicate+0xd8>
        goto done;
    }

    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_INDICATE_REQ_BASE_SZ, NULL);
   1c970:	4608      	mov	r0, r1
   1c972:	2200      	movs	r2, #0
   1c974:	2103      	movs	r1, #3
   1c976:	f7fe fb7a 	bl	1b06e <ble_att_svr_pullup_req_base>
    if (rc != 0) {
   1c97a:	4604      	mov	r4, r0
   1c97c:	2800      	cmp	r0, #0
   1c97e:	d156      	bne.n	1ca2e <ble_att_svr_rx_indicate+0xd6>
        goto done;
    }

    ble_att_indicate_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c980:	682b      	ldr	r3, [r5, #0]
    BLE_ATT_LOG_CMD(0, "indicate req", conn_handle,
   1c982:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 1ca68 <ble_att_svr_rx_indicate+0x110>
    rc = ble_att_svr_pullup_req_base(rxom, BLE_ATT_INDICATE_REQ_BASE_SZ, NULL);
    if (rc != 0) {
        goto done;
    }

    ble_att_indicate_req_parse((*rxom)->om_data, (*rxom)->om_len, &req);
   1c986:	6818      	ldr	r0, [r3, #0]
   1c988:	88d9      	ldrh	r1, [r3, #6]
   1c98a:	aa05      	add	r2, sp, #20
   1c98c:	f7fe fb52 	bl	1b034 <ble_att_indicate_req_parse>
    BLE_ATT_LOG_CMD(0, "indicate req", conn_handle,
   1c990:	4b2e      	ldr	r3, [pc, #184]	; (1ca4c <ble_att_svr_rx_indicate+0xf4>)
   1c992:	9300      	str	r3, [sp, #0]
   1c994:	4b2e      	ldr	r3, [pc, #184]	; (1ca50 <ble_att_svr_rx_indicate+0xf8>)
   1c996:	9302      	str	r3, [sp, #8]
   1c998:	2104      	movs	r1, #4
   1c99a:	4622      	mov	r2, r4
   1c99c:	4b2d      	ldr	r3, [pc, #180]	; (1ca54 <ble_att_svr_rx_indicate+0xfc>)
   1c99e:	482e      	ldr	r0, [pc, #184]	; (1ca58 <ble_att_svr_rx_indicate+0x100>)
   1c9a0:	f8cd 8004 	str.w	r8, [sp, #4]
   1c9a4:	9603      	str	r6, [sp, #12]
   1c9a6:	f000 fc3f 	bl	1d228 <log_printf>
   1c9aa:	a805      	add	r0, sp, #20
   1c9ac:	f7fe fb4c 	bl	1b048 <ble_att_indicate_req_log>
   1c9b0:	4b2a      	ldr	r3, [pc, #168]	; (1ca5c <ble_att_svr_rx_indicate+0x104>)
   1c9b2:	4829      	ldr	r0, [pc, #164]	; (1ca58 <ble_att_svr_rx_indicate+0x100>)
   1c9b4:	2104      	movs	r1, #4
   1c9b6:	4622      	mov	r2, r4
   1c9b8:	f000 fc36 	bl	1d228 <log_printf>
                    ble_att_indicate_req_log, &req);

    if (req.baiq_handle == 0) {
   1c9bc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1c9c0:	2b00      	cmp	r3, #0
   1c9c2:	d0d2      	beq.n	1c96a <ble_att_svr_rx_indicate+0x12>
        rc = BLE_HS_EBADDATA;
        goto done;
    }

    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_INDICATE_REQ_BASE_SZ);
   1c9c4:	6828      	ldr	r0, [r5, #0]
   1c9c6:	2103      	movs	r1, #3
   1c9c8:	f7ed fb79 	bl	a0be <os_mbuf_adj>

    attr_data = ble_att_get_flat_buf();
   1c9cc:	f7fd fa0e 	bl	19dec <ble_att_get_flat_buf>
   1c9d0:	4681      	mov	r9, r0
    attr_len = OS_MBUF_PKTLEN(*rxom);
   1c9d2:	6828      	ldr	r0, [r5, #0]
   1c9d4:	8a05      	ldrh	r5, [r0, #16]
    os_mbuf_copydata(*rxom, 0, attr_len, attr_data);
   1c9d6:	4621      	mov	r1, r4
   1c9d8:	462a      	mov	r2, r5
   1c9da:	464b      	mov	r3, r9

    ble_gap_notify_rx_event(conn_handle, req.baiq_handle, attr_data, attr_len, 1);
   1c9dc:	2701      	movs	r7, #1
    /* Strip the request base from the front of the mbuf. */
    os_mbuf_adj(*rxom, BLE_ATT_INDICATE_REQ_BASE_SZ);

    attr_data = ble_att_get_flat_buf();
    attr_len = OS_MBUF_PKTLEN(*rxom);
    os_mbuf_copydata(*rxom, 0, attr_len, attr_data);
   1c9de:	f7ed fb47 	bl	a070 <os_mbuf_copydata>

    ble_gap_notify_rx_event(conn_handle, req.baiq_handle, attr_data, attr_len, 1);
   1c9e2:	462b      	mov	r3, r5
   1c9e4:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1c9e8:	9700      	str	r7, [sp, #0]
   1c9ea:	4630      	mov	r0, r6
   1c9ec:	464a      	mov	r2, r9
   1c9ee:	f7f5 fcba 	bl	12366 <ble_gap_notify_rx_event>
{
    struct os_mbuf *txom;
    uint8_t *dst;
    int rc;

    txom = ble_hs_misc_pkthdr();
   1c9f2:	f7f8 fd8f 	bl	15514 <ble_hs_misc_pkthdr>
    if (txom == NULL) {
   1c9f6:	4605      	mov	r5, r0
   1c9f8:	b330      	cbz	r0, 1ca48 <ble_att_svr_rx_indicate+0xf0>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    dst = os_mbuf_extend(txom, BLE_ATT_INDICATE_RSP_SZ);
   1c9fa:	4639      	mov	r1, r7
   1c9fc:	f7ed fc38 	bl	a270 <os_mbuf_extend>
    if (dst == NULL) {
   1ca00:	b310      	cbz	r0, 1ca48 <ble_att_svr_rx_indicate+0xf0>
        rc = BLE_HS_ENOMEM;
        goto done;
    }

    ble_att_indicate_rsp_write(dst, BLE_ATT_INDICATE_RSP_SZ);
   1ca02:	4639      	mov	r1, r7
   1ca04:	f7fe fb30 	bl	1b068 <ble_att_indicate_rsp_write>

    rc = ble_att_svr_build_indicate_rsp(&txom);
    if (rc != 0) {
        goto done;
    }
    BLE_ATT_LOG_EMPTY_CMD(1, "indicate rsp", conn_handle);
   1ca08:	4b15      	ldr	r3, [pc, #84]	; (1ca60 <ble_att_svr_rx_indicate+0x108>)
   1ca0a:	9603      	str	r6, [sp, #12]
   1ca0c:	e88d 0108 	stmia.w	sp, {r3, r8}
   1ca10:	4b14      	ldr	r3, [pc, #80]	; (1ca64 <ble_att_svr_rx_indicate+0x10c>)
   1ca12:	9302      	str	r3, [sp, #8]
   1ca14:	4622      	mov	r2, r4
   1ca16:	4810      	ldr	r0, [pc, #64]	; (1ca58 <ble_att_svr_rx_indicate+0x100>)
   1ca18:	4b0e      	ldr	r3, [pc, #56]	; (1ca54 <ble_att_svr_rx_indicate+0xfc>)
   1ca1a:	2104      	movs	r1, #4
   1ca1c:	f000 fc04 	bl	1d228 <log_printf>
   1ca20:	480d      	ldr	r0, [pc, #52]	; (1ca58 <ble_att_svr_rx_indicate+0x100>)
   1ca22:	4b0e      	ldr	r3, [pc, #56]	; (1ca5c <ble_att_svr_rx_indicate+0x104>)
   1ca24:	2104      	movs	r1, #4
   1ca26:	4622      	mov	r2, r4
   1ca28:	f000 fbfe 	bl	1d228 <log_printf>
   1ca2c:	e000      	b.n	1ca30 <ble_att_svr_rx_indicate+0xd8>
    uint16_t attr_len;
    void *attr_data;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1ca2e:	2500      	movs	r5, #0
    BLE_ATT_LOG_EMPTY_CMD(1, "indicate rsp", conn_handle);

    rc = 0;

done:
    rc = ble_att_svr_tx_rsp(conn_handle, rc, txom, BLE_ATT_OP_INDICATE_REQ,
   1ca30:	2300      	movs	r3, #0
   1ca32:	9300      	str	r3, [sp, #0]
   1ca34:	9301      	str	r3, [sp, #4]
   1ca36:	4630      	mov	r0, r6
   1ca38:	4621      	mov	r1, r4
   1ca3a:	462a      	mov	r2, r5
   1ca3c:	231d      	movs	r3, #29
   1ca3e:	f7fe fb21 	bl	1b084 <ble_att_svr_tx_rsp>
                            0, 0);
    return rc;
}
   1ca42:	b007      	add	sp, #28
   1ca44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    uint16_t attr_len;
    void *attr_data;
    int rc;

    /* Initialize some values in case of early error. */
    txom = NULL;
   1ca48:	2406      	movs	r4, #6
   1ca4a:	e7f1      	b.n	1ca30 <ble_att_svr_rx_indicate+0xd8>
   1ca4c:	0001fbda 	.word	0x0001fbda
   1ca50:	00020921 	.word	0x00020921
   1ca54:	0001fbbc 	.word	0x0001fbbc
   1ca58:	20003b9c 	.word	0x20003b9c
   1ca5c:	0001fdec 	.word	0x0001fdec
   1ca60:	0001fe60 	.word	0x0001fe60
   1ca64:	0002092e 	.word	0x0002092e
   1ca68:	000207e0 	.word	0x000207e0

0001ca6c <ble_att_svr_init>:
    ble_att_svr_entry_mem = NULL;
}

int
ble_att_svr_init(void)
{
   1ca6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
}

static void
ble_att_svr_free_mem(void)
{
    free(ble_att_svr_entry_mem);
   1ca6e:	4d20      	ldr	r5, [pc, #128]	; (1caf0 <ble_att_svr_init+0x84>)
   1ca70:	6828      	ldr	r0, [r5, #0]
   1ca72:	f001 f819 	bl	1daa8 <free>
    ble_att_svr_entry_mem = NULL;
   1ca76:	2300      	movs	r3, #0
   1ca78:	602b      	str	r3, [r5, #0]
{
    int rc;

    ble_att_svr_free_mem();

    if (ble_hs_cfg.max_attrs > 0) {
   1ca7a:	4b1e      	ldr	r3, [pc, #120]	; (1caf4 <ble_att_svr_init+0x88>)
   1ca7c:	891e      	ldrh	r6, [r3, #8]
   1ca7e:	461c      	mov	r4, r3
   1ca80:	b916      	cbnz	r6, 1ca88 <ble_att_svr_init+0x1c>
            rc = BLE_HS_EOS;
            goto err;
        }
    }

    if (ble_hs_cfg.max_prep_entries > 0) {
   1ca82:	7aa4      	ldrb	r4, [r4, #10]
   1ca84:	b31c      	cbz	r4, 1cace <ble_att_svr_init+0x62>
   1ca86:	e010      	b.n	1caaa <ble_att_svr_init+0x3e>
    int rc;

    ble_att_svr_free_mem();

    if (ble_hs_cfg.max_attrs > 0) {
        ble_att_svr_entry_mem = malloc(
   1ca88:	0170      	lsls	r0, r6, #5
   1ca8a:	f000 ffc3 	bl	1da14 <malloc>
   1ca8e:	4603      	mov	r3, r0
   1ca90:	6028      	str	r0, [r5, #0]
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_attrs,
                             sizeof (struct ble_att_svr_entry)));
        if (ble_att_svr_entry_mem == NULL) {
   1ca92:	b318      	cbz	r0, 1cadc <ble_att_svr_init+0x70>
            rc = BLE_HS_ENOMEM;
            goto err;
        }

        rc = os_mempool_init(&ble_att_svr_entry_pool, ble_hs_cfg.max_attrs,
   1ca94:	4a18      	ldr	r2, [pc, #96]	; (1caf8 <ble_att_svr_init+0x8c>)
   1ca96:	9200      	str	r2, [sp, #0]
   1ca98:	4818      	ldr	r0, [pc, #96]	; (1cafc <ble_att_svr_init+0x90>)
   1ca9a:	4631      	mov	r1, r6
   1ca9c:	2220      	movs	r2, #32
   1ca9e:	f7ed fc77 	bl	a390 <os_mempool_init>
                             sizeof (struct ble_att_svr_entry),
                             ble_att_svr_entry_mem, "ble_att_svr_entry_pool");
        if (rc != 0) {
   1caa2:	2800      	cmp	r0, #0
   1caa4:	d0ed      	beq.n	1ca82 <ble_att_svr_init+0x16>
            rc = BLE_HS_EOS;
   1caa6:	240b      	movs	r4, #11
   1caa8:	e019      	b.n	1cade <ble_att_svr_init+0x72>
            goto err;
        }
    }

    if (ble_hs_cfg.max_prep_entries > 0) {
        ble_att_svr_prep_entry_mem = malloc(
   1caaa:	eb04 0044 	add.w	r0, r4, r4, lsl #1
   1caae:	0080      	lsls	r0, r0, #2
   1cab0:	f000 ffb0 	bl	1da14 <malloc>
   1cab4:	4a12      	ldr	r2, [pc, #72]	; (1cb00 <ble_att_svr_init+0x94>)
   1cab6:	4603      	mov	r3, r0
   1cab8:	6010      	str	r0, [r2, #0]
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_prep_entries,
                             sizeof (struct ble_att_prep_entry)));
        if (ble_att_svr_prep_entry_mem == NULL) {
   1caba:	b178      	cbz	r0, 1cadc <ble_att_svr_init+0x70>
            rc = BLE_HS_ENOMEM;
            goto err;
        }

        rc = os_mempool_init(&ble_att_svr_prep_entry_pool,
   1cabc:	4a11      	ldr	r2, [pc, #68]	; (1cb04 <ble_att_svr_init+0x98>)
   1cabe:	9200      	str	r2, [sp, #0]
   1cac0:	4811      	ldr	r0, [pc, #68]	; (1cb08 <ble_att_svr_init+0x9c>)
   1cac2:	4621      	mov	r1, r4
   1cac4:	220c      	movs	r2, #12
   1cac6:	f7ed fc63 	bl	a390 <os_mempool_init>
                             ble_hs_cfg.max_prep_entries,
                             sizeof (struct ble_att_prep_entry),
                             ble_att_svr_prep_entry_mem,
                             "ble_att_svr_prep_entry_pool");
        if (rc != 0) {
   1caca:	2800      	cmp	r0, #0
   1cacc:	d1eb      	bne.n	1caa6 <ble_att_svr_init+0x3a>
            rc = BLE_HS_EOS;
            goto err;
        }
    }

    STAILQ_INIT(&ble_att_svr_list);
   1cace:	4b0f      	ldr	r3, [pc, #60]	; (1cb0c <ble_att_svr_init+0xa0>)
   1cad0:	2000      	movs	r0, #0
   1cad2:	e883 0009 	stmia.w	r3, {r0, r3}

    ble_att_svr_id = 0;
   1cad6:	4b0e      	ldr	r3, [pc, #56]	; (1cb10 <ble_att_svr_init+0xa4>)
   1cad8:	8018      	strh	r0, [r3, #0]

    return 0;
   1cada:	e006      	b.n	1caea <ble_att_svr_init+0x7e>
    if (ble_hs_cfg.max_attrs > 0) {
        ble_att_svr_entry_mem = malloc(
            OS_MEMPOOL_BYTES(ble_hs_cfg.max_attrs,
                             sizeof (struct ble_att_svr_entry)));
        if (ble_att_svr_entry_mem == NULL) {
            rc = BLE_HS_ENOMEM;
   1cadc:	2406      	movs	r4, #6
}

static void
ble_att_svr_free_mem(void)
{
    free(ble_att_svr_entry_mem);
   1cade:	6828      	ldr	r0, [r5, #0]
   1cae0:	f000 ffe2 	bl	1daa8 <free>
    ble_att_svr_entry_mem = NULL;
   1cae4:	2300      	movs	r3, #0
   1cae6:	602b      	str	r3, [r5, #0]

    return 0;

err:
    ble_att_svr_free_mem();
    return rc;
   1cae8:	4620      	mov	r0, r4
}
   1caea:	b002      	add	sp, #8
   1caec:	bd70      	pop	{r4, r5, r6, pc}
   1caee:	bf00      	nop
   1caf0:	20002408 	.word	0x20002408
   1caf4:	20003b78 	.word	0x20003b78
   1caf8:	00020a08 	.word	0x00020a08
   1cafc:	200023c0 	.word	0x200023c0
   1cb00:	200023fc 	.word	0x200023fc
   1cb04:	00020a1f 	.word	0x00020a1f
   1cb08:	200023e0 	.word	0x200023e0
   1cb0c:	20002400 	.word	0x20002400
   1cb10:	200023dc 	.word	0x200023dc

0001cb14 <ble_svc_gap_access>:
};

static int
ble_svc_gap_access(uint16_t conn_handle, uint16_t attr_handle,
                   struct ble_gatt_access_ctxt *ctxt, void *arg)
{
   1cb14:	b538      	push	{r3, r4, r5, lr}
    uint16_t uuid16;

    uuid16 = ble_uuid_128_to_16(ctxt->chr->uuid128);
   1cb16:	6853      	ldr	r3, [r2, #4]
   1cb18:	6818      	ldr	r0, [r3, #0]
};

static int
ble_svc_gap_access(uint16_t conn_handle, uint16_t attr_handle,
                   struct ble_gatt_access_ctxt *ctxt, void *arg)
{
   1cb1a:	4615      	mov	r5, r2
    uint16_t uuid16;

    uuid16 = ble_uuid_128_to_16(ctxt->chr->uuid128);
   1cb1c:	f7fb fcbc 	bl	18498 <ble_uuid_128_to_16>
    assert(uuid16 != 0);
   1cb20:	4602      	mov	r2, r0
   1cb22:	b910      	cbnz	r0, 1cb2a <ble_svc_gap_access+0x16>
   1cb24:	482a      	ldr	r0, [pc, #168]	; (1cbd0 <ble_svc_gap_access+0xbc>)
   1cb26:	2156      	movs	r1, #86	; 0x56
   1cb28:	e04c      	b.n	1cbc4 <ble_svc_gap_access+0xb0>

    switch (uuid16) {
   1cb2a:	f5a0 5228 	sub.w	r2, r0, #10752	; 0x2a00
   1cb2e:	2a04      	cmp	r2, #4
   1cb30:	d845      	bhi.n	1cbbe <ble_svc_gap_access+0xaa>
   1cb32:	e8df f002 	tbb	[pc, r2]
   1cb36:	1003      	.short	0x1003
   1cb38:	271b      	.short	0x271b
   1cb3a:	39          	.byte	0x39
   1cb3b:	00          	.byte	0x00
    case BLE_SVC_GAP_CHR_UUID16_DEVICE_NAME:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR);
   1cb3c:	782c      	ldrb	r4, [r5, #0]
   1cb3e:	b114      	cbz	r4, 1cb46 <ble_svc_gap_access+0x32>
   1cb40:	4823      	ldr	r0, [pc, #140]	; (1cbd0 <ble_svc_gap_access+0xbc>)
   1cb42:	215a      	movs	r1, #90	; 0x5a
   1cb44:	e03d      	b.n	1cbc2 <ble_svc_gap_access+0xae>
        ctxt->att->read.data = ble_svc_gap_name;
   1cb46:	68ab      	ldr	r3, [r5, #8]
   1cb48:	4822      	ldr	r0, [pc, #136]	; (1cbd4 <ble_svc_gap_access+0xc0>)
   1cb4a:	6098      	str	r0, [r3, #8]
        ctxt->att->read.len = strlen(ble_svc_gap_name);
   1cb4c:	f7ec fa82 	bl	9054 <strlen>
   1cb50:	68ad      	ldr	r5, [r5, #8]
   1cb52:	81a8      	strh	r0, [r5, #12]
   1cb54:	e026      	b.n	1cba4 <ble_svc_gap_access+0x90>
        break;

    case BLE_SVC_GAP_CHR_UUID16_APPEARANCE:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR);
   1cb56:	7828      	ldrb	r0, [r5, #0]
   1cb58:	b110      	cbz	r0, 1cb60 <ble_svc_gap_access+0x4c>
   1cb5a:	481d      	ldr	r0, [pc, #116]	; (1cbd0 <ble_svc_gap_access+0xbc>)
   1cb5c:	2160      	movs	r1, #96	; 0x60
   1cb5e:	e030      	b.n	1cbc2 <ble_svc_gap_access+0xae>
        ctxt->att->read.data = &ble_svc_gap_appearance;
   1cb60:	68ab      	ldr	r3, [r5, #8]
   1cb62:	4a1d      	ldr	r2, [pc, #116]	; (1cbd8 <ble_svc_gap_access+0xc4>)
   1cb64:	609a      	str	r2, [r3, #8]
        ctxt->att->read.len = sizeof ble_svc_gap_appearance;
   1cb66:	68ab      	ldr	r3, [r5, #8]
   1cb68:	2202      	movs	r2, #2
   1cb6a:	e009      	b.n	1cb80 <ble_svc_gap_access+0x6c>
        break;

    case BLE_SVC_GAP_CHR_UUID16_PERIPH_PRIV_FLAG:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR);
   1cb6c:	7828      	ldrb	r0, [r5, #0]
   1cb6e:	b110      	cbz	r0, 1cb76 <ble_svc_gap_access+0x62>
   1cb70:	4817      	ldr	r0, [pc, #92]	; (1cbd0 <ble_svc_gap_access+0xbc>)
   1cb72:	2166      	movs	r1, #102	; 0x66
   1cb74:	e025      	b.n	1cbc2 <ble_svc_gap_access+0xae>
        ctxt->att->read.data = &ble_svc_gap_privacy_flag;
   1cb76:	68ab      	ldr	r3, [r5, #8]
   1cb78:	4a18      	ldr	r2, [pc, #96]	; (1cbdc <ble_svc_gap_access+0xc8>)
   1cb7a:	609a      	str	r2, [r3, #8]
        ctxt->att->read.len = sizeof ble_svc_gap_privacy_flag;
   1cb7c:	68ab      	ldr	r3, [r5, #8]
   1cb7e:	2201      	movs	r2, #1
   1cb80:	819a      	strh	r2, [r3, #12]
        break;
   1cb82:	bd38      	pop	{r3, r4, r5, pc}

    case BLE_SVC_GAP_CHR_UUID16_RECONNECT_ADDR:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR);
   1cb84:	782b      	ldrb	r3, [r5, #0]
   1cb86:	2b01      	cmp	r3, #1
   1cb88:	d002      	beq.n	1cb90 <ble_svc_gap_access+0x7c>
   1cb8a:	4811      	ldr	r0, [pc, #68]	; (1cbd0 <ble_svc_gap_access+0xbc>)
   1cb8c:	216c      	movs	r1, #108	; 0x6c
   1cb8e:	e018      	b.n	1cbc2 <ble_svc_gap_access+0xae>
        if (ctxt->att->write.len != sizeof ble_svc_gap_reconnect_addr) {
   1cb90:	68aa      	ldr	r2, [r5, #8]
   1cb92:	6893      	ldr	r3, [r2, #8]
   1cb94:	2b06      	cmp	r3, #6
   1cb96:	d118      	bne.n	1cbca <ble_svc_gap_access+0xb6>
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
        }
        memcpy(ble_svc_gap_reconnect_addr, ctxt->att->write.data,
   1cb98:	6812      	ldr	r2, [r2, #0]
   1cb9a:	4b11      	ldr	r3, [pc, #68]	; (1cbe0 <ble_svc_gap_access+0xcc>)
   1cb9c:	6811      	ldr	r1, [r2, #0]
   1cb9e:	8892      	ldrh	r2, [r2, #4]
   1cba0:	6019      	str	r1, [r3, #0]
   1cba2:	809a      	strh	r2, [r3, #4]
    default:
        assert(0);
        break;
    }

    return 0;
   1cba4:	2000      	movs	r0, #0
        if (ctxt->att->write.len != sizeof ble_svc_gap_reconnect_addr) {
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
        }
        memcpy(ble_svc_gap_reconnect_addr, ctxt->att->write.data,
               sizeof ble_svc_gap_reconnect_addr);
        break;
   1cba6:	bd38      	pop	{r3, r4, r5, pc}

    case BLE_SVC_GAP_CHR_UUID16_PERIPH_PREF_CONN_PARAMS:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR);
   1cba8:	7828      	ldrb	r0, [r5, #0]
   1cbaa:	b110      	cbz	r0, 1cbb2 <ble_svc_gap_access+0x9e>
   1cbac:	4808      	ldr	r0, [pc, #32]	; (1cbd0 <ble_svc_gap_access+0xbc>)
   1cbae:	2175      	movs	r1, #117	; 0x75
   1cbb0:	e007      	b.n	1cbc2 <ble_svc_gap_access+0xae>
        ctxt->att->read.data = &ble_svc_gap_pref_conn_params;
   1cbb2:	68ab      	ldr	r3, [r5, #8]
   1cbb4:	4a0b      	ldr	r2, [pc, #44]	; (1cbe4 <ble_svc_gap_access+0xd0>)
   1cbb6:	609a      	str	r2, [r3, #8]
        ctxt->att->read.len = sizeof ble_svc_gap_pref_conn_params;
   1cbb8:	68ab      	ldr	r3, [r5, #8]
   1cbba:	2208      	movs	r2, #8
   1cbbc:	e7e0      	b.n	1cb80 <ble_svc_gap_access+0x6c>
        break;

    default:
        assert(0);
   1cbbe:	4804      	ldr	r0, [pc, #16]	; (1cbd0 <ble_svc_gap_access+0xbc>)
   1cbc0:	217b      	movs	r1, #123	; 0x7b
   1cbc2:	2200      	movs	r2, #0
   1cbc4:	4613      	mov	r3, r2
   1cbc6:	f7ed f883 	bl	9cd0 <__assert_func>
        break;

    case BLE_SVC_GAP_CHR_UUID16_RECONNECT_ADDR:
        assert(ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR);
        if (ctxt->att->write.len != sizeof ble_svc_gap_reconnect_addr) {
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
   1cbca:	200d      	movs	r0, #13
        assert(0);
        break;
    }

    return 0;
}
   1cbcc:	bd38      	pop	{r3, r4, r5, pc}
   1cbce:	bf00      	nop
   1cbd0:	00020a5c 	.word	0x00020a5c
   1cbd4:	20000268 	.word	0x20000268
   1cbd8:	20002416 	.word	0x20002416
   1cbdc:	20002414 	.word	0x20002414
   1cbe0:	20002418 	.word	0x20002418
   1cbe4:	2000240c 	.word	0x2000240c

0001cbe8 <ble_svc_gap_device_name>:

const char *
ble_svc_gap_device_name(void)
{
    return ble_svc_gap_name;
}
   1cbe8:	4800      	ldr	r0, [pc, #0]	; (1cbec <ble_svc_gap_device_name+0x4>)
   1cbea:	4770      	bx	lr
   1cbec:	20000268 	.word	0x20000268

0001cbf0 <ble_svc_gap_device_name_set>:

int
ble_svc_gap_device_name_set(const char *name)
{
   1cbf0:	b538      	push	{r3, r4, r5, lr}
   1cbf2:	4605      	mov	r5, r0
    int len;

    len = strlen(name);
   1cbf4:	f7ec fa2e 	bl	9054 <strlen>
    if (len > BLE_SVC_GAP_NAME_MAX_LEN) {
   1cbf8:	281f      	cmp	r0, #31
int
ble_svc_gap_device_name_set(const char *name)
{
    int len;

    len = strlen(name);
   1cbfa:	4604      	mov	r4, r0
    if (len > BLE_SVC_GAP_NAME_MAX_LEN) {
   1cbfc:	dc09      	bgt.n	1cc12 <ble_svc_gap_device_name_set+0x22>
        return BLE_HS_EINVAL;
    }

    memcpy(ble_svc_gap_name, name, len);
   1cbfe:	4b06      	ldr	r3, [pc, #24]	; (1cc18 <ble_svc_gap_device_name_set+0x28>)
   1cc00:	4629      	mov	r1, r5
   1cc02:	4618      	mov	r0, r3
   1cc04:	4622      	mov	r2, r4
   1cc06:	f7ec f9f9 	bl	8ffc <memcpy>
   1cc0a:	4603      	mov	r3, r0
    ble_svc_gap_name[len] = '\0';
   1cc0c:	2000      	movs	r0, #0
   1cc0e:	5518      	strb	r0, [r3, r4]

    return 0;
   1cc10:	bd38      	pop	{r3, r4, r5, pc}
{
    int len;

    len = strlen(name);
    if (len > BLE_SVC_GAP_NAME_MAX_LEN) {
        return BLE_HS_EINVAL;
   1cc12:	2003      	movs	r0, #3

    memcpy(ble_svc_gap_name, name, len);
    ble_svc_gap_name[len] = '\0';

    return 0;
}
   1cc14:	bd38      	pop	{r3, r4, r5, pc}
   1cc16:	bf00      	nop
   1cc18:	20000268 	.word	0x20000268

0001cc1c <ble_svc_gap_register>:
int
ble_svc_gap_register(void)
{
    int rc;

    rc = ble_gatts_register_svcs(ble_svc_gap_defs, NULL, NULL);
   1cc1c:	2100      	movs	r1, #0
   1cc1e:	4802      	ldr	r0, [pc, #8]	; (1cc28 <ble_svc_gap_register+0xc>)
   1cc20:	460a      	mov	r2, r1
   1cc22:	f7f6 bfc1 	b.w	13ba8 <ble_gatts_register_svcs>
   1cc26:	bf00      	nop
   1cc28:	00020a3c 	.word	0x00020a3c

0001cc2c <ble_svc_gap_init>:
    return rc;
}

int
ble_svc_gap_init(struct ble_hs_cfg *cfg)
{
   1cc2c:	4601      	mov	r1, r0
    int rc;

    rc = ble_gatts_count_cfg(ble_svc_gap_defs, cfg);
   1cc2e:	4801      	ldr	r0, [pc, #4]	; (1cc34 <ble_svc_gap_init+0x8>)
   1cc30:	f7f7 bc05 	b.w	1443e <ble_gatts_count_cfg>
   1cc34:	00020a3c 	.word	0x00020a3c

0001cc38 <ble_svc_gatt_access>:
};

static int
ble_svc_gatt_access(uint16_t conn_handle, uint16_t attr_handle,
                    struct ble_gatt_access_ctxt *ctxt, void *arg)
{
   1cc38:	b508      	push	{r3, lr}
     * access callback gets called by the stack when it needs to read the
     * characteristic value to populate the outgoing indication command.
     * Therefore, this callback should only get called during an attempt to
     * read the characteristic.
     */
    assert(ctxt->op == BLE_GATT_ACCESS_OP_READ_CHR);
   1cc3a:	7813      	ldrb	r3, [r2, #0]
   1cc3c:	b11b      	cbz	r3, 1cc46 <ble_svc_gatt_access+0xe>
   1cc3e:	480b      	ldr	r0, [pc, #44]	; (1cc6c <ble_svc_gatt_access+0x34>)
   1cc40:	213a      	movs	r1, #58	; 0x3a
   1cc42:	2200      	movs	r2, #0
   1cc44:	e006      	b.n	1cc54 <ble_svc_gatt_access+0x1c>
    assert(ctxt->chr == &ble_svc_gatt_defs[0].characteristics[0]);
   1cc46:	6850      	ldr	r0, [r2, #4]
   1cc48:	4909      	ldr	r1, [pc, #36]	; (1cc70 <ble_svc_gatt_access+0x38>)
   1cc4a:	4288      	cmp	r0, r1
   1cc4c:	d005      	beq.n	1cc5a <ble_svc_gatt_access+0x22>
   1cc4e:	4807      	ldr	r0, [pc, #28]	; (1cc6c <ble_svc_gatt_access+0x34>)
   1cc50:	213b      	movs	r1, #59	; 0x3b
   1cc52:	461a      	mov	r2, r3
   1cc54:	4613      	mov	r3, r2
   1cc56:	f7ed f83b 	bl	9cd0 <__assert_func>

    /* XXX: For now, always respond with 0 (unchanged). */
    ctxt->att->read.buf[0] = 0;
   1cc5a:	6891      	ldr	r1, [r2, #8]
   1cc5c:	6849      	ldr	r1, [r1, #4]
   1cc5e:	700b      	strb	r3, [r1, #0]
    ctxt->att->read.len = 1;
   1cc60:	6892      	ldr	r2, [r2, #8]
   1cc62:	2101      	movs	r1, #1
   1cc64:	8191      	strh	r1, [r2, #12]

    return 0;
}
   1cc66:	4618      	mov	r0, r3
   1cc68:	bd08      	pop	{r3, pc}
   1cc6a:	bf00      	nop
   1cc6c:	00020a6a 	.word	0x00020a6a
   1cc70:	20000388 	.word	0x20000388

0001cc74 <ble_svc_gatt_register>:
int
ble_svc_gatt_register(void)
{
    int rc;

    rc = ble_gatts_register_svcs(ble_svc_gatt_defs, NULL, NULL);
   1cc74:	2100      	movs	r1, #0
   1cc76:	4802      	ldr	r0, [pc, #8]	; (1cc80 <ble_svc_gatt_register+0xc>)
   1cc78:	460a      	mov	r2, r1
   1cc7a:	f7f6 bf95 	b.w	13ba8 <ble_gatts_register_svcs>
   1cc7e:	bf00      	nop
   1cc80:	00020a7c 	.word	0x00020a7c

0001cc84 <ble_svc_gatt_init>:
    return rc;
}

int
ble_svc_gatt_init(struct ble_hs_cfg *cfg)
{
   1cc84:	4601      	mov	r1, r0
    int rc;

    rc = ble_gatts_count_cfg(ble_svc_gatt_defs, cfg);
   1cc86:	4801      	ldr	r0, [pc, #4]	; (1cc8c <ble_svc_gatt_init+0x8>)
   1cc88:	f7f7 bbd9 	b.w	1443e <ble_gatts_count_cfg>
   1cc8c:	00020a7c 	.word	0x00020a7c

0001cc90 <ble_store_ram_find_sec>:
}

static int
ble_store_ram_find_sec(struct ble_store_key_sec *key_sec,
                   struct ble_store_value_sec *value_secs, int num_value_secs)
{
   1cc90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int skipped;
    int i;

    skipped = 0;

    for (i = 0; i < num_value_secs; i++) {
   1cc94:	2400      	movs	r4, #0
}

static int
ble_store_ram_find_sec(struct ble_store_key_sec *key_sec,
                   struct ble_store_value_sec *value_secs, int num_value_secs)
{
   1cc96:	4606      	mov	r6, r0
   1cc98:	4690      	mov	r8, r2
   1cc9a:	460d      	mov	r5, r1
    struct ble_store_value_sec *cur;
    int skipped;
    int i;

    skipped = 0;
   1cc9c:	4627      	mov	r7, r4

    for (i = 0; i < num_value_secs; i++) {
   1cc9e:	4544      	cmp	r4, r8
   1cca0:	da21      	bge.n	1cce6 <ble_store_ram_find_sec+0x56>
        cur = value_secs + i;

        if (key_sec->peer_addr_type != BLE_STORE_ADDR_TYPE_NONE) {
   1cca2:	79b3      	ldrb	r3, [r6, #6]
   1cca4:	2bff      	cmp	r3, #255	; 0xff
   1cca6:	d008      	beq.n	1ccba <ble_store_ram_find_sec+0x2a>
            if (cur->peer_addr_type != key_sec->peer_addr_type) {
   1cca8:	79aa      	ldrb	r2, [r5, #6]
   1ccaa:	429a      	cmp	r2, r3
   1ccac:	d118      	bne.n	1cce0 <ble_store_ram_find_sec+0x50>
                continue;
            }

            if (memcmp(cur->peer_addr, key_sec->peer_addr,
   1ccae:	4628      	mov	r0, r5
   1ccb0:	4631      	mov	r1, r6
   1ccb2:	2206      	movs	r2, #6
   1ccb4:	f7ec f994 	bl	8fe0 <memcmp>
   1ccb8:	b990      	cbnz	r0, 1cce0 <ble_store_ram_find_sec+0x50>
                       sizeof cur->peer_addr) != 0) {
                continue;
            }
        }

        if (key_sec->ediv_rand_present) {
   1ccba:	7e33      	ldrb	r3, [r6, #24]
   1ccbc:	07db      	lsls	r3, r3, #31
   1ccbe:	d50b      	bpl.n	1ccd8 <ble_store_ram_find_sec+0x48>
            if (cur->ediv != key_sec->ediv) {
   1ccc0:	892a      	ldrh	r2, [r5, #8]
   1ccc2:	8933      	ldrh	r3, [r6, #8]
   1ccc4:	429a      	cmp	r2, r3
   1ccc6:	d10b      	bne.n	1cce0 <ble_store_ram_find_sec+0x50>
                continue;
            }

            if (cur->rand_num != key_sec->rand_num) {
   1ccc8:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
   1cccc:	e9d6 2304 	ldrd	r2, r3, [r6, #16]
   1ccd0:	4299      	cmp	r1, r3
   1ccd2:	bf08      	it	eq
   1ccd4:	4290      	cmpeq	r0, r2
   1ccd6:	d103      	bne.n	1cce0 <ble_store_ram_find_sec+0x50>
                continue;
            }
        }

        if (key_sec->idx > skipped) {
   1ccd8:	7e73      	ldrb	r3, [r6, #25]
   1ccda:	42bb      	cmp	r3, r7
   1ccdc:	dd07      	ble.n	1ccee <ble_store_ram_find_sec+0x5e>
            skipped++;
   1ccde:	3701      	adds	r7, #1
    int skipped;
    int i;

    skipped = 0;

    for (i = 0; i < num_value_secs; i++) {
   1cce0:	3401      	adds	r4, #1
   1cce2:	3550      	adds	r5, #80	; 0x50
   1cce4:	e7db      	b.n	1cc9e <ble_store_ram_find_sec+0xe>
        }

        return i;
    }

    return -1;
   1cce6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1ccea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ccee:	4620      	mov	r0, r4
}
   1ccf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001ccf4 <ble_store_ram_find_cccd>:
    struct ble_store_value_cccd *cccd;
    int skipped;
    int i;

    skipped = 0;
    for (i = 0; i < ble_store_ram_num_cccds; i++) {
   1ccf4:	4b14      	ldr	r3, [pc, #80]	; (1cd48 <ble_store_ram_find_cccd+0x54>)
 * $cccd                                                                     *
 *****************************************************************************/

static int
ble_store_ram_find_cccd(struct ble_store_key_cccd *key)
{
   1ccf6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    struct ble_store_value_cccd *cccd;
    int skipped;
    int i;

    skipped = 0;
    for (i = 0; i < ble_store_ram_num_cccds; i++) {
   1ccfa:	2400      	movs	r4, #0
   1ccfc:	f8d3 8000 	ldr.w	r8, [r3]
   1cd00:	4d12      	ldr	r5, [pc, #72]	; (1cd4c <ble_store_ram_find_cccd+0x58>)
 * $cccd                                                                     *
 *****************************************************************************/

static int
ble_store_ram_find_cccd(struct ble_store_key_cccd *key)
{
   1cd02:	4606      	mov	r6, r0
    struct ble_store_value_cccd *cccd;
    int skipped;
    int i;

    skipped = 0;
   1cd04:	4627      	mov	r7, r4
    for (i = 0; i < ble_store_ram_num_cccds; i++) {
   1cd06:	4544      	cmp	r4, r8
   1cd08:	da17      	bge.n	1cd3a <ble_store_ram_find_cccd+0x46>
        cccd = ble_store_ram_cccds + i;

        if (key->peer_addr_type != BLE_STORE_ADDR_TYPE_NONE) {
   1cd0a:	79b3      	ldrb	r3, [r6, #6]
   1cd0c:	2bff      	cmp	r3, #255	; 0xff
   1cd0e:	d008      	beq.n	1cd22 <ble_store_ram_find_cccd+0x2e>
            if (cccd->peer_addr_type != key->peer_addr_type) {
   1cd10:	79aa      	ldrb	r2, [r5, #6]
   1cd12:	429a      	cmp	r2, r3
   1cd14:	d10e      	bne.n	1cd34 <ble_store_ram_find_cccd+0x40>
                continue;
            }

            if (memcmp(cccd->peer_addr, key->peer_addr, 6) != 0) {
   1cd16:	4628      	mov	r0, r5
   1cd18:	4631      	mov	r1, r6
   1cd1a:	2206      	movs	r2, #6
   1cd1c:	f7ec f960 	bl	8fe0 <memcmp>
   1cd20:	b940      	cbnz	r0, 1cd34 <ble_store_ram_find_cccd+0x40>
                continue;
            }
        }

        if (key->chr_val_handle != 0) {
   1cd22:	8933      	ldrh	r3, [r6, #8]
   1cd24:	b113      	cbz	r3, 1cd2c <ble_store_ram_find_cccd+0x38>
            if (cccd->chr_val_handle != key->chr_val_handle) {
   1cd26:	892a      	ldrh	r2, [r5, #8]
   1cd28:	429a      	cmp	r2, r3
   1cd2a:	d103      	bne.n	1cd34 <ble_store_ram_find_cccd+0x40>
                continue;
            }
        }

        if (key->idx > skipped) {
   1cd2c:	7ab3      	ldrb	r3, [r6, #10]
   1cd2e:	42bb      	cmp	r3, r7
   1cd30:	dd07      	ble.n	1cd42 <ble_store_ram_find_cccd+0x4e>
            skipped++;
   1cd32:	3701      	adds	r7, #1
    struct ble_store_value_cccd *cccd;
    int skipped;
    int i;

    skipped = 0;
    for (i = 0; i < ble_store_ram_num_cccds; i++) {
   1cd34:	3401      	adds	r4, #1
   1cd36:	3510      	adds	r5, #16
   1cd38:	e7e5      	b.n	1cd06 <ble_store_ram_find_cccd+0x12>
        }

        return i;
    }

    return -1;
   1cd3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1cd3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1cd42:	4620      	mov	r0, r4
}
   1cd44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1cd48:	200027a0 	.word	0x200027a0
   1cd4c:	20002420 	.word	0x20002420

0001cd50 <ble_store_ram_print_value_sec>:
 * $sec                                                                      *
 *****************************************************************************/

static void
ble_store_ram_print_value_sec(struct ble_store_value_sec *sec)
{
   1cd50:	b510      	push	{r4, lr}
    if (sec->ltk_present) {
   1cd52:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
   1cd56:	07d9      	lsls	r1, r3, #31
 * $sec                                                                      *
 *****************************************************************************/

static void
ble_store_ram_print_value_sec(struct ble_store_value_sec *sec)
{
   1cd58:	b086      	sub	sp, #24
   1cd5a:	4604      	mov	r4, r0
    if (sec->ltk_present) {
   1cd5c:	d51b      	bpl.n	1cd96 <ble_store_ram_print_value_sec+0x46>
        BLE_HS_LOG(DEBUG, "ediv=%u rand=%llu authenticated=%d ltk=",
   1cd5e:	8903      	ldrh	r3, [r0, #8]
   1cd60:	9300      	str	r3, [sp, #0]
   1cd62:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
   1cd66:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1cd6a:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
   1cd6e:	4823      	ldr	r0, [pc, #140]	; (1cdfc <ble_store_ram_print_value_sec+0xac>)
   1cd70:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1cd74:	2200      	movs	r2, #0
   1cd76:	9304      	str	r3, [sp, #16]
   1cd78:	2104      	movs	r1, #4
   1cd7a:	4b21      	ldr	r3, [pc, #132]	; (1ce00 <ble_store_ram_print_value_sec+0xb0>)
   1cd7c:	f000 fa54 	bl	1d228 <log_printf>
                       sec->ediv, sec->rand_num, sec->authenticated);
        ble_hs_log_flat_buf(sec->ltk, 16);
   1cd80:	f104 0018 	add.w	r0, r4, #24
   1cd84:	2110      	movs	r1, #16
   1cd86:	f7f8 fbad 	bl	154e4 <ble_hs_log_flat_buf>
        BLE_HS_LOG(DEBUG, " ");
   1cd8a:	481c      	ldr	r0, [pc, #112]	; (1cdfc <ble_store_ram_print_value_sec+0xac>)
   1cd8c:	4b1d      	ldr	r3, [pc, #116]	; (1ce04 <ble_store_ram_print_value_sec+0xb4>)
   1cd8e:	2104      	movs	r1, #4
   1cd90:	2200      	movs	r2, #0
   1cd92:	f000 fa49 	bl	1d228 <log_printf>
    }
    if (sec->irk_present) {
   1cd96:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   1cd9a:	07da      	lsls	r2, r3, #31
   1cd9c:	d510      	bpl.n	1cdc0 <ble_store_ram_print_value_sec+0x70>
        BLE_HS_LOG(DEBUG, "irk=");
   1cd9e:	2200      	movs	r2, #0
   1cda0:	4b19      	ldr	r3, [pc, #100]	; (1ce08 <ble_store_ram_print_value_sec+0xb8>)
   1cda2:	4816      	ldr	r0, [pc, #88]	; (1cdfc <ble_store_ram_print_value_sec+0xac>)
   1cda4:	2104      	movs	r1, #4
   1cda6:	f000 fa3f 	bl	1d228 <log_printf>
        ble_hs_log_flat_buf(sec->irk, 16);
   1cdaa:	f104 0029 	add.w	r0, r4, #41	; 0x29
   1cdae:	2110      	movs	r1, #16
   1cdb0:	f7f8 fb98 	bl	154e4 <ble_hs_log_flat_buf>
        BLE_HS_LOG(DEBUG, " ");
   1cdb4:	4811      	ldr	r0, [pc, #68]	; (1cdfc <ble_store_ram_print_value_sec+0xac>)
   1cdb6:	4b13      	ldr	r3, [pc, #76]	; (1ce04 <ble_store_ram_print_value_sec+0xb4>)
   1cdb8:	2104      	movs	r1, #4
   1cdba:	2200      	movs	r2, #0
   1cdbc:	f000 fa34 	bl	1d228 <log_printf>
    }
    if (sec->csrk_present) {
   1cdc0:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
   1cdc4:	07db      	lsls	r3, r3, #31
   1cdc6:	d510      	bpl.n	1cdea <ble_store_ram_print_value_sec+0x9a>
        BLE_HS_LOG(DEBUG, "csrk=");
   1cdc8:	2200      	movs	r2, #0
   1cdca:	4b10      	ldr	r3, [pc, #64]	; (1ce0c <ble_store_ram_print_value_sec+0xbc>)
   1cdcc:	480b      	ldr	r0, [pc, #44]	; (1cdfc <ble_store_ram_print_value_sec+0xac>)
   1cdce:	2104      	movs	r1, #4
   1cdd0:	f000 fa2a 	bl	1d228 <log_printf>
        ble_hs_log_flat_buf(sec->csrk, 16);
   1cdd4:	f104 003a 	add.w	r0, r4, #58	; 0x3a
   1cdd8:	2110      	movs	r1, #16
   1cdda:	f7f8 fb83 	bl	154e4 <ble_hs_log_flat_buf>
        BLE_HS_LOG(DEBUG, " ");
   1cdde:	4807      	ldr	r0, [pc, #28]	; (1cdfc <ble_store_ram_print_value_sec+0xac>)
   1cde0:	4b08      	ldr	r3, [pc, #32]	; (1ce04 <ble_store_ram_print_value_sec+0xb4>)
   1cde2:	2104      	movs	r1, #4
   1cde4:	2200      	movs	r2, #0
   1cde6:	f000 fa1f 	bl	1d228 <log_printf>
    }

    BLE_HS_LOG(DEBUG, "\n");
   1cdea:	4804      	ldr	r0, [pc, #16]	; (1cdfc <ble_store_ram_print_value_sec+0xac>)
   1cdec:	4b08      	ldr	r3, [pc, #32]	; (1ce10 <ble_store_ram_print_value_sec+0xc0>)
   1cdee:	2104      	movs	r1, #4
   1cdf0:	2200      	movs	r2, #0
}
   1cdf2:	b006      	add	sp, #24
   1cdf4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BLE_HS_LOG(DEBUG, "csrk=");
        ble_hs_log_flat_buf(sec->csrk, 16);
        BLE_HS_LOG(DEBUG, " ");
    }

    BLE_HS_LOG(DEBUG, "\n");
   1cdf8:	f000 ba16 	b.w	1d228 <log_printf>
   1cdfc:	20003b9c 	.word	0x20003b9c
   1ce00:	00020a9c 	.word	0x00020a9c
   1ce04:	0002064c 	.word	0x0002064c
   1ce08:	0001fe90 	.word	0x0001fe90
   1ce0c:	00020ac4 	.word	0x00020ac4
   1ce10:	0001fdec 	.word	0x0001fdec

0001ce14 <ble_store_ram_print_key_sec>:
}

static void
ble_store_ram_print_key_sec(struct ble_store_key_sec *key_sec)
{
   1ce14:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (key_sec->peer_addr_type != BLE_STORE_ADDR_TYPE_NONE) {
   1ce16:	7983      	ldrb	r3, [r0, #6]
   1ce18:	2bff      	cmp	r3, #255	; 0xff
    BLE_HS_LOG(DEBUG, "\n");
}

static void
ble_store_ram_print_key_sec(struct ble_store_key_sec *key_sec)
{
   1ce1a:	4604      	mov	r4, r0
    if (key_sec->peer_addr_type != BLE_STORE_ADDR_TYPE_NONE) {
   1ce1c:	d010      	beq.n	1ce40 <ble_store_ram_print_key_sec+0x2c>
        BLE_HS_LOG(DEBUG, "peer_addr_type=%d peer_addr=",
   1ce1e:	2200      	movs	r2, #0
   1ce20:	9300      	str	r3, [sp, #0]
   1ce22:	4810      	ldr	r0, [pc, #64]	; (1ce64 <ble_store_ram_print_key_sec+0x50>)
   1ce24:	4b10      	ldr	r3, [pc, #64]	; (1ce68 <ble_store_ram_print_key_sec+0x54>)
   1ce26:	2104      	movs	r1, #4
   1ce28:	f000 f9fe 	bl	1d228 <log_printf>
                       key_sec->peer_addr_type);
        ble_hs_log_flat_buf(key_sec->peer_addr, 6);
   1ce2c:	4620      	mov	r0, r4
   1ce2e:	2106      	movs	r1, #6
   1ce30:	f7f8 fb58 	bl	154e4 <ble_hs_log_flat_buf>
        BLE_HS_LOG(DEBUG, " ");
   1ce34:	480b      	ldr	r0, [pc, #44]	; (1ce64 <ble_store_ram_print_key_sec+0x50>)
   1ce36:	4b0d      	ldr	r3, [pc, #52]	; (1ce6c <ble_store_ram_print_key_sec+0x58>)
   1ce38:	2104      	movs	r1, #4
   1ce3a:	2200      	movs	r2, #0
   1ce3c:	f000 f9f4 	bl	1d228 <log_printf>
    }
    if (key_sec->ediv_rand_present) {
   1ce40:	7e23      	ldrb	r3, [r4, #24]
   1ce42:	07db      	lsls	r3, r3, #31
   1ce44:	d50b      	bpl.n	1ce5e <ble_store_ram_print_key_sec+0x4a>
        BLE_HS_LOG(DEBUG, "ediv=0x%02x rand=0x%llx ",
   1ce46:	8923      	ldrh	r3, [r4, #8]
   1ce48:	9300      	str	r3, [sp, #0]
   1ce4a:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   1ce4e:	4805      	ldr	r0, [pc, #20]	; (1ce64 <ble_store_ram_print_key_sec+0x50>)
   1ce50:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1ce54:	2104      	movs	r1, #4
   1ce56:	2200      	movs	r2, #0
   1ce58:	4b05      	ldr	r3, [pc, #20]	; (1ce70 <ble_store_ram_print_key_sec+0x5c>)
   1ce5a:	f000 f9e5 	bl	1d228 <log_printf>
                       key_sec->ediv, key_sec->rand_num);
    }
}
   1ce5e:	b004      	add	sp, #16
   1ce60:	bd10      	pop	{r4, pc}
   1ce62:	bf00      	nop
   1ce64:	20003b9c 	.word	0x20003b9c
   1ce68:	0001f3e7 	.word	0x0001f3e7
   1ce6c:	0002064c 	.word	0x0002064c
   1ce70:	00020aca 	.word	0x00020aca

0001ce74 <ble_store_ram_read>:
ble_store_ram_read(int obj_type, union ble_store_key *key,
               union ble_store_value *value)
{
    int rc;

    switch (obj_type) {
   1ce74:	2802      	cmp	r0, #2
 * @return                      0 if a key was found; else BLE_HS_ENOENT.
 */
int
ble_store_ram_read(int obj_type, union ble_store_key *key,
               union ble_store_value *value)
{
   1ce76:	b570      	push	{r4, r5, r6, lr}
   1ce78:	460d      	mov	r5, r1
   1ce7a:	4614      	mov	r4, r2
    int rc;

    switch (obj_type) {
   1ce7c:	d017      	beq.n	1ceae <ble_store_ram_read+0x3a>
   1ce7e:	2803      	cmp	r0, #3
   1ce80:	d037      	beq.n	1cef2 <ble_store_ram_read+0x7e>
   1ce82:	2801      	cmp	r0, #1
   1ce84:	d142      	bne.n	1cf0c <ble_store_ram_read+0x98>
        BLE_HS_LOG(DEBUG, "\n");
        rc = ble_store_ram_read_peer_sec(&key->sec, &value->sec);
        return rc;

    case BLE_STORE_OBJ_TYPE_OUR_SEC:
        BLE_HS_LOG(DEBUG, "looking up our sec; ");
   1ce86:	2104      	movs	r1, #4
   1ce88:	2200      	movs	r2, #0
   1ce8a:	4b21      	ldr	r3, [pc, #132]	; (1cf10 <ble_store_ram_read+0x9c>)
   1ce8c:	4821      	ldr	r0, [pc, #132]	; (1cf14 <ble_store_ram_read+0xa0>)
ble_store_ram_read_our_sec(struct ble_store_key_sec *key_sec,
                       struct ble_store_value_sec *value_sec)
{
    int idx;

    idx = ble_store_ram_find_sec(key_sec, ble_store_ram_our_secs, ble_store_ram_num_our_secs);
   1ce8e:	4e22      	ldr	r6, [pc, #136]	; (1cf18 <ble_store_ram_read+0xa4>)
        BLE_HS_LOG(DEBUG, "\n");
        rc = ble_store_ram_read_peer_sec(&key->sec, &value->sec);
        return rc;

    case BLE_STORE_OBJ_TYPE_OUR_SEC:
        BLE_HS_LOG(DEBUG, "looking up our sec; ");
   1ce90:	f000 f9ca 	bl	1d228 <log_printf>
        ble_store_ram_print_key_sec(&key->sec);
   1ce94:	4628      	mov	r0, r5
   1ce96:	f7ff ffbd 	bl	1ce14 <ble_store_ram_print_key_sec>
        BLE_HS_LOG(DEBUG, "\n");
   1ce9a:	481e      	ldr	r0, [pc, #120]	; (1cf14 <ble_store_ram_read+0xa0>)
   1ce9c:	4b1f      	ldr	r3, [pc, #124]	; (1cf1c <ble_store_ram_read+0xa8>)
   1ce9e:	2104      	movs	r1, #4
   1cea0:	2200      	movs	r2, #0
   1cea2:	f000 f9c1 	bl	1d228 <log_printf>
ble_store_ram_read_our_sec(struct ble_store_key_sec *key_sec,
                       struct ble_store_value_sec *value_sec)
{
    int idx;

    idx = ble_store_ram_find_sec(key_sec, ble_store_ram_our_secs, ble_store_ram_num_our_secs);
   1cea6:	4628      	mov	r0, r5
   1cea8:	4631      	mov	r1, r6
   1ceaa:	4b1d      	ldr	r3, [pc, #116]	; (1cf20 <ble_store_ram_read+0xac>)
   1ceac:	e012      	b.n	1ced4 <ble_store_ram_read+0x60>
         *
         * Perform a key lookup and populate the context object with the
         * result.  The nimble stack will use this key if this function returns
         * success.
         */
        BLE_HS_LOG(DEBUG, "looking up peer sec; ");
   1ceae:	2104      	movs	r1, #4
   1ceb0:	2200      	movs	r2, #0
   1ceb2:	4b1c      	ldr	r3, [pc, #112]	; (1cf24 <ble_store_ram_read+0xb0>)
   1ceb4:	4817      	ldr	r0, [pc, #92]	; (1cf14 <ble_store_ram_read+0xa0>)
ble_store_ram_read_peer_sec(struct ble_store_key_sec *key_sec,
                        struct ble_store_value_sec *value_sec)
{
    int idx;

    idx = ble_store_ram_find_sec(key_sec, ble_store_ram_peer_secs,
   1ceb6:	4e1c      	ldr	r6, [pc, #112]	; (1cf28 <ble_store_ram_read+0xb4>)
         *
         * Perform a key lookup and populate the context object with the
         * result.  The nimble stack will use this key if this function returns
         * success.
         */
        BLE_HS_LOG(DEBUG, "looking up peer sec; ");
   1ceb8:	f000 f9b6 	bl	1d228 <log_printf>
        ble_store_ram_print_key_sec(&key->sec);
   1cebc:	4628      	mov	r0, r5
   1cebe:	f7ff ffa9 	bl	1ce14 <ble_store_ram_print_key_sec>
        BLE_HS_LOG(DEBUG, "\n");
   1cec2:	4814      	ldr	r0, [pc, #80]	; (1cf14 <ble_store_ram_read+0xa0>)
   1cec4:	4b15      	ldr	r3, [pc, #84]	; (1cf1c <ble_store_ram_read+0xa8>)
   1cec6:	2104      	movs	r1, #4
   1cec8:	2200      	movs	r2, #0
   1ceca:	f000 f9ad 	bl	1d228 <log_printf>
ble_store_ram_read_peer_sec(struct ble_store_key_sec *key_sec,
                        struct ble_store_value_sec *value_sec)
{
    int idx;

    idx = ble_store_ram_find_sec(key_sec, ble_store_ram_peer_secs,
   1cece:	4b17      	ldr	r3, [pc, #92]	; (1cf2c <ble_store_ram_read+0xb8>)
   1ced0:	4628      	mov	r0, r5
   1ced2:	4631      	mov	r1, r6
   1ced4:	681a      	ldr	r2, [r3, #0]
   1ced6:	f7ff fedb 	bl	1cc90 <ble_store_ram_find_sec>
                             ble_store_ram_num_peer_secs);
    if (idx == -1) {
   1ceda:	1c42      	adds	r2, r0, #1
ble_store_ram_read_peer_sec(struct ble_store_key_sec *key_sec,
                        struct ble_store_value_sec *value_sec)
{
    int idx;

    idx = ble_store_ram_find_sec(key_sec, ble_store_ram_peer_secs,
   1cedc:	4601      	mov	r1, r0
                             ble_store_ram_num_peer_secs);
    if (idx == -1) {
   1cede:	d101      	bne.n	1cee4 <ble_store_ram_read+0x70>
        return BLE_HS_ENOENT;
   1cee0:	2005      	movs	r0, #5
   1cee2:	bd70      	pop	{r4, r5, r6, pc}
    idx = ble_store_ram_find_sec(key_sec, ble_store_ram_our_secs, ble_store_ram_num_our_secs);
    if (idx == -1) {
        return BLE_HS_ENOENT;
    }

    *value_sec = ble_store_ram_our_secs[idx];
   1cee4:	2250      	movs	r2, #80	; 0x50
   1cee6:	4620      	mov	r0, r4
   1cee8:	fb02 6101 	mla	r1, r2, r1, r6
   1ceec:	f7ec f886 	bl	8ffc <memcpy>
   1cef0:	e00a      	b.n	1cf08 <ble_store_ram_read+0x94>
ble_store_ram_read_cccd(struct ble_store_key_cccd *key_cccd,
                struct ble_store_value_cccd *value_cccd)
{
    int idx;

    idx = ble_store_ram_find_cccd(key_cccd);
   1cef2:	4608      	mov	r0, r1
   1cef4:	f7ff fefe 	bl	1ccf4 <ble_store_ram_find_cccd>
    if (idx == -1) {
   1cef8:	1c43      	adds	r3, r0, #1
   1cefa:	d0f1      	beq.n	1cee0 <ble_store_ram_read+0x6c>
        return BLE_HS_ENOENT;
    }

    *value_cccd = ble_store_ram_cccds[idx];
   1cefc:	4b0c      	ldr	r3, [pc, #48]	; (1cf30 <ble_store_ram_read+0xbc>)
   1cefe:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   1cf02:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   1cf04:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return 0;
   1cf08:	2000      	movs	r0, #0
   1cf0a:	bd70      	pop	{r4, r5, r6, pc}
    case BLE_STORE_OBJ_TYPE_CCCD:
        rc = ble_store_ram_read_cccd(&key->cccd, &value->cccd);
        return rc;

    default:
        return BLE_HS_ENOTSUP;
   1cf0c:	2008      	movs	r0, #8
    }
}
   1cf0e:	bd70      	pop	{r4, r5, r6, pc}
   1cf10:	00020af9 	.word	0x00020af9
   1cf14:	20003b9c 	.word	0x20003b9c
   1cf18:	20002520 	.word	0x20002520
   1cf1c:	0001fdec 	.word	0x0001fdec
   1cf20:	200027a4 	.word	0x200027a4
   1cf24:	00020ae3 	.word	0x00020ae3
   1cf28:	20002660 	.word	0x20002660
   1cf2c:	200027a8 	.word	0x200027a8
   1cf30:	20002420 	.word	0x20002420

0001cf34 <ble_store_ram_write>:
 * @return                      0 on success; BLE_HS_ENOMEM if the database is
 *                                  full.
 */
int
ble_store_ram_write(int obj_type, union ble_store_value *val)
{
   1cf34:	b570      	push	{r4, r5, r6, lr}
    int rc;

    switch (obj_type) {
   1cf36:	2802      	cmp	r0, #2
 * @return                      0 on success; BLE_HS_ENOMEM if the database is
 *                                  full.
 */
int
ble_store_ram_write(int obj_type, union ble_store_value *val)
{
   1cf38:	b08a      	sub	sp, #40	; 0x28
   1cf3a:	460c      	mov	r4, r1
    int rc;

    switch (obj_type) {
   1cf3c:	d004      	beq.n	1cf48 <ble_store_ram_write+0x14>
   1cf3e:	2803      	cmp	r0, #3
   1cf40:	d052      	beq.n	1cfe8 <ble_store_ram_write+0xb4>
   1cf42:	2801      	cmp	r0, #1
   1cf44:	d16d      	bne.n	1d022 <ble_store_ram_write+0xee>
   1cf46:	e023      	b.n	1cf90 <ble_store_ram_write+0x5c>
ble_store_ram_write_peer_sec(struct ble_store_value_sec *value_sec)
{
    struct ble_store_key_sec key_sec;
    int idx;

    BLE_HS_LOG(DEBUG, "persisting peer sec; ");
   1cf48:	2200      	movs	r2, #0
   1cf4a:	4b37      	ldr	r3, [pc, #220]	; (1d028 <ble_store_ram_write+0xf4>)
   1cf4c:	4837      	ldr	r0, [pc, #220]	; (1d02c <ble_store_ram_write+0xf8>)
    ble_store_ram_print_value_sec(value_sec);

    ble_store_key_from_value_sec(&key_sec, value_sec);
    idx = ble_store_ram_find_sec(&key_sec, ble_store_ram_peer_secs,
   1cf4e:	4e38      	ldr	r6, [pc, #224]	; (1d030 <ble_store_ram_write+0xfc>)
ble_store_ram_write_peer_sec(struct ble_store_value_sec *value_sec)
{
    struct ble_store_key_sec key_sec;
    int idx;

    BLE_HS_LOG(DEBUG, "persisting peer sec; ");
   1cf50:	2104      	movs	r1, #4
   1cf52:	f000 f969 	bl	1d228 <log_printf>
    ble_store_ram_print_value_sec(value_sec);
   1cf56:	4620      	mov	r0, r4
   1cf58:	f7ff fefa 	bl	1cd50 <ble_store_ram_print_value_sec>

    ble_store_key_from_value_sec(&key_sec, value_sec);
   1cf5c:	a802      	add	r0, sp, #8
   1cf5e:	4621      	mov	r1, r4
   1cf60:	f7fb fa4d 	bl	183fe <ble_store_key_from_value_sec>
    idx = ble_store_ram_find_sec(&key_sec, ble_store_ram_peer_secs,
   1cf64:	6835      	ldr	r5, [r6, #0]
   1cf66:	4933      	ldr	r1, [pc, #204]	; (1d034 <ble_store_ram_write+0x100>)
   1cf68:	a802      	add	r0, sp, #8
   1cf6a:	462a      	mov	r2, r5
   1cf6c:	f7ff fe90 	bl	1cc90 <ble_store_ram_find_sec>
                             ble_store_ram_num_peer_secs);
    if (idx == -1) {
   1cf70:	1c41      	adds	r1, r0, #1
   1cf72:	d10a      	bne.n	1cf8a <ble_store_ram_write+0x56>
        if (ble_store_ram_num_peer_secs >= STORE_MAX_MST_LTKS) {
   1cf74:	2d03      	cmp	r5, #3
   1cf76:	dd05      	ble.n	1cf84 <ble_store_ram_write+0x50>
            BLE_HS_LOG(DEBUG, "error persisting peer sec; too many entries "
   1cf78:	9500      	str	r5, [sp, #0]
   1cf7a:	482c      	ldr	r0, [pc, #176]	; (1d02c <ble_store_ram_write+0xf8>)
   1cf7c:	4b2e      	ldr	r3, [pc, #184]	; (1d038 <ble_store_ram_write+0x104>)
   1cf7e:	2104      	movs	r1, #4
   1cf80:	2200      	movs	r2, #0
   1cf82:	e022      	b.n	1cfca <ble_store_ram_write+0x96>
                             "(%d)\n", ble_store_ram_num_peer_secs);
            return BLE_HS_ENOMEM;
        }

        idx = ble_store_ram_num_peer_secs;
        ble_store_ram_num_peer_secs++;
   1cf84:	1c6b      	adds	r3, r5, #1
   1cf86:	6033      	str	r3, [r6, #0]
   1cf88:	4628      	mov	r0, r5
    }

    ble_store_ram_peer_secs[idx] = *value_sec;
   1cf8a:	2250      	movs	r2, #80	; 0x50
   1cf8c:	4b29      	ldr	r3, [pc, #164]	; (1d034 <ble_store_ram_write+0x100>)
   1cf8e:	e025      	b.n	1cfdc <ble_store_ram_write+0xa8>
ble_store_ram_write_our_sec(struct ble_store_value_sec *value_sec)
{
    struct ble_store_key_sec key_sec;
    int idx;

    BLE_HS_LOG(DEBUG, "persisting our sec; ");
   1cf90:	2200      	movs	r2, #0
   1cf92:	4b2a      	ldr	r3, [pc, #168]	; (1d03c <ble_store_ram_write+0x108>)
   1cf94:	4825      	ldr	r0, [pc, #148]	; (1d02c <ble_store_ram_write+0xf8>)
    ble_store_ram_print_value_sec(value_sec);

    ble_store_key_from_value_sec(&key_sec, value_sec);
    idx = ble_store_ram_find_sec(&key_sec, ble_store_ram_our_secs,
   1cf96:	4e2a      	ldr	r6, [pc, #168]	; (1d040 <ble_store_ram_write+0x10c>)
ble_store_ram_write_our_sec(struct ble_store_value_sec *value_sec)
{
    struct ble_store_key_sec key_sec;
    int idx;

    BLE_HS_LOG(DEBUG, "persisting our sec; ");
   1cf98:	2104      	movs	r1, #4
   1cf9a:	f000 f945 	bl	1d228 <log_printf>
    ble_store_ram_print_value_sec(value_sec);
   1cf9e:	4620      	mov	r0, r4
   1cfa0:	f7ff fed6 	bl	1cd50 <ble_store_ram_print_value_sec>

    ble_store_key_from_value_sec(&key_sec, value_sec);
   1cfa4:	a802      	add	r0, sp, #8
   1cfa6:	4621      	mov	r1, r4
   1cfa8:	f7fb fa29 	bl	183fe <ble_store_key_from_value_sec>
    idx = ble_store_ram_find_sec(&key_sec, ble_store_ram_our_secs,
   1cfac:	6835      	ldr	r5, [r6, #0]
   1cfae:	4925      	ldr	r1, [pc, #148]	; (1d044 <ble_store_ram_write+0x110>)
   1cfb0:	462a      	mov	r2, r5
   1cfb2:	a802      	add	r0, sp, #8
   1cfb4:	f7ff fe6c 	bl	1cc90 <ble_store_ram_find_sec>
                             ble_store_ram_num_our_secs);
    if (idx == -1) {
   1cfb8:	1c42      	adds	r2, r0, #1
   1cfba:	d10d      	bne.n	1cfd8 <ble_store_ram_write+0xa4>
        if (ble_store_ram_num_our_secs >= STORE_MAX_SLV_LTKS) {
   1cfbc:	2d03      	cmp	r5, #3
   1cfbe:	dd08      	ble.n	1cfd2 <ble_store_ram_write+0x9e>
            BLE_HS_LOG(DEBUG, "error persisting our sec; too many entries "
   1cfc0:	481a      	ldr	r0, [pc, #104]	; (1d02c <ble_store_ram_write+0xf8>)
   1cfc2:	4b21      	ldr	r3, [pc, #132]	; (1d048 <ble_store_ram_write+0x114>)
   1cfc4:	9500      	str	r5, [sp, #0]
   1cfc6:	2104      	movs	r1, #4
   1cfc8:	2200      	movs	r2, #0
   1cfca:	f000 f92d 	bl	1d228 <log_printf>
                              "(%d)\n", ble_store_ram_num_our_secs);
            return BLE_HS_ENOMEM;
   1cfce:	2006      	movs	r0, #6
   1cfd0:	e028      	b.n	1d024 <ble_store_ram_write+0xf0>
        }

        idx = ble_store_ram_num_our_secs;
        ble_store_ram_num_our_secs++;
   1cfd2:	1c6b      	adds	r3, r5, #1
   1cfd4:	6033      	str	r3, [r6, #0]
   1cfd6:	4628      	mov	r0, r5
    }

    ble_store_ram_our_secs[idx] = *value_sec;
   1cfd8:	4b1a      	ldr	r3, [pc, #104]	; (1d044 <ble_store_ram_write+0x110>)
   1cfda:	2250      	movs	r2, #80	; 0x50
   1cfdc:	fb02 3000 	mla	r0, r2, r0, r3
   1cfe0:	4621      	mov	r1, r4
   1cfe2:	f7ec f80b 	bl	8ffc <memcpy>
   1cfe6:	e01a      	b.n	1d01e <ble_store_ram_write+0xea>
ble_store_ram_write_cccd(struct ble_store_value_cccd *value_cccd)
{
    struct ble_store_key_cccd key_cccd;
    int idx;

    ble_store_key_from_value_cccd(&key_cccd, value_cccd);
   1cfe8:	a802      	add	r0, sp, #8
   1cfea:	f7fb f9fd 	bl	183e8 <ble_store_key_from_value_cccd>
    idx = ble_store_ram_find_cccd(&key_cccd);
   1cfee:	a802      	add	r0, sp, #8
   1cff0:	f7ff fe80 	bl	1ccf4 <ble_store_ram_find_cccd>
    if (idx == -1) {
   1cff4:	1c43      	adds	r3, r0, #1
   1cff6:	d10b      	bne.n	1d010 <ble_store_ram_write+0xdc>
        if (ble_store_ram_num_cccds >= STORE_MAX_SLV_LTKS) {
   1cff8:	4b14      	ldr	r3, [pc, #80]	; (1d04c <ble_store_ram_write+0x118>)
   1cffa:	6818      	ldr	r0, [r3, #0]
   1cffc:	2803      	cmp	r0, #3
   1cffe:	dd05      	ble.n	1d00c <ble_store_ram_write+0xd8>
            BLE_HS_LOG(DEBUG, "error persisting cccd; too many entries (%d)\n",
   1d000:	9000      	str	r0, [sp, #0]
   1d002:	2104      	movs	r1, #4
   1d004:	4809      	ldr	r0, [pc, #36]	; (1d02c <ble_store_ram_write+0xf8>)
   1d006:	4b12      	ldr	r3, [pc, #72]	; (1d050 <ble_store_ram_write+0x11c>)
   1d008:	2200      	movs	r2, #0
   1d00a:	e7de      	b.n	1cfca <ble_store_ram_write+0x96>
                       ble_store_ram_num_cccds);
            return BLE_HS_ENOMEM;
        }

        idx = ble_store_ram_num_cccds;
        ble_store_ram_num_cccds++;
   1d00c:	1c42      	adds	r2, r0, #1
   1d00e:	601a      	str	r2, [r3, #0]
    }

    ble_store_ram_cccds[idx] = *value_cccd;
   1d010:	4b10      	ldr	r3, [pc, #64]	; (1d054 <ble_store_ram_write+0x120>)
   1d012:	eb03 1500 	add.w	r5, r3, r0, lsl #4
   1d016:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   1d01a:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    return 0;
   1d01e:	2000      	movs	r0, #0
        rc = ble_store_ram_write_our_sec(&val->sec);
        return rc;

    case BLE_STORE_OBJ_TYPE_CCCD:
        rc = ble_store_ram_write_cccd(&val->cccd);
        return rc;
   1d020:	e000      	b.n	1d024 <ble_store_ram_write+0xf0>

    default:
        return BLE_HS_ENOTSUP;
   1d022:	2008      	movs	r0, #8
    }
}
   1d024:	b00a      	add	sp, #40	; 0x28
   1d026:	bd70      	pop	{r4, r5, r6, pc}
   1d028:	00020b0e 	.word	0x00020b0e
   1d02c:	20003b9c 	.word	0x20003b9c
   1d030:	200027a8 	.word	0x200027a8
   1d034:	20002660 	.word	0x20002660
   1d038:	00020b24 	.word	0x00020b24
   1d03c:	00020b56 	.word	0x00020b56
   1d040:	200027a4 	.word	0x200027a4
   1d044:	20002520 	.word	0x20002520
   1d048:	00020b6b 	.word	0x00020b6b
   1d04c:	200027a0 	.word	0x200027a0
   1d050:	00020b9c 	.word	0x00020b9c
   1d054:	20002420 	.word	0x20002420

0001d058 <htole16>:
htole16(void *buf, uint16_t x)
{
    uint8_t *u8ptr;

    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
   1d058:	7001      	strb	r1, [r0, #0]
    u8ptr[1] = (uint8_t)(x >> 8);
   1d05a:	0a09      	lsrs	r1, r1, #8
   1d05c:	7041      	strb	r1, [r0, #1]
   1d05e:	4770      	bx	lr

0001d060 <htole32>:
{
    uint8_t *u8ptr;

    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
    u8ptr[1] = (uint8_t)(x >> 8);
   1d060:	0a0b      	lsrs	r3, r1, #8
htole32(void *buf, uint32_t x)
{
    uint8_t *u8ptr;

    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
   1d062:	7001      	strb	r1, [r0, #0]
    u8ptr[1] = (uint8_t)(x >> 8);
   1d064:	7043      	strb	r3, [r0, #1]
    u8ptr[2] = (uint8_t)(x >> 16);
   1d066:	0c0b      	lsrs	r3, r1, #16
    u8ptr[3] = (uint8_t)(x >> 24);
   1d068:	0e09      	lsrs	r1, r1, #24
    uint8_t *u8ptr;

    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
    u8ptr[1] = (uint8_t)(x >> 8);
    u8ptr[2] = (uint8_t)(x >> 16);
   1d06a:	7083      	strb	r3, [r0, #2]
    u8ptr[3] = (uint8_t)(x >> 24);
   1d06c:	70c1      	strb	r1, [r0, #3]
   1d06e:	4770      	bx	lr

0001d070 <htole64>:
{
    uint8_t *u8ptr;

    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
    u8ptr[1] = (uint8_t)(x >> 8);
   1d070:	0a11      	lsrs	r1, r2, #8
htole64(void *buf, uint64_t x)
{
    uint8_t *u8ptr;

    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
   1d072:	7002      	strb	r2, [r0, #0]
    u8ptr[1] = (uint8_t)(x >> 8);
   1d074:	7041      	strb	r1, [r0, #1]
    u8ptr[2] = (uint8_t)(x >> 16);
   1d076:	0c11      	lsrs	r1, r2, #16
    u8ptr[3] = (uint8_t)(x >> 24);
   1d078:	0e12      	lsrs	r2, r2, #24
   1d07a:	70c2      	strb	r2, [r0, #3]
    u8ptr[4] = (uint8_t)(x >> 32);
    u8ptr[5] = (uint8_t)(x >> 40);
   1d07c:	0a1a      	lsrs	r2, r3, #8
    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
    u8ptr[1] = (uint8_t)(x >> 8);
    u8ptr[2] = (uint8_t)(x >> 16);
    u8ptr[3] = (uint8_t)(x >> 24);
    u8ptr[4] = (uint8_t)(x >> 32);
   1d07e:	7103      	strb	r3, [r0, #4]
    u8ptr[5] = (uint8_t)(x >> 40);
   1d080:	7142      	strb	r2, [r0, #5]
    u8ptr[6] = (uint8_t)(x >> 48);
   1d082:	0c1a      	lsrs	r2, r3, #16
    u8ptr[7] = (uint8_t)(x >> 56);
   1d084:	0e1b      	lsrs	r3, r3, #24
    uint8_t *u8ptr;

    u8ptr = buf;
    u8ptr[0] = (uint8_t)x;
    u8ptr[1] = (uint8_t)(x >> 8);
    u8ptr[2] = (uint8_t)(x >> 16);
   1d086:	7081      	strb	r1, [r0, #2]
    u8ptr[3] = (uint8_t)(x >> 24);
    u8ptr[4] = (uint8_t)(x >> 32);
    u8ptr[5] = (uint8_t)(x >> 40);
    u8ptr[6] = (uint8_t)(x >> 48);
   1d088:	7182      	strb	r2, [r0, #6]
    u8ptr[7] = (uint8_t)(x >> 56);
   1d08a:	71c3      	strb	r3, [r0, #7]
   1d08c:	4770      	bx	lr

0001d08e <le16toh>:
    const uint8_t *u8ptr;
    uint16_t x;

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint16_t)u8ptr[1] << 8;
   1d08e:	7842      	ldrb	r2, [r0, #1]
   1d090:	7800      	ldrb	r0, [r0, #0]

    return x;
}
   1d092:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
   1d096:	4770      	bx	lr

0001d098 <le32toh>:
    uint32_t x;

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint32_t)u8ptr[1] << 8;
    x |= (uint32_t)u8ptr[2] << 16;
   1d098:	7882      	ldrb	r2, [r0, #2]
    const uint8_t *u8ptr;
    uint32_t x;

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint32_t)u8ptr[1] << 8;
   1d09a:	7843      	ldrb	r3, [r0, #1]
{
    const uint8_t *u8ptr;
    uint32_t x;

    u8ptr = buf;
    x = u8ptr[0];
   1d09c:	7801      	ldrb	r1, [r0, #0]
    x |= (uint32_t)u8ptr[1] << 8;
    x |= (uint32_t)u8ptr[2] << 16;
    x |= (uint32_t)u8ptr[3] << 24;
   1d09e:	78c0      	ldrb	r0, [r0, #3]
    uint32_t x;

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint32_t)u8ptr[1] << 8;
    x |= (uint32_t)u8ptr[2] << 16;
   1d0a0:	0412      	lsls	r2, r2, #16
   1d0a2:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   1d0a6:	430b      	orrs	r3, r1
    x |= (uint32_t)u8ptr[3] << 24;

    return x;
}
   1d0a8:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
   1d0ac:	4770      	bx	lr

0001d0ae <le64toh>:

uint64_t
le64toh(const void *buf)
{
   1d0ae:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    const uint8_t *u8ptr;
    uint64_t x;

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint64_t)u8ptr[1] << 8;
   1d0b2:	7844      	ldrb	r4, [r0, #1]
    x |= (uint64_t)u8ptr[2] << 16;
   1d0b4:	f890 8002 	ldrb.w	r8, [r0, #2]
{
    const uint8_t *u8ptr;
    uint64_t x;

    u8ptr = buf;
    x = u8ptr[0];
   1d0b8:	7806      	ldrb	r6, [r0, #0]
    x |= (uint64_t)u8ptr[1] << 8;
   1d0ba:	0222      	lsls	r2, r4, #8
    x |= (uint64_t)u8ptr[2] << 16;
   1d0bc:	ea4f 4408 	mov.w	r4, r8, lsl #16
   1d0c0:	2500      	movs	r5, #0
   1d0c2:	4322      	orrs	r2, r4
    const uint8_t *u8ptr;
    uint64_t x;

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint64_t)u8ptr[1] << 8;
   1d0c4:	2300      	movs	r3, #0
{
    const uint8_t *u8ptr;
    uint64_t x;

    u8ptr = buf;
    x = u8ptr[0];
   1d0c6:	2700      	movs	r7, #0
   1d0c8:	432b      	orrs	r3, r5
    x |= (uint64_t)u8ptr[1] << 8;
    x |= (uint64_t)u8ptr[2] << 16;
   1d0ca:	4332      	orrs	r2, r6
    x |= (uint64_t)u8ptr[3] << 24;
   1d0cc:	78c6      	ldrb	r6, [r0, #3]
    x |= (uint64_t)u8ptr[4] << 32;
    x |= (uint64_t)u8ptr[5] << 40;
   1d0ce:	f890 8005 	ldrb.w	r8, [r0, #5]
    uint64_t x;

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint64_t)u8ptr[1] << 8;
    x |= (uint64_t)u8ptr[2] << 16;
   1d0d2:	433b      	orrs	r3, r7
    x |= (uint64_t)u8ptr[3] << 24;
   1d0d4:	2500      	movs	r5, #0
   1d0d6:	0634      	lsls	r4, r6, #24
   1d0d8:	432b      	orrs	r3, r5
    x |= (uint64_t)u8ptr[4] << 32;
   1d0da:	7905      	ldrb	r5, [r0, #4]
    x |= (uint64_t)u8ptr[5] << 40;
    x |= (uint64_t)u8ptr[6] << 48;
    x |= (uint64_t)u8ptr[7] << 56;
   1d0dc:	79c6      	ldrb	r6, [r0, #7]
    x = u8ptr[0];
    x |= (uint64_t)u8ptr[1] << 8;
    x |= (uint64_t)u8ptr[2] << 16;
    x |= (uint64_t)u8ptr[3] << 24;
    x |= (uint64_t)u8ptr[4] << 32;
    x |= (uint64_t)u8ptr[5] << 40;
   1d0de:	ea4f 2708 	mov.w	r7, r8, lsl #8

    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint64_t)u8ptr[1] << 8;
    x |= (uint64_t)u8ptr[2] << 16;
    x |= (uint64_t)u8ptr[3] << 24;
   1d0e2:	4322      	orrs	r2, r4
    x |= (uint64_t)u8ptr[4] << 32;
    x |= (uint64_t)u8ptr[5] << 40;
    x |= (uint64_t)u8ptr[6] << 48;
   1d0e4:	f890 8006 	ldrb.w	r8, [r0, #6]
    u8ptr = buf;
    x = u8ptr[0];
    x |= (uint64_t)u8ptr[1] << 8;
    x |= (uint64_t)u8ptr[2] << 16;
    x |= (uint64_t)u8ptr[3] << 24;
    x |= (uint64_t)u8ptr[4] << 32;
   1d0e8:	2400      	movs	r4, #0
   1d0ea:	4322      	orrs	r2, r4
   1d0ec:	432b      	orrs	r3, r5
    x |= (uint64_t)u8ptr[5] << 40;
   1d0ee:	4322      	orrs	r2, r4
   1d0f0:	433b      	orrs	r3, r7
    x |= (uint64_t)u8ptr[6] << 48;
   1d0f2:	ea4f 4708 	mov.w	r7, r8, lsl #16
   1d0f6:	4322      	orrs	r2, r4
   1d0f8:	433b      	orrs	r3, r7
    x |= (uint64_t)u8ptr[7] << 56;
   1d0fa:	0631      	lsls	r1, r6, #24
   1d0fc:	4620      	mov	r0, r4

    return x;
}
   1d0fe:	4310      	orrs	r0, r2
   1d100:	4319      	orrs	r1, r3
   1d102:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0001d106 <swap_in_place>:

    return x;
}
void
swap_in_place(void *buf, int len)
{
   1d106:	b510      	push	{r4, lr}
    int i;
    int j;

    u8ptr = buf;

    for (i = 0, j = len - 1; i < j; i++, j--) {
   1d108:	3901      	subs	r1, #1
   1d10a:	2300      	movs	r3, #0
   1d10c:	428b      	cmp	r3, r1
   1d10e:	da06      	bge.n	1d11e <swap_in_place+0x18>
        tmp = u8ptr[i];
   1d110:	5cc2      	ldrb	r2, [r0, r3]

        u8ptr[i] = u8ptr[j];
   1d112:	5c44      	ldrb	r4, [r0, r1]
   1d114:	54c4      	strb	r4, [r0, r3]
        u8ptr[j] = tmp;
   1d116:	5442      	strb	r2, [r0, r1]
    int i;
    int j;

    u8ptr = buf;

    for (i = 0, j = len - 1; i < j; i++, j--) {
   1d118:	3301      	adds	r3, #1
   1d11a:	3901      	subs	r1, #1
   1d11c:	e7f6      	b.n	1d10c <swap_in_place+0x6>
        tmp = u8ptr[i];

        u8ptr[i] = u8ptr[j];
        u8ptr[j] = tmp;
    }
}
   1d11e:	bd10      	pop	{r4, pc}

0001d120 <swap_buf>:

/* swap octets */
void
swap_buf(uint8_t *dst, const uint8_t *src, int len)
{
   1d120:	b510      	push	{r4, lr}
   1d122:	4410      	add	r0, r2
    int i;

    for (i = 0; i < len; i++) {
   1d124:	460b      	mov	r3, r1
   1d126:	1a5c      	subs	r4, r3, r1
   1d128:	4294      	cmp	r4, r2
   1d12a:	da04      	bge.n	1d136 <swap_buf+0x16>
        dst[len - 1 - i] = src[i];
   1d12c:	f813 4b01 	ldrb.w	r4, [r3], #1
   1d130:	f800 4d01 	strb.w	r4, [r0, #-1]!
   1d134:	e7f7      	b.n	1d126 <swap_buf+0x6>
    }
}
   1d136:	bd10      	pop	{r4, pc}

0001d138 <log_init>:
{
#ifdef NEWTMGR_PRESENT
    int rc;
#endif

    if (log_inited) {
   1d138:	4b03      	ldr	r3, [pc, #12]	; (1d148 <log_init+0x10>)
   1d13a:	781a      	ldrb	r2, [r3, #0]
   1d13c:	b90a      	cbnz	r2, 1d142 <log_init+0xa>
        return (0);
    }
    log_inited = 1;
   1d13e:	2201      	movs	r2, #1
   1d140:	701a      	strb	r2, [r3, #0]
        return (rc);
    }
#endif /* NEWTMGR_PRESENT */

    return (0);
}
   1d142:	2000      	movs	r0, #0
   1d144:	4770      	bx	lr
   1d146:	bf00      	nop
   1d148:	200027ac 	.word	0x200027ac

0001d14c <log_register>:
log_register(char *name, struct log *log, struct log_handler *lh)
{
    log->l_name = name;
    log->l_log = lh;

    STAILQ_INSERT_TAIL(&g_log_list, log, l_next);
   1d14c:	4b04      	ldr	r3, [pc, #16]	; (1d160 <log_register+0x14>)

int
log_register(char *name, struct log *log, struct log_handler *lh)
{
    log->l_name = name;
    log->l_log = lh;
   1d14e:	e881 0005 	stmia.w	r1, {r0, r2}

    STAILQ_INSERT_TAIL(&g_log_list, log, l_next);
   1d152:	685a      	ldr	r2, [r3, #4]
   1d154:	2000      	movs	r0, #0
   1d156:	6088      	str	r0, [r1, #8]
   1d158:	6011      	str	r1, [r2, #0]
   1d15a:	3108      	adds	r1, #8
   1d15c:	6059      	str	r1, [r3, #4]

    return (0);
}
   1d15e:	4770      	bx	lr
   1d160:	200003b8 	.word	0x200003b8
   1d164:	00000000 	.word	0x00000000

0001d168 <log_append>:

int
log_append(struct log *log, uint16_t module, uint16_t level, void *data,
        uint16_t len)
{
   1d168:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d16c:	461c      	mov	r4, r3
    struct log_entry_hdr *ue;
    int rc;
    struct os_timeval tv;
    int64_t prev_ts;

    if (log->l_name == NULL || log->l_log == NULL) {
   1d16e:	6803      	ldr	r3, [r0, #0]
}

int
log_append(struct log *log, uint16_t module, uint16_t level, void *data,
        uint16_t len)
{
   1d170:	b085      	sub	sp, #20
   1d172:	4605      	mov	r5, r0
   1d174:	4688      	mov	r8, r1
   1d176:	4691      	mov	r9, r2
    struct log_entry_hdr *ue;
    int rc;
    struct os_timeval tv;
    int64_t prev_ts;

    if (log->l_name == NULL || log->l_log == NULL) {
   1d178:	2b00      	cmp	r3, #0
   1d17a:	d047      	beq.n	1d20c <log_append+0xa4>
   1d17c:	6843      	ldr	r3, [r0, #4]
   1d17e:	2b00      	cmp	r3, #0
   1d180:	d044      	beq.n	1d20c <log_append+0xa4>
        goto err;
    }

    ue = (struct log_entry_hdr *) data;

    g_log_info.li_index++;
   1d182:	4e27      	ldr	r6, [pc, #156]	; (1d220 <log_append+0xb8>)
   1d184:	7a33      	ldrb	r3, [r6, #8]

    /* Try to get UTC Time */
    rc = os_gettimeofday(&tv, NULL);
   1d186:	4668      	mov	r0, sp
        goto err;
    }

    ue = (struct log_entry_hdr *) data;

    g_log_info.li_index++;
   1d188:	3301      	adds	r3, #1

    /* Try to get UTC Time */
    rc = os_gettimeofday(&tv, NULL);
   1d18a:	2100      	movs	r1, #0
        goto err;
    }

    ue = (struct log_entry_hdr *) data;

    g_log_info.li_index++;
   1d18c:	7233      	strb	r3, [r6, #8]

    /* Try to get UTC Time */
    rc = os_gettimeofday(&tv, NULL);
   1d18e:	f7ed fb69 	bl	a864 <os_gettimeofday>
   1d192:	46b2      	mov	sl, r6
    if (rc || tv.tv_sec < UTC01_01_2016) {
   1d194:	b938      	cbnz	r0, 1d1a6 <log_append+0x3e>
   1d196:	e9dd 2300 	ldrd	r2, r3, [sp]
   1d19a:	a11f      	add	r1, pc, #124	; (adr r1, 1d218 <log_append+0xb0>)
   1d19c:	e9d1 0100 	ldrd	r0, r1, [r1]
   1d1a0:	4290      	cmp	r0, r2
   1d1a2:	4199      	sbcs	r1, r3
   1d1a4:	db02      	blt.n	1d1ac <log_append+0x44>
        ue->ue_ts = os_get_uptime_usec();
   1d1a6:	f7ed fb7d 	bl	a8a4 <os_get_uptime_usec>
   1d1aa:	e008      	b.n	1d1be <log_append+0x56>
    } else {
        ue->ue_ts = tv.tv_sec * 1000000 + tv.tv_usec;
   1d1ac:	4e1d      	ldr	r6, [pc, #116]	; (1d224 <log_append+0xbc>)
   1d1ae:	fba2 0106 	umull	r0, r1, r2, r6
   1d1b2:	fb06 1103 	mla	r1, r6, r3, r1
   1d1b6:	9b02      	ldr	r3, [sp, #8]
   1d1b8:	18c0      	adds	r0, r0, r3
   1d1ba:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
   1d1be:	6020      	str	r0, [r4, #0]
   1d1c0:	6061      	str	r1, [r4, #4]
    }

    prev_ts = g_log_info.li_timestamp;
    g_log_info.li_timestamp = ue->ue_ts;
   1d1c2:	6822      	ldr	r2, [r4, #0]
   1d1c4:	6863      	ldr	r3, [r4, #4]
        ue->ue_ts = os_get_uptime_usec();
    } else {
        ue->ue_ts = tv.tv_sec * 1000000 + tv.tv_usec;
    }

    prev_ts = g_log_info.li_timestamp;
   1d1c6:	f8df b058 	ldr.w	fp, [pc, #88]	; 1d220 <log_append+0xb8>
   1d1ca:	e9da 6700 	ldrd	r6, r7, [sl]
    g_log_info.li_timestamp = ue->ue_ts;
   1d1ce:	e88a 000c 	stmia.w	sl, {r2, r3}
    ue->ue_level = level;
    ue->ue_module = module;
   1d1d2:	f8a4 8008 	strh.w	r8, [r4, #8]
    ue->ue_index = g_log_info.li_index;
   1d1d6:	f89a 3008 	ldrb.w	r3, [sl, #8]
        ue->ue_ts = tv.tv_sec * 1000000 + tv.tv_usec;
    }

    prev_ts = g_log_info.li_timestamp;
    g_log_info.li_timestamp = ue->ue_ts;
    ue->ue_level = level;
   1d1da:	f884 900b 	strb.w	r9, [r4, #11]
    ue->ue_module = module;
    ue->ue_index = g_log_info.li_index;
   1d1de:	72a3      	strb	r3, [r4, #10]

    rc = log->l_log->log_append(log, data, len + LOG_ENTRY_HDR_SIZE);
   1d1e0:	686b      	ldr	r3, [r5, #4]
   1d1e2:	f8bd 2038 	ldrh.w	r2, [sp, #56]	; 0x38
   1d1e6:	689b      	ldr	r3, [r3, #8]
   1d1e8:	4628      	mov	r0, r5
   1d1ea:	4621      	mov	r1, r4
   1d1ec:	320c      	adds	r2, #12
   1d1ee:	4798      	blx	r3
    if (rc != 0) {
   1d1f0:	b970      	cbnz	r0, 1d210 <log_append+0xa8>
        goto err;
    }

    /* Resetting index every millisecond */
    if (g_log_info.li_timestamp > 1000 + prev_ts) {
   1d1f2:	e9db 2300 	ldrd	r2, r3, [fp]
   1d1f6:	f516 767a 	adds.w	r6, r6, #1000	; 0x3e8
   1d1fa:	f147 0700 	adc.w	r7, r7, #0
   1d1fe:	4296      	cmp	r6, r2
   1d200:	eb77 0303 	sbcs.w	r3, r7, r3
   1d204:	da04      	bge.n	1d210 <log_append+0xa8>
        g_log_info.li_index = 0;
   1d206:	f88b 0008 	strb.w	r0, [fp, #8]
   1d20a:	e001      	b.n	1d210 <log_append+0xa8>
    int rc;
    struct os_timeval tv;
    int64_t prev_ts;

    if (log->l_name == NULL || log->l_log == NULL) {
        rc = -1;
   1d20c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }

    return (0);
err:
    return (rc);
}
   1d210:	b005      	add	sp, #20
   1d212:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d216:	bf00      	nop
   1d218:	5685c17f 	.word	0x5685c17f
   1d21c:	00000000 	.word	0x00000000
   1d220:	20002c80 	.word	0x20002c80
   1d224:	000f4240 	.word	0x000f4240

0001d228 <log_printf>:

void
log_printf(struct log *log, uint16_t module, uint16_t level, char *msg,
        ...)
{
   1d228:	b408      	push	{r3}
   1d22a:	b570      	push	{r4, r5, r6, lr}
   1d22c:	b0a7      	sub	sp, #156	; 0x9c
   1d22e:	ab2b      	add	r3, sp, #172	; 0xac
   1d230:	4606      	mov	r6, r0
   1d232:	460d      	mov	r5, r1
   1d234:	4614      	mov	r4, r2
    va_list args;
    char buf[LOG_ENTRY_HDR_SIZE + LOG_PRINTF_MAX_ENTRY_LEN];
    int len;

    va_start(args, msg);
    len = vsnprintf(&buf[LOG_ENTRY_HDR_SIZE], LOG_PRINTF_MAX_ENTRY_LEN, msg,
   1d236:	a806      	add	r0, sp, #24
}

void
log_printf(struct log *log, uint16_t module, uint16_t level, char *msg,
        ...)
{
   1d238:	f853 2b04 	ldr.w	r2, [r3], #4
    va_list args;
    char buf[LOG_ENTRY_HDR_SIZE + LOG_PRINTF_MAX_ENTRY_LEN];
    int len;

    va_start(args, msg);
   1d23c:	9302      	str	r3, [sp, #8]
    len = vsnprintf(&buf[LOG_ENTRY_HDR_SIZE], LOG_PRINTF_MAX_ENTRY_LEN, msg,
   1d23e:	2180      	movs	r1, #128	; 0x80
   1d240:	f7ec f8f4 	bl	942c <vsnprintf>
   1d244:	287f      	cmp	r0, #127	; 0x7f
   1d246:	bfa8      	it	ge
   1d248:	207f      	movge	r0, #127	; 0x7f
            args);
    if (len >= LOG_PRINTF_MAX_ENTRY_LEN) {
        len = LOG_PRINTF_MAX_ENTRY_LEN-1;
    }

    log_append(log, module, level, (uint8_t *) buf, len);
   1d24a:	b280      	uxth	r0, r0
   1d24c:	9000      	str	r0, [sp, #0]
   1d24e:	4629      	mov	r1, r5
   1d250:	4630      	mov	r0, r6
   1d252:	4622      	mov	r2, r4
   1d254:	ab03      	add	r3, sp, #12
   1d256:	f7ff ff87 	bl	1d168 <log_append>
}
   1d25a:	b027      	add	sp, #156	; 0x9c
   1d25c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1d260:	b001      	add	sp, #4
   1d262:	4770      	bx	lr

0001d264 <log_console_read>:
log_console_read(struct log *log, void *dptr, void *buf, uint16_t offset,
        uint16_t len)
{
    /* You don't read console, console read you */
    return (OS_EINVAL);
}
   1d264:	2002      	movs	r0, #2
   1d266:	4770      	bx	lr

0001d268 <log_console_walk>:
static int
log_console_walk(struct log *log, log_walk_func_t walk_func, void *arg)
{
    /* You don't walk console, console walk you. */
    return (OS_EINVAL);
}
   1d268:	2002      	movs	r0, #2
   1d26a:	4770      	bx	lr

0001d26c <log_console_flush>:
static int
log_console_flush(struct log *log)
{
    /* You don't flush console, console flush you. */
    return (OS_EINVAL);
}
   1d26c:	2002      	movs	r0, #2
   1d26e:	4770      	bx	lr

0001d270 <log_console_append>:
#include "log/log.h"


static int
log_console_append(struct log *log, void *buf, int len)
{
   1d270:	b538      	push	{r3, r4, r5, lr}
   1d272:	460c      	mov	r4, r1
   1d274:	4615      	mov	r5, r2
    struct log_entry_hdr *hdr;

    if (!console_is_init()) {
   1d276:	f7ec fa9d 	bl	97b4 <console_is_init>
   1d27a:	b170      	cbz	r0, 1d29a <log_console_append+0x2a>
        return (0);
    }

    if (!console_is_midline) {
   1d27c:	4b08      	ldr	r3, [pc, #32]	; (1d2a0 <log_console_append+0x30>)
   1d27e:	681b      	ldr	r3, [r3, #0]
   1d280:	b92b      	cbnz	r3, 1d28e <log_console_append+0x1e>
        hdr = (struct log_entry_hdr *) buf;
        console_printf("[ts=%lussb, mod=%u level=%u] ",
   1d282:	4808      	ldr	r0, [pc, #32]	; (1d2a4 <log_console_append+0x34>)
   1d284:	6821      	ldr	r1, [r4, #0]
   1d286:	8922      	ldrh	r2, [r4, #8]
   1d288:	7ae3      	ldrb	r3, [r4, #11]
   1d28a:	f000 fc47 	bl	1db1c <console_printf>
                (unsigned long) hdr->ue_ts, hdr->ue_module,
                hdr->ue_level);
    }

    console_write((char *) buf + LOG_ENTRY_HDR_SIZE, len - LOG_ENTRY_HDR_SIZE);
   1d28e:	f104 000c 	add.w	r0, r4, #12
   1d292:	f1a5 010c 	sub.w	r1, r5, #12
   1d296:	f7ec fa87 	bl	97a8 <console_write>

    return (0);
}
   1d29a:	2000      	movs	r0, #0
   1d29c:	bd38      	pop	{r3, r4, r5, pc}
   1d29e:	bf00      	nop
   1d2a0:	20002d14 	.word	0x20002d14
   1d2a4:	00020bfa 	.word	0x00020bfa

0001d2a8 <log_console_handler_init>:
    return (OS_EINVAL);
}

int
log_console_handler_init(struct log_handler *handler)
{
   1d2a8:	4603      	mov	r3, r0
    handler->log_type = LOG_TYPE_STREAM;
    handler->log_read = log_console_read;
   1d2aa:	4a06      	ldr	r2, [pc, #24]	; (1d2c4 <log_console_handler_init+0x1c>)
   1d2ac:	605a      	str	r2, [r3, #4]
    handler->log_append = log_console_append;
   1d2ae:	4a06      	ldr	r2, [pc, #24]	; (1d2c8 <log_console_handler_init+0x20>)
   1d2b0:	609a      	str	r2, [r3, #8]
    handler->log_walk = log_console_walk;
   1d2b2:	4a06      	ldr	r2, [pc, #24]	; (1d2cc <log_console_handler_init+0x24>)
   1d2b4:	60da      	str	r2, [r3, #12]
}

int
log_console_handler_init(struct log_handler *handler)
{
    handler->log_type = LOG_TYPE_STREAM;
   1d2b6:	2000      	movs	r0, #0
    handler->log_read = log_console_read;
    handler->log_append = log_console_append;
    handler->log_walk = log_console_walk;
    handler->log_flush = log_console_flush;
   1d2b8:	4a05      	ldr	r2, [pc, #20]	; (1d2d0 <log_console_handler_init+0x28>)
}

int
log_console_handler_init(struct log_handler *handler)
{
    handler->log_type = LOG_TYPE_STREAM;
   1d2ba:	6018      	str	r0, [r3, #0]
    handler->log_read = log_console_read;
    handler->log_append = log_console_append;
    handler->log_walk = log_console_walk;
    handler->log_flush = log_console_flush;
   1d2bc:	611a      	str	r2, [r3, #16]
    handler->log_arg = NULL;
   1d2be:	6198      	str	r0, [r3, #24]
    handler->log_rtr_erase = NULL;
   1d2c0:	6158      	str	r0, [r3, #20]

    return (0);
}
   1d2c2:	4770      	bx	lr
   1d2c4:	0001d265 	.word	0x0001d265
   1d2c8:	0001d271 	.word	0x0001d271
   1d2cc:	0001d269 	.word	0x0001d269
   1d2d0:	0001d26d 	.word	0x0001d26d

0001d2d4 <stats_register>:
    return (cur);
}

int
stats_register(char *name, struct stats_hdr *shdr)
{
   1d2d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int rc;

    /* Don't allow duplicate entries, return an error if this stat
     * is already registered.
     */
    STAILQ_FOREACH(cur, &g_stats_registry, s_next) {
   1d2d6:	4e0d      	ldr	r6, [pc, #52]	; (1d30c <stats_register+0x38>)
   1d2d8:	6834      	ldr	r4, [r6, #0]
    return (cur);
}

int
stats_register(char *name, struct stats_hdr *shdr)
{
   1d2da:	4607      	mov	r7, r0
   1d2dc:	460d      	mov	r5, r1
    int rc;

    /* Don't allow duplicate entries, return an error if this stat
     * is already registered.
     */
    STAILQ_FOREACH(cur, &g_stats_registry, s_next) {
   1d2de:	b134      	cbz	r4, 1d2ee <stats_register+0x1a>
        if (!strcmp(cur->s_name, name)) {
   1d2e0:	6820      	ldr	r0, [r4, #0]
   1d2e2:	4639      	mov	r1, r7
   1d2e4:	f000 fc0f 	bl	1db06 <strcmp>
   1d2e8:	b168      	cbz	r0, 1d306 <stats_register+0x32>
    int rc;

    /* Don't allow duplicate entries, return an error if this stat
     * is already registered.
     */
    STAILQ_FOREACH(cur, &g_stats_registry, s_next) {
   1d2ea:	68a4      	ldr	r4, [r4, #8]
   1d2ec:	e7f7      	b.n	1d2de <stats_register+0xa>
        }
    }

    shdr->s_name = name;

    STAILQ_INSERT_TAIL(&g_stats_registry, shdr, s_next);
   1d2ee:	6873      	ldr	r3, [r6, #4]

    STATS_INC(g_stats_stats, num_registered);
   1d2f0:	4a07      	ldr	r2, [pc, #28]	; (1d310 <stats_register+0x3c>)
            rc = -1;
            goto err;
        }
    }

    shdr->s_name = name;
   1d2f2:	602f      	str	r7, [r5, #0]

    STAILQ_INSERT_TAIL(&g_stats_registry, shdr, s_next);
   1d2f4:	60ac      	str	r4, [r5, #8]
   1d2f6:	601d      	str	r5, [r3, #0]

    STATS_INC(g_stats_stats, num_registered);
   1d2f8:	68d3      	ldr	r3, [r2, #12]
        }
    }

    shdr->s_name = name;

    STAILQ_INSERT_TAIL(&g_stats_registry, shdr, s_next);
   1d2fa:	3508      	adds	r5, #8

    STATS_INC(g_stats_stats, num_registered);
   1d2fc:	3301      	adds	r3, #1
        }
    }

    shdr->s_name = name;

    STAILQ_INSERT_TAIL(&g_stats_registry, shdr, s_next);
   1d2fe:	6075      	str	r5, [r6, #4]

    STATS_INC(g_stats_stats, num_registered);
   1d300:	60d3      	str	r3, [r2, #12]
   1d302:	4620      	mov	r0, r4
   1d304:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    return (0);
err:
    return (rc);
   1d306:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   1d30a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1d30c:	200003c0 	.word	0x200003c0
   1d310:	20003df8 	.word	0x20003df8

0001d314 <stats_module_init>:
}


int
stats_module_init(void)
{
   1d314:	b538      	push	{r3, r4, r5, lr}
    int rc;

    if (stats_module_inited) {
   1d316:	4b0a      	ldr	r3, [pc, #40]	; (1d340 <stats_module_init+0x2c>)
   1d318:	7819      	ldrb	r1, [r3, #0]
   1d31a:	b979      	cbnz	r1, 1d33c <stats_module_init+0x28>

int
stats_init(struct stats_hdr *shdr, uint8_t size, uint8_t cnt,
        struct stats_name_map *map, uint8_t map_cnt)
{
    memset((uint8_t *) shdr, 0, sizeof(*shdr) + (size * cnt));
   1d31c:	4c09      	ldr	r4, [pc, #36]	; (1d344 <stats_module_init+0x30>)
    int rc;

    if (stats_module_inited) {
        return 0;
    }
    stats_module_inited = 1;
   1d31e:	2501      	movs	r5, #1

int
stats_init(struct stats_hdr *shdr, uint8_t size, uint8_t cnt,
        struct stats_name_map *map, uint8_t map_cnt)
{
    memset((uint8_t *) shdr, 0, sizeof(*shdr) + (size * cnt));
   1d320:	4620      	mov	r0, r4
   1d322:	2210      	movs	r2, #16
    int rc;

    if (stats_module_inited) {
        return 0;
    }
    stats_module_inited = 1;
   1d324:	701d      	strb	r5, [r3, #0]

int
stats_init(struct stats_hdr *shdr, uint8_t size, uint8_t cnt,
        struct stats_name_map *map, uint8_t map_cnt)
{
    memset((uint8_t *) shdr, 0, sizeof(*shdr) + (size * cnt));
   1d326:	f7eb fe74 	bl	9012 <memset>

    shdr->s_size = size;
   1d32a:	2304      	movs	r3, #4
   1d32c:	7123      	strb	r3, [r4, #4]
    shdr->s_cnt = cnt;
   1d32e:	7165      	strb	r5, [r4, #5]
                    STATS_NAME_INIT_PARMS(stats));
    if (rc != 0) {
        goto err;
    }

    rc = stats_register("stat", STATS_HDR(g_stats_stats));
   1d330:	4621      	mov	r1, r4
   1d332:	4805      	ldr	r0, [pc, #20]	; (1d348 <stats_module_init+0x34>)
    }

    return (0);
err:
    return (rc);
}
   1d334:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                    STATS_NAME_INIT_PARMS(stats));
    if (rc != 0) {
        goto err;
    }

    rc = stats_register("stat", STATS_HDR(g_stats_stats));
   1d338:	f7ff bfcc 	b.w	1d2d4 <stats_register>
    }

    return (0);
err:
    return (rc);
}
   1d33c:	2000      	movs	r0, #0
   1d33e:	bd38      	pop	{r3, r4, r5, pc}
   1d340:	200027ad 	.word	0x200027ad
   1d344:	20003df8 	.word	0x20003df8
   1d348:	00020c18 	.word	0x00020c18

0001d34c <stats_init_and_reg>:
 * Initializes and registers the specified statistics section.
 */
int
stats_init_and_reg(struct stats_hdr *shdr, uint8_t size, uint8_t cnt,
                   struct stats_name_map *map, uint8_t map_cnt, char *name)
{
   1d34c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d34e:	9f07      	ldr	r7, [sp, #28]
   1d350:	4604      	mov	r4, r0
   1d352:	4615      	mov	r5, r2

int
stats_init(struct stats_hdr *shdr, uint8_t size, uint8_t cnt,
        struct stats_name_map *map, uint8_t map_cnt)
{
    memset((uint8_t *) shdr, 0, sizeof(*shdr) + (size * cnt));
   1d354:	fb11 f202 	smulbb	r2, r1, r2
 * Initializes and registers the specified statistics section.
 */
int
stats_init_and_reg(struct stats_hdr *shdr, uint8_t size, uint8_t cnt,
                   struct stats_name_map *map, uint8_t map_cnt, char *name)
{
   1d358:	460e      	mov	r6, r1

int
stats_init(struct stats_hdr *shdr, uint8_t size, uint8_t cnt,
        struct stats_name_map *map, uint8_t map_cnt)
{
    memset((uint8_t *) shdr, 0, sizeof(*shdr) + (size * cnt));
   1d35a:	320c      	adds	r2, #12
   1d35c:	2100      	movs	r1, #0
   1d35e:	f7eb fe58 	bl	9012 <memset>

    shdr->s_size = size;
   1d362:	7126      	strb	r6, [r4, #4]
    shdr->s_cnt = cnt;
   1d364:	7165      	strb	r5, [r4, #5]
    rc = stats_init(shdr, size, cnt, map, map_cnt);
    if (rc != 0) {
        return rc;
    }

    rc = stats_register(name, shdr);
   1d366:	4638      	mov	r0, r7
   1d368:	4621      	mov	r1, r4
    if (rc != 0) {
        return rc;
    }

    return rc;
}
   1d36a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    rc = stats_init(shdr, size, cnt, map, map_cnt);
    if (rc != 0) {
        return rc;
    }

    rc = stats_register(name, shdr);
   1d36e:	f7ff bfb1 	b.w	1d2d4 <stats_register>

0001d372 <_close>:

int
_close(int fd)
{
    return -1;
}
   1d372:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d376:	4770      	bx	lr

0001d378 <_exit>:
}


void
_exit(int s)
{
   1d378:	b508      	push	{r3, lr}
    system_reset();
   1d37a:	f000 f93f 	bl	1d5fc <system_reset>
	...

0001d380 <bsp_init>:
    return FLASH_AREA_IMAGE_0;
}

void
bsp_init(void)
{
   1d380:	b508      	push	{r3, lr}
    /*
     * XXX this reference is here to keep this function in.
     */
    _sbrk(0);
   1d382:	2000      	movs	r0, #0
   1d384:	f000 f80c 	bl	1d3a0 <_sbrk>
    _close(0);
   1d388:	2000      	movs	r0, #0
   1d38a:	f7ff fff2 	bl	1d372 <_close>

    flash_area_init(bsp_flash_areas,
   1d38e:	4803      	ldr	r0, [pc, #12]	; (1d39c <bsp_init+0x1c>)
   1d390:	2105      	movs	r1, #5
      sizeof(bsp_flash_areas) / sizeof(bsp_flash_areas[0]));
}
   1d392:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     * XXX this reference is here to keep this function in.
     */
    _sbrk(0);
    _close(0);

    flash_area_init(bsp_flash_areas,
   1d396:	f000 b825 	b.w	1d3e4 <flash_area_init>
   1d39a:	bf00      	nop
   1d39c:	200003c8 	.word	0x200003c8

0001d3a0 <_sbrk>:

static char *brk = &__HeapBase;

void *
_sbrk(int incr)
{
   1d3a0:	4a0d      	ldr	r2, [pc, #52]	; (1d3d8 <_sbrk+0x38>)
   1d3a2:	b508      	push	{r3, lr}
    void *prev_brk;

    if (incr < 0) {
   1d3a4:	1e03      	subs	r3, r0, #0
        /* Returning memory to the heap. */
        incr = -incr;
        if (brk - incr < &__HeapBase) {
   1d3a6:	6810      	ldr	r0, [r2, #0]
void *
_sbrk(int incr)
{
    void *prev_brk;

    if (incr < 0) {
   1d3a8:	da07      	bge.n	1d3ba <_sbrk+0x1a>
        /* Returning memory to the heap. */
        incr = -incr;
        if (brk - incr < &__HeapBase) {
   1d3aa:	490c      	ldr	r1, [pc, #48]	; (1d3dc <_sbrk+0x3c>)
   1d3ac:	4403      	add	r3, r0
   1d3ae:	428b      	cmp	r3, r1
   1d3b0:	d208      	bcs.n	1d3c4 <_sbrk+0x24>
            prev_brk = (void *)-1;
            errno = EINVAL;
   1d3b2:	f001 fc05 	bl	1ebc0 <__errno>
   1d3b6:	2316      	movs	r3, #22
   1d3b8:	e009      	b.n	1d3ce <_sbrk+0x2e>
            prev_brk = brk;
            brk -= incr;
        }
    } else {
        /* Allocating memory from the heap. */
        if (&__HeapLimit - brk >= incr) {
   1d3ba:	4909      	ldr	r1, [pc, #36]	; (1d3e0 <_sbrk+0x40>)
   1d3bc:	1a09      	subs	r1, r1, r0
   1d3be:	4299      	cmp	r1, r3
   1d3c0:	db02      	blt.n	1d3c8 <_sbrk+0x28>
            prev_brk = brk;
            brk += incr;
   1d3c2:	4403      	add	r3, r0
   1d3c4:	6013      	str	r3, [r2, #0]
   1d3c6:	bd08      	pop	{r3, pc}
        } else {
            prev_brk = (void *)-1;
            errno = ENOMEM;
   1d3c8:	f001 fbfa 	bl	1ebc0 <__errno>
   1d3cc:	230c      	movs	r3, #12
   1d3ce:	6003      	str	r3, [r0, #0]
        /* Allocating memory from the heap. */
        if (&__HeapLimit - brk >= incr) {
            prev_brk = brk;
            brk += incr;
        } else {
            prev_brk = (void *)-1;
   1d3d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
            errno = ENOMEM;
        }
    }

    return prev_brk;
}
   1d3d4:	bd08      	pop	{r3, pc}
   1d3d6:	bf00      	nop
   1d3d8:	20000404 	.word	0x20000404
   1d3dc:	20003e14 	.word	0x20003e14
   1d3e0:	2000fe50 	.word	0x2000fe50

0001d3e4 <flash_area_init>:
static int flash_map_entries;

void
flash_area_init(const struct flash_area *map, int map_entries)
{
    flash_map = map;
   1d3e4:	4b02      	ldr	r3, [pc, #8]	; (1d3f0 <flash_area_init+0xc>)
   1d3e6:	6018      	str	r0, [r3, #0]
    flash_map_entries = map_entries;
   1d3e8:	4b02      	ldr	r3, [pc, #8]	; (1d3f4 <flash_area_init+0x10>)
   1d3ea:	6019      	str	r1, [r3, #0]
   1d3ec:	4770      	bx	lr
   1d3ee:	bf00      	nop
   1d3f0:	200027b0 	.word	0x200027b0
   1d3f4:	200027b4 	.word	0x200027b4

0001d3f8 <nrf52_os_tick_counter.part.0>:
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
   1d3f8:	2200      	movs	r2, #0
        return (result & 0x007fffff);
    }
}

static inline uint32_t
nrf52_os_tick_counter(void)
   1d3fa:	b508      	push	{r3, lr}
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
   1d3fc:	4802      	ldr	r0, [pc, #8]	; (1d408 <nrf52_os_tick_counter.part.0+0x10>)
   1d3fe:	2155      	movs	r1, #85	; 0x55
   1d400:	4613      	mov	r3, r2
   1d402:	f7ec fc65 	bl	9cd0 <__assert_func>
   1d406:	bf00      	nop
   1d408:	00020c1d 	.word	0x00020c1d

0001d40c <sub24>:
static inline int
sub24(uint32_t x, uint32_t y)
{
    int result;

    assert(x <= 0xffffff);
   1d40c:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 * sub24(0x7fffff, 0) = 8388607
 * sub24(0x800000, 0) = -8388608
 */
static inline int
sub24(uint32_t x, uint32_t y)
{
   1d410:	b508      	push	{r3, lr}
    int result;

    assert(x <= 0xffffff);
   1d412:	d302      	bcc.n	1d41a <sub24+0xe>
   1d414:	480a      	ldr	r0, [pc, #40]	; (1d440 <sub24+0x34>)
   1d416:	2143      	movs	r1, #67	; 0x43
   1d418:	e004      	b.n	1d424 <sub24+0x18>
    assert(y <= 0xffffff);
   1d41a:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
   1d41e:	d305      	bcc.n	1d42c <sub24+0x20>
   1d420:	4807      	ldr	r0, [pc, #28]	; (1d440 <sub24+0x34>)
   1d422:	2144      	movs	r1, #68	; 0x44
   1d424:	2200      	movs	r2, #0
   1d426:	4613      	mov	r3, r2
   1d428:	f7ec fc52 	bl	9cd0 <__assert_func>

    result = x - y;
   1d42c:	1a40      	subs	r0, r0, r1
    if (result & 0x800000) {
   1d42e:	0203      	lsls	r3, r0, #8
        return (result | 0xff800000);
   1d430:	bf46      	itte	mi
   1d432:	ea6f 2040 	mvnmi.w	r0, r0, lsl #9
   1d436:	ea6f 2050 	mvnmi.w	r0, r0, lsr #9
    } else {
        return (result & 0x007fffff);
   1d43a:	f3c0 0016 	ubfxpl	r0, r0, #0, #23
    }
}
   1d43e:	bd08      	pop	{r3, pc}
   1d440:	00020c1d 	.word	0x00020c1d

0001d444 <nrf52_os_tick_set_ocmp>:
#endif
}

static inline void
nrf52_os_tick_set_ocmp(uint32_t ocmp)
{
   1d444:	b538      	push	{r3, r4, r5, lr}
   1d446:	4604      	mov	r4, r0
    uint32_t counter;

    OS_ASSERT_CRITICAL();
   1d448:	f7ec fa73 	bl	9932 <os_arch_in_critical>
   1d44c:	4602      	mov	r2, r0
   1d44e:	b970      	cbnz	r0, 1d46e <nrf52_os_tick_set_ocmp+0x2a>
   1d450:	480d      	ldr	r0, [pc, #52]	; (1d488 <nrf52_os_tick_set_ocmp+0x44>)
   1d452:	2167      	movs	r1, #103	; 0x67
   1d454:	4613      	mov	r3, r2
   1d456:	f7ec fc3b 	bl	9cd0 <__assert_func>
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();

#if defined(BSP_HAS_32768_XTAL)
    return OS_TICK_TIMER->COUNTER;
   1d45a:	f8d5 1504 	ldr.w	r1, [r5, #1284]	; 0x504
         *   may not trigger a compare event.
         *
         * - If Counter is 'N' writing (N + 2) to CC register is guaranteed
         *   to trigger a compare event at 'N + 2'.
         */
        delta = sub24(ocmp, counter);
   1d45e:	4620      	mov	r0, r4
   1d460:	f7ff ffd4 	bl	1d40c <sub24>
        if (delta > 2) {
   1d464:	2802      	cmp	r0, #2
   1d466:	dc0d      	bgt.n	1d484 <nrf52_os_tick_set_ocmp+0x40>
        counter = nrf52_os_tick_counter();
        if (TIMER_LT(counter, ocmp)) {
            break;
        }
#endif
        ocmp += g_hal_os_tick.ticks_per_ostick;
   1d468:	4b08      	ldr	r3, [pc, #32]	; (1d48c <nrf52_os_tick_set_ocmp+0x48>)
   1d46a:	681b      	ldr	r3, [r3, #0]
   1d46c:	441c      	add	r4, r3
    while (1) {
#if defined(BSP_HAS_32768_XTAL)
        int delta;

        ocmp &= 0xffffff;
        OS_TICK_TIMER->CC[OS_TICK_CMPREG] = ocmp;
   1d46e:	4d08      	ldr	r5, [pc, #32]	; (1d490 <nrf52_os_tick_set_ocmp+0x4c>)
    OS_ASSERT_CRITICAL();
    while (1) {
#if defined(BSP_HAS_32768_XTAL)
        int delta;

        ocmp &= 0xffffff;
   1d470:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        OS_TICK_TIMER->CC[OS_TICK_CMPREG] = ocmp;
   1d474:	f8c5 454c 	str.w	r4, [r5, #1356]	; 0x54c
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
   1d478:	f7ec fa5b 	bl	9932 <os_arch_in_critical>
   1d47c:	2800      	cmp	r0, #0
   1d47e:	d1ec      	bne.n	1d45a <nrf52_os_tick_set_ocmp+0x16>
   1d480:	f7ff ffba 	bl	1d3f8 <nrf52_os_tick_counter.part.0>
   1d484:	bd38      	pop	{r3, r4, r5, pc}
   1d486:	bf00      	nop
   1d488:	00020c1d 	.word	0x00020c1d
   1d48c:	20003e08 	.word	0x20003e08
   1d490:	40011000 	.word	0x40011000

0001d494 <nrf52_timer_handler>:
    }
}

static void
nrf52_timer_handler(void)
{
   1d494:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ticks;
    os_sr_t sr;
    uint32_t counter;

    OS_ENTER_CRITICAL(sr);
   1d496:	f7ec fa43 	bl	9920 <os_arch_save_sr>
   1d49a:	4607      	mov	r7, r0
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
   1d49c:	f7ec fa49 	bl	9932 <os_arch_in_critical>
   1d4a0:	b908      	cbnz	r0, 1d4a6 <nrf52_timer_handler+0x12>
   1d4a2:	f7ff ffa9 	bl	1d3f8 <nrf52_os_tick_counter.part.0>
    /* Calculate elapsed ticks and advance OS time. */
#if defined(BSP_HAS_32768_XTAL)
    int delta;

    counter = nrf52_os_tick_counter();
    delta = sub24(counter, g_hal_os_tick.lastocmp);
   1d4a6:	4d0f      	ldr	r5, [pc, #60]	; (1d4e4 <nrf52_timer_handler+0x50>)
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();

#if defined(BSP_HAS_32768_XTAL)
    return OS_TICK_TIMER->COUNTER;
   1d4a8:	4e0f      	ldr	r6, [pc, #60]	; (1d4e8 <nrf52_timer_handler+0x54>)
    /* Calculate elapsed ticks and advance OS time. */
#if defined(BSP_HAS_32768_XTAL)
    int delta;

    counter = nrf52_os_tick_counter();
    delta = sub24(counter, g_hal_os_tick.lastocmp);
   1d4aa:	68a9      	ldr	r1, [r5, #8]
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();

#if defined(BSP_HAS_32768_XTAL)
    return OS_TICK_TIMER->COUNTER;
   1d4ac:	f8d6 0504 	ldr.w	r0, [r6, #1284]	; 0x504
    /* Calculate elapsed ticks and advance OS time. */
#if defined(BSP_HAS_32768_XTAL)
    int delta;

    counter = nrf52_os_tick_counter();
    delta = sub24(counter, g_hal_os_tick.lastocmp);
   1d4b0:	f7ff ffac 	bl	1d40c <sub24>
    ticks = delta / g_hal_os_tick.ticks_per_ostick;
   1d4b4:	682c      	ldr	r4, [r5, #0]
   1d4b6:	fb90 f4f4 	sdiv	r4, r0, r4
    os_time_advance(ticks);
   1d4ba:	4620      	mov	r0, r4
   1d4bc:	f7ed f986 	bl	a7cc <os_time_advance>

    /* Clear timer interrupt */
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;
   1d4c0:	2300      	movs	r3, #0
   1d4c2:	f8c6 314c 	str.w	r3, [r6, #332]	; 0x14c

    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
        (ticks * g_hal_os_tick.ticks_per_ostick)) & 0xffffff;
   1d4c6:	6828      	ldr	r0, [r5, #0]

    /* Clear timer interrupt */
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;

    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
   1d4c8:	68ab      	ldr	r3, [r5, #8]
   1d4ca:	fb00 3404 	mla	r4, r0, r4, r3
        (ticks * g_hal_os_tick.ticks_per_ostick)) & 0xffffff;
   1d4ce:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp += ticks * g_hal_os_tick.ticks_per_ostick;
#endif

    /* Update the output compare to interrupt at the next tick */
    nrf52_os_tick_set_ocmp(g_hal_os_tick.lastocmp + g_hal_os_tick.ticks_per_ostick);
   1d4d2:	4420      	add	r0, r4

    /* Clear timer interrupt */
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;

    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
   1d4d4:	60ac      	str	r4, [r5, #8]
    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp += ticks * g_hal_os_tick.ticks_per_ostick;
#endif

    /* Update the output compare to interrupt at the next tick */
    nrf52_os_tick_set_ocmp(g_hal_os_tick.lastocmp + g_hal_os_tick.ticks_per_ostick);
   1d4d6:	f7ff ffb5 	bl	1d444 <nrf52_os_tick_set_ocmp>

    OS_EXIT_CRITICAL(sr);
   1d4da:	4638      	mov	r0, r7
}
   1d4dc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#endif

    /* Update the output compare to interrupt at the next tick */
    nrf52_os_tick_set_ocmp(g_hal_os_tick.lastocmp + g_hal_os_tick.ticks_per_ostick);

    OS_EXIT_CRITICAL(sr);
   1d4e0:	f7ec ba24 	b.w	992c <os_arch_restore_sr>
   1d4e4:	20003e08 	.word	0x20003e08
   1d4e8:	40011000 	.word	0x40011000

0001d4ec <os_tick_idle>:
}

void
os_tick_idle(os_time_t ticks)
{
   1d4ec:	b510      	push	{r4, lr}
   1d4ee:	4604      	mov	r4, r0
    uint32_t ocmp;

    OS_ASSERT_CRITICAL();
   1d4f0:	f7ec fa1f 	bl	9932 <os_arch_in_critical>
   1d4f4:	4602      	mov	r2, r0
   1d4f6:	b920      	cbnz	r0, 1d502 <os_tick_idle+0x16>
   1d4f8:	480c      	ldr	r0, [pc, #48]	; (1d52c <os_tick_idle+0x40>)
   1d4fa:	21b6      	movs	r1, #182	; 0xb6
   1d4fc:	4613      	mov	r3, r2
   1d4fe:	f7ec fbe7 	bl	9cd0 <__assert_func>

    if (ticks > 0) {
   1d502:	b154      	cbz	r4, 1d51a <os_tick_idle+0x2e>
        /*
         * Enter tickless regime during long idle durations.
         */
        if (ticks > g_hal_os_tick.max_idle_ticks) {
   1d504:	4b0a      	ldr	r3, [pc, #40]	; (1d530 <os_tick_idle+0x44>)
   1d506:	685a      	ldr	r2, [r3, #4]
            ticks = g_hal_os_tick.max_idle_ticks;
        }
        ocmp = g_hal_os_tick.lastocmp + (ticks*g_hal_os_tick.ticks_per_ostick);
   1d508:	6818      	ldr	r0, [r3, #0]
   1d50a:	689b      	ldr	r3, [r3, #8]
   1d50c:	4294      	cmp	r4, r2
   1d50e:	bf28      	it	cs
   1d510:	4614      	movcs	r4, r2
        nrf52_os_tick_set_ocmp(ocmp);
   1d512:	fb00 3004 	mla	r0, r0, r4, r3
   1d516:	f7ff ff95 	bl	1d444 <nrf52_os_tick_set_ocmp>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
   1d51a:	f3bf 8f4f 	dsb	sy
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
   1d51e:	bf30      	wfi
    }

    __DSB();
    __WFI();

    if (ticks > 0) {
   1d520:	b11c      	cbz	r4, 1d52a <os_tick_idle+0x3e>
         * Update OS time before anything else when coming out of
         * the tickless regime.
         */
        nrf52_timer_handler();
    }
}
   1d522:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (ticks > 0) {
        /*
         * Update OS time before anything else when coming out of
         * the tickless regime.
         */
        nrf52_timer_handler();
   1d526:	f7ff bfb5 	b.w	1d494 <nrf52_timer_handler>
   1d52a:	bd10      	pop	{r4, pc}
   1d52c:	00020c1d 	.word	0x00020c1d
   1d530:	20003e08 	.word	0x20003e08

0001d534 <os_tick_init>:
os_tick_init(uint32_t os_ticks_per_sec, int prio)
{
    uint32_t sr;
    uint32_t mask;

    assert(RTC_FREQ % os_ticks_per_sec == 0);
   1d534:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   1d538:	fbb3 f3f0 	udiv	r3, r3, r0
   1d53c:	4358      	muls	r0, r3
   1d53e:	f5d0 4000 	rsbs	r0, r0, #32768	; 0x8000
}

#if defined(BSP_HAS_32768_XTAL)
void
os_tick_init(uint32_t os_ticks_per_sec, int prio)
{
   1d542:	b570      	push	{r4, r5, r6, lr}
   1d544:	460d      	mov	r5, r1
    uint32_t sr;
    uint32_t mask;

    assert(RTC_FREQ % os_ticks_per_sec == 0);
   1d546:	d005      	beq.n	1d554 <os_tick_init+0x20>
   1d548:	2200      	movs	r2, #0
   1d54a:	4828      	ldr	r0, [pc, #160]	; (1d5ec <os_tick_init+0xb8>)
   1d54c:	21d6      	movs	r1, #214	; 0xd6
   1d54e:	4613      	mov	r3, r2
   1d550:	f7ec fbbe 	bl	9cd0 <__assert_func>

    g_hal_os_tick.lastocmp = 0;
   1d554:	4a26      	ldr	r2, [pc, #152]	; (1d5f0 <os_tick_init+0xbc>)
    /*
     * The maximum number of OS ticks allowed to elapse during idle is
     * limited to 1/4th the number of timer ticks before the 24-bit counter
     * rolls over.
     */
    g_hal_os_tick.max_idle_ticks = (1UL << 22) / g_hal_os_tick.ticks_per_ostick;
   1d556:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    uint32_t mask;

    assert(RTC_FREQ % os_ticks_per_sec == 0);

    g_hal_os_tick.lastocmp = 0;
    g_hal_os_tick.ticks_per_ostick = RTC_FREQ / os_ticks_per_sec;
   1d55a:	6013      	str	r3, [r2, #0]
    /*
     * The maximum number of OS ticks allowed to elapse during idle is
     * limited to 1/4th the number of timer ticks before the 24-bit counter
     * rolls over.
     */
    g_hal_os_tick.max_idle_ticks = (1UL << 22) / g_hal_os_tick.ticks_per_ostick;
   1d55c:	fbb1 f3f3 	udiv	r3, r1, r3
   1d560:	6053      	str	r3, [r2, #4]

    /* Turn on the LFCLK */
    NRF_CLOCK->TASKS_LFCLKSTOP = 1;
   1d562:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1d566:	2101      	movs	r1, #1
    uint32_t sr;
    uint32_t mask;

    assert(RTC_FREQ % os_ticks_per_sec == 0);

    g_hal_os_tick.lastocmp = 0;
   1d568:	6090      	str	r0, [r2, #8]
   1d56a:	4614      	mov	r4, r2
     * rolls over.
     */
    g_hal_os_tick.max_idle_ticks = (1UL << 22) / g_hal_os_tick.ticks_per_ostick;

    /* Turn on the LFCLK */
    NRF_CLOCK->TASKS_LFCLKSTOP = 1;
   1d56c:	60d9      	str	r1, [r3, #12]
    NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;
   1d56e:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
    NRF_CLOCK->LFCLKSRC = CLOCK_LFCLKSRC_SRC_Xtal;
   1d572:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    NRF_CLOCK->TASKS_LFCLKSTART = 1;
   1d576:	6099      	str	r1, [r3, #8]

    /* Wait here till started! */
    mask = CLOCK_LFCLKSTAT_STATE_Msk | CLOCK_LFCLKSTAT_SRC_Xtal;
    while (1) {
        if (NRF_CLOCK->EVENTS_LFCLKSTARTED) {
   1d578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1d57c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   1d580:	2a00      	cmp	r2, #0
   1d582:	d0f9      	beq.n	1d578 <os_tick_init+0x44>
            if ((NRF_CLOCK->LFCLKSTAT & mask) == mask) {
   1d584:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
   1d588:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
   1d58c:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
   1d590:	d1f2      	bne.n	1d578 <os_tick_init+0x44>
            }
        }
    }

    /* disable interrupts */
    OS_ENTER_CRITICAL(sr);
   1d592:	f7ec f9c5 	bl	9920 <os_arch_save_sr>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   1d596:	0169      	lsls	r1, r5, #5
   1d598:	4d16      	ldr	r5, [pc, #88]	; (1d5f4 <os_tick_init+0xc0>)
   1d59a:	b2c9      	uxtb	r1, r1
   1d59c:	4606      	mov	r6, r0
   1d59e:	f885 1311 	strb.w	r1, [r5, #785]	; 0x311

    /* Set isr in vector table and enable interrupt */
    NVIC_SetPriority(OS_TICK_IRQ, prio);
    NVIC_SetVector(OS_TICK_IRQ, (uint32_t)nrf52_timer_handler);
   1d5a2:	2011      	movs	r0, #17
   1d5a4:	4914      	ldr	r1, [pc, #80]	; (1d5f8 <os_tick_init+0xc4>)
   1d5a6:	f7eb ffbb 	bl	9520 <NVIC_SetVector>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
   1d5aa:	f44f 3300 	mov.w	r3, #131072	; 0x20000
   1d5ae:	602b      	str	r3, [r5, #0]

    /*
     * Program the OS_TICK_TIMER to operate at 32KHz and trigger an output
     * compare interrupt at a rate of 'os_ticks_per_sec'.
     */
    OS_TICK_TIMER->TASKS_STOP = 1;
   1d5b0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1d5b4:	f5a3 4370 	sub.w	r3, r3, #61440	; 0xf000
   1d5b8:	2201      	movs	r2, #1
    OS_TICK_TIMER->TASKS_CLEAR = 1;

    OS_TICK_TIMER->EVTENCLR = 0xffffffff;
   1d5ba:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff

    /*
     * Program the OS_TICK_TIMER to operate at 32KHz and trigger an output
     * compare interrupt at a rate of 'os_ticks_per_sec'.
     */
    OS_TICK_TIMER->TASKS_STOP = 1;
   1d5be:	605a      	str	r2, [r3, #4]
    OS_TICK_TIMER->TASKS_CLEAR = 1;
   1d5c0:	609a      	str	r2, [r3, #8]

    OS_TICK_TIMER->EVTENCLR = 0xffffffff;
   1d5c2:	f8c3 1348 	str.w	r1, [r3, #840]	; 0x348
    OS_TICK_TIMER->INTENCLR = 0xffffffff;
   1d5c6:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    OS_TICK_TIMER->INTENSET = RTC_COMPARE_INT_MASK(OS_TICK_CMPREG);
   1d5ca:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   1d5ce:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304

    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;
   1d5d2:	2100      	movs	r1, #0
   1d5d4:	f8c3 114c 	str.w	r1, [r3, #332]	; 0x14c
    OS_TICK_TIMER->CC[OS_TICK_CMPREG] = g_hal_os_tick.ticks_per_ostick;
   1d5d8:	6821      	ldr	r1, [r4, #0]
   1d5da:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c

    OS_TICK_TIMER->TASKS_START = 1;

    OS_EXIT_CRITICAL(sr);
   1d5de:	4630      	mov	r0, r6
    OS_TICK_TIMER->INTENSET = RTC_COMPARE_INT_MASK(OS_TICK_CMPREG);

    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;
    OS_TICK_TIMER->CC[OS_TICK_CMPREG] = g_hal_os_tick.ticks_per_ostick;

    OS_TICK_TIMER->TASKS_START = 1;
   1d5e0:	601a      	str	r2, [r3, #0]

    OS_EXIT_CRITICAL(sr);
}
   1d5e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;
    OS_TICK_TIMER->CC[OS_TICK_CMPREG] = g_hal_os_tick.ticks_per_ostick;

    OS_TICK_TIMER->TASKS_START = 1;

    OS_EXIT_CRITICAL(sr);
   1d5e6:	f7ec b9a1 	b.w	992c <os_arch_restore_sr>
   1d5ea:	bf00      	nop
   1d5ec:	00020c1d 	.word	0x00020c1d
   1d5f0:	20003e08 	.word	0x20003e08
   1d5f4:	e000e100 	.word	0xe000e100
   1d5f8:	0001d495 	.word	0x0001d495

0001d5fc <system_reset>:
}

int
system_debugger_connected(void)
{
    return CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk;
   1d5fc:	4b08      	ldr	r3, [pc, #32]	; (1d620 <system_reset+0x24>)
   1d5fe:	681b      	ldr	r3, [r3, #0]

void
system_reset(void)
{
    while (1) {
        if (system_debugger_connected()) {
   1d600:	07db      	lsls	r3, r3, #31
   1d602:	d500      	bpl.n	1d606 <system_reset+0xa>
            /*
             * If debugger is attached, breakpoint here.
             */
            asm("bkpt");
   1d604:	be00      	bkpt	0x0000
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
   1d606:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1d60a:	4906      	ldr	r1, [pc, #24]	; (1d624 <system_reset+0x28>)
   1d60c:	4b06      	ldr	r3, [pc, #24]	; (1d628 <system_reset+0x2c>)
   1d60e:	68ca      	ldr	r2, [r1, #12]
   1d610:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1d614:	4313      	orrs	r3, r2
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
   1d616:	60cb      	str	r3, [r1, #12]
   1d618:	f3bf 8f4f 	dsb	sy
   1d61c:	e7fe      	b.n	1d61c <system_reset+0x20>
   1d61e:	bf00      	nop
   1d620:	e000edf0 	.word	0xe000edf0
   1d624:	e000ed00 	.word	0xe000ed00
   1d628:	05fa0004 	.word	0x05fa0004

0001d62c <system_debugger_connected>:
}

int
system_debugger_connected(void)
{
    return CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk;
   1d62c:	4b02      	ldr	r3, [pc, #8]	; (1d638 <system_debugger_connected+0xc>)
   1d62e:	6818      	ldr	r0, [r3, #0]
}
   1d630:	f000 0001 	and.w	r0, r0, #1
   1d634:	4770      	bx	lr
   1d636:	bf00      	nop
   1d638:	e000edf0 	.word	0xe000edf0

0001d63c <hal_uart_tx_fill_buf.constprop.1>:
    u->u_func_arg = arg;
    return 0;
}

static int
hal_uart_tx_fill_buf(struct hal_uart *u)
   1d63c:	b538      	push	{r3, r4, r5, lr}
{
    int data;
    int i;

    for (i = 0; i < sizeof(u->u_tx_buf); i++) {
   1d63e:	2400      	movs	r4, #0
        data = u->u_tx_func(u->u_func_arg);
   1d640:	4d06      	ldr	r5, [pc, #24]	; (1d65c <hal_uart_tx_fill_buf.constprop.1+0x20>)
   1d642:	692b      	ldr	r3, [r5, #16]
   1d644:	69a8      	ldr	r0, [r5, #24]
   1d646:	4798      	blx	r3
        if (data < 0) {
   1d648:	2800      	cmp	r0, #0
   1d64a:	db04      	blt.n	1d656 <hal_uart_tx_fill_buf.constprop.1+0x1a>
   1d64c:	4425      	add	r5, r4
hal_uart_tx_fill_buf(struct hal_uart *u)
{
    int data;
    int i;

    for (i = 0; i < sizeof(u->u_tx_buf); i++) {
   1d64e:	3401      	adds	r4, #1
   1d650:	2c08      	cmp	r4, #8
        data = u->u_tx_func(u->u_func_arg);
        if (data < 0) {
            break;
        }
        u->u_tx_buf[i] = data;
   1d652:	70a8      	strb	r0, [r5, #2]
hal_uart_tx_fill_buf(struct hal_uart *u)
{
    int data;
    int i;

    for (i = 0; i < sizeof(u->u_tx_buf); i++) {
   1d654:	d1f4      	bne.n	1d640 <hal_uart_tx_fill_buf.constprop.1+0x4>
            break;
        }
        u->u_tx_buf[i] = data;
    }
    return i;
}
   1d656:	4620      	mov	r0, r4
   1d658:	bd38      	pop	{r3, r4, r5, pc}
   1d65a:	bf00      	nop
   1d65c:	200027b8 	.word	0x200027b8

0001d660 <uart_irq_handler>:
    NRF_UARTE0->TASKS_STOPTX = 1;
}

static void
uart_irq_handler(void)
{
   1d660:	b538      	push	{r3, r4, r5, lr}
    struct hal_uart *u;
    int rc;

    u = &uart;
    if (NRF_UARTE0->EVENTS_ENDTX) {
   1d662:	4c1c      	ldr	r4, [pc, #112]	; (1d6d4 <uart_irq_handler+0x74>)
   1d664:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
   1d668:	b1f3      	cbz	r3, 1d6a8 <uart_irq_handler+0x48>
        NRF_UARTE0->EVENTS_ENDTX = 0;
   1d66a:	2300      	movs	r3, #0
   1d66c:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
        rc = hal_uart_tx_fill_buf(u);
   1d670:	f7ff ffe4 	bl	1d63c <hal_uart_tx_fill_buf.constprop.1>
        if (rc > 0) {
   1d674:	2800      	cmp	r0, #0
   1d676:	dd07      	ble.n	1d688 <uart_irq_handler+0x28>
            NRF_UARTE0->TXD.PTR = (uint32_t)&u->u_tx_buf;
   1d678:	4b17      	ldr	r3, [pc, #92]	; (1d6d8 <uart_irq_handler+0x78>)
   1d67a:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
            NRF_UARTE0->TXD.MAXCNT = rc;
            NRF_UARTE0->TASKS_STARTTX = 1;
   1d67e:	2301      	movs	r3, #1
    if (NRF_UARTE0->EVENTS_ENDTX) {
        NRF_UARTE0->EVENTS_ENDTX = 0;
        rc = hal_uart_tx_fill_buf(u);
        if (rc > 0) {
            NRF_UARTE0->TXD.PTR = (uint32_t)&u->u_tx_buf;
            NRF_UARTE0->TXD.MAXCNT = rc;
   1d680:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
            NRF_UARTE0->TASKS_STARTTX = 1;
   1d684:	60a3      	str	r3, [r4, #8]
   1d686:	e00f      	b.n	1d6a8 <uart_irq_handler+0x48>
        } else {
            if (u->u_tx_done) {
   1d688:	4c14      	ldr	r4, [pc, #80]	; (1d6dc <uart_irq_handler+0x7c>)
   1d68a:	6963      	ldr	r3, [r4, #20]
   1d68c:	b10b      	cbz	r3, 1d692 <uart_irq_handler+0x32>
                u->u_tx_done(u->u_func_arg);
   1d68e:	69a0      	ldr	r0, [r4, #24]
   1d690:	4798      	blx	r3
            }
            NRF_UARTE0->INTENCLR = UARTE_INT_ENDTX;
   1d692:	4b10      	ldr	r3, [pc, #64]	; (1d6d4 <uart_irq_handler+0x74>)
   1d694:	f44f 7280 	mov.w	r2, #256	; 0x100
   1d698:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            NRF_UARTE0->TASKS_STOPTX = 1;
   1d69c:	2201      	movs	r2, #1
   1d69e:	60da      	str	r2, [r3, #12]
            u->u_tx_started = 0;
   1d6a0:	7823      	ldrb	r3, [r4, #0]
   1d6a2:	f36f 0382 	bfc	r3, #2, #1
   1d6a6:	7023      	strb	r3, [r4, #0]
        }
    }
    if (NRF_UARTE0->EVENTS_ENDRX) {
   1d6a8:	4d0a      	ldr	r5, [pc, #40]	; (1d6d4 <uart_irq_handler+0x74>)
   1d6aa:	f8d5 3110 	ldr.w	r3, [r5, #272]	; 0x110
   1d6ae:	b183      	cbz	r3, 1d6d2 <uart_irq_handler+0x72>
        NRF_UARTE0->EVENTS_ENDRX = 0;
        rc = u->u_rx_func(u->u_func_arg, u->u_rx_buf);
   1d6b0:	4c0a      	ldr	r4, [pc, #40]	; (1d6dc <uart_irq_handler+0x7c>)
            NRF_UARTE0->TASKS_STOPTX = 1;
            u->u_tx_started = 0;
        }
    }
    if (NRF_UARTE0->EVENTS_ENDRX) {
        NRF_UARTE0->EVENTS_ENDRX = 0;
   1d6b2:	2300      	movs	r3, #0
   1d6b4:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
        rc = u->u_rx_func(u->u_func_arg, u->u_rx_buf);
   1d6b8:	69a0      	ldr	r0, [r4, #24]
   1d6ba:	68e3      	ldr	r3, [r4, #12]
   1d6bc:	7861      	ldrb	r1, [r4, #1]
   1d6be:	4798      	blx	r3
        if (rc < 0) {
   1d6c0:	2800      	cmp	r0, #0
   1d6c2:	da04      	bge.n	1d6ce <uart_irq_handler+0x6e>
            u->u_rx_stall = 1;
   1d6c4:	7823      	ldrb	r3, [r4, #0]
   1d6c6:	f043 0302 	orr.w	r3, r3, #2
   1d6ca:	7023      	strb	r3, [r4, #0]
   1d6cc:	bd38      	pop	{r3, r4, r5, pc}
        } else {
            NRF_UARTE0->TASKS_STARTRX = 1;
   1d6ce:	2301      	movs	r3, #1
   1d6d0:	602b      	str	r3, [r5, #0]
   1d6d2:	bd38      	pop	{r3, r4, r5, pc}
   1d6d4:	40002000 	.word	0x40002000
   1d6d8:	200027ba 	.word	0x200027ba
   1d6dc:	200027b8 	.word	0x200027b8

0001d6e0 <hal_uart_init_cbs>:
static struct hal_uart uart;

int
hal_uart_init_cbs(int port, hal_uart_tx_char tx_func, hal_uart_tx_done tx_done,
  hal_uart_rx_char rx_func, void *arg)
{
   1d6e0:	b510      	push	{r4, lr}
    struct hal_uart *u;

    if (port != 0) {
   1d6e2:	b950      	cbnz	r0, 1d6fa <hal_uart_init_cbs+0x1a>
        return -1;
    }
    u = &uart;
    if (u->u_open) {
   1d6e4:	4c06      	ldr	r4, [pc, #24]	; (1d700 <hal_uart_init_cbs+0x20>)
   1d6e6:	7820      	ldrb	r0, [r4, #0]
   1d6e8:	f010 0001 	ands.w	r0, r0, #1
   1d6ec:	d105      	bne.n	1d6fa <hal_uart_init_cbs+0x1a>
        return -1;
    }
    u->u_rx_func = rx_func;
   1d6ee:	60e3      	str	r3, [r4, #12]
    u->u_tx_func = tx_func;
    u->u_tx_done = tx_done;
    u->u_func_arg = arg;
   1d6f0:	9b02      	ldr	r3, [sp, #8]
    u = &uart;
    if (u->u_open) {
        return -1;
    }
    u->u_rx_func = rx_func;
    u->u_tx_func = tx_func;
   1d6f2:	6121      	str	r1, [r4, #16]
    u->u_tx_done = tx_done;
   1d6f4:	6162      	str	r2, [r4, #20]
    u->u_func_arg = arg;
   1d6f6:	61a3      	str	r3, [r4, #24]
    return 0;
   1d6f8:	bd10      	pop	{r4, pc}
  hal_uart_rx_char rx_func, void *arg)
{
    struct hal_uart *u;

    if (port != 0) {
        return -1;
   1d6fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    u->u_rx_func = rx_func;
    u->u_tx_func = tx_func;
    u->u_tx_done = tx_done;
    u->u_func_arg = arg;
    return 0;
}
   1d6fe:	bd10      	pop	{r4, pc}
   1d700:	200027b8 	.word	0x200027b8

0001d704 <hal_uart_start_tx>:
    return i;
}

void
hal_uart_start_tx(int port)
{
   1d704:	b538      	push	{r3, r4, r5, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   1d706:	f3ef 8510 	mrs	r5, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   1d70a:	b672      	cpsid	i
    int sr;
    int rc;

    u = &uart;
    __HAL_DISABLE_INTERRUPTS(sr);
    if (u->u_tx_started == 0) {
   1d70c:	4c0d      	ldr	r4, [pc, #52]	; (1d744 <hal_uart_start_tx+0x40>)
   1d70e:	7823      	ldrb	r3, [r4, #0]
   1d710:	075b      	lsls	r3, r3, #29
   1d712:	d413      	bmi.n	1d73c <hal_uart_start_tx+0x38>
        rc = hal_uart_tx_fill_buf(u);
   1d714:	f7ff ff92 	bl	1d63c <hal_uart_tx_fill_buf.constprop.1>
        if (rc > 0) {
   1d718:	2800      	cmp	r0, #0
   1d71a:	dd0f      	ble.n	1d73c <hal_uart_start_tx+0x38>
            NRF_UARTE0->INTENSET = UARTE_INT_ENDTX;
   1d71c:	4b0a      	ldr	r3, [pc, #40]	; (1d748 <hal_uart_start_tx+0x44>)
   1d71e:	f44f 7280 	mov.w	r2, #256	; 0x100
   1d722:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
            NRF_UARTE0->TXD.PTR = (uint32_t)&u->u_tx_buf;
   1d726:	1ca2      	adds	r2, r4, #2
   1d728:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
            NRF_UARTE0->TXD.MAXCNT = rc;
            NRF_UARTE0->TASKS_STARTTX = 1;
   1d72c:	2201      	movs	r2, #1
    if (u->u_tx_started == 0) {
        rc = hal_uart_tx_fill_buf(u);
        if (rc > 0) {
            NRF_UARTE0->INTENSET = UARTE_INT_ENDTX;
            NRF_UARTE0->TXD.PTR = (uint32_t)&u->u_tx_buf;
            NRF_UARTE0->TXD.MAXCNT = rc;
   1d72e:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
            NRF_UARTE0->TASKS_STARTTX = 1;
   1d732:	609a      	str	r2, [r3, #8]
            u->u_tx_started = 1;
   1d734:	7823      	ldrb	r3, [r4, #0]
   1d736:	f043 0304 	orr.w	r3, r3, #4
   1d73a:	7023      	strb	r3, [r4, #0]
        }
    }
    __HAL_ENABLE_INTERRUPTS(sr);
   1d73c:	b905      	cbnz	r5, 1d740 <hal_uart_start_tx+0x3c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   1d73e:	b662      	cpsie	i
   1d740:	bd38      	pop	{r3, r4, r5, pc}
   1d742:	bf00      	nop
   1d744:	200027b8 	.word	0x200027b8
   1d748:	40002000 	.word	0x40002000

0001d74c <hal_uart_blocking_tx>:
hal_uart_blocking_tx(int port, uint8_t data)
{
    struct hal_uart *u;

    u = &uart;
    if (!u->u_open) {
   1d74c:	4b11      	ldr	r3, [pc, #68]	; (1d794 <hal_uart_blocking_tx+0x48>)
   1d74e:	781b      	ldrb	r3, [r3, #0]
    }
}

void
hal_uart_blocking_tx(int port, uint8_t data)
{
   1d750:	b082      	sub	sp, #8
    struct hal_uart *u;

    u = &uart;
    if (!u->u_open) {
   1d752:	07da      	lsls	r2, r3, #31
    }
}

void
hal_uart_blocking_tx(int port, uint8_t data)
{
   1d754:	f88d 1007 	strb.w	r1, [sp, #7]
    struct hal_uart *u;

    u = &uart;
    if (!u->u_open) {
   1d758:	d519      	bpl.n	1d78e <hal_uart_blocking_tx+0x42>
        return;
    }

    /* If we have started, wait until the current uart dma buffer is done */
    if (u->u_tx_started) {
   1d75a:	f013 0f04 	tst.w	r3, #4
   1d75e:	4b0e      	ldr	r3, [pc, #56]	; (1d798 <hal_uart_blocking_tx+0x4c>)
   1d760:	d003      	beq.n	1d76a <hal_uart_blocking_tx+0x1e>
        while (NRF_UARTE0->EVENTS_ENDTX == 0) {
   1d762:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   1d766:	2a00      	cmp	r2, #0
   1d768:	d0fb      	beq.n	1d762 <hal_uart_blocking_tx+0x16>
            /* Wait here until the dma is finished */
        }
    }

    NRF_UARTE0->EVENTS_ENDTX = 0;
   1d76a:	2200      	movs	r2, #0
   1d76c:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    NRF_UARTE0->TXD.PTR = (uint32_t)&data;
   1d770:	f10d 0207 	add.w	r2, sp, #7
   1d774:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    NRF_UARTE0->TXD.MAXCNT = 1;
   1d778:	2201      	movs	r2, #1
   1d77a:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    NRF_UARTE0->TASKS_STARTTX = 1;
   1d77e:	609a      	str	r2, [r3, #8]

    while (NRF_UARTE0->EVENTS_ENDTX == 0) {
   1d780:	4b05      	ldr	r3, [pc, #20]	; (1d798 <hal_uart_blocking_tx+0x4c>)
   1d782:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   1d786:	2a00      	cmp	r2, #0
   1d788:	d0fa      	beq.n	1d780 <hal_uart_blocking_tx+0x34>
        /* Wait till done */
    }

    /* Stop the uart */
    NRF_UARTE0->TASKS_STOPTX = 1;
   1d78a:	2201      	movs	r2, #1
   1d78c:	60da      	str	r2, [r3, #12]
}
   1d78e:	b002      	add	sp, #8
   1d790:	4770      	bx	lr
   1d792:	bf00      	nop
   1d794:	200027b8 	.word	0x200027b8
   1d798:	40002000 	.word	0x40002000

0001d79c <hal_uart_config>:
}

int
hal_uart_config(int port, int32_t baudrate, uint8_t databits, uint8_t stopbits,
  enum hal_uart_parity parity, enum hal_uart_flow_ctl flow_ctl)
{
   1d79c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1d7a0:	460c      	mov	r4, r1
   1d7a2:	4691      	mov	r9, r2
   1d7a4:	4698      	mov	r8, r3
   1d7a6:	f89d 7020 	ldrb.w	r7, [sp, #32]
   1d7aa:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
    struct hal_uart *u;
    const struct nrf52_uart_cfg *cfg;
    uint32_t cfg_reg = 0;
    uint32_t baud_reg;

    if (port != 0) {
   1d7ae:	2800      	cmp	r0, #0
   1d7b0:	d141      	bne.n	1d836 <hal_uart_config+0x9a>
        return -1;
    }

    u = &uart;
    if (u->u_open) {
   1d7b2:	4d61      	ldr	r5, [pc, #388]	; (1d938 <hal_uart_config+0x19c>)
   1d7b4:	782b      	ldrb	r3, [r5, #0]
   1d7b6:	07db      	lsls	r3, r3, #31
   1d7b8:	d43d      	bmi.n	1d836 <hal_uart_config+0x9a>
        return -1;
    }
    cfg = bsp_uart_config();
   1d7ba:	f000 ff2f 	bl	1e61c <bsp_uart_config>
    assert(cfg);
   1d7be:	4602      	mov	r2, r0
   1d7c0:	b910      	cbnz	r0, 1d7c8 <hal_uart_config+0x2c>
   1d7c2:	485e      	ldr	r0, [pc, #376]	; (1d93c <hal_uart_config+0x1a0>)
   1d7c4:	21ee      	movs	r1, #238	; 0xee
   1d7c6:	e01b      	b.n	1d800 <hal_uart_config+0x64>
     * pin config
     * UART config
     * nvic config
     * enable uart
     */
    if (databits != 8) {
   1d7c8:	f1b9 0f08 	cmp.w	r9, #8
   1d7cc:	d133      	bne.n	1d836 <hal_uart_config+0x9a>
        return -1;
    }
    if (stopbits != 1) {
   1d7ce:	f1b8 0f01 	cmp.w	r8, #1
   1d7d2:	d130      	bne.n	1d836 <hal_uart_config+0x9a>
        return -1;
    }

    switch (parity) {
   1d7d4:	2f01      	cmp	r7, #1
   1d7d6:	d02e      	beq.n	1d836 <hal_uart_config+0x9a>
hal_uart_config(int port, int32_t baudrate, uint8_t databits, uint8_t stopbits,
  enum hal_uart_parity parity, enum hal_uart_flow_ctl flow_ctl)
{
    struct hal_uart *u;
    const struct nrf52_uart_cfg *cfg;
    uint32_t cfg_reg = 0;
   1d7d8:	2f02      	cmp	r7, #2
   1d7da:	bf0c      	ite	eq
   1d7dc:	200e      	moveq	r0, #14
   1d7de:	2000      	movne	r0, #0
    case HAL_UART_PARITY_EVEN:
        cfg_reg |= UARTE_CONFIG_PARITY;
        break;
    }

    switch (flow_ctl) {
   1d7e0:	2e01      	cmp	r6, #1
   1d7e2:	d110      	bne.n	1d806 <hal_uart_config+0x6a>
    case HAL_UART_FLOW_CTL_NONE:
        break;
    case HAL_UART_FLOW_CTL_RTS_CTS:
        cfg_reg |= UARTE_CONFIG_HWFC;
        if (cfg->suc_pin_rts < 0 || cfg->suc_pin_cts < 0) {
   1d7e4:	f992 3002 	ldrsb.w	r3, [r2, #2]
   1d7e8:	2b00      	cmp	r3, #0

    switch (flow_ctl) {
    case HAL_UART_FLOW_CTL_NONE:
        break;
    case HAL_UART_FLOW_CTL_RTS_CTS:
        cfg_reg |= UARTE_CONFIG_HWFC;
   1d7ea:	f040 0001 	orr.w	r0, r0, #1
        if (cfg->suc_pin_rts < 0 || cfg->suc_pin_cts < 0) {
   1d7ee:	db03      	blt.n	1d7f8 <hal_uart_config+0x5c>
   1d7f0:	f992 3003 	ldrsb.w	r3, [r2, #3]
   1d7f4:	2b00      	cmp	r3, #0
   1d7f6:	da12      	bge.n	1d81e <hal_uart_config+0x82>
            /*
             * Can't turn on HW flow control if pins to do that are not
             * defined.
             */
            assert(0);
   1d7f8:	4850      	ldr	r0, [pc, #320]	; (1d93c <hal_uart_config+0x1a0>)
   1d7fa:	f240 1111 	movw	r1, #273	; 0x111
   1d7fe:	2200      	movs	r2, #0
   1d800:	4613      	mov	r3, r2
   1d802:	f7ec fa65 	bl	9cd0 <__assert_func>
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d806:	f5b4 3fe1 	cmp.w	r4, #115200	; 0x1c200
   1d80a:	d011      	beq.n	1d830 <hal_uart_config+0x94>
   1d80c:	dc7a      	bgt.n	1d904 <hal_uart_config+0x168>
   1d80e:	f5b4 4f96 	cmp.w	r4, #19200	; 0x4b00
   1d812:	d00b      	beq.n	1d82c <hal_uart_config+0x90>
   1d814:	dc6a      	bgt.n	1d8ec <hal_uart_config+0x150>
   1d816:	f5b4 5f16 	cmp.w	r4, #9600	; 0x2580
   1d81a:	d010      	beq.n	1d83e <hal_uart_config+0xa2>
   1d81c:	e00b      	b.n	1d836 <hal_uart_config+0x9a>
   1d81e:	f5b4 3fe1 	cmp.w	r4, #115200	; 0x1c200
   1d822:	d005      	beq.n	1d830 <hal_uart_config+0x94>
   1d824:	dc6e      	bgt.n	1d904 <hal_uart_config+0x168>
   1d826:	f5b4 4f96 	cmp.w	r4, #19200	; 0x4b00
   1d82a:	d149      	bne.n	1d8c0 <hal_uart_config+0x124>
    case 9600:
        return UARTE_BAUDRATE_BAUDRATE_Baud9600;
    case 19200:
        return UARTE_BAUDRATE_BAUDRATE_Baud19200;
   1d82c:	4b44      	ldr	r3, [pc, #272]	; (1d940 <hal_uart_config+0x1a4>)
   1d82e:	e007      	b.n	1d840 <hal_uart_config+0xa4>
    case 38400:
        return UARTE_BAUDRATE_BAUDRATE_Baud38400;
    case 57600:
        return UARTE_BAUDRATE_BAUDRATE_Baud57600;
    case 115200:
        return UARTE_BAUDRATE_BAUDRATE_Baud115200;
   1d830:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   1d834:	e004      	b.n	1d840 <hal_uart_config+0xa4>
        }
        break;
    }
    baud_reg = hal_uart_baudrate(baudrate);
    if (baud_reg == 0) {
        return -1;
   1d836:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d83a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
    case 9600:
        return UARTE_BAUDRATE_BAUDRATE_Baud9600;
   1d83e:	4b41      	ldr	r3, [pc, #260]	; (1d944 <hal_uart_config+0x1a8>)
    }
    baud_reg = hal_uart_baudrate(baudrate);
    if (baud_reg == 0) {
        return -1;
    }
    NRF_UARTE0->ENABLE = 0;
   1d840:	4941      	ldr	r1, [pc, #260]	; (1d948 <hal_uart_config+0x1ac>)
   1d842:	2400      	movs	r4, #0
   1d844:	f8c1 4500 	str.w	r4, [r1, #1280]	; 0x500
    NRF_UARTE0->INTENCLR = 0xffffffff;
   1d848:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1d84c:	f8c1 4308 	str.w	r4, [r1, #776]	; 0x308
    NRF_UARTE0->PSEL.TXD = cfg->suc_pin_tx;
   1d850:	f992 7000 	ldrsb.w	r7, [r2]
   1d854:	f8c1 750c 	str.w	r7, [r1, #1292]	; 0x50c
    NRF_UARTE0->PSEL.RXD = cfg->suc_pin_rx;
   1d858:	f992 7001 	ldrsb.w	r7, [r2, #1]
   1d85c:	f8c1 7514 	str.w	r7, [r1, #1300]	; 0x514
    if (flow_ctl == HAL_UART_FLOW_CTL_RTS_CTS) {
   1d860:	2e01      	cmp	r6, #1
   1d862:	d109      	bne.n	1d878 <hal_uart_config+0xdc>
        NRF_UARTE0->PSEL.RTS = cfg->suc_pin_rts;
   1d864:	4938      	ldr	r1, [pc, #224]	; (1d948 <hal_uart_config+0x1ac>)
   1d866:	f992 4002 	ldrsb.w	r4, [r2, #2]
   1d86a:	f8c1 4508 	str.w	r4, [r1, #1288]	; 0x508
        NRF_UARTE0->PSEL.CTS = cfg->suc_pin_cts;
   1d86e:	f992 2003 	ldrsb.w	r2, [r2, #3]
   1d872:	f8c1 2510 	str.w	r2, [r1, #1296]	; 0x510
   1d876:	e003      	b.n	1d880 <hal_uart_config+0xe4>
    } else {
        NRF_UARTE0->PSEL.RTS = 0xffffffff;
   1d878:	f8c1 4508 	str.w	r4, [r1, #1288]	; 0x508
        NRF_UARTE0->PSEL.CTS = 0xffffffff;
   1d87c:	f8c1 4510 	str.w	r4, [r1, #1296]	; 0x510
    }
    NRF_UARTE0->BAUDRATE = baud_reg;
   1d880:	4c31      	ldr	r4, [pc, #196]	; (1d948 <hal_uart_config+0x1ac>)
    NRF_UARTE0->CONFIG = cfg_reg;

    NVIC_SetVector(UARTE0_UART0_IRQn, (uint32_t)uart_irq_handler);
   1d882:	4932      	ldr	r1, [pc, #200]	; (1d94c <hal_uart_config+0x1b0>)
        NRF_UARTE0->PSEL.CTS = cfg->suc_pin_cts;
    } else {
        NRF_UARTE0->PSEL.RTS = 0xffffffff;
        NRF_UARTE0->PSEL.CTS = 0xffffffff;
    }
    NRF_UARTE0->BAUDRATE = baud_reg;
   1d884:	f8c4 3524 	str.w	r3, [r4, #1316]	; 0x524
    NRF_UARTE0->CONFIG = cfg_reg;
   1d888:	f8c4 056c 	str.w	r0, [r4, #1388]	; 0x56c

    NVIC_SetVector(UARTE0_UART0_IRQn, (uint32_t)uart_irq_handler);
   1d88c:	2002      	movs	r0, #2
   1d88e:	f7eb fe47 	bl	9520 <NVIC_SetVector>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
   1d892:	4b2f      	ldr	r3, [pc, #188]	; (1d950 <hal_uart_config+0x1b4>)
   1d894:	2204      	movs	r2, #4
   1d896:	601a      	str	r2, [r3, #0]
    NVIC_EnableIRQ(UARTE0_UART0_IRQn);

    NRF_UARTE0->ENABLE = UARTE_ENABLE;
   1d898:	2308      	movs	r3, #8
   1d89a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500

    NRF_UARTE0->INTENSET = UARTE_INT_ENDRX;
   1d89e:	2310      	movs	r3, #16
   1d8a0:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    NRF_UARTE0->RXD.PTR = (uint32_t)&u->u_rx_buf;
   1d8a4:	4b2b      	ldr	r3, [pc, #172]	; (1d954 <hal_uart_config+0x1b8>)
   1d8a6:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    NRF_UARTE0->RXD.MAXCNT = sizeof(u->u_rx_buf);
   1d8aa:	2301      	movs	r3, #1
   1d8ac:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    NRF_UARTE0->TASKS_STARTRX = 1;
   1d8b0:	6023      	str	r3, [r4, #0]

    u->u_open = 1;
   1d8b2:	782b      	ldrb	r3, [r5, #0]
   1d8b4:	f043 0301 	orr.w	r3, r3, #1
   1d8b8:	702b      	strb	r3, [r5, #0]

    return 0;
   1d8ba:	2000      	movs	r0, #0
   1d8bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d8c0:	dc14      	bgt.n	1d8ec <hal_uart_config+0x150>
   1d8c2:	f5b4 5f16 	cmp.w	r4, #9600	; 0x2580
   1d8c6:	d1b6      	bne.n	1d836 <hal_uart_config+0x9a>
    }
    baud_reg = hal_uart_baudrate(baudrate);
    if (baud_reg == 0) {
        return -1;
    }
    NRF_UARTE0->ENABLE = 0;
   1d8c8:	4b1f      	ldr	r3, [pc, #124]	; (1d948 <hal_uart_config+0x1ac>)
   1d8ca:	2100      	movs	r1, #0
   1d8cc:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    NRF_UARTE0->INTENCLR = 0xffffffff;
   1d8d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1d8d4:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    NRF_UARTE0->PSEL.TXD = cfg->suc_pin_tx;
   1d8d8:	f992 1000 	ldrsb.w	r1, [r2]
   1d8dc:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
    NRF_UARTE0->PSEL.RXD = cfg->suc_pin_rx;
   1d8e0:	f992 1001 	ldrsb.w	r1, [r2, #1]
   1d8e4:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
    case 9600:
        return UARTE_BAUDRATE_BAUDRATE_Baud9600;
   1d8e8:	4b16      	ldr	r3, [pc, #88]	; (1d944 <hal_uart_config+0x1a8>)
   1d8ea:	e7bb      	b.n	1d864 <hal_uart_config+0xc8>
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d8ec:	f5b4 4f16 	cmp.w	r4, #38400	; 0x9600
   1d8f0:	d102      	bne.n	1d8f8 <hal_uart_config+0x15c>
    case 9600:
        return UARTE_BAUDRATE_BAUDRATE_Baud9600;
    case 19200:
        return UARTE_BAUDRATE_BAUDRATE_Baud19200;
    case 38400:
        return UARTE_BAUDRATE_BAUDRATE_Baud38400;
   1d8f2:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   1d8f6:	e7a3      	b.n	1d840 <hal_uart_config+0xa4>
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d8f8:	f5b4 4f61 	cmp.w	r4, #57600	; 0xe100
   1d8fc:	d19b      	bne.n	1d836 <hal_uart_config+0x9a>
    case 19200:
        return UARTE_BAUDRATE_BAUDRATE_Baud19200;
    case 38400:
        return UARTE_BAUDRATE_BAUDRATE_Baud38400;
    case 57600:
        return UARTE_BAUDRATE_BAUDRATE_Baud57600;
   1d8fe:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   1d902:	e79d      	b.n	1d840 <hal_uart_config+0xa4>
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d904:	f5b4 2fe1 	cmp.w	r4, #460800	; 0x70800
   1d908:	d102      	bne.n	1d910 <hal_uart_config+0x174>
    case 115200:
        return UARTE_BAUDRATE_BAUDRATE_Baud115200;
    case 230400:
        return UARTE_BAUDRATE_BAUDRATE_Baud230400;
    case 460800:
        return UARTE_BAUDRATE_BAUDRATE_Baud460800;
   1d90a:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   1d90e:	e797      	b.n	1d840 <hal_uart_config+0xa4>
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d910:	dc05      	bgt.n	1d91e <hal_uart_config+0x182>
   1d912:	f5b4 3f61 	cmp.w	r4, #230400	; 0x38400
   1d916:	d18e      	bne.n	1d836 <hal_uart_config+0x9a>
    case 57600:
        return UARTE_BAUDRATE_BAUDRATE_Baud57600;
    case 115200:
        return UARTE_BAUDRATE_BAUDRATE_Baud115200;
    case 230400:
        return UARTE_BAUDRATE_BAUDRATE_Baud230400;
   1d918:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   1d91c:	e790      	b.n	1d840 <hal_uart_config+0xa4>
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d91e:	f5b4 2f61 	cmp.w	r4, #921600	; 0xe1000
   1d922:	d102      	bne.n	1d92a <hal_uart_config+0x18e>
    case 230400:
        return UARTE_BAUDRATE_BAUDRATE_Baud230400;
    case 460800:
        return UARTE_BAUDRATE_BAUDRATE_Baud460800;
    case 921600:
        return UARTE_BAUDRATE_BAUDRATE_Baud921600;
   1d924:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   1d928:	e78a      	b.n	1d840 <hal_uart_config+0xa4>
}

static uint32_t
hal_uart_baudrate(int baudrate)
{
    switch (baudrate) {
   1d92a:	4b0b      	ldr	r3, [pc, #44]	; (1d958 <hal_uart_config+0x1bc>)
   1d92c:	429c      	cmp	r4, r3
   1d92e:	d182      	bne.n	1d836 <hal_uart_config+0x9a>
    case 460800:
        return UARTE_BAUDRATE_BAUDRATE_Baud460800;
    case 921600:
        return UARTE_BAUDRATE_BAUDRATE_Baud921600;
    case 1000000:
        return UARTE_BAUDRATE_BAUDRATE_Baud1M;
   1d930:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1d934:	e784      	b.n	1d840 <hal_uart_config+0xa4>
   1d936:	bf00      	nop
   1d938:	200027b8 	.word	0x200027b8
   1d93c:	00020c2b 	.word	0x00020c2b
   1d940:	004ea000 	.word	0x004ea000
   1d944:	00275000 	.word	0x00275000
   1d948:	40002000 	.word	0x40002000
   1d94c:	0001d661 	.word	0x0001d661
   1d950:	e000e100 	.word	0xe000e100
   1d954:	200027b9 	.word	0x200027b9
   1d958:	000f4240 	.word	0x000f4240

0001d95c <malloc_lock_nop>:
	},
	&__malloc_head,
	&__malloc_head
};

static bool malloc_lock_nop() {return true;}
   1d95c:	2001      	movs	r0, #1
   1d95e:	4770      	bx	lr

0001d960 <malloc_unlock_nop>:
static void malloc_unlock_nop() {}
   1d960:	4770      	bx	lr
	...

0001d964 <__free_block>:

static struct free_arena_header *__free_block(struct free_arena_header *ah)
{
	struct free_arena_header *pah, *nah;

	pah = ah->a.prev;
   1d964:	68c3      	ldr	r3, [r0, #12]
	nah = ah->a.next;
   1d966:	6882      	ldr	r2, [r0, #8]
	if (pah->a.type == ARENA_TYPE_FREE &&
   1d968:	6819      	ldr	r1, [r3, #0]
   1d96a:	2901      	cmp	r1, #1

	return (void *)(&fp->a + 1);
}

static struct free_arena_header *__free_block(struct free_arena_header *ah)
{
   1d96c:	b510      	push	{r4, lr}
	struct free_arena_header *pah, *nah;

	pah = ah->a.prev;
	nah = ah->a.next;
	if (pah->a.type == ARENA_TYPE_FREE &&
   1d96e:	d109      	bne.n	1d984 <__free_block+0x20>
	    (char *)pah + pah->a.size == (char *)ah) {
   1d970:	6859      	ldr	r1, [r3, #4]
   1d972:	185c      	adds	r4, r3, r1
{
	struct free_arena_header *pah, *nah;

	pah = ah->a.prev;
	nah = ah->a.next;
	if (pah->a.type == ARENA_TYPE_FREE &&
   1d974:	4284      	cmp	r4, r0
   1d976:	d105      	bne.n	1d984 <__free_block+0x20>
	    (char *)pah + pah->a.size == (char *)ah) {
		/* Coalesce into the previous block */
		pah->a.size += ah->a.size;
   1d978:	6860      	ldr	r0, [r4, #4]
		pah->a.next = nah;
   1d97a:	609a      	str	r2, [r3, #8]
	pah = ah->a.prev;
	nah = ah->a.next;
	if (pah->a.type == ARENA_TYPE_FREE &&
	    (char *)pah + pah->a.size == (char *)ah) {
		/* Coalesce into the previous block */
		pah->a.size += ah->a.size;
   1d97c:	4401      	add	r1, r0
   1d97e:	6059      	str	r1, [r3, #4]
		pah->a.next = nah;
		nah->a.prev = pah;
   1d980:	60d3      	str	r3, [r2, #12]
		mark_block_dead(ah);

		ah = pah;
		pah = ah->a.prev;
   1d982:	e009      	b.n	1d998 <__free_block+0x34>
	} else {
		/* Need to add this block to the free chain */
		ah->a.type = ARENA_TYPE_FREE;
   1d984:	2301      	movs	r3, #1
   1d986:	6003      	str	r3, [r0, #0]

		ah->next_free = __malloc_head.next_free;
   1d988:	4b0d      	ldr	r3, [pc, #52]	; (1d9c0 <__free_block+0x5c>)
		ah->prev_free = &__malloc_head;
   1d98a:	6143      	str	r3, [r0, #20]
		pah = ah->a.prev;
	} else {
		/* Need to add this block to the free chain */
		ah->a.type = ARENA_TYPE_FREE;

		ah->next_free = __malloc_head.next_free;
   1d98c:	6919      	ldr	r1, [r3, #16]
   1d98e:	6101      	str	r1, [r0, #16]
		ah->prev_free = &__malloc_head;
		__malloc_head.next_free = ah;
   1d990:	6118      	str	r0, [r3, #16]
		ah->next_free->prev_free = ah;
   1d992:	6903      	ldr	r3, [r0, #16]
   1d994:	6158      	str	r0, [r3, #20]
   1d996:	4603      	mov	r3, r0
	}

	/* In either of the previous cases, we might be able to merge
	   with the subsequent block... */
	if (nah->a.type == ARENA_TYPE_FREE &&
   1d998:	6811      	ldr	r1, [r2, #0]
   1d99a:	2901      	cmp	r1, #1
   1d99c:	d10e      	bne.n	1d9bc <__free_block+0x58>
	    (char *)ah + ah->a.size == (char *)nah) {
   1d99e:	6859      	ldr	r1, [r3, #4]
   1d9a0:	1858      	adds	r0, r3, r1
		ah->next_free->prev_free = ah;
	}

	/* In either of the previous cases, we might be able to merge
	   with the subsequent block... */
	if (nah->a.type == ARENA_TYPE_FREE &&
   1d9a2:	4290      	cmp	r0, r2
   1d9a4:	d10a      	bne.n	1d9bc <__free_block+0x58>
	    (char *)ah + ah->a.size == (char *)nah) {
		ah->a.size += nah->a.size;
   1d9a6:	6850      	ldr	r0, [r2, #4]
   1d9a8:	4401      	add	r1, r0
   1d9aa:	6059      	str	r1, [r3, #4]

static inline void remove_from_free_chain(struct free_arena_header *ah)
{
	struct free_arena_header *ap, *an;

	ap = ah->prev_free;
   1d9ac:	6950      	ldr	r0, [r2, #20]
	an = ah->next_free;
   1d9ae:	6911      	ldr	r1, [r2, #16]
	ap->next_free = an;
   1d9b0:	6101      	str	r1, [r0, #16]
	an->prev_free = ap;
   1d9b2:	6148      	str	r0, [r1, #20]
{
	struct free_arena_header *ap, *an;

	mark_block_dead(ah);

	ap = ah->a.prev;
   1d9b4:	68d1      	ldr	r1, [r2, #12]
	an = ah->a.next;
   1d9b6:	6892      	ldr	r2, [r2, #8]
	ap->a.next = an;
   1d9b8:	608a      	str	r2, [r1, #8]
	an->a.prev = ap;
   1d9ba:	60d1      	str	r1, [r2, #12]
		remove_from_chains(nah);
	}

	/* Return the block that contains the called block */
	return ah;
}
   1d9bc:	4618      	mov	r0, r3
   1d9be:	bd10      	pop	{r4, pc}
   1d9c0:	20000408 	.word	0x20000408

0001d9c4 <add_malloc_block>:
void add_malloc_block(void *buf, size_t size)
{
	struct free_arena_header *fp = buf;
	struct free_arena_header *pah;

	if (size < sizeof(struct free_arena_header))
   1d9c4:	2917      	cmp	r1, #23
	return result;
}

/* Call this to give malloc some memory to allocate from */
void add_malloc_block(void *buf, size_t size)
{
   1d9c6:	b510      	push	{r4, lr}
   1d9c8:	4604      	mov	r4, r0
	struct free_arena_header *fp = buf;
	struct free_arena_header *pah;

	if (size < sizeof(struct free_arena_header))
   1d9ca:	d91b      	bls.n	1da04 <add_malloc_block+0x40>
		return; // Too small.

	/* Insert the block into the management chains.  We need to set
	   up the size and the main block list pointer, the rest of
	   the work is logically identical to free(). */
	fp->a.type = ARENA_TYPE_FREE;
   1d9cc:	2301      	movs	r3, #1
   1d9ce:	6003      	str	r3, [r0, #0]
	fp->a.size = size;

        if (!malloc_lock())
   1d9d0:	4b0d      	ldr	r3, [pc, #52]	; (1da08 <add_malloc_block+0x44>)

	/* Insert the block into the management chains.  We need to set
	   up the size and the main block list pointer, the rest of
	   the work is logically identical to free(). */
	fp->a.type = ARENA_TYPE_FREE;
	fp->a.size = size;
   1d9d2:	6041      	str	r1, [r0, #4]

        if (!malloc_lock())
   1d9d4:	681b      	ldr	r3, [r3, #0]
   1d9d6:	4798      	blx	r3
   1d9d8:	b1a0      	cbz	r0, 1da04 <add_malloc_block+0x40>

	/* We need to insert this into the main block list in the proper
	   place -- this list is required to be sorted.  Since we most likely
	   get memory assignments in ascending order, search backwards for
	   the proper place. */
	for (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;
   1d9da:	4b0c      	ldr	r3, [pc, #48]	; (1da0c <add_malloc_block+0x48>)
	     pah = pah->a.prev) {
   1d9dc:	68db      	ldr	r3, [r3, #12]

	/* We need to insert this into the main block list in the proper
	   place -- this list is required to be sorted.  Since we most likely
	   get memory assignments in ascending order, search backwards for
	   the proper place. */
	for (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;
   1d9de:	681a      	ldr	r2, [r3, #0]
   1d9e0:	2a02      	cmp	r2, #2
   1d9e2:	d001      	beq.n	1d9e8 <add_malloc_block+0x24>
	     pah = pah->a.prev) {
		if (pah < fp)
   1d9e4:	42a3      	cmp	r3, r4
   1d9e6:	d2f9      	bcs.n	1d9dc <add_malloc_block+0x18>
			break;
	}

	/* Now pah points to the node that should be the predecessor of
	   the new node */
	fp->a.next = pah->a.next;
   1d9e8:	689a      	ldr	r2, [r3, #8]
   1d9ea:	60a2      	str	r2, [r4, #8]
	fp->a.prev = pah;
   1d9ec:	60e3      	str	r3, [r4, #12]
	pah->a.next = fp;
   1d9ee:	609c      	str	r4, [r3, #8]
	fp->a.next->a.prev = fp;
   1d9f0:	68a3      	ldr	r3, [r4, #8]

	/* Insert into the free chain and coalesce with adjacent blocks */
	fp = __free_block(fp);
   1d9f2:	4620      	mov	r0, r4
	/* Now pah points to the node that should be the predecessor of
	   the new node */
	fp->a.next = pah->a.next;
	fp->a.prev = pah;
	pah->a.next = fp;
	fp->a.next->a.prev = fp;
   1d9f4:	60dc      	str	r4, [r3, #12]

	/* Insert into the free chain and coalesce with adjacent blocks */
	fp = __free_block(fp);
   1d9f6:	f7ff ffb5 	bl	1d964 <__free_block>

        malloc_unlock();
   1d9fa:	4b05      	ldr	r3, [pc, #20]	; (1da10 <add_malloc_block+0x4c>)
}
   1d9fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	fp->a.next->a.prev = fp;

	/* Insert into the free chain and coalesce with adjacent blocks */
	fp = __free_block(fp);

        malloc_unlock();
   1da00:	681b      	ldr	r3, [r3, #0]
   1da02:	4718      	bx	r3
   1da04:	bd10      	pop	{r4, pc}
   1da06:	bf00      	nop
   1da08:	20000424 	.word	0x20000424
   1da0c:	20000408 	.word	0x20000408
   1da10:	20000420 	.word	0x20000420

0001da14 <malloc>:
	/* Return the block that contains the called block */
	return ah;
}

void *malloc(size_t size)
{
   1da14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct free_arena_header *fp;
        void *more_mem;
        extern void *_sbrk(int incr);

	if (size == 0)
   1da16:	b908      	cbnz	r0, 1da1c <malloc+0x8>
		return NULL;
   1da18:	2000      	movs	r0, #0
   1da1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;

        if (!malloc_lock())
   1da1c:	4b1f      	ldr	r3, [pc, #124]	; (1da9c <malloc+0x88>)

	if (size == 0)
		return NULL;

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
   1da1e:	301f      	adds	r0, #31

        if (!malloc_lock())
   1da20:	681b      	ldr	r3, [r3, #0]

	if (size == 0)
		return NULL;

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
   1da22:	f020 040f 	bic.w	r4, r0, #15

        if (!malloc_lock())
   1da26:	4798      	blx	r3
   1da28:	2800      	cmp	r0, #0
   1da2a:	d0f5      	beq.n	1da18 <malloc+0x4>
                return NULL;

        void *result = NULL;
retry_alloc:
	for (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;
   1da2c:	4b1c      	ldr	r3, [pc, #112]	; (1daa0 <malloc+0x8c>)
   1da2e:	6918      	ldr	r0, [r3, #16]
   1da30:	6803      	ldr	r3, [r0, #0]
   1da32:	2b02      	cmp	r3, #2
   1da34:	d029      	beq.n	1da8a <malloc+0x76>
	     fp = fp->next_free) {
		if (fp->a.size >= size) {
   1da36:	6842      	ldr	r2, [r0, #4]
   1da38:	42a2      	cmp	r2, r4
   1da3a:	d31e      	bcc.n	1da7a <malloc+0x66>

	fsize = fp->a.size;

	/* We need the 2* to account for the larger requirements of a
	   free block */
	if (fsize >= size + 2 * sizeof(struct arena_header)) {
   1da3c:	f104 0320 	add.w	r3, r4, #32
   1da40:	429a      	cmp	r2, r3
   1da42:	6901      	ldr	r1, [r0, #16]
   1da44:	6945      	ldr	r5, [r0, #20]
   1da46:	d311      	bcc.n	1da6c <malloc+0x58>
		/* Bigger block than required -- split block */
		nfp = (struct free_arena_header *)((char *)fp + size);
   1da48:	1903      	adds	r3, r0, r4
		na = fp->a.next;
   1da4a:	6886      	ldr	r6, [r0, #8]

		nfp->a.type = ARENA_TYPE_FREE;
		nfp->a.size = fsize - size;
   1da4c:	1b12      	subs	r2, r2, r4
	if (fsize >= size + 2 * sizeof(struct arena_header)) {
		/* Bigger block than required -- split block */
		nfp = (struct free_arena_header *)((char *)fp + size);
		na = fp->a.next;

		nfp->a.type = ARENA_TYPE_FREE;
   1da4e:	2701      	movs	r7, #1
   1da50:	5107      	str	r7, [r0, r4]
		nfp->a.size = fsize - size;
   1da52:	605a      	str	r2, [r3, #4]
		fp->a.type = ARENA_TYPE_USED;
   1da54:	2200      	movs	r2, #0
		fp->a.size = size;
   1da56:	e880 0014 	stmia.w	r0, {r2, r4}

		/* Insert into all-block chain */
		nfp->a.prev = fp;
   1da5a:	60d8      	str	r0, [r3, #12]
		nfp->a.next = na;
   1da5c:	609e      	str	r6, [r3, #8]
		na->a.prev = nfp;
   1da5e:	60f3      	str	r3, [r6, #12]
		fp->a.next = nfp;
   1da60:	6083      	str	r3, [r0, #8]

		/* Replace current block on free chain */
		nfp->next_free = fpn = fp->next_free;
   1da62:	6119      	str	r1, [r3, #16]
		nfp->prev_free = fpp = fp->prev_free;
   1da64:	615d      	str	r5, [r3, #20]
		fpn->prev_free = nfp;
   1da66:	614b      	str	r3, [r1, #20]
		fpp->next_free = nfp;
   1da68:	612b      	str	r3, [r5, #16]
   1da6a:	e003      	b.n	1da74 <malloc+0x60>
	} else {
		fp->a.type = ARENA_TYPE_USED; /* Allocate the whole block */
   1da6c:	2300      	movs	r3, #0
   1da6e:	6003      	str	r3, [r0, #0]
{
	struct free_arena_header *ap, *an;

	ap = ah->prev_free;
	an = ah->next_free;
	ap->next_free = an;
   1da70:	6129      	str	r1, [r5, #16]
	an->prev_free = ap;
   1da72:	614d      	str	r5, [r1, #20]
	} else {
		fp->a.type = ARENA_TYPE_USED; /* Allocate the whole block */
		remove_from_free_chain(fp);
	}

	return (void *)(&fp->a + 1);
   1da74:	f100 0410 	add.w	r4, r0, #16
   1da78:	e002      	b.n	1da80 <malloc+0x6c>
                return NULL;

        void *result = NULL;
retry_alloc:
	for (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;
	     fp = fp->next_free) {
   1da7a:	6900      	ldr	r0, [r0, #16]
   1da7c:	e7d8      	b.n	1da30 <malloc+0x1c>
   1da7e:	2400      	movs	r4, #0
            if (more_mem != (void *)-1) {
                add_malloc_block(more_mem, size);
                goto retry_alloc;
            }
        }
        malloc_unlock();
   1da80:	4b08      	ldr	r3, [pc, #32]	; (1daa4 <malloc+0x90>)
   1da82:	681b      	ldr	r3, [r3, #0]
   1da84:	4798      	blx	r3
	return result;
   1da86:	4620      	mov	r0, r4
   1da88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			result = __malloc_from_block(fp, size);
                        break;
		}
	}
        if (result == NULL) {
            more_mem = _sbrk(size);
   1da8a:	4620      	mov	r0, r4
   1da8c:	f7ff fc88 	bl	1d3a0 <_sbrk>
            if (more_mem != (void *)-1) {
   1da90:	1c43      	adds	r3, r0, #1
   1da92:	d0f4      	beq.n	1da7e <malloc+0x6a>
                add_malloc_block(more_mem, size);
   1da94:	4621      	mov	r1, r4
   1da96:	f7ff ff95 	bl	1d9c4 <add_malloc_block>
                goto retry_alloc;
   1da9a:	e7c7      	b.n	1da2c <malloc+0x18>
   1da9c:	20000424 	.word	0x20000424
   1daa0:	20000408 	.word	0x20000408
   1daa4:	20000420 	.word	0x20000420

0001daa8 <free>:

        malloc_unlock();
}

void free(void *ptr)
{
   1daa8:	b510      	push	{r4, lr}
	struct free_arena_header *ah;

	if (!ptr)
   1daaa:	4604      	mov	r4, r0
   1daac:	b160      	cbz	r0, 1dac8 <free+0x20>

#ifdef DEBUG_MALLOC
	assert(ah->a.type == ARENA_TYPE_USED);
#endif

        if (!malloc_lock())
   1daae:	4b07      	ldr	r3, [pc, #28]	; (1dacc <free+0x24>)
   1dab0:	681b      	ldr	r3, [r3, #0]
   1dab2:	4798      	blx	r3
   1dab4:	b140      	cbz	r0, 1dac8 <free+0x20>
            return;

	/* Merge into adjacent free blocks */
	ah = __free_block(ah);
   1dab6:	f1a4 0010 	sub.w	r0, r4, #16
   1daba:	f7ff ff53 	bl	1d964 <__free_block>
        malloc_unlock();
   1dabe:	4b04      	ldr	r3, [pc, #16]	; (1dad0 <free+0x28>)
}
   1dac0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        if (!malloc_lock())
            return;

	/* Merge into adjacent free blocks */
	ah = __free_block(ah);
        malloc_unlock();
   1dac4:	681b      	ldr	r3, [r3, #0]
   1dac6:	4718      	bx	r3
   1dac8:	bd10      	pop	{r4, pc}
   1daca:	bf00      	nop
   1dacc:	20000424 	.word	0x20000424
   1dad0:	20000420 	.word	0x20000420

0001dad4 <memmove>:
		q += (n - 1);
		asm volatile("std; rep; movsb; cld"
			     : "+c" (n), "+S"(p), "+D"(q));
	}
#else
	if (q < p) {
   1dad4:	4288      	cmp	r0, r1
 */

#include <string.h>

void *memmove(void *dst, const void *src, size_t n)
{
   1dad6:	b530      	push	{r4, r5, lr}
   1dad8:	eb01 0402 	add.w	r4, r1, r2
		q += (n - 1);
		asm volatile("std; rep; movsb; cld"
			     : "+c" (n), "+S"(p), "+D"(q));
	}
#else
	if (q < p) {
   1dadc:	d208      	bcs.n	1daf0 <memmove+0x1c>
   1dade:	1e43      	subs	r3, r0, #1
		while (n--) {
   1dae0:	42a1      	cmp	r1, r4
   1dae2:	d004      	beq.n	1daee <memmove+0x1a>
			*q++ = *p++;
   1dae4:	f811 2b01 	ldrb.w	r2, [r1], #1
   1dae8:	f803 2f01 	strb.w	r2, [r3, #1]!
   1daec:	e7f8      	b.n	1dae0 <memmove+0xc>
   1daee:	bd30      	pop	{r4, r5, pc}
		}
	} else {
		p += n;
		q += n;
   1daf0:	1881      	adds	r1, r0, r2
	if (q < p) {
		while (n--) {
			*q++ = *p++;
		}
	} else {
		p += n;
   1daf2:	4623      	mov	r3, r4
   1daf4:	1b15      	subs	r5, r2, r4
		q += n;
		while (n--) {
   1daf6:	42eb      	cmn	r3, r5
   1daf8:	d004      	beq.n	1db04 <memmove+0x30>
			*--q = *--p;
   1dafa:	f813 5d01 	ldrb.w	r5, [r3, #-1]!
   1dafe:	f801 5d01 	strb.w	r5, [r1, #-1]!
   1db02:	e7f7      	b.n	1daf4 <memmove+0x20>
		}
	}
#endif

	return dst;
}
   1db04:	bd30      	pop	{r4, r5, pc}

0001db06 <strcmp>:
	const unsigned char *c2 = (const unsigned char *)s2;
	unsigned char ch;
	int d = 0;

	while (1) {
		d = (int)(ch = *c1++) - (int)*c2++;
   1db06:	f810 2b01 	ldrb.w	r2, [r0], #1
   1db0a:	f811 3b01 	ldrb.w	r3, [r1], #1
		if (d || !ch)
   1db0e:	1ad3      	subs	r3, r2, r3
   1db10:	d101      	bne.n	1db16 <strcmp+0x10>
   1db12:	2a00      	cmp	r2, #0
   1db14:	d1f7      	bne.n	1db06 <strcmp>
			break;
	}

	return d;
}
   1db16:	4618      	mov	r0, r3
   1db18:	4770      	bx	lr
	...

0001db1c <console_printf>:
    .vmt = &console_file_ops
};

void
console_printf(const char *fmt, ...)
{
   1db1c:	b40f      	push	{r0, r1, r2, r3}
    va_list args;

    /* Prefix each line with a timestamp. */
    if (!console_is_midline) {
   1db1e:	4b0b      	ldr	r3, [pc, #44]	; (1db4c <console_printf+0x30>)
   1db20:	681b      	ldr	r3, [r3, #0]
    .vmt = &console_file_ops
};

void
console_printf(const char *fmt, ...)
{
   1db22:	b507      	push	{r0, r1, r2, lr}
    va_list args;

    /* Prefix each line with a timestamp. */
    if (!console_is_midline) {
   1db24:	b933      	cbnz	r3, 1db34 <console_printf+0x18>
        fprintf((FILE *)&console_file, "%lu:", (unsigned long)os_time_get());
   1db26:	f7ec fe4b 	bl	a7c0 <os_time_get>
   1db2a:	4909      	ldr	r1, [pc, #36]	; (1db50 <console_printf+0x34>)
   1db2c:	4602      	mov	r2, r0
   1db2e:	4809      	ldr	r0, [pc, #36]	; (1db54 <console_printf+0x38>)
   1db30:	f7eb fc6f 	bl	9412 <fprintf>
    }

    va_start(args, fmt);
   1db34:	aa05      	add	r2, sp, #20
    vfprintf((FILE *)&console_file, fmt, args);
   1db36:	9904      	ldr	r1, [sp, #16]
   1db38:	4806      	ldr	r0, [pc, #24]	; (1db54 <console_printf+0x38>)
    /* Prefix each line with a timestamp. */
    if (!console_is_midline) {
        fprintf((FILE *)&console_file, "%lu:", (unsigned long)os_time_get());
    }

    va_start(args, fmt);
   1db3a:	9201      	str	r2, [sp, #4]
    vfprintf((FILE *)&console_file, fmt, args);
   1db3c:	f7eb fc67 	bl	940e <vfprintf>
    va_end(args);
}
   1db40:	b003      	add	sp, #12
   1db42:	f85d eb04 	ldr.w	lr, [sp], #4
   1db46:	b004      	add	sp, #16
   1db48:	4770      	bx	lr
   1db4a:	bf00      	nop
   1db4c:	20002d14 	.word	0x20002d14
   1db50:	00020c3c 	.word	0x00020c3c
   1db54:	00020c38 	.word	0x00020c38

0001db58 <mbedtls_aes_init>:

#endif /* MBEDTLS_AES_ROM_TABLES */

void mbedtls_aes_init( mbedtls_aes_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_aes_context ) );
   1db58:	2100      	movs	r1, #0
   1db5a:	f44f 728c 	mov.w	r2, #280	; 0x118
   1db5e:	f7eb ba58 	b.w	9012 <memset>
	...

0001db64 <mbedtls_aes_setkey_enc>:
        aes_init_done = 1;

    }
#endif

    switch( keybits )
   1db64:	2ac0      	cmp	r2, #192	; 0xc0
 * AES key schedule (encryption)
 */
#if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)
int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,
                    unsigned int keybits )
{
   1db66:	b5f0      	push	{r4, r5, r6, r7, lr}
        aes_init_done = 1;

    }
#endif

    switch( keybits )
   1db68:	d007      	beq.n	1db7a <mbedtls_aes_setkey_enc+0x16>
   1db6a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   1db6e:	d006      	beq.n	1db7e <mbedtls_aes_setkey_enc+0x1a>
   1db70:	2a80      	cmp	r2, #128	; 0x80
   1db72:	f040 80db 	bne.w	1dd2c <mbedtls_aes_setkey_enc+0x1c8>
    {
        case 128: ctx->nr = 10; break;
   1db76:	230a      	movs	r3, #10
   1db78:	e002      	b.n	1db80 <mbedtls_aes_setkey_enc+0x1c>
        case 192: ctx->nr = 12; break;
   1db7a:	230c      	movs	r3, #12
   1db7c:	e000      	b.n	1db80 <mbedtls_aes_setkey_enc+0x1c>
        case 256: ctx->nr = 14; break;
   1db7e:	230e      	movs	r3, #14
   1db80:	6003      	str	r3, [r0, #0]

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
   1db82:	f100 0308 	add.w	r3, r0, #8
   1db86:	6043      	str	r3, [r0, #4]
#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
#endif

    for( i = 0; i < ( keybits >> 5 ); i++ )
   1db88:	0952      	lsrs	r2, r2, #5
   1db8a:	2400      	movs	r4, #0
   1db8c:	4294      	cmp	r4, r2
   1db8e:	d010      	beq.n	1dbb2 <mbedtls_aes_setkey_enc+0x4e>
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
   1db90:	eb01 0784 	add.w	r7, r1, r4, lsl #2
   1db94:	78bd      	ldrb	r5, [r7, #2]
   1db96:	787e      	ldrb	r6, [r7, #1]
   1db98:	042d      	lsls	r5, r5, #16
   1db9a:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
   1db9e:	f811 6024 	ldrb.w	r6, [r1, r4, lsl #2]
   1dba2:	4335      	orrs	r5, r6
   1dba4:	78fe      	ldrb	r6, [r7, #3]
   1dba6:	ea45 6506 	orr.w	r5, r5, r6, lsl #24
   1dbaa:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
#endif

    for( i = 0; i < ( keybits >> 5 ); i++ )
   1dbae:	3401      	adds	r4, #1
   1dbb0:	e7ec      	b.n	1db8c <mbedtls_aes_setkey_enc+0x28>
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
    }

    switch( ctx->nr )
   1dbb2:	6802      	ldr	r2, [r0, #0]
   1dbb4:	2a0c      	cmp	r2, #12
   1dbb6:	d031      	beq.n	1dc1c <mbedtls_aes_setkey_enc+0xb8>
   1dbb8:	2a0e      	cmp	r2, #14
   1dbba:	d066      	beq.n	1dc8a <mbedtls_aes_setkey_enc+0x126>
   1dbbc:	2a0a      	cmp	r2, #10
   1dbbe:	f040 80b8 	bne.w	1dd32 <mbedtls_aes_setkey_enc+0x1ce>
   1dbc2:	2500      	movs	r5, #0
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
            {
                RK[4]  = RK[0] ^ RCON[i] ^
   1dbc4:	4a5c      	ldr	r2, [pc, #368]	; (1dd38 <mbedtls_aes_setkey_enc+0x1d4>)
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
   1dbc6:	68dc      	ldr	r4, [r3, #12]
   1dbc8:	f852 1025 	ldr.w	r1, [r2, r5, lsl #2]
   1dbcc:	681a      	ldr	r2, [r3, #0]
   1dbce:	4e5b      	ldr	r6, [pc, #364]	; (1dd3c <mbedtls_aes_setkey_enc+0x1d8>)
   1dbd0:	4051      	eors	r1, r2
   1dbd2:	f3c4 2207 	ubfx	r2, r4, #8, #8

    switch( ctx->nr )
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
   1dbd6:	3501      	adds	r5, #1
            {
                RK[4]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
   1dbd8:	5cb0      	ldrb	r0, [r6, r2]
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
   1dbda:	0e22      	lsrs	r2, r4, #24
   1dbdc:	4041      	eors	r1, r0
   1dbde:	5cb2      	ldrb	r2, [r6, r2]
   1dbe0:	ea81 4102 	eor.w	r1, r1, r2, lsl #16
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
   1dbe4:	b2e2      	uxtb	r2, r4

    switch( ctx->nr )
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
   1dbe6:	2d0a      	cmp	r5, #10
            {
                RK[4]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
   1dbe8:	5cb2      	ldrb	r2, [r6, r2]
   1dbea:	ea81 6102 	eor.w	r1, r1, r2, lsl #24

            for( i = 0; i < 10; i++, RK += 4 )
            {
                RK[4]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
   1dbee:	f3c4 4207 	ubfx	r2, r4, #16, #8

    switch( ctx->nr )
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
   1dbf2:	f103 0310 	add.w	r3, r3, #16
            {
                RK[4]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
   1dbf6:	5cb2      	ldrb	r2, [r6, r2]
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
   1dbf8:	ea81 2202 	eor.w	r2, r1, r2, lsl #8
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );

                RK[5]  = RK[1] ^ RK[4];
   1dbfc:	f853 1c0c 	ldr.w	r1, [r3, #-12]
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
            {
                RK[4]  = RK[0] ^ RCON[i] ^
   1dc00:	601a      	str	r2, [r3, #0]
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );

                RK[5]  = RK[1] ^ RK[4];
   1dc02:	ea82 0201 	eor.w	r2, r2, r1
                RK[6]  = RK[2] ^ RK[5];
   1dc06:	f853 1c08 	ldr.w	r1, [r3, #-8]
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );

                RK[5]  = RK[1] ^ RK[4];
   1dc0a:	605a      	str	r2, [r3, #4]
                RK[6]  = RK[2] ^ RK[5];
   1dc0c:	ea82 0201 	eor.w	r2, r2, r1
                RK[7]  = RK[3] ^ RK[6];
   1dc10:	ea84 0402 	eor.w	r4, r4, r2
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );

                RK[5]  = RK[1] ^ RK[4];
                RK[6]  = RK[2] ^ RK[5];
   1dc14:	609a      	str	r2, [r3, #8]
                RK[7]  = RK[3] ^ RK[6];
   1dc16:	60dc      	str	r4, [r3, #12]

    switch( ctx->nr )
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
   1dc18:	d1d4      	bne.n	1dbc4 <mbedtls_aes_setkey_enc+0x60>
   1dc1a:	e08a      	b.n	1dd32 <mbedtls_aes_setkey_enc+0x1ce>
    for( i = 0; i < ( keybits >> 5 ); i++ )
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
    }

    switch( ctx->nr )
   1dc1c:	2400      	movs	r4, #0

        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
            {
                RK[6]  = RK[0] ^ RCON[i] ^
   1dc1e:	4a46      	ldr	r2, [pc, #280]	; (1dd38 <mbedtls_aes_setkey_enc+0x1d4>)
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
   1dc20:	6958      	ldr	r0, [r3, #20]
   1dc22:	f852 1024 	ldr.w	r1, [r2, r4, lsl #2]
   1dc26:	681a      	ldr	r2, [r3, #0]
   1dc28:	4d44      	ldr	r5, [pc, #272]	; (1dd3c <mbedtls_aes_setkey_enc+0x1d8>)
   1dc2a:	404a      	eors	r2, r1
   1dc2c:	f3c0 2107 	ubfx	r1, r0, #8, #8
            }
            break;

        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
   1dc30:	3401      	adds	r4, #1
            {
                RK[6]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
   1dc32:	5c69      	ldrb	r1, [r5, r1]
   1dc34:	404a      	eors	r2, r1
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
   1dc36:	0e01      	lsrs	r1, r0, #24
            }
            break;

        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
   1dc38:	2c08      	cmp	r4, #8
            {
                RK[6]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
   1dc3a:	5c69      	ldrb	r1, [r5, r1]
   1dc3c:	ea82 4201 	eor.w	r2, r2, r1, lsl #16
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
   1dc40:	b2c1      	uxtb	r1, r0
            }
            break;

        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
   1dc42:	f103 0318 	add.w	r3, r3, #24
            {
                RK[6]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
   1dc46:	5c69      	ldrb	r1, [r5, r1]
   1dc48:	ea82 6201 	eor.w	r2, r2, r1, lsl #24

            for( i = 0; i < 8; i++, RK += 6 )
            {
                RK[6]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
   1dc4c:	f3c0 4107 	ubfx	r1, r0, #16, #8
   1dc50:	5c69      	ldrb	r1, [r5, r1]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
   1dc52:	ea82 2201 	eor.w	r2, r2, r1, lsl #8
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );

                RK[7]  = RK[1] ^ RK[6];
   1dc56:	f853 1c14 	ldr.w	r1, [r3, #-20]

        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
            {
                RK[6]  = RK[0] ^ RCON[i] ^
   1dc5a:	601a      	str	r2, [r3, #0]
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );

                RK[7]  = RK[1] ^ RK[6];
   1dc5c:	ea82 0201 	eor.w	r2, r2, r1
                RK[8]  = RK[2] ^ RK[7];
   1dc60:	f853 1c10 	ldr.w	r1, [r3, #-16]
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );

                RK[7]  = RK[1] ^ RK[6];
   1dc64:	605a      	str	r2, [r3, #4]
                RK[8]  = RK[2] ^ RK[7];
   1dc66:	ea82 0201 	eor.w	r2, r2, r1
                RK[9]  = RK[3] ^ RK[8];
   1dc6a:	f853 1c0c 	ldr.w	r1, [r3, #-12]
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );

                RK[7]  = RK[1] ^ RK[6];
                RK[8]  = RK[2] ^ RK[7];
   1dc6e:	609a      	str	r2, [r3, #8]
                RK[9]  = RK[3] ^ RK[8];
   1dc70:	ea82 0201 	eor.w	r2, r2, r1
                RK[10] = RK[4] ^ RK[9];
   1dc74:	f853 1c08 	ldr.w	r1, [r3, #-8]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );

                RK[7]  = RK[1] ^ RK[6];
                RK[8]  = RK[2] ^ RK[7];
                RK[9]  = RK[3] ^ RK[8];
   1dc78:	60da      	str	r2, [r3, #12]
                RK[10] = RK[4] ^ RK[9];
   1dc7a:	ea82 0201 	eor.w	r2, r2, r1
                RK[11] = RK[5] ^ RK[10];
   1dc7e:	ea80 0002 	eor.w	r0, r0, r2
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );

                RK[7]  = RK[1] ^ RK[6];
                RK[8]  = RK[2] ^ RK[7];
                RK[9]  = RK[3] ^ RK[8];
                RK[10] = RK[4] ^ RK[9];
   1dc82:	611a      	str	r2, [r3, #16]
                RK[11] = RK[5] ^ RK[10];
   1dc84:	6158      	str	r0, [r3, #20]
            }
            break;

        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
   1dc86:	d1ca      	bne.n	1dc1e <mbedtls_aes_setkey_enc+0xba>
   1dc88:	e053      	b.n	1dd32 <mbedtls_aes_setkey_enc+0x1ce>
    for( i = 0; i < ( keybits >> 5 ); i++ )
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
    }

    switch( ctx->nr )
   1dc8a:	2500      	movs	r5, #0

        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
            {
                RK[8]  = RK[0] ^ RCON[i] ^
   1dc8c:	4a2a      	ldr	r2, [pc, #168]	; (1dd38 <mbedtls_aes_setkey_enc+0x1d4>)
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
   1dc8e:	69dc      	ldr	r4, [r3, #28]
   1dc90:	f852 1025 	ldr.w	r1, [r2, r5, lsl #2]
   1dc94:	681a      	ldr	r2, [r3, #0]
   1dc96:	4e29      	ldr	r6, [pc, #164]	; (1dd3c <mbedtls_aes_setkey_enc+0x1d8>)
   1dc98:	4051      	eors	r1, r2
   1dc9a:	f3c4 2207 	ubfx	r2, r4, #8, #8
            }
            break;

        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
   1dc9e:	3501      	adds	r5, #1
            {
                RK[8]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
   1dca0:	5cb0      	ldrb	r0, [r6, r2]
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
   1dca2:	0e22      	lsrs	r2, r4, #24
   1dca4:	4041      	eors	r1, r0
   1dca6:	5cb2      	ldrb	r2, [r6, r2]
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );

                RK[9]  = RK[1] ^ RK[8];
   1dca8:	6858      	ldr	r0, [r3, #4]
   1dcaa:	ea81 4102 	eor.w	r1, r1, r2, lsl #16
            {
                RK[8]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
   1dcae:	b2e2      	uxtb	r2, r4
            }
            break;

        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
   1dcb0:	2d07      	cmp	r5, #7
            {
                RK[8]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
   1dcb2:	5cb2      	ldrb	r2, [r6, r2]
   1dcb4:	ea81 6102 	eor.w	r1, r1, r2, lsl #24

            for( i = 0; i < 7; i++, RK += 8 )
            {
                RK[8]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
   1dcb8:	f3c4 4207 	ubfx	r2, r4, #16, #8
            }
            break;

        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
   1dcbc:	f103 0320 	add.w	r3, r3, #32
            {
                RK[8]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
   1dcc0:	5cb2      	ldrb	r2, [r6, r2]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
   1dcc2:	ea81 2102 	eor.w	r1, r1, r2, lsl #8
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );

                RK[9]  = RK[1] ^ RK[8];
                RK[10] = RK[2] ^ RK[9];
   1dcc6:	f853 2c18 	ldr.w	r2, [r3, #-24]

        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
            {
                RK[8]  = RK[0] ^ RCON[i] ^
   1dcca:	6019      	str	r1, [r3, #0]
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );

                RK[9]  = RK[1] ^ RK[8];
   1dccc:	ea81 0100 	eor.w	r1, r1, r0
                RK[10] = RK[2] ^ RK[9];
                RK[11] = RK[3] ^ RK[10];
   1dcd0:	f853 0c14 	ldr.w	r0, [r3, #-20]
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );

                RK[9]  = RK[1] ^ RK[8];
   1dcd4:	6059      	str	r1, [r3, #4]
                RK[10] = RK[2] ^ RK[9];
   1dcd6:	ea81 0102 	eor.w	r1, r1, r2
                RK[11] = RK[3] ^ RK[10];
   1dcda:	ea80 0001 	eor.w	r0, r0, r1

                RK[12] = RK[4] ^
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
   1dcde:	b2c2      	uxtb	r2, r0
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );

                RK[9]  = RK[1] ^ RK[8];
                RK[10] = RK[2] ^ RK[9];
   1dce0:	6099      	str	r1, [r3, #8]
                RK[11] = RK[3] ^ RK[10];

                RK[12] = RK[4] ^
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
   1dce2:	5cb2      	ldrb	r2, [r6, r2]
   1dce4:	f853 1c10 	ldr.w	r1, [r3, #-16]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );

                RK[9]  = RK[1] ^ RK[8];
                RK[10] = RK[2] ^ RK[9];
                RK[11] = RK[3] ^ RK[10];
   1dce8:	60d8      	str	r0, [r3, #12]
   1dcea:	ea81 0102 	eor.w	r1, r1, r2

                RK[12] = RK[4] ^
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
   1dcee:	ea4f 6210 	mov.w	r2, r0, lsr #24
   1dcf2:	5cb2      	ldrb	r2, [r6, r2]
   1dcf4:	ea81 6102 	eor.w	r1, r1, r2, lsl #24
                RK[10] = RK[2] ^ RK[9];
                RK[11] = RK[3] ^ RK[10];

                RK[12] = RK[4] ^
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
   1dcf8:	f3c0 2207 	ubfx	r2, r0, #8, #8
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
   1dcfc:	f3c0 4007 	ubfx	r0, r0, #16, #8
                RK[10] = RK[2] ^ RK[9];
                RK[11] = RK[3] ^ RK[10];

                RK[12] = RK[4] ^
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
   1dd00:	5cb2      	ldrb	r2, [r6, r2]
   1dd02:	ea81 2102 	eor.w	r1, r1, r2, lsl #8
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
   1dd06:	5c32      	ldrb	r2, [r6, r0]
   1dd08:	ea81 4202 	eor.w	r2, r1, r2, lsl #16
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );

                RK[13] = RK[5] ^ RK[12];
   1dd0c:	f853 1c0c 	ldr.w	r1, [r3, #-12]

                RK[9]  = RK[1] ^ RK[8];
                RK[10] = RK[2] ^ RK[9];
                RK[11] = RK[3] ^ RK[10];

                RK[12] = RK[4] ^
   1dd10:	611a      	str	r2, [r3, #16]
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );

                RK[13] = RK[5] ^ RK[12];
   1dd12:	ea82 0201 	eor.w	r2, r2, r1
                RK[14] = RK[6] ^ RK[13];
   1dd16:	f853 1c08 	ldr.w	r1, [r3, #-8]
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );

                RK[13] = RK[5] ^ RK[12];
   1dd1a:	615a      	str	r2, [r3, #20]
                RK[14] = RK[6] ^ RK[13];
   1dd1c:	ea82 0201 	eor.w	r2, r2, r1
                RK[15] = RK[7] ^ RK[14];
   1dd20:	ea84 0402 	eor.w	r4, r4, r2
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );

                RK[13] = RK[5] ^ RK[12];
                RK[14] = RK[6] ^ RK[13];
   1dd24:	619a      	str	r2, [r3, #24]
                RK[15] = RK[7] ^ RK[14];
   1dd26:	61dc      	str	r4, [r3, #28]
            }
            break;

        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
   1dd28:	d1b0      	bne.n	1dc8c <mbedtls_aes_setkey_enc+0x128>
   1dd2a:	e002      	b.n	1dd32 <mbedtls_aes_setkey_enc+0x1ce>
    switch( keybits )
    {
        case 128: ctx->nr = 10; break;
        case 192: ctx->nr = 12; break;
        case 256: ctx->nr = 14; break;
        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
   1dd2c:	f06f 001f 	mvn.w	r0, #31
   1dd30:	bdf0      	pop	{r4, r5, r6, r7, pc}
                RK[15] = RK[7] ^ RK[14];
            }
            break;
    }

    return( 0 );
   1dd32:	2000      	movs	r0, #0
}
   1dd34:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1dd36:	bf00      	nop
   1dd38:	00021d4c 	.word	0x00021d4c
   1dd3c:	00020c4c 	.word	0x00020c4c

0001dd40 <mbedtls_aes_encrypt>:
 */
#if !defined(MBEDTLS_AES_ENCRYPT_ALT)
void mbedtls_aes_encrypt( mbedtls_aes_context *ctx,
                          const unsigned char input[16],
                          unsigned char output[16] )
{
   1dd40:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
   1dd44:	788d      	ldrb	r5, [r1, #2]
   1dd46:	784b      	ldrb	r3, [r1, #1]
   1dd48:	780c      	ldrb	r4, [r1, #0]
                          unsigned char output[16] )
{
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
   1dd4a:	6847      	ldr	r7, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
   1dd4c:	7a4e      	ldrb	r6, [r1, #9]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
   1dd4e:	f891 e00d 	ldrb.w	lr, [r1, #13]
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
   1dd52:	042d      	lsls	r5, r5, #16
   1dd54:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
   1dd58:	78cb      	ldrb	r3, [r1, #3]
   1dd5a:	4325      	orrs	r5, r4
   1dd5c:	ea45 6303 	orr.w	r3, r5, r3, lsl #24
   1dd60:	683d      	ldr	r5, [r7, #0]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
   1dd62:	794c      	ldrb	r4, [r1, #5]
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
   1dd64:	405d      	eors	r5, r3
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
   1dd66:	798b      	ldrb	r3, [r1, #6]
   1dd68:	041b      	lsls	r3, r3, #16
   1dd6a:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
   1dd6e:	790c      	ldrb	r4, [r1, #4]
   1dd70:	4323      	orrs	r3, r4
   1dd72:	79cc      	ldrb	r4, [r1, #7]
   1dd74:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
   1dd78:	687c      	ldr	r4, [r7, #4]
   1dd7a:	4063      	eors	r3, r4
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
   1dd7c:	7a8c      	ldrb	r4, [r1, #10]
   1dd7e:	0424      	lsls	r4, r4, #16
   1dd80:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
   1dd84:	7a0e      	ldrb	r6, [r1, #8]
   1dd86:	4334      	orrs	r4, r6
   1dd88:	7ace      	ldrb	r6, [r1, #11]
   1dd8a:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
   1dd8e:	68be      	ldr	r6, [r7, #8]
   1dd90:	4074      	eors	r4, r6
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
   1dd92:	7b8e      	ldrb	r6, [r1, #14]
   1dd94:	0436      	lsls	r6, r6, #16
   1dd96:	ea46 260e 	orr.w	r6, r6, lr, lsl #8
   1dd9a:	f891 e00c 	ldrb.w	lr, [r1, #12]
   1dd9e:	7bc9      	ldrb	r1, [r1, #15]
   1dda0:	ea46 060e 	orr.w	r6, r6, lr
   1dda4:	ea46 6101 	orr.w	r1, r6, r1, lsl #24
   1dda8:	68fe      	ldr	r6, [r7, #12]
   1ddaa:	404e      	eors	r6, r1

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1ddac:	6801      	ldr	r1, [r0, #0]
   1ddae:	1049      	asrs	r1, r1, #1
   1ddb0:	3901      	subs	r1, #1
   1ddb2:	9101      	str	r1, [sp, #4]
    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
   1ddb4:	f107 0110 	add.w	r1, r7, #16

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1ddb8:	9801      	ldr	r0, [sp, #4]
   1ddba:	f8df e340 	ldr.w	lr, [pc, #832]	; 1e0fc <mbedtls_aes_encrypt+0x3bc>
   1ddbe:	2800      	cmp	r0, #0
   1ddc0:	4688      	mov	r8, r1
   1ddc2:	48cc      	ldr	r0, [pc, #816]	; (1e0f4 <mbedtls_aes_encrypt+0x3b4>)
   1ddc4:	f101 0120 	add.w	r1, r1, #32
   1ddc8:	ea4f 6716 	mov.w	r7, r6, lsr #24
   1ddcc:	fa5f fc85 	uxtb.w	ip, r5
   1ddd0:	f340 80be 	ble.w	1df50 <mbedtls_aes_encrypt+0x210>
   1ddd4:	f850 9027 	ldr.w	r9, [r0, r7, lsl #2]
   1ddd8:	f85e 702c 	ldr.w	r7, [lr, ip, lsl #2]
    {
        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1dddc:	f8df 8320 	ldr.w	r8, [pc, #800]	; 1e100 <mbedtls_aes_encrypt+0x3c0>
   1dde0:	f8df c320 	ldr.w	ip, [pc, #800]	; 1e104 <mbedtls_aes_encrypt+0x3c4>
   1dde4:	ea89 0907 	eor.w	r9, r9, r7
   1dde8:	f851 7c20 	ldr.w	r7, [r1, #-32]
   1ddec:	ea89 0907 	eor.w	r9, r9, r7
   1ddf0:	f3c3 2707 	ubfx	r7, r3, #8, #8
   1ddf4:	ea4f 6a15 	mov.w	sl, r5, lsr #24
   1ddf8:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
   1ddfc:	f850 a02a 	ldr.w	sl, [r0, sl, lsl #2]
   1de00:	ea89 0707 	eor.w	r7, r9, r7
   1de04:	f3c4 4907 	ubfx	r9, r4, #16, #8
   1de08:	ea4f 6b13 	mov.w	fp, r3, lsr #24
   1de0c:	f85c 9029 	ldr.w	r9, [ip, r9, lsl #2]
   1de10:	f850 b02b 	ldr.w	fp, [r0, fp, lsl #2]
   1de14:	ea87 0909 	eor.w	r9, r7, r9
   1de18:	b2df      	uxtb	r7, r3
   1de1a:	f3c3 4307 	ubfx	r3, r3, #16, #8
   1de1e:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
   1de22:	ea8a 0a07 	eor.w	sl, sl, r7
   1de26:	f851 7c1c 	ldr.w	r7, [r1, #-28]
   1de2a:	ea8a 0707 	eor.w	r7, sl, r7
   1de2e:	f3c4 2a07 	ubfx	sl, r4, #8, #8
   1de32:	f858 a02a 	ldr.w	sl, [r8, sl, lsl #2]
   1de36:	ea87 070a 	eor.w	r7, r7, sl
   1de3a:	f3c6 4a07 	ubfx	sl, r6, #16, #8
   1de3e:	f85c a02a 	ldr.w	sl, [ip, sl, lsl #2]
   1de42:	ea87 0a0a 	eor.w	sl, r7, sl
   1de46:	b2e7      	uxtb	r7, r4
   1de48:	0e24      	lsrs	r4, r4, #24
   1de4a:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
   1de4e:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
   1de52:	ea8b 0b07 	eor.w	fp, fp, r7
   1de56:	f851 7c18 	ldr.w	r7, [r1, #-24]
   1de5a:	ea8b 0707 	eor.w	r7, fp, r7
   1de5e:	f3c6 2b07 	ubfx	fp, r6, #8, #8
   1de62:	f858 b02b 	ldr.w	fp, [r8, fp, lsl #2]
   1de66:	ea87 070b 	eor.w	r7, r7, fp
   1de6a:	f3c5 4b07 	ubfx	fp, r5, #16, #8
   1de6e:	f3c5 2507 	ubfx	r5, r5, #8, #8
   1de72:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
   1de76:	ea87 070b 	eor.w	r7, r7, fp
   1de7a:	fa5f fb86 	uxtb.w	fp, r6
   1de7e:	f85e 602b 	ldr.w	r6, [lr, fp, lsl #2]
   1de82:	4066      	eors	r6, r4
   1de84:	f851 4c14 	ldr.w	r4, [r1, #-20]
   1de88:	4074      	eors	r4, r6
   1de8a:	f858 6025 	ldr.w	r6, [r8, r5, lsl #2]
   1de8e:	4074      	eors	r4, r6
   1de90:	f85c 6023 	ldr.w	r6, [ip, r3, lsl #2]
   1de94:	4066      	eors	r6, r4
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
   1de96:	0e33      	lsrs	r3, r6, #24
   1de98:	fa5f f489 	uxtb.w	r4, r9
   1de9c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1dea0:	f85e 5024 	ldr.w	r5, [lr, r4, lsl #2]
   1dea4:	f3ca 2407 	ubfx	r4, sl, #8, #8
   1dea8:	405d      	eors	r5, r3
   1deaa:	f851 3c10 	ldr.w	r3, [r1, #-16]
   1deae:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
   1deb2:	406b      	eors	r3, r5
   1deb4:	4063      	eors	r3, r4
   1deb6:	f3c7 4407 	ubfx	r4, r7, #16, #8
   1deba:	fa5f fb87 	uxtb.w	fp, r7
   1debe:	f85c 5024 	ldr.w	r5, [ip, r4, lsl #2]
   1dec2:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
   1dec6:	fa5f f48a 	uxtb.w	r4, sl
   1deca:	405d      	eors	r5, r3
   1decc:	ea4f 6319 	mov.w	r3, r9, lsr #24
   1ded0:	f85e 4024 	ldr.w	r4, [lr, r4, lsl #2]
   1ded4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1ded8:	405c      	eors	r4, r3
   1deda:	f851 3c0c 	ldr.w	r3, [r1, #-12]
   1dede:	4063      	eors	r3, r4
   1dee0:	f3c7 2407 	ubfx	r4, r7, #8, #8
   1dee4:	0e3f      	lsrs	r7, r7, #24
   1dee6:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
   1deea:	4063      	eors	r3, r4
   1deec:	f3c6 4407 	ubfx	r4, r6, #16, #8
   1def0:	f85c 4024 	ldr.w	r4, [ip, r4, lsl #2]
   1def4:	4063      	eors	r3, r4
   1def6:	ea4f 641a 	mov.w	r4, sl, lsr #24
   1defa:	f3ca 4a07 	ubfx	sl, sl, #16, #8
   1defe:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
   1df02:	ea8b 0b04 	eor.w	fp, fp, r4
   1df06:	f851 4c08 	ldr.w	r4, [r1, #-8]
   1df0a:	ea8b 0404 	eor.w	r4, fp, r4
   1df0e:	f3c6 2b07 	ubfx	fp, r6, #8, #8
   1df12:	b2f6      	uxtb	r6, r6
   1df14:	f858 b02b 	ldr.w	fp, [r8, fp, lsl #2]
   1df18:	f850 0027 	ldr.w	r0, [r0, r7, lsl #2]
   1df1c:	f85e 6026 	ldr.w	r6, [lr, r6, lsl #2]
   1df20:	ea84 040b 	eor.w	r4, r4, fp
   1df24:	f3c9 4b07 	ubfx	fp, r9, #16, #8
   1df28:	f3c9 2907 	ubfx	r9, r9, #8, #8
   1df2c:	4046      	eors	r6, r0
   1df2e:	f851 0c04 	ldr.w	r0, [r1, #-4]
   1df32:	f858 7029 	ldr.w	r7, [r8, r9, lsl #2]
   1df36:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
   1df3a:	4070      	eors	r0, r6
   1df3c:	f85c 602a 	ldr.w	r6, [ip, sl, lsl #2]
   1df40:	4078      	eors	r0, r7
   1df42:	4046      	eors	r6, r0
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1df44:	9801      	ldr	r0, [sp, #4]
   1df46:	3801      	subs	r0, #1
    {
        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
   1df48:	ea84 040b 	eor.w	r4, r4, fp
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1df4c:	9001      	str	r0, [sp, #4]
   1df4e:	e733      	b.n	1ddb8 <mbedtls_aes_encrypt+0x78>
   1df50:	f850 1027 	ldr.w	r1, [r0, r7, lsl #2]
   1df54:	f85e c02c 	ldr.w	ip, [lr, ip, lsl #2]
    {
        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1df58:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 1e100 <mbedtls_aes_encrypt+0x3c0>
   1df5c:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 1e104 <mbedtls_aes_encrypt+0x3c4>
   1df60:	f3c3 2707 	ubfx	r7, r3, #8, #8
   1df64:	ea8c 0c01 	eor.w	ip, ip, r1
   1df68:	f8d8 1000 	ldr.w	r1, [r8]
   1df6c:	f85a 7027 	ldr.w	r7, [sl, r7, lsl #2]
   1df70:	ea8c 0101 	eor.w	r1, ip, r1
   1df74:	4079      	eors	r1, r7
   1df76:	f3c4 4707 	ubfx	r7, r4, #16, #8
   1df7a:	fa5f fb84 	uxtb.w	fp, r4
   1df7e:	f859 7027 	ldr.w	r7, [r9, r7, lsl #2]
   1df82:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
   1df86:	ea81 0c07 	eor.w	ip, r1, r7
   1df8a:	b2df      	uxtb	r7, r3
   1df8c:	0e29      	lsrs	r1, r5, #24
   1df8e:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
   1df92:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
   1df96:	404f      	eors	r7, r1
   1df98:	f8d8 1004 	ldr.w	r1, [r8, #4]
   1df9c:	4079      	eors	r1, r7
   1df9e:	f3c4 2707 	ubfx	r7, r4, #8, #8
   1dfa2:	0e24      	lsrs	r4, r4, #24
   1dfa4:	f85a 7027 	ldr.w	r7, [sl, r7, lsl #2]
   1dfa8:	4079      	eors	r1, r7
   1dfaa:	f3c6 4707 	ubfx	r7, r6, #16, #8
   1dfae:	f859 7027 	ldr.w	r7, [r9, r7, lsl #2]
   1dfb2:	4079      	eors	r1, r7
   1dfb4:	0e1f      	lsrs	r7, r3, #24
   1dfb6:	f3c3 4307 	ubfx	r3, r3, #16, #8
   1dfba:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
   1dfbe:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
   1dfc2:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
   1dfc6:	ea8b 0b07 	eor.w	fp, fp, r7
   1dfca:	f8d8 7008 	ldr.w	r7, [r8, #8]
   1dfce:	ea8b 0707 	eor.w	r7, fp, r7
   1dfd2:	f3c6 2b07 	ubfx	fp, r6, #8, #8
   1dfd6:	b2f6      	uxtb	r6, r6
   1dfd8:	f85a b02b 	ldr.w	fp, [sl, fp, lsl #2]
   1dfdc:	f85e 6026 	ldr.w	r6, [lr, r6, lsl #2]
   1dfe0:	ea87 070b 	eor.w	r7, r7, fp
   1dfe4:	ea86 0400 	eor.w	r4, r6, r0
   1dfe8:	f3c5 4b07 	ubfx	fp, r5, #16, #8
   1dfec:	f8d8 000c 	ldr.w	r0, [r8, #12]
   1dff0:	f859 b02b 	ldr.w	fp, [r9, fp, lsl #2]
   1dff4:	f3c5 2507 	ubfx	r5, r5, #8, #8
   1dff8:	4060      	eors	r0, r4
   1dffa:	f85a 4025 	ldr.w	r4, [sl, r5, lsl #2]
   1dffe:	4060      	eors	r0, r4
   1e000:	4058      	eors	r0, r3

    X0 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
   1e002:	fa5f f48c 	uxtb.w	r4, ip
   1e006:	4b3c      	ldr	r3, [pc, #240]	; (1e0f8 <mbedtls_aes_encrypt+0x3b8>)
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
   1e008:	0e05      	lsrs	r5, r0, #24
    }

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
   1e00a:	5d1e      	ldrb	r6, [r3, r4]
   1e00c:	f8d8 4010 	ldr.w	r4, [r8, #16]
   1e010:	4074      	eors	r4, r6
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
   1e012:	5d5e      	ldrb	r6, [r3, r5]

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
   1e014:	f3c1 2507 	ubfx	r5, r1, #8, #8
    {
        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1e018:	ea87 070b 	eor.w	r7, r7, fp
   1e01c:	ea84 6406 	eor.w	r4, r4, r6, lsl #24

    X0 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
   1e020:	5d5e      	ldrb	r6, [r3, r5]
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
   1e022:	f3c7 4507 	ubfx	r5, r7, #16, #8
   1e026:	ea84 2406 	eor.w	r4, r4, r6, lsl #8
   1e02a:	5d5e      	ldrb	r6, [r3, r5]
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
   1e02c:	ea84 4606 	eor.w	r6, r4, r6, lsl #16
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
   1e030:	b2cc      	uxtb	r4, r1
   1e032:	5d1d      	ldrb	r5, [r3, r4]
   1e034:	f8d8 4014 	ldr.w	r4, [r8, #20]
   1e038:	406c      	eors	r4, r5
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
   1e03a:	ea4f 651c 	mov.w	r5, ip, lsr #24
   1e03e:	5d5d      	ldrb	r5, [r3, r5]
   1e040:	ea84 6405 	eor.w	r4, r4, r5, lsl #24
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
   1e044:	f3c7 2507 	ubfx	r5, r7, #8, #8
   1e048:	5d5d      	ldrb	r5, [r3, r5]
   1e04a:	ea84 2405 	eor.w	r4, r4, r5, lsl #8
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
   1e04e:	f3c0 4507 	ubfx	r5, r0, #16, #8
   1e052:	5d5d      	ldrb	r5, [r3, r5]
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
   1e054:	ea84 4505 	eor.w	r5, r4, r5, lsl #16
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
   1e058:	b2fc      	uxtb	r4, r7

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
   1e05a:	0e3f      	lsrs	r7, r7, #24
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
   1e05c:	f813 e004 	ldrb.w	lr, [r3, r4]
   1e060:	f8d8 4018 	ldr.w	r4, [r8, #24]
   1e064:	ea8e 0404 	eor.w	r4, lr, r4
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
   1e068:	ea4f 6e11 	mov.w	lr, r1, lsr #24

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
   1e06c:	f3c1 4107 	ubfx	r1, r1, #16, #8

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
   1e070:	f813 e00e 	ldrb.w	lr, [r3, lr]
   1e074:	ea84 640e 	eor.w	r4, r4, lr, lsl #24
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
   1e078:	f3c0 2e07 	ubfx	lr, r0, #8, #8
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
   1e07c:	b2c0      	uxtb	r0, r0
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
   1e07e:	f813 e00e 	ldrb.w	lr, [r3, lr]

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
   1e082:	5ddf      	ldrb	r7, [r3, r7]
   1e084:	ea84 240e 	eor.w	r4, r4, lr, lsl #8
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
   1e088:	f3cc 4e07 	ubfx	lr, ip, #16, #8
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
   1e08c:	f3cc 2c07 	ubfx	ip, ip, #8, #8
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
   1e090:	f813 e00e 	ldrb.w	lr, [r3, lr]
            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
   1e094:	ea84 440e 	eor.w	r4, r4, lr, lsl #16
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
   1e098:	f813 e000 	ldrb.w	lr, [r3, r0]
   1e09c:	f8d8 001c 	ldr.w	r0, [r8, #28]
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
   1e0a0:	7016      	strb	r6, [r2, #0]
   1e0a2:	ea8e 0000 	eor.w	r0, lr, r0
   1e0a6:	ea80 6007 	eor.w	r0, r0, r7, lsl #24
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
   1e0aa:	f813 700c 	ldrb.w	r7, [r3, ip]
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
   1e0ae:	5c5b      	ldrb	r3, [r3, r1]
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
    PUT_UINT32_LE( X1, output,  4 );
   1e0b0:	7115      	strb	r5, [r2, #4]
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
   1e0b2:	0a31      	lsrs	r1, r6, #8
   1e0b4:	7051      	strb	r1, [r2, #1]
   1e0b6:	0c31      	lsrs	r1, r6, #16
   1e0b8:	7091      	strb	r1, [r2, #2]
    PUT_UINT32_LE( X1, output,  4 );
   1e0ba:	0a29      	lsrs	r1, r5, #8
   1e0bc:	7151      	strb	r1, [r2, #5]
   1e0be:	0c29      	lsrs	r1, r5, #16
   1e0c0:	ea80 2007 	eor.w	r0, r0, r7, lsl #8
   1e0c4:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
   1e0c6:	0a21      	lsrs	r1, r4, #8
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
   1e0c8:	ea80 4303 	eor.w	r3, r0, r3, lsl #16
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
    PUT_UINT32_LE( X1, output,  4 );
    PUT_UINT32_LE( X2, output,  8 );
   1e0cc:	7251      	strb	r1, [r2, #9]
   1e0ce:	0c21      	lsrs	r1, r4, #16
   1e0d0:	7291      	strb	r1, [r2, #10]
    PUT_UINT32_LE( X3, output, 12 );
   1e0d2:	0a19      	lsrs	r1, r3, #8
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
   1e0d4:	0e36      	lsrs	r6, r6, #24
    PUT_UINT32_LE( X1, output,  4 );
   1e0d6:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X2, output,  8 );
   1e0d8:	7214      	strb	r4, [r2, #8]
    PUT_UINT32_LE( X3, output, 12 );
   1e0da:	7313      	strb	r3, [r2, #12]
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
    PUT_UINT32_LE( X1, output,  4 );
    PUT_UINT32_LE( X2, output,  8 );
   1e0dc:	0e24      	lsrs	r4, r4, #24
    PUT_UINT32_LE( X3, output, 12 );
   1e0de:	7351      	strb	r1, [r2, #13]
   1e0e0:	0c19      	lsrs	r1, r3, #16
   1e0e2:	0e1b      	lsrs	r3, r3, #24
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
   1e0e4:	70d6      	strb	r6, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
   1e0e6:	71d5      	strb	r5, [r2, #7]
    PUT_UINT32_LE( X2, output,  8 );
   1e0e8:	72d4      	strb	r4, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
   1e0ea:	7391      	strb	r1, [r2, #14]
   1e0ec:	73d3      	strb	r3, [r2, #15]
}
   1e0ee:	b003      	add	sp, #12
   1e0f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e0f4:	00022974 	.word	0x00022974
   1e0f8:	00020c4c 	.word	0x00020c4c
   1e0fc:	00021d74 	.word	0x00021d74
   1e100:	00022174 	.word	0x00022174
   1e104:	00022574 	.word	0x00022574

0001e108 <mbedtls_aes_decrypt>:
 */
#if !defined(MBEDTLS_AES_DECRYPT_ALT)
void mbedtls_aes_decrypt( mbedtls_aes_context *ctx,
                          const unsigned char input[16],
                          unsigned char output[16] )
{
   1e108:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
   1e10c:	788d      	ldrb	r5, [r1, #2]
   1e10e:	784b      	ldrb	r3, [r1, #1]
   1e110:	780c      	ldrb	r4, [r1, #0]
                          unsigned char output[16] )
{
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
   1e112:	6846      	ldr	r6, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
   1e114:	790f      	ldrb	r7, [r1, #4]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
   1e116:	f891 800e 	ldrb.w	r8, [r1, #14]
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
   1e11a:	042d      	lsls	r5, r5, #16
   1e11c:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
   1e120:	78cb      	ldrb	r3, [r1, #3]
   1e122:	4325      	orrs	r5, r4
   1e124:	ea45 6303 	orr.w	r3, r5, r3, lsl #24
   1e128:	6835      	ldr	r5, [r6, #0]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
   1e12a:	798c      	ldrb	r4, [r1, #6]
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
   1e12c:	405d      	eors	r5, r3
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
   1e12e:	794b      	ldrb	r3, [r1, #5]
   1e130:	0424      	lsls	r4, r4, #16
   1e132:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
   1e136:	79cb      	ldrb	r3, [r1, #7]
   1e138:	433c      	orrs	r4, r7
   1e13a:	ea44 6303 	orr.w	r3, r4, r3, lsl #24
   1e13e:	6874      	ldr	r4, [r6, #4]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
   1e140:	7a4f      	ldrb	r7, [r1, #9]
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
   1e142:	405c      	eors	r4, r3
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
   1e144:	7a8b      	ldrb	r3, [r1, #10]
   1e146:	041b      	lsls	r3, r3, #16
   1e148:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
   1e14c:	7a0f      	ldrb	r7, [r1, #8]
   1e14e:	433b      	orrs	r3, r7
   1e150:	7acf      	ldrb	r7, [r1, #11]
   1e152:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
   1e156:	68b7      	ldr	r7, [r6, #8]
   1e158:	407b      	eors	r3, r7
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
   1e15a:	7b4f      	ldrb	r7, [r1, #13]
   1e15c:	ea4f 4808 	mov.w	r8, r8, lsl #16
   1e160:	ea48 2807 	orr.w	r8, r8, r7, lsl #8
   1e164:	7b0f      	ldrb	r7, [r1, #12]
   1e166:	7bc9      	ldrb	r1, [r1, #15]
   1e168:	ea48 0807 	orr.w	r8, r8, r7
   1e16c:	ea48 6801 	orr.w	r8, r8, r1, lsl #24
   1e170:	68f1      	ldr	r1, [r6, #12]
   1e172:	ea88 0801 	eor.w	r8, r8, r1

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1e176:	6801      	ldr	r1, [r0, #0]
   1e178:	1049      	asrs	r1, r1, #1
   1e17a:	3901      	subs	r1, #1
   1e17c:	9101      	str	r1, [sp, #4]
    RK = ctx->rk;

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
   1e17e:	f106 0110 	add.w	r1, r6, #16

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1e182:	9801      	ldr	r0, [sp, #4]
   1e184:	4ed2      	ldr	r6, [pc, #840]	; (1e4d0 <mbedtls_aes_decrypt+0x3c8>)
   1e186:	2800      	cmp	r0, #0
   1e188:	468c      	mov	ip, r1
   1e18a:	48d2      	ldr	r0, [pc, #840]	; (1e4d4 <mbedtls_aes_decrypt+0x3cc>)
   1e18c:	f101 0120 	add.w	r1, r1, #32
   1e190:	ea4f 6714 	mov.w	r7, r4, lsr #24
   1e194:	fa5f fe85 	uxtb.w	lr, r5
   1e198:	f340 80c6 	ble.w	1e328 <mbedtls_aes_decrypt+0x220>
   1e19c:	f850 9027 	ldr.w	r9, [r0, r7, lsl #2]
   1e1a0:	f856 702e 	ldr.w	r7, [r6, lr, lsl #2]
    {
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1e1a4:	f8df c334 	ldr.w	ip, [pc, #820]	; 1e4dc <mbedtls_aes_decrypt+0x3d4>
   1e1a8:	f8df e334 	ldr.w	lr, [pc, #820]	; 1e4e0 <mbedtls_aes_decrypt+0x3d8>
   1e1ac:	ea89 0907 	eor.w	r9, r9, r7
   1e1b0:	f851 7c20 	ldr.w	r7, [r1, #-32]
   1e1b4:	ea89 0907 	eor.w	r9, r9, r7
   1e1b8:	f3c8 2707 	ubfx	r7, r8, #8, #8
   1e1bc:	ea4f 6a13 	mov.w	sl, r3, lsr #24
   1e1c0:	f85c 7027 	ldr.w	r7, [ip, r7, lsl #2]
   1e1c4:	f850 a02a 	ldr.w	sl, [r0, sl, lsl #2]
   1e1c8:	ea89 0707 	eor.w	r7, r9, r7
   1e1cc:	f3c3 4907 	ubfx	r9, r3, #16, #8
   1e1d0:	ea4f 6b18 	mov.w	fp, r8, lsr #24
   1e1d4:	f85e 9029 	ldr.w	r9, [lr, r9, lsl #2]
   1e1d8:	f850 b02b 	ldr.w	fp, [r0, fp, lsl #2]
   1e1dc:	ea87 0909 	eor.w	r9, r7, r9
   1e1e0:	b2e7      	uxtb	r7, r4
   1e1e2:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
   1e1e6:	ea8a 0a07 	eor.w	sl, sl, r7
   1e1ea:	f851 7c1c 	ldr.w	r7, [r1, #-28]
   1e1ee:	ea8a 0707 	eor.w	r7, sl, r7
   1e1f2:	f3c5 2a07 	ubfx	sl, r5, #8, #8
   1e1f6:	f85c a02a 	ldr.w	sl, [ip, sl, lsl #2]
   1e1fa:	ea87 070a 	eor.w	r7, r7, sl
   1e1fe:	f3c8 4a07 	ubfx	sl, r8, #16, #8
   1e202:	f85e a02a 	ldr.w	sl, [lr, sl, lsl #2]
   1e206:	ea87 0a0a 	eor.w	sl, r7, sl
   1e20a:	b2df      	uxtb	r7, r3
   1e20c:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1e210:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
   1e214:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   1e218:	ea8b 0b07 	eor.w	fp, fp, r7
   1e21c:	f851 7c18 	ldr.w	r7, [r1, #-24]
   1e220:	ea8b 0707 	eor.w	r7, fp, r7
   1e224:	f3c4 2b07 	ubfx	fp, r4, #8, #8
   1e228:	f3c4 4407 	ubfx	r4, r4, #16, #8
   1e22c:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
   1e230:	ea87 070b 	eor.w	r7, r7, fp
   1e234:	f3c5 4b07 	ubfx	fp, r5, #16, #8
   1e238:	0e2d      	lsrs	r5, r5, #24
   1e23a:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
   1e23e:	f850 5025 	ldr.w	r5, [r0, r5, lsl #2]
   1e242:	ea87 070b 	eor.w	r7, r7, fp
   1e246:	fa5f fb88 	uxtb.w	fp, r8
   1e24a:	f856 802b 	ldr.w	r8, [r6, fp, lsl #2]
   1e24e:	ea85 0808 	eor.w	r8, r5, r8
   1e252:	f851 5c14 	ldr.w	r5, [r1, #-20]
   1e256:	ea88 0505 	eor.w	r5, r8, r5
   1e25a:	405d      	eors	r5, r3
   1e25c:	f85e 3024 	ldr.w	r3, [lr, r4, lsl #2]
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
   1e260:	fa5f f489 	uxtb.w	r4, r9
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
    {
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1e264:	ea85 0803 	eor.w	r8, r5, r3
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
   1e268:	ea4f 631a 	mov.w	r3, sl, lsr #24
   1e26c:	f856 5024 	ldr.w	r5, [r6, r4, lsl #2]
   1e270:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1e274:	f3c8 2407 	ubfx	r4, r8, #8, #8
   1e278:	405d      	eors	r5, r3
   1e27a:	f851 3c10 	ldr.w	r3, [r1, #-16]
   1e27e:	f85c 4024 	ldr.w	r4, [ip, r4, lsl #2]
   1e282:	406b      	eors	r3, r5
   1e284:	4063      	eors	r3, r4
   1e286:	f3c7 4407 	ubfx	r4, r7, #16, #8
   1e28a:	fa5f fb87 	uxtb.w	fp, r7
   1e28e:	f85e 5024 	ldr.w	r5, [lr, r4, lsl #2]
   1e292:	f856 b02b 	ldr.w	fp, [r6, fp, lsl #2]
   1e296:	fa5f f48a 	uxtb.w	r4, sl
   1e29a:	405d      	eors	r5, r3
   1e29c:	0e3b      	lsrs	r3, r7, #24
   1e29e:	f856 4024 	ldr.w	r4, [r6, r4, lsl #2]
   1e2a2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1e2a6:	405c      	eors	r4, r3
   1e2a8:	f851 3c0c 	ldr.w	r3, [r1, #-12]
   1e2ac:	4063      	eors	r3, r4
   1e2ae:	f3c9 2407 	ubfx	r4, r9, #8, #8
   1e2b2:	f3c7 2707 	ubfx	r7, r7, #8, #8
   1e2b6:	f85c 4024 	ldr.w	r4, [ip, r4, lsl #2]
   1e2ba:	4063      	eors	r3, r4
   1e2bc:	f3c8 4407 	ubfx	r4, r8, #16, #8
   1e2c0:	f85e 4024 	ldr.w	r4, [lr, r4, lsl #2]
   1e2c4:	405c      	eors	r4, r3
   1e2c6:	ea4f 6318 	mov.w	r3, r8, lsr #24
   1e2ca:	fa5f f888 	uxtb.w	r8, r8
   1e2ce:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1e2d2:	ea8b 0b03 	eor.w	fp, fp, r3
   1e2d6:	f851 3c08 	ldr.w	r3, [r1, #-8]
   1e2da:	ea8b 0303 	eor.w	r3, fp, r3
   1e2de:	f3ca 2b07 	ubfx	fp, sl, #8, #8
   1e2e2:	f3ca 4a07 	ubfx	sl, sl, #16, #8
   1e2e6:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
   1e2ea:	f856 6028 	ldr.w	r6, [r6, r8, lsl #2]
   1e2ee:	ea83 030b 	eor.w	r3, r3, fp
   1e2f2:	f3c9 4b07 	ubfx	fp, r9, #16, #8
   1e2f6:	ea4f 6919 	mov.w	r9, r9, lsr #24
   1e2fa:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
   1e2fe:	f850 0029 	ldr.w	r0, [r0, r9, lsl #2]
   1e302:	ea86 0800 	eor.w	r8, r6, r0
   1e306:	f851 0c04 	ldr.w	r0, [r1, #-4]
   1e30a:	f85c 6027 	ldr.w	r6, [ip, r7, lsl #2]
   1e30e:	ea88 0000 	eor.w	r0, r8, r0
   1e312:	4070      	eors	r0, r6
   1e314:	f85e 602a 	ldr.w	r6, [lr, sl, lsl #2]
   1e318:	ea80 0806 	eor.w	r8, r0, r6
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1e31c:	9801      	ldr	r0, [sp, #4]
   1e31e:	3801      	subs	r0, #1
    {
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
   1e320:	ea83 030b 	eor.w	r3, r3, fp
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
   1e324:	9001      	str	r0, [sp, #4]
   1e326:	e72c      	b.n	1e182 <mbedtls_aes_decrypt+0x7a>
   1e328:	f850 1027 	ldr.w	r1, [r0, r7, lsl #2]
   1e32c:	f856 e02e 	ldr.w	lr, [r6, lr, lsl #2]
    {
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1e330:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 1e4dc <mbedtls_aes_decrypt+0x3d4>
   1e334:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 1e4e0 <mbedtls_aes_decrypt+0x3d8>
   1e338:	f3c8 2707 	ubfx	r7, r8, #8, #8
   1e33c:	ea8e 0e01 	eor.w	lr, lr, r1
   1e340:	f8dc 1000 	ldr.w	r1, [ip]
   1e344:	f85a 7027 	ldr.w	r7, [sl, r7, lsl #2]
   1e348:	ea8e 0101 	eor.w	r1, lr, r1
   1e34c:	4079      	eors	r1, r7
   1e34e:	f3c3 4707 	ubfx	r7, r3, #16, #8
   1e352:	fa5f fb83 	uxtb.w	fp, r3
   1e356:	f859 7027 	ldr.w	r7, [r9, r7, lsl #2]
   1e35a:	f856 b02b 	ldr.w	fp, [r6, fp, lsl #2]
   1e35e:	ea81 0e07 	eor.w	lr, r1, r7
   1e362:	b2e7      	uxtb	r7, r4
   1e364:	0e19      	lsrs	r1, r3, #24
   1e366:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
   1e36a:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
   1e36e:	404f      	eors	r7, r1
   1e370:	f8dc 1004 	ldr.w	r1, [ip, #4]
   1e374:	4079      	eors	r1, r7
   1e376:	f3c5 2707 	ubfx	r7, r5, #8, #8
   1e37a:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1e37e:	f85a 7027 	ldr.w	r7, [sl, r7, lsl #2]
   1e382:	f85a 3023 	ldr.w	r3, [sl, r3, lsl #2]
   1e386:	4079      	eors	r1, r7
   1e388:	f3c8 4707 	ubfx	r7, r8, #16, #8
   1e38c:	f859 7027 	ldr.w	r7, [r9, r7, lsl #2]
   1e390:	4079      	eors	r1, r7
   1e392:	ea4f 6718 	mov.w	r7, r8, lsr #24
   1e396:	fa5f f888 	uxtb.w	r8, r8
   1e39a:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
   1e39e:	f856 6028 	ldr.w	r6, [r6, r8, lsl #2]
   1e3a2:	ea8b 0b07 	eor.w	fp, fp, r7
   1e3a6:	f8dc 7008 	ldr.w	r7, [ip, #8]
   1e3aa:	ea8b 0707 	eor.w	r7, fp, r7
   1e3ae:	f3c4 2b07 	ubfx	fp, r4, #8, #8
   1e3b2:	f3c4 4407 	ubfx	r4, r4, #16, #8
   1e3b6:	f85a b02b 	ldr.w	fp, [sl, fp, lsl #2]
   1e3ba:	ea87 070b 	eor.w	r7, r7, fp
   1e3be:	f3c5 4b07 	ubfx	fp, r5, #16, #8
   1e3c2:	0e2d      	lsrs	r5, r5, #24
   1e3c4:	f859 b02b 	ldr.w	fp, [r9, fp, lsl #2]
   1e3c8:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
   1e3cc:	ea86 0500 	eor.w	r5, r6, r0
   1e3d0:	f8dc 000c 	ldr.w	r0, [ip, #12]
   1e3d4:	4068      	eors	r0, r5
   1e3d6:	4058      	eors	r0, r3
   1e3d8:	f859 3024 	ldr.w	r3, [r9, r4, lsl #2]

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
   1e3dc:	fa5f f48e 	uxtb.w	r4, lr
    {
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1e3e0:	4058      	eors	r0, r3

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
   1e3e2:	4b3d      	ldr	r3, [pc, #244]	; (1e4d8 <mbedtls_aes_decrypt+0x3d0>)
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
   1e3e4:	0e0d      	lsrs	r5, r1, #24
    }

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
   1e3e6:	5d1e      	ldrb	r6, [r3, r4]
   1e3e8:	f8dc 4010 	ldr.w	r4, [ip, #16]
   1e3ec:	4074      	eors	r4, r6
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
   1e3ee:	5d5e      	ldrb	r6, [r3, r5]

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
   1e3f0:	f3c0 2507 	ubfx	r5, r0, #8, #8
    {
        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
   1e3f4:	ea87 070b 	eor.w	r7, r7, fp
   1e3f8:	ea84 6406 	eor.w	r4, r4, r6, lsl #24

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
   1e3fc:	5d5e      	ldrb	r6, [r3, r5]
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
   1e3fe:	f3c7 4507 	ubfx	r5, r7, #16, #8
   1e402:	ea84 2406 	eor.w	r4, r4, r6, lsl #8
   1e406:	5d5e      	ldrb	r6, [r3, r5]
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    }

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
   1e408:	ea84 4606 	eor.w	r6, r4, r6, lsl #16
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
   1e40c:	b2cc      	uxtb	r4, r1
   1e40e:	5d1d      	ldrb	r5, [r3, r4]
   1e410:	f8dc 4014 	ldr.w	r4, [ip, #20]
   1e414:	406c      	eors	r4, r5
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
   1e416:	0e3d      	lsrs	r5, r7, #24
   1e418:	5d5d      	ldrb	r5, [r3, r5]
   1e41a:	ea84 6405 	eor.w	r4, r4, r5, lsl #24
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
   1e41e:	f3ce 2507 	ubfx	r5, lr, #8, #8
   1e422:	5d5d      	ldrb	r5, [r3, r5]
   1e424:	ea84 2405 	eor.w	r4, r4, r5, lsl #8
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
   1e428:	f3c0 4507 	ubfx	r5, r0, #16, #8
   1e42c:	5d5d      	ldrb	r5, [r3, r5]
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
   1e42e:	ea84 4505 	eor.w	r5, r4, r5, lsl #16
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
   1e432:	b2fc      	uxtb	r4, r7
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
   1e434:	f3c7 2707 	ubfx	r7, r7, #8, #8
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
   1e438:	f813 8004 	ldrb.w	r8, [r3, r4]
   1e43c:	f8dc 4018 	ldr.w	r4, [ip, #24]
   1e440:	ea88 0404 	eor.w	r4, r8, r4
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
   1e444:	ea4f 6810 	mov.w	r8, r0, lsr #24

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
   1e448:	b2c0      	uxtb	r0, r0

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
   1e44a:	f813 8008 	ldrb.w	r8, [r3, r8]
   1e44e:	ea84 6408 	eor.w	r4, r4, r8, lsl #24
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
   1e452:	f3c1 2807 	ubfx	r8, r1, #8, #8
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
   1e456:	f3c1 4107 	ubfx	r1, r1, #16, #8
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
   1e45a:	f813 8008 	ldrb.w	r8, [r3, r8]
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
   1e45e:	5ddf      	ldrb	r7, [r3, r7]
   1e460:	ea84 2408 	eor.w	r4, r4, r8, lsl #8
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
   1e464:	f3ce 4807 	ubfx	r8, lr, #16, #8

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
   1e468:	ea4f 6e1e 	mov.w	lr, lr, lsr #24
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
   1e46c:	f813 8008 	ldrb.w	r8, [r3, r8]

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
   1e470:	f813 e00e 	ldrb.w	lr, [r3, lr]
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
   1e474:	ea84 4408 	eor.w	r4, r4, r8, lsl #16
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
   1e478:	f813 8000 	ldrb.w	r8, [r3, r0]
   1e47c:	f8dc 001c 	ldr.w	r0, [ip, #28]
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
   1e480:	5c5b      	ldrb	r3, [r3, r1]
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
   1e482:	7016      	strb	r6, [r2, #0]
   1e484:	0a31      	lsrs	r1, r6, #8
   1e486:	7051      	strb	r1, [r2, #1]
   1e488:	0c31      	lsrs	r1, r6, #16
   1e48a:	ea88 0000 	eor.w	r0, r8, r0
   1e48e:	7091      	strb	r1, [r2, #2]
    PUT_UINT32_LE( X1, output,  4 );
   1e490:	0a29      	lsrs	r1, r5, #8
   1e492:	ea80 600e 	eor.w	r0, r0, lr, lsl #24
   1e496:	7151      	strb	r1, [r2, #5]
   1e498:	0c29      	lsrs	r1, r5, #16
   1e49a:	ea80 2007 	eor.w	r0, r0, r7, lsl #8
   1e49e:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
   1e4a0:	0a21      	lsrs	r1, r4, #8
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
   1e4a2:	ea80 4303 	eor.w	r3, r0, r3, lsl #16
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
    PUT_UINT32_LE( X1, output,  4 );
    PUT_UINT32_LE( X2, output,  8 );
   1e4a6:	7251      	strb	r1, [r2, #9]
   1e4a8:	0c21      	lsrs	r1, r4, #16
   1e4aa:	7291      	strb	r1, [r2, #10]
    PUT_UINT32_LE( X3, output, 12 );
   1e4ac:	0a19      	lsrs	r1, r3, #8
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
   1e4ae:	0e36      	lsrs	r6, r6, #24
    PUT_UINT32_LE( X1, output,  4 );
   1e4b0:	7115      	strb	r5, [r2, #4]
    PUT_UINT32_LE( X2, output,  8 );
   1e4b2:	7214      	strb	r4, [r2, #8]
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
    PUT_UINT32_LE( X1, output,  4 );
   1e4b4:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X2, output,  8 );
   1e4b6:	0e24      	lsrs	r4, r4, #24
    PUT_UINT32_LE( X3, output, 12 );
   1e4b8:	7313      	strb	r3, [r2, #12]
   1e4ba:	7351      	strb	r1, [r2, #13]
   1e4bc:	0c19      	lsrs	r1, r3, #16
   1e4be:	0e1b      	lsrs	r3, r3, #24
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
   1e4c0:	70d6      	strb	r6, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
   1e4c2:	71d5      	strb	r5, [r2, #7]
    PUT_UINT32_LE( X2, output,  8 );
   1e4c4:	72d4      	strb	r4, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
   1e4c6:	7391      	strb	r1, [r2, #14]
   1e4c8:	73d3      	strb	r3, [r2, #15]
}
   1e4ca:	b003      	add	sp, #12
   1e4cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e4d0:	00020d4c 	.word	0x00020d4c
   1e4d4:	0002194c 	.word	0x0002194c
   1e4d8:	00022d74 	.word	0x00022d74
   1e4dc:	0002114c 	.word	0x0002114c
   1e4e0:	0002154c 	.word	0x0002154c

0001e4e4 <mbedtls_aes_crypt_ecb>:
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_ENCRYPT )
   1e4e4:	2901      	cmp	r1, #1
 */
int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
                    int mode,
                    const unsigned char input[16],
                    unsigned char output[16] )
{
   1e4e6:	b508      	push	{r3, lr}
        //
    }
#endif

    if( mode == MBEDTLS_AES_ENCRYPT )
        mbedtls_aes_encrypt( ctx, input, output );
   1e4e8:	4611      	mov	r1, r2
   1e4ea:	461a      	mov	r2, r3
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_ENCRYPT )
   1e4ec:	d102      	bne.n	1e4f4 <mbedtls_aes_crypt_ecb+0x10>
        mbedtls_aes_encrypt( ctx, input, output );
   1e4ee:	f7ff fc27 	bl	1dd40 <mbedtls_aes_encrypt>
   1e4f2:	e001      	b.n	1e4f8 <mbedtls_aes_crypt_ecb+0x14>
    else
        mbedtls_aes_decrypt( ctx, input, output );
   1e4f4:	f7ff fe08 	bl	1e108 <mbedtls_aes_decrypt>

    return( 0 );
}
   1e4f8:	2000      	movs	r0, #0
   1e4fa:	bd08      	pop	{r3, pc}

0001e4fc <os_sem_init>:
 *      OS_OK               no error.
 */
os_error_t
os_sem_init(struct os_sem *sem, uint16_t tokens)
{
    if (!sem) {
   1e4fc:	b120      	cbz	r0, 1e508 <os_sem_init+0xc>
        return OS_INVALID_PARM;
    }

    sem->sem_tokens = tokens;
    SLIST_FIRST(&sem->sem_head) = NULL;
   1e4fe:	2300      	movs	r3, #0
{
    if (!sem) {
        return OS_INVALID_PARM;
    }

    sem->sem_tokens = tokens;
   1e500:	80c1      	strh	r1, [r0, #6]
    SLIST_FIRST(&sem->sem_head) = NULL;
   1e502:	6003      	str	r3, [r0, #0]

    return OS_OK;
   1e504:	4618      	mov	r0, r3
   1e506:	4770      	bx	lr
 */
os_error_t
os_sem_init(struct os_sem *sem, uint16_t tokens)
{
    if (!sem) {
        return OS_INVALID_PARM;
   1e508:	2003      	movs	r0, #3

    sem->sem_tokens = tokens;
    SLIST_FIRST(&sem->sem_head) = NULL;

    return OS_OK;
}
   1e50a:	4770      	bx	lr

0001e50c <os_sem_release>:
 *      OS_INVALID_PARM Semaphore passed in was NULL.
 *      OS_OK No error
 */
os_error_t
os_sem_release(struct os_sem *sem)
{
   1e50c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_sr_t sr;
    struct os_task *current;
    struct os_task *rdy;

    /* OS must be started to release semaphores */ 
    if (!g_os_started) {
   1e50e:	4b16      	ldr	r3, [pc, #88]	; (1e568 <os_sem_release+0x5c>)
   1e510:	681b      	ldr	r3, [r3, #0]
 *      OS_INVALID_PARM Semaphore passed in was NULL.
 *      OS_OK No error
 */
os_error_t
os_sem_release(struct os_sem *sem)
{
   1e512:	4604      	mov	r4, r0
    os_sr_t sr;
    struct os_task *current;
    struct os_task *rdy;

    /* OS must be started to release semaphores */ 
    if (!g_os_started) {
   1e514:	b31b      	cbz	r3, 1e55e <os_sem_release+0x52>
        return (OS_NOT_STARTED);
    }

    /* Check for valid semaphore */
    if (!sem) {
   1e516:	b320      	cbz	r0, 1e562 <os_sem_release+0x56>
        return OS_INVALID_PARM;
    }

    /* Get current task */
    resched = 0;
    current = os_sched_get_current_task();
   1e518:	f7eb ffea 	bl	a4f0 <os_sched_get_current_task>
   1e51c:	4607      	mov	r7, r0

    OS_ENTER_CRITICAL(sr);
   1e51e:	f7eb f9ff 	bl	9920 <os_arch_save_sr>

    /* Check if tasks are waiting for the semaphore */
    rdy = SLIST_FIRST(&sem->sem_head);
   1e522:	6825      	ldr	r5, [r4, #0]

    /* Get current task */
    resched = 0;
    current = os_sched_get_current_task();

    OS_ENTER_CRITICAL(sr);
   1e524:	4606      	mov	r6, r0

    /* Check if tasks are waiting for the semaphore */
    rdy = SLIST_FIRST(&sem->sem_head);
    if (rdy) {
   1e526:	b16d      	cbz	r5, 1e544 <os_sem_release+0x38>
        /* Clear flag that we are waiting on the semaphore; wake up task */
        rdy->t_flags &= ~OS_TASK_FLAG_SEM_WAIT;
   1e528:	7beb      	ldrb	r3, [r5, #15]
   1e52a:	f023 0302 	bic.w	r3, r3, #2
   1e52e:	73eb      	strb	r3, [r5, #15]
        os_sched_wakeup(rdy);
   1e530:	4628      	mov	r0, r5
   1e532:	f7ec f83b 	bl	a5ac <os_sched_wakeup>

        /* Schedule if waiting task higher priority */
        if (current->t_prio > rdy->t_prio) {
   1e536:	7b7b      	ldrb	r3, [r7, #13]
   1e538:	7b68      	ldrb	r0, [r5, #13]
   1e53a:	4283      	cmp	r3, r0
   1e53c:	bf94      	ite	ls
   1e53e:	2400      	movls	r4, #0
   1e540:	2401      	movhi	r4, #1
   1e542:	e003      	b.n	1e54c <os_sem_release+0x40>
            resched = 1;
        }
    } else {
        /* Add to the number of tokens */
        sem->sem_tokens++;
   1e544:	88e3      	ldrh	r3, [r4, #6]
   1e546:	3301      	adds	r3, #1
   1e548:	80e3      	strh	r3, [r4, #6]
    if (!sem) {
        return OS_INVALID_PARM;
    }

    /* Get current task */
    resched = 0;
   1e54a:	462c      	mov	r4, r5
    } else {
        /* Add to the number of tokens */
        sem->sem_tokens++;
    }

    OS_EXIT_CRITICAL(sr);
   1e54c:	4630      	mov	r0, r6
   1e54e:	f7eb f9ed 	bl	992c <os_arch_restore_sr>

    /* Re-schedule if needed */
    if (resched) {
   1e552:	b114      	cbz	r4, 1e55a <os_sem_release+0x4e>
        os_sched(rdy);
   1e554:	4628      	mov	r0, r5
   1e556:	f7eb ffd7 	bl	a508 <os_sched>
    }

    return OS_OK;
   1e55a:	2000      	movs	r0, #0
   1e55c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    struct os_task *current;
    struct os_task *rdy;

    /* OS must be started to release semaphores */ 
    if (!g_os_started) {
        return (OS_NOT_STARTED);
   1e55e:	2009      	movs	r0, #9
   1e560:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Check for valid semaphore */
    if (!sem) {
        return OS_INVALID_PARM;
   1e562:	2003      	movs	r0, #3
   1e564:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e566:	bf00      	nop
   1e568:	20002f28 	.word	0x20002f28

0001e56c <os_sem_pend>:
 *      OS_TIMEOUT          Semaphore was owned by another task and timeout=0
 *      OS_OK               no error.
 */ 
os_error_t
os_sem_pend(struct os_sem *sem, uint32_t timeout)
{
   1e56c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    struct os_task *current;
    struct os_task *entry;
    struct os_task *last;

    /* Check if OS is started */
    if (!g_os_started) {
   1e56e:	4b2a      	ldr	r3, [pc, #168]	; (1e618 <os_sem_pend+0xac>)
   1e570:	681b      	ldr	r3, [r3, #0]
 *      OS_TIMEOUT          Semaphore was owned by another task and timeout=0
 *      OS_OK               no error.
 */ 
os_error_t
os_sem_pend(struct os_sem *sem, uint32_t timeout)
{
   1e572:	4605      	mov	r5, r0
   1e574:	460e      	mov	r6, r1
    struct os_task *current;
    struct os_task *entry;
    struct os_task *last;

    /* Check if OS is started */
    if (!g_os_started) {
   1e576:	2b00      	cmp	r3, #0
   1e578:	d047      	beq.n	1e60a <os_sem_pend+0x9e>
        return (OS_NOT_STARTED);
    }

    /* Check for valid semaphore */
    if (!sem) {
   1e57a:	2800      	cmp	r0, #0
   1e57c:	d047      	beq.n	1e60e <os_sem_pend+0xa2>
        return OS_INVALID_PARM;
    }

    /* Assume we dont have to put task to sleep; get current task */
    sched = 0;
    current = os_sched_get_current_task();
   1e57e:	f7eb ffb7 	bl	a4f0 <os_sched_get_current_task>
   1e582:	4604      	mov	r4, r0

    OS_ENTER_CRITICAL(sr);
   1e584:	f7eb f9cc 	bl	9920 <os_arch_save_sr>

    /* 
     * If there is a token available, take it. If no token, either return
     * with error if timeout was 0 or put this task to sleep.
     */
    if (sem->sem_tokens != 0) {
   1e588:	88ea      	ldrh	r2, [r5, #6]

    /* Assume we dont have to put task to sleep; get current task */
    sched = 0;
    current = os_sched_get_current_task();

    OS_ENTER_CRITICAL(sr);
   1e58a:	4607      	mov	r7, r0

    /* 
     * If there is a token available, take it. If no token, either return
     * with error if timeout was 0 or put this task to sleep.
     */
    if (sem->sem_tokens != 0) {
   1e58c:	b11a      	cbz	r2, 1e596 <os_sem_pend+0x2a>
        sem->sem_tokens--;
   1e58e:	3a01      	subs	r2, #1
   1e590:	80ea      	strh	r2, [r5, #6]
    if (!sem) {
        return OS_INVALID_PARM;
    }

    /* Assume we dont have to put task to sleep; get current task */
    sched = 0;
   1e592:	2600      	movs	r6, #0
   1e594:	e01f      	b.n	1e5d6 <os_sem_pend+0x6a>
     * with error if timeout was 0 or put this task to sleep.
     */
    if (sem->sem_tokens != 0) {
        sem->sem_tokens--;
        rc = OS_OK;
    } else if (timeout == 0) {
   1e596:	b306      	cbz	r6, 1e5da <os_sem_pend+0x6e>
        /* Silence gcc maybe-uninitialized warning. */
        rc = OS_OK;

        /* Link current task to tasks waiting for semaphore */
        current->t_obj = sem; 
        current->t_flags |= OS_TASK_FLAG_SEM_WAIT;
   1e598:	7be3      	ldrb	r3, [r4, #15]
    } else {
        /* Silence gcc maybe-uninitialized warning. */
        rc = OS_OK;

        /* Link current task to tasks waiting for semaphore */
        current->t_obj = sem; 
   1e59a:	61e5      	str	r5, [r4, #28]
        current->t_flags |= OS_TASK_FLAG_SEM_WAIT;
   1e59c:	f043 0302 	orr.w	r3, r3, #2
   1e5a0:	73e3      	strb	r3, [r4, #15]
        last = NULL;
        if (!SLIST_EMPTY(&sem->sem_head)) {
   1e5a2:	6829      	ldr	r1, [r5, #0]
   1e5a4:	b181      	cbz	r1, 1e5c8 <os_sem_pend+0x5c>
            /* Insert in priority order */
            SLIST_FOREACH(entry, &sem->sem_head, t_obj_list) {
                if (current->t_prio < entry->t_prio) { 
   1e5a6:	f894 e00d 	ldrb.w	lr, [r4, #13]
   1e5aa:	460b      	mov	r3, r1
   1e5ac:	7b58      	ldrb	r0, [r3, #13]
   1e5ae:	4570      	cmp	r0, lr
   1e5b0:	d804      	bhi.n	1e5bc <os_sem_pend+0x50>
        current->t_obj = sem; 
        current->t_flags |= OS_TASK_FLAG_SEM_WAIT;
        last = NULL;
        if (!SLIST_EMPTY(&sem->sem_head)) {
            /* Insert in priority order */
            SLIST_FOREACH(entry, &sem->sem_head, t_obj_list) {
   1e5b2:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
   1e5b4:	461a      	mov	r2, r3
   1e5b6:	b118      	cbz	r0, 1e5c0 <os_sem_pend+0x54>
   1e5b8:	4603      	mov	r3, r0
   1e5ba:	e7f7      	b.n	1e5ac <os_sem_pend+0x40>
                }
                last = entry;
            }
        }

        if (last) {
   1e5bc:	4613      	mov	r3, r2
   1e5be:	b11a      	cbz	r2, 1e5c8 <os_sem_pend+0x5c>
            SLIST_INSERT_AFTER(last, current, t_obj_list);
   1e5c0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   1e5c2:	64e2      	str	r2, [r4, #76]	; 0x4c
   1e5c4:	64dc      	str	r4, [r3, #76]	; 0x4c
   1e5c6:	e001      	b.n	1e5cc <os_sem_pend+0x60>
        } else {
            SLIST_INSERT_HEAD(&sem->sem_head, current, t_obj_list);
   1e5c8:	64e1      	str	r1, [r4, #76]	; 0x4c
   1e5ca:	602c      	str	r4, [r5, #0]
        }

        /* We will put this task to sleep */
        sched = 1;
        os_sched_sleep(current, timeout);
   1e5cc:	4631      	mov	r1, r6
   1e5ce:	4620      	mov	r0, r4
   1e5d0:	f7eb ffb2 	bl	a538 <os_sched_sleep>
        } else {
            SLIST_INSERT_HEAD(&sem->sem_head, current, t_obj_list);
        }

        /* We will put this task to sleep */
        sched = 1;
   1e5d4:	2601      	movs	r6, #1
        rc = OS_OK;
    } else if (timeout == 0) {
        rc = OS_TIMEOUT;
    } else {
        /* Silence gcc maybe-uninitialized warning. */
        rc = OS_OK;
   1e5d6:	2500      	movs	r5, #0
   1e5d8:	e000      	b.n	1e5dc <os_sem_pend+0x70>
     */
    if (sem->sem_tokens != 0) {
        sem->sem_tokens--;
        rc = OS_OK;
    } else if (timeout == 0) {
        rc = OS_TIMEOUT;
   1e5da:	2506      	movs	r5, #6
        /* We will put this task to sleep */
        sched = 1;
        os_sched_sleep(current, timeout);
    }

    OS_EXIT_CRITICAL(sr);
   1e5dc:	4638      	mov	r0, r7
   1e5de:	f7eb f9a5 	bl	992c <os_arch_restore_sr>

    if (sched) {
   1e5e2:	b1b6      	cbz	r6, 1e612 <os_sem_pend+0xa6>
        os_sched(NULL);
   1e5e4:	2000      	movs	r0, #0
   1e5e6:	f7eb ff8f 	bl	a508 <os_sched>
        /* Check if we timed out or got the semaphore */
        if (current->t_flags & OS_TASK_FLAG_SEM_WAIT) {
   1e5ea:	7be3      	ldrb	r3, [r4, #15]
   1e5ec:	f003 0302 	and.w	r3, r3, #2
   1e5f0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   1e5f4:	b173      	cbz	r3, 1e614 <os_sem_pend+0xa8>
            OS_ENTER_CRITICAL(sr);
   1e5f6:	f7eb f993 	bl	9920 <os_arch_save_sr>
            current->t_flags &= ~OS_TASK_FLAG_SEM_WAIT;
   1e5fa:	7be3      	ldrb	r3, [r4, #15]
   1e5fc:	f023 0302 	bic.w	r3, r3, #2
   1e600:	73e3      	strb	r3, [r4, #15]
            OS_EXIT_CRITICAL(sr);
   1e602:	f7eb f993 	bl	992c <os_arch_restore_sr>
            rc = OS_TIMEOUT;
   1e606:	2006      	movs	r0, #6
   1e608:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    struct os_task *entry;
    struct os_task *last;

    /* Check if OS is started */
    if (!g_os_started) {
        return (OS_NOT_STARTED);
   1e60a:	2009      	movs	r0, #9
   1e60c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Check for valid semaphore */
    if (!sem) {
        return OS_INVALID_PARM;
   1e60e:	2003      	movs	r0, #3
   1e610:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e612:	4628      	mov	r0, r5
            rc = OS_OK; 
        }
    }

    return rc;
}
   1e614:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e616:	bf00      	nop
   1e618:	20002f28 	.word	0x20002f28

0001e61c <bsp_uart_config>:

const struct nrf52_uart_cfg *
bsp_uart_config(void)
{
    return &uart_cfg;
}
   1e61c:	4800      	ldr	r0, [pc, #0]	; (1e620 <bsp_uart_config+0x4>)
   1e61e:	4770      	bx	lr
   1e620:	00022e74 	.word	0x00022e74

0001e624 <__aeabi_uldivmod>:
   1e624:	b953      	cbnz	r3, 1e63c <__aeabi_uldivmod+0x18>
   1e626:	b94a      	cbnz	r2, 1e63c <__aeabi_uldivmod+0x18>
   1e628:	2900      	cmp	r1, #0
   1e62a:	bf08      	it	eq
   1e62c:	2800      	cmpeq	r0, #0
   1e62e:	bf1c      	itt	ne
   1e630:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1e634:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   1e638:	f000 b83c 	b.w	1e6b4 <__aeabi_idiv0>
   1e63c:	b082      	sub	sp, #8
   1e63e:	46ec      	mov	ip, sp
   1e640:	e92d 5000 	stmdb	sp!, {ip, lr}
   1e644:	f000 f81e 	bl	1e684 <__gnu_uldivmod_helper>
   1e648:	f8dd e004 	ldr.w	lr, [sp, #4]
   1e64c:	b002      	add	sp, #8
   1e64e:	bc0c      	pop	{r2, r3}
   1e650:	4770      	bx	lr
   1e652:	bf00      	nop

0001e654 <__gnu_ldivmod_helper>:
   1e654:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e658:	9c06      	ldr	r4, [sp, #24]
   1e65a:	4615      	mov	r5, r2
   1e65c:	4606      	mov	r6, r0
   1e65e:	460f      	mov	r7, r1
   1e660:	4698      	mov	r8, r3
   1e662:	f000 f829 	bl	1e6b8 <__divdi3>
   1e666:	fb05 f301 	mul.w	r3, r5, r1
   1e66a:	fb00 3808 	mla	r8, r0, r8, r3
   1e66e:	fba5 2300 	umull	r2, r3, r5, r0
   1e672:	1ab2      	subs	r2, r6, r2
   1e674:	4443      	add	r3, r8
   1e676:	eb67 0303 	sbc.w	r3, r7, r3
   1e67a:	e9c4 2300 	strd	r2, r3, [r4]
   1e67e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e682:	bf00      	nop

0001e684 <__gnu_uldivmod_helper>:
   1e684:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e688:	9c06      	ldr	r4, [sp, #24]
   1e68a:	4690      	mov	r8, r2
   1e68c:	4606      	mov	r6, r0
   1e68e:	460f      	mov	r7, r1
   1e690:	461d      	mov	r5, r3
   1e692:	f000 f95f 	bl	1e954 <__udivdi3>
   1e696:	fb00 f505 	mul.w	r5, r0, r5
   1e69a:	fba0 2308 	umull	r2, r3, r0, r8
   1e69e:	fb08 5501 	mla	r5, r8, r1, r5
   1e6a2:	1ab2      	subs	r2, r6, r2
   1e6a4:	442b      	add	r3, r5
   1e6a6:	eb67 0303 	sbc.w	r3, r7, r3
   1e6aa:	e9c4 2300 	strd	r2, r3, [r4]
   1e6ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e6b2:	bf00      	nop

0001e6b4 <__aeabi_idiv0>:
   1e6b4:	4770      	bx	lr
   1e6b6:	bf00      	nop

0001e6b8 <__divdi3>:
   1e6b8:	2900      	cmp	r1, #0
   1e6ba:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1e6be:	f2c0 80a6 	blt.w	1e80e <__divdi3+0x156>
   1e6c2:	2600      	movs	r6, #0
   1e6c4:	2b00      	cmp	r3, #0
   1e6c6:	f2c0 809c 	blt.w	1e802 <__divdi3+0x14a>
   1e6ca:	4688      	mov	r8, r1
   1e6cc:	4694      	mov	ip, r2
   1e6ce:	469e      	mov	lr, r3
   1e6d0:	4615      	mov	r5, r2
   1e6d2:	4604      	mov	r4, r0
   1e6d4:	460f      	mov	r7, r1
   1e6d6:	2b00      	cmp	r3, #0
   1e6d8:	d13d      	bne.n	1e756 <__divdi3+0x9e>
   1e6da:	428a      	cmp	r2, r1
   1e6dc:	d959      	bls.n	1e792 <__divdi3+0xda>
   1e6de:	fab2 f382 	clz	r3, r2
   1e6e2:	b13b      	cbz	r3, 1e6f4 <__divdi3+0x3c>
   1e6e4:	f1c3 0220 	rsb	r2, r3, #32
   1e6e8:	409f      	lsls	r7, r3
   1e6ea:	fa20 f202 	lsr.w	r2, r0, r2
   1e6ee:	409d      	lsls	r5, r3
   1e6f0:	4317      	orrs	r7, r2
   1e6f2:	409c      	lsls	r4, r3
   1e6f4:	0c29      	lsrs	r1, r5, #16
   1e6f6:	0c22      	lsrs	r2, r4, #16
   1e6f8:	fbb7 fef1 	udiv	lr, r7, r1
   1e6fc:	b2a8      	uxth	r0, r5
   1e6fe:	fb01 771e 	mls	r7, r1, lr, r7
   1e702:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
   1e706:	fb00 f30e 	mul.w	r3, r0, lr
   1e70a:	42bb      	cmp	r3, r7
   1e70c:	d90a      	bls.n	1e724 <__divdi3+0x6c>
   1e70e:	197f      	adds	r7, r7, r5
   1e710:	f10e 32ff 	add.w	r2, lr, #4294967295	; 0xffffffff
   1e714:	f080 8105 	bcs.w	1e922 <__divdi3+0x26a>
   1e718:	42bb      	cmp	r3, r7
   1e71a:	f240 8102 	bls.w	1e922 <__divdi3+0x26a>
   1e71e:	f1ae 0e02 	sub.w	lr, lr, #2
   1e722:	442f      	add	r7, r5
   1e724:	1aff      	subs	r7, r7, r3
   1e726:	b2a4      	uxth	r4, r4
   1e728:	fbb7 f3f1 	udiv	r3, r7, r1
   1e72c:	fb01 7713 	mls	r7, r1, r3, r7
   1e730:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
   1e734:	fb00 f003 	mul.w	r0, r0, r3
   1e738:	42b8      	cmp	r0, r7
   1e73a:	d908      	bls.n	1e74e <__divdi3+0x96>
   1e73c:	197f      	adds	r7, r7, r5
   1e73e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
   1e742:	f080 80f0 	bcs.w	1e926 <__divdi3+0x26e>
   1e746:	42b8      	cmp	r0, r7
   1e748:	f240 80ed 	bls.w	1e926 <__divdi3+0x26e>
   1e74c:	3b02      	subs	r3, #2
   1e74e:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
   1e752:	2200      	movs	r2, #0
   1e754:	e003      	b.n	1e75e <__divdi3+0xa6>
   1e756:	428b      	cmp	r3, r1
   1e758:	d90f      	bls.n	1e77a <__divdi3+0xc2>
   1e75a:	2200      	movs	r2, #0
   1e75c:	4613      	mov	r3, r2
   1e75e:	1c34      	adds	r4, r6, #0
   1e760:	bf18      	it	ne
   1e762:	2401      	movne	r4, #1
   1e764:	4260      	negs	r0, r4
   1e766:	f04f 0500 	mov.w	r5, #0
   1e76a:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
   1e76e:	4058      	eors	r0, r3
   1e770:	4051      	eors	r1, r2
   1e772:	1900      	adds	r0, r0, r4
   1e774:	4169      	adcs	r1, r5
   1e776:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1e77a:	fab3 f283 	clz	r2, r3
   1e77e:	2a00      	cmp	r2, #0
   1e780:	f040 8086 	bne.w	1e890 <__divdi3+0x1d8>
   1e784:	428b      	cmp	r3, r1
   1e786:	d302      	bcc.n	1e78e <__divdi3+0xd6>
   1e788:	4584      	cmp	ip, r0
   1e78a:	f200 80db 	bhi.w	1e944 <__divdi3+0x28c>
   1e78e:	2301      	movs	r3, #1
   1e790:	e7e5      	b.n	1e75e <__divdi3+0xa6>
   1e792:	b912      	cbnz	r2, 1e79a <__divdi3+0xe2>
   1e794:	2301      	movs	r3, #1
   1e796:	fbb3 f5f2 	udiv	r5, r3, r2
   1e79a:	fab5 f085 	clz	r0, r5
   1e79e:	2800      	cmp	r0, #0
   1e7a0:	d13b      	bne.n	1e81a <__divdi3+0x162>
   1e7a2:	1b78      	subs	r0, r7, r5
   1e7a4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1e7a8:	fa1f fc85 	uxth.w	ip, r5
   1e7ac:	2201      	movs	r2, #1
   1e7ae:	fbb0 f8fe 	udiv	r8, r0, lr
   1e7b2:	0c21      	lsrs	r1, r4, #16
   1e7b4:	fb0e 0718 	mls	r7, lr, r8, r0
   1e7b8:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
   1e7bc:	fb0c f308 	mul.w	r3, ip, r8
   1e7c0:	42bb      	cmp	r3, r7
   1e7c2:	d907      	bls.n	1e7d4 <__divdi3+0x11c>
   1e7c4:	197f      	adds	r7, r7, r5
   1e7c6:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
   1e7ca:	d202      	bcs.n	1e7d2 <__divdi3+0x11a>
   1e7cc:	42bb      	cmp	r3, r7
   1e7ce:	f200 80bd 	bhi.w	1e94c <__divdi3+0x294>
   1e7d2:	4688      	mov	r8, r1
   1e7d4:	1aff      	subs	r7, r7, r3
   1e7d6:	b2a4      	uxth	r4, r4
   1e7d8:	fbb7 f3fe 	udiv	r3, r7, lr
   1e7dc:	fb0e 7713 	mls	r7, lr, r3, r7
   1e7e0:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
   1e7e4:	fb0c fc03 	mul.w	ip, ip, r3
   1e7e8:	45bc      	cmp	ip, r7
   1e7ea:	d907      	bls.n	1e7fc <__divdi3+0x144>
   1e7ec:	197f      	adds	r7, r7, r5
   1e7ee:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
   1e7f2:	d202      	bcs.n	1e7fa <__divdi3+0x142>
   1e7f4:	45bc      	cmp	ip, r7
   1e7f6:	f200 80a7 	bhi.w	1e948 <__divdi3+0x290>
   1e7fa:	460b      	mov	r3, r1
   1e7fc:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   1e800:	e7ad      	b.n	1e75e <__divdi3+0xa6>
   1e802:	4252      	negs	r2, r2
   1e804:	ea6f 0606 	mvn.w	r6, r6
   1e808:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1e80c:	e75d      	b.n	1e6ca <__divdi3+0x12>
   1e80e:	4240      	negs	r0, r0
   1e810:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1e814:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   1e818:	e754      	b.n	1e6c4 <__divdi3+0xc>
   1e81a:	f1c0 0220 	rsb	r2, r0, #32
   1e81e:	fa24 f102 	lsr.w	r1, r4, r2
   1e822:	fa07 f300 	lsl.w	r3, r7, r0
   1e826:	4085      	lsls	r5, r0
   1e828:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1e82c:	40d7      	lsrs	r7, r2
   1e82e:	4319      	orrs	r1, r3
   1e830:	fbb7 f2fe 	udiv	r2, r7, lr
   1e834:	0c0b      	lsrs	r3, r1, #16
   1e836:	fb0e 7712 	mls	r7, lr, r2, r7
   1e83a:	fa1f fc85 	uxth.w	ip, r5
   1e83e:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
   1e842:	fb0c f702 	mul.w	r7, ip, r2
   1e846:	429f      	cmp	r7, r3
   1e848:	fa04 f400 	lsl.w	r4, r4, r0
   1e84c:	d907      	bls.n	1e85e <__divdi3+0x1a6>
   1e84e:	195b      	adds	r3, r3, r5
   1e850:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
   1e854:	d274      	bcs.n	1e940 <__divdi3+0x288>
   1e856:	429f      	cmp	r7, r3
   1e858:	d972      	bls.n	1e940 <__divdi3+0x288>
   1e85a:	3a02      	subs	r2, #2
   1e85c:	442b      	add	r3, r5
   1e85e:	1bdf      	subs	r7, r3, r7
   1e860:	b289      	uxth	r1, r1
   1e862:	fbb7 f8fe 	udiv	r8, r7, lr
   1e866:	fb0e 7318 	mls	r3, lr, r8, r7
   1e86a:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
   1e86e:	fb0c f708 	mul.w	r7, ip, r8
   1e872:	429f      	cmp	r7, r3
   1e874:	d908      	bls.n	1e888 <__divdi3+0x1d0>
   1e876:	195b      	adds	r3, r3, r5
   1e878:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
   1e87c:	d25c      	bcs.n	1e938 <__divdi3+0x280>
   1e87e:	429f      	cmp	r7, r3
   1e880:	d95a      	bls.n	1e938 <__divdi3+0x280>
   1e882:	f1a8 0802 	sub.w	r8, r8, #2
   1e886:	442b      	add	r3, r5
   1e888:	1bd8      	subs	r0, r3, r7
   1e88a:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
   1e88e:	e78e      	b.n	1e7ae <__divdi3+0xf6>
   1e890:	f1c2 0320 	rsb	r3, r2, #32
   1e894:	fa2c f103 	lsr.w	r1, ip, r3
   1e898:	fa0e fe02 	lsl.w	lr, lr, r2
   1e89c:	fa20 f703 	lsr.w	r7, r0, r3
   1e8a0:	ea41 0e0e 	orr.w	lr, r1, lr
   1e8a4:	fa08 f002 	lsl.w	r0, r8, r2
   1e8a8:	fa28 f103 	lsr.w	r1, r8, r3
   1e8ac:	ea4f 451e 	mov.w	r5, lr, lsr #16
   1e8b0:	4338      	orrs	r0, r7
   1e8b2:	fbb1 f8f5 	udiv	r8, r1, r5
   1e8b6:	0c03      	lsrs	r3, r0, #16
   1e8b8:	fb05 1118 	mls	r1, r5, r8, r1
   1e8bc:	fa1f f78e 	uxth.w	r7, lr
   1e8c0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   1e8c4:	fb07 f308 	mul.w	r3, r7, r8
   1e8c8:	428b      	cmp	r3, r1
   1e8ca:	fa0c fc02 	lsl.w	ip, ip, r2
   1e8ce:	d909      	bls.n	1e8e4 <__divdi3+0x22c>
   1e8d0:	eb11 010e 	adds.w	r1, r1, lr
   1e8d4:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
   1e8d8:	d230      	bcs.n	1e93c <__divdi3+0x284>
   1e8da:	428b      	cmp	r3, r1
   1e8dc:	d92e      	bls.n	1e93c <__divdi3+0x284>
   1e8de:	f1a8 0802 	sub.w	r8, r8, #2
   1e8e2:	4471      	add	r1, lr
   1e8e4:	1ac9      	subs	r1, r1, r3
   1e8e6:	b280      	uxth	r0, r0
   1e8e8:	fbb1 f3f5 	udiv	r3, r1, r5
   1e8ec:	fb05 1113 	mls	r1, r5, r3, r1
   1e8f0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   1e8f4:	fb07 f703 	mul.w	r7, r7, r3
   1e8f8:	428f      	cmp	r7, r1
   1e8fa:	d908      	bls.n	1e90e <__divdi3+0x256>
   1e8fc:	eb11 010e 	adds.w	r1, r1, lr
   1e900:	f103 30ff 	add.w	r0, r3, #4294967295	; 0xffffffff
   1e904:	d216      	bcs.n	1e934 <__divdi3+0x27c>
   1e906:	428f      	cmp	r7, r1
   1e908:	d914      	bls.n	1e934 <__divdi3+0x27c>
   1e90a:	3b02      	subs	r3, #2
   1e90c:	4471      	add	r1, lr
   1e90e:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   1e912:	1bc9      	subs	r1, r1, r7
   1e914:	fba3 890c 	umull	r8, r9, r3, ip
   1e918:	4549      	cmp	r1, r9
   1e91a:	d309      	bcc.n	1e930 <__divdi3+0x278>
   1e91c:	d005      	beq.n	1e92a <__divdi3+0x272>
   1e91e:	2200      	movs	r2, #0
   1e920:	e71d      	b.n	1e75e <__divdi3+0xa6>
   1e922:	4696      	mov	lr, r2
   1e924:	e6fe      	b.n	1e724 <__divdi3+0x6c>
   1e926:	4613      	mov	r3, r2
   1e928:	e711      	b.n	1e74e <__divdi3+0x96>
   1e92a:	4094      	lsls	r4, r2
   1e92c:	4544      	cmp	r4, r8
   1e92e:	d2f6      	bcs.n	1e91e <__divdi3+0x266>
   1e930:	3b01      	subs	r3, #1
   1e932:	e7f4      	b.n	1e91e <__divdi3+0x266>
   1e934:	4603      	mov	r3, r0
   1e936:	e7ea      	b.n	1e90e <__divdi3+0x256>
   1e938:	4688      	mov	r8, r1
   1e93a:	e7a5      	b.n	1e888 <__divdi3+0x1d0>
   1e93c:	46c8      	mov	r8, r9
   1e93e:	e7d1      	b.n	1e8e4 <__divdi3+0x22c>
   1e940:	4602      	mov	r2, r0
   1e942:	e78c      	b.n	1e85e <__divdi3+0x1a6>
   1e944:	4613      	mov	r3, r2
   1e946:	e70a      	b.n	1e75e <__divdi3+0xa6>
   1e948:	3b02      	subs	r3, #2
   1e94a:	e757      	b.n	1e7fc <__divdi3+0x144>
   1e94c:	f1a8 0802 	sub.w	r8, r8, #2
   1e950:	442f      	add	r7, r5
   1e952:	e73f      	b.n	1e7d4 <__divdi3+0x11c>

0001e954 <__udivdi3>:
   1e954:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e958:	2b00      	cmp	r3, #0
   1e95a:	d144      	bne.n	1e9e6 <__udivdi3+0x92>
   1e95c:	428a      	cmp	r2, r1
   1e95e:	4615      	mov	r5, r2
   1e960:	4604      	mov	r4, r0
   1e962:	d94f      	bls.n	1ea04 <__udivdi3+0xb0>
   1e964:	fab2 f782 	clz	r7, r2
   1e968:	460e      	mov	r6, r1
   1e96a:	b14f      	cbz	r7, 1e980 <__udivdi3+0x2c>
   1e96c:	f1c7 0320 	rsb	r3, r7, #32
   1e970:	40b9      	lsls	r1, r7
   1e972:	fa20 f603 	lsr.w	r6, r0, r3
   1e976:	fa02 f507 	lsl.w	r5, r2, r7
   1e97a:	430e      	orrs	r6, r1
   1e97c:	fa00 f407 	lsl.w	r4, r0, r7
   1e980:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1e984:	0c23      	lsrs	r3, r4, #16
   1e986:	fbb6 f0fe 	udiv	r0, r6, lr
   1e98a:	b2af      	uxth	r7, r5
   1e98c:	fb0e 6110 	mls	r1, lr, r0, r6
   1e990:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1e994:	fb07 f100 	mul.w	r1, r7, r0
   1e998:	4299      	cmp	r1, r3
   1e99a:	d909      	bls.n	1e9b0 <__udivdi3+0x5c>
   1e99c:	195b      	adds	r3, r3, r5
   1e99e:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
   1e9a2:	f080 80ec 	bcs.w	1eb7e <__udivdi3+0x22a>
   1e9a6:	4299      	cmp	r1, r3
   1e9a8:	f240 80e9 	bls.w	1eb7e <__udivdi3+0x22a>
   1e9ac:	3802      	subs	r0, #2
   1e9ae:	442b      	add	r3, r5
   1e9b0:	1a5a      	subs	r2, r3, r1
   1e9b2:	b2a4      	uxth	r4, r4
   1e9b4:	fbb2 f3fe 	udiv	r3, r2, lr
   1e9b8:	fb0e 2213 	mls	r2, lr, r3, r2
   1e9bc:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
   1e9c0:	fb07 f703 	mul.w	r7, r7, r3
   1e9c4:	4297      	cmp	r7, r2
   1e9c6:	d908      	bls.n	1e9da <__udivdi3+0x86>
   1e9c8:	1952      	adds	r2, r2, r5
   1e9ca:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
   1e9ce:	f080 80d8 	bcs.w	1eb82 <__udivdi3+0x22e>
   1e9d2:	4297      	cmp	r7, r2
   1e9d4:	f240 80d5 	bls.w	1eb82 <__udivdi3+0x22e>
   1e9d8:	3b02      	subs	r3, #2
   1e9da:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1e9de:	2600      	movs	r6, #0
   1e9e0:	4631      	mov	r1, r6
   1e9e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e9e6:	428b      	cmp	r3, r1
   1e9e8:	d847      	bhi.n	1ea7a <__udivdi3+0x126>
   1e9ea:	fab3 f683 	clz	r6, r3
   1e9ee:	2e00      	cmp	r6, #0
   1e9f0:	d148      	bne.n	1ea84 <__udivdi3+0x130>
   1e9f2:	428b      	cmp	r3, r1
   1e9f4:	d302      	bcc.n	1e9fc <__udivdi3+0xa8>
   1e9f6:	4282      	cmp	r2, r0
   1e9f8:	f200 80cd 	bhi.w	1eb96 <__udivdi3+0x242>
   1e9fc:	2001      	movs	r0, #1
   1e9fe:	4631      	mov	r1, r6
   1ea00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ea04:	b912      	cbnz	r2, 1ea0c <__udivdi3+0xb8>
   1ea06:	2501      	movs	r5, #1
   1ea08:	fbb5 f5f2 	udiv	r5, r5, r2
   1ea0c:	fab5 f885 	clz	r8, r5
   1ea10:	f1b8 0f00 	cmp.w	r8, #0
   1ea14:	d177      	bne.n	1eb06 <__udivdi3+0x1b2>
   1ea16:	1b4a      	subs	r2, r1, r5
   1ea18:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1ea1c:	b2af      	uxth	r7, r5
   1ea1e:	2601      	movs	r6, #1
   1ea20:	fbb2 f0fe 	udiv	r0, r2, lr
   1ea24:	0c23      	lsrs	r3, r4, #16
   1ea26:	fb0e 2110 	mls	r1, lr, r0, r2
   1ea2a:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   1ea2e:	fb07 f300 	mul.w	r3, r7, r0
   1ea32:	428b      	cmp	r3, r1
   1ea34:	d907      	bls.n	1ea46 <__udivdi3+0xf2>
   1ea36:	1949      	adds	r1, r1, r5
   1ea38:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
   1ea3c:	d202      	bcs.n	1ea44 <__udivdi3+0xf0>
   1ea3e:	428b      	cmp	r3, r1
   1ea40:	f200 80ba 	bhi.w	1ebb8 <__udivdi3+0x264>
   1ea44:	4610      	mov	r0, r2
   1ea46:	1ac9      	subs	r1, r1, r3
   1ea48:	b2a4      	uxth	r4, r4
   1ea4a:	fbb1 f3fe 	udiv	r3, r1, lr
   1ea4e:	fb0e 1113 	mls	r1, lr, r3, r1
   1ea52:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
   1ea56:	fb07 f703 	mul.w	r7, r7, r3
   1ea5a:	42a7      	cmp	r7, r4
   1ea5c:	d908      	bls.n	1ea70 <__udivdi3+0x11c>
   1ea5e:	1964      	adds	r4, r4, r5
   1ea60:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
   1ea64:	f080 808f 	bcs.w	1eb86 <__udivdi3+0x232>
   1ea68:	42a7      	cmp	r7, r4
   1ea6a:	f240 808c 	bls.w	1eb86 <__udivdi3+0x232>
   1ea6e:	3b02      	subs	r3, #2
   1ea70:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1ea74:	4631      	mov	r1, r6
   1ea76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ea7a:	2600      	movs	r6, #0
   1ea7c:	4630      	mov	r0, r6
   1ea7e:	4631      	mov	r1, r6
   1ea80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ea84:	f1c6 0420 	rsb	r4, r6, #32
   1ea88:	fa22 f504 	lsr.w	r5, r2, r4
   1ea8c:	40b3      	lsls	r3, r6
   1ea8e:	432b      	orrs	r3, r5
   1ea90:	fa20 fc04 	lsr.w	ip, r0, r4
   1ea94:	fa01 f706 	lsl.w	r7, r1, r6
   1ea98:	fa21 f504 	lsr.w	r5, r1, r4
   1ea9c:	ea4f 4e13 	mov.w	lr, r3, lsr #16
   1eaa0:	ea4c 0707 	orr.w	r7, ip, r7
   1eaa4:	fbb5 f8fe 	udiv	r8, r5, lr
   1eaa8:	0c39      	lsrs	r1, r7, #16
   1eaaa:	fb0e 5518 	mls	r5, lr, r8, r5
   1eaae:	fa1f fc83 	uxth.w	ip, r3
   1eab2:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
   1eab6:	fb0c f108 	mul.w	r1, ip, r8
   1eaba:	42a9      	cmp	r1, r5
   1eabc:	fa02 f206 	lsl.w	r2, r2, r6
   1eac0:	d904      	bls.n	1eacc <__udivdi3+0x178>
   1eac2:	18ed      	adds	r5, r5, r3
   1eac4:	f108 34ff 	add.w	r4, r8, #4294967295	; 0xffffffff
   1eac8:	d367      	bcc.n	1eb9a <__udivdi3+0x246>
   1eaca:	46a0      	mov	r8, r4
   1eacc:	1a6d      	subs	r5, r5, r1
   1eace:	b2bf      	uxth	r7, r7
   1ead0:	fbb5 f4fe 	udiv	r4, r5, lr
   1ead4:	fb0e 5514 	mls	r5, lr, r4, r5
   1ead8:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
   1eadc:	fb0c fc04 	mul.w	ip, ip, r4
   1eae0:	458c      	cmp	ip, r1
   1eae2:	d904      	bls.n	1eaee <__udivdi3+0x19a>
   1eae4:	18c9      	adds	r1, r1, r3
   1eae6:	f104 35ff 	add.w	r5, r4, #4294967295	; 0xffffffff
   1eaea:	d35c      	bcc.n	1eba6 <__udivdi3+0x252>
   1eaec:	462c      	mov	r4, r5
   1eaee:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
   1eaf2:	ebcc 0101 	rsb	r1, ip, r1
   1eaf6:	fba4 2302 	umull	r2, r3, r4, r2
   1eafa:	4299      	cmp	r1, r3
   1eafc:	d348      	bcc.n	1eb90 <__udivdi3+0x23c>
   1eafe:	d044      	beq.n	1eb8a <__udivdi3+0x236>
   1eb00:	4620      	mov	r0, r4
   1eb02:	2600      	movs	r6, #0
   1eb04:	e76c      	b.n	1e9e0 <__udivdi3+0x8c>
   1eb06:	f1c8 0420 	rsb	r4, r8, #32
   1eb0a:	fa01 f308 	lsl.w	r3, r1, r8
   1eb0e:	fa05 f508 	lsl.w	r5, r5, r8
   1eb12:	fa20 f704 	lsr.w	r7, r0, r4
   1eb16:	40e1      	lsrs	r1, r4
   1eb18:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1eb1c:	431f      	orrs	r7, r3
   1eb1e:	fbb1 f6fe 	udiv	r6, r1, lr
   1eb22:	0c3a      	lsrs	r2, r7, #16
   1eb24:	fb0e 1116 	mls	r1, lr, r6, r1
   1eb28:	fa1f fc85 	uxth.w	ip, r5
   1eb2c:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
   1eb30:	fb0c f206 	mul.w	r2, ip, r6
   1eb34:	429a      	cmp	r2, r3
   1eb36:	fa00 f408 	lsl.w	r4, r0, r8
   1eb3a:	d907      	bls.n	1eb4c <__udivdi3+0x1f8>
   1eb3c:	195b      	adds	r3, r3, r5
   1eb3e:	f106 31ff 	add.w	r1, r6, #4294967295	; 0xffffffff
   1eb42:	d237      	bcs.n	1ebb4 <__udivdi3+0x260>
   1eb44:	429a      	cmp	r2, r3
   1eb46:	d935      	bls.n	1ebb4 <__udivdi3+0x260>
   1eb48:	3e02      	subs	r6, #2
   1eb4a:	442b      	add	r3, r5
   1eb4c:	1a9b      	subs	r3, r3, r2
   1eb4e:	b2bf      	uxth	r7, r7
   1eb50:	fbb3 f0fe 	udiv	r0, r3, lr
   1eb54:	fb0e 3310 	mls	r3, lr, r0, r3
   1eb58:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
   1eb5c:	fb0c f100 	mul.w	r1, ip, r0
   1eb60:	4299      	cmp	r1, r3
   1eb62:	d907      	bls.n	1eb74 <__udivdi3+0x220>
   1eb64:	195b      	adds	r3, r3, r5
   1eb66:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
   1eb6a:	d221      	bcs.n	1ebb0 <__udivdi3+0x25c>
   1eb6c:	4299      	cmp	r1, r3
   1eb6e:	d91f      	bls.n	1ebb0 <__udivdi3+0x25c>
   1eb70:	3802      	subs	r0, #2
   1eb72:	442b      	add	r3, r5
   1eb74:	1a5a      	subs	r2, r3, r1
   1eb76:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
   1eb7a:	4667      	mov	r7, ip
   1eb7c:	e750      	b.n	1ea20 <__udivdi3+0xcc>
   1eb7e:	4610      	mov	r0, r2
   1eb80:	e716      	b.n	1e9b0 <__udivdi3+0x5c>
   1eb82:	460b      	mov	r3, r1
   1eb84:	e729      	b.n	1e9da <__udivdi3+0x86>
   1eb86:	4613      	mov	r3, r2
   1eb88:	e772      	b.n	1ea70 <__udivdi3+0x11c>
   1eb8a:	40b0      	lsls	r0, r6
   1eb8c:	4290      	cmp	r0, r2
   1eb8e:	d2b7      	bcs.n	1eb00 <__udivdi3+0x1ac>
   1eb90:	1e60      	subs	r0, r4, #1
   1eb92:	2600      	movs	r6, #0
   1eb94:	e724      	b.n	1e9e0 <__udivdi3+0x8c>
   1eb96:	4630      	mov	r0, r6
   1eb98:	e722      	b.n	1e9e0 <__udivdi3+0x8c>
   1eb9a:	42a9      	cmp	r1, r5
   1eb9c:	d995      	bls.n	1eaca <__udivdi3+0x176>
   1eb9e:	f1a8 0802 	sub.w	r8, r8, #2
   1eba2:	441d      	add	r5, r3
   1eba4:	e792      	b.n	1eacc <__udivdi3+0x178>
   1eba6:	458c      	cmp	ip, r1
   1eba8:	d9a0      	bls.n	1eaec <__udivdi3+0x198>
   1ebaa:	3c02      	subs	r4, #2
   1ebac:	4419      	add	r1, r3
   1ebae:	e79e      	b.n	1eaee <__udivdi3+0x19a>
   1ebb0:	4610      	mov	r0, r2
   1ebb2:	e7df      	b.n	1eb74 <__udivdi3+0x220>
   1ebb4:	460e      	mov	r6, r1
   1ebb6:	e7c9      	b.n	1eb4c <__udivdi3+0x1f8>
   1ebb8:	3802      	subs	r0, #2
   1ebba:	4429      	add	r1, r5
   1ebbc:	e743      	b.n	1ea46 <__udivdi3+0xf2>
   1ebbe:	bf00      	nop

0001ebc0 <__errno>:
   1ebc0:	4b01      	ldr	r3, [pc, #4]	; (1ebc8 <__errno+0x8>)
   1ebc2:	6818      	ldr	r0, [r3, #0]
   1ebc4:	4770      	bx	lr
   1ebc6:	bf00      	nop
   1ebc8:	20000850 	.word	0x20000850

0001ebcc <__libc_init_array>:
   1ebcc:	b570      	push	{r4, r5, r6, lr}
   1ebce:	4e0f      	ldr	r6, [pc, #60]	; (1ec0c <__libc_init_array+0x40>)
   1ebd0:	4d0f      	ldr	r5, [pc, #60]	; (1ec10 <__libc_init_array+0x44>)
   1ebd2:	1b76      	subs	r6, r6, r5
   1ebd4:	10b6      	asrs	r6, r6, #2
   1ebd6:	bf18      	it	ne
   1ebd8:	2400      	movne	r4, #0
   1ebda:	d005      	beq.n	1ebe8 <__libc_init_array+0x1c>
   1ebdc:	3401      	adds	r4, #1
   1ebde:	f855 3b04 	ldr.w	r3, [r5], #4
   1ebe2:	4798      	blx	r3
   1ebe4:	42a6      	cmp	r6, r4
   1ebe6:	d1f9      	bne.n	1ebdc <__libc_init_array+0x10>
   1ebe8:	4e0a      	ldr	r6, [pc, #40]	; (1ec14 <__libc_init_array+0x48>)
   1ebea:	4d0b      	ldr	r5, [pc, #44]	; (1ec18 <__libc_init_array+0x4c>)
   1ebec:	1b76      	subs	r6, r6, r5
   1ebee:	f000 f815 	bl	1ec1c <_init>
   1ebf2:	10b6      	asrs	r6, r6, #2
   1ebf4:	bf18      	it	ne
   1ebf6:	2400      	movne	r4, #0
   1ebf8:	d006      	beq.n	1ec08 <__libc_init_array+0x3c>
   1ebfa:	3401      	adds	r4, #1
   1ebfc:	f855 3b04 	ldr.w	r3, [r5], #4
   1ec00:	4798      	blx	r3
   1ec02:	42a6      	cmp	r6, r4
   1ec04:	d1f9      	bne.n	1ebfa <__libc_init_array+0x2e>
   1ec06:	bd70      	pop	{r4, r5, r6, pc}
   1ec08:	bd70      	pop	{r4, r5, r6, pc}
   1ec0a:	bf00      	nop
   1ec0c:	20000854 	.word	0x20000854
   1ec10:	20000854 	.word	0x20000854
   1ec14:	20000854 	.word	0x20000854
   1ec18:	20000854 	.word	0x20000854

0001ec1c <_init>:
   1ec1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ec1e:	bf00      	nop
   1ec20:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1ec22:	bc08      	pop	{r3}
   1ec24:	469e      	mov	lr, r3
   1ec26:	4770      	bx	lr

0001ec28 <_fini>:
   1ec28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ec2a:	bf00      	nop
   1ec2c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1ec2e:	bc08      	pop	{r3}
   1ec30:	469e      	mov	lr, r3
   1ec32:	4770      	bx	lr
   1ec34:	6f727265 	.word	0x6f727265
   1ec38:	65732072 	.word	0x65732072
   1ec3c:	6e697474 	.word	0x6e697474
   1ec40:	64612067 	.word	0x64612067
   1ec44:	74726576 	.word	0x74726576
   1ec48:	6d657369 	.word	0x6d657369
   1ec4c:	20746e65 	.word	0x20746e65
   1ec50:	61746164 	.word	0x61746164
   1ec54:	6372203b 	.word	0x6372203b
   1ec58:	0a64253d 	.word	0x0a64253d
   1ec5c:	72726500 	.word	0x72726500
   1ec60:	6520726f 	.word	0x6520726f
   1ec64:	6c62616e 	.word	0x6c62616e
   1ec68:	20676e69 	.word	0x20676e69
   1ec6c:	65766461 	.word	0x65766461
   1ec70:	73697472 	.word	0x73697472
   1ec74:	6e656d65 	.word	0x6e656d65
   1ec78:	72203b74 	.word	0x72203b74
   1ec7c:	64253d63 	.word	0x64253d63
   1ec80:	616d000a 	.word	0x616d000a
   1ec84:	632e6e69 	.word	0x632e6e69
   1ec88:	6e616800 	.word	0x6e616800
   1ec8c:	3d656c64 	.word	0x3d656c64
   1ec90:	6f206425 	.word	0x6f206425
   1ec94:	6f5f7275 	.word	0x6f5f7275
   1ec98:	615f6174 	.word	0x615f6174
   1ec9c:	5f726464 	.word	0x5f726464
   1eca0:	65707974 	.word	0x65707974
   1eca4:	2064253d 	.word	0x2064253d
   1eca8:	5f72756f 	.word	0x5f72756f
   1ecac:	5f61746f 	.word	0x5f61746f
   1ecb0:	72646461 	.word	0x72646461
   1ecb4:	6f20003d 	.word	0x6f20003d
   1ecb8:	695f7275 	.word	0x695f7275
   1ecbc:	64615f64 	.word	0x64615f64
   1ecc0:	745f7264 	.word	0x745f7264
   1ecc4:	3d657079 	.word	0x3d657079
   1ecc8:	6f206425 	.word	0x6f206425
   1eccc:	695f7275 	.word	0x695f7275
   1ecd0:	64615f64 	.word	0x64615f64
   1ecd4:	003d7264 	.word	0x003d7264
   1ecd8:	65657020 	.word	0x65657020
   1ecdc:	746f5f72 	.word	0x746f5f72
   1ece0:	64615f61 	.word	0x64615f61
   1ece4:	745f7264 	.word	0x745f7264
   1ece8:	3d657079 	.word	0x3d657079
   1ecec:	70206425 	.word	0x70206425
   1ecf0:	5f726565 	.word	0x5f726565
   1ecf4:	5f61746f 	.word	0x5f61746f
   1ecf8:	72646461 	.word	0x72646461
   1ecfc:	7020003d 	.word	0x7020003d
   1ed00:	5f726565 	.word	0x5f726565
   1ed04:	615f6469 	.word	0x615f6469
   1ed08:	5f726464 	.word	0x5f726464
   1ed0c:	65707974 	.word	0x65707974
   1ed10:	2064253d 	.word	0x2064253d
   1ed14:	72656570 	.word	0x72656570
   1ed18:	5f64695f 	.word	0x5f64695f
   1ed1c:	72646461 	.word	0x72646461
   1ed20:	6320003d 	.word	0x6320003d
   1ed24:	5f6e6e6f 	.word	0x5f6e6e6f
   1ed28:	6c767469 	.word	0x6c767469
   1ed2c:	2064253d 	.word	0x2064253d
   1ed30:	6e6e6f63 	.word	0x6e6e6f63
   1ed34:	74616c5f 	.word	0x74616c5f
   1ed38:	79636e65 	.word	0x79636e65
   1ed3c:	2064253d 	.word	0x2064253d
   1ed40:	65707573 	.word	0x65707573
   1ed44:	73697672 	.word	0x73697672
   1ed48:	5f6e6f69 	.word	0x5f6e6f69
   1ed4c:	656d6974 	.word	0x656d6974
   1ed50:	3d74756f 	.word	0x3d74756f
   1ed54:	65206425 	.word	0x65206425
   1ed58:	7972636e 	.word	0x7972636e
   1ed5c:	64657470 	.word	0x64657470
   1ed60:	2064253d 	.word	0x2064253d
   1ed64:	68747561 	.word	0x68747561
   1ed68:	69746e65 	.word	0x69746e65
   1ed6c:	65746163 	.word	0x65746163
   1ed70:	64253d64 	.word	0x64253d64
   1ed74:	6e6f6220 	.word	0x6e6f6220
   1ed78:	3d646564 	.word	0x3d646564
   1ed7c:	000a6425 	.word	0x000a6425
   1ed80:	61747365 	.word	0x61747365
   1ed84:	73696c62 	.word	0x73696c62
   1ed88:	00646568 	.word	0x00646568
   1ed8c:	6c696166 	.word	0x6c696166
   1ed90:	63006465 	.word	0x63006465
   1ed94:	656e6e6f 	.word	0x656e6e6f
   1ed98:	6f697463 	.word	0x6f697463
   1ed9c:	7325206e 	.word	0x7325206e
   1eda0:	7473203b 	.word	0x7473203b
   1eda4:	73757461 	.word	0x73757461
   1eda8:	2064253d 	.word	0x2064253d
   1edac:	73696400 	.word	0x73696400
   1edb0:	6e6e6f63 	.word	0x6e6e6f63
   1edb4:	3b746365 	.word	0x3b746365
   1edb8:	61657220 	.word	0x61657220
   1edbc:	3d6e6f73 	.word	0x3d6e6f73
   1edc0:	00206425 	.word	0x00206425
   1edc4:	72636e65 	.word	0x72636e65
   1edc8:	69747079 	.word	0x69747079
   1edcc:	63206e6f 	.word	0x63206e6f
   1edd0:	676e6168 	.word	0x676e6168
   1edd4:	76652065 	.word	0x76652065
   1edd8:	3b746e65 	.word	0x3b746e65
   1eddc:	61747320 	.word	0x61747320
   1ede0:	3d737574 	.word	0x3d737574
   1ede4:	00206425 	.word	0x00206425
   1ede8:	75730a0a 	.word	0x75730a0a
   1edec:	72637362 	.word	0x72637362
   1edf0:	20656269 	.word	0x20656269
   1edf4:	6e657665 	.word	0x6e657665
   1edf8:	63203b74 	.word	0x63203b74
   1edfc:	5f6e6e6f 	.word	0x5f6e6e6f
   1ee00:	646e6168 	.word	0x646e6168
   1ee04:	253d656c 	.word	0x253d656c
   1ee08:	74612064 	.word	0x74612064
   1ee0c:	685f7274 	.word	0x685f7274
   1ee10:	6c646e61 	.word	0x6c646e61
   1ee14:	64253d65 	.word	0x64253d65
   1ee18:	61657220 	.word	0x61657220
   1ee1c:	3d6e6f73 	.word	0x3d6e6f73
   1ee20:	70206425 	.word	0x70206425
   1ee24:	6e766572 	.word	0x6e766572
   1ee28:	2064253d 	.word	0x2064253d
   1ee2c:	6e727563 	.word	0x6e727563
   1ee30:	2064253d 	.word	0x2064253d
   1ee34:	76657270 	.word	0x76657270
   1ee38:	64253d69 	.word	0x64253d69
   1ee3c:	72756320 	.word	0x72756320
   1ee40:	64253d69 	.word	0x64253d69
   1ee44:	6c62000a 	.word	0x6c62000a
   1ee48:	70727065 	.word	0x70727065
   1ee4c:	626d5f68 	.word	0x626d5f68
   1ee50:	645f6675 	.word	0x645f6675
   1ee54:	00617461 	.word	0x00617461
   1ee58:	70656c62 	.word	0x70656c62
   1ee5c:	00687072 	.word	0x00687072
   1ee60:	2d656c62 	.word	0x2d656c62
   1ee64:	6f697067 	.word	0x6f697067
   1ee68:	5f6f6900 	.word	0x5f6f6900
   1ee6c:	6c6c6f70 	.word	0x6c6c6f70
   1ee70:	7361745f 	.word	0x7361745f
   1ee74:	006b      	.short	0x006b
   1ee76:	7325      	.short	0x7325
   1ee78:	30257830 	.word	0x30257830
   1ee7c:	25007832 	.word	0x25007832
   1ee80:	3a783230 	.word	0x3a783230
   1ee84:	78323025 	.word	0x78323025
   1ee88:	3230253a 	.word	0x3230253a
   1ee8c:	30253a78 	.word	0x30253a78
   1ee90:	253a7832 	.word	0x253a7832
   1ee94:	3a783230 	.word	0x3a783230
   1ee98:	78323025 	.word	0x78323025
	...

0001ee9d <gatt_svr_chr_gpio>:
   1ee9d:	07c96db7 b0160071 897e45e1 5c3a659e     .m..q....E~..e:\
   1eead:	01000000                                         ...

0001eeb0 <gatt_svr_svcs>:
   1eeb0:	00000001 20000148 00000000 20000188     ....H.. ....... 
   1eec0:	00000001 0001eee0 00000000 20000100     ............... 
	...

0001eee0 <gatt_svr_svc_gpio>:
   1eee0:	59a2712b 12c858b4 95439999 59462f12     +q.Y.X....C../FY

0001eef0 <gatt_svr_unr_alert_cat>:
   1eef0:	74616701 76735f74 00632e72 78323025     .gatt_svr.c.%02x
   1ef00:	78323025 78323025 78323025 3025002d     %02x%02x%02x-.%0
   1ef10:	30257832 252d7832 25783230 2d783230     2x%02x-%02x%02x-
   1ef20:	67657200 65747369 20646572 76726573     .registered serv
   1ef30:	20656369 77207325 20687469 646e6168     ice %s with hand
   1ef40:	253d656c 72000a64 73696765 69726574     le=%d..registeri
   1ef50:	6320676e 61726168 72657463 69747369     ng characteristi
   1ef60:	73252063 74697720 65642068 61685f66     c %s with def_ha
   1ef70:	656c646e 2064253d 5f6c6176 646e6168     ndle=%d val_hand
   1ef80:	253d656c 72000a64 73696765 69726574     le=%d..registeri
   1ef90:	6420676e 72637365 6f747069 73252072     ng descriptor %s
   1efa0:	74697720 61682068 656c646e 0a64253d      with handle=%d.
   1efb0:	736e4900 63757274 6e6f6974 63657220     .Instruction rec
   1efc0:	65766965 70203a64 253d6e69 64202c75     eived: pin=%u, d
   1efd0:	253d7269 76202c75 253d6c61 53000a75     ir=%u, val=%u..S
   1efe0:	69747465 5020676e 25206e69 73612064     etting Pin %d as
   1eff0:	74756f20 2e747570 000a2e2e 74746553      output.....Sett
   1f000:	20676e69 206e6950 61206425 6e692073     ing Pin %d as in
   1f010:	2e747570 000a2e2e 6e756f46 69642064     put.....Found di
   1f020:	65726373 636e6570 6e6f2079 6e697020     screpency on pin
   1f030:	6425203a 6db8000a                                : %d..

0001f036 <gatt_svr_chr_gpio_notif>:
   1f036:	07c96db8 b0160071 897e45e1 5c3a659e     .m..q....E~..e:\

0001f046 <gatt_svr_new_alert_cat>:
   1f046:	6c616801 7570635f 656d6974 0000632e     .hal_cputime.c..
	...

0001f058 <CSWTCH.11>:
   1f058:	00000000 00000001 ffffffff 00000002     ................
   1f068:	ffffffff ffffffff ffffffff 00000003     ................
   1f078:	ffffffff ffffffff ffffffff ffffffff     ................
   1f088:	ffffffff ffffffff ffffffff 00000004     ................

0001f098 <MemFile_methods>:
   1f098:	000094b5 00000000 656c6469 2e736f00     ........idle.os.
   1f0a8:	736f0063 6c61635f 74756f6c 4100632e     c.os_callout.c.A
   1f0b8:	72657373 73252074 6166203b 64656c69     ssert %s; failed
   1f0c8:	206e6920 253a7325 55000a64 6e61686e      in %s:%d..Unhan
   1f0d8:	64656c64 746e6920 75727265 28207470     dled interrupt (
   1f0e8:	29646c25 7865202c 74706563 206e6f69     %ld), exception 
   1f0f8:	30207073 38302578 000a786c 3a307220     sp 0x%08lx.. r0:
   1f108:	30257830 20786c38 3a317220 30257830     0x%08lx  r1:0x%0
   1f118:	20786c38 3a327220 30257830 20786c38     8lx  r2:0x%08lx 
   1f128:	3a337220 30257830 0a786c38 34722000      r3:0x%08lx.. r4
   1f138:	2578303a 786c3830 35722020 2578303a     :0x%08lx  r5:0x%
   1f148:	786c3830 36722020 2578303a 786c3830     08lx  r6:0x%08lx
   1f158:	37722020 2578303a 786c3830 7220000a       r7:0x%08lx.. r
   1f168:	78303a38 6c383025 72202078 78303a39     8:0x%08lx  r9:0x
   1f178:	6c383025 31722078 78303a30 6c383025     %08lx r10:0x%08l
   1f188:	31722078 78303a31 6c383025 72000a78     x r11:0x%08lx..r
   1f198:	303a3231 38302578 2020786c 303a726c     12:0x%08lx  lr:0
   1f1a8:	38302578 2020786c 303a6370 38302578     x%08lx  pc:0x%08
   1f1b8:	7020786c 303a7273 38302578 000a786c     lx psr:0x%08lx..
   1f1c8:	52534349 2578303a 786c3830 53464820     ICSR:0x%08lx HFS
   1f1d8:	78303a52 6c383025 46432078 303a5253     R:0x%08lx CFSR:0
   1f1e8:	38302578 000a786c 52414642 2578303a     x%08lx..BFAR:0x%
   1f1f8:	786c3830 464d4d20 303a5241 38302578     08lx MMFAR:0x%08
   1f208:	000a786c 6d5f736f 2e667562 736f0063     lx..os_mbuf.c.os
   1f218:	6863735f 632e6465 5f736f00 656d6974     _sched.c.os_time
   1f228:	6f00632e 756d5f73 2e786574 6c620063     .c.os_mutex.c.bl
   1f238:	6c6c5f65 6200632e 6c5f656c 6c62006c     e_ll.c.ble_ll.bl
   1f248:	6c6c5f65 7664615f 6200632e 6c5f656c     e_ll_adv.c.ble_l
   1f258:	6f635f6c 632e6e6e 656c6200 5f6c6c5f     l_conn.c.ble_ll_
   1f268:	6e6e6f63 01f40000                                conn..

0001f26e <g_ble_sca_ppm_tbl>:
   1f26e:	00fa01f4 00640096 0032004b 0014001e     ......d.K.2.....
   1f27e:	5f656c62 635f6c6c 5f6e6e6f 2e696368     ble_ll_conn_hci.
   1f28e:	6c620063 6c6c5f65 7274635f 00632e6c     c.ble_ll_ctrl.c.

0001f29e <g_ble_ll_ctrl_pkt_lengths>:
   1f29e:	1601070b 0100000c 00000808 17080105     ................
   1f2ae:	00000217 00010808                                ......

0001f2b4 <CSWTCH.40>:
   1f2b4:	00010001 01000000 08000000 10000202     ................
   1f2c4:	6c622000 6c6c5f65 6963685f 6200632e     . ble_ll_hci.c.b
   1f2d4:	6c5f656c 65725f6c 766c6f73 6200632e     le_ll_resolv.c.b
   1f2e4:	6c5f656c 63735f6c 632e6e61 656c6200     le_ll_scan.c.ble
   1f2f4:	5f6c6c5f 65686373 00632e64              _ll_sched.c.

0001f300 <g_ble_ll_supp_cmds>:
   1f300:	00000020 00004000 00000000 22280000      ....@........("
	...
   1f318:	fffff700 00000009 08003000 5f656c62     .........0..ble_
   1f328:	00796870 5f656c62 2e796870 6e650063     phy.ble_phy.c.en
   1f338:	2d797274 7b3d6425 72646461 7079745f     try-%d={addr_typ
   1f348:	64253d65 64646120 7d003d72 41470020     e=%d addr=.} .GA
   1f358:	72702050 6465636f 20657275 74696e69     P procedure init
   1f368:	65746169 73203a64 77207465 65746968     iated: set white
   1f378:	7473696c 6300203b 746e756f 2064253d     list; .count=%d 
   1f388:	50414700 6f727020 75646563 69206572     .GAP procedure i
   1f398:	6974696e 64657461 7473203a 6120706f     nitiated: stop a
   1f3a8:	72657664 69736974 0a2e676e 50414700     dvertising...GAP
   1f3b8:	6f727020 75646563 69206572 6974696e      procedure initi
   1f3c8:	64657461 6461203a 74726576 3b657369     ated: advertise;
   1f3d8:	69640020 6d5f6373 3d65646f 70206425      .disc_mode=%d p
   1f3e8:	5f726565 72646461 7079745f 64253d65     eer_addr_type=%d
   1f3f8:	65657020 64615f72 003d7264 656e6f6e      peer_addr=.none
   1f408:	64612000 68635f76 656e6e61 616d5f6c     . adv_channel_ma
   1f418:	64253d70 6e776f20 6464615f 79745f72     p=%d own_addr_ty
   1f428:	253d6570 64612064 69665f76 7265746c     pe=%d adv_filter
   1f438:	6c6f705f 3d796369 61206425 695f7664     _policy=%d adv_i
   1f448:	5f6c7674 3d6e696d 61206425 695f7664     tvl_min=%d adv_i
   1f458:	5f6c7674 3d78616d 61206425 645f7664     tvl_max=%d adv_d
   1f468:	5f617461 3d6e656c 47006425 70205041     ata_len=%d.GAP p
   1f478:	65636f72 65727564 696e6920 74616974     rocedure initiat
   1f488:	203a6465 63736964 7265766f 00203b79     ed: discovery; .
   1f498:	5f6e776f 72646461 7079745f 64253d65     own_addr_type=%d
   1f4a8:	6c696620 5f726574 696c6f70 253d7963      filter_policy=%
   1f4b8:	61702064 76697373 64253d65 6d696c20     d passive=%d lim
   1f4c8:	64657469 2064253d 746c6966 645f7265     ited=%d filter_d
   1f4d8:	696c7075 65746163 64253d73 75640020     uplicates=%d .du
   1f4e8:	69746172 663d6e6f 7665726f 64007265     ration=forever.d
   1f4f8:	74617275 3d6e6f69 736d6425 50414700     uration=%dms.GAP
   1f508:	6f727020 75646563 69206572 6974696e      procedure initi
   1f518:	64657461 6f63203a 63656e6e 00203b74     ated: connect; .
   1f528:	00412f4e 61637320 74695f6e 253d6c76     N/A. scan_itvl=%
   1f538:	63732064 775f6e61 6f646e69 64253d77     d scan_window=%d
   1f548:	76746920 696d5f6c 64253d6e 76746920      itvl_min=%d itv
   1f558:	616d5f6c 64253d78 74616c20 79636e65     l_max=%d latency
   1f568:	2064253d 65707573 73697672 5f6e6f69     =%d supervision_
   1f578:	656d6974 3d74756f 6d206425 635f6e69     timeout=%d min_c
   1f588:	656c5f65 64253d6e 78616d20 5f65635f     e_len=%d max_ce_
   1f598:	3d6e656c 6f206425 615f6e77 5f726464     len=%d own_addr_
   1f5a8:	65707974 0064253d 20504147 636f7270     type=%d.GAP proc
   1f5b8:	72756465 6e692065 61697469 3a646574     edure initiated:
   1f5c8:	72657420 616e696d 63206574 656e6e6f      terminate conne
   1f5d8:	6f697463 63203b6e 5f6e6e6f 646e6168     ction; conn_hand
   1f5e8:	253d656c 63682064 65725f69 6e6f7361     le=%d hci_reason
   1f5f8:	0a64253d 50414700 6f727020 75646563     =%d..GAP procedu
   1f608:	69206572 6974696e 64657461 6163203a     re initiated: ca
   1f618:	6c65636e 6e6f6320 7463656e 0a6e6f69     ncel connection.
   1f628:	50414700 6f727020 75646563 69206572     .GAP procedure i
   1f638:	6974696e 64657461 6300203a 656e6e6f     nitiated: .conne
   1f648:	6f697463 6170206e 656d6172 20726574     ction parameter 
   1f658:	61647075 203b6574 6e6e6f63 6e61685f     update; conn_han
   1f668:	3d656c64 69206425 5f6c7674 3d6e696d     dle=%d itvl_min=
   1f678:	69206425 5f6c7674 3d78616d 6c206425     %d itvl_max=%d l
   1f688:	6e657461 253d7963 75732064 76726570     atency=%d superv
   1f698:	6f697369 69745f6e 756f656d 64253d74     ision_timeout=%d
   1f6a8:	6e696d20 5f65635f 3d6e656c 6d206425      min_ce_len=%d m
   1f6b8:	635f7861 656c5f65 64253d6e 6e657300     ax_ce_len=%d.sen
   1f6c8:	61702064 656b7373 63612079 6e6f6974     d passkey action
   1f6d8:	71657220 74736575 0a642520 656c6200      request %d..ble
   1f6e8:	7061675f 00000000                       _gap....

0001f6f0 <ble_gattc_rx_read_rsp_entries>:
   1f6f0:	00000007 00012723 00000009 00012f05     ....#'......./..
   1f700:	00000003 00012b39                       ....9+..

0001f708 <ble_gattc_rx_read_type_elem_entries>:
   1f708:	00000003 00012f89 00000004 00012ca3     ...../.......,..
   1f718:	00000005 00012d31 00000008 00012793     ....1-.......'..

0001f728 <ble_gattc_rx_prep_entries>:
   1f728:	0000000c 00012dd9 0000000d 00013049     .....-......I0..
   1f738:	54544147 6f727020 75646563 69206572     GATT procedure i
   1f748:	6974696e 64657461 7325203a 32302500     nitiated: %s.%02
   1f758:	32302578 32302578 32302578 30252d78     x%02x%02x%02x-%0
   1f768:	30257832 252d7832 25783230 2d783230     2x%02x-%02x%02x-
   1f778:	78323025 78323025 78323025 78323025     %02x%02x%02x%02x
   1f788:	78323025 78323025 78323025 78323025     %02x%02x%02x%02x
   1f798:	63786500 676e6168 746d2065 64000a75     .exchange mtu..d
   1f7a8:	6f637369 20726576 206c6c61 76726573     iscover all serv
   1f7b8:	73656369 6964000a 766f6373 73207265     ices..discover s
   1f7c8:	69767265 62206563 75752079 203b6469     ervice by uuid; 
   1f7d8:	64697575 6966003d 6920646e 756c636e     uuid=.find inclu
   1f7e8:	20646564 76726573 73656369 7300203b     ded services; .s
   1f7f8:	74726174 6e61685f 3d656c64 65206425     tart_handle=%d e
   1f808:	685f646e 6c646e61 64253d65 6964000a     nd_handle=%d..di
   1f818:	766f6373 61207265 63206c6c 61726168     scover all chara
   1f828:	72657463 69747369 203b7363 73696400     cteristics; .dis
   1f838:	65766f63 68632072 63617261 69726574     cover characteri
   1f848:	63697473 79622073 69757520 00203b64     stics by uuid; .
   1f858:	72617473 61685f74 656c646e 2064253d     start_handle=%d 
   1f868:	5f646e65 646e6168 253d656c 75752064     end_handle=%d uu
   1f878:	003d6469 63736964 7265766f 6c6c6120     id=.discover all
   1f888:	73656420 70697263 73726f74 6300203b      descriptors; .c
   1f898:	765f7268 685f6c61 6c646e61 64253d65     hr_val_handle=%d
   1f8a8:	646e6520 6e61685f 3d656c64 000a6425      end_handle=%d..
   1f8b8:	64616572 6100203b 685f7474 6c646e61     read; .att_handl
   1f8c8:	64253d65 6572000a 62206461 75752079     e=%d..read by uu
   1f8d8:	203b6469 61657200 6f6c2064 203b676e     id; .read long; 
   1f8e8:	72002c00 20646165 746c756d 656c7069     .,.read multiple
   1f8f8:	6100203b 685f7474 6c646e61 003d7365     ; .att_handles=.
   1f908:	64257325 69727700 6e206574 7372206f     %s%d.write no rs
   1f918:	00203b70 5f747461 646e6168 253d656c     p; .att_handle=%
   1f928:	656c2064 64253d6e 7277000a 3b657469     d len=%d..write;
   1f938:	72770020 20657469 676e6f6c 7700203b      .write long; .w
   1f948:	65746972 6c657220 6c626169 00203b65     rite reliable; .
   1f958:	69746f6e 203b7966 646e6900 74616369     notify; .indicat
   1f968:	00203b65 5f656c62 74746167 6c620063     e; .ble_gattc.bl
   1f978:	61675f65 5f637474 636f7270 6f6f705f     e_gattc_proc_poo
   1f988:	0000006c                                l...

0001f98c <ble_gattc_rx_read_type_complete_entries>:
   1f98c:	00000003 00012ed5 00000004 00012e79     ............y...
   1f99c:	00000005 00012ea7 00000008 00012e2f     ............/...

0001f9ac <ble_gattc_rx_exec_entries>:
   1f9ac:	0000000c 000128ad 0000000d 000128f9     .....(.......(..

0001f9bc <ble_gattc_err_dispatch>:
   1f9bc:	000124f5 0001253d 0001258d 000125dd     .$..=%...%...%..
   1f9cc:	00012631 00012681 000126cd 0001271d     1&...&...&...'..
   1f9dc:	00012785 00012805 00012861 00012a3d     .'...(..a(..=*..
   1f9ec:	00012c47 00012f63 00012c75 5f656c62     G,..c/..u,..ble_
   1f9fc:	74746167 6c635f73 66635f74 6f705f67     gatts_clt_cfg_po
   1fa0c:	62006c6f 675f656c 73747461 656c6200     ol.ble_gatts.ble
   1fa1c:	2e73685f 6c620063 73685f65 49434800     _hs.c.ble_hs.HCI
   1fa2c:	50646d43 006c6f6f 4f494348 65764573     CmdPool.HCIOsEve
   1fa3c:	6f50746e 00006c6f                       ntPool..

0001fa44 <ble_hs_cfg_dflt>:
   1fa44:	00100108 00100020 10060040 00030108     .... ...@.......
	...
   1fa64:	0000012c 5f656c62 635f7368 2e6e6e6f     ,...ble_hs_conn.
   1fa74:	6c620063 73685f65 6e6f635f 6f705f6e     c.ble_hs_conn_po
   1fa84:	30006c6f 32302578 ef002078                       ol.0x%02x .

0001fa8f <default_irk>:
   1fa8f:	16e28def 0d43ec4f 34dd5bbf b81e53c0     ....O.C..[.4.S..
   1fa9f:	5f656c62 735f7368 74726174 632e7075     ble_hs_startup.c
   1faaf:	20787200 75206e6f 6f6e6b6e 4c206e77     .rx on unknown L
   1fabf:	50414332 61686320 6c656e6e 6425203a     2CAP channel: %d
   1facf:	6c62000a 326c5f65 5f706163 6e616863     ..ble_l2cap_chan
   1fadf:	6f6f705f 6c62006c 326c5f65 00706163     _pool.ble_l2cap.
	...

0001faf0 <ble_l2cap_sig_dispatch>:
   1faf0:	00000000 00015a75 00000000 00015a75     ....uZ......uZ..
   1fb00:	00000000 00015a75 00000000 00015a75     ....uZ......uZ..
   1fb10:	00000000 00015a75 00000000 00015a75     ....uZ......uZ..
   1fb20:	00000000 00015a75 00000000 00015a75     ....uZ......uZ..
   1fb30:	00000000 00015a75 00015b39 00015c01     ....uZ..9[...\..
   1fb40:	00000000 00015a75 4143324c 202d2050     ....uZ..L2CAP - 
   1fb50:	64657872 67697320 6c6c616e 20676e69     rxed signalling 
   1fb60:	3a67736d 6c620020 326c5f65 5f706163     msg: .ble_l2cap_
   1fb70:	5f676973 636f7270 6f6f705f 0000006c     sig_proc_pool...

0001fb80 <ble_sm_dispatch>:
   1fb80:	00000000 00016941 00016b91 00016aa5     ....Ai...k...j..
   1fb90:	00017155 00016145 0001686d 000167a5     Uq..Ea..mh...g..
   1fba0:	000166d1 00016601 0001652d 000173b5     .f...f..-e...s..
   1fbb0:	00015ea1 00015ea1 00015ea1 64657325     .^...^...^..%sed
   1fbc0:	20732520 6d6d6f63 3a646e61 3b732520      %s command: %s;
   1fbd0:	6e6f6320 64253d6e 78720020 006d7300      conn=%d .rx.sm.
   1fbe0:	6c696166 5f787200 5f79656b 67616c66     fail.rx_key_flag
   1fbf0:	78303d73 78323025 6973000a 69206e67     s=0x%02x..sign i
   1fc00:	006f666e 61206469 20726464 6f666e69     nfo.id addr info
   1fc10:	20646900 6f666e69 73616d00 20726574     .id info.master 
   1fc20:	65006469 6920636e 006f666e 72696170     id.enc info.pair
   1fc30:	71657220 6e6f6300 6d726966 69617000      req.confirm.pai
   1fc40:	73722072 61720070 6d6f646e 63657300     r rsp.random.sec
   1fc50:	71657220 656c6200 5f6d735f 636f7270      req.ble_sm_proc
   1fc60:	6f6f705f 0000006c                       _pool...

0001fc68 <ble_sm_state_dispatch>:
   1fc68:	00017085 000160e3 000160d7 00016033     .p...`...`..3`..
   1fc78:	00016091 00015f85 0001639d 000161c5     .`..._...c...a..
   1fc88:	00016a49 00000000 00000000 20202020     Ij..........    
   1fc98:	003d7325 5f656c62 615f6d73 735f676c     %s=.ble_sm_alg_s
   1fca8:	0a292831 20202020 0a003d6b 20202020     1().    k=..    
   1fcb8:	003d3172 2020200a 3d327220 20200a00     r1=..    r2=..  
   1fcc8:	756f2020 62003d74 735f656c 6c615f6d       out=.ble_sm_al
   1fcd8:	31635f67 200a2928 6b202020 200a003d     g_c1().    k=.. 
   1fce8:	72202020 200a003d 69202020 253d7461        r=..    iat=%
   1fcf8:	61722064 64253d74 20200a00 61692020     d rat=%d..    ia
   1fd08:	200a003d 72202020 0a003d61 20202020     =..    ra=..    
   1fd18:	71657270 200a003d 70202020 3d736572     preq=..    pres=
   1fd28:	20200a00 31702020 200a003d 70202020     ..    p1=..    p
   1fd38:	0a003d32 20202020 5f74756f 5f636e65     2=..    out_enc_
   1fd48:	61746164 200a003d 72202020 64253d63     data=..    rc=%d
   1fd58:	6c62000a 6d735f65 676c615f 2834665f     ..ble_sm_alg_f4(
   1fd68:	20200a29 3d752020 20200a00 3d762020     ).    u=..    v=
   1fd78:	20200a00 3d782020 20200a00 3d7a2020     ..    x=..    z=
   1fd88:	30257830 000a7832 5f656c62 615f6d73     0x%02x..ble_sm_a
   1fd98:	665f676c 0a292835 6e007700 326e0031     lg_f5()..w.n1.n2
   1fda8:	63616d00 0079656b 006b746c 5f656c62     .mackey.ltk.ble_
   1fdb8:	615f6d73 665f676c 0a292836 636f6900     sm_alg_f6()..ioc
   1fdc8:	61007061 61007431 32610031 32610074     ap.a1t.a1.a2t.a2
   1fdd8:	73657200 656c6200 5f6d735f 5f676c61     .res.ble_sm_alg_
   1fde8:	29283267 0076000a 20202020 73736170     g2()..v.    pass
   1fdf8:	3d79656b 000a7525 635f6f69 253d7061     key=%u..io_cap=%
   1fe08:	6f6f2064 61645f62 665f6174 3d67616c     d oob_data_flag=
   1fe18:	61206425 72687475 303d7165 32302578     %d authreq=0x%02
   1fe28:	616d2078 6e655f63 656b5f63 69735f79     x mac_enc_key_si
   1fe38:	253d657a 6e692064 6b5f7469 645f7965     ze=%d init_key_d
   1fe48:	3d747369 72206425 5f707365 5f79656b     ist=%d resp_key_
   1fe58:	74736964 0064253d 76007874 65756c61     dist=%d.tx.value
   1fe68:	6572003d 6e6f7361 0064253d 76696465     =.reason=%d.ediv
   1fe78:	2578303d 20783430 6e617200 78303d64     =0x%04x .rand=0x
   1fe88:	36313025 00786c6c 3d6b7269 67697300     %016llx.irk=.sig
   1fe98:	79656b5f 7561003d 65726874 78303d71     _key=.authreq=0x
   1fea8:	78323025 656c6200 5f6d735f 2e646d63     %02x.ble_sm_cmd.
   1feb8:	75700063 63696c62 79656b20 6b686400     c.public key.dhk
   1fec8:	63207965 6b636568 03000000                       ey check.

0001fed1 <ble_sm_lgcy_resp_ioa>:
   1fed1:	00030000 03000003 02020300 00020002     ................
   1fee1:	00000000 00030202 02000002                       .........

0001feea <ble_sm_lgcy_init_ioa>:
   1feea:	00020000 02000002 03030200 00030002     ................
   1fefa:	00000000 00020303 73694403 6e6e6f63     .........Disconn
   1ff0a:	69746365 43206e6f 6c706d6f 3a657465     ection Complete:
   1ff1a:	61747320 3d737574 68207525 6c646e61      status=%u handl
   1ff2a:	75253d65 61657220 3d6e6f73 000a7525     e=%u reason=%u..
   1ff3a:	72636e45 20747079 2079656b 72666572     Encrypt key refr
   1ff4a:	3a687365 61747320 3d737574 68207525     esh: status=%u h
   1ff5a:	6c646e61 75253d65 6e45000a 70797263     andle=%u..Encryp
   1ff6a:	68632074 65676e61 7473203a 73757461     t change: status
   1ff7a:	2075253d 646e6168 253d656c 74732075     =%u handle=%u st
   1ff8a:	3d657461 000a7525 6f6d6552 56206574     ate=%u..Remote V
   1ff9a:	69737265 49206e6f 3a6f666e 61747320     ersion Info: sta
   1ffaa:	3d737574 68207525 6c646e61 75253d65     tus=%u handle=%u
   1ffba:	72657620 726e5f73 2075253d 706d6f63      vers_nr=%u comp
   1ffca:	253d6469 75732075 72657662 0a75253d     id=%u subver=%u.
   1ffda:	766e4900 64696c61 6d6f6320 646e616d     .Invalid command
   1ffea:	6d6f6320 74656c70 6c203a65 253d6e65      complete: len=%
   1fffa:	65282064 63657078 20646574 33203d3e     d (expected >= 3
   2000a:	6f430029 6e616d6d 6f632064 656c706d     ).Command comple
   2001a:	203a6574 5f646d63 73746b70 2075253d     te: cmd_pkts=%u 
   2002a:	3d66676f 78257830 66636f20 2578303d     ogf=0x%x ocf=0x%
   2003a:	73200078 75746174 75253d73 63680020     x. status=%u .hc
   2004a:	65765f69 75253d72 69636820 7665725f     i_ver=%u hci_rev
   2005a:	2075253d 5f706d6c 3d726576 6d207525     =%u lmp_ver=%u m
   2006a:	3d677266 6c207525 735f706d 65766275     frg=%u lmp_subve
   2007a:	75253d72 70757300 6d635f70 003d7364     r=%u.supp_cmds=.
   2008a:	78323025 3230253a 30253a78 253a7832     %02x:%02x:%02x:%
   2009a:	3a783230 78323025 3230253a 30253a78     02x:%02x:%02x:%0
   200aa:	253a7832 3a783230 70757300 65665f70     2x:%02x:.supp_fe
   200ba:	303d7461 786c2578 6c383025 64620078     at=0x%lx%08lx.bd
   200ca:	6464615f 78253d72 3a78253a 253a7825     _addr=%x:%x:%x:%
   200da:	78253a78 0078253a 646e6168 253d656c     x:%x:%x.handle=%
   200ea:	73722075 253d6973 61680064 656c646e     u rssi=%d.handle
   200fa:	2075253d 6e616863 3d70616d 252e7825     =%u chanmap=%x.%
   2010a:	78252e78 2e78252e 74007825 74636f78     x.%x.%x.%x.txoct
   2011a:	2075253d 69747874 253d656d 78722075     =%u txtime=%u rx
   2012a:	3d74636f 72207525 6d697478 75253d65     oct=%u rxtime=%u
   2013a:	61747300 3d736574 6c257830 38302578     .states=0x%lx%08
   2014a:	6500786c 6164636e 303d6174 32302578     lx.encdata=0x%02
   2015a:	32302578 32302578 32302578 32302578     x%02x%02x%02x%02
   2016a:	32302578 32302578 32302578 61720078     x%02x%02x%02x.ra
   2017a:	303d646e 32302578 32302578 32302578     nd=0x%02x%02x%02
   2018a:	32302578 32302578 32302578 32302578     x%02x%02x%02x%02
   2019a:	32302578 78740078 3d74636f 74207525     x%02x.txoct=%u t
   201aa:	6d697478 75253d65 6e616800 3d656c64     xtime=%u.handle=
   201ba:	43007525 616d6d6f 5320646e 75746174     %u.Command Statu
   201ca:	73203a73 75746174 75253d73 646d6320     s: status=%u cmd
   201da:	746b705f 75253d73 66636f20 2578303d     _pkts=%u ocf=0x%
   201ea:	676f2078 78303d66 000a7825 3a525245     x ogf=0x%x..ERR:
   201fa:	6d754e20 20726562 4320666f 6c706d6f      Number of Compl
   2020a:	64657465 63615020 7374656b 64616220     eted Packets bad
   2021a:	6e656c20 3a687467 6d756e20 6e61685f      length: num_han
   2022a:	73656c64 2075253d 3d6e656c 000a7525     dles=%u len=%u..
   2023a:	626d754e 6f207265 6f432066 656c706d     Number of Comple
   2024a:	20646574 6b636150 3a737465 6d756e20     ted Packets: num
   2025a:	6e61685f 73656c64 0a75253d 6e616800     _handles=%u..han
   2026a:	3a656c64 70207525 3a73746b 000a7525     dle:%u pkts:%u..
   2027a:	6320454c 656e6e6f 6f697463 6f63206e     LE connection co
   2028a:	656c706d 202e6574 646e6168 253d656c     mplete. handle=%
   2029a:	6f722075 253d656c 61702075 74726464     u role=%u paddrt
   202aa:	3d657079 61207525 3d726464 252e7825     ype=%u addr=%x.%
   202ba:	78252e78 2e78252e 252e7825 6c002078     x.%x.%x.%x.%x .l
   202ca:	6c61636f 6170725f 2e78253d 252e7825     ocal_rpa=%x.%x.%
   202da:	78252e78 2e78252e 70207825 5f726565     x.%x.%x.%x peer_
   202ea:	3d617072 252e7825 78252e78 2e78252e     rpa=%x.%x.%x.%x.
   202fa:	252e7825 69002078 3d6c7674 6c207525     %x.%x .itvl=%u l
   2030a:	6e657461 253d7963 70732075 745f6e76     atency=%u spvn_t
   2031a:	253d6f6d 636d2075 75253d61 454c000a     mo=%u mca=%u..LE
   2032a:	6e6f6320 7463656e 206e6f69 706d6f63      connection comp
   2033a:	6574656c 4146202e 28204c49 74617473     lete. FAIL (stat
   2034a:	253d7375 000a2975 6120454c 72657664     us=%u)..LE adver
   2035a:	69736974 7220676e 726f7065 6c202e74     tising report. l
   2036a:	253d6e65 756e2075 75253d6d 74766520     en=%u num=%u evt
   2037a:	3d657079 61207525 74726464 3d657079     ype=%u addrtype=
   2038a:	61207525 3d726464 252e7825 78252e78     %u addr=%x.%x.%x
   2039a:	2e78252e 252e7825 64612078 6e656c76     .%x.%x.%x advlen
   203aa:	2075253d 69737372 0a64253d 0a732500     =%u rssi=%d..%s.
   203ba:	20454c00 6e6e6f43 69746365 55206e6f     .LE Connection U
   203ca:	74616470 6f432065 656c706d 202e6574     pdate Complete. 
   203da:	646e6168 253d656c 74692075 253d6c76     handle=%u itvl=%
   203ea:	616c2075 636e6574 75253d79 6d697420     u latency=%u tim
   203fa:	74756f65 0a75253d 20454c00 6e6e6f43     eout=%u..LE Conn
   2040a:	69746365 55206e6f 74616470 6f432065     ection Update Co
   2041a:	656c706d 202e6574 4c494146 74732820     mplete. FAIL (st
   2042a:	73757461 2975253d 454c000a 74614420     atus=%u)..LE Dat
   2043a:	654c2061 6874676e 61684320 2e65676e     a Length Change.
   2044a:	6e616820 3d656c64 6d207525 745f7861      handle=%u max_t
   2045a:	79625f78 3d736574 6d207525 745f7861     x_bytes=%u max_t
   2046a:	69745f78 253d656d 616d2075 78725f78     x_time=%u max_rx
   2047a:	7479625f 253d7365 616d2075 78725f78     _bytes=%u max_rx
   2048a:	6d69745f 75253d65 454c000a 6d655220     _time=%u..LE Rem
   2049a:	2065746f 6e6e6f43 69746365 50206e6f     ote Connection P
   204aa:	6d617261 72657465 71655220 74736575     arameter Request
   204ba:	6168202e 656c646e 2075253d 5f6e696d     . handle=%u min_
   204ca:	6c767469 2075253d 5f78616d 6c767469     itvl=%u max_itvl
   204da:	2075253d 6574616c 3d79636e 74207525     =%u latency=%u t
   204ea:	6f656d69 253d7475 4c000a75 65522045     imeout=%u..LE Re
   204fa:	65746f6d 65735520 65462064 72757461     mote Used Featur
   2050a:	202e7365 646e6168 253d656c 65662075     es. handle=%u fe
   2051a:	003d7461 5220454c 746f6d65 73552065     at=.LE Remote Us
   2052a:	46206465 75746165 2e736572 49414620     ed Features. FAI
   2053a:	7328204c 75746174 75253d73 4c000a29     L (status=%u)..L
   2054a:	544c2045 6552204b 68202e71 6c646e61     E LTK Req. handl
   2055a:	75253d65 6e617220 6c253d64 786c2578     e=%u rand=%lx%lx
   2056a:	636e6520 3d766964 000a7525 6b6e5509      encdiv=%u...Unk
   2057a:	6e776f6e 20454c20 6e657665 45000a74     nown LE event..E
   2058a:	203a5252 68747541 646c7950 456f6d54     RR: AuthPyldTmoE
   2059a:	746e6576 64616220 6e656c20 20687467     vent bad length 
   205aa:	000a7525 68747541 646c7950 3a6f6d54     %u..AuthPyldTmo:
   205ba:	6e616820 3d656c64 000a7525 6e6b6e55      handle=%u..Unkn
   205ca:	206e776f 6e657665 78302074 6c207825     own event 0x%x l
   205da:	253d6e65 68000a75 5f74736f 5f696368     en=%u..host_hci_
   205ea:	61746164 2878725f 68203a29 6c646e61     data_rx(): handl
   205fa:	75253d65 3d627020 6c207825 253d6e65     e=%u pb=%x len=%
   2060a:	61642075 003d6174 74736f68 20787420     u data=.host tx 
   2061a:	20696368 61746164 6168203b 656c646e     hci data; handle
   2062a:	2064253d 676e656c 253d6874 68000a64     =%d length=%d..h
   2063a:	5f74736f 5f696368 61746164 2878745f     ost_hci_data_tx(
   2064a:	00203a29 00010000                                ): ...

00020650 <host_hci_le_event_dispatch>:
   20650:	00000001 00019079 00000002 00018d6d     ....y.......m...
   20660:	00000003 00018ffb 00000005 00018fbb     ................
   20670:	00000006 00018f37 0000000a 00019079     ....7.......y...
   20680:	0000000b 00018e6d                       ....m...

00020688 <host_hci_event_dispatch>:
   20688:	00000005 000191a9 00000008 0001917b     ............{...
   20698:	00000013 00018f01 00000030 00019153     ........0...S...
   206a8:	0000003e 00018e35 74736f68 6963685f     >...5...host_hci
   206b8:	646d635f 6e65735f 6f203a64 303d6667     _cmd_send: ogf=0
   206c8:	32302578 636f2078 78303d66 78323025     x%02x ocf=0x%02x
   206d8:	6e656c20 0a64253d 736f6800 63685f74      len=%d..host_hc
   206e8:	6d635f69 65735f64 6620646e 756c6961     i_cmd_send failu
   206f8:	203b6572 253d6372 00000a64              re; rc=%d...

00020704 <ble_att_rx_dispatch>:
   20704:	00000001 00019f49 00000002 0001b4f9     ....I...........
   20714:	00000003 00019fbd 00000004 0001b635     ............5...
   20724:	00000005 0001a0e1 00000006 0001b7fd     ................
   20734:	00000007 0001a26d 00000008 0001ba05     ....m...........
   20744:	00000009 0001a391 0000000a 0001bc59     ............Y...
   20754:	0000000b 0001a4dd 0000000c 0001bd8d     ................
   20764:	0000000d 0001a5e1 0000000e 0001bee1     ................
   20774:	0000000f 0001a655 00000010 0001c059     ....U.......Y...
   20784:	00000011 0001a76d 00000012 0001c31d     ....m...........
   20794:	00000013 0001a83d 00000016 0001c4ed     ....=...........
   207a4:	00000017 0001a94d 00000018 0001c709     ....M...........
   207b4:	00000019 0001aa7d 0000001b 0001c8a5     ....}...........
   207c4:	0000001d 0001c959 0000001e 0001ac2d     ....Y.......-...
   207d4:	00000052 0001c43d 5f656c62 00747461     R...=...ble_att.
   207e4:	6f727265 73722072 746d0070 65722075     error rsp.mtu re
   207f4:	746d0071 73722075 69660070 6920646e     q.mtu rsp.find i
   20804:	206f666e 00716572 646e6966 666e6920     nfo req.find inf
   20814:	7372206f 69660070 7420646e 20657079     o rsp.find type 
   20824:	756c6176 65722065 69660071 7420646e     value req.find t
   20834:	20657079 756c6176 73722065 65720070     ype value rsp.re
   20844:	74206461 20657079 00716572 64616572     ad type req.read
   20854:	70797420 73722065 65720070 72206461      type rsp.read r
   20864:	72007165 20646165 00707372 64616572     eq.read rsp.read
   20874:	6f6c6220 65722062 65720071 62206461      blob req.read b
   20884:	20626f6c 00707372 64716572 6c756d20     lob rsp.reqd mul
   20894:	65722074 65720071 6d206461 20746c75     t req.read mult 
   208a4:	00707372 64616572 6f726720 74207075     rsp.read group t
   208b4:	20657079 00716572 64616572 6f726720     ype req.read gro
   208c4:	74207075 20657079 00707372 74697277     up type rsp.writ
   208d4:	6d632065 72700064 77207065 65746972     e cmd.prep write
   208e4:	71657220 65727000 72772070 20657469      req.prep write 
   208f4:	00707372 63657865 69727720 72206574     rsp.exec write r
   20904:	65007165 20636578 74697277 73722065     eq.exec write rs
   20914:	6f6e0070 79666974 71657220 646e6900     p.notify req.ind
   20924:	74616369 65722065 6e690071 61636964     icate req.indica
   20934:	72206574 72007073 6f5f7165 64253d70     te rsp.req_op=%d
   20944:	6e616820 3d656c64 30257830 65207834      handle=0x%04x e
   20954:	726f7272 646f635f 64253d65 75746d00     rror_code=%d.mtu
   20964:	0064253d 72617473 61685f74 656c646e     =%d.start_handle
   20974:	2578303d 20783430 5f646e65 646e6168     =0x%04x end_hand
   20984:	303d656c 34302578 6f660078 74616d72     le=0x%04x.format
   20994:	0064253d 72617473 61685f74 656c646e     =%d.start_handle
   209a4:	2578303d 20783430 5f646e65 646e6168     =0x%04x end_hand
   209b4:	303d656c 34302578 74612078 745f7274     le=0x%04x attr_t
   209c4:	3d657079 6c006425 74676e65 64253d68     ype=%d.length=%d
   209d4:	6e616800 3d656c64 30257830 6f207834     .handle=0x%04x o
   209e4:	65736666 64253d74 616c6600 303d7367     ffset=%d.flags=0
   209f4:	32302578 65720078 6d206461 20746c75     x%02x.read mult 
   20a04:	00716572 5f656c62 5f747461 5f727673     req.ble_att_svr_
   20a14:	72746e65 6f705f79 62006c6f 615f656c     entry_pool.ble_a
   20a24:	735f7474 705f7276 5f706572 72746e65     tt_svr_prep_entr
   20a34:	6f705f79 00006c6f                       y_pool..

00020a3c <ble_svc_gap_defs>:
   20a3c:	00000001 20000258 00000000 200002c8     ....X.. ....... 
	...
   20a5c:	5f656c62 5f637673 2e706167 6c620063     ble_svc_gap.c.bl
   20a6c:	76735f65 61675f63 632e7474 00000000     e_svc_gatt.c....

00020a7c <ble_svc_gatt_defs>:
   20a7c:	00000001 20000368 00000000 20000388     ....h.. ....... 
	...
   20a9c:	76696465 2075253d 646e6172 6c6c253d     ediv=%u rand=%ll
   20aac:	75612075 6e656874 61636974 3d646574     u authenticated=
   20abc:	6c206425 003d6b74 6b727363 6465003d     %d ltk=.csrk=.ed
   20acc:	303d7669 32302578 61722078 303d646e     iv=0x%02x rand=0
   20adc:	6c6c2578 6c002078 696b6f6f 7520676e     x%llx .looking u
   20aec:	65702070 73207265 203b6365 6f6f6c00     p peer sec; .loo
   20afc:	676e696b 20707520 2072756f 3b636573     king up our sec;
   20b0c:	65700020 73697372 676e6974 65657020      .persisting pee
   20b1c:	65732072 00203b63 6f727265 65702072     r sec; .error pe
   20b2c:	73697372 676e6974 65657020 65732072     rsisting peer se
   20b3c:	74203b63 6d206f6f 20796e61 72746e65     c; too many entr
   20b4c:	20736569 29642528 6570000a 73697372     ies (%d)..persis
   20b5c:	676e6974 72756f20 63657320 6500203b     ting our sec; .e
   20b6c:	726f7272 72657020 74736973 20676e69     rror persisting 
   20b7c:	2072756f 3b636573 6f6f7420 6e616d20     our sec; too man
   20b8c:	6e652079 65697274 25282073 000a2964     y entries (%d)..
   20b9c:	6f727265 65702072 73697372 676e6974     error persisting
   20bac:	63636320 74203b64 6d206f6f 20796e61      cccd; too many 
   20bbc:	72746e65 20736569 29642528 0800000a              entries (%d)..

00020bca <g_ble_hci_le_cmd_len>:
   20bca:	00000800 000f0600 07012020 00001902     ........  ......
   20bda:	0e070700 20020205 02121c00 00030100     ....... ........
   20bea:	0006030e 27400004 07000007 00020107     ......@'........
   20bfa:	3d73745b 73756c25 202c6273 3d646f6d     [ts=%lussb, mod=
   20c0a:	6c207525 6c657665 5d75253d 74730020     %u level=%u] .st
   20c1a:	68007461 6f5f6c61 69745f73 632e6b63     at.hal_os_tick.c
   20c2a:	6c616800 7261755f 00632e74 0c440000              .hal_uart.c...

00020c38 <console_file>:
   20c38:	00020c44 3a756c25 00000000              D...%lu:....

00020c44 <console_file_ops>:
   20c44:	00009755 00000000                       U.......

00020c4c <FSb>:
   20c4c:	7b777c63 c56f6bf2 2b670130 76abd7fe     c|w{.ko.0.g+...v
   20c5c:	7dc982ca f04759fa afa2d4ad c072a49c     ...}.YG.......r.
   20c6c:	2693fdb7 ccf73f36 f1e5a534 1531d871     ...&6?..4...q.1.
   20c7c:	c323c704 9a059618 e2801207 75b227eb     ..#..........'.u
   20c8c:	1a2c8309 a05a6e1b b3d63b52 842fe329     ..,..nZ.R;..)./.
   20c9c:	ed00d153 5bb1fc20 39becb6a cf584c4a     S... ..[j..9JLX.
   20cac:	fbaaefd0 85334d43 7f02f945 a89f3c50     ....CM3.E...P<..
   20cbc:	8f40a351 f5389d92 21dab6bc d2f3ff10     Q.@...8....!....
   20ccc:	ec130ccd 1744975f 3d7ea7c4 73195d64     ...._.D...~=d].s
   20cdc:	dc4f8160 88902a22 14b8ee46 db0b5ede     `.O."*..F....^..
   20cec:	0a3a32e0 5c240649 62acd3c2 79e49591     .2:.I.$\...b...y
   20cfc:	6d37c8e7 a94ed58d eaf4566c 08ae7a65     ..7m..N.lV..ez..
   20d0c:	2e2578ba c6b4a61c 1f74dde8 8a8bbd4b     .x%.......t.K...
   20d1c:	66b53e70 0ef60348 b9573561 9e1dc186     p>.fH...a5W.....
   20d2c:	1198f8e1 948ed969 e9871e9b df2855ce     ....i........U(.
   20d3c:	0d89a18c 6842e6bf 0f2d9941 16bb54b0     ......BhA.-..T..

00020d4c <RT0>:
   20d4c:	50a7f451 5365417e c3a4171a 965e273a     Q..P~AeS....:'^.
   20d5c:	cb6bab3b f1459d1f ab58faac 9303e34b     ;.k...E...X.K...
   20d6c:	55fa3020 f66d76ad 9176cc88 254c02f5      0.U.vm...v...L%
   20d7c:	fcd7e54f d7cb2ac5 80443526 8fa362b5     O....*..&5D..b..
   20d8c:	495ab1de 671bba25 980eea45 e1c0fe5d     ..ZI%..gE...]...
   20d9c:	02752fc3 12f04c81 a397468d c6f9d36b     ./u..L...F..k...
   20dac:	e75f8f03 959c9215 eb7a6dbf da595295     .._......mz..RY.
   20dbc:	2d83bed4 d3217458 2969e049 44c8c98e     ...-Xt!.I.i)...D
   20dcc:	6a89c275 78798ef4 6b3e5899 dd71b927     u..j..yx.X>k'.q.
   20ddc:	b64fe1be 17ad88f0 66ac20c9 b43ace7d     ..O...... .f}.:.
   20dec:	184adf63 82311ae5 60335197 457f5362     c.J...1..Q3`bS.E
   20dfc:	e07764b1 84ae6bbb 1ca081fe 942b08f9     .dw..k........+.
   20e0c:	58684870 19fd458f 876cde94 b7f87b52     pHhX.E....l.R{..
   20e1c:	23d373ab e2024b72 578f1fe3 2aab5566     .s.#rK.....WfU.*
   20e2c:	0728ebb2 03c2b52f 9a7bc586 a50837d3     ..(./.....{..7..
   20e3c:	f2872830 b2a5bf23 ba6a0302 5c8216ed     0(..#.....j....\
   20e4c:	2b1ccf8a 92b479a7 f0f207f3 a1e2694e     ...+.y......Ni..
   20e5c:	cdf4da65 d5be0506 1f6234d1 8afea6c4     e........4b.....
   20e6c:	9d532e34 a055f3a2 32e18a05 75ebf6a4     4.S...U....2...u
   20e7c:	39ec830b aaef6040 069f715e 51106ebd     ...9@`..^q...n.Q
   20e8c:	f98a213e 3d06dd96 ae053edd 46bde64d     >!.....=.>..M..F
   20e9c:	b58d5491 055dc471 6fd40604 ff155060     .T..q.]....o`P..
   20eac:	24fb9819 97e9bdd6 cc434089 779ed967     ...$.....@C.g..w
   20ebc:	bd42e8b0 888b8907 385b19e7 dbeec879     ..B.......[8y...
   20ecc:	470a7ca1 e90f427c c91e84f8 00000000     .|.G|B..........
   20edc:	83868009 48ed2b32 ac70111e 4e725a6c     ....2+.H..p.lZrN
   20eec:	fbff0efd 5638850f 1ed5ae3d 27392d36     ......8V=...6-9'
   20efc:	64d90f0a 21a65c68 d1545b9b 3a2e3624     ...dh\.!.[T.$6.:
   20f0c:	b1670a0c 0fe75793 d296eeb4 9e919b1b     ..g..W..........
   20f1c:	4fc5c080 a220dc61 694b775a 161a121c     ...Oa. .ZwKi....
   20f2c:	0aba93e2 e52aa0c0 43e0223c 1d171b12     ......*.<".C....
   20f3c:	0b0d090e adc78bf2 b9a8b62d c8a91e14     ........-.......
   20f4c:	8519f157 4c0775af bbdd99ee fd607fa3     W....u.L......`.
   20f5c:	9f2601f7 bcf5725c c53b6644 347efb5b     ..&.\r..Df;.[.~4
   20f6c:	7629438b dcc623cb 68fcedb6 63f1e4b8     .C)v.#.....h...c
   20f7c:	cadc31d7 10856342 40229713 2011c684     .1..Bc...."@... 
   20f8c:	7d244a85 f83dbbd2 1132f9ae 6da129c7     .J$}..=...2..).m
   20f9c:	4b2f9e1d f330b2dc ec52860d d0e3c177     ../K..0...R.w...
   20fac:	6c16b32b 99b970a9 fa489411 2264e947     +..l.p....H.G.d"
   20fbc:	c48cfca8 1a3ff0a0 d82c7d56 ef903322     ......?.V},."3..
   20fcc:	c74e4987 c1d138d9 fea2ca8c 360bd498     .IN..8.........6
   20fdc:	cf81f5a6 28de7aa5 268eb7da a4bfad3f     .....z.(...&?...
   20fec:	e49d3a2c 0d927850 9bcc5f6a 62467e54     ,:..Px..j_..T~Fb
   20ffc:	c2138df6 e8b8d890 5ef7392e f5afc382     .........9.^....
   2100c:	be805d9f 7c93d069 a92dd56f b31225cf     .]..i..|o.-..%..
   2101c:	3b99acc8 a77d1810 6e639ce8 7bbb3bdb     ...;..}...cn.;.{
   2102c:	097826cd f418596e 01b79aec a89a4f83     .&x.nY.......O..
   2103c:	656e95e6 7ee6ffaa 08cfbc21 e6e815ef     ..ne...~!.......
   2104c:	d99be7ba ce366f4a d4099fea d67cb029     ....Jo6.....).|.
   2105c:	afb2a431 31233f2a 3094a5c6 c066a235     1...*?#1...05.f.
   2106c:	37bc4e74 a6ca82fc b0d090e0 15d8a733     tN.7........3...
   2107c:	4a9804f1 f7daec41 0e50cd7f 2ff69117     ...JA.....P..../
   2108c:	8dd64d76 4db0ef43 544daacc df0496e4     vM..C..M..MT....
   2109c:	e3b5d19e 1b886a4c b81f2cc1 7f516546     ....Lj...,..FeQ.
   210ac:	04ea5e9d 5d358c01 737487fa 2e410bfb     .^....5]..ts..A.
   210bc:	5a1d67b3 52d2db92 335610e9 1347d66d     .g.Z...R..V3m.G.
   210cc:	8c61d79a 7a0ca137 8e14f859 893c13eb     ..a.7..zY.....<.
   210dc:	ee27a9ce 35c961b7 ede51ce1 3cb1477a     ..'..a.5....zG.<
   210ec:	59dfd29c 3f73f255 79ce1418 bf37c773     ...YU.s?...ys.7.
   210fc:	eacdf753 5baafd5f 146f3ddf 86db4478     S..._..[.=o.xD..
   2110c:	81f3afca 3ec468b9 2c342438 5f40a3c2     .....h.>8$4,..@_
   2111c:	72c31d16 0c25e2bc 8b493c28 41950dff     ...r..%.(<I....A
   2112c:	7101a839 deb30c08 9ce4b4d8 90c15664     9..q........dV..
   2113c:	6184cb7b 70b632d5 745c6c48 4257b8d0     {..a.2.pHl\t..WB

0002114c <RT1>:
   2114c:	a7f45150 65417e53 a4171ac3 5e273a96     PQ..S~Ae.....:'^
   2115c:	6bab3bcb 459d1ff1 58faacab 03e34b93     .;.k...E...X.K..
   2116c:	fa302055 6d76adf6 76cc8891 4c02f525     U 0...vm...v%..L
   2117c:	d7e54ffc cb2ac5d7 44352680 a362b58f     .O....*..&5D..b.
   2118c:	5ab1de49 1bba2567 0eea4598 c0fe5de1     I..Zg%...E...]..
   2119c:	752fc302 f04c8112 97468da3 f9d36bc6     ../u..L...F..k..
   211ac:	5f8f03e7 9c921595 7a6dbfeb 595295da     ..._......mz..RY
   211bc:	83bed42d 217458d3 69e04929 c8c98e44     -....Xt!)I.iD...
   211cc:	89c2756a 798ef478 3e58996b 71b927dd     ju..x..yk.X>.'.q
   211dc:	4fe1beb6 ad88f017 ac20c966 3ace7db4     ...O....f. ..}.:
   211ec:	4adf6318 311ae582 33519760 7f536245     .c.J...1`.Q3EbS.
   211fc:	7764b1e0 ae6bbb84 a081fe1c 2b08f994     ..dw..k........+
   2120c:	68487058 fd458f19 6cde9487 f87b52b7     XpHh..E....l.R{.
   2121c:	d373ab23 024b72e2 8f1fe357 ab55662a     #.s..rK.W...*fU.
   2122c:	28ebb207 c2b52f03 7bc5869a 0837d3a5     ...(./.....{..7.
   2123c:	872830f2 a5bf23b2 6a0302ba 8216ed5c     .0(..#.....j\...
   2124c:	1ccf8a2b b479a792 f207f3f0 e2694ea1     +.....y......Ni.
   2125c:	f4da65cd be0506d5 6234d11f fea6c48a     .e........4b....
   2126c:	532e349d 55f3a2a0 e18a0532 ebf6a475     .4.S...U2...u...
   2127c:	ec830b39 ef6040aa 9f715e06 106ebd51     9....@`..^q.Q.n.
   2128c:	8a213ef9 06dd963d 053eddae bde64d46     .>!.=.....>.FM..
   2129c:	8d5491b5 5dc47105 d406046f 155060ff     ..T..q.]o....`P.
   212ac:	fb981924 e9bdd697 434089cc 9ed96777     $.........@Cwg..
   212bc:	42e8b0bd 8b890788 5b19e738 eec879db     ...B....8..[.y..
   212cc:	0a7ca147 0f427ce9 1e84f8c9 00000000     G.|..|B.........
   212dc:	86800983 ed2b3248 70111eac 725a6c4e     ....H2+....pNlZr
   212ec:	ff0efdfb 38850f56 d5ae3d1e 392d3627     ....V..8.=..'6-9
   212fc:	d90f0a64 a65c6821 545b9bd1 2e36243a     d...!h\...[T:$6.
   2130c:	670a0cb1 e757930f 96eeb4d2 919b1b9e     ...g..W.........
   2131c:	c5c0804f 20dc61a2 4b775a69 1a121c16     O....a. iZwK....
   2132c:	ba93e20a 2aa0c0e5 e0223c43 171b121d     .......*C<".....
   2133c:	0d090e0b c78bf2ad a8b62db9 a91e14c8     .........-......
   2134c:	19f15785 0775af4c dd99eebb 607fa3fd     .W..L.u........`
   2135c:	2601f79f f5725cbc 3b6644c5 7efb5b34     ...&.\r..Df;4[.~
   2136c:	29438b76 c623cbdc fcedb668 f1e4b863     v.C)..#.h...c...
   2137c:	dc31d7ca 85634210 22971340 11c68420     ..1..Bc.@.." ...
   2138c:	244a857d 3dbbd2f8 32f9ae11 a129c76d     }.J$...=...2m.).
   2139c:	2f9e1d4b 30b2dcf3 52860dec e3c177d0     K../...0...R.w..
   213ac:	16b32b6c b970a999 489411fa 64e94722     l+....p....H"G.d
   213bc:	8cfca8c4 3ff0a01a 2c7d56d8 903322ef     .......?.V},."3.
   213cc:	4e4987c7 d138d9c1 a2ca8cfe 0bd49836     ..IN..8.....6...
   213dc:	81f5a6cf de7aa528 8eb7da26 bfad3fa4     ....(.z.&....?..
   213ec:	9d3a2ce4 9278500d cc5f6a9b 467e5462     .,:..Px..j_.bT~F
   213fc:	138df6c2 b8d890e8 f7392e5e afc382f5     ........^.9.....
   2140c:	805d9fbe 93d0697c 2dd56fa9 1225cfb3     ..].|i...o.-..%.
   2141c:	99acc83b 7d1810a7 639ce86e bb3bdb7b     ;......}n..c{.;.
   2142c:	7826cd09 18596ef4 b79aec01 9a4f83a8     ..&x.nY.......O.
   2143c:	6e95e665 e6ffaa7e cfbc2108 e815efe6     e..n~....!......
   2144c:	9be7bad9 366f4ace 099fead4 7cb029d6     .....Jo6.....).|
   2145c:	b2a431af 233f2a31 94a5c630 66a235c0     .1..1*?#0....5.f
   2146c:	bc4e7437 ca82fca6 d090e0b0 d8a73315     7tN..........3..
   2147c:	9804f14a daec41f7 50cd7f0e f691172f     J....A.....P/...
   2148c:	d64d768d b0ef434d 4daacc54 0496e4df     .vM.MC..T..M....
   2149c:	b5d19ee3 886a4c1b 1f2cc1b8 5165467f     .....Lj...,..FeQ
   214ac:	ea5e9d04 358c015d 7487fa73 410bfb2e     ..^.]..5s..t...A
   214bc:	1d67b35a d2db9252 5610e933 47d66d13     Z.g.R...3..V.m.G
   214cc:	61d79a8c 0ca1377a 14f8598e 3c13eb89     ...az7...Y.....<
   214dc:	27a9ceee c961b735 e51ce1ed b1477a3c     ...'5.a.....<zG.
   214ec:	dfd29c59 73f2553f ce141879 37c773bf     Y...?U.sy....s.7
   214fc:	cdf753ea aafd5f5b 6f3ddf14 db447886     .S..[_....=o.xD.
   2150c:	f3afca81 c468b93e 3424382c 40a3c25f     ....>.h.,8$4_..@
   2151c:	c31d1672 25e2bc0c 493c288b 950dff41     r......%.(<IA...
   2152c:	01a83971 b30c08de e4b4d89c c1566490     q9...........dV.
   2153c:	84cb7b61 b632d570 5c6c4874 57b8d042     a{..p.2.tHl\B..W

0002154c <RT2>:
   2154c:	f45150a7 417e5365 171ac3a4 273a965e     .PQ.eS~A....^.:'
   2155c:	ab3bcb6b 9d1ff145 faacab58 e34b9303     k.;.E...X.....K.
   2156c:	302055fa 76adf66d cc889176 02f5254c     .U 0m..vv...L%..
   2157c:	e54ffcd7 2ac5d7cb 35268044 62b58fa3     ..O....*D.&5...b
   2158c:	b1de495a ba25671b ea45980e fe5de1c0     ZI...g%...E...].
   2159c:	2fc30275 4c8112f0 468da397 d36bc6f9     u../...L...F..k.
   215ac:	8f03e75f 9215959c 6dbfeb7a 5295da59     _.......z..mY..R
   215bc:	bed42d83 7458d321 e0492969 c98e44c8     .-..!.Xti)I..D..
   215cc:	c2756a89 8ef47879 58996b3e b927dd71     .ju.yx..>k.Xq.'.
   215dc:	e1beb64f 88f017ad 20c966ac ce7db43a     O........f. :.}.
   215ec:	df63184a 1ae58231 51976033 5362457f     J.c.1...3`.Q.EbS
   215fc:	64b1e077 6bbb84ae 81fe1ca0 08f9942b     w..d...k....+...
   2160c:	48705868 458f19fd de94876c 7b52b7f8     hXpH...El.....R{
   2161c:	73ab23d3 4b72e202 1fe3578f 55662aab     .#.s..rK.W...*fU
   2162c:	ebb20728 b52f03c2 c5869a7b 37d3a508     (...../.{......7
   2163c:	2830f287 bf23b2a5 0302ba6a 16ed5c82     ..0(..#.j....\..
   2164c:	cf8a2b1c 79a792b4 07f3f0f2 694ea1e2     .+.....y......Ni
   2165c:	da65cdf4 0506d5be 34d11f62 a6c48afe     ..e.....b..4....
   2166c:	2e349d53 f3a2a055 8a0532e1 f6a475eb     S.4.U....2...u..
   2167c:	830b39ec 6040aaef 715e069f 6ebd5110     .9....@`..^q.Q.n
   2168c:	213ef98a dd963d06 3eddae05 e64d46bd     ..>!.=.....>.FM.
   2169c:	5491b58d c471055d 06046fd4 5060ff15     ...T].q..o....`P
   216ac:	981924fb bdd697e9 4089cc43 d967779e     .$......C..@.wg.
   216bc:	e8b0bd42 8907888b 19e7385b c879dbee     B.......[8....y.
   216cc:	7ca1470a 427ce90f 84f8c91e 00000000     .G.|..|B........
   216dc:	80098386 2b3248ed 111eac70 5a6c4e72     .....H2+p...rNlZ
   216ec:	0efdfbff 850f5638 ae3d1ed5 2d362739     ....8V....=.9'6-
   216fc:	0f0a64d9 5c6821a6 5b9bd154 36243a2e     .d...!h\T..[.:$6
   2170c:	0a0cb167 57930fe7 eeb4d296 9b1b9e91     g......W........
   2171c:	c0804fc5 dc61a220 775a694b 121c161a     .O.. .a.KiZw....
   2172c:	93e20aba a0c0e52a 223c43e0 1b121d17     ....*....C<"....
   2173c:	090e0b0d 8bf2adc7 b62db9a8 1e14c8a9     ..........-.....
   2174c:	f1578519 75af4c07 99eebbdd 7fa3fd60     ..W..L.u....`...
   2175c:	01f79f26 725cbcf5 6644c53b fb5b347e     &.....\r;.Df~4[.
   2176c:	438b7629 23cbdcc6 edb668fc e4b863f1     )v.C...#.h...c..
   2177c:	31d7cadc 63421085 97134022 c6842011     ...1..Bc"@... ..
   2178c:	4a857d24 bbd2f83d f9ae1132 29c76da1     $}.J=...2....m.)
   2179c:	9e1d4b2f b2dcf330 860dec52 c177d0e3     /K..0...R.....w.
   217ac:	b32b6c16 70a999b9 9411fa48 e9472264     .l+....pH...d"G.
   217bc:	fca8c48c f0a01a3f 7d56d82c 3322ef90     ....?...,.V}.."3
   217cc:	4987c74e 38d9c1d1 ca8cfea2 d498360b     N..I...8.....6..
   217dc:	f5a6cf81 7aa528de b7da268e ad3fa4bf     .....(.z.&....?.
   217ec:	3a2ce49d 78500d92 5f6a9bcc 7e546246     ..,:..Px..j_FbT~
   217fc:	8df6c213 d890e8b8 392e5ef7 c382f5af     .........^.9....
   2180c:	5d9fbe80 d0697c93 d56fa92d 25cfb312     ...].|i.-.o....%
   2181c:	acc83b99 1810a77d 9ce86e63 3bdb7bbb     .;..}...cn...{.;
   2182c:	26cd0978 596ef418 9aec01b7 4f83a89a     x..&..nY.......O
   2183c:	95e6656e ffaa7ee6 bc2108cf 15efe6e8     ne...~....!.....
   2184c:	e7bad99b 6f4ace36 9fead409 b029d67c     ....6.Jo....|.).
   2185c:	a431afb2 3f2a3123 a5c63094 a235c066     ..1.#1*?.0..f.5.
   2186c:	4e7437bc 82fca6ca 90e0b0d0 a73315d8     .7tN..........3.
   2187c:	04f14a98 ec41f7da cd7f0e50 91172ff6     .J....A.P..../..
   2188c:	4d768dd6 ef434db0 aacc544d 96e4df04     ..vM.MC.MT......
   2189c:	d19ee3b5 6a4c1b88 2cc1b81f 65467f51     ......Lj...,Q.Fe
   218ac:	5e9d04ea 8c015d35 87fa7374 0bfb2e41     ...^5]..ts..A...
   218bc:	67b35a1d db9252d2 10e93356 d66d1347     .Z.g.R..V3..G.m.
   218cc:	d79a8c61 a1377a0c f8598e14 13eb893c     a....z7...Y.<...
   218dc:	a9ceee27 61b735c9 1ce1ede5 477a3cb1     '....5.a.....<zG
   218ec:	d29c59df f2553f73 141879ce c773bf37     .Y..s?U..y..7.s.
   218fc:	f753eacd fd5f5baa 3ddf146f 447886db     ..S..[_.o..=..xD
   2190c:	afca81f3 68b93ec4 24382c34 a3c25f40     .....>.h4,8$@_..
   2191c:	1d1672c3 e2bc0c25 3c288b49 0dff4195     .r..%...I.(<.A..
   2192c:	a8397101 0c08deb3 b4d89ce4 566490c1     .q9...........dV
   2193c:	cb7b6184 32d570b6 6c48745c b8d04257     .a{..p.2\tHlWB..

0002194c <RT3>:
   2194c:	5150a7f4 7e536541 1ac3a417 3a965e27     ..PQAeS~....'^.:
   2195c:	3bcb6bab 1ff1459d acab58fa 4b9303e3     .k.;.E...X.....K
   2196c:	2055fa30 adf66d76 889176cc f5254c02     0.U vm...v...L%.
   2197c:	4ffcd7e5 c5d7cb2a 26804435 b58fa362     ...O*...5D.&b...
   2198c:	de495ab1 25671bba 45980eea 5de1c0fe     .ZI...g%...E...]
   2199c:	c302752f 8112f04c 8da39746 6bc6f9d3     /u..L...F......k
   219ac:	03e75f8f 15959c92 bfeb7a6d 95da5952     ._......mz..RY..
   219bc:	d42d83be 58d32174 492969e0 8e44c8c9     ..-.t!.X.i)I..D.
   219cc:	756a89c2 f478798e 996b3e58 27dd71b9     ..ju.yx.X>k..q.'
   219dc:	beb64fe1 f017ad88 c966ac20 7db43ace     .O...... .f..:.}
   219ec:	63184adf e582311a 97603351 62457f53     .J.c.1..Q3`.S.Eb
   219fc:	b1e07764 bb84ae6b fe1ca081 f9942b08     dw..k........+..
   21a0c:	70586848 8f19fd45 94876cde 52b7f87b     HhXpE....l..{..R
   21a1c:	ab23d373 72e2024b e3578f1f 662aab55     s.#.K..r..W.U.*f
   21a2c:	b20728eb 2f03c2b5 869a7bc5 d3a50837     .(...../.{..7...
   21a3c:	30f28728 23b2a5bf 02ba6a03 ed5c8216     (..0...#.j....\.
   21a4c:	8a2b1ccf a792b479 f3f0f207 4ea1e269     ..+.y.......i..N
   21a5c:	65cdf4da 06d5be05 d11f6234 c48afea6     ...e....4b......
   21a6c:	349d532e a2a055f3 0532e18a a475ebf6     .S.4.U....2...u.
   21a7c:	0b39ec83 40aaef60 5e069f71 bd51106e     ..9.`..@q..^n.Q.
   21a8c:	3ef98a21 963d06dd ddae053e 4d46bde6     !..>..=.>.....FM
   21a9c:	91b58d54 71055dc4 046fd406 60ff1550     T....].q..o.P..`
   21aac:	1924fb98 d697e9bd 89cc4340 67779ed9     ..$.....@C....wg
   21abc:	b0bd42e8 07888b89 e7385b19 79dbeec8     .B.......[8....y
   21acc:	a1470a7c 7ce90f42 f8c91e84 00000000     |.G.B..|........
   21adc:	09838680 3248ed2b 1eac7011 6c4e725a     ....+.H2.p..ZrNl
   21aec:	fdfbff0e 0f563885 3d1ed5ae 3627392d     .....8V....=-9'6
   21afc:	0a64d90f 6821a65c 9bd1545b 243a2e36     ..d.\.!h[T..6.:$
   21b0c:	0cb1670a 930fe757 b4d296ee 1b9e919b     .g..W...........
   21b1c:	804fc5c0 61a220dc 5a694b77 1c161a12     ..O.. .awKiZ....
   21b2c:	e20aba93 c0e52aa0 3c43e022 121d171b     .....*..".C<....
   21b3c:	0e0b0d09 f2adc78b 2db9a8b6 14c8a91e     ...........-....
   21b4c:	578519f1 af4c0775 eebbdd99 a3fd607f     ...Wu.L......`..
   21b5c:	f79f2601 5cbcf572 44c53b66 5b347efb     .&..r..\f;.D.~4[
   21b6c:	8b762943 cbdcc623 b668fced b863f1e4     C)v.#.....h...c.
   21b7c:	d7cadc31 42108563 13402297 842011c6     1...c..B."@... .
   21b8c:	857d244a d2f83dbb ae1132f9 c76da129     J$}..=...2..).m.
   21b9c:	1d4b2f9e dcf330b2 0dec5286 77d0e3c1     ./K..0...R.....w
   21bac:	2b6c16b3 a999b970 11fa4894 472264e9     ..l+p....H...d"G
   21bbc:	a8c48cfc a01a3ff0 56d82c7d 22ef9033     .....?..},.V3.."
   21bcc:	87c74e49 d9c1d138 8cfea2ca 98360bd4     IN..8.........6.
   21bdc:	a6cf81f5 a528de7a da268eb7 3fa4bfad     ....z.(...&....?
   21bec:	2ce49d3a 500d9278 6a9bcc5f 5462467e     :..,x..P_..j~FbT
   21bfc:	f6c2138d 90e8b8d8 2e5ef739 82f5afc3     ........9.^.....
   21c0c:	9fbe805d 697c93d0 6fa92dd5 cfb31225     ].....|i.-.o%...
   21c1c:	c83b99ac 10a77d18 e86e639c db7bbb3b     ..;..}...cn.;.{.
   21c2c:	cd097826 6ef41859 ec01b79a 83a89a4f     &x..Y..n....O...
   21c3c:	e6656e95 aa7ee6ff 2108cfbc efe6e815     .ne...~....!....
   21c4c:	bad99be7 4ace366f ead4099f 29d67cb0     ....o6.J.....|.)
   21c5c:	31afb2a4 2a31233f c63094a5 35c066a2     ...1?#1*..0..f.5
   21c6c:	7437bc4e fca6ca82 e0b0d090 3315d8a7     N.7t...........3
   21c7c:	f14a9804 41f7daec 7f0e50cd 172ff691     ..J....A.P..../.
   21c8c:	768dd64d 434db0ef cc544daa e4df0496     M..v..MC.MT.....
   21c9c:	9ee3b5d1 4c1b886a c1b81f2c 467f5165     ....j..L,...eQ.F
   21cac:	9d04ea5e 015d358c fa737487 fb2e410b     ^....5]..ts..A..
   21cbc:	b35a1d67 9252d2db e9335610 6d1347d6     g.Z...R..V3..G.m
   21ccc:	9a8c61d7 377a0ca1 598e14f8 eb893c13     .a....z7...Y.<..
   21cdc:	ceee27a9 b735c961 e1ede51c 7a3cb147     .'..a.5.....G.<z
   21cec:	9c59dfd2 553f73f2 1879ce14 73bf37c7     ..Y..s?U..y..7.s
   21cfc:	53eacdf7 5f5baafd df146f3d 7886db44     ...S..[_=o..D..x
   21d0c:	ca81f3af b93ec468 382c3424 c25f40a3     ....h.>.$4,8.@_.
   21d1c:	1672c31d bc0c25e2 288b493c ff41950d     ..r..%..<I.(..A.
   21d2c:	397101a8 08deb30c d89ce4b4 6490c156     ..q9........V..d
   21d3c:	7b6184cb d570b632 48745c6c d04257b8     ..a{2.p.l\tH.WB.

00021d4c <RCON>:
   21d4c:	00000001 00000002 00000004 00000008     ................
   21d5c:	00000010 00000020 00000040 00000080     .... ...@.......
   21d6c:	0000001b 00000036                       ....6...

00021d74 <FT0>:
   21d74:	a56363c6 847c7cf8 997777ee 8d7b7bf6     .cc..||..ww..{{.
   21d84:	0df2f2ff bd6b6bd6 b16f6fde 54c5c591     .....kk..oo....T
   21d94:	50303060 03010102 a96767ce 7d2b2b56     `00P.....gg.V++}
   21da4:	19fefee7 62d7d7b5 e6abab4d 9a7676ec     .......bM....vv.
   21db4:	45caca8f 9d82821f 40c9c989 877d7dfa     ...E.......@.}}.
   21dc4:	15fafaef eb5959b2 c947478e 0bf0f0fb     .....YY..GG.....
   21dd4:	ecadad41 67d4d4b3 fda2a25f eaafaf45     A......g_...E...
   21de4:	bf9c9c23 f7a4a453 967272e4 5bc0c09b     #...S....rr....[
   21df4:	c2b7b775 1cfdfde1 ae93933d 6a26264c     u.......=...L&&j
   21e04:	5a36366c 413f3f7e 02f7f7f5 4fcccc83     l66Z~??A.......O
   21e14:	5c343468 f4a5a551 34e5e5d1 08f1f1f9     h44\Q......4....
   21e24:	937171e2 73d8d8ab 53313162 3f15152a     .qq....sb11S*..?
   21e34:	0c040408 52c7c795 65232346 5ec3c39d     .......RF##e...^
   21e44:	28181830 a1969637 0f05050a b59a9a2f     0..(7......./...
   21e54:	0907070e 36121224 9b80801b 3de2e2df     ....$..6.......=
   21e64:	26ebebcd 6927274e cdb2b27f 9f7575ea     ...&N''i.....uu.
   21e74:	1b090912 9e83831d 742c2c58 2e1a1a34     ........X,,t4...
   21e84:	2d1b1b36 b26e6edc ee5a5ab4 fba0a05b     6..-.nn..ZZ.[...
   21e94:	f65252a4 4d3b3b76 61d6d6b7 ceb3b37d     .RR.v;;M...a}...
   21ea4:	7b292952 3ee3e3dd 712f2f5e 97848413     R)){...>^//q....
   21eb4:	f55353a6 68d1d1b9 00000000 2cededc1     .SS....h.......,
   21ec4:	60202040 1ffcfce3 c8b1b179 ed5b5bb6     @  `....y....[[.
   21ed4:	be6a6ad4 46cbcb8d d9bebe67 4b393972     .jj....Fg...r99K
   21ee4:	de4a4a94 d44c4c98 e85858b0 4acfcf85     .JJ..LL..XX....J
   21ef4:	6bd0d0bb 2aefefc5 e5aaaa4f 16fbfbed     ...k...*O.......
   21f04:	c5434386 d74d4d9a 55333366 94858511     .CC..MM.f33U....
   21f14:	cf45458a 10f9f9e9 06020204 817f7ffe     .EE.............
   21f24:	f05050a0 443c3c78 ba9f9f25 e3a8a84b     .PP.x<<D%...K...
   21f34:	f35151a2 fea3a35d c0404080 8a8f8f05     .QQ.]....@@.....
   21f44:	ad92923f bc9d9d21 48383870 04f5f5f1     ?...!...p88H....
   21f54:	dfbcbc63 c1b6b677 75dadaaf 63212142     c...w......uB!!c
   21f64:	30101020 1affffe5 0ef3f3fd 6dd2d2bf      ..0...........m
   21f74:	4ccdcd81 140c0c18 35131326 2fececc3     ...L....&..5.../
   21f84:	e15f5fbe a2979735 cc444488 3917172e     .__.5....DD....9
   21f94:	57c4c493 f2a7a755 827e7efc 473d3d7a     ...WU....~~.z==G
   21fa4:	ac6464c8 e75d5dba 2b191932 957373e6     .dd..]].2..+.ss.
   21fb4:	a06060c0 98818119 d14f4f9e 7fdcdca3     .``......OO.....
   21fc4:	66222244 7e2a2a54 ab90903b 8388880b     D""fT**~;.......
   21fd4:	ca46468c 29eeeec7 d3b8b86b 3c141428     .FF....)k...(..<
   21fe4:	79dedea7 e25e5ebc 1d0b0b16 76dbdbad     ...y.^^........v
   21ff4:	3be0e0db 56323264 4e3a3a74 1e0a0a14     ...;d22Vt::N....
   22004:	db494992 0a06060c 6c242448 e45c5cb8     .II.....H$$l.\\.
   22014:	5dc2c29f 6ed3d3bd efacac43 a66262c4     ...]...nC....bb.
   22024:	a8919139 a4959531 37e4e4d3 8b7979f2     9...1......7.yy.
   22034:	32e7e7d5 43c8c88b 5937376e b76d6dda     ...2...Cn77Y.mm.
   22044:	8c8d8d01 64d5d5b1 d24e4e9c e0a9a949     .......d.NN.I...
   22054:	b46c6cd8 fa5656ac 07f4f4f3 25eaeacf     .ll..VV........%
   22064:	af6565ca 8e7a7af4 e9aeae47 18080810     .ee..zz.G.......
   22074:	d5baba6f 887878f0 6f25254a 722e2e5c     o....xx.J%%o\..r
   22084:	241c1c38 f1a6a657 c7b4b473 51c6c697     8..$W...s......Q
   22094:	23e8e8cb 7cdddda1 9c7474e8 211f1f3e     ...#...|.tt.>..!
   220a4:	dd4b4b96 dcbdbd61 868b8b0d 858a8a0f     .KK.a...........
   220b4:	907070e0 423e3e7c c4b5b571 aa6666cc     .pp.|>>Bq....ff.
   220c4:	d8484890 05030306 01f6f6f7 120e0e1c     .HH.............
   220d4:	a36161c2 5f35356a f95757ae d0b9b969     .aa.j55_.WW.i...
   220e4:	91868617 58c1c199 271d1d3a b99e9e27     .......X:..''...
   220f4:	38e1e1d9 13f8f8eb b398982b 33111122     ...8....+..."..3
   22104:	bb6969d2 70d9d9a9 898e8e07 a7949433     .ii....p....3...
   22114:	b69b9b2d 221e1e3c 92878715 20e9e9c9     -...<.."....... 
   22124:	49cece87 ff5555aa 78282850 7adfdfa5     ...I.UU.P((x...z
   22134:	8f8c8c03 f8a1a159 80898909 170d0d1a     ....Y...........
   22144:	dabfbf65 31e6e6d7 c6424284 b86868d0     e......1.BB..hh.
   22154:	c3414182 b0999929 772d2d5a 110f0f1e     .AA.)...Z--w....
   22164:	cbb0b07b fc5454a8 d6bbbb6d 3a16162c     {....TT.m...,..:

00022174 <FT1>:
   22174:	6363c6a5 7c7cf884 7777ee99 7b7bf68d     ..cc..||..ww..{{
   22184:	f2f2ff0d 6b6bd6bd 6f6fdeb1 c5c59154     ......kk..ooT...
   22194:	30306050 01010203 6767cea9 2b2b567d     P`00......gg}V++
   221a4:	fefee719 d7d7b562 abab4de6 7676ec9a     ....b....M....vv
   221b4:	caca8f45 82821f9d c9c98940 7d7dfa87     E.......@.....}}
   221c4:	fafaef15 5959b2eb 47478ec9 f0f0fb0b     ......YY..GG....
   221d4:	adad41ec d4d4b367 a2a25ffd afaf45ea     .A..g...._...E..
   221e4:	9c9c23bf a4a453f7 7272e496 c0c09b5b     .#...S....rr[...
   221f4:	b7b775c2 fdfde11c 93933dae 26264c6a     .u.......=..jL&&
   22204:	36366c5a 3f3f7e41 f7f7f502 cccc834f     Zl66A~??....O...
   22214:	3434685c a5a551f4 e5e5d134 f1f1f908     \h44.Q..4.......
   22224:	7171e293 d8d8ab73 31316253 15152a3f     ..qqs...Sb11?*..
   22234:	0404080c c7c79552 23234665 c3c39d5e     ....R...eF##^...
   22244:	18183028 969637a1 05050a0f 9a9a2fb5     (0...7......./..
   22254:	07070e09 12122436 80801b9b e2e2df3d     ....6$......=...
   22264:	ebebcd26 27274e69 b2b27fcd 7575ea9f     &...iN''......uu
   22274:	0909121b 83831d9e 2c2c5874 1a1a342e     ........tX,,.4..
   22284:	1b1b362d 6e6edcb2 5a5ab4ee a0a05bfb     -6....nn..ZZ.[..
   22294:	5252a4f6 3b3b764d d6d6b761 b3b37dce     ..RRMv;;a....}..
   222a4:	2929527b e3e3dd3e 2f2f5e71 84841397     {R))>...q^//....
   222b4:	5353a6f5 d1d1b968 00000000 ededc12c     ..SSh.......,...
   222c4:	20204060 fcfce31f b1b179c8 5b5bb6ed     `@  .....y....[[
   222d4:	6a6ad4be cbcb8d46 bebe67d9 3939724b     ..jjF....g..Kr99
   222e4:	4a4a94de 4c4c98d4 5858b0e8 cfcf854a     ..JJ..LL..XXJ...
   222f4:	d0d0bb6b efefc52a aaaa4fe5 fbfbed16     k...*....O......
   22304:	434386c5 4d4d9ad7 33336655 85851194     ..CC..MMUf33....
   22314:	45458acf f9f9e910 02020406 7f7ffe81     ..EE............
   22324:	5050a0f0 3c3c7844 9f9f25ba a8a84be3     ..PPDx<<.%...K..
   22334:	5151a2f3 a3a35dfe 404080c0 8f8f058a     ..QQ.]....@@....
   22344:	92923fad 9d9d21bc 38387048 f5f5f104     .?...!..Hp88....
   22354:	bcbc63df b6b677c1 dadaaf75 21214263     .c...w..u...cB!!
   22364:	10102030 ffffe51a f3f3fd0e d2d2bf6d     0 ..........m...
   22374:	cdcd814c 0c0c1814 13132635 ececc32f     L.......5&../...
   22384:	5f5fbee1 979735a2 444488cc 17172e39     ..__.5....DD9...
   22394:	c4c49357 a7a755f2 7e7efc82 3d3d7a47     W....U....~~Gz==
   223a4:	6464c8ac 5d5dbae7 1919322b 7373e695     ..dd..]]+2....ss
   223b4:	6060c0a0 81811998 4f4f9ed1 dcdca37f     ..``......OO....
   223c4:	22224466 2a2a547e 90903bab 88880b83     fD""~T**.;......
   223d4:	46468cca eeeec729 b8b86bd3 1414283c     ..FF)....k..<(..
   223e4:	dedea779 5e5ebce2 0b0b161d dbdbad76     y.....^^....v...
   223f4:	e0e0db3b 32326456 3a3a744e 0a0a141e     ;...Vd22Nt::....
   22404:	494992db 06060c0a 2424486c 5c5cb8e4     ..II....lH$$..\\
   22414:	c2c29f5d d3d3bd6e acac43ef 6262c4a6     ]...n....C....bb
   22424:	919139a8 959531a4 e4e4d337 7979f28b     .9...1..7.....yy
   22434:	e7e7d532 c8c88b43 37376e59 6d6ddab7     2...C...Yn77..mm
   22444:	8d8d018c d5d5b164 4e4e9cd2 a9a949e0     ....d.....NN.I..
   22454:	6c6cd8b4 5656acfa f4f4f307 eaeacf25     ..ll..VV....%...
   22464:	6565caaf 7a7af48e aeae47e9 08081018     ..ee..zz.G......
   22474:	baba6fd5 7878f088 25254a6f 2e2e5c72     .o....xxoJ%%r\..
   22484:	1c1c3824 a6a657f1 b4b473c7 c6c69751     $8...W...s..Q...
   22494:	e8e8cb23 dddda17c 7474e89c 1f1f3e21     #...|.....tt!>..
   224a4:	4b4b96dd bdbd61dc 8b8b0d86 8a8a0f85     ..KK.a..........
   224b4:	7070e090 3e3e7c42 b5b571c4 6666ccaa     ..ppB|>>.q....ff
   224c4:	484890d8 03030605 f6f6f701 0e0e1c12     ..HH............
   224d4:	6161c2a3 35356a5f 5757aef9 b9b969d0     ..aa_j55..WW.i..
   224e4:	86861791 c1c19958 1d1d3a27 9e9e27b9     ....X...':...'..
   224f4:	e1e1d938 f8f8eb13 98982bb3 11112233     8........+..3"..
   22504:	6969d2bb d9d9a970 8e8e0789 949433a7     ..iip........3..
   22514:	9b9b2db6 1e1e3c22 87871592 e9e9c920     .-.."<...... ...
   22524:	cece8749 5555aaff 28285078 dfdfa57a     I.....UUxP((z...
   22534:	8c8c038f a1a159f8 89890980 0d0d1a17     .....Y..........
   22544:	bfbf65da e6e6d731 424284c6 6868d0b8     .e..1.....BB..hh
   22554:	414182c3 999929b0 2d2d5a77 0f0f1e11     ..AA.)..wZ--....
   22564:	b0b07bcb 5454a8fc bbbb6dd6 16162c3a     .{....TT.m..:,..

00022574 <FT2>:
   22574:	63c6a563 7cf8847c 77ee9977 7bf68d7b     c..c|..|w..w{..{
   22584:	f2ff0df2 6bd6bd6b 6fdeb16f c59154c5     ....k..ko..o.T..
   22594:	30605030 01020301 67cea967 2b567d2b     0P`0....g..g+}V+
   225a4:	fee719fe d7b562d7 ab4de6ab 76ec9a76     .....b....M.v..v
   225b4:	ca8f45ca 821f9d82 c98940c9 7dfa877d     .E.......@..}..}
   225c4:	faef15fa 59b2eb59 478ec947 f0fb0bf0     ....Y..YG..G....
   225d4:	ad41ecad d4b367d4 a25ffda2 af45eaaf     ..A..g...._...E.
   225e4:	9c23bf9c a453f7a4 72e49672 c09b5bc0     ..#...S.r..r.[..
   225f4:	b775c2b7 fde11cfd 933dae93 264c6a26     ..u.......=.&jL&
   22604:	366c5a36 3f7e413f f7f502f7 cc834fcc     6Zl6?A~?.....O..
   22614:	34685c34 a551f4a5 e5d134e5 f1f908f1     4\h4..Q..4......
   22624:	71e29371 d8ab73d8 31625331 152a3f15     q..q.s..1Sb1.?*.
   22634:	04080c04 c79552c7 23466523 c39d5ec3     .....R..#eF#.^..
   22644:	18302818 9637a196 050a0f05 9a2fb59a     .(0...7......./.
   22654:	070e0907 12243612 801b9b80 e2df3de2     .....6$......=..
   22664:	ebcd26eb 274e6927 b27fcdb2 75ea9f75     .&..'iN'....u..u
   22674:	09121b09 831d9e83 2c58742c 1a342e1a     ........,tX,..4.
   22684:	1b362d1b 6edcb26e 5ab4ee5a a05bfba0     .-6.n..nZ..Z..[.
   22694:	52a4f652 3b764d3b d6b761d6 b37dceb3     R..R;Mv;.a....}.
   226a4:	29527b29 e3dd3ee3 2f5e712f 84139784     ){R).>../q^/....
   226b4:	53a6f553 d1b968d1 00000000 edc12ced     S..S.h.......,..
   226c4:	20406020 fce31ffc b179c8b1 5bb6ed5b      `@ ......y.[..[
   226d4:	6ad4be6a cb8d46cb be67d9be 39724b39     j..j.F....g.9Kr9
   226e4:	4a94de4a 4c98d44c 58b0e858 cf854acf     J..JL..LX..X.J..
   226f4:	d0bb6bd0 efc52aef aa4fe5aa fbed16fb     .k...*....O.....
   22704:	4386c543 4d9ad74d 33665533 85119485     C..CM..M3Uf3....
   22714:	458acf45 f9e910f9 02040602 7ffe817f     E..E............
   22724:	50a0f050 3c78443c 9f25ba9f a84be3a8     P..P<Dx<..%...K.
   22734:	51a2f351 a35dfea3 4080c040 8f058a8f     Q..Q..].@..@....
   22744:	923fad92 9d21bc9d 38704838 f5f104f5     ..?...!.8Hp8....
   22754:	bc63dfbc b677c1b6 daaf75da 21426321     ..c...w..u..!cB!
   22764:	10203010 ffe51aff f3fd0ef3 d2bf6dd2     .0 ..........m..
   22774:	cd814ccd 0c18140c 13263513 ecc32fec     .L.......5&../..
   22784:	5fbee15f 9735a297 4488cc44 172e3917     _.._..5.D..D.9..
   22794:	c49357c4 a755f2a7 7efc827e 3d7a473d     .W....U.~..~=Gz=
   227a4:	64c8ac64 5dbae75d 19322b19 73e69573     d..d]..].+2.s..s
   227b4:	60c0a060 81199881 4f9ed14f dca37fdc     `..`....O..O....
   227c4:	22446622 2a547e2a 903bab90 880b8388     "fD"*~T*..;.....
   227d4:	468cca46 eec729ee b86bd3b8 14283c14     F..F.)....k..<(.
   227e4:	dea779de 5ebce25e 0b161d0b dbad76db     .y..^..^.....v..
   227f4:	e0db3be0 32645632 3a744e3a 0a141e0a     .;..2Vd2:Nt:....
   22804:	4992db49 060c0a06 24486c24 5cb8e45c     I..I....$lH$\..\
   22814:	c29f5dc2 d3bd6ed3 ac43efac 62c4a662     .]...n....C.b..b
   22824:	9139a891 9531a495 e4d337e4 79f28b79     ..9...1..7..y..y
   22834:	e7d532e7 c88b43c8 376e5937 6ddab76d     .2...C..7Yn7m..m
   22844:	8d018c8d d5b164d5 4e9cd24e a949e0a9     .....d..N..N..I.
   22854:	6cd8b46c 56acfa56 f4f307f4 eacf25ea     l..lV..V.....%..
   22864:	65caaf65 7af48e7a ae47e9ae 08101808     e..ez..z..G.....
   22874:	ba6fd5ba 78f08878 254a6f25 2e5c722e     ..o.x..x%oJ%.r\.
   22884:	1c38241c a657f1a6 b473c7b4 c69751c6     .$8...W...s..Q..
   22894:	e8cb23e8 dda17cdd 74e89c74 1f3e211f     .#...|..t..t.!>.
   228a4:	4b96dd4b bd61dcbd 8b0d868b 8a0f858a     K..K..a.........
   228b4:	70e09070 3e7c423e b571c4b5 66ccaa66     p..p>B|>..q.f..f
   228c4:	4890d848 03060503 f6f701f6 0e1c120e     H..H............
   228d4:	61c2a361 356a5f35 57aef957 b969d0b9     a..a5_j5W..W..i.
   228e4:	86179186 c19958c1 1d3a271d 9e27b99e     .....X...':...'.
   228f4:	e1d938e1 f8eb13f8 982bb398 11223311     .8........+..3".
   22904:	69d2bb69 d9a970d9 8e07898e 9433a794     i..i.p........3.
   22914:	9b2db69b 1e3c221e 87159287 e9c920e9     ..-.."<...... ..
   22924:	ce8749ce 55aaff55 28507828 dfa57adf     .I..U..U(xP(.z..
   22934:	8c038f8c a159f8a1 89098089 0d1a170d     ......Y.........
   22944:	bf65dabf e6d731e6 4284c642 68d0b868     ..e..1..B..Bh..h
   22954:	4182c341 9929b099 2d5a772d 0f1e110f     A..A..).-wZ-....
   22964:	b07bcbb0 54a8fc54 bb6dd6bb 162c3a16     ..{.T..T..m..:,.

00022974 <FT3>:
   22974:	c6a56363 f8847c7c ee997777 f68d7b7b     cc..||..ww..{{..
   22984:	ff0df2f2 d6bd6b6b deb16f6f 9154c5c5     ....kk..oo....T.
   22994:	60503030 02030101 cea96767 567d2b2b     00P`....gg..++}V
   229a4:	e719fefe b562d7d7 4de6abab ec9a7676     ......b....Mvv..
   229b4:	8f45caca 1f9d8282 8940c9c9 fa877d7d     ..E.......@.}}..
   229c4:	ef15fafa b2eb5959 8ec94747 fb0bf0f0     ....YY..GG......
   229d4:	41ecadad b367d4d4 5ffda2a2 45eaafaf     ...A..g...._...E
   229e4:	23bf9c9c 53f7a4a4 e4967272 9b5bc0c0     ...#...Srr....[.
   229f4:	75c2b7b7 e11cfdfd 3dae9393 4c6a2626     ...u.......=&&jL
   22a04:	6c5a3636 7e413f3f f502f7f7 834fcccc     66Zl??A~......O.
   22a14:	685c3434 51f4a5a5 d134e5e5 f908f1f1     44\h...Q..4.....
   22a24:	e2937171 ab73d8d8 62533131 2a3f1515     qq....s.11Sb..?*
   22a34:	080c0404 9552c7c7 46652323 9d5ec3c3     ......R.##eF..^.
   22a44:	30281818 37a19696 0a0f0505 2fb59a9a     ..(0...7......./
   22a54:	0e090707 24361212 1b9b8080 df3de2e2     ......6$......=.
   22a64:	cd26ebeb 4e692727 7fcdb2b2 ea9f7575     ..&.''iN....uu..
   22a74:	121b0909 1d9e8383 58742c2c 342e1a1a     ........,,tX...4
   22a84:	362d1b1b dcb26e6e b4ee5a5a 5bfba0a0     ..-6nn..ZZ.....[
   22a94:	a4f65252 764d3b3b b761d6d6 7dceb3b3     RR..;;Mv..a....}
   22aa4:	527b2929 dd3ee3e3 5e712f2f 13978484     )){R..>.//q^....
   22ab4:	a6f55353 b968d1d1 00000000 c12ceded     SS....h.......,.
   22ac4:	40602020 e31ffcfc 79c8b1b1 b6ed5b5b       `@.......y[[..
   22ad4:	d4be6a6a 8d46cbcb 67d9bebe 724b3939     jj....F....g99Kr
   22ae4:	94de4a4a 98d44c4c b0e85858 854acfcf     JJ..LL..XX....J.
   22af4:	bb6bd0d0 c52aefef 4fe5aaaa ed16fbfb     ..k...*....O....
   22b04:	86c54343 9ad74d4d 66553333 11948585     CC..MM..33Uf....
   22b14:	8acf4545 e910f9f9 04060202 fe817f7f     EE..............
   22b24:	a0f05050 78443c3c 25ba9f9f 4be3a8a8     PP..<<Dx...%...K
   22b34:	a2f35151 5dfea3a3 80c04040 058a8f8f     QQ.....]@@......
   22b44:	3fad9292 21bc9d9d 70483838 f104f5f5     ...?...!88Hp....
   22b54:	63dfbcbc 77c1b6b6 af75dada 42632121     ...c...w..u.!!cB
   22b64:	20301010 e51affff fd0ef3f3 bf6dd2d2     ..0 ..........m.
   22b74:	814ccdcd 18140c0c 26351313 c32fecec     ..L.......5&../.
   22b84:	bee15f5f 35a29797 88cc4444 2e391717     __.....5DD....9.
   22b94:	9357c4c4 55f2a7a7 fc827e7e 7a473d3d     ..W....U~~..==Gz
   22ba4:	c8ac6464 bae75d5d 322b1919 e6957373     dd..]]....+2ss..
   22bb4:	c0a06060 19988181 9ed14f4f a37fdcdc     ``......OO......
   22bc4:	44662222 547e2a2a 3bab9090 0b838888     ""fD**~T...;....
   22bd4:	8cca4646 c729eeee 6bd3b8b8 283c1414     FF....)....k..<(
   22be4:	a779dede bce25e5e 161d0b0b ad76dbdb     ..y.^^........v.
   22bf4:	db3be0e0 64563232 744e3a3a 141e0a0a     ..;.22Vd::Nt....
   22c04:	92db4949 0c0a0606 486c2424 b8e45c5c     II......$$lH\\..
   22c14:	9f5dc2c2 bd6ed3d3 43efacac c4a66262     ..]...n....Cbb..
   22c24:	39a89191 31a49595 d337e4e4 f28b7979     ...9...1..7.yy..
   22c34:	d532e7e7 8b43c8c8 6e593737 dab76d6d     ..2...C.77Ynmm..
   22c44:	018c8d8d b164d5d5 9cd24e4e 49e0a9a9     ......d.NN.....I
   22c54:	d8b46c6c acfa5656 f307f4f4 cf25eaea     ll..VV........%.
   22c64:	caaf6565 f48e7a7a 47e9aeae 10180808     ee..zz.....G....
   22c74:	6fd5baba f0887878 4a6f2525 5c722e2e     ...oxx..%%oJ..r\
   22c84:	38241c1c 57f1a6a6 73c7b4b4 9751c6c6     ..$8...W...s..Q.
   22c94:	cb23e8e8 a17cdddd e89c7474 3e211f1f     ..#...|.tt....!>
   22ca4:	96dd4b4b 61dcbdbd 0d868b8b 0f858a8a     KK.....a........
   22cb4:	e0907070 7c423e3e 71c4b5b5 ccaa6666     pp..>>B|...qff..
   22cc4:	90d84848 06050303 f701f6f6 1c120e0e     HH..............
   22cd4:	c2a36161 6a5f3535 aef95757 69d0b9b9     aa..55_jWW.....i
   22ce4:	17918686 9958c1c1 3a271d1d 27b99e9e     ......X...':...'
   22cf4:	d938e1e1 eb13f8f8 2bb39898 22331111     ..8........+..3"
   22d04:	d2bb6969 a970d9d9 07898e8e 33a79494     ii....p........3
   22d14:	2db69b9b 3c221e1e 15928787 c920e9e9     ...-.."<...... .
   22d24:	8749cece aaff5555 50782828 a57adfdf     ..I.UU..((xP..z.
   22d34:	038f8c8c 59f8a1a1 09808989 1a170d0d     .......Y........
   22d44:	65dabfbf d731e6e6 84c64242 d0b86868     ...e..1.BB..hh..
   22d54:	82c34141 29b09999 5a772d2d 1e110f0f     AA.....)--wZ....
   22d64:	7bcbb0b0 a8fc5454 6dd6bbbb 2c3a1616     ...{TT.....m..:,

00022d74 <RSb>:
   22d74:	d56a0952 38a53630 9ea340bf fbd7f381     R.j.06.8.@......
   22d84:	8239e37c 87ff2f9b 44438e34 cbe9dec4     |.9../..4.CD....
   22d94:	32947b54 3d23c2a6 0b954cee 4ec3fa42     T{.2..#=.L..B..N
   22da4:	66a12e08 b224d928 49a25b76 25d18b6d     ...f(.$.v[.Im..%
   22db4:	64f6f872 16986886 cc5ca4d4 92b6655d     r..d.h....\.]e..
   22dc4:	5048706c dab9edfd 5746155e 849d8da7     lpHP....^.FW....
   22dd4:	00abd890 0ad3bc8c 0558e4f7 0645b3b8     ..........X...E.
   22de4:	8f1e2cd0 020f3fca 03bdafc1 6b8a1301     .,...?.........k
   22df4:	4111913a eadc674f cecff297 73e6b4f0     :..AOg.........s
   22e04:	2274ac96 8535ade7 e837f9e2 6edf751c     ..t"..5...7..u.n
   22e14:	711af147 89c5291d 0e62b76f 1bbe18aa     G..q.)..o.b.....
   22e24:	4b3e56fc 2079d2c6 fec0db9a f45acd78     .V>K..y ....x.Z.
   22e34:	33a8dd1f 31c70788 591012b1 5fec8027     ...3...1...Y'.._
   22e44:	a97f5160 0d4ab519 9f7ae52d ef9cc993     `Q....J.-.z.....
   22e54:	4d3be0a0 b0f52aae 3cbbebc8 61995383     ..;M.*.....<.S.a
   22e64:	7e042b17 26d677ba 631469e1 7d0c2155     .+.~.w.&.i.cU!.}

00022e74 <uart_cfg>:
   22e74:	07050806 00000043                       ....C...

/Users/briangiori/dev/newt/blegpio/bin/blegpio/apps/blegpio/blegpio.elf:     file format elf32-littlearm

Contents of section .text:
 08020 00000120 4d8b0000 7d8b0000 7f8b0000  ... M...}.......
 08030 00000000 00000000 00000000 00000000  ................
 08040 00000000 00000000 00000000 35a90000  ............5...
 08050 00000000 00000000 7ba90000 a5a90000  ........{.......
 08060 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 08070 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 08080 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 08090 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 080a0 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 080b0 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 080c0 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 080d0 8d8b0000 8d8b0000 00000000 00000000  ................
 080e0 8d8b0000 8d8b0000 8d8b0000 8d8b0000  ................
 080f0 8d8b0000 8d8b0000 154b002b 08bf134b  .........K.+...K
 08100 9d46a3f5 803a0021 8b460f46 1348144a  .F...:.!.F.F.H.J
 08110 121a00f0 7eff0f4b 002b00d0 98470e4b  ....~..K.+...G.K
 08120 002b00d0 98470020 00210400 0d000d48  .+...G. .!.....H
 08130 002802d0 0c48aff3 008016f0 47fd2000  .(...H......G. .
 08140 290000f0 a7f900f0 3fff00bf 00000800  ).......?.......
 08150 00000120 00000000 00000000 00100020  ... ........... 
 08160 143e0020 00000000 00000000 30b5a5b0  .>. ........0...
 08170 00216c22 09a800f0 4cff0123 8df82530  .!l"....L..#..%0
 08180 8df84730 80238df8 463014f0 2dfd1090  ..G0.#..F0..-...
 08190 00f060ff 9df84530 8df84400 43f00103  ..`...E0..D.C...
 081a0 8df84530 24ab41f6 110223f8 7c2d0a93  ..E0$.A...#.|-..
 081b0 01238df8 2c309df8 2d3009a8 43f00103  .#..,0..-0..C...
 081c0 8df82d30 09f034ff 044628b1 00904021  ..-0..4..F(...@!
 081d0 1148124b 03221be0 06ad2146 0a222846  .H.K."....!F."(F
 081e0 00f017ff 02238df8 18308df8 19300c4b  .....#...0...0.K
 081f0 01930095 02942046 21462246 6ff00043  ...... F!F"Fo..C
 08200 09f0aafd 30b10090 064b0348 40210322  ....0....K.H@!."
 08210 15f00af8 25b030bd e02c0020 34ec0100  ....%.0..,. 4...
 08220 2d830000 5dec0100 08b50cf0 2dfb18b1  -...].......-...
 08230 0d4840f2 251115e0 fff798ff 0b4801f0  .H@.%........H..
 08240 02fd4378 012b0ad1 c2692ab9 064840f2  ..Cx.+...i*..H@.
 08250 2f111346 01f03cfd 40689047 eee70248  /..F..<.@h.G...H
 08260 40f23311 0022f4e7 82ec0100 04280020  @.3..".......(. 
 08270 30b587b0 838b274d 009390f8 27300193  0.....'M....'0..
 08280 04464021 28460122 234b14f0 cdff04f1  .F@!(F."#K......
 08290 160000f0 25fa94f8 26300093 28464021  ....%...&0..(F@!
 082a0 01221e4b 14f0c0ff 04f11000 00f018fa  .".K............
 082b0 94f82430 00932846 40210122 184b14f0  ..$0..(F@!.".K..
 082c0 b3ff201d 00f00cfa 94f82530 00932846  .. .......%0..(F
 082d0 40210122 134b14f0 a7ff04f1 0a0000f0  @!.".K..........
 082e0 fff9e38b 0093238c 0193638c 02932378  ......#...c...#x
 082f0 03f00102 0392c3f3 4002c3f3 80030492  ........@.......
 08300 05932846 40210122 074b14f0 8dff07b0  ..(F@!.".K......
 08310 30bd00bf e02c0020 89ec0100 b6ec0100  0....,. ........
 08320 d8ec0100 feec0100 22ed0100 30b50378  ........"...0..x
 08330 95b00446 0e2b00f2 8b80dfe8 03f0082e  ...F.+..........
 08340 89438989 89898989 58898989 69004268  .C......X...i.Bh
 08350 4149424b 0192002a 18bf0b46 00934048  AIBK...*...F..@H
 08360 404b4021 012214f0 5fff6568 5db92089  @K@!.".._.eh]. .
 08370 09a909f0 01fb18b1 3b48da21 2a4629e0  ........;H.!*F).
 08380 09a8fff7 75ff394b 35484021 012214f0  ....u.9K5H@!."..
 08390 4bff6368 002b5bd0 11e04368 00934021  K.ch.+[...Ch..@!
 083a0 0122334b 2e4814f0 3fff04f1 0800fff7  ."3K.H..?.......
 083b0 5fff2b48 2d4b4021 012214f0 35fffff7  _.+H-K@!."..5...
 083c0 d5fe45e0 008909a9 09f0d6fa 28b12648  ..E.........(.&H
 083d0 f3210022 134601f0 7bfc09a8 fff748ff  .!.".F..{.....H.
 083e0 1f48224b 40210122 14f01eff 30e04368  .H"K@!."....0.Ch
 083f0 00931b48 1f4b4021 012214f0 15ff2089  ...H.K@!.".... .
 08400 09a909f0 b9fa0028 e7d01748 fe21e0e7  .......(...H.!..
 08410 83880093 c3880193 037a0293 437a1048  .........z..Cz.H
 08420 03f00102 0392c3f3 40020492 c3f38002  ........@.......
 08430 c3f3c003 05920693 40210122 0e4b14f0  ........@!.".K..
 08440 f3fe0e4b a2880e48 0e491a80 01f0d1fb  ...K...H.I......
 08450 002015b0 30bd00bf 8ced0100 80ed0100  . ..0...........
 08460 e02c0020 93ed0100 82ec0100 ecfd0100  .,. ............
 08470 aded0100 c4ed0100 e8ed0100 e4270020  .............'. 
 08480 d8270020 242c0020 014b1888 704700bf  .'. $,. .K..pG..
 08490 e4270020 f0b58fb0 01f00efa 794800f0  .'. ........yH..
 084a0 01fc18b1 784840f2 4f1118e0 0346774a  ....xH@.O....FwJ
 084b0 9a5c0133 1043042b 4fea0020 f7d100f0  .\.3.C.+O.. ....
 084c0 bffd734b 00937348 734b0c21 4ff49272  ..sK..sHsK.!O..r
 084d0 01f05eff 044630b1 6b4840f2 5f110022  ..^..F0.kH@._.."
 084e0 134601f0 f5fb6d48 6a494ff4 92720c23  .F....mHjIO..r.#
 084f0 01f0ecfc 054618b1 634840f2 6311bee0  .....F..cH@.c...
 08500 664801f0 c7fc0446 18b15f48 4ff4b371  fH.....F.._HO..q
 08510 9be014f0 11fe6248 14f0c6fe 6149604a  ......bH....aI`J
 08520 614814f0 13fe4ff0 ff330193 5f4b0293  aH....O..3.._K..
 08530 01274ff4 a8730393 5b495d4a 00972346  .'O..s..[I]J..#F
 08540 5c4802f0 c1f82046 0c214ff4 827202f0  \H.... F.!O..r..
 08550 29fe0646 18b14c48 40f27311 8fe0564d  )..F..LH@.s...VM
 08560 0fcd05ac 0fc40fcd 0fc42b68 23600323  ..........+h#`.#
 08570 8df81430 8df81f30 9df82330 8df81570  ...0...0..#0...p
 08580 02221343 8df82330 4c4b0a93 05a84c4b  .".C..#0LK....LK
 08590 8df81a20 8df82070 8df82470 8df82570  ... .. p..$p..%p
 085a0 0b93adf8 1c60adf8 1660adf8 186014f0  .....`...`...`..
 085b0 3dfb0446 20b13448 4ff4c471 32468fe7  =..F .4HO..q2F..
 085c0 05a814f0 5ffb0546 18b12f48 40f28b11  ...._..F../H@...
 085d0 55e005a8 00f0b4fa 044618b1 2a484ff4  U........F..*HO.
 085e0 c77132e0 374801f0 fbfa3648 05a90cf0  .q2.7H....6H....
 085f0 93f918b1 24484ff4 ca7140e0 01f0e0f8  ....$HO..q@.....
 08600 18b12148 4ff4cc71 69e714f0 07fb0546  ..!HO..qi......F
 08610 18b11d48 4ff4cf71 61e714f0 2bfb0446  ...HO..qa...+..F
 08620 18b11948 40f2a111 0fe000f0 7ffa0546  ...H@..........F
 08630 18b11548 4ff4d271 21e02348 14f0d8fa  ...HO..q!.#H....
 08640 044620b1 10484ff4 d4712a46 48e70222  .F ..HO..q*FH.."
 08650 4ff0ff33 8de80c00 1c4b0293 4ff48073  O..3.....K..O..s
 08660 1b491c4a 03931c48 234602f0 2df81b48  .I.J...H#F..-..H
 08670 01f0b6fa 01f038f9 034840f2 b5112246  ......8..H@..."F
 08680 2ee700bf 40420f00 82ec0100 d8000020  ....@B......... 
 08690 46ee0100 e8270020 00100020 18280020  F....'. ... .(. 
 086a0 b01d0020 e02c0020 58ee0100 54080020  ... .,. X...T.. 
 086b0 29820000 302c0020 44fa0100 75ce0100  )...0,. D...u...
 086c0 35cf0100 04280020 60ee0100 24280020  5....(. `...$(. 
 086d0 69ee0100 a18a0000 902c0020 d8270020  i........,. .'. 
 086e0 7fb54379 00930379 0193c378 02938378  ..Cy...y...x...x
 086f0 03934378 04930378 05930448 044b4021  ..Cx...x...H.K@!
 08700 012214f0 91fd07b0 5df804fb e02c0020  ."......]....,. 
 08710 7fee0100 002208b5 024840f2 87111346  ....."...H@....F
 08720 01f0d6fa f1ee0100 30b587b0 04460d46  ........0....F.F
 08730 0ff0b2fe 024620b1 28461749 00f071fc  .....F .(F.I..q.
 08740 27e0617b 0091217b e27ba37b 01912846  '.a{..!{.{.{..(F
 08750 124900f0 66fc617a 0091217a e27aa37a  .I..f.az..!z.z.z
 08760 019105f1 09000e49 00f05bfc 61790091  .......I..[.ay..
 08770 21790191 e1780291 a1780391 61780491  !y...x...x..ax..
 08780 21780591 e279a379 064905f1 130000f0  !x...y.y.I......
 08790 48fc2846 07b030bd 87090200 fcee0100  H.(F..0.........
 087a0 0eef0100 78f70100 10b50378 022b8eb0  ....x......x.+..
 087b0 044610d0 032b1fd0 012b2cd1 836804a9  .F...+...+,..h..
 087c0 5868fff7 b1ffa388 00900193 1648174b  Xh...........H.K
 087d0 40210022 1ce08368 04a91868 fff7a4ff  @!."...h...h....
 087e0 a3880193 e3880090 02930f48 104b4021  ...........H.K@!
 087f0 002214f0 19fd15e0 836804a9 1868fff7  .".......h...h..
 08800 93ffa388 00900193 07480a4b 40210022  .........H.K@!."
 08810 14f00afd 06e00022 07484ff4 de711346  .......".HO..q.F
 08820 01f056fa 0eb010bd e02c0020 21ef0100  ..V......,. !...
 08830 47ef0100 87ef0100 f1ee0100 70b50128  G...........p..(
 08840 0d461646 059c05d0 00220b48 97211346  .F.F.....".H.!.F
 08850 01f03efa 09688a68 b2420bdb 9a4209dc  ..>..h.h.B...B..
 08860 04980968 00f0cafb 14b12b68 9b682380  ...h......+h.h#.
 08870 002070bd 0d2070bd f1ee0100 2de9ff41  . p.. p.....-..A
 08880 53681778 18684649 14461022 00f0a8fb  Sh.x.hFI.F."....
 08890 05460028 7bd117b1 012f07d0 72e0a368  .F.({..../..r..h
 088a0 404a9a60 a3680222 9a8175e0 02223e4e  @J.`.h."..u..">N
 088b0 01900096 384604f1 08011346 fff7beff  ....8F.....F....
 088c0 804618b1 394840f2 27115ee0 35883848  .F..9H@.'.^.5.8H
 088d0 384b2c0a c5f30316 05f00f05 8de85000  8K,...........P.
 088e0 02954021 3a4614f0 9ffc1f2c 06d92f48  ..@!:F.....,../H
 088f0 40f22f11 42461346 01f0eaf9 012e2e4b  @./.BF.F.......K
 08900 19d11f5d 97b91e55 29480094 40213246  ...]...U)H..@!2F
 08910 2a4b14f0 89fc2046 294600f0 2bfb0028  *K.... F)F..+..(
 08920 3ad02248 40f23711 3a46e4e7 20462946  :."H@.7.:F.. F)F
 08930 00f036fb 30e0022e 20d113f8 0480b8f1  ..6.0... .......
 08940 000f10d1 1e551a48 00944021 3a461c4b  .....U.H..@!:F.K
 08950 14f06afc 20462946 00f0f8fa 18b11348  ..j. F)F.......H
 08960 4ff4a171 c6e72046 00f025fb 154b0030  O..q.. F..%..K.0
 08970 18bf0120 18550b4b 18800de0 0b4840f2  ... .U.K.....H@.
 08980 4b11b7e7 09484ff4 a8712a46 b3e70748  K....HO..q*F...H
 08990 40f25711 0022aee7 002004b0 bde8f081  @.W.."... ......
 089a0 9dee0100 ee1d0020 f21d0020 f1ee0100  ....... ... ....
 089b0 e02c0020 b1ef0100 361e0020 dfef0100  .,. ....6.. ....
 089c0 fcef0100 ce1d0020 13b55368 18681446  ....... ..Sh.h.F
 089d0 0ff062fd 024610b9 2a48b821 0ee0a0f5  ..b..F..*H.!....
 089e0 2952043a 042a47d8 dfe802f0 382d0e03  )R.:.*G.....8-..
 089f0 21002078 28b12348 bc210022 134601f0  !. x(.#H.!.".F..
 08a00 67f9a368 204a19e0 20780128 08d11f4b  g..h J.. x.(...K
 08a10 00931f4b 019304f1 08010022 402328e0  ...K......."@#(.
 08a20 28b9a368 194a9a60 a3684022 09e02078  (..h.J.`.h@".. x
 08a30 10b11448 cf21e0e7 a368164a 9a60a368  ...H.!...h.J.`.h
 08a40 01229a81 1ce02078 134b0128 0ad0a268  .".... x.K.(...h
 08a50 9360a368 02229a81 002011e0 20780128  .`.h."... .. x.(
 08a60 0dd10e4b 00930222 00230193 04f10801  ...K...".#......
 08a70 1346fff7 e3fe03e0 0248ea21 bde70e20  .F.......H.!... 
 08a80 02b010bd f1ee0100 46f00100 f61d0020  ........F...... 
 08a90 561e0020 f0ee0100 cc1d0020 f41d0020  V.. ....... ... 
 08aa0 2de9f043 1b4885b0 01f0cdf8 fff7ecfc  -..C.H..........
 08ab0 80462a20 01f0c2fe 0024174b e75c022f  .F* .....$.K.\./
 08ac0 23d12046 00f077fa 144e10f1 000918bf  #. F..w..N......
 08ad0 4ff00109 335d1ffa 89f5ab42 15d01048  O...3].....B...H
 08ae0 104b0094 40210022 14f09efb 05eb0425  .K..@!.".......%
 08af0 0d4b04aa 20351988 22f8025d 40463b46  .K.. 5.."..]@F;F
 08b00 0af066fb 08b904f8 06900134 202cd4d1  ..f........4 ,..
 08b10 cce700bf d8270020 361e0020 ce1d0020  .....'. 6.. ... 
 08b20 e02c0020 18f00100 f01d0020 02480349  .,. ....... .H.I
 08b30 00220bf0 39b800bf b0ee0100 a9870000  ."..9...........
 08b40 01460148 0bf07bbc b0ee0100 0649074a  .F.H..{......I.J
 08b50 074b9b1a 03dd043b c858d050 fbdc0548  .K.....;.X.P...H
 08b60 80470548 00470000 942e0200 d8000020  .G.H.G......... 
 08b70 54080020 918b0000 f9800000 fee7fee7  T.. ............
 08b80 fee7fee7 fee7fee7 fee7fee7 fee700bf  ................
 08b90 274b1b78 062b0ed1 264b1b68 19070ad1  'K.x.+..&K.h....
 08ba0 254b1b68 03f0f003 302b04d1 234b1b68  %K.h....0+..#K.h
 08bb0 13f0f00f 2ad01e4b 1b78062b 0ed11d4b  ....*..K.x.+...K
 08bc0 1b681a07 0ad11c4b 1b6803f0 f003302b  .h.....K.h....0+
 08bd0 04d11a4b 1b6813f0 f00f1dd0 144b1b78  ...K.h.......K.x
 08be0 062b0ed1 134b1b68 1b070ad1 124b1b68  .+...K.h.....K.h
 08bf0 03f0f003 302b04d1 104b1b68 13f0f003  ....0+...K.h....
 08c00 0ed00f4b 0f4a1a60 00f074bc 0e4ad368  ...K.J.`..t..J.h
 08c10 23f08073 d360cee7 0c4b0322 1a60dde7  #..s.`...K.".`..
 08c20 4ff08042 c2f80c31 c2f81031 e9e700bf  O..B...1...1....
 08c30 e00f00f0 e40f00f0 e80f00f0 ec0f00f0  ................
 08c40 18020020 0090d003 f0ed00e0 a0050040  ... ...........@
 08c50 f8b500f0 65fe0646 114d2c68 2f462cb1  ....e..F.M,h/F,.
 08c60 00f06cf9 a368c01a 002804da 386880b1  ..l..h...(..8h..
 08c70 00f0fcf8 0fe0e368 22690bb1 1a6100e0  .......h"i...a..
 08c80 6a602269 13600023 23616068 23689847  j`"i.`.##a`h#h.G
 08c90 e2e700f0 e3f83046 bde8f840 00f046be  ......0F...@..F.
 08ca0 002d0020 024b0022 83e80c00 00f0fcb8  .-. .K."........
 08cb0 002d0020 014b1b68 58437047 ec2c0020  .-. .K.hXCpG.,. 
 08cc0 034b1a68 531e1844 b0fbf2f0 704700bf  .K.hS..D....pG..
 08cd0 ec2c0020 10b50346 0c4618b9 0748ee21  .,. ...F.F...H.!
 08ce0 1a4604e0 29b90548 ef212246 234600f0  .F..)..H.!"F#F..
 08cf0 efff1960 42600022 026110bd 47f00100  ...`B`.".a..G...
 08d00 70b50d46 044620b9 1e484ff4 83712246  p..F.F ..HO..q"F
 08d10 05e00369 33b11b48 40f20711 00221346  ...i3..H@....".F
 08d20 00f0d6ff 00f0fcfd 174aa560 13680646  .........J.`.h.F
 08d30 33b92146 146041f8 0c3f2261 516016e0  3.!F.`A..?"aQ`..
 08d40 9868281a 002808da 19692161 1969e360  .h(..(...i!a.i.`
 08d50 0c6004f1 0c011961 09e0db68 002befd1  .`.....a...h.+..
 08d60 e3605368 23611c60 04f10c03 53601368  .`Sh#a.`....S`.h
 08d70 9c4202d1 204600f0 79f83046 bde87040  .B.. F..y.0F..p@
 08d80 00f0d4bd 47f00100 002d0020 38b50c46  ....G....-. 8..F
 08d90 054630b9 084840f2 31112a46 2b4600f0  .F0..H@.1.*F+F..
 08da0 97ff00f0 cbf8054b 196801fb 04012846  .......K.h....(F
 08db0 bde83840 fff7a4bf 47f00100 ec2c0020  ..8@....G....,. 
 08dc0 70b50446 30b91448 40f24711 22462346  p..F0..H@.G."F#F
 08dd0 00f07eff 00f0a4fd 22690546 bab10f49  ..~....."i.F...I
 08de0 e3680868 84420dbf 18460020 00260126  .h.h.B...F. .&.&
 08df0 0bb11a61 00e04a60 22691360 00232361  ...a..J`"i.`.##a
 08e00 2eb110b1 00f032f8 01e000f0 27f82846  ......2.....'.(F
 08e10 bde87040 00f08abd 47f00100 002d0020  ..p@....G....-. 
 08e20 08b50c4b d3f84c21 12b10022 c3f84c21  ...K..L!..."..L!
 08e30 094a9168 01319160 d3f80833 1b0307d5  .J.h.1.`...3....
 08e40 d3680133 d360fff7 03ff024b d3f84c31  .h.3.`.....K..L1
 08e50 08bd00bf 00800040 ec2c0020 024b4ff4  .......@.,. .KO.
 08e60 0022c3f8 08237047 00800040 0c4b4ff4  ."...#pG...@.KO.
 08e70 0021c3f8 08138268 c3f84c25 0020c3f8  .!.....h..L%. ..
 08e80 4c01c3f8 04130121 9964d3f8 48359b1a  L......!.d..H5..
 08e90 8342a2bf 034b4ff4 8072c3f8 00217047  .B...KO..r...!pG
 08ea0 00800040 00e100e0 38b51c4a a0f57423  ...@....8..J..t#
 08eb0 a3f51073 93422cd8 194ab2fb f0f300fb  ...s.B,..J......
 08ec0 03f19142 25d1013b 164a52f8 2320531c  ...B%..;.JR.# S.
 08ed0 1fd0eff3 108572b6 1349144b b0fbf3f3  ......r..I.K....
 08ee0 0b60134b 01210320 00245960 c3f80445  .`.K.!. .$Y`...E
 08ef0 c3f80805 c3f81025 08201960 0d4900f0  .......%. .`.I..
 08f00 0ffb0d4b 4ff48072 1a602db9 62b62846  ...KO..r.`-.b.(F
 08f10 38bd4ff0 ff3038bd 204638bd c0e1e400  8.O..08. F8.....
 08f20 0024f400 58f00100 ec2c0020 40420f00  .$..X....,. @B..
 08f30 00800040 218e0000 00e100e0 024b0122  ...@!........K."
 08f40 9a64d3f8 48057047 00800040 012904d0  .d..H.pG...@.)..
 08f50 02290cbf 04230023 00e00c23 4ff0a042  .)...#.#...#O..B
 08f60 00f5e071 42f82130 01238340 c2f81c35  ...qB.!0.#.@...5
 08f70 00207047 01234ff0 a0428340 11b1c2f8  . pG.#O..B.@....
 08f80 083501e0 c2f80c35 4ff0a042 00f5e071  .5.....5O..B...q
 08f90 012342f8 21308340 c2f81835 00207047  .#B.!0.@...5. pG
 08fa0 01234ff0 a0428340 11b1c2f8 08357047  .#O..B.@.....5pG
 08fb0 c2f80c35 70474ff0 a043d3f8 10250123  ...5pGO..C...%.#
 08fc0 03fa00f0 10407047 08b514f0 d5f90000  .....@pG........
 08fd0 08b50248 00f04afa 400808bd 082d0020  ...H..J.@....-. 
 08fe0 10b50244 904206d0 10f8013b 11f8014b  ...D.B.....;...K
 08ff0 1b1bf7d0 00e00023 184610bd 10b5431e  .......#.F....C.
 09000 0a449142 04d011f8 014b03f8 014ff8e7  .D.B.....K...O..
 09010 10bd0244 03469342 02d003f8 011bfae7  ...D.F.B........
 09020 70470eb4 03b503ab 4ff0ff31 53f8042b  pG......O..1S..+
 09030 019300f0 fbf902b0 5df804eb 03b07047  ........].....pG
 09040 034b43f2 0e325880 000c1a80 98807047  .KC..2X.......pG
 09050 082d0020 03461a46 01331178 0029fad1  .-. .F.F.3.x.)..
 09060 101a7047 2de9f74f d2f804b0 92f80380  ..pG-..O........
 09070 06460f46 92464ff0 00090124 00253046  .F.F.FO....$.%0F
 09080 39462246 2b4615f0 cdfa4945 08bf4045  9F"F+F....IE..@E
 09090 07d304fb 09f308fb 0533a4fb 08451d44  .........3...E.D
 090a0 ede74ff0 000c54ea 05033fd0 22462b46  ..O...T...?."F+F
 090b0 30463946 cdf804c0 15f0b4fa 22462b46  0F9F........"F+F
 090c0 80468946 30463946 15f0acfa 20462946  .F.F0F9F.... F)F
 090d0 16461f46 9af80320 002315f0 a3faddf8  .F.F... .#......
 090e0 04c00446 0d46bcf1 000f05d1 58ea0903  ...F.F......X...
 090f0 02d154ea 0503d6d1 b9f1000f 08bfb8f1  ..T.............
 09100 0a0f0bf1 01015ffa 88f307d3 9af80220  ......_........ 
 09110 12f0040f 14bf3722 572200e0 30221344  ......7"W"..0".D
 09120 8bf80030 0cf1010c 8b46bce7 00238bf8  ...0.....F...#..
 09130 003003b0 bde8f08f 07b50368 8df80710  .0.........h....
 09140 1b6813b9 4ff0ff30 07e00df1 07010122  .h..O..0......."
 09150 98470128 f6d19df8 07000130 18bf0120  .G.(.......0... 
 09160 03b05df8 04fb2de9 f0414b68 0d780746  ..]...-..AKh.x.F
 09170 0e4613f8 012b12b1 0db1013d f9e7b378  .F...+.....=...x
 09180 da077388 23f0fd03 9bb241f2 020248bf  ..s.#.....A...H.
 09190 05f1ff35 934201d1 023d05e0 40f60202  ...5.B...=..@...
 091a0 934208bf 05f1ff35 74788cb9 a846b8f1  .B.....5tx...F..
 091b0 000f07dd 38462021 fff7beff 08f1ff38  ....8F !.......8
 091c0 0444f4e7 6b1e002d acbf5d1b 1d4600e0  .D..k..-..]..F..
 091d0 0024b378 db0704d5 38462d21 fff7acff  .$.x....8F-!....
 091e0 04447388 23f0fd03 9bb241f2 02029342  .Ds.#.....A....B
 091f0 0dd13021 3846fff7 9fffb378 13f0040f  ..0!8F.....x....
 09200 044418bf 58213846 08bf7821 05e040f6  .D..X!8F..x!..@.
 09210 02029342 04d13846 3021fff7 8dff0444  ...B..8F0!.....D
 09220 737843b1 002d06dd 38463021 fff784ff  sxC..-..8F0!....
 09230 013d0444 f6e77568 15f8011b 21b13846  .=.D..uh....!.8F
 09240 fff77aff 0444f7e7 2046bde8 f08110b5  ..z..D.. F......
 09250 136808b1 01280ad1 21b1191d 11601868  .h...(..!....`.h
 09260 c11710bd 191d1160 18680021 10bd1946  .......`.h.!...F
 09270 002051f8 084b1160 20435968 10bdf0b5  . Q..K.` CYh....
 09280 8bb004ae 07460192 03960024 4d1c0978  .....F.....$M..x
 09290 002900f0 b9802529 40f0b080 9df80a30  .)....%)@......0
 092a0 002203f0 fd0362f3 00038df8 0a308df8  ."....b......0..
 092b0 09208df8 0820c3f3 400315f8 011b39b1  . ... ..@.....9.
 092c0 232903d0 302903d1 0122f6e7 0123f4e7  #)..0)..."...#..
 092d0 8df80920 9df80a20 63f34102 a1f13003  ... ... c.A...0.
 092e0 092b8df8 0a201cd8 0022a1f1 3003d8b2  .+... ..."..0...
 092f0 092805d8 0a2101fb 023215f8 011bf4e7  .(...!...2......
 09300 a1f16103 052b02d8 a1f15703 05e0a1f1  ..a..+....W.....
 09310 4103052b 03d8a1f1 37030a2b eadd8df8  A..+....7..+....
 09320 08206c29 09d12978 6c290dbf 69780135  . l)..)xl)..ix.5
 09330 01200235 08bf0220 00e00020 642920d0  . .5... ... d) .
 09340 0fd82529 5ad002d8 00295dd0 5ae05829  ..%)Z....)].Z.X)
 09350 2cd06329 56d1019b 1a1d0192 38461978  ,.c)V.......8F.x
 09360 4de07329 3ed005d8 69290ad0 6f2949d1  M.s)>...i)..o)I.
 09370 082329e0 752902d0 782917d0 42e00a23  .#).u)..x)..B..#
 09380 22e00a23 012101aa 8df80b30 fff75fff  "..#.!.....0.._.
 09390 002871f1 00031dda 9df80a30 404243f0  .(q........0@BC.
 093a0 010361eb 41018df8 0a3013e0 10238df8  ..a.A....0...#..
 093b0 0b30a1f1 58035942 59419df8 0a3061f3  .0..X.YBYA...0a.
 093c0 82038df8 0a3001e0 8df80b30 002101aa  .....0.....0.!..
 093d0 fff73dff 02aafff7 45fe3846 02a9fff7  ..=.....E.8F....
 093e0 c2fe0ee0 019b1a1d 01921b68 03933846  ...........h..8F
 093f0 02a9fff7 b8fe0396 044403e0 3846fff7  .........D..8F..
 09400 9bfe0444 294641e7 20460bb0 f0bdfff7  ...D)FA. F......
 09410 36bf0eb4 03b503aa 52f8041b 0192fff7  6.......R.......
 09420 2eff02b0 5df804eb 03b07047 7fb50646  ....].....pG...F
 09430 1c461546 68464a1e 314600f0 51f82246  .F.FhFJ.1F..Q."F
 09440 2946fff7 1cff019b 00221a70 029804b0  )F.......".p....
 09450 70bd0cb4 07b504ab 53f8042b 0193fff7  p.......S..+....
 09460 e5ff03b0 5df804eb 02b07047 42888388  ....].....pGB...
 09470 30b51404 00221219 04884ff0 00050146  0...."....O....F
 09480 6b410520 12194ff0 0005094c 6b415043  kA. ..O....LkAPC
 09490 04fb0300 a2fb0423 0b320344 43f10003  .......#.2.DC...
 094a0 100c40ea 03400a80 48808b80 30bd00bf  ..@..@..H...0...
 094b0 6de6ecde 30b50346 002012f1 ff320dd3  m...0..F. ...2..
 094c0 9c68dd68 0134ac42 9c60f6d8 5c68651c  .h.h.4.B.`..\he.
 094d0 5d600d78 25700130 0131eee7 30bd0000  ]`.x%p.0.1..0...
 094e0 10b54160 024c0460 00218160 c26010bd  ..A`.L.`.!.`.`..
 094f0 98f00100 074a084b 93421146 02d1074a  .....J.K.B.F...J
 09500 93607047 00228858 98500432 d82afad1  .`pG.".X.P.2.*..
 09510 f5e700bf 20800000 00000020 00ed00e0  .... ...... ....
 09520 034b1030 9b6843f8 2010bff3 5f8f7047  .K.0.hC. ..._.pG
 09530 00ed00e0 03784268 d1548378 5a1e0378  .....xBh.T.xZ..x
 09540 01331340 03707047 01460020 14f0feb8  .3.@.ppG.F. ....
 09550 70b50446 0e460025 b5420eda 63782278  p..F.F.%.B..cx"x
 09560 9a420ad0 6268d05c a2780133 013a1340  .B..bh.\.x.3.:.@
 09570 6370fff7 e9ff0135 eee770bd 7fb590f8  cp.....5..p.....
 09580 2a2090f8 283090f8 29600446 013a581c  * ..(0..)`.F.:X.
 09590 1040b042 06d1d4f8 b030002b 00f08980  .@.B.....0.+....
 095a0 984786e0 422904f1 28000ed8 41292fd2  .G..B)..(...A)/.
 095b0 0a2911d0 01d80829 28e00d29 0cd01b29  .).....)(..)...)
 095c0 4cd194f8 b8300122 18e04429 19d02ad3  L....0."..D)..*.
 095d0 5b290dd0 7f2919e0 0d230a21 02930191  [)...)...#.!....
 095e0 fff7a8ff d4f8b030 002b42d0 984740e0  .......0.+B..G@.
 095f0 94f8b830 03f00602 022a2fd1 62f34203  ...0.....*/.b.B.
 09600 0ee094f8 b85005f0 0605042d 26d112e0  .....P.....-&...
 09610 94f8b830 03f00602 042a1fd1 6ff34203  ...0.....*..o.B.
 09620 84f8b830 43e094f8 b83003f0 0603042b  ...0C....0.....+
 09630 08bf2021 12e094f8 b810b342 6ff34201  .. !.......Bo.B.
 09640 84f8b810 33d0013b 134084f8 28302022  ....3..;.@..(0 "
 09650 08230193 02920393 03250be0 94f8b830  .#.......%.....0
 09660 01916ff3 420384f8 b830fff7 63ff0125  ..o.B....0..c..%
 09670 00e00225 94f8b830 db0718d4 a3786278  ...%...0.....xbx
 09680 591e2378 d31a0b40 ab4203dc 20462946  Y.#x...@.B.. F)F
 09690 fff75eff 002601ab 204613f8 26100136  ..^..&.. F..&..6
 096a0 fff748ff ae42f6d1 002014f0 2bf80020  ..H..B... ..+.. 
 096b0 01e04ff0 ff3004b0 70bd0000 38b50546  ..O..0..p...8..F
 096c0 00f02ef9 04460f48 83785a1e 03780133  .....F.H.xZ..x.3
 096d0 13404278 93420dd1 002014f0 13f82046  .@Bx.B... .... F
 096e0 00f024f9 00f0c6f8 0028e9d0 012001f0  ..$......(... ..
 096f0 a5f8e5e7 2946fff7 1dff2046 bde83840  ....)F.... F..8@
 09700 00f014b9 182d0020 43780278 9a421fbf  .....-. Cx.x.B..
 09710 81784268 01f1ff31 d25c1fbf 01330b40  .xBh...1.\...3.@
 09720 43701046 08bf4ff0 ff307047 10b500f0  Cp.F..O..0pG....
 09730 f7f80446 0548064b c0f8b430 2021fff7  ...F.H.K...0 !..
 09740 07ff2046 bde81040 00f0f0b8 182d0020  .. F...@.....-. 
 09750 49950000 2de9f041 15460c46 8f18bc42  I...-..A.F.F...B
 09760 0fd02378 0e4e0a2b a04603d1 d6f8b430  ..#x.N.+.F.....0
 09770 0d209847 d6f8b430 98f80000 01349847  . .G...0.....4.G
 09780 ede735b1 14f8013c 064a0a3b 18bf0123  ..5....<.J.;...#
 09790 13600020 13f0b6ff 2846bde8 f08100bf  .`. ....(F......
 097a0 182d0020 142d0020 03460a46 00201946  .-. .-. .F.F. .F
 097b0 fff7d0bf 014b1868 704700bf 102d0020  .....K.hpG...-. 
 097c0 37b50546 134c0094 00201349 134b0246  7..F.L... .I.K.F
 097d0 13f086ff d8b92022 a27004f1 08026260  ...... ".p....b`
 097e0 802284f8 2a2004f1 3002e262 0c4ac4f8  ."..* ..0..b.J..
 097f0 b4200090 01904ff4 e1310822 0123c4f8  . ....O..1.".#..
 09800 b05013f0 cbff10b9 064b0122 1a6003b0  .P.......K.".`..
 09810 30bd00bf 182d0020 09970000 7d950000  0....-. ....}...
 09820 bd960000 102d0020 70b5114a 13680133  .....-. p..J.h.3
 09830 136000f0 75f80546 00f0c2ff 064600f0  .`..u..F.....F..
 09840 0dff0446 304600f0 b1f9a042 28bf2046  ...F0F.....B(. F
 09850 0b2805d9 b0f5963f 28bf4ff4 963000e0  .(.....?(.O..0..
 09860 002013f0 43fe2846 00f060f8 dde700bf  . ..C.(F..`.....
 09870 242e0020 014b1868 704700bf 282f0020  $.. .K.hpG..(/. 
 09880 1fb5ff22 4ff0ff33 8de80c00 064b0293  ..."O..3.....K..
 09890 40230393 0549064a 06480023 00f014ff  @#...I.J.H.#....
 098a0 05b05df8 04fb00bf 282e0020 a0f00100  ..].....(.. ....
 098b0 29980000 d42d0020 084b10b5 00241c60  )....-. .K...$.`
 098c0 5b60074b 1c605b60 00f060f8 28b10548  [`.K.`[`..`.(..H
 098d0 71212246 234600f0 fbf910bd 2c2f0020  q!"F#F......,/. 
 098e0 3c2f0020 a5f00100 08b500f0 b7f828b1  </. ..........(.
 098f0 00220348 7e211346 00f0eaf9 08bd00bf  .".H~!.F........
 09900 a5f00100 012000f0 61bf0000 08b500f0  ..... ..a.......
 09910 d7fd024b 4ff08052 5a6008bd 00ed00e0  ...KO..RZ`......
 09920 eff31080 72b600f0 01007047 00b962b6  ....r.....pG..b.
 09930 7047eff3 108000f0 01007047 70b5a1f1  pG........pGp...
 09940 20030646 0c46a1f1 4005a1f1 0c020021   ..F.F..@......!
 09950 43f8041f 9342fad1 284600f0 e8ff4ff0  C....B..(F....O.
 09960 807344f8 043c7369 44f8083c b36944f8  .sD..<siD..<.iD.
 09970 203c2846 70bd0000 034a5369 43f01003   <(Fp....JSiC...
 09980 5361fff7 7dbf00bf 00ed00e0 38b5eff3  Sa..}.......8...
 09990 0583002b 41d103f1 604202f5 61420133  ...+A...`B..aB.3
 099a0 ff21f02b 82f80013 f5d16ff0 0d001c49  .!.+......o....I
 099b0 fff7b6fd 6ff00c00 1949fff7 b1fd6ff0  ....o....I....o.
 099c0 0b001749 fff7acfd 6ff00a00 1449fff7  ...I....o....I..
 099d0 a7fd6ff0 09001249 fff7a2fd 002460b2  ..o....I.....$`.
 099e0 0f490134 fff79cfd 262cf8d1 0d4ce025  .I.4....&,...L.%
 099f0 13f0c6fc 84f82250 2025e577 00f08cff  ......"P %.w....
 09a00 eff31484 14f00104 02d1fff7 b5ff02e0  ................
 09a10 dff814c0 00df0020 38bd0720 38bd00bf  ....... 8.. 8...
 09a20 b1a90000 00ed00e0 79990000 10b500f0  ........y.......
 09a30 33fe0446 00f062fd 23682033 83f30988  3..F..b.#h 3....
 09a40 06218020 13f076fd 034b0122 20461a60  .!. ..v..K." F.`
 09a50 fff75cff a06910bd 282f0020 10b5eff3  ..\..i..(/. ....
 09a60 058494b9 eff31484 04f00304 022c02d0  .............,..
 09a70 032c05d0 0be0094c 2468e407 07d408e0  .,.....L$h......
 09a80 064c2468 e40704d4 01e00720 10bd0820  .L$h....... ... 
 09a90 10bddff8 0cc000df 002010bd 581e0020  ......... ..X.. 
 09aa0 2d9a0000 f8b50446 0e461546 00211c22  -......F.F.F.!."
 09ab0 1f46fff7 aefa0123 63706760 e660e561  .F.....#cpg`.`.a
 09ac0 f8bd0000 38b50446 fff72aff a2690546  ....8..F..*..i.F
 09ad0 4ab16369 0bb19a61 01e00849 4a60a269  J.ci...a...IJ`.i
 09ae0 13600023 a361e068 10b12146 00f0d1f8  .`.#.a.h..!F....
 09af0 2846bde8 3840fff7 19bf00bf 2c2f0020  (F..8@......,/. 
 09b00 70b50d1e 044615db fff70aff 06462046  p....F.......F F
 09b10 fff7d8ff 002d08bf 012500f0 51fe104a  .....-...%..Q..J
 09b20 28441368 20619bb1 1969411a 002903db  (D.h a...iA..)..
 09b30 5b69f8e7 022070bd 9a69a261 9a696361  [i... p..i.a.ica
 09b40 14601434 9c613046 fff7f0fe 002070bd  .`.4.a0F..... p.
 09b50 63615368 a3611c60 14345460 f3e700bf  caSh.a.`.4T`....
 09b60 2c2f0020 38b500f0 2bfe0546 fff7d8fe  ,/. 8...+..F....
 09b70 0d4a1468 7cb12369 eb1a002b 0adb6369  .J.h|.#i...+..ci
 09b80 a1690bb1 996100e0 5160a269 13600023  .i...a..Q`.i.`.#
 09b90 a36100e0 0024fff7 c9fe24b1 e0682146  .a...$....$..h!F
 09ba0 00f027f8 e2e738bd 2c2f0020 10b50446  ..'...8.,/. ...F
 09bb0 fff7bffe 024620b9 0748ba21 134600f0  .....F ..H.!.F..
 09bc0 87f8064b 1b6823b1 1869001b 20eae070  ...K.h#..i.. ..p
 09bd0 10bd4ff0 ff3010bd aaf00100 2c2f0020  ..O..0......,/. 
 09be0 10b50021 04460c22 fff713fa 231da360  ...!.F."....#..`
 09bf0 10bdf8b5 0d460646 fff792fe 2b780746  .....F.F....+x.F
 09c00 1bb1bde8 f840fff7 91be0124 2c70b268  .....@.....$,p.h
 09c10 ab601560 30680835 b56048b1 827b022a  .`.`0h.5.`H..{.*
 09c20 02d100f0 c3fc00e0 1c460023 336000e0  .........F.#3`..
 09c30 04463846 fff77afe 24b10020 bde8f840  .F8F..z.$.. ...@
 09c40 00f062bc f8bd70b5 0546fff7 69fe0646  ..b...p..F..i..F
 09c50 6c682cb1 a3686b60 a3b92b1d ab6011e0  lh,..hk`..+..`..
 09c60 00f046fc 4ff0ff31 286000f0 65fc3046  ..F.O..1(`..e.0F
 09c70 fff75cfe 204600f0 47fcfff7 51fe2c60  ..\. F..G...Q.,`
 09c80 0646e5e7 00233046 2370fff7 4ffe2046  .F...#0F#p..O. F
 09c90 70bd38b5 0c460546 fff742fe 23788bb1  p.8..F.F..B.#x..
 09ca0 6b68a342 04d1a368 6b605bb9 2b1d08e0  kh.B...hk`[.+...
 09cb0 9a68a242 01d01346 fae7a268 9a600ab9  .h.B...F...h.`..
 09cc0 0833ab60 00232370 bde83840 fff72ebe  .3.`.##p..8@....
 09cd0 70b50d46 1c460646 fff722fe fff726fd  p..F.F.F.."...&.
 09ce0 0a490b48 002c18bf 21463246 2b4613f0  .I.H.,..!F2F+F..
 09cf0 15ff13f0 9bfc00b1 00be064b 4ff00042  ...........KO..B
 09d00 5a60bff3 6f8f13f0 79fc00bf edfd0100  Z`..o...y.......
 09d10 b7f00100 00ed00e0 1b4d07b5 0446fff7  .........M...F..
 09d20 05fd6968 19482268 c1f30801 13f0f6fe  ..ih.H"h........
 09d30 23681748 da680092 0ecb13f0 effe2369  #h.H.h........#i
 09d40 0093211d 0ec91348 13f0e8fe 236a0093  ..!....H....#j..
 09d50 04f11401 0ec91048 13f0e0fe 23680f48  .......H....#h.H
 09d60 da690092 03f11001 0ec913f0 d7fe6968  .i............ih
 09d70 0b48ea6a ab6a13f0 d1fea96b 09486a6b  .H.j.j.....k.Hjk
 09d80 13f0ccfe 13f03afc 00ed00e0 d3f00100  ......:.........
 09d90 04f10100 35f10100 66f10100 97f10100  ....5...f.......
 09da0 c8f10100 f0f10100 8368c288 1b881033  .........h.....3
 09db0 03440068 1044181a 80b27047 074a10b5  .D.h.D....pG.J..
 09dc0 11680b46 23b11c88 844204d2 9b68f9e7  .h.F#....B...h..
 09dd0 09b15368 083b1846 10bd00bf 1c020020  ..Sh.;.F....... 
 09de0 38b5c388 04460d46 33b10022 084840f2  8....F.F3..".H@.
 09df0 a5111346 fff76cff 10301031 6a79fff7  ...F..l..0.1jy..
 09e00 fdf86b79 63716b79 10332344 236038bd  ..kycqky.3#D#`8.
 09e10 0cf20100 70b50446 00250560 0e466060  ....p..F.%.`.F``
 09e20 29460c22 0830fff7 f4f80223 6372e660  )F.".0.....#cr.`
 09e30 284670bd 38b50546 fff772fd 2c681cb1  (Fp.8..F..r.,h..
 09e40 63682b60 03b96d60 fff770fd 14b1a4f1  ch+`..m`..p.....
 09e50 100038bd 204638bd f8b55379 072b0646  ..8. F8...Sy.+.F
 09e60 0c461546 13d9fff7 5bfd0027 73686f61  .F.F....[..'shoa
 09e70 05f11002 14351a60 7560fff7 57fd2046  .....5.`u`..W. F
 09e80 3cb106f1 0801fff7 b4fe3846 f8bd0220  <.........8F... 
 09e90 f8bdf8bd 10b50c4a 13686bb1 04881988  .......J.hk.....
 09ea0 8c4201d8 9b68f8e7 99688160 11b900f1  .B...h...h.`....
 09eb0 08015160 986004e0 83605368 18600830  ..Q`.`...`Sh.`.0
 09ec0 50600020 10bd00bf 1c020020 103a0280  P`. ....... .:..
 09ed0 43804160 00207047 38b50388 8b420546  C.A`. pG8....B.F
 09ee0 0c460dd3 406800f0 87fa0023 48b11034  .F..@h.....#H..4
 09ef0 04440371 4371c360 c3800460 856038bd  .D.qCq.`...`.`8.
 09f00 002038bd 038810b5 01f10804 a3420ed3  . 8..........B..
 09f10 ff2c0cd8 0021fff7 dfff48b1 03684471  .,...!....H..hDq
 09f20 1c440023 04600382 43824361 10bd0020  .D.#.`..C.Ca... 
 09f30 10bd0830 084410b5 80b20c46 fff73eff  ...0.D.....F..>.
 09f40 20b1e1b2 bde81040 fff7dcbf 10bd0146   ......@.......F
 09f50 806808b5 10b14068 00f062fa 08bd10b5  .h....@h..b.....
 09f60 28b1c468 fff7f3ff 08b92046 f8e710bd  (..h...... F....
 09f70 2de9f047 0f469046 06460028 44d0d0f8  -..G.F.F.F.(D...
 09f80 08900546 eb680bb1 1d46fbe7 28464446  ...F.h...F..(FDF
 09f90 fff70aff 40b34045 a8bf4046 0446eb88  ....@.@E..@F.F..
 09fa0 28683946 18442246 fff728f8 eb882344  (h9F.D"F..(...#D
 09fb0 2744eb80 c4eb0804 16e04846 0021fff7  'D........HF.!..
 09fc0 8bff8246 90b1b9f8 0020a242 a8bf2246  ...F..... .B.."F
 09fd0 c2803946 0068fff7 11f8baf8 0630c5f8  ..9F.h.......0..
 09fe0 0ca01f44 e41a5546 002ce6dc 7379072b  ...D..UF.,..sy.+
 09ff0 05d9338a 9844c4eb 0808a6f8 1080201c  ..3..D........ .
 0a000 18bf0120 bde8f087 0220bde8 f08710b5  ... ..... ......
 0a010 50b1c488 c3688c42 01dc02d1 0bb91160  P....h.B.......`
 0a020 10bd091b 1846f3e7 10bdf7b5 06460846  .....F.......F.F
 0a030 114601aa 1d46fff7 eaff0746 a8b195b1  .F...F.....F....
 0a040 019bfc88 3968e41a ac42a8bf 2c46a4b2  ....9h...B..,F..
 0a050 30461944 2246fff7 8bff38b9 2d1badb2  0F.D"F....8.-...
 0a060 ff680190 ebe72846 00e00220 03b0f0bd  .h....(F... ....
 0a070 70b50446 16463ab9 002070bd 3cb1e288  p..F.F:.. p.<...
 0a080 914219db e468891a 0029f7dc 14e04ff0  .B...h...)....O.
 0a090 ff3070bd 002cfad0 e5882268 6d1ab542  .0p..,...."hm..B
 0a0a0 a8bf3546 11441846 2a46fef7 a7ffe468  ..5F.D.F*F.....h
 0a0b0 0346761b 2b440021 002eebdc dce770b5  .Fv.+D.!......p.
 0a0c0 04460028 45d00029 1adb0246 0b46002b  .F.(E..)...F.F.+
 0a0d0 0fddd088 984206dc 1b1a0020 d080d268  .....B..... ...h
 0a0e0 002af4d1 05e0c01a d0801068 03441360  .*.........h.D.`
 0a0f0 00236279 072a2cd9 228a511a 0b4411e0  .#by.*,.".Q..D..
 0a100 4b420025 c288c668 15440eb1 3046f9e7  KB.%...h.D..0F..
 0a110 9a426679 08db9bb2 d21a072e c28018d9  .Bfy............
 0a120 228ad31a 238270bd 294421ea e171072e  "...#.p.)D!..q..
 0a130 88bf2182 e3888b42 07dbe068 e18040b1  ..!....B...h..@.
 0a140 fff70dff 0023e360 70bde468 c91a002c  .....#.`p..h...,
 0a150 f0d170bd 2de9f341 1f1e9046 01dc0020  ..p.-..A...F... 
 0a160 22e001aa fff753ff 00260546 15b94ff0  ".....S..&.F..O.
 0a170 ff3019e0 019aeb88 bc1b9b1a 9c42a8bf  .0...........B..
 0a180 1c46002c 07dd2868 08eb0601 10442246  .F.,..(h.....D"F
 0a190 fef726ff 40b92644 be42e0d0 ed680023  ..&.@.&D.B...h.#
 0a1a0 0193002d e2d1e2e7 02b0bde8 f08170b5  ...-..........p.
 0a1b0 04460d46 61792268 e0880729 8cbf8bb2  .F.Fay"h...)....
 0a1c0 00231033 2344d31a 9bb2ab42 a8bf2b46  .#.3#D.....B..+F
 0a1d0 d21a0729 226088bf 228a9eb2 88bf9219  ...)"`..".......
 0a1e0 304488bf 2282ed1a e08022d0 0729a068  0D.."....."..).h
 0a1f0 04d90839 c9b2fff7 85fe02e0 0021fff7  ...9.........!..
 0a200 6bfe0646 20b92046 fff7a9fe 344610e0  k..F . F....4F..
 0a210 6379072b 04d92146 fff7e2fd 00236371  cy.+..!F.....#cq
 0a220 3046fff7 c1fd3368 f4601844 30603446  0F....3h.`.D0`4F
 0a230 c0e72046 70bd10b5 0346da68 0ab11346  .. Fp....F.h...F
 0a240 fbe7d960 4379072b 0fd94b79 072b03d9  ...`Cy.+..Ky.+..
 0a250 0a8a038a 134407e0 038a0a46 d488d268  .....D.....F...h
 0a260 23449bb2 002af9d1 03820023 4b7110bd  #D...*.....#Kq..
 0a270 2de9f843 d0f80880 b8f80030 8b420546  -..C.......0.B.F
 0a280 0e4602d2 0020bde8 f8830446 e7680fb1  .F... .....F.h..
 0a290 3c46fbe7 2046fff7 87fdb042 a14608d2  <F.. F.....B.F..
 0a2a0 40463946 fff718fe 04460028 ead0c9f8  @F9F.....F.(....
 0a2b0 0c00e388 20681844 3344e380 6b79072b  .... h.D3D..ky.+
 0a2c0 82bf2b8a f6182e82 bde8f883 2de9f843  ..+.........-..C
 0a2d0 c5888768 8d420446 0e4653d2 fff764fd  ...h.B.F.FS...d.
 0a2e0 2844b042 06dbe368 23b1761b b6b22546  (D.B...h#.v...%F
 0a2f0 1c4611e0 3b886279 9b1a9e42 3cdc3846  .F..;.by...B<.8F
 0a300 0021fff7 e9fd0546 002835d0 6379072b  .!.....F.(5.cy.+
 0a310 02d92146 fff764fd 2846fff7 45fd8046  ..!F..d.(F..E..F
 0a320 a146e788 eb882868 21684745 a8bf4746  .F....(h!hGE..GF
 0a330 b742a8bf 37461844 3a46fef7 5ffeeb88  .B..7F.D:F.._...
 0a340 bab21344 eb80e388 9b1ab61a 9bb2b6b2  ...D............
 0a350 e380c7eb 08082bb1 23681f44 2760002e  ......+.#h.D'`..
 0a360 dfd111e0 4846e468 fff7f1fd 66b1002c  ....HF.h....f..,
 0a370 d6d12846 fff7ebfd 2046fff7 f0fd0020  ..(F.... F..... 
 0a380 bde8f883 bde8f883 ec602846 bde8f883  .........`(F....
 0a390 70b550b3 4bb30029 27dd002a 25dd9c07  p.P.K..)'..*%...
 0a3a0 25d112f0 03041abf c4f10404 a4181446  %..............F
 0a3b0 0260049a 82618160 4160c360 43611d46  .`...a.`A`.`Ca.F
 0a3c0 0a46012a 04d02e19 2e60013a 3546f8e7  .F.*.....`.:5F..
 0a3d0 01396143 00225a50 06490261 4b681860  .9aC."ZP.I.aKh.`
 0a3e0 00f11003 4b601046 70bd0320 70bd0420  ....K`.Fp.. p.. 
 0a3f0 70bd00bf 24020020 38b50446 68b1fff7  p...$.. 8..Fh...
 0a400 8ffaa368 2bb16569 013b2a68 6261a360  ...h+.ei.;*hba.`
 0a410 00e01d46 fff78afa 00e00546 284638bd  ...F.......F(F8.
 0a420 70b50e46 054610b3 09b30468 c0686b68  p..F.F.....h.hkh
 0a430 14f00302 16bfc2f1 04022246 12198142  .........."F...B
 0a440 15d303fb 02039942 11d2081a b0fbf2f3  .......B........
 0a450 02fb1304 5cb9fff7 63fa6b69 3360ab68  ....\...c.ki3`.h
 0a460 6e610133 ab60fff7 61fa2046 70bd0320  na.3.`..a. Fp.. 
 0a470 70bd0000 38b5837b 012b0446 0ad1fff7  p...8..{.+.F....
 0a480 4ffa0e4a 136893b1 657b597b 8d4203d3  O..J.h..e{Y{.B..
 0a490 5b6cf8e7 022038bd 9a6ca264 9a6c6364  [l... 8..l.d.lcd
 0a4a0 14604434 9c64fff7 41fa0020 38bd6364  .`D4.d..A.. 8.cd
 0a4b0 5368a364 1c604434 5460f4e7 2c020020  Sh.d.`D4T`..,.. 
 0a4c0 084b1a68 824210b5 0bd0c36b 06490133  .K.h.B.....k.I.3
 0a4d0 c363064b 0c681868 936b0860 03441b1b  .c.K.h.h.k.`.D..
 0a4e0 936310bd 342f0020 382f0020 482f0020  .c..4/. 8/. H/. 
 0a4f0 014b1868 704700bf 342f0020 014b1860  .K.hpG..4/. .K.`
 0a500 704700bf 342f0020 38b50446 fff708fa  pG..4/. 8..F....
 0a510 05460cb9 064b1c68 064b1b68 9c4202d0  .F...K.h.K.h.B..
 0a520 2046fff7 f3f92846 bde83840 fff7feb9   F....(F..8@....
 0a530 2c020020 342f0020 38b5436c 826c0446  ,.. 4/. 8.Cl.l.F
 0a540 0d460bb1 9a6401e0 16494a60 a26c1360  .F...d...IJ`.l.`
 0a550 0223a373 00f034f9 28440135 6063124a  .#.s..4.(D.5`c.J
 0a560 05d1e37b 43f00103 e3730023 0ae01368  ...{C....s.#...h
 0a570 43b1d97b c9070cd4 596b091a 002908dc  C..{....Yk...)..
 0a580 5b6cf5e7 63645368 a3641c60 44345460  [l..cdSh.d.`D4T`
 0a590 06e09a6c a2649a6c 63641460 44349c64  ...l.d.lcd.`D4.d
 0a5a0 002038bd 2c020020 34020020 08b5837b  . 8.,.. 4.. ...{
 0a5b0 022b03d0 1848ce21 002205e0 c369abb1  .+...H.!."...i..
 0a5c0 1a6822b9 1448d321 1346fff7 81fb8242  .h"..H.!.F.....B
 0a5d0 02d1c26c 1a6006e0 d36c8342 01d01a46  ...l.`...l.B...F
 0a5e0 fae7c36c d3640023 c364c361 01238373  ...l.d.#.d.a.#.s
 0a5f0 00234363 c37b826c 23f00103 c373436c  .#Cc.{.l#....sCl
 0a600 0bb19a64 01e00549 4a60826c 1360fff7  ...d...IJ`.l.`..
 0a610 31ff0020 08bd00bf 16f20100 34020020  1.. ........4.. 
 0a620 70b500f0 cdf80546 fff77af9 0a4b0446  p......F..z..K.F
 0a630 186858b1 c37bdb07 08d4436b 466ceb1a  .hX..{....CkFl..
 0a640 002b03db fff7b2ff 3046f2e7 2046bde8  .+......0F.. F..
 0a650 7040fff7 6bb900bf 34020020 10b50446  p@..k...4.. ...F
 0a660 fff767f9 024628b9 094840f2 17111346  ..g..F(..H@....F
 0a670 fff72efb 074b1b68 3bb1da7b d20704d4  .....K.h;..{....
 0a680 586b001b 20eae070 10bd4ff0 ff3010bd  Xk.. ..p..O..0..
 0a690 16f20100 34020020 014b1868 704700bf  ....4.. .K.hpG..
 0a6a0 2c020020 837b012b 0ad1436c 826c0bb1  ,.. .{.+..Cl.l..
 0a6b0 9a6401e0 03494a60 826c1360 fff7dabe  .d...IJ`.l.`....
 0a6c0 704700bf 2c020020 2de9f047 04461f46  pG..,.. -..G.F.F
 0a6d0 89469246 00215022 ddf82480 0a9dbdf8  .F.F.!P"..$.....
 0a6e0 2c60fef7 96fca761 c4f814a0 fff718f9  ,`.....a........
 0a6f0 1f4b1f78 7a1c1a70 fff718f9 9df82030  .K.xz..p...... 0
 0a700 63730123 2773a373 04f12007 0023c4f8  cs.#'s.s.. ..#..
 0a710 10906363 384600f0 7ff938bb b8f1ff3f  ..cc8F....8....?
 0a720 01d10023 06e0c4f8 24803846 00f07cf9  ...#....$.8F..|.
 0a730 e0b9f6e7 b34204da 0e4a45f8 23200133  .....B...JE.# .3
 0a740 f8e705eb 86053246 20462946 fff7f6f8  ......2F F)F....
 0a750 00232364 084b2681 5a6884e8 21001460  .##d.K&.Zh..!..`
 0a760 204604f1 40025a60 fff784fe bde8f087   F..@.Z`........
 0a770 442f0020 efbeadde 3c2f0020 30b5d1e9  D/. ....</. 0...
 0a780 0045c309 8968e418 00f07f03 41f68460  .E...h......A..`
 0a790 00fb0310 094b9060 45f10005 9842c2e9  .....K.`E....B..
 0a7a0 004509dd 013445f1 0005a0f5 7420c2e9  .E...4E.....t ..
 0a7b0 0045a0f5 10709060 30bd00bf 3f420f00  .E...p.`0...?B..
 0a7c0 014b1868 704700bf 482f0020 f8b5041e  .K.hpG..H/. ....
 0a7d0 05da0022 16486121 1346fff7 79fa26d0  ...".Ha!.F..y.&.
 0a7e0 144efff7 9df83368 0746e018 90ea030f  .N....3h.F......
 0a7f0 306010d5 104d2946 51f8084b 041b0a46  0`...M)FQ..K...F
 0a800 2046fff7 bbff05f1 18012046 0a46fff7   F........ F.F..
 0a810 b5ff3368 2b603846 fff788f8 fff7a2f9  ..3h+`8F........
 0a820 fff7fefe 0020bde8 f840fff7 6dbef8bd  ..... ...@..m...
 0a830 21f20100 482f0020 601e0020 38b5051e  !...H/. `.. 8...
 0a840 0fddfff7 6df80446 fff752fe 2946fff7  ....m..F..R.)F..
 0a850 73fe2046 fff76af8 0020bde8 3840fff7  s. F..j.. ..8@..
 0a860 53be38bd 70b50546 0c46fff7 59f80646  S.8.p..F.F..Y..F
 0a870 45b1094b 09491868 51f8183b 2a46c01a  E..K.I.hQ..;*F..
 0a880 fff77cff 14b1064b 18682060 3046fff7  ..|....K.h `0F..
 0a890 4df80020 70bd00bf 482f0020 601e0020  M.. p...H/. `.. 
 0a8a0 881e0020 7fb5fff7 3bf8114d 05f10803  ... ....;..M....
 0a8b0 06460fcb 8de80f00 0e4b2d68 1b686c46  .F.......K-h.hlF
 0a8c0 5d1b3046 fff732f8 28466946 2246fff7  ].0F..2.(FiF"F..
 0a8d0 55ff0949 009a0198 a2fb0123 01fb0033  U..I.......#...3
 0a8e0 02981418 43ebe075 29462046 04b070bd  ....C..u)F F..p.
 0a8f0 601e0020 482f0020 40420f00 10b50346  `.. H/. @B.....F
 0a900 0c464ff4 7a72590e c0010023 13f08afe  .FO.zrY....#....
 0a910 20600020 10bd0000 684680f3 09882c48   `. ....hF....,H
 0a920 00780230 80f31488 bff36f8f 704780e8  .x.0......o.pG..
 0a930 f00f7047 eff30980 816911f8 021c51b9  ..pG.....i....Q.
 0a940 90e80f10 10b5e047 bde81040 eff3098c  .......G...@....
 0a950 8ce80700 704710b5 1e4a1268 914209d8  ....pG...J.h.B..
 0a960 1d4c54f8 214090e8 0f10a047 eff3098c  .LT.!@.....G....
 0a970 8ce80f00 bde81040 7047184b 1a68184b  .......@pG.K.h.K
 0a980 19689142 08bf7047 eff3098c 2ce9f00f  .h.B..pG....,...
 0a990 c1f800c0 1a60d2f8 00c0bce8 f00f8cf3  .....`..........
 0a9a0 09887047 10b5fef7 adffbde8 10407047  ..pG.........@pG
 0a9b0 1ef0040f 0cbfeff3 0883eff3 09832de9  ..............-.
 0a9c0 f84f6846 fff7a8f9 bde8f84f 70470000  .OhF.......OpG..
 0a9d0 581e0020 00000000 fcffffff 2c020020  X.. ........,.. 
 0a9e0 342f0020 08b5044b 186820b1 03484ff0  4/. ...K.h ..HO.
 0a9f0 ff3100f0 7bf808bd 282f0020 502f0020  .1..{...(/. P/. 
 0aa00 08b5034b 186810b1 024800f0 27f808bd  ...K.h...H..'...
 0aa10 282f0020 502f0020 08b50021 1422fef7  (/. P/. ...!."..
 0aa20 f8fa0020 08bd0000 10b50446 fff7daff  ... .......F....
 0aa30 38b9044b 1a682261 1c60bde8 1040fff7  8..K.h"a.`...@..
 0aa40 dfbf10bd 901e0020 30b10023 4371c380  ....... 0..#Cq..
 0aa50 83600360 18467047 03207047 f8b5214b  .`.`.FpG. pG..!K
 0aa60 1b680446 002b36d0 002836d0 fff740fd  .h.F.+6..(6...@.
 0aa70 e388002b 33d0a568 854230d1 013b9bb2  ...+3..h.B0..;..
 0aa80 e38033bb fef74cff 63796a7b 9a420746  ..3...L.cyj{.B.F
 0aa90 03d06b73 2846fff7 05fe2668 6eb1f269  ..ks(F....&hn..i
 0aaa0 22b91148 68211346 fff712f9 3046fff7  "..Hh!.F....0F..
 0aab0 7dfd0123 e380737b 6371a660 fff7ecfd  }..#..s{cq.`....
 0aac0 04463846 fef732ff ac4202d0 2046fff7  .F8F..2..B.. F..
 0aad0 1bfd0020 f8bd0920 f8bd0320 f8bd0520  ... ... ... ... 
 0aae0 f8bd00bf 282f0020 2bf20100 364b1b68  ....(/. +...6K.h
 0aaf0 2de9f041 06468846 002b5ed0 00285fd0  -..A.F.F.+^..(_.
 0ab00 fef70eff 0746fff7 f3fcf588 04462db9  .....F.......F-.
 0ab10 b060437b 73710123 f38004e0 b3688342  .`C{sq.#.....h.B
 0ab20 07d1681c f0803846 fef700ff 0020bde8  ..h...8F..... ..
 0ab30 f081b8f1 000f05d1 3846fef7 f7fe0620  ........8F..... 
 0ab40 bde8f081 427b597b 914203d9 5a73b068  ....B{Y{.B..Zs.h
 0ab50 fff7a8fd 326882b1 657b1346 0021587b  ....2h..e{.F.!X{
 0ab60 a84204d8 d86c1946 18b10346 f7e70b46  .B...l.F...F...F
 0ab70 19b1da6c e264dc64 01e0e264 3460e37b  ...l.d.d...d4`.{
 0ab80 e66143f0 0403e373 41462046 fff7d4fc  .aC....sAF F....
 0ab90 3846fef7 cbfe0020 fff7b6fc fef7c0fe  8F..... ........
 0aba0 e37b23f0 0403e373 fef7c0fe b068a042  .{#....s.....h.B
 0abb0 14bf0620 0020bde8 f0810920 bde8f081  ... . ..... ....
 0abc0 0320bde8 f08100bf 282f0020 08b506f0  . ......(/. ....
 0abd0 65fd0b4b 1b7888b9 022b0bd0 042b05d0  e..K.x...+...+..
 0abe0 012b0bd1 bde80840 00f09ebf bde80840  .+.....@.......@
 0abf0 01f07abc bde80840 05f07cb9 08bd00bf  ..z....@..|.....
 0ac00 c0320020 10b50446 236843b1 a3f11000  .2. ...F#hC.....
 0ac10 5b682360 03b96460 fff7a1f9 f4e710bd  [h#`..d`........
 0ac20 f8b506f0 97f90020 06f084fa 03f09cff  ....... ........
 0ac30 04f074fc 7c48fff7 06f84378 013b152b  ..t.|H....Cx.;.+
 0ac40 00f2eb80 dfe813f0 1600e900 e900e900  ................
 0ac50 e900e900 e900e900 e900e900 e900e900  ................
 0ac60 e900e900 e9001f00 22005400 2600e100  ........".T.&...
 0ac70 e500d000 c2691ab9 6c484ff4 5d71d0e0  .....i..lHO.]q..
 0ac80 40689047 d6e703f0 b9ffd3e7 406800f0  @h.G........@h..
 0ac90 79fecfe7 406804f0 89ffcbe7 fef740fe  y...@h........@.
 0aca0 6b6b5b68 6b63a4f1 100613b9 05f13403  kk[hkc........4.
 0acb0 ab63fef7 3bfe54f8 101c237a 08782588  .c..;.T...#z.x%.
 0acc0 677a13f0 800f04f1 080200f0 0f00584b  gz............XK
 0acd0 3dd0242f 11d81f6b 01371f63 9f6b3d44  =.$/...k.7.c.k=D
 0ace0 9d63657a 242d43d8 30461146 02f026f8  .cez$-C.0F.F..&.
 0acf0 504d6c6b 002cd1d1 9ce71f6a 01371f62  PMlk.,.....j.7.b
 0ad00 9f6a3d44 9d620628 ebd8dfe8 00f00408  .j=D.b.(........
 0ad10 0c101418 1c005d6c 01355d64 e1e79d6c  ......]l.5]d...l
 0ad20 01359d64 dde7dd6c 0135dd64 d9e71d6d  .5.d...l.5.d...m
 0ad30 01351d65 d5e75d6d 01355d65 d1e79d6d  .5.e..]m.5]e...m
 0ad40 01359d65 cde7dd6d 0135dd65 c9e7242f  .5.e...m.5.e..$/
 0ad50 95bf5f6b 5f6a0137 013795bf 5f635f62  .._k_j.7.7.._c_b
 0ad60 df6bdf6a 95bfed19 ed19dd63 dd62b8e7  .k.j.......c.b..
 0ad70 247a04f0 0304022c 06d0032c 07d0012c  $z.....,...,...,
 0ad80 0ad100f0 9dfe0ae0 05f0c4f8 07e00846  ...............F
 0ad90 114601f0 edfd02e0 9a690132 9a613046  .F.......i.2.a0F
 0ada0 fff7ddf8 a4e76268 9a64a4f1 100512b9  ......bh.d......
 0adb0 03f14802 da6454f8 100c12f0 68f90646  ..H..dT.....h..F
 0adc0 54f8100c 023012f0 62f90421 07462846  T....0..b..!.F(F
 0add0 fff775f9 2288ba42 0bd0154a d3692846  ..u."..B...J.i(F
 0ade0 0133d361 fff7bbf8 124b9c6c 002cdad1  .3.a.....K.l.,..
 0adf0 20e706f4 4053b3f5 805feed8 002aecd0   ...@S..._...*..
 0ae00 28463146 02f0bcf9 eee74068 01f062ff  (F1F......@h..b.
 0ae10 10e74068 01f046fd 0ce70448 40f28e31  ..@h..F....H@..1
 0ae20 00221346 fef754ff c8320020 36f20100  .".F..T..2. 6...
 0ae30 ac300020 c0320020 1b38e028 8cbf0020  .0. .2. .8.(... 
 0ae40 01207047 a0f5a470 b0f5e06f 8cbf0020  . pG...p...o... 
 0ae50 01207047 39b14079 00f0c000 a0f14003  . pG9.@y......@.
 0ae60 58425841 70470846 70470000 10b50146  XBXApG.FpG.....F
 0ae70 431e021d 002013f8 014f2044 934280b2  C.... ...O D.B..
 0ae80 f9d14b79 03f03f04 204480b2 00b340f2  ..Ky..?. D....@.
 0ae90 3a529042 1bd003f0 c003c02b 15d0402b  :R.B.......+..@+
 0aea0 0ad10b79 ca78e018 801811d0 40f23d23  ...y.x......@.=#
 0aeb0 c01a18bf 012010bd 4bb90622 0548fef7  ..... ..K..".H..
 0aec0 8ff80030 18bf0120 10bd0120 10bd0020  ...0... ... ... 
 0aed0 10bd00bf d8000020 10b50446 fff7c6ff  ....... ...F....
 0aee0 30b1044b 22681a60 a2889a80 002010bd  0..K"h.`..... ..
 0aef0 122010bd 10280020 08b5074a 03460748  . ...(. ...J.F.H
 0af00 002908bf 10461946 0622fef7 69f8b0fa  .)...F.F."..i...
 0af10 80f04009 08bd00bf d8000020 10280020  ..@........ .(. 
 0af20 01460148 fdf7ecbe d4320020 0148fdf7  .F.H.....2. .H..
 0af30 47bf00bf d4320020 06490023 43618b6b  G....2. .I.#Ca.k
 0af40 00f11002 14301a60 886301f1 08002831  .....0.`.c....(1
 0af50 fef74fbe c0320020 38b50b4d 0446fef7  ..O..2. 8..M.F..
 0af60 dffc0023 6361eb6c 04f11002 1a601434  ...#ca.l.....`.4
 0af70 ec64fef7 dbfc05f1 080005f1 3c01bde8  .d..........<...
 0af80 3840fef7 36be00bf c0320020 242910b5  8@..6....2. $)..
 0af90 02681e4b 044611d8 1b78042b 08d106f0  .h.K.F...x.+....
 0afa0 77fb0146 04f11800 bde81040 01f096be  w..F.......@....
 0afb0 174a9369 01339361 002010bd 1b781078  .J.i.3.a. ...x.x
 0afc0 013b00f0 0f00032b 18d8dfe8 03f0020b  .;.....+........
 0afd0 0610bde8 104000f0 b9bc0128 8cbf0020  .....@.....(... 
 0afe0 012010bd 2146bde8 104004f0 39be0022  . ..!F...@..9.."
 0aff0 084840f2 c7211346 fef76afe 044a9369  .H@..!.F..j..J.i
 0b000 01339361 4ff0ff30 10bd00bf c0320020  .3.aO..0.....2. 
 0b010 ac300020 36f20100 f8b54b78 0d780268  .0. 6.....Kx.x.h
 0b020 25f07f05 242b0446 0f46edb2 537809d8  %...$+.F.F..Sx..
 0b030 02330382 c380fff7 7fff2046 bde8f840  .3........ F...@
 0b040 01f036bf 167803f0 3f039a1c 06f00f06  ..6..x..?.......
 0b050 0282c280 a5b1062e 37d80122 b24012f0  ........7..".@..
 0b060 550f08d1 12f00a0f 03d19206 2dd5222b  U...........-."+
 0b070 05e00c2b 03e0063b 1f2b26d8 00e024d1  ...+...;.+&...$.
 0b080 3b7803f0 0303022b 09d0032b 0dd0012b  ;x.....+...+...+
 0b090 10d13046 21462a46 00f0a6fb 03e02046  ..0F!F*F...... F
 0b0a0 294604f0 fbfd0546 0ae02046 294601f0  )F.....F.. F)F..
 0b0b0 a5fcf8e7 0a4a9369 01339361 4ff0ff35  .....J.i.3.aO..5
 0b0c0 64b12046 fff738ff 08e0054a 136c2046  d. F..8....J.l F
 0b0d0 01331364 0024fef7 42ffd1e7 2846f8bd  .3.d.$..B...(F..
 0b0e0 ac300020 014b1870 704700bf c0320020  .0. .K.ppG...2. 
 0b0f0 014b1878 704700bf c0320020 01460148  .K.xpG...2. .F.H
 0b100 fef777bd c8320020 4ff0ff30 40f2ff31  ..w..2. O..0@..1
 0b110 70470000 014b5878 704700bf c0320020  pG...KXxpG...2. 
 0b120 8bb2c380 03820023 03764376 8176c276  .......#.vCv.v.v
 0b130 70470000 10b506f0 71f8fef7 f1fb0446  pG......q......F
 0b140 fff7f4fe 05f04efc 2046134c fef7eefb  ......N. F.L....
 0b150 05f0eaf8 00f00efd 2046fff7 53fda4f1  ........ F..S...
 0b160 1400fff7 4ffd0021 78220c48 fdf751ff  ....O..!x".H..Q.
 0b170 02f022f9 04f006f8 00210622 084804f8  .."......!.".H..
 0b180 481cfdf7 46ff05f0 67fc04f0 adfbbde8  H...F...g.......
 0b190 104005f0 dfbe00bf 08330020 b8300020  .@.......3. .0. 
 0b1a0 10280020 7fb5234c 064604f1 0800a170  .(. ..#L.F.....p
 0b1b0 a280fef7 15fd2346 002543f8 485fe364  ......#F.%C.H_.d
 0b1c0 23462a46 43f8345f a3631223 1a4984f8  #F*FC.4_.c.#.I..
 0b1d0 293004f1 14001623 84f83d30 fdf77afd  )0.....#..=0..z.
 0b1e0 03f0d0ff 05f004fc 00f0aefc 05f072f8  ..............r.
 0b1f0 02f02af9 04f066fb 04f09cf9 fd236370  ..*...f......#cp
 0b200 4ff0ff33 0d4c0193 0d4b0293 50230393  O..3.L...K..P#..
 0b210 21462b46 00960b4a 0b48fff7 55fa0095  !F+F...J.H..U...
 0b220 01940421 1e222b46 084812f0 8ff804b0  ...!."+F.H......
 0b230 70bd00bf c0320020 cdab0000 3ff20100  p....2. ....?...
 0b240 30310020 21ac0000 70320020 ac300020  01. !...p2. .0. 
 0b250 08b500f1 80010448 fef7cbfc 0020bde8  .......H..... ..
 0b260 0840fff7 3fbf00bf c8320020 70b50446  .@..?....2. p..F
 0b270 184bc4f8 9800457a c0f89c30 012380f8  .K....Ez...0.#..
 0b280 8c304378 0a35ed00 042b09d8 dfe803f0  .0Cx.5...+......
 0b290 06030608 030005f5 fb7501e0 05f55575  .........u....Uu
 0b2a0 39b1fdf7 4bfe0646 c4f89000 05f1f000  9...K..F........
 0b2b0 09e0be20 e669fdf7 fdfc301a e669c4f8  ... .i....0..i..
 0b2c0 900005f1 3200fdf7 f5fc3044 c4f89400  ....2.....0D....
 0b2d0 70bd00bf d9b20000 f8b5c468 00210546  p..........h.!.F
 0b2e0 0a46e079 05f046ff 18b14848 4ff4b771  .F.y..F...HHO..q
 0b2f0 47e06868 323006f0 15f920b1 444a536e  G.hh20.... .DJSn
 0b300 01335366 7ce005f0 f9feff23 a37204f0  .3Sf|......#.r..
 0b310 d3fa10b1 06f0caf9 01e006f0 d7f96378  ..............cx
 0b320 032b05d1 3b482146 05f0fefe 002704e0  .+..;H!F.....'..
 0b330 00200146 05f0f8fe 02274ff4 82700821  . .F.....'O..p.!
 0b340 fef7f7fd 054610b9 05f068ff 58e06378  .....F....h.X.cx
 0b350 a678042b 13d8dfe8 03f00d05 0f030500  .x.+............
 0b360 02220ae0 637b002b 0cbf0122 81220c21  ."..c{.+...".".!
 0b370 00260ce0 002200e0 06221f2e 05d92348  .&..."..."....#H
 0b380 f0210022 1346fef7 a3fcb11d c9b28b1c  .!.".F..........
 0b390 6372237b 0bb142f0 40022846 fff7c0fe  cr#{..B.@.(F....
 0b3a0 22462b68 52f8281f 19609288 9a80e27a  "F+hR.(..`.....z
 0b3b0 981d32b1 224652f8 3a1fc3f8 06109388  ..2."FR.:.......
 0b3c0 838026b1 04f14001 3246fdf7 17fe2846  ..&...@.2F....(F
 0b3d0 394606f0 c9f80646 2846fef7 c0fd7eb9  9F.....F(F....~.
 0b3e0 237913b1 05f0a0fb 01e005f0 9ffb0120  #y............. 
 0b3f0 fff778fe 064a136e 01331366 0020f8bd  ..x..J.n.3.f. ..
 0b400 2046fff7 25ff0120 f8bd00bf 46f20100   F..%.. ....F...
 0b410 ac300020 51b20000 38b50f4c 2378cbb1  .0. Q...8..L#x..
 0b420 04f18c00 05f0a0fa 04f18001 0b48fef7  .............H..
 0b430 30fcfef7 75fa0546 fff75afe 012804d1  0...u..F..Z..(..
 0b440 fff774fd 0020fff7 4dfe2846 fef76efa  ..t.. ..M.(F..n.
 0b450 00232370 38bd00bf 10330020 c8320020  .##p8....3. .2. 
 0b460 2de9f041 4379012b 044636d9 fff7a8f9  -..ACy.+.F6.....
 0b470 636ac31a 002b0546 2fdb04f1 340804f1  cj...+.F/...4...
 0b480 28070123 4046a179 3a4604f0 cdf9e37a  (..#@F.y:F.....z
 0b490 9bb104f1 3a06a179 40463246 002304f0  ....:..y@F2F.#..
 0b4a0 c3f93046 0121fff7 d5fc08b1 012303e0  ..0F.!.......#..
 0b4b0 637913f0 0103f9d1 637304f0 6df92844  cy......cs..m.(D
 0b4c0 60620121 3846fff7 c5fc08b1 012303e0  `b.!8F.......#..
 0b4d0 637913f0 0103f9d1 2373bde8 f0810000  cy......#s......
 0b4e0 0148fff7 b5be00bf 10330020 2de9f84f  .H.......3. -..O
 0b4f0 374c94f8 00a00546 baf1000f 65d111f0  7L.....F....e...
 0b500 c6fd0646 a81c11f0 c2fd95f8 048095f8  ...F............
 0b510 0e9084f8 0ba00746 b8f1040f 17d8dfe8  .......F........
 0b520 08f01905 03030900 a02314e0 00231f46  .........#...#.F
 0b530 1e4600e0 20230122 e2722a46 4ff00009  .F.. #.".r*FO...
 0b540 52f8070f 60639188 224a9180 03e04ff6  R...`c.."J....O.
 0b550 ff7300e0 2023be42 02d91220 bde8f88f  .s.. #.B... ....
 0b560 9e42fad3 b6f5804f f7d8b7f5 804ff4d8  .B.....O.....O..
 0b570 95f805a0 95f806b0 baf1030f edd8bbf1  ................
 0b580 010fead8 baf1010f 09d92b46 114a53f8  ..........+F.JS.
 0b590 070f1060 9b889380 fff712f9 60626b7b  ...`........`bk{
 0b5a0 13f0f800 d9d1002b d7d0b9f1 030fd4d8  .......+........
 0b5b0 84f805a0 84f806b0 84f80490 e37084f8  .............p..
 0b5c0 0180e681 2782bde8 f88f0c20 bde8f88f  ....'...... ....
 0b5d0 10330020 44330020 38b50446 be20fdf7  .3. D3. 8..F. ..
 0b5e0 69fb054d 04440548 ac61ec61 fdf762fb  i..M.D.H.a.a..b.
 0b5f0 20442862 38bd00bf 10330020 00881300   D(b8....3. ....
 0b600 00230122 03700a70 18467047 38b50478  .#.".p.p.FpG8..x
 0b610 012c50d1 2b4b1a78 1c46002a 4ed15b79  .,P.+K.x.F.*N.[y
 0b620 012b07d0 6379274a 13f00103 09d11373  .+..cy'J.......s
 0b630 254a09e0 2548fff7 19fc0028 f2d10c20  %J..%H.....(... 
 0b640 38bd0123 1373214a 1e4b1068 9288a062  8..#.s!J.K.h...b
 0b650 9a85e27a 62b11a46 52f8340f c3f83a00  ...zb..FR.4...:.
 0b660 9288da87 9a7912f0 010218bf 01225a73  .....y......."Zs
 0b670 144d2846 fff7f4fe 01232370 6378012b  .M(F.....##pcx.+
 0b680 1bbf2a8a 40f27123 40f6a663 53436b61  ..*.@.q#@..cSCka
 0b690 e378da07 05d413f0 020f14bf 26232723  .x..........&#'#
 0b6a0 00e02523 0748e371 0121fff7 dffd0848  ..%#.H.q.!.....H
 0b6b0 05f0a6f8 02e01cb9 fff7aefe 002038bd  ............. 8.
 0b6c0 122038bd 10330020 d8000020 10280020  . 8..3. ... .(. 
 0b6d0 9c330020 08b50278 1f2a0146 07d80548  .3. ...x.*.F...H
 0b6e0 01310272 5f30fdf7 89fc0020 08bd1220  .1.r_0..... ... 
 0b6f0 08bd00bf 10330020 08b50278 1f2a0146  .....3. ...x.*.F
 0b700 07d80548 01318270 4030fdf7 77fc0020  ...H.1.p@0..w.. 
 0b710 08bd1220 08bd00bf 10330020 2de9f843  ... .....3. -..C
 0b720 0d7805f0 40030646 0f4603f0 ff04002b  .x..@..F.F.....+
 0b730 4fd0294a 04785378 05f00405 012bedb2  O.)J.xSx.....+..
 0b740 00f10209 c4f38014 904601d0 042b15d1  .........F...+..
 0b750 45b198f9 0a20214b 282101fb 0233991c  E.... !K(!...3..
 0b760 5c7800e0 494698f8 0630a342 04d11c48  \x..IF...0.B...H
 0b770 0622fdf7 35fc08b1 00242ae0 d5b1194b  ."..5....$*....K
 0b780 d9f80020 1a60b9f8 04209a80 134998f9  ... .`... ...I..
 0b790 0a302820 00fb0313 53f8022f c6f80220  .0( ....S../... 
 0b7a0 9b88a9f8 043098f9 0a2000fb 02135c78  .....0... ....\x
 0b7b0 0234e4b2 73787968 03f03f03 0a332246  .4..sxyh..?..3"F
 0b7c0 304601eb c30101f0 1ffd0446 08b1fff7  0F.........F....
 0b7d0 23fe2046 bde8f883 10330020 24360020  #. F.....3. $6. 
 0b7e0 44330020 3e330020 2de9f047 80460d46  D3. >3. -..G.F.F
 0b7f0 19b95048 fff72cfd 79e0002a 77d00328  ..PH..,.y..*w..(
 0b800 01d00528 73d12e68 4b48dff8 2c9106f1  ...(s..hKH..,...
 0b810 08010622 fdf7e4fb 002868d1 a9f12807  ...".....(h...(.
 0b820 16f802ab 3c79b8f1 030fcaf3 801a18bf  ....<y..........
 0b830 04f00204 30465146 0cbf04f0 0104e4b2  ....0FQF........
 0b840 fff708fb c8b104f0 37f8b0b1 05f0d6fa  ........7.......
 0b850 c0b243b2 002bb872 0ddb2a7e 42f00402  ..C..+.r..*~B...
 0b860 2a768cb1 354a2820 00fb0320 861c90f8  *v..5J( ... ....
 0b870 01a00122 03e03cb1 39e02cb1 00223046  ..."..<.9.,.."0F
 0b880 514605f0 09f990b3 2b7eb8f1 030f43f0  QF......+~....C.
 0b890 40032b76 2bd14ff4 82700821 fef749fb  @.+v+.O..p.!..I.
 0b8a0 064620b3 3c7adff8 8c801f2c 06d90022  .F .<z.....,..."
 0b8b0 234840f2 23111346 fef70afa 98f80c30  #H@.#..F.......0
 0b8c0 a11d002b 0cbf0422 4422c9b2 fff728fc  ...+..."D"....(.
 0b8d0 3368d9f8 00001860 b9f80420 9a8064b1  3h.....`... ..d.
 0b8e0 981d08f1 5f012246 fdf788fb 05e04ff0  ...._."F......O.
 0b8f0 ff340020 fff7f6fb 18e01248 0d4905f0  .4. .......H.I..
 0b900 13fc3046 002105f0 2ffe0446 48b92b7e  ..0F.!../..FH.+~
 0b910 0d4a43f0 10032b76 d2f88030 0133c2f8  .JC...+v...0.3..
 0b920 80303046 fef71bfb 002ce2d1 2046bde8  .00F.....,.. F..
 0b930 f08700bf 10330020 38330020 24360020  .....3. 83. $6. 
 0b940 46f20100 51b20000 ac300020 032808b5  F...Q....0. .(..
 0b950 06d10b4b 5b7813f0 fd0f0bd1 012008bd  ...K[x....... ..
 0b960 052807d1 064b5b78 042b01d0 012b01d8  .(...K[x.+...+..
 0b970 002008bd 0248fff7 6bfc4ff0 ff3008bd  . ...H..k.O..0..
 0b980 10330020 2de9f041 02780446 2ab94a48  .3. -..A.x.F*.JH
 0b990 40f2b941 1346fef7 9bf900f1 8c073846  @..A.F........8F
 0b9a0 04f18006 04f0e0ff 44483146 fef771f9  ........DH1F..q.
 0b9b0 e0784107 05d410f0 020f14bf 26222522  .xA.........&"%"
 0b9c0 00e02722 e3799342 3fd104f0 5bfae378  ..'".y.B?...[..x
 0b9d0 da0705d4 13f0020f 14bf2623 272300e0  ..........&#'#..
 0b9e0 2523e371 63786569 012b08d0 fdf7f0fa  %#.qcxei.+......
 0b9f0 42f21073 90fbf3f2 02fb1300 05442846  B..s.........D(F
 0ba00 fdf758f9 a5690544 a561e561 be20fdf7  ..X..i.D.a.a. ..
 0ba10 51f92d1a fdf792fa 2d1a29d5 6378d4f8  Q.-.....-.).cx..
 0ba20 1480012b 08d0fdf7 d3fa42f2 107390fb  ...+......B..s..
 0ba30 f3f202fb 13008044 4046fdf7 3bf9a369  .......D@F..;..i
 0ba40 0344a361 e3612d18 e7e75a1c d2b2a2f1  .D.a.a-...Z.....
 0ba50 25050121 a9400842 0abf0233 e271e371  %..!.@.B...3.q.q
 0ba60 fdf76cfa 0546be20 fdf724f9 2844e061  ..l..F. ..$.(D.a
 0ba70 6378012b 0cd1e269 236a9a42 08d30020  cx.+...i#j.B... 
 0ba80 20703c21 01f03cfd bde8f041 04f0fab9   p<!..<....A....
 0ba90 2046fff7 e5fc2046 0021fff7 e7fb3846   F.... F.!....8F
 0baa0 04f00aff 28b13146 0448bde8 f041fef7  ....(.1F.H...A..
 0bab0 a0b8bde8 f08100bf 46f20100 c8320020  ........F....2. 
 0bac0 08b51378 13f0800f 0bd00528 05d10846  ...x.......(...F
 0bad0 1146fff7 23fe48b9 03e00328 01d1db06  .F..#.H....(....
 0bae0 04d40348 bde80840 fff74cbf 08bd00bf  ...H...@..L.....
 0baf0 10330020 044b1a78 22b11879 b0fa80f0  .3. .K.x"..y....
 0bb00 40097047 01207047 10330020 03484379  @.pG. pG.3. .HCy
 0bb10 022b00f1 280038bf 00207047 10330020  .+..(.8.. pG.3. 
 0bb20 00487047 3e330020 08b505f0 77fb0248  .HpG>3. ....w..H
 0bb30 bde80840 fff78cbb 10330020 014b1878  ...@.....3. .K.x
 0bb40 704700bf 10330020 10b5094c 00212046  pG...3. ...L.! F
 0bb50 a822fdf7 5efa4ff4 0063e381 23820723  ."..^.O..c..#..#
 0bb60 e3701123 84f88130 c4f88440 10bd00bf  .p.#...0...@....
 0bb70 10330020 08b5fff7 4ffcbde8 0840fff7  .3. ....O....@..
 0bb80 e3bf9830 fff7baba 08b505f0 47fbfff7  ...0........G...
 0bb90 cdf90020 fff7a6fa 014b0022 1a6008bd  ... .....K.".`..
 0bba0 cc330020 10b58378 6ff30003 04468370  .3. ...xo....F.p
 0bbb0 fff7eaff 04f1a400 bde81040 fff79eba  ...........@....
 0bbc0 10b58378 43f00103 04468370 fff7dcff  ...xC....F.p....
 0bbd0 04f1a400 bde81040 fff790ba 10b50446  .......@.......F
 0bbe0 fff7d2ff 04f1a400 bde81040 fff786ba  ...........@....
 0bbf0 0020fff7 77ba07b5 82780346 42f00102  . ..w....x.FB...
 0bc00 8270da79 b3f82601 12f1ff32 18bf0122  .p.y..&....2..."
 0bc10 00920021 03f59872 03f5ac73 05f03cfa  ...!...r...s..<.
 0bc20 03b05df8 04fb8378 6ff30003 837005f0  ..]....xo....p..
 0bc30 65bac279 b0f82601 12f1ff32 4ff00001  e..y..&....2O...
 0bc40 18bf0122 05f052ba b0f86030 13b5c46e  ..."..R...`0...n
 0bc50 40f2e240 5843fdf7 2df80444 01a804f0  @..@XC..-..D....
 0bc60 affe28b1 019b1a1b 34ea2204 28bf1c46  ..(.....4.".(..F
 0bc70 204602b0 10bd0000 2de9f04f d0f8b060   F......-..O...`
 0bc80 d0f8b4a0 8db00446 002e4fd1 4378dd06  .......F..O.Cx..
 0bc90 6fd4baf1 000f03d1 43f01003 43709be1  o.......C...Cp..
 0bca0 90f82031 daf80490 022baaf1 10061fd9  .. 1.....+......
 0bcb0 504602f0 d9fa38b9 637843f0 10036370  PF....8.cxC...cp
 0bcc0 80460127 0546ade0 b9f1000f 02d14ff0  .F.'.F........O.
 0bcd0 00090de0 484602f0 c7fa48b9 e379012b  ....HF....H..y.+
 0bce0 f5d03046 02f0d8fa 002808bf 4ff00009  ..0F.....(..O...
 0bcf0 d4f8b430 5b68c4f8 b4301bb9 04f1b403  ...0[h...0......
 0bd00 c4f8b830 baf80050 94f80cb0 9af80b70  ...0...P.......p
 0bd10 ab4588bf 5ffa85fb 8af80ab0 0af10808  .E.._...........
 0bd20 c4f8b060 ca464ff0 000936e0 96f81990  ...`.FO...6.....
 0bd30 358a96f8 1ab006f1 1808b9f1 000f03d1  5...............
 0bd40 f77e07f0 030700e0 012794f8 2021022a  .~.......'.. !.*
 0bd50 23d9baf1 000f23d0 504602f0 85fa78bb  #.....#.PF....x.
 0bd60 e279012a 1cd0d4f8 b00002f0 95fab8b1  .y.*............
 0bd70 26e090f8 2031022b 19d9baf1 000f06d1  &... 1.+........
 0bd80 4ff00008 4546c146 c3460127 08e05046  O...EF.F.F.'..PF
 0bd90 02f06afa 0028f3d0 0de0baf1 000f0fd1  ..j..(..........
 0bda0 09eb0b02 aa423cda 4ff0000a 08e0baf1  .....B<.O.......
 0bdb0 000f00f0 1181b046 3546b146 b3460127  .......F5F.F.F.'
 0bdc0 22785007 2dd42046 fff73eff 09eb0b02  "xP.-. F..>.....
 0bdd0 aa420146 05dac9eb 0505cbeb 0500c5b2  .B.F............
 0bde0 05e0baf8 0030257b ab4298bf ddb2238b  .....0%{.B....#.
 0bdf0 e2790391 03ebc500 012a00eb cb0508bf  .y.......*......
 0be00 963305f2 622008bf c018fcf7 53ff0546  .3..b ......S..F
 0be10 fdf794f8 03992844 88422cbf 00250125  ......(D.B,..%.%
 0be20 00e00025 6378d906 0bd50cab 04930023  ...%cx.........#
 0be30 8df82830 8df82930 8df82a30 0df12808  ..(0..)0..*0..(.
 0be40 04ae94f8 2c300bb1 47f00807 0db147f0  ....,0..G.....G.
 0be50 100794f8 2d300bb1 47f00407 88f80370  ....-0..G......p
 0be60 23785a07 18d4e379 022b04d0 4ff00009  #xZ....y.+..O...
 0be70 4ff0020a 14e0002d f8d194f8 2e30002b  O......-.....0.+
 0be80 f4d194f8 3030db06 f0d43368 38461978  ....00....3h8F.x
 0be90 02f0d8fa 0028e9d1 dff86491 4ff0000a  .....(....d.O...
 0bea0 98f80330 03f00303 032b57d1 33681b78  ...0.....+W.3h.x
 0beb0 062b18d1 a378b4f8 240143f0 0103a370  .+...x..$.C....p
 0bec0 012384f8 2131e379 03f1ff3e def10003  .#..!1.y...>....
 0bed0 43eb0e03 00930021 04f59872 04f5ac73  C......!...r...s
 0bee0 05f0daf8 4ee0052b 0dd1a278 84f82031  ....N..+...x.. 1
 0bef0 6ff30002 0023a270 84f82131 05f0fef8  o....#.p..!1....
 0bf00 394b3a4a 18e00b2b 28d1e379 022ba378  9K:J...+(..y.+.x
 0bf10 18d143f0 0103a370 012384f8 21310023  ..C....p.#..!1.#
 0bf20 b4f82401 009304f5 987204f5 ac730021  ..$......r...s.!
 0bf30 05f0b2f8 2e4b2f4a b9f1000f 0cbf9146  .....K/J.......F
 0bf40 99461fe0 6ff30003 a3700123 84f82031  .F..o....p.#.. 1
 0bf50 002384f8 213105f0 d1f813e0 a378da07  .#..!1.......x..
 0bf60 10d5e279 b4f82401 012384f8 2131d31a  ...y..$..#..!1..
 0bf70 5a425a41 002105f0 b9f81f4b b9f1000f  ZBZA.!.....K....
 0bf80 08bf9946 48462146 05f0cef8 30465146  ...FHF!F....0FQF
 0bf90 05f0eafa 20bb6378 98f80260 65f34513  .... .cx...`e.E.
 0bfa0 13f0100f 6370154b 03d0da6e 0132da66  ....cp.K...n.2.f
 0bfb0 16e007f0 0307032f 07bfdc6d 196e596e  ......./...m.nYn
 0bfc0 9a6e07bf 01348919 01319219 07bfdc65  .n...4...1.....e
 0bfd0 19665966 9a6603e0 b0460127 354621e7  .fYf.f...F.'5F!.
 0bfe0 0db0bde8 f08f00bf c1bb0000 f7bb0000  ................
 0bff0 a5bb0000 27bc0000 33bc0000 80350020  ....'...3....5. 
 0c000 ddbb0000 f7b5c468 394d0746 2c6034b9  .......h9M.F,`4.
 0c010 384840f2 53412246 2346fdf7 59fe04f0  8H@.SA"F#F..Y...
 0c020 85fd0420 fff75ef8 a16ce26c 94f82700  ... ..^..l.l..'.
 0c030 05f0a0f8 05f04afb e679012e 1ed17868  ......J..y....xh
 0c040 323005f0 6ffaa0b9 a378da07 0ad5b4f8  20..o....x......
 0c050 24010096 002104f5 987204f5 ac7305f0  $....!...r...s..
 0c060 1bf801e0 05f04af8 2046fff7 05fe60b3  ......J. F....`.
 0c070 2de0214a 13690133 136128e0 a378db07  -.!J.i.3.a(..x..
 0c080 0bd50123 b4f82601 00930021 04f59872  ...#..&....!...r
 0c090 04f5ac73 05f000f8 01e005f0 2ff805f0  ...s......../...
 0c0a0 09fa20b1 144a136b 01331363 0fe02378  .. ..J.k.3.c..#x
 0c0b0 606fe56e 43f01003 2370a36f 1844de30  `o.nC...#p.o.D.0
 0c0c0 fcf7f8fd 2844fef7 2bff0025 09e004f1  ....(D..+..%....
 0c0d0 a400fff7 13f80020 fff704f8 00232b60  ....... .....#+`
 0c0e0 0125fcf7 2bffa065 284603b0 f0bd00bf  .%..+..e(F......
 0c0f0 cc330020 53f20100 80350020 10b54378  .3. S....5. ..Cx
 0c100 19060446 0bd503f0 17f920b1 20460321  ...F...... . F.!
 0c110 062202f0 adfc6378 6ff3c713 63706378  ."....cxo...cpcx
 0c120 da0719d5 a18fcb07 05d50021 204602f0  ...........! F..
 0c130 11fa0021 09e001f0 400189b2 29b10621  ...!....@...)..!
 0c140 204602f0 07fa94f8 32102046 03f090f8   F......2. F....
 0c150 63786ff3 00036370 10bd836d 886d181a  cxo...cp...m.m..
 0c160 c00f7047 034b1b68 0bb9fcf7 e7be186d  ..pG.K.h.......m
 0c170 704700bf cc330020 012805d1 03488379  pG...3. .(...H.y
 0c180 002b08bf 00207047 00207047 e0330020  .+... pG. pG.3. 
 0c190 064b1868 28b1d0f8 bc201a60 2ab95b60  .K.h(.... .`*.[`
 0c1a0 7047034a 136a0133 13627047 d0330020  pG.J.j.3.bpG.3. 
 0c1b0 80350020 c36e10b5 0446006f 181a0028  .5. .n...F.o...(
 0c1c0 0fddfcf7 7dfd94f8 3410074b 33f81130  ....}...4..K3..0
 0c1d0 3c334ff4 7a72b0fb f2f05843 b0fbf2f0  <3O.zr....XC....
 0c1e0 10bd0020 10bd00bf 6ef20100 30b5411e  ... ....n...0.A.
 0c1f0 021d0020 11f8015f 75b1ff2d 02d10830  ... ..._u..-...0
 0c200 c0b209e0 08240123 2b421cbf 0130c0b2  .....$.#+B...0..
 0c210 5b00013c dbb2f7d1 9142ebd1 30bdf0b5  [..<.....B..0...
 0c220 90f82620 90f82930 1344dbb2 252b84bf  ..& ..)0.D..%+..
 0c230 253bdbb2 03f00701 01228a40 00ebd301  %;.......".@....
 0c240 80f82830 897e0a40 23d190f8 2a40b3fb  ..(0.~.@#...*@..
 0c250 f4f104fb 1134e4b2 19301646 10f801ef  .....4...0.F....
 0c260 f700ffb2 bef1000f 10d00125 002115ea  ...........%.!..
 0c270 0e0f06d0 a24202d1 7b18d8b2 f0bd0132  .....B..{......2
 0c280 d2b20131 6d000829 edb2f0d1 0136052e  ...1m..).....6..
 0c290 e4d11846 f0bd70b5 0446fff7 2fffb4f8  ...F..p..F../...
 0c2a0 600040f2 e2435843 238823f4 ee6323f0  `.@..CXC#.#..c#.
 0c2b0 07031b05 1b0d082b 08d12378 dd0705d5  .......+..#x....
 0c2c0 b4f86250 0135adb2 684300e0 0125e38f  ..bP.5..hC...%..
 0c2d0 2b44e387 fcf7eefc e36e1844 2378e066  +D.......n.D#x.f
 0c2e0 190650d5 e28fb4f8 80319a42 4bd1e379  ..P......1.BK..y
 0c2f0 012b11d0 b4f86020 b4f87a31 9a420bd1  .+....` ..z1.B..
 0c300 b4f86220 b4f87c31 9a4205d1 b4f86420  ..b ..|1.B....d 
 0c310 b4f87e31 9a4203d0 637843f0 01036370  ..~1.B..cxC...cp
 0c320 b4f87a31 a4f86030 b4f87e31 a4f86430  ..z1..`0..~1..d0
 0c330 b4f87c31 a4f86230 94f87631 84f83530  ..|1..b0..v1..50
 0c340 40f2e240 43436367 b4f87831 a4f86a30  @..@CCcg..x1..j0
 0c350 5843fcf7 affce36e 04f18406 1844e066  XC.....n.....D.f
 0c360 3046fcf7 2dfdb4f8 643042f2 10705843  0F..-...d0B..pXC
 0c370 fcf7a0fc e16e0144 3046fcf7 c1fc2378  .....n.D0F....#x
 0c380 6ff3c713 23706378 1a071bd5 a38ce28f  o...#pcx........
 0c390 9b1a1bb2 002b15dc 04f11f06 3046fff7  .....+......0F..
 0c3a0 25ffd4f8 1f30c4f8 1a3094f8 2330a377  %....0...0..#0.w
 0c3b0 637884f8 2a006ff3 c3036370 20460121  cx..*.o...cp F.!
 0c3c0 02f0c8f8 5db194f8 283084f8 29302046  ....]...(0..)0 F
 0c3d0 fff725ff 013d84f8 2700adb2 f2e7a38f  ..%..=..'.......
 0c3e0 9b0607d5 636de26e 9b1a002b 02dc4ff0  ....cm.n...+..O.
 0c3f0 ff3070bd e379022b 10d12046 fff7dafe  .0p..y.+.. F....
 0c400 b4f86020 40f27123 5343963b 9842eed2  ..` @.q#SC.;.B..
 0c410 636fa067 03f6c413 184401e0 40f60610  co.g.....D..@...
 0c420 e56efcf7 47fc2844 20650020 70bd0000  .n..G.(D e. p...
 0c430 38b50123 8371b0f8 60300446 0d4641f6  8..#.q..`0.F.FA.
 0c440 4c515943 8430fcf7 a1fc2378 6ff30003  LQYC.0....#xo...
 0c450 2370fcf7 73fde379 a065022b 256725d1  #p..s..y.e.+%g%.
 0c460 94f83530 40f2e240 43436367 b4f86a30  ..50@..@CCcg..j0
 0c470 03fb0000 fcf71efc 0544606f e56600f6  .........D`o.f..
 0c480 c410fcf7 17fc0023 28442065 a3672046  .......#(D e.g F
 0c490 04f04ef9 50b12046 fff7fdfe 0028f6d0  ..N.P. F.....(..
 0c4a0 104ad368 0133d360 002038bd 237a1b2b  .J.h.3.`. 8.#z.+
 0c4b0 0ad8637a 1b2b07d8 e389b3f5 a47f03d8  ..cz.+..........
 0c4c0 238ab3f5 a47f07d9 fef724fe 830603d5  #.........$.....
 0c4d0 20460821 01f0e4ff 20460021 01f010f8   F.!.... F.!....
 0c4e0 012038bd 80350020 074b10b5 1c68fff7  . 8..5. .K...h..
 0c4f0 4bfb3cb1 04f1a400 fef700fe 034a5369  K.<..........JSi
 0c500 01335361 10bd00bf cc330020 80350020  .3Sa.....3. .5. 
 0c510 b0f84610 4ff4a063 4b43fc30 4ff47a71  ..F.O..cKC.0O.zq
 0c520 b3fbf1f1 fdf7ecba 10b50446 01f0d8f8  ...........F....
 0c530 20460721 01f0b4ff 2046bde8 1040fff7   F.!.... F...@..
 0c540 e7bf0000 012370b5 c37180f8 35300023  .....#p..q..50.#
 0c550 a0f86a30 042380f8 34300446 0d46fcf7  ..j0.#..40.F.F..
 0c560 37fd0c23 90fbf3f2 02fb1300 053084f8  7..#.........0..
 0c570 26006b8a a4f86230 ab8aa4f8 64302b7b  &.k...b0....d0+{
 0c580 84f87c30 2b7953b9 2b4653f8 062fc4f8  ..|0+yS.+FS../..
 0c590 7e209b88 a4f88230 6b7984f8 7d30eb89  ~ .....0ky..}0..
 0c5a0 a4f85c30 2b8aea8a a4f85e30 a4f86030  ..\0+.....^0..`0
 0c5b0 5b009a42 d8bfa4f8 66202a8b c8bfa4f8  [..B....f *.....
 0c5c0 66309a42 c8bfa4f8 6830274b d8bfa4f8  f0.B....h0'K....
 0c5d0 68205a79 84f82a20 1a681b79 c4f81a20  h Zy..* .h.y... 
 0c5e0 a377fcf7 f5fc0546 fcf7f2fc abb280b2  .w.....F........
 0c5f0 8342f6d0 10f47c42 f3d0b2f5 7c4ff0d0  .B....|B....|O..
 0c600 1a4d43ea 00404540 20230021 01222a42  .MC..@E@ #.!."*B
 0c610 01d029b9 0121013b 4fea4202 f7d1e0e7  ..)..!.;O.B.....
 0c620 002200f0 01062025 1346013d 0ed04900  .".... %.F.=..I.
 0c630 014201d0 0eb905e0 26b90133 dbb2062b  .B......&..3...+
 0c640 f3d9cee7 0132d2b2 0023eee7 062bc8d8  .....2...#...+..
 0c650 182ac6d8 a064fcf7 bbfc054b c4f8f030  .*...d.....K...0
 0c660 20f07f40 e06470bd b8330020 d6be898e   ..@.dp..3. ....
 0c670 05c00000 7f2370b5 04460025 80f82b30  .....#p..F.%..+0
 0c680 ff2380f8 313080f8 36300560 c5878571  .#..10..60.`...q
 0c690 80f83750 80f83950 80f83a50 a0f84250  ..7P..9P..:P..BP
 0c6a0 a0f84450 80f83250 8587a0f8 68512e49  ..DP..2P....hQ.I
 0c6b0 22468430 fcf70efb 84f82950 2046fff7  "F.0......)P F..
 0c6c0 aefd1423 84f89930 152384f8 a5302346  ...#...0.#...0#F
 0c6d0 84f82700 c4f89c40 84f89850 c4f8a840  ..'....@...P...@
 0c6e0 84f8a450 43f8b45f c4f8b830 1f4bc4f8  ...PC.._...0.K..
 0c6f0 b0501a7a 2272da79 62729a89 1b8a2382  .P.z"r.ybr....#.
 0c700 4ff4a473 01266382 a382e382 23831b23  O..s.&c.....#..#
 0c710 e281a372 e3722373 63732946 482284f8  ...r.r#scs)FH"..
 0c720 2c5084f8 2d5084f8 2e5084f8 2f60a4f8  ,P..-P...P../`..
 0c730 405004f5 9070fcf7 6cfc40f6 b833a4f8  @P...p..l.@..3..
 0c740 4630a378 0a4a84f8 206143f0 0403a370  F0.x.J.. aC....p
 0c750 04f1fc00 23460749 fdf7a4f9 064b1a68  ....#F.I.....K.h
 0c760 c4f8bc20 1c6070bd 83bb0000 b8330020  ... .`p......3. 
 0c770 29c50000 c8320020 f4350020 30b50c78  )....2. .5. 0..x
 0c780 ca884b88 c4720d79 018a4282 8a4228bf  ..K..r.y..B..B(.
 0c790 0a46018b 83829142 c18916bf 02830022  .F.....B......."
 0c7a0 01228b42 28bf0b46 c18a8572 9942417a  .".B(..F...r.BAz
 0c7b0 1cbfc382 0122437b a94228bf 29468b42  ....."C{.B(.)F.B
 0c7c0 037a1cbf 41730122 017ba342 28bf2346  .z..As.".{.B(.#F
 0c7d0 994201d0 037300e0 1ab1bde8 304002f0  .B...s......0@..
 0c7e0 e7bc30bd 70b50446 e0300d46 04f0bcf8  ..0.p..F.0.F....
 0c7f0 04f18400 fcf7e4fa 04f1c000 fdf762f9  ..............b.
 0c800 04f1fc00 fdf75ef9 234a1368 a34203d1  ......^.#J.h.B..
 0c810 d4f8bc30 136009e0 d3f8bc20 a24201d0  ...0.`..... .B..
 0c820 1346f9e7 d4f8bc20 c3f8bc20 d4f8b000  .F..... ... ....
 0c830 20b1fdf7 94fb0023 c4f8b030 d4f8b460   ......#...0...`
 0c840 66b17368 c4f8b430 1bb904f1 b403c4f8  f.sh...0........
 0c850 b830a6f1 1000fdf7 82fbefe7 0f4804f1  .0...........H..
 0c860 9801fdf7 16fa0d48 04f1a401 fdf711fa  .......H........
 0c870 a67145b1 022d2046 294602d1 00f040fe  .qE..- F)F....@.
 0c880 01e000f0 49ff0023 c4f8bc30 044b5a68  ....I..#...0.KZh
 0c890 1460bc34 5c6070bd f4350020 c8320020  .`.4\`p..5. .2. 
 0c8a0 d0330020 38b50446 30b92448 40f24471  .3. 8..F0.$H@.Dq
 0c8b0 22462346 fdf70cfa 03f0e4fa 237813f0  "F#F........#x..
 0c8c0 06050ad0 9a0705d4 94f83810 002908bf  ..........8..)..
 0c8d0 132100e0 16212046 0ee01948 04f1a401  .!...! F...H....
 0c8e0 fdf7d7f9 2378db07 48bf6567 2046fff7  ....#x..H.eg F..
 0c8f0 d2fc28b1 20461621 bde83840 fff772bf  ..(. F.!..8@..r.
 0c900 237884f8 2e0060f3 00032370 204601f0  #x....`...#p F..
 0c910 f7fd0c4b c4f8f030 204603f0 c9fd28b1  ...K...0 F....(.
 0c920 2046fff7 b8fc0028 f6d0e3e7 b4f84030   F.....(......@0
 0c930 1bb1bde8 384000f0 67be38bd 53f20100  ....8@..g.8.S...
 0c940 c8320020 05c00000 10b5084c 0020fef7  .2. .......L. ..
 0c950 c9fb2068 40b10378 6ff30003 00f8a43b  .. h@..xo......;
 0c960 fef7ccfb 00232360 10bd00bf cc330020  .....##`.....3. 
 0c970 f8b5204e 34680546 0f46002c 36d06378  .. N4h.F.F.,6.cx
 0c980 5b0633d5 03f09efc c8b194f9 31202b78  [.3.........1 +x
 0c990 002aa3bf 184b2821 01fb0233 c3f38012  .*...K(!...3....
 0c9a0 a1bf5a78 0232d2b2 0233b8bf ab1c84f8  ..Zx.2...3......
 0c9b0 7d201a68 c4f87e20 9b88a4f8 823094f9  } .h..~ .....0..
 0c9c0 3130002b 02dba81c 03f06efc 00203060  10.+......n.. 0`
 0c9d0 03f0c6f8 6b787968 03f03f03 0a332046  ....kxyh..?..3 F
 0c9e0 01ebc301 bde8f840 fff722bd bde8f840  .......@.."....@
 0c9f0 03f048ba d8330020 24360020 2de9f74f  ..H..3. $6. -..O
 0ca00 044620b9 04f00afc 04f054fd 2fe10029  .F .......T./..)
 0ca10 6cd00568 984a2b78 6978d2f8 00800191  l..h.J+xix......
 0ca20 13f00f07 00921cd0 012f5fd1 23f07f03  ........./_.#...
 0ca30 05f10809 03f0ff06 2bb14846 3146fef7  ........+.HF1F..
 0ca40 09fac7b2 00e03746 98f87c30 012b02d9  ......7F..|0.+..
 0ca50 002f4bd0 05e04846 3146fef7 4dfa0028  ./K...HF1F..M..(
 0ca60 44d0ae1c 2d7803f0 2dfcc5f3 80158246  D...-x..-......F
 0ca70 29463046 fef7eef9 02460028 41d002f0  )F0F.....F.(A...
 0ca80 1bff0246 00283cd0 04f0b8f9 b0f1000b  ...F.(<.........
 0ca90 33db227e 794942f0 04022276 282202fb  3."~yIB..."v("..
 0caa0 0b1288f8 31b0901c 51780122 baf1000f  ....1...Qx."....
 0cab0 2cd003f0 f1ff0028 00f0d780 227e42f0  ,......(...."~B.
 0cac0 40022276 002f57d1 019be269 03f03f01  @."v./W....i..?.
 0cad0 0a3102eb c1014046 022203f0 7bfd0446  .1....@F."..{..F
 0cae0 002856d0 664ad368 0133d360 4ff0ff35  .(V.fJ.h.3.`O..5
 0caf0 0020fef7 f7fa2c46 b9e0baf1 000f05d0  . ....,F........
 0cb00 b3e03046 29464ff0 ff3bcfe7 009b1968  ..0F)FO..;.....h
 0cb10 002900f0 aa8091f8 7d20032a 00f2a580  .)......} .*....
 0cb20 dfe802f0 02020611 954240f0 9e8018e0  .........B@.....
 0cb30 bbf1000f c0f29980 50482822 02fb0b00  ........PH("....
 0cb40 427862b1 91e0bbf1 000fc0f2 8e804b48  Bxb...........KH
 0cb50 282202fb 0b004278 012a40f0 86800230  ("....Bx.*@....0
 0cb60 03e0002e 00f08180 30467e31 0622fcf7  ........0F~1."..
 0cb70 37fa0028 79d1a1e7 bbf1000f 75db414a  7..(y.......u.AJ
 0cb80 28214846 01fb0b21 02f064fe 00289bd1  (!HF...!..d..(..
 0cb90 6be0b8f8 6a300193 03f08efb 814630b9  k...j0.......F0.
 0cba0 394840f2 ab714a46 4b46fdf7 91f8c77e  9H@..qJFKF.....~
 0cbb0 07f00f07 0db147f0 8007009b d9f800a0  ......G.........
 0cbc0 1a6892f8 7c20d307 4cbf304b 304b0093  .h..| ..L.0K0K..
 0cbd0 48bf47f0 4007012a 1bd93046 2946fef7  H.G.@..*..0F)F..
 0cbe0 39f938b1 bbf1000f 13db2448 282202fb  9.8.......$H("..
 0cbf0 0b0007e0 02f060fe 58b13046 294602f0  ......`.X.0F)F..
 0cc00 0ffd30b1 01215246 47f04007 02f0cafd  ..0..!RFG.@.....
 0cc10 07e0009b 1b68caf8 0030009b 9b88aaf8  .....h...0......
 0cc20 04303368 caf80630 b388aaf8 0a300af1  .03h...0.....0..
 0cc30 14000199 10f010fa 164889f8 1b700021  .........H...p.!
 0cc40 04f072fa 48460021 04f08efc 05460028  ..r.HF.!.....F.(
 0cc50 7ff44eaf 98f80130 094a43f0 400388f8  ..N....0.JC.@...
 0cc60 0130136c 01331364 01e04ff0 ff342046  .0.l.3.d..O..4 F
 0cc70 03b0bde8 f08f00bf d8330020 24360020  .........3. $6. 
 0cc80 80350020 2c360020 53f20100 10280020  .5. ,6. S....(. 
 0cc90 d8000020 f1bb0000 f8b50446 0e46fcf7  ... .......F.F..
 0cca0 3ffe0b4b 1b68a342 074603d1 fef76cff  ?..K.h.B.F....l.
 0ccb0 012500e0 00253846 fcf738fe 0db103f0  .%...%8F..8.....
 0ccc0 e1f82046 3146bde8 f840fff7 8bbd00bf  .. F1F...@......
 0ccd0 cc330020 0821fff7 dfbf0000 f8b5154e  .3. .!.........N
 0cce0 05460f46 fef722f9 34680cb3 a36c9f42  .F.F..".4h...l.B
 0ccf0 0fd0114a 936a0020 01339362 fef7f2f9  ...J.j. .3.b....
 0cd00 04f1a400 fef7faf9 00233360 4ff0ff30  .........#3`O..0
 0cd10 f8bda388 ab702378 43f00103 da062370  .....p#xC.....#p
 0cd20 41bf6ff3 04132370 6b682367 48bfe366  A.o...#pkh#gH..f
 0cd30 0120f8bd cc330020 80350020 2de9f047  . ...3. .5. -..G
 0cd40 91f90030 002b0646 894680f2 a5808878  ...0.+.F.F.....x
 0cd50 fff712fa 04460028 00f09a80 00f18405  .....F.(........
 0cd60 2846fcf7 2df8b4f8 643042f2 10712846  (F..-...d0B..q(F
 0cd70 5943fcf7 0bf82046 fff7c0f9 33681d78  YC.... F....3h.x
 0cd80 93f801a0 15f00308 05d0b8f1 020f1ffa  ................
 0cd90 8af705d1 27b9444a 936d0133 93657be0  ....'.DJ.m.3.e{.
 0cda0 94f82031 022b06d1 a3785a07 03d517b1  .. 1.+...xZ.....
 0cdb0 2046fff7 adfb99f8 033084f8 2b30e379   F.......0..+0.y
 0cdc0 022b05d1 6b0742bf 237843f0 08032370  .+..k.B.#xC...#p
 0cdd0 05f00805 94f82f30 edb2ab42 53d0b8f1  ....../0...BS...
 0cde0 010f84f8 2f5001d1 002f55d0 99f80020  ..../P.../U.... 
 0cdf0 2d4d02f0 200202f0 ff033ab1 2b6f2046  -M.. .....:.+o F
 0ce00 01333d21 2b67fff7 47ff45e0 b8f1030f  .3=!+g..G.E.....
 0ce10 0dd1ab6c 20460133 3146ab64 01f0b2fb  ...l F.31F.d....
 0ce20 00283ed0 6b6d0133 6b65bde8 f087ea6c  .(>.km.3ke.....l
 0ce30 0132ea64 2a6d5244 2a657279 072a88bf  .2.d*mRD*ery.*..
 0ce40 93b21033 32683344 d31a9bb2 012b06d8  ...32h3D.....+..
 0ce50 00221648 40f60521 1346fcf7 39ff3046  .".H@..!.F..9.0F
 0ce60 0221fdf7 a4f93568 a1882846 41ea0831  .!....5h..(FA..1
 0ce70 10f0f2f8 a81c3946 10f0eef8 3046bde8  ......9F....0F..
 0ce80 f04707f0 15bd084a 536b0133 536303e0  .G.....JSk.3Sc..
 0ce90 054ad369 0133d361 3046bde8 f047fdf7  .J.i.3.a0F...G..
 0cea0 5eb8bde8 f08700bf 80350020 53f20100  ^........5. S...
 0ceb0 8e4b2de9 f0471c68 074624b9 8c4a536a  .K-..G.h.F$..JSj
 0cec0 01335362 f2e00368 93f800a0 5d7890f9  .3Sb...h....]x..
 0ced0 1830002b 10db94f8 2e300133 dbb2012b  .0.+.....0.3...+
 0cee0 84f82e30 00f2fb80 e379012b 40f0a980  ...0.....y.+@...
 0cef0 6378c3f3 4013a2e0 00231af0 030984f8  cx..@....#......
 0cf00 2e3000f0 d3801af0 080f84f8 30a094f8  .0..........0...
 0cf10 2d3001d0 0bb912e0 8bb983f0 010384f8  -0..............
 0cf20 2d30a378 d8070ad5 3a681378 03f00303  -0.x....:h.x....
 0cf30 012b40f0 c5805378 002b40f0 c1806378  .+@...Sx.+@...cx
 0cf40 03f01003 03f0ff01 1bb9d4f8 b030002b  .............0.+
 0cf50 4ed01af0 040f94f8 2c30654a 01d00bb9  N.......,0eJ....
 0cf60 04e01bb9 d36b0133 d36341e0 83f00103  .....k.3.cA.....
 0cf70 84f82c30 936b0133 936321b1 63786ff3  ..,0.k.3.c!.cxo.
 0cf80 04136370 34e0d4f8 b00088b3 94f82131  ..cp4.........!1
 0cf90 23b1b4f8 24310133 a4f82431 c37e03f0  #...$1.3..$1.~..
 0cfa0 0303032b 09d10023 c4f8b030 214601f0  ...+...#...0!F..
 0cfb0 86fd0646 00287bd1 1ae0427e 817e038a  ...F.({...B~.~..
 0cfc0 0a44d2b2 9a424276 0bd321b1 b4f84030  .D...BBv..!...@0
 0cfd0 0133a4f8 4030fcf7 c2ff0023 c4f8b030  .3..@0.....#...0
 0cfe0 06e09a1a 237bd2b2 9a4228bf 1a468276  ....#{...B(..F.v
 0cff0 b9f1030f 0ed13b68 93f80280 b8f1020f  ......;h........
 0d000 0ad12378 43f00403 23703b68 db7884f8  ..#xC...#p;h.x..
 0d010 383016e0 002200e0 0122e379 012b06d1  80..."...".y.+..
 0d020 62789106 58bfcaf3 0013dbb2 07e042b1  bx..X.........B.
 0d030 b8f10b0f 05d10123 84f82031 01e045b1  .......#.. 1..E.
 0d040 02e0002d 48d00123 a278d207 44bf0435  ...-H..#.x..D..5
 0d050 edb2fa69 0a3502eb c5053bb3 e379012b  ...i.5....;..y.+
 0d060 34d12046 fef7f0fd d4f8b020 064632b9  4. F....... .F2.
 0d070 d4f8b430 83b1b3f1 10020dd0 01e002f1  ...0............
 0d080 1003527e 1b789b1a 227bdbb2 934228bf  ..R~.x.."{...B(.
 0d090 13460a33 db0000e0 5023208b 00f59670  .F.3....P# ....p
 0d0a0 1844fbf7 07fe2844 b0420fd3 4ff0ff36  .D....(D.B..O..6
 0d0b0 fef76afd bcb104f1 a400fef7 1ff812e0  ..j.............
 0d0c0 b4f82631 0133a4f8 263138e7 2046fef7  ..&1.3..&18. F..
 0d0d0 d3fd0646 38b1ebe7 fd695035 bee7002d  ...F8....iP5...-
 0d0e0 e4d00023 b0e73046 bde8f087 cc330020  ...#..0F.....3. 
 0d0f0 80350020 f8b50646 0c460846 19461d46  .5. ...F.F.F.F.F
 0d100 fef70ef8 327b9542 88bfa276 96f82031  ....2{.B...v.. 1
 0d110 022b19d9 e37e03f0 0303032b 14d12368  .+...~.....+..#h
 0d120 1b78023b dbb20f2b 0ed80125 05fa03f3  .x.;...+...%....
 0d130 48f61902 1a4042b9 13f40075 05d0f579  H....@B....u...y
 0d140 6b1e5d42 5d4100e0 002504f1 1007fcf7  k.]B]A...%......
 0d150 e7fb4db1 d6f8b430 636113b9 1434c6f8  ..M....0ca...4..
 0d160 b840c6f8 b47006e0 44f8145f d6f8b830  .@...p..D.._...0
 0d170 1f60c6f8 b840bde8 f840fcf7 d7bb0000  .`...@...@......
 0d180 70b50446 c1f30b00 16460d46 fef7f4ff  p..F.....F.F....
 0d190 0c4a70b1 516c15f4 405f01f1 01015164  .Jp.Ql..@_....Qd
 0d1a0 f3b22146 0cbf0222 0122bde8 7040fff7  ..!F..."."..p@..
 0d1b0 a1bf9369 20460133 bde87040 9361fcf7  ...i F.3..p@.a..
 0d1c0 cebe00bf 80350020 70b50d4c 06460522  .....5. p..L.F."
 0d1d0 20460d46 fbf704ff 80b16671 2b682360   F.F......fq+h#`
 0d1e0 2b792371 074b1c68 44b1e179 012902d1  +y#q.K.hD..y.)..
 0d1f0 204601f0 55f9d4f8 bc40f5e7 70bd00bf   F..U....@..p...
 0d200 b8330020 f4350020 2de9f047 664e3468  .3. .5. -..GfN4h
 0d210 05468846 9146871c b4b104f1 7e003946  .F.F.F......~.9F
 0d220 0622fbf7 ddfe60b9 2b7813f0 400f94f8  ."....`.+x..@...
 0d230 7d3004d0 da0704d5 0020bde8 f087db07  }0....... ......
 0d240 fad5d4f8 bc40e7e7 fef7a2ff 04460028  .....@.......F.(
 0d250 f2d005f1 0e000ff0 1fffa064 eb7c2a7d  ...........d.|*}
 0d260 43ea0222 ab7c43ea 0223e364 6b7d84f8  C..".|C..#.dk}..
 0d270 353005f1 16000ff0 0affa4f8 6a0005f1  50..........j...
 0d280 18000ff0 04ffa4f8 600005f1 1a000ff0  ........`.......
 0d290 fefea4f8 620005f1 1c000ff0 f8fe2b46  ....b.........+F
 0d2a0 a4f86400 53f81e2f c4f81a20 1b79a377  ..d.S../... .y.w
 0d2b0 95f82330 b4f86a20 03f01f03 84f82630  ..#0..j ......&0
 0d2c0 95f82330 5b0984f8 3430b4f8 60309a42  ..#0[...40..`0.B
 0d2d0 04f11a0e 59d89a1f 92b240f6 7a418a42  ....Y.....@.zA.B
 0d2e0 53d894f8 35c0bcf1 000f4ed0 b4f862a0  S...5.....N...b.
 0d2f0 baf5fa7f 49d242f2 107101fb 00f540f6  ....I.B..q....@.
 0d300 c41101fb 03f20afb 02229542 3dd9013b  .........".B=..;
 0d310 082ba8bf 08239c45 37d83b68 c4f87e30  .+...#.E7.;h..~0
 0d320 bb88a4f8 823084f8 7d907046 fef75eff  .....0..}.pF..^.
 0d330 012884f8 2a0028d9 0223e371 2046fff7  .(..*.(..#.q F..
 0d340 99f91a4b c4f8f030 20464146 fff770f8  ...K...0 FAF..p.
 0d350 38bb3368 a34204d1 134bd4f8 bc201a60  8.3h.B...K... .`
 0d360 09e0d3f8 bc20a242 01d01346 f9e7d4f8  ..... .B...F....
 0d370 bc20c3f8 bc200e4b 5a680020 c4f8bc00  . ... .KZh. ....
 0d380 1460bc34 5c60bde8 f087094b 5a680020  .`.4\`.....KZh. 
 0d390 c4f8bc00 1460074a bc345c60 d36a0133  .....`.J.4\`.j.3
 0d3a0 d362bde8 f08700bf f4350020 05c00000  .b.......5. ....
 0d3b0 d0330020 80350020 1f4b1868 10b518b1  .3. .5. .K.h....
 0d3c0 00211960 fff70efa 1c4b1868 08b10021  .!.`.....K.h...!
 0d3d0 f8e704f0 69f91a4c fb2894bf 83b2fb23  ....i..L.(.....#
 0d3e0 e3710e33 fb284fea c3032382 94bf83b2  .q.3.(O...#.....
 0d3f0 fb23a371 1b2803f1 0e0394bf 80b21b20  .#.q.(......... 
 0d400 db00e381 20721b23 0e306372 c0004ff4  .... r.#.0cr..O.
 0d410 a473a081 6381ff21 25230422 08486371  .s..c..!%#.".Hcq
 0d420 fbf7f7fd 1f232371 06480021 6822bde8  .....##q.H.!h"..
 0d430 1040fbf7 eebd00bf cc330020 f4350020  .@.......3. .5. 
 0d440 b8330020 8c350020 37b5164c 164b0025  .3. .5. 7..L.K.%
 0d450 29464ff4 d0722046 1d60fbf7 dafd0123  )FO..r F.`.....#
 0d460 a380124b 12481c60 04f1bc02 5a600323  ...K.H.`....Z`.#
 0d470 84f8e030 0f4b0193 00950421 1a222b46  ...0.K.....!."+F
 0d480 c4f8ec40 0ff062ff 30b10b48 40f67941  ...@..b.0..H@.yA
 0d490 2a462b46 fcf71cfc 03b0bde8 3040fff7  *F+F........0@..
 0d4a0 8bbf00bf e0330020 f4350020 d0330020  .....3. .5. .3. 
 0d4b0 80350020 61f20100 53f20100 884210b5  .5. a...S....B..
 0d4c0 1cd8841f a4b240f6 7a408442 16d8b2f5  ......@.z@.B....
 0d4d0 fa7f13d2 a3f10a04 a4b240f6 76408442  ..........@.v@.B
 0d4e0 0cd840f6 c4146143 42f21074 634302fb  ..@...aCB..tcC..
 0d4f0 01118b42 94bf1220 002010bd 122010bd  ...B... . ... ..
 0d500 2de9f041 05460120 0e4601f0 47fb0446  -..A.F. .F..G..F
 0d510 0a2001f0 43fb8046 0cb90028 6fd03948  . ..C..F...(o.9H
 0d520 fcf76aff 04460028 69d03e23 0370b8f1  ..j..F.(i.>#.p..
 0d530 000f03d0 1f234370 0a2302e0 13234370  .....#Cp.#...#Cp
 0d540 0123a370 e670002d 54d0201d a9880ff0  .#.p.p.-T. .....
 0d550 83fdeb79 013ba371 95f87d70 04f10e06  ...y.;.q..}p....
 0d560 b8f1000f 29d03046 00210c22 fbf751fd  ....).0F.!."..Q.
 0d570 eb79012b 06d195f8 7c30012b 0ad902f0  .y.+....|0.+....
 0d580 8dfe01e0 fef7c2fa 20b10368 c4f80e30  ........ ..h...0
 0d590 8388b380 95f87d30 012b0bd9 eb79012b  ......}0.+...y.+
 0d5a0 02d102f0 77fe01e0 fef7bafa 03686361  ....w........hca
 0d5b0 83882383 04f11a06 03e0012f 84bf023f  ..#......../...?
 0d5c0 ffb22b46 e77153f8 7e2fa260 9b88a381  ..+F.qS.~/.`....
 0d5d0 3046b5f8 60100ff0 3ffdb01c b5f86210  0F..`...?.....b.
 0d5e0 0ff03afd 301db5f8 64100ff0 35fd95f8  ..:.0...d...5...
 0d5f0 3430b371 2046bde8 f04101f0 adbabde8  40.q F...A......
 0d600 f08100bf 5c3b0020 2de9f84f 314d2c68  ....\;. -..O1M,h
 0d610 fdf7d6f8 201aff28 a84659d9 2e4b0024  .... ..(.FY..K.$
 0d620 1e68a146 27462546 a246aeb3 b37983b3  .h.F'F%F.F...y..
 0d630 b6f84030 13b9d6f8 b43053b3 45b92748  ..@0.....0S.E.'H
 0d640 fcf7dafe 0546d0b3 c71c00f1 7b090024  .....F......{..$
 0d650 3846b188 01340ff0 fffce4b2 4846b6f8  8F...4......HF..
 0d660 40100ff0 f9fc4ff0 000b3c2c a6f840b0  @.....O...<,..@.
 0d670 07f10207 09f10209 0bd11323 2b70f123  ...........#+p.#
 0d680 ac706b70 284601f0 67fa5c46 5d464ff0  .pkp(F..g.\F]FO.
 0d690 010ad6f8 bc60c8e7 8db11323 2b70a300  .....`.....#+p..
 0d6a0 01333b2c 6b70ac70 05d83846 05f17b01  .3;,kp.p..8F..{.
 0d6b0 620010f0 0ffa2846 01f04efa 02e0baf1  b.....(F..N.....
 0d6c0 000f05d0 fdf77cf8 00f58070 c8f80000  ......|....p....
 0d6d0 bde8f88f 941e0020 f4350020 5c3b0020  ....... .5. \;. 
 0d6e0 38b50546 572001f0 73fa88b1 0948fcf7  8..FW ..s....H..
 0d6f0 83fe0446 60b15723 03700223 4370a988  ...F`.W#.p.#Cp..
 0d700 18440ff0 a9fc2046 bde83840 01f024ba  .D.... F..8@..$.
 0d710 38bd00bf 5c3b0020 70b50646 05200d46  8...\;. p..F. .F
 0d720 01f056fa a0b10b48 fcf766fe 044678b1  ..V....H..f..Fx.
 0d730 05230370 04234370 00238370 b1880330  .#.p.#Cp.#.p...0
 0d740 0ff08afc 65712046 bde87040 01f004ba  ....eq F..p@....
 0d750 70bd00bf 5c3b0020 f0b5754f 3b6889b0  p...\;. ..uO;h..
 0d760 04460bb1 0c26dfe0 02f08efd 06460028  .F...&.......F.(
 0d770 f8d12046 0ff08bfc adf80400 a01c0ff0  .. F............
 0d780 86fcbdf8 0420adf8 0600131f 9bb243f6  ..... ........C.
 0d790 fc718b42 01d91226 c6e0031f 9bb28b42  .q.B...&.......B
 0d7a0 f9d88242 f7d32379 8df80830 012bf2d8  ...B..#y...0.+..
 0d7b0 63b96379 8df80930 032becd8 234653f8  c.cy...0.+..#FS.
 0d7c0 062fcdf8 0a209b88 adf80e30 237b8df8  ./... .....0#{..
 0d7d0 1030032b dfd804f1 0d000ff0 58fcadf8  .0.+........X...
 0d7e0 120004f1 0f000ff0 52fcadf8 140004f1  ........R.......
 0d7f0 11000ff0 4cfcadf8 160004f1 13000ff0  ....L...........
 0d800 46fcbdf8 1410adf8 18000346 bdf81620  F..........F... 
 0d810 bdf81200 fff752fe 002840f0 828004f1  ......R..(@.....
 0d820 15000ff0 34fcadf8 1a0004f1 17000ff0  ....4...........
 0d830 2efcbdf8 1a30adf8 1c008342 abd8fef7  .....0.....B....
 0d840 a7fc0446 00286ed0 01a9fef7 7bfe2046  ...F.(n.....{. F
 0d850 fef710ff 02f030fd 054628b9 35486021  ......0..F(.5H`!
 0d860 2a462b46 fcf734fa 05222221 fdf758fc  *F+F..4..""!..X.
 0d870 2d68a16c 05f10c00 0ff0f2fb e36c2b74  -h.l.........l+t
 0d880 e36c1b0a 6b74b4f8 4e30ab74 94f83530  .l..kt..N0.t..50
 0d890 eb7405f1 1400b4f8 6a100ff0 ddfb05f1  .t......j.......
 0d8a0 1600b4f8 60100ff0 d7fb05f1 1800b4f8  ....`...........
 0d8b0 62100ff0 d1fb05f1 1a00b4f8 64100ff0  b...........d...
 0d8c0 cbfb2346 01a853f8 1a2fea61 1b7985f8  ..#F..S../.a.y..
 0d8d0 203094f8 342094f8 263043ea 421385f8   0..4 ..&0C.B...
 0d8e0 213002f0 c1fcd0b1 134a1368 a34203d1  !0.......J.h.B..
 0d8f0 d4f8bc30 136009e0 d3f8bc20 a24201d0  ...0.`..... .B..
 0d900 1346f9e7 d4f8bc20 c3f8bc20 0023c4f8  .F..... ... .#..
 0d910 bc300a4b 5a681460 bc345c60 01e03c60  .0.KZh.`.4\`..<`
 0d920 02e00646 00e00926 304609b0 f0bd00bf  ...F...&0F......
 0d930 d8330020 7ef20100 f4350020 d0330020  .3. ~....5. .3. 
 0d940 10b50ff0 a4fbfef7 17fc0446 70b1c379  ...........Fp..y
 0d950 022b05d0 20460321 00f0a2fd 002010bd  .+.. F.!..... ..
 0d960 fdf7d8fb 0307f5d4 012010bd 022010bd  ......... ... ..
 0d970 f8b50546 0ff08bfb 0746fef7 fdfb0446  ...F.....F.....F
 0d980 00285dd0 838f03f0 4103002b 5ad1fdf7  .(].....A..+Z...
 0d990 c1fb00f0 020000f0 ff0618b9 e379022b  .............y.+
 0d9a0 01d151e0 06262378 9a060bd5 e279022a  ..Q..&#x.....y.*
 0d9b0 4cd06ff3 45132370 204694f8 33102322  L.o.E.#p F..3.#"
 0d9c0 01f056f8 63781b07 02d5e379 022b3fd0  ..V.cx.....y.+?.
 0d9d0 a4f86871 a81c0ff0 5afba4f8 6a01281d  ..hq....Z...j.(.
 0d9e0 0ff055fb a4f86c01 a81d0ff0 50fba4f8  ..U...l.....P...
 0d9f0 6e0105f1 08000ff0 4afba4f8 700105f1  n.......J...p...
 0da00 0a000ff0 44fba4f8 720105f1 0c000ff0  ....D...r.......
 0da10 3efbb4f8 7231a4f8 74018342 1ad8b4f8  >...r1..t..B....
 0da20 6a01b4f8 6c11b4f8 6e21b4f8 7031fff7  j...l...n!..p1..
 0da30 45fd0546 80b92046 314600f0 31fd0be0  E..F.. F1F..1...
 0da40 0220f8bd 0c20f8bd 0120f8bd 2320f8bd  . ... ... ..# ..
 0da50 2a20f8bd 1220f8bd 2846f8bd f8b50546  * ... ..(F.....F
 0da60 0e46fdf7 57fb8207 6ed52846 0ff00ffb  .F..W...n.(F....
 0da70 fef782fb 04460028 68d0af78 ceb38388  .....F.(h..x....
 0da80 a0f86831 a81c0ff0 02fba4f8 6a01281d  ..h1........j.(.
 0da90 0ff0fdfa a4f86c01 a81d0ff0 f8faa4f8  ......l.........
 0daa0 6e0105f1 08000ff0 f2faa4f8 700105f1  n...........p...
 0dab0 0a000ff0 ecfaa4f8 720105f1 0c000ff0  ........r.......
 0dac0 e6fab4f8 6c11a4f8 74010546 b4f86e21  ....l...t..F..n!
 0dad0 b4f86a01 b4f87031 fff7f0fc 18b9b4f8  ..j...p1........
 0dae0 7231ab42 07d90023 a4f86831 3b271225  r1.B...#..h1;'.%
 0daf0 02e03546 00e00546 23789b06 28d5c6b1  ..5F...F#x..(...
 0db00 bdb91b20 0821fcf7 14fa0646 b8b10768  ... .!.....F...h
 0db10 04f5c172 39462046 00f0e0fb 0d4b3870  ...r9F F.....K8p
 0db20 1b5c0133 20463146 0322dbb2 fff7e2fa  .\.3 F1F."......
 0db30 05e02046 94f83310 3a4600f0 99ff2378  .. F..3.:F....#x
 0db40 6ff34513 237003e0 0120f8bd 0220f8bd  o.E.#p... ... ..
 0db50 2846f8bd 9ef20100 38b5084b 1d685db1  (F......8..K.h].
 0db60 ac794cb9 01201c60 01f0faff 28460221  .yL.. .`....(F.!
 0db70 fef738fe 204638bd 0c2038bd d8330020  ..8. F8.. 8..3. 
 0db80 38b50446 0ff083fa b0f5706f a57822d2  8..F......po.x".
 0db90 152d03d8 132d07d2 052d04e0 292d03d0  .-...-...-..)-..
 0dba0 3b2d01d0 1a2d16d1 fef7e6fa a8b190f8  ;-...-..........
 0dbb0 3720a2b9 848f04f0 2004a4b2 2cb10948  7 ...... ...,..H
 0dbc0 40f2ff21 1346fcf7 83f880f8 375000f0  @..!.F......7P..
 0dbd0 43fc2046 38bd1220 38bd0220 38bd0c20  C. F8.. 8.. 8.. 
 0dbe0 38bd00bf 7ef20100 38b50ff0 50fafef7  8...~...8...P...
 0dbf0 c3faa0b1 828f02f0 10039bb2 8bb94178  ..............Ax
 0dc00 01f00201 01f0ff05 21b90421 00f048fc  ........!..!..H.
 0dc10 284638bd 42f01002 82871846 38bd0220  (F8.B......F8.. 
 0dc20 38bd0c20 38bd2de9 f0410d46 17460ff0  8.. 8.-..A.F.F..
 0dc30 2efa8046 fef7a0fa 18b190f8 2b600024  ...F........+`.$
 0dc40 01e07f26 02242846 41460ff0 05fa0323  ...&.$(FAF.....#
 0dc50 ae703b70 2046bde8 f081f8b5 0d461646  .p;p F.......F.F
 0dc60 0ff015fa 0746fef7 87faa8b1 437803f0  .....F......Cx..
 0dc70 080303f0 ff04aa1c 3bb150f8 1f3fc5f8  ........;.P..?..
 0dc80 02300379 13710024 07e050f8 1a3fc5f8  .0.y.q.$..P..?..
 0dc90 02300379 137100e0 02242846 39460ff0  .0.y.q...$(F9F..
 0dca0 dbf90723 33702046 f8bd38b5 0546fef7  ...#3p F..8..F..
 0dcb0 9dfa0128 06d92b79 13f0e00f 14bf1224  ...(..+y.......$
 0dcc0 002400e0 12242946 fff77efa 204638bd  .$...$)F..~. F8.
 0dcd0 2de9f041 04460f46 15460ff0 d8f90646  -..A.F.F.F.....F
 0dce0 fef74afa 98b1a01c 0ff0d1f9 8046201d  ..J..........F .
 0dcf0 0ff0cdf9 04464046 fdf79ef8 48b12046  .....F@F....H. F
 0dd00 fdf7a0f8 002814bf 00241224 02e00224  .....(...$.$...$
 0dd10 00e01224 38463146 0ff09ef9 02232b70  ...$8F1F.....#+p
 0dd20 2046bde8 f08138b5 05460ff0 b0f9fef7   F....8..F......
 0dd30 23fa0446 00b3c379 022b1fd0 90f83630  #..F...y.+....60
 0dd40 022b1dd0 a81c0ff0 b2f904f5 9473c3e9  .+...........s..
 0dd50 000105f1 0a000ff0 9af905f1 0c01a4f8  ................
 0dd60 22011022 04f59c70 0ff0daf9 20460221  ".."...p.... F.!
 0dd70 00f096fb 002038bd 022038bd 1f2038bd  ..... 8.. 8.. 8.
 0dd80 0c2038bd 2de9f041 0e469046 07460ff0  . 8.-..A.F.F.F..
 0dd90 7ef90546 fef7f0f9 0446f8b1 c379012b  ~..F.....F...y.+
 0dda0 1ed090f8 2031072b 1cd1b8f1 1a0f0dd1  .... 1.+........
 0ddb0 b91c1022 00f59c70 0ff0b2f9 204600f0  ..."...p.... F..
 0ddc0 4afa2046 052100f0 74fa0be0 03210622  J. F.!..t....!."
 0ddd0 00f04efe 082384f8 203103e0 022402e0  ..N..#.. 1...$..
 0dde0 1f2400e0 00243046 29460ff0 35f92046  .$...$0F)F..5. F
 0ddf0 bde8f081 2de9f041 0f461546 04460ff0  ....-..A.F.F.F..
 0de00 46f90646 fef7b8f9 8046d8b1 a01c0ff0  F..F.....F......
 0de10 3ef9b8f8 602040f2 e2435343 b8f86220  >...` @..CSC..b 
 0de20 02fb0333 42f21072 b3fbf2f3 98420bd3  ...3B..r.....B..
 0de30 d8f81441 a8f84600 3cb14046 fef768fb  ...A..F.<.@F..h.
 0de40 002402e0 022400e0 12243846 31460ff0  .$...$...$8F1F..
 0de50 03f90223 2b702046 bde8f081 f8b5c58f  ...#+p F........
 0de60 b0f86230 1d440735 04460e46 adb2002a  ..b0.D.5.F.F...*
 0de70 3bd09189 4ff6ff73 994228d0 b0f860c0  ;...O..s.B(...`.
 0de80 50895388 471b17f4 004f18bf 324f40f2  P.S.G....O..2O@.
 0de90 e24e18bf 79430efb 0cfc18bf 281a0efb  .N..yC......(...
 0dea0 03f315bf 0cfb0011 0efb01fe b1fbf3f0  ................
 0deb0 0cfb07e1 15bf03fb 1011b1fb f3f05b1a  ..............[.
 0dec0 03fb1013 40f2e241 b3fbf1f3 00e00023  ....@..A.......#
 0ded0 a4f87831 5388a4f8 7a31d388 a4f87e31  ..x1S...z1....~1
 0dee0 9388a4f8 7c310123 0fe0b0f8 6c31a0f8  ....|1.#....l1..
 0def0 7a31b0f8 7031a0f8 7e31b0f8 6e31a0f8  z1..p1..~1..n1..
 0df00 7c3190f8 3530a0f8 782184f8 76313046  |1..50..x!..v10F
 0df10 94f87631 a4f88051 00f8013b b4f87811  ..v1...Q...;..x.
 0df20 0ff09af8 f01cb4f8 7a110ff0 95f8701d  ........z.....p.
 0df30 b4f87c11 0ff090f8 f01db4f8 7e110ff0  ..|.........~...
 0df40 8bf806f1 09002946 0ff086f8 237843f0  ......)F....#xC.
 0df50 80032370 f8bd00bf 1efbffff 38b50446  ..#p........8..F
 0df60 0d46481c 617a0ff0 77f8e81c 218a0ff0  .FH.az..w...!...
 0df70 73f8681d 217a0ff0 6ff8e81d e189bde8  s.h.!z..o.......
 0df80 38400ff0 69b80000 2de9f843 05460c46  8@..i...-..C.F.F
 0df90 164601f1 020901f1 04088f1d 72b10846  .F..........r..F
 0dfa0 11880ff0 59f84846 71880ff0 55f84046  ....Y.HFq...U.@F
 0dfb0 b1880ff0 51f83846 f18819e0 b0f86831  ....Q.8F......h1
 0dfc0 23b92348 4ff43a71 fbf782fe 0846b5f8  #.#HO.:q.....F..
 0dfd0 6a110ff0 41f84846 b5f86c11 0ff03cf8  j...A.HF..l...<.
 0dfe0 4046b5f8 6e110ff0 37f8b5f8 70113846  @F..n...7...p.8F
 0dff0 0ff032f8 00232372 04f10900 e98f0ff0  ..2..##r........
 0e000 2bf804f1 0b004ff6 ff710ff0 25f804f1  +.....O..q..%...
 0e010 0d004ff6 ff710ff0 1ff804f1 0f004ff6  ..O..q........O.
 0e020 ff710ff0 19f804f1 11004ff6 ff710ff0  .q........O..q..
 0e030 13f804f1 13004ff6 ff710ff0 0df804f1  ......O..q......
 0e040 15004ff6 ff71bde8 f8430ff0 05b800bf  ..O..q...C......
 0e050 90f20100 2221fef7 1fbe0000 f8b50446  ...."!.........F
 0e060 0e461b20 0821fbf7 64ff0746 002800f0  .F. .!..d..F.(..
 0e070 95800568 691c082e 7cd8dfe8 06f0050b  ...hi...|.......
 0e080 52273041 46824c00 20460022 fff7e6fe  R'0AF.L. F."....
 0e090 002679e0 424b1a68 c5f80120 1b790b71  .&y.BK.h... .y.q
 0e0a0 0b68c4f8 1f300b79 84f82330 e18fb4f8  .h...0.y..#0....
 0e0b0 62301944 073189b2 a184a81d 0ef0ccff  b0.D.1..........
 0e0c0 637843f0 08036370 01265de0 e379012b  cxC...cp.&]..y.+
 0e0d0 0cbf0826 0e26fdf7 1df86870 54e06378  ...&.&....hpT.cx
 0e0e0 43f00203 63700823 6b70a81c 4ff6ff71  C...cp.#kp..O..q
 0e0f0 0ef0b2ff 281d0021 0ef0aeff 0c2643e0  ....(..!.....&C.
 0e100 94f83730 6b700226 3ee02046 0022fff7  ..70kp.&>. F."..
 0e110 3bff0f26 38e02046 2946fff7 1fff1426  ;..&8. F)F.....&
 0e120 32e094f8 2031022b 2dd004f5 9473d3e9  2... 1.+-....s..
 0e130 00230846 0ef09cff 04f5a876 05f10900  .#.F.......v....
 0e140 b4f82211 0ef088ff 30460821 01f096f9  ..".....0F.!....
 0e150 314605f1 0b000822 04f59876 0ef0e0ff  1F....."...v....
 0e160 30460421 01f08af9 d4f83031 c5f81330  0F.!......01...0
 0e170 032609e0 00220b48 40f22651 1346fbf7  .&...".H@.&Q.F..
 0e180 a7fd1226 00e00a26 074b2e70 9b5d0133  ...&...&.K.p.].3
 0e190 20463946 0322dbb2 fef7acff 3846f8bd   F9F."......8F..
 0e1a0 b8330020 90f20100 9ef20100 37b50446  .3. ........7..F
 0e1b0 08460d46 0ef06bff adf80000 a81c0ef0  .F.F..k.........
 0e1c0 66ffadf8 0200281d 0ef061ff adf80400  f.....(...a.....
 0e1d0 a81d0ef0 5cffbdf8 0030adf8 06001b3b  ....\....0.....;
 0e1e0 9bb2e02b 01d90120 17e0bdf8 04301b3b  ...+... .....0.;
 0e1f0 9bb2e02b f7d8a0f5 a470b0f5 e06ff2d8  ...+.....p...o..
 0e200 bdf80230 a3f5a473 9bb2b3f5 e06fead8  ...0...s.....o..
 0e210 20466946 fef7b2fa 002003b0 30bd70b5   FiF..... ..0.p.
 0e220 0e2b0446 1646c379 01d1012b 00e0022b  .+.F.F.y...+...+
 0e230 0fd10d78 fcf76eff 284084f8 39000021  ...x..n.(@..9..!
 0e240 701c0822 faf7e5fe 94f83930 73700920  p.."......90sp. 
 0e250 70bd0720 70bd10b5 044604f5 9c7002f0  p.. p....F...p..
 0e260 27fd0028 f9d110bd c37a03f0 0303032b  '..(.....z.....+
 0e270 10d150f8 103c1b78 023bdbb2 0f2b09d8  ..P..<.x.;...+..
 0e280 012202fa 03f348f6 1f301840 003018bf  ."....H..0.@.0..
 0e290 01207047 00207047 c37e03f0 0303032b  . pG. pG.~.....+
 0e2a0 05d10368 1878831f 58425841 70470020  ...h.x..XBXApG. 
 0e2b0 704738b5 04460d46 1b200821 fbf739fe  pG8..F.F. .!..9.
 0e2c0 014640b1 03680322 1d702046 0123fef7  .F@..h.".p F.#..
 0e2d0 11ff0020 38bd4ff0 ff3038bd 08b5c379  ... 8.O..08....y
 0e2e0 022b01f1 010103d1 fff74efe 102008bd  .+........N.. ..
 0e2f0 fff7b4fd 002008bd f8b50446 08460d46  ..... .....F.F.F
 0e300 17461e46 0ef0c3fe a4f88201 a81c0ef0  .F.F............
 0e310 befea4f8 8401281d 0ef0b9fe a4f88601  ......(.........
 0e320 a81d0ef0 b4fea4f8 88012b7a 84f88a31  ..........+z...1
 0e330 05f10900 0ef0abfe a4f88c01 05f10b00  ................
 0e340 0ef0a5fe a4f88e01 05f10d00 0ef09ffe  ................
 0e350 a4f89001 05f10f00 0ef099fe a4f89201  ................
 0e360 05f11100 0ef093fe a4f89401 05f11300  ................
 0e370 0ef08dfe a4f89601 05f11500 0ef087fe  ................
 0e380 b4f88411 a4f89801 b4f88621 b4f88201  ...........!....
 0e390 b4f88831 fff792f8 00284ed1 0f2e04f5  ...1.....(N.....
 0e3a0 c17215d1 b4f86030 b4f88211 99420fd8  .r....`0.....B..
 0e3b0 b4f88411 99420bd3 b4f86410 b4f88831  .....B....d....1
 0e3c0 994205d1 b4f86210 b4f88631 99422fd0  .B....b....1.B/.
 0e3d0 e379022b 01d0102e 1ed1b4f8 6831dbb1  .y.+........h1..
 0e3e0 b4f88211 b4f86a01 814215d3 b4f86c31  ......j..B....l1
 0e3f0 994211d8 b4f88411 81420dd3 99420bd8  .B.......B...B..
 0e400 b4f88611 b4f86e31 994205d1 b4f88811  ......n1.B......
 0e410 b4f87031 99420bd0 20461146 00f0f8fe  ..p1.B.. F.F....
 0e420 237884f8 336043f0 20032370 ff20f8bd  #x..3`C. .#p. ..
 0e430 20463946 fff752ff f8bd1e23 7e70bb70   F9F..R....#~p.p
 0e440 1120f8bd 00f00300 032803d1 8b1e5842  . .......(....XB
 0e450 58417047 00207047 70b590f8 37200446  XApG. pGp...7 .F
 0e460 2ab90e48 40f26e51 1346fbf7 31fc0521  *..H@.nQ.F..1..!
 0e470 fff7f4fd 80b1a38f b4f86460 43f02003  ..........d`C. .
 0e480 a38742f2 10735e43 faf758fd 05463046  ..B..s^C..X..F0F
 0e490 faf710fc 28446065 70bd00bf 90f20100  ....(D`ep.......
 0e4a0 052970b5 04460d46 06d10022 114840f2  .)p..F.F...".H@.
 0e4b0 8a511346 fbf70cfc 90f83630 ff2b13d1  .Q.F......60.+..
 0e4c0 fff7ccfd 80b1012d 84f83650 0cd004f1  .......-..6P....
 0e4d0 c0063046 0849094a 2346fbf7 e3fa3046  ..0F.I.J#F....0F
 0e4e0 4ff4a051 fbf70cfb a28f0123 ab401343  O..Q.......#.@.C
 0e4f0 a38770bd 90f20100 c8320020 55e00000  ..p......2. U...
 0e500 38b590f8 37400546 1cb1bde8 3840fff7  8...7@.F....8@..
 0e510 a3bf90f8 3630ff2b 1bd1838f cbb1ab8f  ....60.+........
 0e520 2341da07 12d5042c 28460ad1 6b785b07  #A.....,(F..kx[.
 0e530 07d50021 00f054ff ab8f23f0 1003ab87  ...!..T...#.....
 0e540 04e02146 bde83840 fff7aabf 0134092c  ..!F..8@.....4.,
 0e550 e5d138bd 38b590f8 36308b42 04460d46  ..8.8...60.B.F.F
 0e560 05d1c030 fbf7aefa ff2384f8 3630a28f  ...0.....#..60..
 0e570 0123ab40 22ea0303 a3872046 bde83840  .#.@"..... F..8@
 0e580 fff7bebf 2de9f84f 0d686b78 af78013b  ....-..O.hkx.x.;
 0e590 152f0446 884605f1 030bdbb2 00f25282  ./.F.F........R.
 0e5a0 c94ad15d 99429146 40f04c82 fb1edbb2  .J.].B.F@.L.....
 0e5b0 112b1ad8 c54ad65c beb1fcf7 abfd10ea  .+...J.\........
 0e5c0 060a12d1 032f40f0 448294f8 393003f0  ...../@.D...90..
 0e5d0 040303f0 ff001a22 1bb16f70 aa701126  ......."..op.p.&
 0e5e0 19e26a70 82460d26 15e2152f 00f20d82  ..jp.F.&.../....
 0e5f0 dfe817f0 16004a00 0b021401 4f016e01  ......J.....O.n.
 0e600 7c018f00 c300c800 9601a301 d800ea01  |...............
 0e610 0d01ac01 d301ea01 3102a901 67008000  ........1...g...
 0e620 e379012b 00f0f181 eb7884f8 7631281d  .y.+.....x..v1(.
 0e630 0ef02dfd a4f87801 a81d0ef0 28fda4f8  ..-...x.....(...
 0e640 7a0105f1 08000ef0 22fda4f8 7c0105f1  z......."...|...
 0e650 0a000ef0 1cfda4f8 7e0105f1 0c000ef0  ........~.......
 0e660 16fde38f a4f88001 c01a80b2 47f6fe73  ............G..s
 0e670 984204d9 20462821 fef70efb c5e12378  .B.. F(!......#x
 0e680 43f08003 2370c0e1 e379022b 40f0bd81  C...#p...y.+@...
 0e690 05f10800 0ef0fbfc e38fc31a 9bb247f6  ..............G.
 0e6a0 fe729342 e6d8a084 dbf80030 c4f81f30  .r.B.......0...0
 0e6b0 9bf80430 84f82330 637843f0 08036370  ...0..#0cxC...cp
 0e6c0 a3e12046 5946fff7 71fd0028 40f0ba81  .. FYF..q..(@...
 0e6d0 94f83630 082b05d0 a38fda05 44bf23f4  ..60.+......D.#.
 0e6e0 8073a387 20462946 fff738fc 4ff0000a  .s.. F)F..8.O...
 0e6f0 152690e1 94f83650 082d40f0 86812046  .&....6P.-@... F
 0e700 5946fff7 53fd0028 40f09c81 20462946  YF..S..(@... F)F
 0e710 45e0ed78 102d06d8 0f2d09d2 bdb10e2d  E..x.-...-.....-
 0e720 12d10325 13e0122d 04d0142d 0ed00be0  ...%...-...-....
 0e730 06250ce0 a3786ff3 8203a370 04f1fc00  .%...xo....p....
 0e740 fbf7c0f9 072502e0 092500e0 082594f8  .....%...%...%..
 0e750 3630ab42 40f05981 20462946 fff7fafe  60.B@.Y. F)F....
 0e760 062d02d1 20461a21 3fe1032d 40f04d81  .-.. F.!?..-@.M.
 0e770 20461a21 00f00cfe 47e12046 59462a46   F.!....G. FYF*F
 0e780 082348e0 eb7884f8 3930a38f 1b0740f1  .#H..x..90....@.
 0e790 3c812046 002100f0 fbfd2046 0321fff7  <. F.!.... F.!..
 0e7a0 d9fe32e1 eb7884f8 3a302e1d 30460ef0  ..2..x..:0..0F..
 0e7b0 6efca4f8 4200a81d 0ef069fc 6378a4f8  n...B.....i.cx..
 0e7c0 440043f0 040303f0 02026370 02f0ff07  D.C.......cp....
 0e7d0 7ab943f0 02036370 08236b70 a81c4ff6  z.C...cp.#kp..O.
 0e7e0 ff710ef0 39fc3046 39460ef0 35fc0c26  .q..9.0F9F..5..&
 0e7f0 00e0ff26 a38fdf06 40f13381 20460021  ...&....@.3. F.!
 0e800 00f0eefd 20460421 fff7a4fe 29e12046  .... F.!....). F
 0e810 59462a46 0e23fff7 02fdd3e0 e379022b  YF*F.#.......y.+
 0e820 40f0f380 4ff0000a a4f826a1 a4f824a1  @...O.....&...$.
 0e830 84f821a1 58460ef0 3afc04f5 9473c3e9  ..!.XF..:....s..
 0e840 000105f1 0b000ef0 22fc0822 a4f82201  ........".."..".
 0e850 05f10d01 04f5a870 0ef062fc 04f5a476  .......p..b....v
 0e860 d5f81530 c4f83031 30460821 00f006fe  ...0..010F.!....
 0e870 3146681c 082204f5 9a760ef0 51fc3046  1Fh.."...v..Q.0F
 0e880 042100f0 fbfdd4f8 3431c5f8 09300426  .!......41...0.&
 0e890 c1e094f8 3630022b 40f0b780 0023a4f8  ....60.+@....#..
 0e8a0 2631a4f8 243184f8 213104f5 a4705946  &1..$1..!1...pYF
 0e8b0 08220ef0 35fcd5f8 0b30c4f8 34312046  ."..5....0..41 F
 0e8c0 fff7c9fc 04239be0 9ef20100 b4f20100  .....#..........
 0e8d0 e379012b 08d194f8 2031042b 04d10523  .y.+.... 1.+...#
 0e8e0 84f82031 062619e0 ff2617e0 94f82031  .. 1.&...&.... 1
 0e8f0 052b40f0 8a80e379 012b0ad1 022184f8  .+@....y.+...!..
 0e900 20112046 fff726fe 2046fdf7 01feff26   . F..&. F.....&
 0e910 00e00626 20460021 00f0dafc f6b272e0  ...& F.!......r.
 0e920 e379022b 06d194f8 2031022b 14bfff26  .y.+.... 1.+...&
 0e930 0b2600e0 ff26f6b2 93e094f8 07a0baf1  .&...&..........
 0e940 010f62d1 8be02046 072128e7 23789e06  ..b... F.!(.#x..
 0e950 26d4a38f 58060fd5 e379022b 08d12046  &...X....y.+.. F
 0e960 0621fff7 f7fd2046 232100f0 81fc03e0  .!.... F#!......
 0e970 0f236b70 232308e0 e379012b 08d16378  .#kp##...y.+..cx
 0e980 190705d5 0f236b70 2a23ab70 112019e0  .....#kp*#.p. ..
 0e990 20465946 2a460f23 11e0e379 022b01d1   FYF*F.#...y.+..
 0e9a0 ff200fe0 23789a06 44bf6ff3 45132370  . ..#x..D.o.E.#p
 0e9b0 a38f5b06 f4d52046 59462a46 1023fff7  ..[... FYF*F.#..
 0e9c0 9bfcc0b2 c6b21ee0 94f83610 0d2f0cbf  ..........6../..
 0e9d0 ed782d79 02290bd0 062916d1 112f14d1  .x-y.)...).../..
 0e9e0 2046fff7 b7fd2046 294600f0 41fc0ce0   F.... F)F..A...
 0e9f0 2046fff7 affd2046 294600f0 69fc0123   F.... F)F..i..#
 0ea00 84f82031 01e0ff2e 03d14046 fbf7a7fa  .. 1......@F....
 0ea10 15e04ff0 000a072e 2e7008bf 6f7019f8  ..O......p..op..
 0ea20 06300133 20464146 0322dbb2 fef762fb  .0.3 FAF."....b.
 0ea30 baf1000f 03d02046 0221fff7 0ffb0020  ...... F.!..... 
 0ea40 bde8f88f 4046fbf7 8afa4ff0 ff30bde8  ....@F....O..0..
 0ea50 f88f0726 dfe74ff0 000a1326 dbe70b26  ...&..O....&...&
 0ea60 d9e7ff2e d1d02e70 4ff0000a d7e700bf  .......pO.......
 0ea70 70b50446 0e461b20 08211546 fbf759fa  p..F.F. .!.F..Y.
 0ea80 0146d0b1 032e0368 07d194f8 392012f0  .F.....h....9 ..
 0ea90 040f14bf 11200d20 00e01120 0d281870  ..... . ... .(.p
 0eaa0 0ebf5d70 5e709d70 20460cbf 02230323  ..]p^p.p F...#.#
 0eab0 0322fef7 1ffb0020 70bd0120 70bd38b5  ."..... p.. p.8.
 0eac0 02681378 023b0546 0f2b3ed8 dfe803f0  .h.x.;.F.+>.....
 0ead0 0821233d 2b3d3d3d 21373d1f 3d3d3d0f  .!#=+===!7=.===.
 0eae0 0b7843f0 02030b70 4ff0ff34 2ee091f8  .xC....pO..4....
 0eaf0 3630062b 01bf9378 81f83230 4b7843f0  60.+...x..20KxC.
 0eb00 010308bf 4b7091f8 2031022b 1dd90123  ....Kp.. 1.+...#
 0eb10 19e00323 17e00723 81f82031 4b7843f0  ...#...#.. 1KxC.
 0eb20 80034b70 11e0cb79 022b0ed1 81f82031  ..Kp...y.+.... 1
 0eb30 8b785b07 09d50846 fdf7eafc 05e0cb79  .x[....F.......y
 0eb40 022b02d1 062381f8 20310024 2846fbf7  .+...#.. 1.$(F..
 0eb50 06fa2046 38bd0000 024a5369 01335361  .. F8....JSi.3Sa
 0eb60 0af080bb ac300020 10b50b48 fbf744fc  .....0. ...H..D.
 0eb70 044670b1 0e230370 03234370 01238370  .Fp..#.p.#Cp.#.p
 0eb80 00210330 0ef068fa 2046fff7 e5ff0020  .!.0..h. F..... 
 0eb90 10bd0720 10bd00bf 5c3b0020 0a4bda79  ... ....\;. .K.y
 0eba0 02f02002 02f0ff03 62b10138 00f00703  .. .....b..8....
 0ebb0 082290fb f2f20120 d2b29840 034b9b5c  ."..... ...@.K.\
 0ebc0 18407047 18467047 a01e0020 a81e0020  .@pG.FpG... ... 
 0ebd0 3f28cbbf 403800f1 ff300649 06490822  ?(..@8...0.I.I."
 0ebe0 90fbf2f2 d2b200f0 07030120 98408b5c  ........... .@.\
 0ebf0 18407047 981e0020 a01e0020 2de9f041  .@pG... ... -..A
 0ec00 46688eb0 014626b9 b44840f2 97313246  Fh...F&..H@..12F
 0ec10 08e0b348 fbf704fc 044630b1 af4840f2  ...H.....F0..H@.
 0ec20 9b310022 1346fbf7 53f83046 0ef02ffa  .1.".F..S.0F../.
 0ec30 c0f38523 013b0746 c0f30908 8df80740  ...#.;.F.......@
 0ec40 072b00f2 7482dfe8 13f00800 72022000  .+..t.......r. .
 0ec50 5100ac00 72027202 bc00b8f1 060fb378  Q...r.r........x
 0ec60 06f10300 03d0b8f1 1d0f05d0 5fe2032b  ............_..+
 0ec70 07d1fef7 85ff05e0 022b02d1 fef7b4ff  .........+......
 0ec80 00e01220 00f58074 1ce2b8f1 630fb378  ... ...t....c..x
 0ec90 06f10300 06f10901 19d006d8 b8f1010f  ................
 0eca0 0ad0b8f1 030f0cd0 41e2b8f1 7b0f18d0  ........A...{...
 0ecb0 b8f17c0f 15d03ae2 082b40f0 3a82894a  ..|...:..+@.:..J
 0ecc0 09e0002b 40f03582 fcf734fa 77e0082b  ...+@.5...4.w..+
 0ecd0 40f02f82 844a0368 13604368 53600024  @./..J.h.`ChS`.$
 0ece0 f8e10df1 0702fff7 85f868e0 08f1ff33  ..........h....3
 0ecf0 b478b51d 082b00f2 1a82dfe8 13f00900  .x...+..........
 0ed00 21003600 18021802 18021802 18024500  !.6...........E.
 0ed10 002c40f0 0e820825 f01d2146 b5710ef0  .,@....%..!F.q..
 0ed20 9bf906f1 0a004ff6 ff717572 0ef094f9  ......O..qur....
 0ed30 06f10c00 21460ef0 8ff98df8 0750c9e1  ....!F.......P..
 0ed40 002c40f0 f6814022 28462146 faf761f9  .,@...@"(F!F..a.
 0ed50 664b03f1 240253f8 041b45f8 041b9342  fK..$.S...E....B
 0ed60 f9d14023 8df80730 b9e7002c 40f0e181  ..@#...0...,@...
 0ed70 4ff00808 28462146 4246faf7 4af96023  O...(F!FBF..J.`#
 0ed80 b3728df8 0780a5e1 002c40f0 d281584b  .r.......,@...XK
 0ed90 1a68c6f8 06209b88 ab800623 8df80730  .h... .....#...0
 0eda0 98e1b8f1 050fb378 40f0c181 022b40f0  .......x@....+@.
 0edb0 c081f01c b11d0df1 0702fef7 34ff0446  ............4..F
 0edc0 80e14c4a b37812f8 0820ff2a 02d09342  ..LJ.x... .*...B
 0edd0 40f04881 08f1ff32 b51df11c 2e2a00f2  @.H....2.....*..
 0ede0 6481dfe8 12f02f00 35003e00 62014a00  d...../.5.>.b.J.
 0edf0 4e005200 58006100 6a007200 6e007600  N.R.X.a.j.r.n.v.
 0ee00 8d009300 90009900 9e00a300 a700ab00  ................
 0ee10 b200b600 d100d800 dc00dc00 e7006201  ..............b.
 0ee20 62016201 f200ef00 f700fe00 0a016201  b.b...........b.
 0ee30 62012701 2b012f01 32013801 3c014101  b.'.+./.2.8.<.A.
 0ee40 45014a01 2c4a0b68 13604b68 53602ee1  E.J.,J.h.`KhS`..
 0ee50 2a4c2846 a1880ef0 fff8a378 33720323  *L(F.......x3r.#
 0ee60 20e10824 00212246 2846faf7 d2f8fcf7   ..$.!"F(F......
 0ee70 51f98df8 0740b071 19e10846 fcf72cf8  Q....@.q...F..,.
 0ee80 f9e00846 fcf732fb f5e02846 0df10701  ...F..2...(F....
 0ee90 fcf7b6fb efe0002b 00f0e480 013b0846  .......+.....;.F
 0eea0 d9b2fcf7 29fce6e0 002b00f0 db80013b  ....)....+.....;
 0eeb0 0846d9b2 fcf70efc dde00846 fcf7a6fb  .F.........F....
 0eec0 d9e00846 01f0a0f9 d5e00846 01f068f9  ...F.......F..h.
 0eed0 d1e00846 fef740fc cde000bf c6f20100  ...F..@.........
 0eee0 403b0020 a01e0020 981e0020 00f30100  @;. ... ... ....
 0eef0 d8000020 ca0b0200 a81e0020 c0320020  ... ....... .2. 
 0ef00 fef72afe b7e001f0 a7fdb4e0 28460df1  ..*.........(F..
 0ef10 070101f0 bbfdaee0 301df178 01f0c2fd  ........0..x....
 0ef20 a9e0301d f17801f0 e5fda4e0 0846fef7  ..0..x.......F..
 0ef30 1ffda0e0 0846fef7 b8fe9ce0 08460df1  .....F.......F..
 0ef40 07022946 fef789fe 95e00846 fef7f8fc  ..)F.......F....
 0ef50 91e002a8 10220ef0 e3f806a8 06f11301  ....."..........
 0ef60 10220ef0 ddf802a8 01f0a2fe 044630b9  ."...........F0.
 0ef70 28460aa9 10220ef0 d3f81023 17e00023  (F...".....#...#
 0ef80 8df80730 3a2493e0 28460821 00f076fa  ...0:$..(F.!..v.
 0ef90 08230446 0be00846 fef7c5fe 6be00846  .#.F...F....k..F
 0efa0 5ffa88f2 2946fef7 edfe0223 04468df8  _...)F.....#.F..
 0efb0 07307de0 fcf7a8f8 02460b46 28460ef0  .0}......F.F(F..
 0efc0 57f86ee0 08460021 01e00846 0121fef7  W.n..F.!...F.!..
 0efd0 45fd50e0 08460df1 07022946 fef778fe  E.P..F....)F..x.
 0efe0 49e0554c 2846617a 0ef036f8 06f10800  I.UL(Faz..6.....
 0eff0 61890ef0 31f80423 54e00846 0ef047f8  a...1..#T..F..G.
 0f000 0546701d 0ef043f8 04462846 fbf714ff  .Fp...C..F(F....
 0f010 40b32046 fbf716ff 20b3474b d9895c81  @. F.... .GK..\.
 0f020 eab2a142 5a7242d3 9979a942 3fd31a72  ...BZrB..y.B?..r
 0f030 9c813ce0 084600f0 13fb1ce0 084600f0  ..<..F.......F..
 0f040 57fb18e0 00f0d2fa 15e02846 0df10701  W.........(F....
 0f050 00f0dcfa 0fe00846 00f08afb 0be00846  .......F.......F
 0f060 00f088fb 122423e0 084600f0 69fb02e0  .....$#..F..i...
 0f070 084600f0 81fb0446 1ae02f4c 2846a179  .F.....F../L(F.y
 0f080 0df0eaff 06f10800 e1890df0 e5ff06f1  ................
 0f090 0a00e179 0df0e0ff 06f10c00 218a0df0  ...y........!...
 0f0a0 dbff0823 8df80730 01e00124 00e00024  ...#...0...$...$
 0f0b0 a8f10d03 9bb2192b 04d80122 9a401f4b  .......+...".@.K
 0f0c0 13408bbb 002c03da 1d484ff4 6f71a8e5  .@...,...HO.oq..
 0f0d0 ff2c0ddc 0e233370 9df80730 04337370  .,...#3p...0.3sp
 0f0e0 0123b370 f01c3946 0df0b6ff 74710ce0  .#.p..9F....tq..
 0f0f0 0f233370 0423a4f5 80747370 0123b470  .#3p.#...tsp.#.p
 0f100 f370301d 39460df0 a7ff0e4b 1cb11a69  .p0.9F.....K...i
 0f110 01321a61 02e0da68 0132da60 3046fff7  .2.a...h.2.`0F..
 0f120 1bfd0eb0 bde8f081 04f58074 cae70124  ...........t...$
 0f130 d0e71224 cee700bf b8330020 41120003  ...$.....3. A...
 0f140 c6f20100 ac300020 38b50546 0848fbf7  .....0. 8..F.H..
 0f150 53f90146 48b10024 10230470 43704560  S..FH..$.#.pCpE`
 0f160 0448faf7 46fd2046 38bd0720 38bd00bf  .H..F. F8.. 8...
 0f170 403b0020 c8320020 08b5fbf7 edfe0020  @;. .2. ....... 
 0f180 08bd0000 074b0848 1f211970 074bff22  .....K.H.!.p.K."
 0f190 1a705a70 9a70da70 1a715971 08220021  .pZp.p.p.qYq.".!
 0f1a0 f9f737bf a81e0020 981e0020 a01e0020  ..7.... ... ... 
 0f1b0 38b50546 0720fff7 f1fc28b3 1348fbf7  8..F. ....(..H..
 0f1c0 1bf90446 00b33e23 03700b23 43700723  ...F..>#.p.#Cp.#
 0f1d0 8370a988 03300df0 3fff601d 297b0df0  .p...0..?.`.){..
 0f1e0 3bffe01d e98a0df0 37ff04f1 0900697b  ;.......7.....i{
 0f1f0 0df032ff 04f10b00 298b0df0 2dff2046  ..2.....)...-. F
 0f200 bde83840 fff7a8bc 38bd00bf 5c3b0020  ..8@....8...\;. 
 0f210 70b50646 06200d46 fff7c0fc 28b31348  p..F. .F....(..H
 0f220 fbf7eaf8 044600b3 3e230370 0b234370  .....F..>#.p.#Cp
 0f230 06238370 b1880330 0df00eff 601d2988  .#.p...0....`.).
 0f240 0df00aff e01d6988 0df006ff 04f10900  ......i.........
 0f250 a9880df0 01ff04f1 0b00e988 0df0fcfe  ................
 0f260 2046bde8 7040fff7 77bc70bd 5c3b0020   F..p@..w.p.\;. 
 0f270 70b50546 03200e46 fff790fc 28b31348  p..F. .F....(..H
 0f280 fbf7baf8 044600b3 3e230370 0a234370  .....F..>#.p.#Cp
 0f290 03238370 c670a988 04300df0 ddfea01d  .#.p.p...0......
 0f2a0 b5f86010 0df0d8fe 04f10800 b5f86210  ..`...........b.
 0f2b0 0df0d2fe 04f10a00 b5f86410 0df0ccfe  ..........d.....
 0f2c0 2046bde8 7040fff7 47bc70bd 5c3b0020   F..p@..G.p.\;. 
 0f2d0 2de9f041 837803f0 0203002b 0cbf0826  -..A.x.....+...&
 0f2e0 30260546 30460cbf 4ff00408 4ff00308  0&.F0F..O...O...
 0f2f0 0f46fff7 6dfcb0b1 0e48fbf7 7df80446  .F..m....H..}..F
 0f300 88b10670 80f80180 8770a988 03300df0  ...p.....p...0..
 0f310 a3fe082e 04d10fb9 012300e0 00236371  .........#...#cq
 0f320 2046fff7 19fcab78 43f00203 ab70bde8   F.....xC....p..
 0f330 f08100bf 5c3b0020 38b50546 0520fff7  ....\;. 8..F. ..
 0f340 2dfc00b3 1148fbf7 57f80446 c8b13e23  -....H..W..F..>#
 0f350 03700d23 43700523 8370a988 03300df0  .p.#Cp.#.p...0..
 0f360 7bfe05f5 9473601d d3e90023 0df080fe  {....s`....#....
 0f370 04f10d00 b5f82211 0df06efe 2046fff7  ......"...n. F..
 0f380 ebfb0020 38bd4ff0 ff3038bd 5c3b0020  ... 8.O..08.\;. 
 0f390 70b50546 04200e46 fff700fc e0b10f48  p..F. .F.......H
 0f3a0 fbf72af8 0446b8b1 3e230370 0c234370  ..*..F..>#.p.#Cp
 0f3b0 04238370 c670a988 18440df0 4dfea01d  .#.p.p...D..M...
 0f3c0 00210822 f9f725fe 95f83930 a3712046  .!."..%...90.q F
 0f3d0 bde87040 fff7c0bb 70bd00bf 5c3b0020  ..p@....p...\;. 
 0f3e0 70b50546 0c200e46 fff7f2fb 00b31148  p..F. .F.......H
 0f3f0 fbf702f8 0446d8b1 0c230370 08234370  .....F...#.p.#Cp
 0f400 8670a988 03300df0 27fe95f8 3a306371  .p...0..'...:0cq
 0f410 a01db5f8 42100df0 1ffe04f1 0800b5f8  ....B...........
 0f420 44100df0 19fe2046 bde87040 fff794bb  D..... F..p@....
 0f430 70bd00bf 5c3b0020 38b50546 faf770fa  p...\;. 8..F..p.
 0f440 0c4b1a7a 1f2a0446 0dd81a7a 0a490132  .K.z.*.F...z.I.2
 0f450 d2b21a72 1a681570 1a688a42 0cbf203a  ...r.h.p.h.B.. :
 0f460 01321a60 01e001f0 79fc2046 bde83840  .2.`....y. F..8@
 0f470 faf75cba f8350020 24360020 f8b50646  ..\..5. $6. ...F
 0f480 0c4674b3 184dfaf7 4bfa2a7a 2b7aa242  .Ft..M..K.*z+z.B
 0f490 28bf2246 9b1aa41a dbb2e4b2 2b7206f1  (."F........+r..
 0f4a0 ff3e1146 79b16b68 dff840c0 1b780ef8  .>.Fy.kh..@..x..
 0f4b0 013f6b68 0c4f6345 0cbf203b 01330139  .?kh.OcE.. ;.3.9
 0f4c0 7b60c9b2 eee71644 faf730fa 01f02efc  {`.....D..0.....
 0f4d0 3cb12b7a a342d4d2 034b1b7a 1f2bf8d9  <.+z.B...K.z.+..
 0f4e0 cfe70020 f8bd00bf f8350020 24360020  ... .....5. $6. 
 0f4f0 10b50446 03212046 fff7c0ff a3786178  ...F.! F.....xax
 0f500 20785a18 1218f5d0 40f2fd21 8a42f1d0   xZ.....@..!.B..
 0f510 03f03f03 43f04003 a37010bd 08b5044b  ..?.C.@..p.....K
 0f520 1b7a1f2b 01d801f0 01fc0020 08bd00bf  .z.+....... ....
 0f530 f8350020 08b5054b 054a0648 1a600121  .5. ...K.J.H.`.!
 0f540 5a6001f0 d1fb0020 08bd00bf f8350020  Z`..... .....5. 
 0f550 04360020 39f40000 2de9f041 0e4b0f4d  .6. 9...-..A.K.M
 0f560 1e780746 88460020 b04211da 15f8013c  .x.F.F. .B.....<
 0f570 434500f1 010408d1 28463946 0622f9f7  CE......(F9F."..
 0f580 2ffd10b9 2046bde8 f0812046 2835ebe7  /... F.... F(5..
 0f590 0020bde8 f08100bf cc360020 26360020  . .......6. &6. 
 0f5a0 08b50a4b 1b7873b1 fcf7c8fa 08b10020  ...K.xs........ 
 0f5b0 08bd00f0 69fe0028 f9d1054b 1868b0fa  ....i..(...K.h..
 0f5c0 80f04009 08bd0120 08bd00bf c4360020  ..@.... .....6. 
 0f5d0 d8330020 421e00f1 0f0312f8 010f10b9  .3. B...........
 0f5e0 9a42fad1 70470120 70470000 10b5fff7  .B..pG. pG......
 0f5f0 d7ff30b1 044b0024 1c7001f0 c1fb2046  ..0..K.$.p.... F
 0f600 10bd0c20 10bd00bf cc360020 034b1b78  ... .....6. .K.x
 0f610 03700123 0b700020 704700bf c5360020  .p.#.p. pG...6. 
 0f620 2de9f041 0c4b0d4c 1e780746 88460025  -..A.K.L.x.F.F.%
 0f630 b5420bda 63784345 05d1a01c 39460622  .B..cxCE....9F."
 0f640 f9f7cefc 28b12834 0135f1e7 0020bde8  ....(.(4.5... ..
 0f650 f0812046 bde8f081 cc360020 24360020  .. F.....6. $6. 
 0f660 2de9f843 0746fff7 9bff90b3 1d4e1e4b  -..C.F.......N.K
 0f670 34781b78 a3422fd9 3d4615f8 019b2846  4x.x.B/.=F....(F
 0f680 4946fff7 69ff50bb dff86080 28204443  IF..i.P...`.( DC
 0f690 08eb0403 f91d83f8 01902a68 c3f80220  ..........*h... 
 0f6a0 aa88da80 04f11805 45442846 10220df0  ........ED(F."..
 0f6b0 37fd04f1 08004044 07f11701 10220df0  7.....@D....."..
 0f6c0 2ffd3378 01333370 2846bde8 f84301f0  /.3x.33p(F...C..
 0f6d0 5dbb0c20 bde8f883 0720bde8 f8830020  ].. ..... ..... 
 0f6e0 bde8f883 cc360020 c5360020 24360020  .....6. .6. $6. 
 0f6f0 70b50446 fff754ff c8b1601c 2178fff7  p..F..T...`.!x..
 0f700 2bff0246 a8b10c4e 3478a042 11da0b4b  +..F...N4x.B...K
 0f710 451e2821 01fb0530 01fb0231 a21a0ef0  E.(!...0...1....
 0f720 d9f9013c 28463470 01f04efb 01e00c20  ...<(F4p..N.... 
 0f730 70bd0020 70bd00bf cc360020 24360020  p.. p....6. $6. 
 0f740 10b50446 fcf7faf9 08b10c20 10bd00f0  ...F....... ....
 0f750 9bfd0028 f9d1044b 18680028 f5d1034b  ...(...K.h.(...K
 0f760 22781a70 10bd00bf d8330020 c4360020  "x.p.....3. .6. 
 0f770 00207047 70470000 08b50df0 88fc431e  . pGpG........C.
 0f780 9bb24af2 b7129342 9ebf024b c0011860  ..J....B...K...`
 0f790 122008bd c8360020 014b1868 704700bf  . ...6. .K.hpG..
 0f7a0 c8360020 f0b50f46 8db01546 044628b9  .6. ...F...F.F(.
 0f7b0 1c4840f2 59112246 234604e0 2ab91948  .H@.Y."F#F..*..H
 0f7c0 4ff4ad71 1346faf7 83fad61c 3046fff7  O..q.F......0F..
 0f7d0 8ffe17b1 04f10802 01e004f1 18026b46  ..............kF
 0f7e0 02f1100e 6f461068 51681c46 03c40832  ....oF.hQh.F...2
 0f7f0 72452346 f7d104a8 00211022 f9f709fc  rE#F.....!."....
 0f800 31460df1 1d000322 0df08afc 384601f0  1F....."....8F..
 0f810 4ffa2846 0df12d01 03220df0 81fc0db0  O.(F..-.."......
 0f820 f0bd00bf d3f20100 70b51646 1d46fff7  ........p..F.F..
 0f830 f7fe0446 68b10db1 083000e0 1830fff7  ...Fh....0...0..
 0f840 c9fe30b1 20462946 3246fff7 abff0120  ..0. F)F2F..... 
 0f850 70bd70bd f0b58db0 04460b46 6a4601f1  p.p......F.FjF..
 0f860 10076e46 18685968 154603c5 0833bb42  ..nF.hYh.F...3.B
 0f870 2a46f7d1 00211022 04a8f9f7 cafb0322  *F...!."......."
 0f880 0df11d00 e11c0df0 4bfc3046 01f010fa  ........K.0F....
 0f890 9df82f20 23789a42 0bd19df8 2e206378  ../ #x.B..... cx
 0f8a0 9a4206d1 a0789df8 2d301b1a 58425841  .B...x..-0..XBXA
 0f8b0 00e00020 0db0f0bd 014b1878 704700bf  ... .....K.xpG..
 0f8c0 c4360020 08b5064b 4ff4e132 1a6001f0  .6. ...KO..2.`..
 0f8d0 93fa044b 042828bf 04201870 08bd00bf  ...K.((.. .p....
 0f8e0 c8360020 c5360020 08b5044b 00221a70  .6. .6. ...K.".p
 0f8f0 fff77cfe bde80840 fff7e4bf c4360020  ..|....@.....6. 
 0f900 2de9f041 0f4b104d 1c780746 8846ae1e  -..A.K.M.x.F.F..
 0f910 9cb12846 39460622 f9f762fb 48b935f8  ..(F9F."..b.H.5.
 0f920 023cb8f1 000f02d0 da0702d5 06e0db07  .<..............
 0f930 04d5013c e4b20835 e9e72646 3046bde8  ...<...5..&F0F..
 0f940 f08100bf b11e0020 d2360020 f8b50e4b  ....... .6. ...K
 0f950 0e4d1c78 06460f46 8cb12846 31460622  .M.x.F.F..(F1F."
 0f960 f9f73efb 38b935f8 023c17b1 da0702d5  ..>.8.5..<......
 0f970 07e0db07 05d5013c e4b20835 ece72046  .......<...5.. F
 0f980 f8bd0120 f8bd00bf b01e0020 12370020  ... ....... .7. 
 0f990 10b50446 0020a071 1b4a89b1 237ae071  ...F. .q.J..#z.q
 0f9a0 0133dbb2 022b01d0 237205e0 238a2072  .3...+..#r..#. r
 0f9b0 012b84bf 5b082382 d36f0133 d36710e0  .+..[.#..o.3.g..
 0f9c0 e3792172 0133dbb2 022b01d0 e37105e0  .y!r.3...+...q..
 0f9d0 238ae171 ff2b9cbf 5b002382 936f0133  #..q.+..[.#..o.3
 0f9e0 9367f9f7 f5fa238a 013b1840 013080b2  .g....#..;.@.0..
 0f9f0 b0f5807f 608205d9 00220448 75211346  ....`....".Hu!.F
 0fa00 faf766f9 10bd00bf ac300020 e3f20100  ..f......0. ....
 0fa10 10b50446 08460021 0a4601f0 abfb0146  ...F.F.!.F.....F
 0fa20 30b10022 164840f2 33211346 faf750f9  0..".H@.3!.F..P.
 0fa30 01f07afb 01f062fb fff73eff 10b101f0  ..z...b...>.....
 0fa40 35fe01e0 01f042fe 01f034fd 70b92379  5.....B...4.p.#y
 0fa50 db0702d5 01f068f8 01e001f0 67f86378  ......h.....g.cx
 0fa60 022b0cbf 03200220 fbf73cfb a3792bb1  .+... . ..<..y+.
 0fa70 20460021 bde81040 fff78abf 10bd00bf   F.!...@........
 0fa80 e3f20100 2030fbf7 39bb0000 38b5114c  .... 0..9...8..L
 0fa90 a378012b 17d0104a 136f0133 13670123  .x.+...J.o.3.g.#
 0faa0 23702382 63820d4b 00251d70 0c4ba571  #p#.c..K.%.p.K.q
 0fab0 2522e270 1d70f9f7 41faa061 0948fbf7  %".p.p..A..a.H..
 0fac0 1dfb2846 38bd0848 fbf7d0f9 0028e2d1  ..(F8..H.....(..
 0fad0 0c2038bd 50370020 ac300020 b01e0020  . 8.P7. .0. ... 
 0fae0 b11e0020 70370020 10280020 10b50446  ... p7. .(. ...F
 0faf0 1046fff7 05ff38b1 012c0088 02d1c0f3  .F....8..,......
 0fb00 800010bd c0f3c000 10bd0000 f8b50646  ...............F
 0fb10 0c461746 fff7f4fe a0b90f4d 2b78082b  .F.F.......M+x.+
 0fb20 18d00e49 326801eb c300c0f8 0220b288  ...I2h....... ..
 0fb30 c2805a1c 2a7014b9 21f83340 02e00122  ..Z.*p..!.3@..."
 0fb40 21f83320 03880b2f 0cbf43f0 040343f0  !.3 .../..C...C.
 0fb50 08030380 f8bd00bf b11e0020 d0360020  ........... .6. 
 0fb60 70b5104d 06462846 f9f72af9 0e4a536f  p..M.F(F..*..JSo
 0fb70 00240133 05f82c4c 536796b1 f9f7d0fe  .$.3..,LSg......
 0fb80 0546fbf7 b5fa0238 c0b20128 04d801f0  .F.....8...(....
 0fb90 45fb2046 fbf7a6fa 2846bde8 7040f9f7  E. F....(F..p@..
 0fba0 c5be70bd 7c370020 ac300020 f8b50378  ..p.|7. .0. ...x
 0fbb0 044623b9 2c30bde8 f840f9f7 01b9f9f7  .F#.,0...@......
 0fbc0 bdf9a38a 054640f2 71205843 f9f772f8  .....F@.q XC..r.
 0fbd0 a769e378 ed1b8542 07eb0006 07d30133  .i.x...B.......3
 0fbe0 dbb2282b 374608bf 25232d1a f3e7e370  ..(+7F..%#-....p
 0fbf0 a28ae38a a7619a42 07d040f2 71205843  .....a.B..@.q XC
 0fc00 f9f758f8 854202d2 c6190125 00e00025  ..X..B.....%...%
 0fc10 f9f786fe 0746fbf7 6bfa0428 07d8dfe8  .....F..k..(....
 0fc20 00f00d12 03031200 01f0f8fa 06e00022  ..............."
 0fc30 0a4840f2 2e311346 faf74af8 1db12046  .H@..1.F..J... F
 0fc40 e178fff7 e5fe3846 f9f770fe 04f12c00  .x....8F..p...,.
 0fc50 3146bde8 f840f9f7 53b800bf e3f20100  1F...@..S.......
 0fc60 10b50d4b 5c78012c 13d110b1 821f5442  ...K\x.,......TB
 0fc70 54419b79 53b10428 04d10b7e 43f00803  TA.yS..(...~C...
 0fc80 0b7603e0 04480021 fff782fe fbf74ef9  .v...H.!......N.
 0fc90 00e00024 204610bd 50370020 2de9f74f  ...$ F..P7. -..O
 0fca0 074660b9 72488379 13b13946 fff770fe  .F`.rH.y..9F..p.
 0fcb0 01f0b4fa 4ff00008 01f0fcfb d3e00029  ....O..........)
 0fcc0 00f0ce80 04686a4d 14f8023b c3f38016  .....hjM...;....
 0fcd0 03f00f03 062b05d8 dfe803f0 08131304  .....+..........
 0fce0 04040800 4ff0000b d8460ee0 95f80180  ....O....F......
 0fcf0 08f1ff31 d1f10008 48eb0108 4ff0010b  ...1....H...O...
 0fd00 03e04ff0 010b4ff0 00082b79 204613f0  ..O...O...+y F..
 0fd10 010f3146 08bf4ff0 000bfbf7 9bf8e0b1  ..1F..O.........
 0fd20 fff7cafd c8b101f0 69f80028 0ddb3b7e  ........i..(..;~
 0fd30 504a43f0 04033b76 282303fb 002303f1  PJC...;v(#...#..
 0fd40 020a93f8 01900122 0ce0bbf1 000f40f0  ......."......@.
 0fd50 8780a246 b1465a46 04e00246 a246b146  ...F.FZF...F.F.F
 0fd60 4ff0ff30 6872bbf1 000f07d1 3b7e43f0  O..0hr......;~C.
 0fd70 40033b76 b8f1000f 09d171e0 50464946  @.;v......q.PFIF
 0fd80 00f08afe 0028f1d1 4ff0ff38 6be05046  .....(..O..8k.PF
 0fd90 4946fff7 dbfd8046 0028f5d1 ab79344a  IF.....F.(...y4J
 0fda0 23b13548 40f2ed31 424613e0 538a013b  #.5H@..1BF..S..;
 0fdb0 9bb25382 002b53d1 d5f81ca0 002e0cbf  ..S..+S.........
 0fdc0 4ff00309 4ff08309 baf1000f 05d12a48  O...O.........*H
 0fdd0 97215246 1346f9f7 7bff9378 da0746bf  .!RF.F..{..x..F.
 0fde0 49f04009 254f264f 012b1cd9 20463146  I.@.%O&O.+.. F1F
 0fdf0 fbf730f8 40b195f9 0930002b 13db1d4a  ..0.@....0.+...J
 0fe00 282000fb 032007e0 fff756fd 58b12046  ( ... ....V.X. F
 0fe10 3146fff7 05fc30b1 01216a46 fff7c2fc  1F....0..!jF....
 0fe20 49f04009 6f465046 0c214a46 fbf778f9  I.@.oFPF.!JF..x.
 0fe30 daf80030 3a681a60 ba889a80 2268c3f8  ...0:h.`...."h..
 0fe40 0620a288 5a81e869 022101f0 8dfb0123  . ..Z..i.!.....#
 0fe50 ab710446 38b10020 fbf744f9 a04602e0  .q.F8.. ..D..F..
 0fe60 4ff0ff34 f7e74046 03b0bde8 f08f00bf  O..4..@F........
 0fe70 50370020 24360020 e3f20100 10280020  P7. $6. .....(. 
 0fe80 d8000020 f8b51a4d 2b787bb3 f9f748fd  ... ...M+x{...H.
 0fe90 0746fbf7 2df9f8b9 f9f750f8 ab8a0646  .F..-.....P....F
 0fea0 40f27120 5843f8f7 05ffab69 ec78f61a  @.q XC.....i.x..
 0feb0 864206d3 0134e4b2 282c08bf 2524361a  .B...4..(,..%$6.
 0fec0 f6e7eb8a aa8a9a42 0bd040f2 71205843  .......B..@.q XC
 0fed0 f8f7f0fe 864204d3 3846bde8 f840f9f7  .....B..8F...@..
 0fee0 25bd0348 2146fff7 93fdf5e7 f8bd00bf  %..H!F..........
 0fef0 50370020 08b501f0 91f90548 837913b1  P7. .......H.y..
 0ff00 0021fff7 45fdbde8 084001f0 d3ba00bf  .!..E....@......
 0ff10 50370020 2de9f04f 13789b4f 85b09346  P7. -..O.x.O...F
 0ff20 03f00802 d2b213f0 800f0446 88460092  ...........F.F..
 0ff30 17d00328 15d00528 13d03a79 032a05d8  ...(...(..:y.*..
 0ff40 dfe802f0 1c0b020b 012618e0 00228f48  .........&...".H
 0ff50 40f20621 1346f9f7 bbfe0428 24d05b06  @..!.F.....($.[.
 0ff60 22d4bb79 2bb1009b 1bb18748 0021fff7  "..y+......H.!..
 0ff70 0ffd05b0 bde8f04f fff784bf 0026012c  .......O.....&.,
 0ff80 12d14046 10f8085b 25f07f05 edb22946  ..@F...[%.....)F
 0ff90 faf7b2ff 40b9002e e3d008f1 02002946  ....@.........)F
 0ffa0 faf758ff 0028dcd0 454697f9 092015f8  ..X..(..EF... ..
 0ffb0 023b002a 03f04003 dbb2c0f2 e2807449  .;.*..@.......tI
 0ffc0 282000fb 0212961c 92f80190 042c39d1  ( ...........,9.
 0ffd0 ba79002a 36d0009a a2b36b4a d169ca7e  .y.*6.....kJ.i.~
 0ffe0 096822f0 7f02d2b2 03b10ab9 d34229d1  .h"..........B).
 0fff0 28460631 0622f8f7 f3ff18bb 654a0192  (F.1."......eJ..
 10000 92f800a0 baf1080f 18d03046 4946fff7  ..........0FIF..
 10010 9dfc019a 90b9604b 306803eb ca01c1f8  ......`K0h......
 10020 0200b088 c880b9f1 000f01d1 022100e0  .............!..
 10030 032123f8 3a100af1 01031370 52480121  .!#.:......pRH.!
 10040 fff7a6fc 7b7933b1 20464946 3246fff7  ....{y3. FIF2F..
 10050 4dfd0028 85d1012c 12d1bb78 012b25d9  M..(...,...x.+%.
 10060 98f80d30 13f0400f 08f10801 4ff01203  ...0..@.....O...
 10070 4ff00006 0cbf4ff0 020a4ff0 0b0a1ae0  O.....O...O.....
 10080 34b1062c 06d0022c 0cbf0322 042202e0  4..,...,..."."..
 10090 224600e0 022298f8 013003f0 3f039e1f  "F..."...0..?...
 100a0 f6b20633 00214ff0 020a05e0 00261223  ...3.!O......&.#
 100b0 31464ff0 020a2246 50460392 02930191  1FO..."FPF......
 100c0 fef76cfd 00283ff4 4caf3448 faf794f9  ..l..(?.L.4H....
 100d0 04460028 3ff445af 029b6370 039a84f8  .F.(?.E...cp....
 100e0 02a00123 3e20e370 20702271 9bf80020  ...#> .p p"q... 
 100f0 019919f1 000318bf 012312f0 040f08d0  .........#......
 10100 97f90920 22482825 05fb0205 02330235  ... "H(%.....3.5
 10110 dbb251b1 01226271 a01d3246 0193f8f7  ..Q.."bq..2F....
 10120 6dff04f1 0c0c019b 13e004f1 050c3246  m.............2F
 10130 267304f1 0d0008f1 08010293 cdf804c0  &s..............
 10140 f8f75cff ddf804c0 9bf80320 029b6644  ..\........ ..fD
 10150 32726246 204602f8 013b2b68 ccf80130  2rbF F...;+h...0
 10160 ab889380 fef7f8fc 00287ff4 faae7b79  .........(....{y
 10170 002b3ff4 f6ae2846 49465246 fff7c6fc  .+?...(FIFRF....
 10180 efe69946 2e4621e7 50370020 e3f20100  ...F.F!.P7. ....
 10190 24360020 b01e0020 10370020 5c3b0020  $6. ... .7. \;. 
 101a0 2de9f041 174d2c78 06462cbb 10f8018b  -..A.M,x.F,.....
 101b0 0cf06dff 0746f01c 0cf069ff b8f1010f  ..m..F....i.....
 101c0 7279b179 1bd83b1f 9bb243f6 fc76b342  ry.y..;...C..v.B
 101d0 15d8031f 9bb2b342 11d88742 0fd3032a  .......B...B...*
 101e0 0dd80329 0bd885f8 01802971 aa70e882  ...)......)q.p..
 101f0 af822046 bde8f081 0c20bde8 f0811220  .. F..... ..... 
 10200 bde8f081 50370020 10b54278 0478012a  ....P7. ..Bx.x.*
 10210 17d8012c 15d80c4b 64b11978 21b95a71  ...,...Kd..x!.Zq
 10220 bde81040 fff732bc 5b78022b 14bf0020  ...@..2.[x.+... 
 10230 0c2010bd 187828b1 0120fff7 91fc2046  . ...x(.. .... F
 10240 10bd1220 10bd00bf 50370020 054b1a78  ... ....P7. .K.x
 10250 2ab11879 80f00100 00f00100 70470120  *..y........pG. 
 10260 704700bf 50370020 064b0222 5a700288  pG..P7. .K."Zp..
 10270 9a824288 da820279 1a71027b 9a70fff7  ..B....y.q.{.p..
 10280 05bc00bf 50370020 014b1878 704700bf  ....P7. .K.xpG..
 10290 50370020 00487047 5a370020 014bdb69  P7. .HpGZ7. .K.i
 102a0 18687047 50370020 024b0268 1a608288  .hpGP7. .K.h.`..
 102b0 9a807047 5a370020 014bd869 704700bf  ..pGZ7. .K.ipG..
 102c0 50370020 024b1879 00f00100 704700bf  P7. .K.y....pG..
 102d0 50370020 10b5114c 00214022 2046f8f7  P7. ...L.!@" F..
 102e0 98fe1323 224684f8 213004f1 2c001023  ...#"F..!0..,..#
 102f0 0b49a382 e3826462 f8f7ecfc 4ff48270  .I....db....O..p
 10300 0821f9f7 16fe0246 e06128b9 054840f2  .!.....F.a(..H@.
 10310 cb511346 f9f7dcfc 10bd00bf 50370020  .Q.F........P7. 
 10320 85fa0000 e3f20100 10b50e4b 1a781c46  ...........K.x.F
 10330 12b10020 fff714fc e069f9f7 10fe0024  ... .....i.....$
 10340 094b0a48 1c702146 4022f8f7 62fe084b  .K.H.p!F@"..b..K
 10350 08481c70 21464022 f8f75bfe bde81040  .H.p!F@"..[....@
 10360 fff7b8bf 50370020 b01e0020 10370020  ....P7. ... .7. 
 10370 b11e0020 d0360020 43684a68 10b59c1a  ... .6. ChJh....
 10380 002c06da 8368981a 0028d4bf 00200120  .,...h...(... . 
 10390 10bd8868 181ac00f 10bd0000 10b50378  ...h...........x
 103a0 032b11d1 00234370 4369c168 82690bb1  .+...#CpCi.h.i..
 103b0 9a6101e0 064c6260 826901f1 a4001360  .a...Lb`.i.....`
 103c0 faf79cfe 002010bd 4ff0ff30 10bd00bf  ..... ..O..0....
 103d0 a4370020 70b5214d 2c68002c 3dd0f8f7  .7. p.!M,h.,=...
 103e0 adfd6168 401a0028 32db6369 a2690bb1  ..ah@..(2.ci.i..
 103f0 9a6100e0 6a60a269 00261360 6670faf7  .a..j`.i.&.`fp..
 10400 77fe0546 c8b100f0 09fffaf7 8ffdab1e  w..F............
 10410 dbb2012b 03d83046 faf764fe 0de0012d  ...+..0F..d....-
 10420 0f4b05d1 da6e0132 da66fbf7 59f804e0  .K...n.2.f..Y...
 10430 9a6e0132 9a66fcf7 87fa2269 2ab90948  .n.2.f...."i*..H
 10440 40f28b21 1346f9f7 43fc2046 9047c2e7  @..!.F..C. F.G..
 10450 0548bde8 7040f8f7 53bc70bd a4370020  .H..p@..S.p..7. 
 10460 ac300020 f1f20100 90370020 10b50446  .0. .....7. ...F
 10470 faf73efe 042808d1 fbf774fe 6368c01a  ..>..(....t.ch..
 10480 0028d4bf 00200120 10bd0020 10bd0000  .(... . ... ....
 10490 064a0346 106838b9 19461360 41f8140f  .J.F.h8..F.`A...
 104a0 9a615160 01225a70 704700bf a4370020  .aQ`."ZppG...7. 
 104b0 2de9f047 c379022b 044600f1 e00908bf  -..G.y.+.F......
 104c0 806fe56e 0cbfbe30 be20f8f7 f3fb236d  .o.n...0. ....#m
 104d0 c4f8e830 2d1ac4f8 e450f8f7 2ffd281a  ...0-....P../.(.
 104e0 00286bdb f9f71cfa 82464846 fff7beff  .(k......FHF....
 104f0 064618b1 5046f9f7 19fa5fe0 334f3448  .F..PF...._.3O4H
 10500 f8f75efc 3d68b046 2db34846 2946fff7  ..^.=h.F-.HF)F..
 10510 33ff68b1 2b78012b 54d0d4f8 ec00e968  3.h.+x.+T......h
 10520 fbf71bfe 00284dd0 a84696b9 2e4610e0  .....(M..F...F..
 10530 d4f8e830 6a689b1a 002b0ada ab69c4f8  ...0jh...+...i..
 10540 f8302346 aa6943f8 f45fc2f8 0090ab61  .0#F.iC.._.....a
 10550 0be06d69 d8e77b68 c4f8f830 c4f8f450  ..mi..{h...0...P
 10560 c3f80090 04f1f403 7b600123 84f8e130  ........{`.#...0
 10570 002413e0 33787569 032b03d1 f068a430  .$..3xui.+...h.0
 10580 faf7bcfd 7369b269 5bb19a61 b2694645  ....si.i[..a.iFE
 10590 13604ff0 00037370 05d02e46 002ee9d1  .`O...sp...F....
 105a0 01e07a60 f2e73d68 5046f9f7 bff90848  ..z`..=hPF.....H
 105b0 6968f8f7 a5fb2046 bde8f087 4ff0ff30  ih.... F....O..0
 105c0 bde8f087 4ff0ff34 0026e7e7 a4370020  ....O..4.&...7. 
 105d0 90370020 2de9f74f 0c460546 30b95148  .7. -..O.F.F0.QH
 105e0 4ff48071 2a462b46 f9f772fb 40f2e247  O..q*F+F..r.@..G
 105f0 00f1e008 07fb02f0 f8f75cfb 81464ff4  ..........\..FO.
 10600 db60f8f7 57fb0444 b5f86000 7843f8f7  .`..W..D..`.xC..
 10610 51fb8346 f9f784f9 c5f8e440 0090faf7  Q..F.......@....
 10620 67fd0428 04eb0906 14d13846 f8f742fb  g..(......8F..B.
 10630 0746fbf7 97fd0646 f8f780fc 301a0028  .F.....F....0..(
 10640 01da3e44 f8e7331b 002b01da 3e44fae7  ..>D..3..+..>D..
 10650 34464e44 4046fff7 1bff334f 10b9a5f8  4FND@F....3O....
 10660 6a0045e0 3148f8f7 abfb3b68 a2461bb3  j.E.1H....;h.F..
 10670 c5f8e4a0 5968c5f8 e860711a 00290eda  ....Yh...`q..)..
 10680 c4eb0a01 59453fd8 9969c5f8 f8102946  ....YE?..i....)F
 10690 986941f8 f43fc0f8 00809961 1ae01946  .iA..?.....a...F
 106a0 40460193 fff768fe 019b18b1 d3f808a0  @F....h.........
 106b0 09eb0a06 5b69dae7 c4eb0a01 594523d8  ....[i......YE#.
 106c0 c5f8f430 7b68c5f8 f830c3f8 008005f1  ...0{h...0......
 106d0 f4037b60 012385f8 e13040f2 e240f8f7  ..{`.#...0@..@..
 106e0 e9fac4eb 0a04b4fb f0f05446 a5f86a00  ..........TF..j.
 106f0 c5f8e440 c5f8e860 be20f8f7 dbfa2044  ...@...`. .... D
 10700 e8662e65 002401e0 4ff0ff34 3d680098  .f.e.$..O..4=h..
 10710 f9f70cf9 05486968 f8f7f2fa 204603b0  .....Hih.... F..
 10720 bde8f08f f1f20100 a4370020 90370020  .........7. .7. 
 10730 2de9f041 0546c46e 00f1e006 806fbe30  -..A.F.n.....o.0
 10740 f8f7b8fa 2b6dc5f8 e830201a c5f8e400  ....+m...0 .....
 10750 f9f7e6f8 80463046 fff788fe 28b14046  .....F0F....(.@F
 10760 f9f7e4f8 4ff0ff34 42e03046 fff790fe  ....O..4B.0F....
 10770 04460028 2fd02048 f8f722fb d5f8e830  .F.(/. H.."....0
 10780 62686769 9b1a002b 09daa369 c5f8f830  bhgi...+...i...0
 10790 2b46a269 43f8f44f 1660a361 23e03046  +F.iC..O.`.a#.0F
 107a0 2146fff7 e9fd68b9 3c46002f e6d1134b  !F....h.<F./...K
 107b0 c5f8f470 5a68c5f8 f8201660 05f1f402  ...pZh... .`....
 107c0 5a6010e0 2046fff7 e9fd0028 ecd04ff0  Z`.. F.....(..O.
 107d0 ff340a4b 1e684046 f9f7a8f8 06487168  .4.K.h@F.....Hqh
 107e0 f8f78efa 04e00123 85f8e130 0024f0e7  .......#...0.$..
 107f0 2046bde8 f08100bf 90370020 a4370020   F.......7. .7. 
 10800 2de9f041 43688768 0446ff1a f9f788f8  -..ACh.h.F......
 10810 8046faf7 6dfc0428 0ed141f2 8830f8f7  .F..m..(..A..0..
 10820 49fa0546 fbf79efc 6368c31a ab42b8bf  I..F....ch...B..
 10830 40196060 3844a060 2046fff7 29fe08b9  @.``8D.` F..)...
 10840 606829e0 1a4e1b48 f8f7bafa 3568c5b1  `h)..N.H....5h..
 10850 a3686a68 9b1a002b 08daab69 a361ab69  .hjh...+...i.a.i
 10860 65611c60 04f11403 ab6111e0 20462946  ea.`.....a.. F)F
 10870 fff782fd 18b1ab68 63603b44 a3606d69  .......hc`;D.`mi
 10880 e5e77368 a3616561 1c6004f1 14037360  ..sh.aea.`....s`
 10890 01236370 60683468 faf79efe 4046f9f7  .#cp`h4h....@F..
 108a0 45f80448 6168f8f7 2bfa0020 bde8f081  E..Hah..+.. ....
 108b0 a4370020 90370020 2de9f041 0446f9f7  .7. .7. -..A.F..
 108c0 2ff88046 2046fff7 d1fd0646 28b14046  /..F F.....F(.@F
 108d0 f9f72cf8 4ff0ff36 3de02046 fff7d8fd  ..,.O..6=. F....
 108e0 05460028 30d01d48 f8f76afa a3686a68  .F.(0..H..j..hjh
 108f0 6f699b1a 002b08da ab69a361 ab696561  oi...+...i.a.iea
 10900 1c6004f1 1403ab61 1ae02046 2946fff7  .`.....a.. F)F..
 10910 33fd50b1 2846fff7 41fd30b1 00221048  3.P.(F..A.0..".H
 10920 40f22521 1346f9f7 d3f93d46 002fddd1  @.%!.F....=F./..
 10930 0c4b6761 5a68a261 146004f1 14025a60  .KgaZh.a.`....Z`
 10940 01236370 074b1c68 4046f8f7 efff0348  .#cp.K.h@F.....H
 10950 6168f8f7 d5f93046 bde8f081 90370020  ah....0F.....7. 
 10960 f1f20100 a4370020 f8b50446 18b3f8f7  .....7. ...F....
 10970 d7ff6378 0746cbb1 0f4d2e68 a64202d1  ..cx.F...M.h.B..
 10980 0e48f8f7 1dfa6369 a2690bb1 9a6100e0  .H....ci.i...a..
 10990 6a60a269 a6421360 4ff00003 637005d1  j`.i.B.`O...cp..
 109a0 2b681bb1 05485968 f8f7aaf9 3846bde8  +h...HYh....8F..
 109b0 f840f8f7 bbbff8bd a4370020 90370020  .@.......7. .7. 
 109c0 10b50446 f8f7acff 054b1b68 1bb15b68  ...F.....K.h..[h
 109d0 23600124 00e01c46 f8f7a8ff 204610bd  #`.$...F.... F..
 109e0 a4370020 0148f8f7 ebb900bf 90370020  .7. .H.......7. 
 109f0 08b50348 03490022 f8f76cf9 002008bd  ...H.I."..l.. ..
 10a00 90370020 d5030100 f8b50d4d 06460f46  .7. .......M.F.F
 10a10 002015f8 023c441c 5bb115f8 013cbb42  . ...<D.[....<.B
 10a20 07d12846 31460622 f8f7dafa 08b92046  ..(F1F."...... F
 10a30 f8bd082c 204605f1 0805ead1 0020f8bd  ..., F....... ..
 10a40 ae370020 08b5fbf7 55f820b1 fff7fefb  .7. ....U. .....
 10a50 003018bf 012008bd 10b5fff7 f3ff88b1  .0... ..........
 10a60 094b0024 1c701c72 1c741c76 83f82040  .K.$.p.r.t.v.. @
 10a70 83f82840 83f83040 83f83840 00f074f8  ..(@..0@..8@..t.
 10a80 204610bd 0c2010bd ac370020 08230370   F... ...7. .#.p
 10a90 01230b70 00207047 0ab1fff7 b5bf00f0  .#.p. pG........
 10aa0 01b90000 38b50446 0d46fff7 cbffd8b1  ....8..F.F......
 10ab0 20462946 fff7a8ff c0b90d4a 8318825c   F)F.......J...\
 10ac0 6ab92268 c3f80220 a288da80 01225d70  j."h... ....."]p
 10ad0 1a702046 2946bde8 384000f0 51b80830  .p F)F..8@..Q..0
 10ae0 4028ead1 072038bd 0c2038bd 002038bd  @(... 8.. 8.. 8.
 10af0 ac370020 38b50546 0c46fff7 a3ff78b1  .7. 8..F.F....x.
 10b00 28462146 fff780ff 20b10138 054b0022  (F!F.... ..8.K."
 10b10 03f83020 28462146 00f068f8 002038bd  ..0 (F!F..h.. 8.
 10b20 0c2038bd ac370020 00f0a4b8 00f0b0b8  . 8..7. ........
 10b30 0b4b1a68 0b4b3ab9 0121c3f8 0813c3f8  .K.h.K:..!......
 10b40 0021d3f8 00327047 d3f80011 31b10021  .!...2pG....1..!
 10b50 c3f80011 d3f80805 c0b21047 704700bf  ...........GpG..
 10b60 30380020 00d00040 034a0023 c2f84036  08. ...@.J.#..@6
 10b70 024a1370 704700bf 00100040 b21e0020  .J.ppG.....@... 
 10b80 2de9f041 174e3378 07468846 01250024  -..A.N3x.F.F.%.$
 10b90 1d421fd1 3846a400 0cf07efa 04f18044  .B..8F....~....D
 10ba0 04f58054 c4f80006 381d0cf0 70fab8f1  ...T....8...p...
 10bb0 010f08bf 0c4ac4f8 200602bf d2f84036  .....J.. .....@6
 10bc0 43ea0523 c2f84036 33781d43 35700020  C..#..@63x.C5p. 
 10bd0 bde8f081 0134082c 4fea4505 d8d10720  .....4.,O.E.... 
 10be0 bde8f081 b21e0020 00100040 2de9f843  ....... ...@-..C
 10bf0 04468946 0cf050fa 8046201d 0cf047fa  .F.F..P..F ...G.
 10c00 1a4b1b4c d3f84036 26784fea 132e0122  .K.L..@6&xO...."
 10c10 00272546 324215d0 bb0003f1 804303f5  .'%F2B.......C..
 10c20 8053d3f8 00168845 0cd1d3f8 20369842  .S.....E.... 6.B
 10c30 08d1d3b2 b9f1010f 03ea0e04 01d10cb1  ................
 10c40 07e034b1 0137082f 4fea4202 e2d1bde8  ..4..7./O.B.....
 10c50 f88326ea 03030549 2b70d1f8 403623ea  ..&....I+p..@6#.
 10c60 0202c1f8 4026bde8 f88300bf 00100040  ....@&.........@
 10c70 b21e0020 044a0549 d2f84036 09780b43  ... .J.I..@6.x.C
 10c80 c2f84036 704700bf 00100040 b21e0020  ..@6pG.....@... 
 10c90 034ad2f8 403603f4 7f43c2f8 40367047  .J..@6...C..@6pG
 10ca0 00100040 014bd3f8 14017047 00100040  ...@.K....pG...@
 10cb0 0c4b0122 00215a60 c3f80011 c3f80411  .K.".!Z`........
 10cc0 c3f80405 1a60d3f8 0021d3f8 040122b9  .....`...!....".
 10cd0 0028f8d0 4ff0ff30 70470030 18bf0120  .(..O..0pG.0... 
 10ce0 40427047 00e00040 38b50446 0b4b19b1  @BpG...@8..F.K..
 10cf0 0122c3f8 042501e0 c3f80415 64b1084d  ."...%......d..M
 10d00 0849e023 85f80d33 0d20f8f7 09fc4ff4  .I.#...3. ....O.
 10d10 00532b60 044b1c60 002038bd 00d00040  .S+`.K.`. 8....@
 10d20 00e100e0 310b0100 30380020 08b5f8f7  ....1...08. ....
 10d30 f7fd084b 1a6842b9 c3f80021 064a1168  ...K.hB....!.J.h
 10d40 012209b1 c3f80423 1a60f8f7 effd0020  .".....#.`..... 
 10d50 08bd00bf 00d00040 30380020 10b5f8f7  .......@08. ....
 10d60 dffd064b 01220024 c3f80823 5a60c3f8  ...K.".$...#Z`..
 10d70 0041f8f7 dbfd2046 10bd00bf 00d00040  .A.... F.......@
 10d80 014b0022 1a707047 ec370020 f0b50c4b  .K.".ppG.7. ...K
 10d90 1a78042a 1d4611d0 0a4c0346 04eb0214  .x.*.F...L.F....
 10da0 00f11007 18685968 264603c6 0833bb42  .....hYh&F...3.B
 10db0 3446f7d1 01322a70 0020f0bd 0720f0bd  4F...2*p. ... ..
 10dc0 ec370020 f0370020 09490b78 98420246  .7. .7. .I.x.B.F
 10dd0 0cda013b dbb28342 0b7007dd 054800eb  ...;...B.p...H..
 10de0 820000f1 10019a1a 0cf074be 704700bf  ..........t.pG..
 10df0 ec370020 f0370020 10207047 064bd3f8  .7. .7. . pG.K..
 10e00 00212ab1 d3f80421 12b1d3f8 00047047  .!*....!......pG
 10e10 4ff0ff30 704700bf 00f00040 064bd3f8  O..0pG.....@.K..
 10e20 50253ab1 22f00801 042903d1 d3f85015  P%:."....)....P.
 10e30 9142fae7 704700bf 00100040 314b324a  .B..pG.....@1K2J
 10e40 9979f9b1 3149c2f8 041502f5 6042c2f8  .y..1I......`B..
 10e50 0c155969 0968c2f8 10152d49 c2f81415  ..Yi.h....-I....
 10e60 2c49c2f8 04152c49 c2f80815 0021c2f8  ,I....,I.....!..
 10e70 0012c2f8 0811c2f8 04114ff0 407102f5  ..........O.@q..
 10e80 803201e0 59690968 c2f80415 da791d49  .2..Yi.h.....y.I
 10e90 aab1224a 0320c2f8 00052148 c2f80805  .."J. ....!H....
 10ea0 48690c31 0068c2f8 1005c2f8 14150021  Hi.1.h.........!
 10eb0 c2f80011 c2f80411 c2f80811 04e08a79  ...............y
 10ec0 12b91649 c1f80025 164a4ff4 1001c2f8  ...I...%.JO.....
 10ed0 08150022 01215a71 d9700b4b 0821c3f8  ...".!Zq.p.K.!..
 10ee0 6015c3f8 0421c3f8 1421c3f8 2821c3f8  `....!...!..(!..
 10ef0 1c2140f2 5712c3f8 00220222 c3f80423  .!@.W...."."...#
 10f00 704700bf 34380020 00100040 b41e0020  pG..48. ...@... 
 10f10 54380020 01000001 a4390020 00f00040  T8. .....9. ...@
 10f20 f0370020 00f00140 08b54ff4 82700821  .7. ...@..O..p.!
 10f30 f8f7ffff 20b9054a 536b0133 536308bd  .... ..JSk.3Sc..
 10f40 03680233 0360024b 586108bd 60390020  .h.3.`.KXa..`9. 
 10f50 34380020 4ff08043 00222de9 f341c3f8  48. O..C."-..A..
 10f60 00210122 1a60f9f7 2bfc00f1 23044ff0  .!.".`..+...#.O.
 10f70 8043d3f8 003133b9 f9f722fc 001b0028  .C...13..."....(
 10f80 f5dd0220 68e0364e 364d3748 2823b370  ... h.6N6M7H(#.p
 10f90 364b0024 012743f2 ff42c3f8 fc4fc3f8  6K.$.'C..B...O..
 10fa0 fc7fc3f8 08230322 c3f81025 304ac3f8  .....#."...%0J..
 10fb0 1425304a c3f81825 2f4ac3f8 1c258e22  .%0J...%/J...%."
 10fc0 c3f82425 40f20312 c3f83425 2b4ac3f8  ..$%@.....4%+J..
 10fd0 38259622 c3f84425 03f5f033 4ff08062  8%."..D%...3O..b
 10fe0 4ff0ff38 c3f80425 2146c5f8 08834ff4  O..8...%!F....O.
 10ff0 8672c5f8 0072c5f8 0841f8f7 0af8204b  .r...r...A.... K
 11000 f460c5f8 0835c5f8 0883c5f8 0041c5f8  .`...5.......A..
 11010 0441c5f8 0841c5f8 04451a4d 1a4985f8  .A...A...E.M.I..
 11020 01433846 f8f77cfa 02232b60 357895b9  .C8F..|..#+`5x..
 11030 164b0193 00951648 04210e22 2b460cf0  .K.....H.!."+F..
 11040 85f930b1 134840f2 83212a46 2b46f8f7  ..0..H@..!*F+F..
 11050 3ffe3770 00e02046 02b0bde8 f08100bf  ?.7p.. F........
 11060 34380020 00f00040 54380020 00100040  48. ...@T8. ...@
 11070 08011000 ff000302 00d6be89 5b060001  ............[...
 11080 f0370020 00e100e0 59120100 24f30100  .7. ....Y...$...
 11090 60390020 2cf30100 f0b5104d 03f11006  `9. ,......M....
 110a0 2c4653f8 047b45f8 047bb342 f9d12061  ,FS..{E..{.B.. a
 110b0 61611368 c4f81930 5368094a 53609df8  aa.h...0Sh.JS`..
 110c0 14302376 074b0122 9a71074b 0022c3f8  .0#v.K.".q.K."..
 110d0 00250222 c3f80025 f0bd00bf a4390020  .%."...%.....9. 
 110e0 bd390020 34380020 00f00040 024b1861  .9. 48. ...@.K.a
 110f0 59611a76 704700bf a4390020 074b4ff0  Ya.vpG...9. .KO.
 11100 4072c3f8 0825064a 01239360 0023c2f8  @r...%.J.#.`.#..
 11110 0831c2f8 0035034a 93717047 00f00140  .1...5.J.qpG...@
 11120 00f00040 34380020 014bd861 99617047  ...@48. .K.a.apG
 11130 34380020 0a2808b5 06dd0022 0a4840f2  48. .(.....".H@.
 11140 99311346 f8f7c4fd 6ff02703 9842b8bf  .1.F....o.'..B..
 11150 18460428 054ba8bf 0420c3f8 0c05044b  .F.(.K... .....K
 11160 58700020 08bd00bf 2cf30100 00100040  Xp. ....,......@
 11170 34380020 2728f8b5 06d90022 224840f2  48. '(.....""H@.
 11180 cb311346 f8f7a4fd 2428204e 204d1fd8  .1.F....$( N M..
 11190 3161d5f8 24450a28 4fea1167 24f47f44  1a..$E.(O..g$..D
 111a0 4fea0121 c5f82015 98bf831c 4ff00101  O..!.. .....O...
 111b0 88bfc31c 44ea0724 c5f82445 5b00c5f8  ....D..$..$E[...
 111c0 2c150221 c5f83015 dbb2c5f8 3c2512e0  ,..!..0.....<%..
 111d0 252804d0 26280cbf 1a235023 00e00223  %(..&(...#P#...#
 111e0 0022c5f8 2c250122 c5f83025 094ac5f8  ."..,%."..0%.J..
 111f0 3c25094a 3261064a b070c2f8 0835c2f8  <%.J2a.J.p...5..
 11200 54050020 f8bd00bf 2cf30100 34380020  T.. ....,...48. 
 11210 00100040 55555500 d6be898e 0b4b43f2  ...@UUU......KC.
 11220 ff42c3f8 08230121 0022c3f8 00221961  .B...#.!."...".a
 11230 03f5f033 4ff43001 c3f80815 044b0221  ...3O.0......K.!
 11240 c3f88011 034bda70 704700bf 00100040  .....K.ppG.....@
 11250 00e100e0 34380020 2de9f843 8e4bd3f8  ....48. -..C.K..
 11260 0863f206 57d5d3f8 1021002a 53d08b4d  .c..W....!.*S..M
 11270 ea78022a 03d08a48 4ff49e71 42e00022  .x.*...HO..qB.."
 11280 1021c3f8 1021c3f8 0813c3f8 0c21d3f8  .!...!.......!..
 11290 0032ab79 4bb18349 d1f80831 2bb18248  .2.yK..I...1+..H
 112a0 036c0133 0364c1f8 08212b79 022b20d1  .l.3.d...!+y.+ .
 112b0 7a4b5b69 13b1fff7 c1fd05e0 7a4a536b  zK[i........zJSk
 112c0 01335363 fff7aaff 2c7a24b1 734b9b79  .3Sc....,z$.sK.y
 112d0 0bb10434 e4b2754b de20d3f8 4475f7f7  ...4..uK. ..Du..
 112e0 e9fc283f 38440a34 00ebc400 f9f718fe  ..(?8D.4........
 112f0 0ce06f4a 4ff48011 c2f80815 33b16848  ..oJO.......3.hH
 11300 40f26f11 00221346 f8f7e2fc eb6913b1  @.o..".F.....i..
 11310 624a9069 9847b307 53d55f4b d3f80421  bJ.i.G..S._K...!
 11320 002a4ed0 5d4f0022 7d69c3f8 04210222  .*N.]O."}i...!."
 11330 c3f80823 25b95a48 40f2d311 2a46e2e7  ...#%.ZH@...*F..
 11340 554cd4f8 5035d4f8 282142b9 002bf7d1  UL..P5..(!B..+..
 11350 43f2ff42 c4f80823 c4f80032 31e0f9f7  C..B...#...21...
 11360 c7fe4ff0 0008b978 504b2876 697685f8  ..O....xPK(viv..
 11370 1a80d3f8 44357869 dff82091 283beb61  ....D5xi.. .(;.a
 11380 f9f704fe 4045484d 13db0123 89f80530  ....@EHM...#...0
 11390 0823c4f8 043399f8 07307bb1 444bc4f8  .#...3...0{.DK..
 113a0 28814ff4 0002c3f8 04254023 c4f86035  (.O......%@#..`5
 113b0 04e0fff7 33ff6b6a 01336b62 2b6a0133  ....3.kj.3kb+j.3
 113c0 2b6216f0 080f384c 5ed0334b d3f80c21  +b....8L^.3K...!
 113d0 002a59d0 0022c3f8 0c210822 c3f80823  .*Y.."...!."...#
 113e0 334a2e4d 4ff40011 c2f80815 6869d3f8  3J.MO.......hi..
 113f0 1c2100f1 18011ab9 29484ff4 c57182e7  .!......)HO..q..
 11400 d3f84825 5242c276 d3f80034 026813f0  ..H%RB.v...4.h..
 11410 ff0f03d1 e36a0133 e36226e0 a36a0133  .....j.3.b&..j.3
 11420 a362037e 63f07f06 0676ae79 eeb15778  .b.~c....v.y..Wx
 11430 1c4e2fb1 d6f80074 17b963f0 5f030376  .N/....t..c._..v
 11440 d6f80831 33b1e36b 0133e363 037e03f0  ...13..k.3.c.~..
 11450 7f030376 134bd3f8 043133b9 e36b0133  ...v.K...13..k.3
 11460 e363037e 03f07f03 03760023 6b615378  .c.~.....v.#kaSx
 11470 93701378 53700368 01330360 f9f7ccfd  .p.xSp.h.3.`....
 11480 002801da fff7cafe 034bd3f8 0032e368  .(.......K...2.h
 11490 0133e360 bde8f883 00100040 34380020  .3.`.......@48. 
 114a0 2cf30100 00f00040 60390020 00800040  ,......@`9. ...@
 114b0 00f00140 38b5174c fff7b0fc d4f85035  ...@8..L......P5
 114c0 3bb1fff7 abfe144a 936b0133 93630120  ;......J.k.3.c. 
 114d0 38bd124b 5b6993b1 43f2ff43 0025c4f8  8..K[i..C..C.%..
 114e0 0833c4f8 0c51c4f8 1051fff7 a7fc0c4b  .3...Q...Q.....K
 114f0 d3f80035 13f40013 07d02846 38bdfff7  ...5......(F8...
 11500 13fd0028 e8d10420 38bd024a 01215160  ...(... 8..J.!Q`
 11510 184638bd 00100040 60390020 34380020  .F8....@`9. 48. 
 11520 00f00140 0e4b10b5 c3f84005 03f5b833  ...@.K....@....3
 11530 4ff48012 c3f80425 4ff40012 c3f80825  O......%O......%
 11540 0446f7f7 fbfc001b 002807db 054a9369  .F.......(...J.i
 11550 01339361 fff762fe 052010bd 002010bd  .3.a..b.. ... ..
 11560 00800040 60390020 2de9f041 88460746  ...@`9. -..A.F.F
 11570 30b93c48 40f23231 3a463b46 f8f7a8fb  0.<H@.21:F;F....
 11580 394dfff7 4bfcab79 be7e3849 3848e3b1  9M..K..y.~8I8H..
 11590 0123c1f8 0032374c 374bc1f8 0c45c1f8  .#...27L7K...E..
 115a0 1005c1f8 14350023 c1f80831 4ff08072  .....5.#...1O..r
 115b0 324bc1f8 0425c1f8 0835314b 4ff02071  2K...%...51KO. q
 115c0 c3f80815 c3f80425 08e02d4b 4ff40002  .......%..-KO...
 115d0 c3f80825 2b4bc1f8 08350446 fb7e2370  ...%+K...5.F.~#p
 115e0 294b6670 0022b8f1 020fa270 c3f80405  )Kfp.".....p....
 115f0 c3f80021 c3f80c21 c3f81021 01d00322  ...!...!...!..."
 11600 06e06b69 1bb9fff7 8ffc0028 f7d00b22  ..ki.......(..."
 11610 1d4b1021 c3f80413 c3f80022 2e7285f8  .K.!.......".r..
 11620 0480d3f8 5035194d 0b2b12d0 3246e31c  ....P5.M.+..2F..
 11630 3846797e f8f71cfd 0b4b0222 da702b69  8Fy~.....K.".p+i
 11640 01332b61 eb691344 1e44ee61 0020bde8  .3+a.i.D.D.a. ..
 11650 f081fff7 e3fdab69 0133ab61 0120bde8  .......i.3.a. ..
 11660 f08100bf 2cf30100 34380020 00f00040  ....,...48. ...@
 11670 b81f0020 b41e0020 54380020 a4390020  ... ... T8. .9. 
 11680 00f00140 f0370020 00100040 60390020  ...@.7. ...@`9. 
 11690 014b1869 704700bf 34380020 014b5879  .K.ipG..48. .KXy
 116a0 704700bf 34380020 fb207047 044b1a78  pG..48. . pG.K.x
 116b0 044bc3f8 0425044b 0122da71 704700bf  .K...%.K.".qpG..
 116c0 ec370020 00f00040 34380020 014b0022  .7. ...@48. .K."
 116d0 da717047 34380020 30b587b0 0c4601a9  .qpG48. 0....F..
 116e0 054603f0 19fe9df8 043084f8 2730029b  .F.......0..'0..
 116f0 1a68c4f8 16209b88 63839df8 053084f8  .h... ..c....0..
 11700 2630039b 1a682261 9b88a382 9df80630  &0...h"a.......0
 11710 84f82430 049b1a68 62609b88 23819df8  ..$0...hb`..#...
 11720 073084f8 2530059b 1a68c4f8 0a209b88  .0..%0...h... ..
 11730 e381ab88 a3836b8b e383ab8b 2384eb8b  ......k.....#...
 11740 638495f8 203084f8 29306b6c 236095f8  c... 0..)0kl#`..
 11750 2130db07 4cbf0023 012384f8 283007b0  !0..L..#.#..(0..
 11760 30bd07b5 032101a8 08f010f8 01a802f0  0....!..........
 11770 5bff03b0 5df804fb 07b50030 18bf0120  [...]......0... 
 11780 003118bf 01216a46 052307f0 dfff6846  .1...!jF.#....hF
 11790 02f04aff 03b05df8 04fb07b5 003018bf  ..J...]......0..
 117a0 012001a9 042207f0 c5ff01a8 02f03cff  . ..."........<.
 117b0 03b05df8 04fbf8b5 0c460546 02f0c2ff  ..]......F.F....
 117c0 204603f0 67fd0446 10b1866c c76c01e0   F..g..F...l.l..
 117d0 07460646 02f0beff 0cb90720 f8bd26b1  .F.F....... ..&.
 117e0 28463946 b04768b9 0ae02b78 042b07d1  (F9F.Gh...+x.+..
 117f0 6968aa68 0b681360 4b685360 8b689360  ih.h.h.`KhS`.h.`
 11800 0020f8bd f8bd0000 10b5084b 1a784ab1  . .........K.xJ.
 11810 5a78d207 06d55c68 f8f7d2ff 201a20ea  Zx....\h.... . .
 11820 e07010bd 6ff00040 10bd00bf 940d0020  .p..o..@....... 
 11830 10b5084b 1a7d4ab1 5a7dd207 06d59c69  ...K.}J.Z}.....i
 11840 f8f7beff 201a20ea e07010bd 6ff00040  .... . ..p..o..@
 11850 10bd00bf 940d0020 10b5fff7 d5ff0446  ....... .......F
 11860 fff7e6ff a042a8bf 2046bde8 104002f0  .....B.. F...@..
 11870 cbbf0000 70b58eb0 02f064ff 0c4b5a7d  ....p.....d..KZ}
 11880 1d6a5e6a 002464f3 00021c75 5a7502f0  .j^j.$d....uZu..
 11890 61ff55b1 214601a8 3422f7f7 bafb0923  a.U.!F..4".....#
 118a0 8df80430 01a83146 a8470eb0 70bd00bf  ...0..1F.G..p...
 118b0 940d0020 2de9f041 114c2378 022b8eb0  ... -..A.L#x.+..
 118c0 07461ad1 0f4a136c 01331364 02f03aff  .F...J.l.3.d..:.
 118d0 6378a668 d4f80c80 002565f3 00032570  cx.h.....%e...%p
 118e0 637002f0 37ff46b1 294601a8 3422f7f7  cp..7.F.)F..4"..
 118f0 90fb0297 01a84146 b0470eb0 bde8f081  ......AF.G......
 11900 940d0020 c8390020 2de9f041 8eb03422  ... .9. -..A..4"
 11910 04460f46 01a80021 f7f77bfb 02f012ff  .F.F...!..{.....
 11920 204603f0 b7fc0546 28b103a9 fff7d4fe   F.....F(.......
 11930 ae6cd5f8 4c8002f0 0dffbdb1 204605f0  .l..L....... F..
 11940 dbfd2046 02f0befa 204601f0 21ff2046  .. F.... F..!. F
 11950 03f08ffb 01238df8 04300297 16b101a8  .....#...0......
 11960 4146b047 034a536e 01335366 0eb0bde8  AF.G.JSn.3Sf....
 11970 f08100bf c8390020 38b50546 0c4602f0  .....9. 8..F.F..
 11980 e1fe2846 03f086fc 054618b1 14b12146  ..(F.....F....!F
 11990 fff7a2fe 02f0defe 002d0cbf 07200020  .........-... . 
 119a0 38bd0000 114a30b5 936e0133 93668478  8....J0..n.3.f.x
 119b0 8fb00546 3cb9e978 008809b1 01f50071  ...F<..x.......q
 119c0 fff7a2ff 10e00021 01a83422 f7f721fb  .......!..4"..!.
 119d0 04f50074 06232988 8df80430 01a8adf8  ...t.#)....0....
 119e0 0c100294 fff7e7fe 0fb030bd c8390020  ..........0..9. 
 119f0 10b5184a d36e8eb0 01330446 d3660021  ...J.n...3.F.f.!
 11a00 342201a8 f7f705fb 02f09cfe 608803f0  4"..........`...
 11a10 41fc38b1 63782bb9 a3884383 e3888383  A.8.cx+...C.....
 11a20 2389c383 90f82130 23f00203 80f82130  #.....!0#.....!0
 11a30 02f090fe 03238df8 04306378 6188adf8  .....#...0cxa...
 11a40 0c100bb1 03f50073 01a80293 fff7b3fe  .......s........
 11a50 0eb010bd c8390020 f0b51a4a 1a4d136f  .....9. ...J.M.o
 11a60 01331367 2b78012b a9b00446 27d10dae  .3.g+x.+...F'...
 11a70 3046e168 a27803f0 e3f900bb 2b7cda07  0F.h.x......+|..
 11a80 03d59df8 3430db07 19d52661 02f05afe  ....40....&a..Z.
 11a90 ae68ef68 02f05efe 8eb10021 34226846  .h.h..^....!4"hF
 11aa0 f7f7b7fa 07238df8 00300fcc 01ad0fc5  .....#...0......
 11ab0 94e80700 85e80700 68463946 b04729b0  ........hF9F.G).
 11ac0 f0bd00bf c8390020 940d0020 2de9f041  .....9. ... -..A
 11ad0 dff8b881 d8f87430 06460133 8eb04088  ......t0.F.3..@.
 11ae0 c8f87430 002103f0 d9fa7778 044640b9  ..t0.!....wx.F@.
 11af0 002f00f0 c5807088 07f50071 fff704ff  ./....p....q....
 11b00 bee0614d 7fb33c2f 06d12b7d 012b40f0  ..aM..</..+}.+@.
 11b10 ad80fff7 affea9e0 2c78002c 00f0b080  ........,x.,....
 11b20 022f4ff0 000419d1 02f00cfe 6b78ae68  ./O.........kx.h
 11b30 d5f80c80 2c7064f3 00036b70 02f00afe  ....,pd...kp....
 11b40 002e00f0 93802146 01a83422 f7f761fa  ......!F..4"..a.
 11b50 8df80470 01a84146 b04787e0 07f50070  ...p..AF.G.....p
 11b60 fff7a8fe 8ce03379 13b1012b 04d010e0  ......3y...+....
 11b70 2b78022b 08d07be0 2b7d012b 78d12b7f  +x.+..{.+}.+x.+.
 11b80 013b012b 74d875e0 d8f85c30 0133c8f8  .;.+t.u...\0.3..
 11b90 5c3003f0 35fb7388 83803346 00f10e0e  \0..5.s...3F....
 11ba0 53f8062f 82609b88 83817379 83713246  S../.`....sy.q2F
 11bb0 00f11407 52f8133f c0f80e30 9388aef8  ....R..?...0....
 11bc0 04303346 044653f8 191f4161 9988b980  .03F.FS...Aa....
 11bd0 b1894183 f1898183 318ac183 b17c80f8  ..A.....1....|..
 11be0 20103179 99b9a868 a064e868 e06494f8   .1y...h.d.h.d..
 11bf0 21002970 40f00100 84f82100 287cc0f3  !.)p@.....!.(|..
 11c00 4100e071 687861f3 00006870 0de0296a  A..qhxa...hp..)j
 11c10 8164696a c164a97f c1f30101 c171697d  .dij.d.......qi}
 11c20 002060f3 00012875 69751168 c4f80e10  . `...(uiu.h....
 11c30 9288aef8 04201a68 62619b88 bb8002f0  ..... .hba......
 11c40 81fd0021 342201a8 f7f7e3f9 204603f0  ...!4"...... F..
 11c50 2bfb0024 02f07efd 71888df8 044001a8  +..$..~.q....@..
 11c60 adf80c10 0294fff7 a6fd09e0 002407e0  .............$..
 11c70 052405e0 d8f86030 0133c8f8 603088e7  .$....`0.3..`0..
 11c80 20460eb0 bde8f081 940d0020 c8390020   F......... .9. 
 11c90 30b58fb0 04460d46 342201a8 0021f7f7  0....F.F4"...!..
 11ca0 b8f90523 01a82146 8df80430 adf81040  ...#..!F...0...@
 11cb0 0295fff7 80fd0fb0 30bd0000 f0b58fb0  ........0.......
 11cc0 fff7a2fd 014608b1 04462ce0 214c2378  .....F...F,.!L#x
 11cd0 012b0ad0 022b24d1 fff743fd 08b16424  .+...+$...C...d$
 11ce0 21e00d20 fff7e6fd 1be0fff7 45fd0546  !.. ........E..F
 11cf0 0028f4d1 02f026fd 6378a668 e7682570  .(....&.cx.h.h%p
 11d00 65f30003 637002f0 25fd56b1 294601a8  e...cp..%.V.)F..
 11d10 3422f7f7 7ef90823 8df80430 01a83946  4"..~..#...0..9F
 11d20 b0476ff0 0044fff7 83fd70b9 fff735fd  .Go..D....p...5.
 11d30 50b9084b 5a7d1875 60f30002 5a75fff7  P..KZ}.u`...Zu..
 11d40 99fd6ff0 004000e0 6420a042 a8bf2046  ..o..@..d .B.. F
 11d50 0fb0f0bd 940d0020 2de9f047 a94f94b0  ....... -..G.O..
 11d60 9946fb69 1c9d0133 80468a46 1446fb61  .F.i...3.F.F.F.a
 11d70 02f0e8fc 55b3b8f1 030f27d8 6b78022b  ....U.....'.kx.+
 11d80 24d8a14e 337d53bb 2b78012b 0fd002d3  $..N3}S.+x.+....
 11d90 022b04d0 1ae02b7a d90717d4 0de02b7a  .+....+z......+z
 11da0 da0713d4 03f0d2f9 38b90624 0fe0baf1  ........8..$....
 11db0 030f0bd8 002cf5d1 08e06ff0 00439945  .....,....o..C.E
 11dc0 0fd04846 06a9f8f7 99fd50b1 032402f0  ..HF......P..$..
 11dd0 c1fc14b1 3b6a0133 3b622046 0ee10224  ....;j.3;b F...$
 11de0 f5e74046 03f040fb 002840f0 07818748  ..@F..@..(@....H
 11df0 874b0421 01220bf0 17fa737f 83488de8  .K.!."....s..H..
 11e00 08040421 0122834b 0bf00efa 94b16379  ...!.".K......cy
 11e10 00932379 0193e378 0293a378 03936378  ..#y...x...x..cx
 11e20 04932378 05937948 7b4b0421 01220bf0  ..#x..yH{K.!."..
 11e30 fbf905e0 7548794b 04210122 0bf0f4f9  ....uHyK.!."....
 11e40 ab797248 8de80801 eb790293 6b880393  .yrH.....y..k...
 11e50 ab880493 96f86630 05930421 0122704b  ......f0...!."pK
 11e60 0bf0e2f9 01226f4b 68480421 0bf0dcf9  ....."oKhH.!....
 11e70 1d9b3362 1e9b7362 2b783377 6b787377  ..3b..sb+x3wkxsw
 11e80 b37f8df8 1e8068f3 0103b377 664b6a88  ......h....wfKj.
 11e90 8df81fa0 002c08bf 1c462368 cdf82630  .....,...F#h..&0
 11ea0 a388adf8 2a302b78 8ab9a988 79b9012b  ....*0+x....y..+
 11eb0 08d002d3 022b05d0 0ee0a022 adf82220  .....+.....".." 
 11ec0 f02207e0 3022adf8 22206022 02e0adf8  ."..0".." `"....
 11ed0 2220aa88 adf82420 aa7902b9 07228df8  " ....$ .y..."..
 11ee0 1d20ea79 8df82020 43b1012b 0cd12b7a  . .y..  C..+..+z
 11ef0 13f0010f 14bf0123 042306e0 6b78002b  .......#.#..kx.+
 11f00 0cbf0323 022300e0 002314a8 0ba900f8  ...#.#...#......
 11f10 343d1222 07f02efb 00287ff4 57af0ba8  4=.".....(..W...
 11f20 02f082fb 04460028 7ff451af 2b78012b  .....F.(..Q.+x.+
 11f30 07d10120 fff731fc 04460028 7ff447af  ... ..1..F.(..G.
 11f40 4ae096f8 6830db07 1fd52f4b 8df82c00  J...h0..../K..,.
 11f50 5b7f012b 01d0022b 01d18df8 2c309df8  [..+...+....,0..
 11f60 2c3043f0 04038df8 2c30304b 00931f22  ,0C.....,00K..."
 11f70 01200192 3e3b0146 0baa02f0 fefd96f8  . ..>;.F........
 11f80 68306ff3 000386f8 68301f4d 96f86610  h0o.....h0.M..f.
 11f90 05f12800 0baa2323 07f035fb 04460028  ..(...##..5..F.(
 11fa0 7ff415af 0ba802f0 3ffb0446 00287ff4  ........?..F.(..
 11fb0 0eaf05f1 470095f8 67100baa 232307f0  ....G...g...##..
 11fc0 41fb0446 00287ff4 02af0ba8 02f02cfb  A..F.(........,.
 11fd0 04460028 add0fae6 6ff00043 99450ad0  .F.(....o..C.E..
 11fe0 069df8f7 edfb737d 284443f0 0103b061  ......s}(DC....a
 11ff0 7375fff7 31fc0123 3375e8e6 14b0bde8  su..1..#3u......
 12000 f08700bf c8390020 940d0020 9c3b0020  .....9. ... .;. 
 12010 b5f30100 daf30100 7fee0100 04f40100  ................
 12020 09f40100 ecfd0100 a83b0020 fa0d0020  .........;. ... 
 12030 38b5174c 636a0133 05466362 02f082fb  8..Lcj.3.Fcb....
 12040 144a117d d9b92b88 c3f30803 b3f5807f  .J.}..+.........
 12050 92f86830 18bf61f3 00030f49 12bf82f8  ..h0..a....I....
 12060 683043f0 010382f8 68302846 0cbf1c23  h0C.....h0(F...#
 12070 1f2301f1 3e0202f0 a0fd0546 00e00f25  .#..>......F...%
 12080 02f068fb 15b1a36a 0133a362 284638bd  ..h....j.3.b(F8.
 12090 c8390020 940d0020 bc0d0020 7fb5144c  .9. ... ... ...L
 120a0 636c0546 01330e46 636402f0 4bfb2846  cl.F.3.Fcd..K.(F
 120b0 03f02af9 90b18de8 60000e48 0e4b0421  ..*.....`..H.K.!
 120c0 01220bf0 b1f82846 314602aa 062307f0  ."....(F1F...#..
 120d0 fcfa02a8 02f0a8fa 054600e0 072502f0  .........F...%..
 120e0 39fb15b1 a36c0133 a3642846 04b070bd  9....l.3.d(F..p.
 120f0 c8390020 9c3b0020 b0f50100 70b50446  .9. .;. ....p..F
 12100 a4b00021 34220aa8 f6f783ff a388adf8  ...!4"..........
 12110 0030e388 adf80230 2389adf8 04306389  .0.....0#....0c.
 12120 adf80630 0023adf8 0830adf8 0a309de8  ...0.#...0...0..
 12130 070003ae 86e80700 19463422 0aa8f6f7  .........F4"....
 12140 68ff0423 61888df8 28300aa8 adf83410  h..#a...(0....4.
 12150 0c96cdf8 2cd0fff7 2efb6388 adf81830  ....,.....c....0
 12160 054650b1 8df81a00 17a906a8 062207f0  .FP.........."..
 12170 7bfb17a8 02f058fa 40e0bdf8 0c30adf8  {.....X.@....0..
 12180 1a30bdf8 0e30adf8 1c30bdf8 1030adf8  .0...0...0...0..
 12190 1e30bdf8 1230adf8 2030bdf8 1430adf8  .0...0.. 0...0..
 121a0 223006a8 bdf81630 adf82430 17a91122  "0.....0..$0..."
 121b0 07f02efb 17a802f0 37fa6488 0646c0b1  ........7.d..F..
 121c0 0f4a936d 01339365 20462a46 022102f0  .J.m.3.e F*F.!..
 121d0 79ff2946 17a83422 f6f71bff 032317a8  y.)F..4".....#..
 121e0 21468df8 5c30adf8 64401896 fff7e3fa  !F..\0..d@......
 121f0 04e02046 02210122 02f064ff 24b070bd  .. F.!."..d.$.p.
 12200 c8390020 f0b5324d 6b6d93b0 01330746  .9. ..2Mkm...3.F
 12210 0c466b65 02f096fa 384603f0 3bf80646  .Fke....8F..;..F
 12220 002849d0 90f82130 9b0747d4 29482a4b  .(I...!0..G.)H*K
 12230 04210122 0af0f8ff 00972388 01936388  .!."......#...c.
 12240 0293a388 0393e388 04932389 05936389  ..........#...c.
 12250 06932048 214b0421 01220af0 e5ff1d48  .. H!K.!.".....H
 12260 1f4b0421 01220af0 dfff2388 adf82630  .K.!."....#...&0
 12270 6388adf8 2830a388 adf82a30 e388adf8  c...(0....*0....
 12280 2c302389 adf82e30 09a86389 adf82470  ,0#....0..c...$p
 12290 0da91122 adf83030 07f081fa 044670b9  ..."..00.....Fp.
 122a0 0da802f0 c1f90446 48b996f8 213043f0  .......FH...!0C.
 122b0 020386f8 213002e0 072400e0 022402f0  ....!0...$...$..
 122c0 49fa14b1 ab6d0133 ab652046 13b0f0bd  I....m.3.e F....
 122d0 c8390020 9c3b0020 29f60100 43f60100  .9. .;. )...C...
 122e0 ecfd0100 30b591b0 0b780093 05460c46  ....0....x...F.F
 122f0 0d4b0e48 04210022 0af096ff 342203a8  .K.H.!."....4"..
 12300 0021f6f7 86fe94e8 03000b23 8df80c30  .!.........#...0
 12310 04ab83e8 030003a8 2946adf8 1850fff7  ........)F...P..
 12320 4afa11b0 30bd00bf c5f60100 9c3b0020  J...0........;. 
 12330 70b58eb0 04460d46 16460021 01a83422  p....F.F.F.!..4"
 12340 f6f767fe 0a2301a8 21468df8 0430adf8  ..g..#..!F...0..
 12350 0c400295 fff72ffa 1db916b1 204601f0  .@..../..... F..
 12360 abff0eb0 70bdf0b5 8fb00446 0f461646  ....p......F.F.F
 12370 01a80021 34221d46 f6f74bfe 149aadf8  ...!4".F..K.....
 12380 10400c23 8df80430 4ff00003 62f30003  .@.#...0O...b...
 12390 01a82146 adf80c70 0296adf8 0e508df8  ..!F...p.....P..
 123a0 1230fff7 08fa0fb0 f0bdf0b5 8fb00c46  .0.............F
 123b0 07461646 01a80021 34221d46 f6f729fe  .F.F...!4".F..).
 123c0 4ff00002 0d2365f3 000201a8 21468df8  O....#e.....!F..
 123d0 0430adf8 0c400297 adf80e60 8df81020  .0...@.....`... 
 123e0 fff7e9f9 0fb0f0bd f0b58fb0 05460f46  .............F.F
 123f0 164601a8 00213422 1c46f6f7 0afe0e23  .F...!4".F.....#
 12400 8df80430 9df85030 9df85420 adf80850  ...0..P0..T ...P
 12410 003318bf 01230034 18bf0124 003218bf  .3...#.4...$.2..
 12420 012244ea 430362f3 82039df8 5820adf8  ."D.C.b.....X ..
 12430 0a700032 18bf0122 62f3c303 01a82946  .p.2..."b.....)F
 12440 8df80c60 8df80d30 fff7b5f9 0fb0f0bd  ...`...0........
 12450 07b50021 14220c48 f6f7dbfd 00215822  ...!.".H.....!X"
 12460 0a48f6f7 d6fd0023 094a0192 00930421  .H.....#.J.....!
 12470 1f220848 0af06aff 002814bf 0b200020  .".H..j..(... . 
 12480 03b05df8 04fb00bf 940d0020 a80d0020  ..]........ ... 
 12490 e5f60100 c8390020 034618b1 0e2808bf  .....9. .F...(..
 124a0 002100e0 01460248 03804180 704700bf  .!...F.H..A.pG..
 124b0 c0200020 2de9f041 05461e46 29b10e29  . . -..A.F.F)..)
 124c0 1fbf0b4c 20690130 2061ec68 64b10846  ...L i.0 a.hd..F
 124d0 11462f89 fff7e0ff 32460146 2b693846  .F/.....2F.F+i8F
 124e0 a446bde8 f0416047 2046bde8 f08100bf  .F...A`G F......
 124f0 503a0020 0023fff7 ddbf0000 2de9f041  P:. .#......-..A
 12500 05461e46 29b10e29 1fbf0b4c a0690130  .F.F)..)...L.i.0
 12510 a0612c69 64b10846 11462f89 fff7bcff  .a,id..F.F/.....
 12520 32460146 6b693846 a446bde8 f0416047  2F.Fki8F.F...A`G
 12530 2046bde8 f08100bf 503a0020 b1f5857f   F......P:. ....
 12540 08bf0e21 89b20023 fff7d8bf 2de9f041  ...!...#....-..A
 12550 05461e46 29b10e29 1fbf0b4c 206a0130  .F.F)..)...L j.0
 12560 20622c6a 64b10846 11462f89 fff794ff   b,jd..F.F/.....
 12570 32460146 6b6a3846 a446bde8 f0416047  2F.Fkj8F.F...A`G
 12580 2046bde8 f08100bf 503a0020 b1f5857f   F......P:. ....
 12590 08bf0e21 0023fff7 d9bf0000 2de9f041  ...!.#......-..A
 125a0 05461e46 29b10e29 1fbf0b4c a06a0130  .F.F)..)...L.j.0
 125b0 a0626c69 64b10846 11462f89 fff76cff  .blid..F.F/...l.
 125c0 32460146 ab693846 a446bde8 f0416047  2F.F.i8F.F...A`G
 125d0 2046bde8 f08100bf 503a0020 038a1bb9   F......P:. ....
 125e0 b1f5857f 08bf0e21 0023fff7 d7bf0000  .......!.#......
 125f0 2de9f041 05461e46 29b10e29 1fbf0b4c  -..A.F.F)..)...L
 12600 206b0130 20632c69 64b10846 11462f89   k.0 c,id..F.F/.
 12610 fff742ff 32460146 6b693846 a446bde8  ..B.2F.Fki8F.F..
 12620 f0416047 2046bde8 f08100bf 503a0020  .A`G F......P:. 
 12630 b1f5857f 08bf0e21 0023fff7 d9bf0000  .......!.#......
 12640 2de9f041 05461e46 29b10e29 1fbf0b4c  -..A.F.F)..)...L
 12650 a06b0130 a0632c6a 64b10846 11462f89  .k.0.c,jd..F.F/.
 12660 fff71aff 32460146 6b6a3846 a446bde8  ....2F.Fkj8F.F..
 12670 f0416047 2046bde8 f08100bf 503a0020  .A`G F......P:. 
 12680 b1f5857f 08bf0e21 0023fff7 d9bf0000  .......!.#......
 12690 f7b50546 1e4629b1 0e291fbf 0a4c206c  ...F.F)..)...L l
 126a0 01302064 6c6964b1 08461146 2f89fff7  .0 dlid..F.F/...
 126b0 f3feab69 00930146 aa893846 3346a047  ...i...F..8F3F.G
 126c0 00e02046 03b0f0bd 503a0020 b1f5857f  .. F....P:. ....
 126d0 08bf0e21 0023fff7 dbbf0000 2de9f041  ...!.#......-..A
 126e0 05461e46 29b10e29 1fbf0b4c a06c0130  .F.F)..)...L.l.0
 126f0 a0642c69 64b10846 11462f89 fff7ccfe  .d,id..F.F/.....
 12700 32460146 6b693846 a446bde8 f0416047  2F.Fki8F.F...A`G
 12710 2046bde8 f08100bf 503a0020 0023fff7   F......P:. .#..
 12720 ddbf1fb5 8489adf8 04400024 adf80830  .........@.$...0
 12730 039201ab 2246adf8 0640fff7 cfff0e20  ...."F...@..... 
 12740 04b010bd 2de9f041 05461e46 29b10e29  ....-..A.F.F)..)
 12750 1fbf0b4c 206d0130 2065ec68 64b10846  ...L m.0 e.hd..F
 12760 11462f89 fff798fe 32460146 2b693846  .F/.....2F.F+i8F
 12770 a446bde8 f0416047 2046bde8 f08100bf  .F...A`G F......
 12780 503a0020 b1f5857f 08bf0021 0023fff7  P:. .......!.#..
 12790 d9bf1fb5 0b460a88 adf80420 00215a68  .....F..... .!Zh
 127a0 9b68adf8 08200393 0a4601ab adf80610  .h... ...F......
 127b0 fff7c8ff 002814bf 0e200020 05b05df8  .....(... . ..].
 127c0 04fb0000 2de9f041 05461e46 29b10e29  ....-..A.F.F)..)
 127d0 1fbf0b4c a06d0130 a0652c69 64b10846  ...L.m.0.e,id..F
 127e0 11462f89 fff758fe 32460146 6b693846  .F/...X.2F.Fki8F
 127f0 a446bde8 f0416047 2046bde8 f08100bf  .F...A`G F......
 12800 503a0020 0023fff7 ddbf0000 f0b50546  P:. .#.........F
 12810 85b029b1 0e291fbf 104c206e 01302066  ..)..)...L n.0 f
 12820 ec68bcb1 51b9bdf8 2800adf8 0410adf8  .h..Q...(.......
 12830 0610adf8 08000393 01ae00e0 00260846  .............&.F
 12840 11462f89 fff728fe 32460146 2b693846  .F/...(.2F.F+i8F
 12850 a04700e0 204605b0 f0bd00bf 503a0020  .G.. F......P:. 
 12860 07b50023 0093fff7 d1ff03b0 5df804fb  ...#........]...
 12870 70b50446 29b10e29 1fbf0b48 836f0133  p..F)..)...H.o.3
 12880 8367e569 6db10846 11462689 fff704fe  .g.im..F.F&.....
 12890 04f10c02 0146236a 3046ac46 bde87040  .....F#j0F.F..p@
 128a0 60472846 70bd00bf 503a0020 08b50022  `G(Fp...P:. ..."
 128b0 fff7deff 0e2008bd 73b50546 39b10e29  ..... ..s..F9..)
 128c0 1fbf0c48 d0f88030 0133c0f8 8030ac69  ...H...0.3...0.i
 128d0 64b10846 11462e89 fff7defd ea690092  d..F.F.......i..
 128e0 01462b7c ea683046 a04700e0 204602b0  .F+|.h0F.G.. F..
 128f0 70bd00bf 503a0020 08b50022 fff7dcff  p...P:. ..."....
 12900 0e2008bd f8b50746 0e4601f0 1bff104b  . .....F.F.....K
 12910 1d680022 2c46b4b1 2189b942 04d1a17a  .h.",F..!..B...z
 12920 b14204d0 ff2e02d0 22462468 f3e72ab9  .B......"F$h..*.
 12930 2968074a 196031b9 526004e0 11680968  )h.J.`1.R`...h.h
 12940 116001b9 5a6001f0 05ff2046 f8bd00bf  .`..Z`.... F....
 12950 c4200020 2de9f84f 184e8146 88469246  . . -..O.N.F.F.F
 12960 9b4601f0 effe3068 00250446 0cb32389  .F....0h.%.F..#.
 12970 4b451bd1 a27a0027 574517da 18f83710  KE...z.'WE....7.
 12980 914208eb c70301d1 45b901e0 0137f3e7  .B......E....7..
 12990 01680a4a 316031b9 526004e0 2a681268  .h.J1`1.R`..*h.h
 129a0 2a6002b9 7560cbf8 003002e0 25462468  *`..u`...0..%F$h
 129b0 dce701f0 cffe2046 bde8f88f c4200020  ...... F..... . 
 129c0 014610b1 0148f7f7 2bbd7047 cc200020  .F...H..+.pG. . 
 129d0 10b50548 f7f710fd 044618b1 00212822  ...H.....F...!("
 129e0 f6f717fb 204610bd cc200020 2de9ff41  .... F... . -..A
 129f0 05469046 0e4629b1 0e291fbf 0e4a136f  .F.F.F)..)...J.o
 12a00 01331367 2c6994b1 0c2201a8 0021f6f7  .3.g,i..."...!..
 12a10 00fbab89 adf80430 41463046 2f89fff7  .......0AF0F/...
 12a20 3bfd01aa 01466b69 3846a047 00e02046  ;....Fki8F.G.. F
 12a30 04b0bde8 f08100bf 503a0020 fff7d6bf  ........P:. ....
 12a40 07b5054b 00900421 04480122 0af0ecfb  ...K...!.H."....
 12a50 03b05df8 04fb00bf 38f70100 9c3b0020  ..].....8....;. 
 12a60 70b50446 86b00e46 42f60300 02a905f0  p..F...FB.......
 12a70 29fda389 20890133 adf80430 01a9e389  )... ..3...0....
 12a80 adf80630 02aa07f0 2ffc0546 30b12eb1  ...0..../..F0...
 12a90 00222046 29461346 fff7aafd 284606b0  ." F)F.F....(F..
 12aa0 70bd70b5 044686b0 0e4642f6 030002a9  p.p..F...FB.....
 12ab0 05f008fd a38b2089 0133adf8 043001a9  ...... ..3...0..
 12ac0 e38badf8 063002aa 07f00efc 054630b1  .....0.......F0.
 12ad0 2eb10022 20462946 1346fff7 b1fd2846  ..." F)F.F....(F
 12ae0 06b070bd 70b5038a 86b00446 0e468bb9  ..p.p......F.F..
 12af0 83890133 adf80430 02a9c389 adf80630  ...3...0.......0
 12b00 42f60200 05f0defc 208901a9 02aa07f0  B....... .......
 12b10 ebfb05e0 06a90089 21f8183d 07f096fc  ........!..=....
 12b20 054630b1 2eb10022 20462946 1346fff7  .F0...." F)F.F..
 12b30 35fd2846 06b070bd 70b50446 008a86b0  5.(F..p.p..F....
 12b40 10b311bb 102b1fd1 638aadf8 0400adf8  .....+..c.......
 12b50 063002ad 02f11006 10685168 2b4603c3  .0.......hQh+F..
 12b60 0832b242 1d46f7d1 00212046 0a4601ab  .2.B.F...! F.F..
 12b70 fff714fd 70b92082 60820121 2046fff7  ....p. .`..! F..
 12b80 b1ff0146 08b907e0 0a210022 20461346  ...F.....!." F.F
 12b90 fff704fd 0e20ffe7 06b070bd 73b5c389  ..... ....p.s...
 12ba0 82890546 0e460089 2bb902a9 21f8082d  ...F.F..+...!..-
 12bb0 07f04cfc 06e001a9 adf80420 adf80630  ..L........ ...0
 12bc0 07f0c6fc 044630b1 2eb10022 28462146  .....F0...."(F!F
 12bd0 1346fff7 f7fd2046 02b070bd 73b5c289  .F.... F..p.s...
 12be0 038a9a42 04460e46 008919d2 07f002f9  ...B.F.F........
 12bf0 05381ed0 e389228a adf80630 19189142  .8...."....0...B
 12c00 c4bfd21a 2283a289 adf80420 6269d8bf  ...."...... bi..
 12c10 20831a44 2089238b 01a907f0 39fe05e0   ..D .#.....9...
 12c20 02a90123 01f8083d 07f0defe 054638b1  ...#...=.....F8.
 12c30 00e00725 26b12046 29460022 fff718fe  ...%&. F)F."....
 12c40 284602b0 70bd73b5 c3890446 0e461546  (F..p.s....F.F.F
 12c50 4bb1028a 9a4206d9 02a90023 01f8043d  K....B.....#...=
 12c60 008907f0 c1fe2046 31462a46 fff700fe  ...... F1F*F....
 12c70 02b070bd 072938b5 04460d46 0ad12846  ..p..)8..F.F..(F
 12c80 2189a289 0123fff7 90fb2089 bde83840  !....#.... ...8@
 12c90 01f0ceb9 0089a189 01f0f6f9 0028eed0  .............(..
 12ca0 38bd30b5 0c4687b0 05460021 68461622  8.0..F...F.!hF."
 12cb0 f6f7aff9 2388adf8 00306368 052b07d0  ....#....0ch.+..
 12cc0 132b25d1 a3680df1 0501da1c 133309e0  .+%..h.......3..
 12cd0 a0680330 0af0dbf9 0df10501 05f0f2fb  .h.0............
 12ce0 30b115e0 52f8040b 41f8040b 9a42f9d1  0...R...A....B..
 12cf0 a06810f8 013b8df8 04300af0 c8f92388  .h...;...0....#.
 12d00 aa89adf8 02009a42 02d2ab81 002400e0  .......B.....$..
 12d10 0a242846 21460022 6b46fff7 69fc24b9  .$(F!F."kF..i.$.
 12d20 002814bf 0e200020 00e00e20 07b030bd  .(... . ... ..0.
 12d30 30b50c46 87b00546 00216846 1622f6f7  0..F...F.!hF."..
 12d40 68f92388 adf80030 6368052b 07d0132b  h.#....0ch.+...+
 12d50 38d1a368 0df10501 da1c1333 09e0a068  8..h.......3...h
 12d60 03300af0 94f90df1 050105f0 abfb30b1  .0............0.
 12d70 28e052f8 040b41f8 040b9a42 f9d1a068  (.R...A....B...h
 12d80 10f8013b 8df80430 0af081f9 2388aa8b  ...;...0....#...
 12d90 adf80200 9a4215d2 ab830df1 050005f1  .....B..........
 12da0 0c011022 f6f71cf9 044648b9 21462246  ...".....FH.!F"F
 12db0 28466b46 fff744fc 002818bf 0e2408e0  (FkF..D..(...$..
 12dc0 002406e0 00222846 0a211346 fff738fc  .$..."(F.!.F..8.
 12dd0 0e242046 07b030bd 70b50446 bdf81050  .$ F..0.p..F...P
 12de0 f1b91088 a1898842 19d15288 e1899142  .......B..R....B
 12df0 15d1228a 4e199642 11dc228b aa420ed1  ..".N..B.."..B..
 12e00 65691846 2944f6f7 ebf80546 38b90121  ei.F)D.....F8..!
 12e10 e6812046 fff7e2fe 014608b9 05e00a21  .. F.....F.....!
 12e20 20460022 fff724fd 0e252846 70bd08b5   F."..$..%(Fp...
 12e30 0a4609b1 002200e0 0e211346 fff782fc  .F..."...!.F....
 12e40 0e2008bd 38b50446 0d4679b9 f7f7b8fc  . ..8..F.Fy.....
 12e50 00f57060 606001f0 75fc064b 25605a68  ..p```..u..K%`Zh
 12e60 14605c60 bde83840 01f074bc bde83840  .`\`..8@..t...8@
 12e70 fff7a6bd c4200020 08b50a46 09b10022  ..... . ...F..."
 12e80 04e08189 c3899942 05d10e21 1346fff7  .......B...!.F..
 12e90 affb0e20 08bd0121 fff7e2fd 002814bf  ... ...!.....(..
 12ea0 0e200020 08bd08b5 0a4609b1 002204e0  . . .....F..."..
 12eb0 818bc38b 994205d1 0e211346 fff7c0fb  .....B...!.F....
 12ec0 0e2008bd 0121fff7 ecfd0028 14bf0e20  . ...!.....(... 
 12ed0 002008bd 08b50a46 09b10022 05e08189  . .....F..."....
 12ee0 4ff6ff73 994205d1 0e211346 fff756fb  O..s.B...!.F..V.
 12ef0 0e2008bd 0121fff7 f5fd0028 14bf0e20  . ...!.....(... 
 12f00 002008bd f0b585b0 1f468389 adf80430  . .......F.....0
 12f10 c389adf8 0630bdb2 039201ab 00220446  .....0.......".F
 12f20 0e46adf8 0850fff7 4dfc68b9 66b92089  .F...P..M.h.f. .
 12f30 06f060ff 40b10138 874207da 20460e21  ..`.@..8.B.. F.!
 12f40 32463346 fff73efc 0e2008e0 e3892b44  2F3F..>.. ....+D
 12f50 e3812046 0121fff7 21fe0028 f4d105b0  .. F.!..!..(....
 12f60 f0bd13b5 0446fff7 a7fc6369 002b09dd  .....F....ci.+..
 12f70 22699342 06da02a9 002301f8 043d2089  "i.B.....#...= .
 12f80 07f032fd 02b010bd 30b5038a 87b00546  ..2.....0......F
 12f90 0c462bbb 0b888289 9a4223d2 83814b68  .F+......B#...Kh
 12fa0 042b14d0 062b1dd1 88680af0 70f8adf8  .+...+...h..p...
 12fb0 0400a068 02300af0 6af8adf8 0600a068  ...h.0..j......h
 12fc0 04300af0 64f802a9 05f07cfa 0ae08868  .0..d.....|....h
 12fd0 0af05df8 2882a068 02300af0 58f86882  ..].(..h.0..X.h.
 12fe0 002008e0 00212846 0a4601ab fff7d6fa  . ...!(F.F......
 12ff0 0028f5d0 0e2007b0 30bd37b5 42690369  .(... ..0.7.Bi.i
 13000 9a420446 00890fda 0c235343 e268d518  .B.F.....#SC.h..
 13010 d35aadf8 04300023 adf80630 01a9aa68  .Z...0.#...0...h
 13020 ab8807f0 35fc05e0 02a90123 01f8083d  ....5......#...=
 13030 07f0dafc 054620b1 20462946 0022fff7  .....F . F)F."..
 13040 3bfc2846 03b030bd f8b50446 09bb4569  ;.(F..0....F..Ei
 13050 01698d42 1cda0c21 c7681088 69437e18  .i.B...!.h..iC~.
 13060 795a8842 14d15288 92b9b288 bdf81810  yZ.B..R.........
 13070 8a420dd1 b1681846 f5f7b2ff 064638b9  .B...h.F.....F8.
 13080 01356561 2046fff7 b8ff0146 08b905e0  .5ea F.....F....
 13090 0a212046 0022fff7 0ffc0e26 3046f8bd  .! F.".....&0F..
 130a0 2de9f743 02ad0026 45f8086d 224c0195  -..C...&E..m"L..
 130b0 80468946 01f046fb 23683246 ebb14ff6  .F.F..F.#h2F..O.
 130c0 ff718845 186802d0 19894145 12d1b9f1  .q.E.h....AE....
 130d0 ff0f02d0 997a4945 0cd11abb 2168164e  .....zIE....!h.N
 130e0 0f682760 07b97660 00211960 01990b60  .h'`..v`.!.`...`
 130f0 01931346 1a460346 e0e701f0 2bfb009c  ...F.F.F....+...
 13100 bcb1a27a 0d4b2046 53f82230 07210022  ...z.K FS."0.!."
 13110 9847009b 1b680093 03b90195 2046fff7  .G...h...... F..
 13120 4ffcece7 11680e68 1660002e dcd16260  O....h.h.`....b`
 13130 dae703b0 bde8f083 c4200020 bcf90100  ......... . ....
 13140 73b502ad f7f73cfb 002445f8 084d0646  s.....<..$E..M.F
 13150 019501f0 f7fa1c49 0b682246 cbb193e8  .......I.h"F....
 13160 1100341b 002c11db 32b90c68 164a2468  ..4..,..2..h.J$h
 13170 0c6034b9 526004e0 14682468 146004b9  .`4.R`...h$h.`..
 13180 4a600022 1a60019a 13600193 1a460346  J`.".`...`...F.F
 13190 e4e701f0 dffa009c 94b10c4a 2089d2f8  ...........J ...
 131a0 94301321 0133c2f8 9430fef7 77ff009b  .0.!.3...0..w...
 131b0 1b680093 03b90195 2046fff7 01fceae7  .h...... F......
 131c0 6ff00040 02b070bd c4200020 503a0020  o..@..p.. . P:. 
 131d0 2de9f041 194c9846 d4f88430 88b00e46  -..A.L.F...0...F
 131e0 01330746 1648c4f8 84301546 fff728fc  .3.F.H...0.F..(.
 131f0 00961448 144b0421 01220af0 15f855b9  ...H.K.!."....U.
 13200 4ff6ff70 314604aa 2b4608f0 5ff960b9  O..p1F..+F.._.`.
 13210 069dbdf8 1c8008a9 384621f8 146d2a46  ........8F!..m*F
 13220 434607f0 5ffc08b9 05e00920 d4f88830  CF.._...... ...0
 13230 0133c4f8 883008b0 bde8f081 503a0020  .3...0......P:. 
 13240 58f90100 9c3b0020 bff80100 002270b5  X....;. ....."p.
 13250 13460d46 0646fff7 bbff3146 04462a46  .F.F.F....1F.F*F
 13260 0023fff7 a2f82046 70bd0e21 fff718bf  .#.... Fp..!....
 13270 2de9f041 284cd4f8 8c3088b0 01338046  -..A(L...0...3.F
 13280 0e46c4f8 8c30fff7 a3fb2546 074660b3  .F...0....%F.F`.
 13290 0e238372 a0f80880 86812048 fff7d0fb  .#.r...... H....
 132a0 1f48204b 00960421 012209f0 bdff4ff6  .H K...!."....O.
 132b0 ff703146 04aa0023 08f008f9 b8b908a9  .p1F...#........
 132c0 404621f8 146d069a bdf81c30 07f05cfc  @F!..m.....0..\.
 132d0 044668b9 01f036fa 404601f0 dbff08b1  .Fh...6.@F......
 132e0 a0f84060 01f036fa 07e00624 00e00924  ..@`..6....$...$
 132f0 d5f89030 0133c5f8 90302046 41463246  ...0.3...0 FAF2F
 13300 0123fff7 52f83846 2146fff7 9bfd2046  .#..R.8F!F.... F
 13310 08b0bde8 f08100bf 503a0020 61f90100  ........P:. a...
 13320 9c3b0020 bff80100 38b50d46 ff21fff7  .;. ....8..F.!..
 13330 e9fa0446 78b1827a 074b53f8 22302bb1  ...Fx..z.KS."0+.
 13340 e978b5f8 012001f5 80719847 2046bde8  .x... ...q.G F..
 13350 3840fff7 35bb38bd bcf90100 70b50e46  8@..5.8.....p..F
 13360 00211546 fff7cefa 044648b1 31462b46  .!.F.....FH.1F+F
 13370 0022fff7 9ff82046 bde87040 fff720bb  .".... F..p@.. .
 13380 70bd70b5 0d4686b0 0621fff7 bbfa0446  p.p..F...!.....F
 13390 30b32b88 c2899a42 38bfc381 2b4638bf  0.+....B8...+F8.
 133a0 002633f8 022badf8 042028bf 0a260df1  .&3..+... (..&..
 133b0 06021235 53f8041b 42f8041b ab42f9d1  ...5S...B....B..
 133c0 20463146 002201ab fff762f9 26b90028   F1F."....b.&..(
 133d0 14bf0e21 002100e0 0e212046 fff732fd  ...!.!...! F..2.
 133e0 06b070bd 37b50d46 0621fff7 8bfa0446  ..p.7..F.!.....F
 133f0 e8b115b1 29460022 12e0c389 028a9342  ....)F.".......B
 13400 01d10e21 0be00133 01a90089 adf80430  ...!...3.......0
 13410 adf80620 06f026fe 014628b1 20462a46  ... ..&..F(. F*F
 13420 1346fff7 35f90e21 2046fff7 0bfd03b0  .F..5..! F......
 13430 30bd70b5 0d4686b0 0221fff7 63fa0446  0.p..F...!..c..F
 13440 50b36b88 828b9a42 15d28383 2b88adf8  P.k....B....+...
 13450 04306b88 adf80630 02ad00f1 0c0300f1  .0k....0........
 13460 1c061868 59682a46 03c20833 b3421546  ...hYh*F...3.B.F
 13470 f7d10025 00e00a25 20462946 002201ab  ...%...% F)F."..
 13480 fff764f8 25b90028 14bf0e21 002100e0  ..d.%..(...!.!..
 13490 0e212046 fff7d6fc 06b070bd 37b50d46  .! F......p.7..F
 134a0 0221fff7 2ffa0446 28b315b1 29460022  .!../..F(...)F."
 134b0 1ae0838b 4ff6ff72 934201d1 0e2112e0  ....O..r.B...!..
 134c0 0133adf8 00304ff4 2053adf8 0220adf8  .3...0O. S... ..
 134d0 04306946 008904f1 0c021023 06f07afe  .0iF.......#..z.
 134e0 014628b1 20462a46 1346fff7 2ff80e21  .F(. F*F.F../..!
 134f0 2046fff7 a7fc03b0 30bd0000 37b50422   F......0...7.."
 13500 0d460deb 02030749 fff724fa 044638b1  .F.....I..$..F8.
 13510 019b2946 5b689847 01462046 fff792fc  ..)F[h.G.F F....
 13520 03b030bd 08f70100 37b50422 0d460deb  ..0.....7..".F..
 13530 02030749 fff70efa 044638b1 019b2946  ...I.....F8...)F
 13540 5b689847 01462046 fff77cfc 03b030bd  [h.G.F F..|...0.
 13550 8cf90100 f0b50d46 87b00121 fff7d2f9  .......F...!....
 13560 06460028 38d06b68 022b06d0 102b22d1  .F.(8.kh.+...+".
 13570 ab6802ac 03f11007 08e0a868 09f087fd  .h.........h....
 13580 02a904f0 9fff0446 b0b907e0 18685968  .......F.....hYh
 13590 224603c2 0833bb42 1446f7d1 6b88b289  "F...3.B.F..k...
 135a0 9a4208d2 b3812b88 adf80430 6b88adf8  .B....+....0k...
 135b0 06300024 00e00a24 3046a1b2 002201ab  .0.$...$0F..."..
 135c0 fef79cff 24b90028 14bf0e21 002100e0  ....$..(...!.!..
 135d0 0e213046 fff736fc 07b0f0bd 70b50d46  .!0F..6.....p..F
 135e0 86b00121 fff78ef9 044630b3 15b1a9b2  ...!.....F0.....
 135f0 00221be0 83894ff6 ff76b342 01d10e21  ."....O..v.B...!
 13600 13e002a9 4ff42050 04f05cff a3892089  ....O. P..\... .
 13610 adf80660 013301a9 02aaadf8 043007f0  ...`.3.......0..
 13620 53f80146 30b12046 89b22a46 1346fef7  S..F0. F..*F.F..
 13630 65ff0e21 2046fff7 05fc06b0 70bd0000  e..! F......p...
 13640 2de9f341 88461746 1e460a49 032201ab  -..A.F.F.F.I."..
 13650 fff780f9 044648b1 019b4146 5d683a46  .....FH...AF]h:F
 13660 3346a847 01462046 fff7ecfb 02b0bde8  3F.G.F F........
 13670 f08100bf f0f60100 f8b50f46 09211646  ...........F.!.F
 13680 1d46fff7 3ff90446 50b13946 32462b46  .F..?..FP.9F2F+F
 13690 fff738fc 01462046 bde8f840 fff7d2bb  ..8..F F...@....
 136a0 f8bdf7b5 0f460a21 16461c46 fff72af9  .....F.!.F.F..*.
 136b0 054660b1 a4b20094 39460022 3346fff7  .F`.....9F."3F..
 136c0 a5f82846 03b0bde8 f040fff7 79b903b0  ..(F.....@..y...
 136d0 f0bd10b5 0b21fff7 15f90446 40b10021  .....!.....F@..!
 136e0 0a46fff7 83f92046 bde81040 fff768b9  .F.... F...@..h.
 136f0 10bd0000 2de9ff41 88461746 1e460b49  ....-..A.F.F.F.I
 13700 022203ab fff726f9 044660b1 bdf82830  ."....&..F`...(0
 13710 0093039b 41465d68 3a463346 a8470146  ....AF]h:F3F.G.F
 13720 2046fff7 8ffb04b0 bde8f081 28f70100   F..........(...
 13730 37b50d46 02220849 01abfff7 0bf90446  7..F.".I.......F
 13740 38b1019b 29465b68 98470146 2046fff7  8...)F[h.G.F F..
 13750 79fb03b0 30bd00bf acf90100 10b50e21  y...0..........!
 13760 fff7d0f8 044690b1 0089a189 00f08cfc  .....F..........
 13770 40b90e20 2189a289 0123fef7 16fe2089  @.. !....#.... .
 13780 00f056fc 2046bde8 1040fff7 19b910bd  ..V. F...@......
 13790 ff21fff7 85bc0000 37b5194d 28680af0  .!......7..M(h..
 137a0 83f9184b 002283e8 0c00174b 9c795cb9  ...K.".....K.y\.
 137b0 164a0192 00230093 15480421 232209f0  .J...#...H.!#"..
 137c0 c5fdd8b1 0b2413e0 04eb8400 c0000af0  .....$..........
 137d0 21f90346 286050b1 0e4a0092 21460e48  !..F(`P..J..!F.H
 137e0 2822f6f7 d5fd0446 0028e1d0 00e00624  (".....F.(.....$
 137f0 28680af0 59f90023 2b602046 03b030bd  (h..Y..#+` F..0.
 13800 bc200020 c4200020 783b0020 6cf90100  . . . . x;. l...
 13810 503a0020 76f90100 cc200020 094b10b5  P:. v.... . .K..
 13820 1a88094b 19680023 934205da 51f83340  ...K.h.#.B..Q.3@
 13830 844204d0 0133f7e7 4ff0ff30 10bd1846  .B...3..O..0...F
 13840 10bd00bf ec200020 f0200020 10b5084b  ..... . . . ...K
 13850 1a680023 934205da 30f82340 8c4204d0  .h.#.B..0.#@.B..
 13860 0133f7e7 4ff0ff30 10bd1846 10bd00bf  .3..O..0...F....
 13870 e8200020 0b4a38b5 059d9369 6868049c  . . .J8....ihh..
 13880 01339361 04f008fe 014620b1 606809f0  .3.a.....F .`h..
 13890 e3fb0223 02e06b68 a3601023 a3810020  ...#..kh.`.#... 
 138a0 38bd00bf e83a0020 0f4a38b5 d369059d  8....:. .J8..i..
 138b0 049ca988 0133d361 606809f0 cdfb6068  .....3.a`h....`h
 138c0 e9880230 09f0c8fb 2b685868 04f0e4fd  ...0....+hXh....
 138d0 014628b1 60680430 09f0befb 062300e0  .F(.`h.0.....#..
 138e0 0423a381 002038bd e83a0020 38b5064c  .#... 8..:. 8..L
 138f0 00252068 0af0d8f8 2560044c 20680af0  .% h....%`.L h..
 13900 d3f82560 38bd00bf fc200020 f0200020  ..%`8.... . . . 
 13910 03469b06 c0f30010 44bf40f0 020080b2  .F......D.@.....
 13920 70470000 022802d0 032805d0 7047054a  pG...(...(..pG.J
 13930 d36a0133 d3627047 024a136b 01331363  .j.3.bpG.J.k.3.c
 13940 704700bf e83a0020 8a781306 30b507d5  pG...:. .x..0...
 13950 12f00105 06d102f0 02040cb1 03881bb1  ................
 13960 002030bd 1b2000e0 1d2002f0 7f028a70  . 0.. ... .....p
 13970 30bd0000 274a38b5 136a059d 049c0133  0...'J8..j.....3
 13980 13622a8a 606802f0 010312f0 020f1cbf  .b*.`h..........
 13990 43f00203 dbb212f0 040f18bf 43f00403  C...........C...
 139a0 12f0080f 18bf43f0 080312f0 100f18bf  ......C.........
 139b0 43f01003 12f0200f 18bf43f0 200312f0  C..... ...C. ...
 139c0 400f18bf 43f04003 12f4c07f 18bf43f0  @...C.@.......C.
 139d0 80030370 60680131 89b20130 09f03cfb  ...p`h.1...0..<.
 139e0 286804f0 59fd0146 606821b1 033009f0  (h..Y..F`h!..0..
 139f0 33fb0523 0ae02b68 033003f1 100253f8  3..#..+h.0....S.
 13a00 041b40f8 041b9342 f9d11323 a3810020  ..@....B...#... 
 13a10 38bd00bf e83a0020 f0b585b0 022b0746  8....:. .....+.F
 13a20 0b9c0cbf 03200220 0e468df8 0400fff7  ..... . .F......
 13a30 79ff0a9b 03930294 a568e368 38463146  y........h.h8F1F
 13a40 01aaa847 05b0f0bd 2de9f04f 8fb08846  ...G....-..O...F
 13a50 05901d46 189c00f0 75fe0598 01f01afc  ...F....u.......
 13a60 834608b9 0e246ee0 08f1ff39 1ffa89f9  .F...$n....9....
 13a70 4ff00003 c145adf8 3030f3d8 d0f838a0  O....E..00....8.
 13a80 49465046 fff7e2fe 431cebd0 1aeb800a  IFPF....C.......
 13a90 e8d0022d 0cbf0325 02252846 9af80270  ...-...%.%(F...p
 13aa0 fff740ff 032d3e48 10d0c36a 3d4d0133  ..@..->H...j=M.3
 13ab0 c3629af8 02102846 01f00301 09f0ccfa  .b....(F........
 13ac0 0223a560 a3813e46 00243ce0 016b0131  .#.`..>F.$<..k.1
 13ad0 0163a168 02292dd1 206809f0 d8fa9af8  .c.h.)-. h......
 13ae0 034030ea 040428d1 9af80210 814227d0  .@0...(......B'.
 13af0 c6b28af8 02609bf8 441001f0 040101f0  .....`..D.......
 13b00 ff00f9b1 5b469bf8 061053f8 080f8df8  ....[F....S.....
 13b10 2e109b88 0a90adf8 2c30adf8 30909af8  ........,0..0...
 13b20 0230adf8 32309df8 343064f3 00038df8  .0..20..40d.....
 13b30 343008e0 3e460d24 05e03e46 2c4602e0  40..>F.$..>F,F..
 13b40 3e4600e0 044600f0 05fe2cbb b74211d0  >F...F....,..B..
 13b50 06f00103 08f1ff31 009306f0 020607f0  .......1........
 13b60 02030122 01930296 059889b2 07ea0203  ..."............
 13b70 fef73afc bdf83030 73b1bdf8 32303bb9  ..:...00s...20;.
 13b80 07a80aa9 04f030fc 07a804f0 29fc02e0  ......0.....)...
 13b90 0aa804f0 21fc0446 20460fb0 bde8f08f  ....!..F F......
 13ba0 e83a0020 f4200020 2de9f04f 0f469a49  .:. . . -..O.F.I
 13bb0 99b00b68 04919346 00220446 08332178  ...h...F.".F.3!x
 13bc0 103051b1 002123f8 041c4ff6 ff7143f8  .0Q..!#...O..qC.
 13bd0 084c23f8 021c0132 efe7904b 5b889a42  .L#....2...K[..B
 13be0 75dc8f4b 02911a80 8d4b029a 1b889a42  u..K.....K.....B
 13bf0 6bda4ff0 0009c846 894b1b88 984558da  k.O....F.K...EX.
 13c00 854b1d68 05ebc803 03939b88 002b4dd1  .K.h.........+M.
 13c10 55f83860 b4686cb1 043c54f8 040f48b1  U.8`.hl..<T...H.
 13c20 fff7fcfd 431c41d0 05ebc000 8388002b  ....C.A........+
 13c30 f3d13be0 33785a1e 012a3dd8 7268002a  ..;.3xZ..*=.rh.*
 13c40 3ad0022b 42f60100 009618bf 4ff42050  :..+B.......O. P
 13c50 01210df1 1a02734b 07f0e4fb 20bb57b1  .!....sK.... .W.
 13c60 01238df8 243009a8 bdf81a30 adf82830  .#..$0.....0..(0
 13c70 59460b96 b847b368 5bb30025 b3685859  YF...G.h[..%.hXY
 13c80 38b3fff7 cbfd049b 1b6803eb c0000090  8........h......
 13c90 012142f6 020013aa 634b07f0 c3fb0435  .!B.....cK.....5
 13ca0 0028ebd0 002844d0 012807d1 08f10108  .(...(D..(......
 13cb0 a2e7b9f1 000f04d1 0320fbe0 002840f0  ......... ...(@.
 13cc0 f980029b 4b440293 8ee70020 f2e00620  ....KD..... ... 
 13cd0 f0e0f568 2db11835 55f8183c a5f1180a  ...h-..5U..<....
 13ce0 23b9524a d3680133 d36022e0 55f8143c  #.RJ.h.3.`".U..<
 13cf0 0bb90324 18e035f8 080cfff7 09fe40b1  ...$..5.......@.
 13d00 4b4a4649 13688988 8b4200f3 cf800133  KJFI.h...B.....3
 13d10 1360cdf8 00a042f6 03000121 07aa454b  .`....B....!..EK
 13d20 07f080fb 044678b1 1835002c d4d02046  .....Fx..5.,.. F
 13d30 b8e7039a bdf81a30 938007f0 87fb039b  .......0........
 13d40 09f10109 d880b1e7 35f8083c cdf800a0  ........5..<....
 13d50 c3f34001 13f00c0f 1cbf41f0 0201c9b2  ..@.......A.....
 13d60 980548bf 41f00401 5a0548bf 41f00801  ..H.A...Z.H.A...
 13d70 1c0548bf 41f01001 d80448bf 41f02001  ..H.A.....H.A. .
 13d80 9a0448bf 41f04001 5b0448bf 41f08001  ..H.A.@.[.H.A...
 13d90 55f8180c 284b0df1 1e0207f0 09fb0446  U...(K.........F
 13da0 0028c1d1 55f8043c 13b1bdf8 1e201a80  .(..U..<..... ..
 13db0 87b10223 8df83830 bdf81c30 adf83c30  ...#..80...0..<0
 13dc0 0ea8bdf8 1e30adf8 3e305946 1196cdf8  .....0..>0YF....
 13dd0 40a0b847 35f8080c fff79afd 28b955f8  @..G5.......(.U.
 13de0 0cccbcf1 000f53d1 55e042f6 021013a9  ......S.U.B.....
 13df0 04f068fb 60b90090 032113a8 08aa0f4b  ..h.`....!.....K
 13e00 07f0d6fa 20b9094a 53690133 5361e6e7  .... ..JSi.3Sa..
 13e10 0028e4d0 4ce000bf f0200020 783b0020  .(..L.... . x;. 
 13e20 ec200020 75380100 a9380100 e83a0020  . . u8...8...:. 
 13e30 e8200020 75390100 dd410100 493a0100  . . u9...A..I:..
 13e40 9cf80410 1d4bcdf8 00c00df1 2202cdf8  .....K......"...
 13e50 14c007f0 adfaddf8 14c048bb 97b10323  ..........H....#
 13e60 8df84c30 13a8bdf8 2230cdf8 54c05946  ..L0...."0..T.YF
 13e70 cdf814c0 adf85030 1796cdf8 58a0b847  ......P0....X..G
 13e80 ddf814c0 0e4a5369 01335361 0cf1100c  .....JSi.3Sa....
 13e90 dcf80000 20b90a4a 13690133 136143e7  .... ..J.i.3.aC.
 13ea0 dcf80830 002bcbd1 032001e0 06243be7  ...0.+... ...$;.
 13eb0 044639e7 19b0bde8 f08f00bf 193a0100  .F9..........:..
 13ec0 e83a0020 f0b50646 85b000f0 3bfc3046  .:. ...F....;.0F
 13ed0 01f0e0f9 044620b1 0023856b c76b8363  .....F ..#.k.k.c
 13ee0 c36300f0 37fc0cb3 3046fff7 bef9edb1  .c..7...0F......
 13ef0 0024bc42 13da05eb 840335f8 24109b78  .$.B......5.$..x
 13f00 5bb10022 03f00200 00920190 02923046  [.."..........0F
 13f10 022203f0 0103fef7 67fa0134 e9e70448  ."......g..4...H
 13f20 294605b0 bde8f040 f6f77aba 05b0f0bd  )F.....@..z.....
 13f30 00210020 70b5204b 1a6886b0 0ab90020  .!. p. K.h..... 
 13f40 37e01e4b 1e489988 1e4b0093 1e4b91fb  7..K.H...K...K..
 13f50 f2f11b68 9200f6f7 1bfa0446 30bb1848  ...h.......F0..H
 13f60 1a4ef6f7 49fa3060 10b342f6 030002a9  .N..I.0`..B.....
 13f70 04f0a8fa 25462846 02a94ff6 ff7207f0  ....%F(F..O..r..
 13f80 89fa0546 0028dad0 eb69188a fff7c0fc  ...F.(...i......
 13f90 0028f0d0 eb8a3168 013301eb 840221f8  .(....1h.3....!.
 13fa0 24300023 d0709370 0134e4e7 0b2000e0  $0.#.p.p.4... ..
 13fb0 062006b0 70bd00bf e8200020 783b0020  . ..p.... . x;. 
 13fc0 00210020 f8f90100 fc200020 f8200020  .!. ..... . . . 
 13fd0 054b1b68 33b1054b 98680028 d4bf0020  .K.h3..K.h.(... 
 13fe0 01207047 01207047 e8200020 00210020  . pG. pG. . .!. 
 13ff0 38b50c4d 2b68002b 04460ddd 0a48f6f7  8..M+h.+.F...H..
 14000 fbf92060 60b12d68 084baa00 1968f4f7  .. ``.-h.K...h..
 14010 f5ff6560 002038bd 00202060 606038bd  ..e`. 8..  ```8.
 14020 062038bd e8200020 00210020 f8200020  . 8.. . .!. . . 
 14030 70b50646 00f086fb 304601f0 2bf90446  p..F....0F..+..F
 14040 90b1c06b 00228242 0cdaa36b 03eb8203  ...k.".B...k....
 14050 99780d06 04d501f0 7f011d88 997004e0  .x...........p..
 14060 0132f0e7 002500e0 054600f0 73fb34b1  .2...%...F..s.4.
 14070 3db13046 2946bde8 7040fff7 f9b80720  =.0F)F..p@..... 
 14080 70bd0520 70bd0000 2de9ff41 294b1c68  p.. p...-..A)K.h
 14090 80462046 0f46fff7 d9fb421c 2ad08600  .F F.F....B.*...
 140a0 3444e378 9b0725d5 00f04cfb 404601f0  4D.x..%...L.@F..
 140b0 f1f8b0f8 4020ba42 10d190f8 4430856b  ....@ .B....D0.k
 140c0 002403f0 0403a0f8 404003f0 ff013bb1  .$......@@....;.
 140d0 2e4496f9 0230a342 12da02e0 052401e0  .D...0.B.....$..
 140e0 0c462546 00f036fb 34b93db1 684604f0  .F%F..6.4.=.hF..
 140f0 73f901e0 05201ae0 204618e0 284616e0  s.... .. F..(F..
 14100 83798df8 06300346 012553f8 080f0090  .y...0.F.%S.....
 14110 9b88adf8 0430adf8 0820b378 adf80a30  .....0... .x...0
 14120 9df80c30 64f30003 8df80c30 dae704b0  ...0d......0....
 14130 bde8f081 f8200020 f0b5274b 07463946  ..... . ..'K.F9F
 14140 89b01868 fff782fb 411c0446 42d000f0  ...h....A..FB...
 14150 f9faa400 00263046 01f0c8f8 054638b1  .....&0F.....F8.
 14160 836b2344 01369a78 62f07f02 9a70f2e7  .k#D.6.xb....p..
 14170 00f0f0fa 00f082fb ff238df8 0a30adf8  .........#...0..
 14180 0c708df8 0e5001a8 04a904f0 1ff908bb  .p...P..........
 14190 00f0d8fa 9df81600 04a901f0 91f820b1  .............. .
 141a0 bdf81a40 c4f34004 00e00124 00f0d2fa  ...@..@....$....
 141b0 54b19df8 1c30da07 06d443f0 010304a8  T....0....C.....
 141c0 8df81c30 04f008f9 9df80e30 01338df8  ...0.......0.3..
 141d0 0e30d8e7 09b0f0bd f8200020 7fb59a1e  .0....... . ....
 141e0 53425341 0d46099e 8df80430 104a1bb9  SBSA.F.....0.J..
 141f0 536a0133 536202e0 936a0133 9362089b  Sj.3Sb...j.3.b..
 14200 03937468 02962946 01aab368 a0470446  ..th..)F...h.G.F
 14210 58b99df8 0430012b 07d1308a fff778fb  X....0.+..0...x.
 14220 20b1681e 80b2fff7 87ff2046 04b070bd   .h....... F..p.
 14230 e83a0020 2de9f047 00251d4b 1b689d42  .:. -..G.%.K.h.B
 14240 33da1c4b 186830f8 25804146 fff7fefa  3..K.h0.%.AF....
 14250 431c28d0 86000027 00f074fa 384601f0  C.(....'..t.8F..
 14260 45f80446 40b1816b 40303144 fff76cfb  E..F@..k@01D..l.
 14270 b4f80490 824602e0 82464ff6 ff7900f0  .....F...FO..y..
 14280 69fa84b1 baf11b0f 07d0baf1 1d0f08d1  i...............
 14290 48464146 fef7ecff 03e04846 4146fef7  HFAF......HFAF..
 142a0 d5ff0137 d8e70135 c7e7bde8 f08700bf  ...7...5........
 142b0 e8200020 f8200020 70b50546 8cb000f0  . . . . p..F....
 142c0 41fa2846 00f0e6ff 83798df8 1a300346  A.(F.....y...0.F
 142d0 53f8080f 05909b88 adf81830 0023adf8  S..........0.#..
 142e0 1c308df8 1e3000f0 35fa05a8 08a904f0  .0...0..5.......
 142f0 6df80028 53d100f0 25fa2846 00f0caff  m..(S...%.(F....
 14300 846bbdf8 28100646 2046fff7 9ffa411c  .k..(..F F....A.
 14310 01d10024 11e014eb 8001fad0 9df82a30  ...$..........*0
 14320 8b709df8 2c20d207 f3d563f0 7f038b70  .p.., ....c....p
 14330 06f14000 fff708fb 044600f0 0bfa9df8  ..@......F......
 14340 2a20bdf8 28105ab1 02f00103 009302f0  * ..(.Z.........
 14350 02020023 02920193 28460322 fef744f8  ...#....(F."..D.
 14360 1b2c07d0 1d2c14d1 2846bdf8 2810fef7  .,...,..(F..(...
 14370 7fff0ee0 2846bdf8 2810fef7 67ff40b9  ....(F..(...g.@.
 14380 9df82c30 60f30003 08a88df8 2c3004f0  ..,0`.......,0..
 14390 23f89df8 1e300133 8df81e30 a5e70cb0  #....0.3...0....
 143a0 70bd10b5 03783bb1 013b012b 01d90320  p....x;..;.+... 
 143b0 10bd4368 13b9fae7 184610bd 0b880133  ..Ch.....F.....3
 143c0 0b804b89 01334b81 836843b9 c36823b1  ..K..3K..hC..h#.
 143d0 1a6812b1 5a6872b9 e9e71030 e2e7043b  .h..Zhr....0...;
 143e0 53f8042f 002af1d0 4a880132 4a804a89  S../.*..J..2J.J.
 143f0 01324a81 f4e78a88 01328a80 4a89941c  .2J......2..J...
 14400 4c811c8a 04f03004 3cb1cc88 0134cc80  L.....0.<....4..
 14410 0c890332 01340c81 4a81da68 6ab11468  ...2.4..J..hj..h
 14420 5cb11032 52f8084c 002cc0d0 cc880134  \..2R..L.,.....4
 14430 cc804c89 01344c81 f1e71833 c8e730b5  ..L..4L....3..0.
 14440 85b00546 0c4601a8 00210c22 f4f7e1fd  ...F.F...!."....
 14450 284601a9 fff7a5ff 88b9bdf8 04206388  (F........... c.
 14460 bdf90c10 13446380 bdf80e20 23891344  .....Dc.... #..D
 14470 23816378 5a1ca388 01fb0233 a38005b0  #.cxZ......3....
 14480 30bd0000 13b5fff7 31fa164a 00231360  0.......1..J.#.`
 14490 154a1360 154b9888 1c4610b9 608848b9  .J.`.K...F..`.H.
 144a0 0fe08000 09f0b6fa 114b1860 0028f5d1  .........K.`.(..
 144b0 062411e0 c00009f0 adfa0e4b 18600028  .$.........K.`.(
 144c0 f6d00d4a 01920023 00930c48 04210a22  ...J...#...H.!."
 144d0 08f03cff 18b10b24 fff708fa 204602b0  ..<....$.... F..
 144e0 10bd00bf e8200020 f8200020 783b0020  ..... . . . x;. 
 144f0 fc200020 f0200020 0ffa0100 e83a0020  . . . . .....:. 
 14500 2de9f04f 044685b0 0e464248 4ff0ff31  -..O.F...FBHO..1
 14510 90461f46 f6f7eafa 204605f0 1df80446  .F.F.... F.....F
 14520 002870d1 3c488021 0af020f8 20b10628  .(p.<H.!.. . ..(
 14530 0cbf1324 0b2466e0 384adff8 e8909369  ...$.$f.8J.....i
 14540 48460133 936104f0 0ff899f8 00b099f8  HF.3.a..........
 14550 01506846 21461022 05f1020a f4f759fd  .PhF!F."......Y.
 14560 bbf10e0f 5ffa8afa 03d0bbf1 0f0f20d0  ...._......... .
 14570 46e0baf1 040f45d9 09f10300 08f087fd  F.....E.........
 14580 033d15f0 ff05adf8 0c000ed0 99f80530  .=.............0
 14590 13b103f5 007300e0 2346012d 009319d0  .....s..#F.-....
 145a0 1f4b0193 013d0295 14e098b1 0c230093  .K...=.......#..
 145b0 10e0baf1 050f25d9 09f10400 99f80250  ......%........P
 145c0 08f065fd adf80c00 15b105f5 007500e0  ..e..........u..
 145d0 25460095 0eb90296 0be0029b 01994345  %F............CE
 145e0 c8bfcdf8 08803046 029ac8bf 0c24f4f7  ......0F.....$..
 145f0 05fd0196 3cb90fb1 029b3b70 009c02e0  ....<.....;p....
 14600 112400e0 0c240348 f6f728fa 204605b0  .$...$.H..(. F..
 14610 bde8f08f 24210020 1c210020 1c3b0020  ....$!. .!. .;. 
 14620 163c0020 103c0020 00210a46 0b46fff7  .<. .<. .!.F.F..
 14630 67bf0000 0248c388 0bb909f0 67bf7047  g....H......g.pG
 14640 1c210020 08b50448 002109f0 57ff0348  .!. ...H.!..W..H
 14650 bde80840 f6f7f8b9 1c210020 24210020  ...@.....!. $!. 
 14660 13b50446 032101a8 05f087f8 01a82146  ...F.!........!F
 14670 01220df1 0303fff7 43ff60b9 9df80330  ."......C.`....0
 14680 012b07d1 23781433 dbb21e2b 8cbf0c20  .+..#x.3...+... 
 14690 002000e0 0c2002b0 10bd7fb5 05460c46  . ... .......F.F
 146a0 01a80321 05f0f1f8 002c17dd 01a802a9  ...!.....,......
 146b0 08220df1 0303fff7 23ff90b9 9df80330  ."......#......0
 146c0 082b0dd1 082c2646 28bf0826 284602a9  .+...,&F(..&(F..
 146d0 3246f4f7 93fca41b 3544e5e7 002000e0  2F......5D... ..
 146e0 0c2004b0 70bd70b5 0d460422 00212b46  . ..p.p..F.".!+F
 146f0 0646f5f7 bdfc0446 78b90421 3046f5f7  .F.....Fx..!0F..
 14700 defc2846 08f0c3fc 2b4623f8 020b1846  ..(F....+F#....F
 14710 08f0bdfc 68802046 70bd0c20 70bd0000  ....h. Fp.. p...
 14720 38b5064c 00252068 09f0bef9 2560044c  8..L.% h....%`.L
 14730 206809f0 b9f92560 38bd00bf 38210020   h....%`8...8!. 
 14740 84210020 02484ff0 ff31f6f7 cfb900bf  .!. .HO..1......
 14750 3c210020 0148f6f7 81b900bf 3c210020  <!. .H......<!. 
 14760 08b50448 f5f766fb 10b1faf7 05fdf8e7  ...H..f.........
 14770 08bd00bf 9c210020 70b50224 1d4df5f7  .....!. p..$.M..
 14780 cff86e68 f5f7d2f8 96b32846 f5f75bfa  ..nh......(F..[.
 14790 4378022b 22d00cd8 012b11d0 012c06d1  Cx.+"....+...,..
 147a0 154b1649 1868bde8 7040f5f7 22ba0124  .K.I.h..p@.."..$
 147b0 e4e7102b 0fd0112b f0d1fff7 3bfd0de0  ...+...+....;...
 147c0 c2692ab9 0e4840f2 09111346 f5f780fa  .i*..H@....F....
 147d0 40689047 e2e704f0 31fddfe7 fff7c0ff  @h.G....1.......
 147e0 0848f5f7 27fb0028 d8d004f0 63fdf7e7  .H..'..(....c...
 147f0 70bd00bf d0210020 34210020 b0210020  p....!. 4!. .!. 
 14800 19fa0100 88210020 6ff00043 98420146  .....!. o..C.B.F
 14810 09d0054b 9a691ab1 1b69c31a 002b02da  ...K.i...i...+..
 14820 0148f5f7 6db97047 48210020 08b58020  .H..m.pGH!. ... 
 14830 fff7eaff fef784fc fff7e6ff fdf73efa  ..............>.
 14840 fff7e2ff 01f03afa fff7deff 02f0e4fc  ......:.........
 14850 bde80840 fff7d8bf 08b50146 0448f5f7  ...@.......F.H..
 14860 c8f9044b 04491868 bde80840 f5f7c1b9  ...K.I.h...@....
 14870 d0210020 34210020 b0210020 0148fff7  .!. 4!. .!. .H..
 14880 ebbf00bf 3c020020 08b5f5f7 31fe064b  ....<.. ....1..K
 14890 80211860 0548f5f7 33f9fff7 4bfbbde8  .!.`.H..3...K...
 148a0 084000f0 39bf00bf 30210020 48210020  .@..9...0!. H!. 
 148b0 10b50246 07490848 f5f7cefa 044630b9  ...F.I.H.....F0.
 148c0 064b0749 1868f5f7 94f92046 10bd0b20  .K.I.h.... F... 
 148d0 10bd00bf d0210020 88210020 34210020  .....!. .!. 4!. 
 148e0 b0210020 10b50246 07490848 f5f7b4fa  .!. ...F.I.H....
 148f0 044630b9 064b0749 1868f5f7 7af92046  .F0..K.I.h..z. F
 14900 10bd0b20 10bd00bf d0210020 9c210020  ... .....!. .!. 
 14910 34210020 b0210020 f7b50446 0e46fff7  4!. .!. ...F.F..
 14920 fffe002c 00f09580 4d4d3046 2c6000f0  ...,....MM0F,`..
 14930 e5fb4c4c 08f000fc 4b4808f0 b5fc4a4a  ..LL....KH....JJ
 14940 4a494b48 08f002fc 27784ff4 827606fb  JIKH....'xO..v..
 14950 07f009f0 5ff8474a 03461060 08b90624  ...._.GJ.F.`...$
 14960 78e0454a 00924548 32463946 f5f710fd  x.EJ..EH2F9F....
 14970 064620b1 42484ff4 d7710022 16e02478  .F .BHO..q."..$x
 14980 04eb4400 800009f0 45f83e4a 03461060  ..D.....E.>J.F.`
 14990 0028e4d0 3c4a0092 3c482146 0c22f5f7  .(..<J..<H!F."..
 149a0 f7fc30b1 364840f2 bb113246 1346f5f7  ..0.6H@...2F.F..
 149b0 8ff93748 f5f714f9 08f0acfc 08b10b24  ..7H...........$
 149c0 48e0fff7 3ffe00f0 e9fc0446 002841d1  H...?......F.(A.
 149d0 01f00cf8 04460028 3cd105f0 35fa0446  .....F.(<...5..F
 149e0 002837d1 08f042f8 04460028 32d1fdf7  .(7...B..F.(2...
 149f0 2ffd0446 70bbfef7 cffe0446 50bbfff7  /..Fp......FP...
 14a00 41fd0446 30bb2146 2248f5f7 03fa2146  A..F0.!F"H....!F
 14a10 2148f5f7 fff9164b 00940193 1f482346  !H.....K.....H#F
 14a20 04210622 08f092fc 04460028 c7d11c48  .!.".....F.(...H
 14a30 29681c4a 2346f5f7 35f81b48 14491b4a  )h.J#F..5..H.I.J
 14a40 2346f5f7 2ff81a48 f5f7feff 0028b6d1  #F../..H.....(..
 14a50 03e00324 fff764fe 204603b0 f0bd00bf  ...$..d. F......
 14a60 34210020 783b0020 68210020 9c3b0020  4!. x;. h!. .;. 
 14a70 22fa0100 38210020 29fa0100 5c3b0020  "...8!. )...\;. 
 14a80 19fa0100 84210020 34fa0100 403b0020  .....!. 4...@;. 
 14a90 d0210020 88210020 9c210020 1c3b0020  .!. .!. .!. .;. 
 14aa0 48210020 2d480100 b0210020 79470100  H!. -H...!. yG..
 14ab0 3c210020 f8b512f0 01040546 0e4611d1  <!. .......F.F..
 14ac0 094b4360 52080272 2b7a9c42 08da06eb  .KC`R..r+z.B....
 14ad0 44006f68 08f0dbfa 27f81400 0134f3e7  D.oh....'....4..
 14ae0 0020f8bd 0a20f8bd dc210020 f8b512f0  . ... ...!. ....
 14af0 03040546 0e4611d1 094bc360 92080274  ...F.F...K.`...t
 14b00 2b7c9c42 08da06eb 8400ef68 08f0c4fa  +|.B.......h....
 14b10 47f82400 0134f3e7 0020f8bd 0a20f8bd  G.$..4... ... ..
 14b20 f8210020 2de9f041 069c9df8 1c509046  .!. -..A.....P.F
 14b30 22780f46 49001e46 c9b2931c 0b44ab42  "x.FI..F.....D.B
 14b40 18dc0131 b1542378 33440025 58702378  ...1.T#x3D.%Xp#x
 14b50 02332370 bd420ada 207838f8 15103044  .3#p.B.. x8...0D
 14b60 08f07afa 23780233 23700135 f2e70020  ..z.#x.3#p.5... 
 14b70 bde8f081 0420bde8 f081f8b5 069c9df8  ..... ..........
 14b80 1ce00f46 2178fdb2 8e1c2e44 764512dc  ...F!x.....DvE..
 14b90 6e1c5e54 26781e44 11467070 20780230  n.^T&x.D.Fpp x.0
 14ba0 c0b22070 3a461844 f4f728fa 23782b44  .. p:F.D..(.#x+D
 14bb0 23700020 f8bd0420 f8bd2de9 ff471e46  #p. ... ..-..G.F
 14bc0 00231370 4378db07 07460d46 144609d5  .#.pCx...F.F.F..
 14bd0 03783bb1 01208de8 50000146 3a462b46  .x;.. ..P..F:F+F
 14be0 fff7cbff 7a682ab9 d7f80ca0 baf1000f  ....zh*.........
 14bf0 11d115e0 397a0029 f6d07b7a 13f0010f  ....9z.)..{z....
 14c00 14bf0320 02208de8 50002b46 fff78aff  ... . ..P.+F....
 14c10 0028e9d0 11e197f8 1090b9f1 000f02d1  .(..............
 14c20 7a6942bb 29e07b7c 207813f0 010f4fea  ziB.).{| x....O.
 14c30 8903dbb2 00f10202 1a4414bf 05210421  .........D...!.!
 14c40 b24200f3 f9800133 2b542378 2b444ff0  .B.....3+T#x+DO.
 14c50 00085970 23780233 2370c845 e0da2078  ..Yp#x.3#p.E.. x
 14c60 5af82810 284408f0 fbf92378 04332370  Z.(.(D....#x.3#p
 14c70 08f10108 f1e7397e 11b9fa69 7ab911e0  ......9~...iz...
 14c80 7b7e13f0 010f14bf 07200620 8de85000  {~....... . ..P.
 14c90 09012b46 fff771ff 0028eed0 cde097f8  ..+F..q..(......
 14ca0 201021b9 97f82330 d8070fd4 25e097f8   .!...#0....%...
 14cb0 213013f0 010f14bf 09200820 8de85000  !0....... . ..P.
 14cc0 2b46fff7 5aff0028 ecd0b6e0 97f82230  +F..Z..(......"0
 14cd0 802b15d1 0df10f00 fff7c2fc 002840f0  .+...........(@.
 14ce0 ac808de8 50000a20 01210df1 0f022b46  ....P.. .!....+F
 14cf0 fff743ff 002840f0 a0807a6a 1ab90ce0  ..C..(@...zj....
 14d00 8df80f30 ede78de8 50000d20 03212b46  ...0....P.. .!+F
 14d10 fff733ff 002840f0 9080ba6a 4ab18de8  ..3..(@....jJ...
 14d20 50001220 04212b46 fff727ff 002840f0  P.. .!+F..'..(@.
 14d30 8480fa6a 4ab197f8 30101620 8de85000  ...jJ...0.. ..P.
 14d40 2b46fff7 1aff0028 77d17a6b 12b197f8  +F.....(w.zk....
 14d50 381021b9 97f83c30 d90717d5 0be001eb  8.!...<0........
 14d60 41018de8 50001720 49002b46 fff705ff  A...P.. I.+F....
 14d70 0028efd0 61e08de8 50001920 022107f1  .(..a...P.. .!..
 14d80 3a022b46 fff7f9fe 002856d1 97f84030  :.+F.....(V...@0
 14d90 da070ad5 8de85000 1a200121 07f13e02  ......P.. .!..>.
 14da0 2b46fff7 bffe0028 47d17a6c 42b18de8  +F.....(G.zlB...
 14db0 50001b20 07212b46 fff7dffe 00283cd1  P.. .!+F.....(<.
 14dc0 97f84930 db0709d5 8de85000 1c200121  ..I0......P.. .!
 14dd0 07f14802 2b46fff7 d0fe70bb fa6c42b1  ..H.+F....p..lB.
 14de0 97f85010 20208de8 50002b46 fff7c5fe  ..P.  ..P.+F....
 14df0 18bb7a6d 42b197f8 58102120 8de85000  ..zmB...X.! ..P.
 14e00 2b46fff7 bafec0b9 fa6d42b1 97f86010  +F.......mB...`.
 14e10 24208de8 50002b46 fff7affe 68b97a6e  $ ..P.+F....h.zn
 14e20 0ab91046 09e097f8 68102b46 8de85000  ...F....h.+F..P.
 14e30 ff20fff7 a2fe00e0 042004b0 bde8f087  . ....... ......
 14e40 f8b50d46 17460021 6c220446 f4f7e1f8  ...F.F.!l".F....
 14e50 002f00f0 08812a78 561cf6b2 b742c0f0  ./....*xV....B..
 14e60 0481013a d2b21c2a 687800f2 00810d28  ...:...*hx.....(
 14e70 05f10201 00f0a080 1ed80528 64d00ed8  ...........(d...
 14e80 02284cd0 02d80128 3fd0e8e0 032850d0  .(L....(?....(P.
 14e90 042840f0 e4802046 fff728fe 42e00828  .(@... F..(.B..(
 14ea0 6cd004d8 062853d0 07285cd0 d7e00928  l....(S..(\....(
 14eb0 6cd00a28 74d0d2e0 1b2800f0 b1800fd8  l..(t....(......
 14ec0 172800f0 878004d8 122879d0 16287bd0  .(.......(y..({.
 14ed0 c5e01928 00f08a80 1a2800f0 9480bee0  ...(.....(......
 14ee0 212800f0 b38006d8 1c2800f0 9d802028  !(.......(.... (
 14ef0 00f0a680 b3e02428 00f0ae80 ff2840f0  ......$(.....(@.
 14f00 ae806166 84f86820 a9e0012a 40f0af80  ..af..h ...*@...
 14f10 ab782370 637843f0 01036370 9fe02046  .x#pcxC...cp.. F
 14f20 fff7c8fd 002840f0 a380637a 6ff30003  .....(@...czo...
 14f30 08e02046 fff7befd 002840f0 9980637a  .. F.....(@...cz
 14f40 43f00103 63728ae0 2046fff7 cffdf3e7  C...cr.. F......
 14f50 12f00f00 40f08b80 637e6161 12092276  ....@...c~aa.."v
 14f60 60f30003 08e01307 40f08180 637e6161  `.......@...c~aa
 14f70 12092276 43f00103 637670e0 94f82130  .."vC...cvp...!0
 14f80 e16184f8 20206ff3 000306e0 94f82130  .a..  o.......!0
 14f90 e16184f8 202043f0 010384f8 21305ee0  .a..  C.....!0^.
 14fa0 012a65d1 ab7884f8 223094f8 233043f0  .*e..x.."0..#0C.
 14fb0 010384f8 233052e0 032a58d1 61624ee0  ....#0R..*X.abN.
 14fc0 042a54d1 a1624ae0 012a50d9 e16284f8  .*T..bJ..*P..b..
 14fd0 302044e0 0623b2fb f3f003fb 102212f0  0 D..#......."..
 14fe0 ff0f44d1 616384f8 380038e0 022a3ed1  ..D.ac..8.8..*>.
 14ff0 084608f0 4cf894f8 3c306087 43f00103  .F..L...<0`.C...
 15000 84f83c30 2be0022a 31d10846 08f03ff8  ..<0+..*1..F..?.
 15010 94f84030 e08743f0 010384f8 40301ee0  ..@0..C.....@0..
 15020 072a24d1 61641ae0 012a20d1 ab7884f8  .*$.ad...* ..x..
 15030 483094f8 493043f0 010384f8 49300ee0  H0..I0C.....I0..
 15040 032a14d9 e16484f8 502008e0 0f2a0ed9  .*...d..P ...*..
 15050 616584f8 582002e0 e16584f8 6020b81b  ae..X ...e..` ..
 15060 3544c7b2 f4e63846 f8bd0420 f8bd0a20  5D....8F... ... 
 15070 f8bd10b5 0446fff7 65fb2046 00f00af9  .....F..e. F....
 15080 044620b1 00f0f4f8 204600f0 99f8fff7  .F ..... F......
 15090 61fb002c 0cbf0720 002010bd 38b50546  a..,... . ..8..F
 150a0 0c46fff7 4ffb2846 00f0f4f8 28b12cb1  .F..O.(F....(.,.
 150b0 90f82130 23700024 00e00724 fff74afb  ..!0#p.$...$..J.
 150c0 204638bd 70b50646 0d461446 fff73afb   F8.p..F.F.F..:.
 150d0 304600f0 dff860b1 90f82130 24b12b43  0F....`...!0$.+C
 150e0 80f82130 002405e0 23ea0503 80f82130  ..!0.$..#.....!0
 150f0 00e00724 fff72efb 204670bd 38b50146  ...$.... Fp.8..F
 15100 114cc8b9 24222046 f3f783ff 20201023  .L..$" F....  .#
 15110 a0804020 08210122 6380a371 2081e372  ..@ .!."c..q ..r
 15120 06200323 a3732170 4ff49673 6270a072  . .#.s!pO..sbp.r
 15130 21736273 238438bd 05460fcd 0fc40fcd  !sbs#.8..F......
 15140 0fc42b68 236038bd 783b0020 08b5084b  ..+h#`8.x;. ...K
 15150 9b68002b 09dd074b 9b68022b 05ddfef7  .h.+...K.h.+....
 15160 37ff0030 18bf0120 08bd0020 08bd00bf  7..0... ... ....
 15170 18220020 c03b0020 406a28b1 83888b42  .". .;. @j(....B
 15180 04d002d8 0068f8e7 70470020 704770b5  .....h..pG. pGp.
 15190 446a0023 224622b1 96888d88 ae420cd0  Dj.#"F"......B..
 151a0 03d92bb9 0c604162 05e01346 1268f2e7  ..+..`Ab...F.h..
 151b0 1a680a60 19600020 70bd0220 70bd0000  .h.`.`. p.. p...
 151c0 10b50446 b0b13030 07f086f9 606a48b1  ...F..00....`jH.
 151d0 a36a8342 04bf0023 a3620368 636200f0  .j.B...#.b.hcb..
 151e0 2bfbf3e7 04482146 f5f71af9 034a1369  +....H!F.....J.i
 151f0 01331361 10bd00bf 18220020 1c3b0020  .3.a.....". .;. 
 15200 10b51948 f5f7f8f8 044640b3 00215022  ...H.....F@..!P"
 15210 f3f7fffe 00236362 04f004fe 0146f0b1  .....#cb.....F..
 15220 2046fff7 b4ffd0b9 00f03afd 0146b0b1   F........:..F..
 15230 2046fff7 acff90b9 02f050f9 014670b1   F........P..Fp.
 15240 2046fff7 a4ff50b9 04f13800 fef7d0fe   F....P...8.....
 15250 28b9064a d3680133 d3602046 10bd2046  (..J.h.3.` F.. F
 15260 fff7aeff 002010bd 18220020 1c3b0020  ..... ...". .;. 
 15270 074a1368 834202d1 1b681360 70471a68  .J.h.B...h.`pG.h
 15280 824201d0 1346fae7 02681a60 704700bf  .B...F...h.`pG..
 15290 34220020 034b1b68 13b19a88 8242fad1  4". .K.h.....B..
 152a0 18467047 34220020 10b50446 8088fff7  .FpG4". ...F....
 152b0 f1ff024b 1a682260 1c6010bd 34220020  ...K.h"`.`..4". 
 152c0 094b70b5 1c680546 0e465cb1 a379ab42  .Kp..h.F.F\..y.B
 152d0 06d104f1 08003146 0622f3f7 81fe08b1  ......1F."......
 152e0 2468f2e7 204670bd 34220020 054b1b68  $h.. Fp.4". .K.h
 152f0 002223b1 824202d0 01321b68 f9e71846  ."#..B...2.h...F
 15300 704700bf 34220020 08b5fff7 c3ff0030  pG..4". .......0
 15310 18bf0120 08bd0000 70b50546 c0790c46  ... ....p..F.y.F
 15320 00f042f9 04f10801 60700022 00f076f8  ..B.....`p."..v.
 15330 30b10022 174840f2 47111346 f4f7c8fc  0..".H@.G..F....
 15340 05f10e06 30461449 0622f3f7 49fe20b9  ....0F.I."..I. .
 15350 63782370 a3686360 02e0eb79 23706660  cx#p.hc`...y#pf`
 15360 ab79a370 05f10803 2361aa79 032a0fd8  .y.p....#a.y.*..
 15370 dfe802f0 0204080a 002200e0 0122e270  ........."...".p
 15380 e36070bd 002300e0 01231435 e370e560  .`p..#...#.5.p.`
 15390 70bd00bf 68fa0100 38220020 73b5124c  p...h...8". s..L
 153a0 206808f0 81fb114b 5e7806eb 86000001   h.....K^x......
 153b0 08f030fb 25460346 206050b1 0c4a0092  ..0.%F.F `P..J..
 153c0 0c483146 5022f4f7 e3ff20b9 0a4b1860  .H1FP".... ..K.`
 153d0 08e00624 00e00b24 286808f0 65fb0023  ...$...$(h..e..#
 153e0 2b602046 02b070bd 14220020 783b0020  +` F..p..". x;. 
 153f0 76fa0100 18220020 34220020 10b50446  v....". 4". ...F
 15400 fff7a0f9 044b2268 1a60a288 9a80bde8  .....K"h.`......
 15410 1040fff7 9fb900bf 3e220020 f8b50f46  .@......>". ...F
 15420 144648b1 012815d1 0c4e7379 13f0c00f  .FH..(...Nsy....
 15430 0cbf0125 002501e0 094e0546 30460949  ...%.%...N.F0F.I
 15440 0622f3f7 cdfd38b1 07b13e60 04b12560  ."....8...>`..%`
 15450 0020f8bd 0320f8bd 1520f8bd 44220020  . ... ... ..D". 
 15460 3e220020 a83b0020 07b50328 14d8dfe8  >". .;. ...(....
 15470 00f00202 07070021 0a46fff7 cfff0ee0  .......!.F......
 15480 00f092f8 002101aa fff7c8ff 38b9019b  .....!......8...
 15490 23b900f0 d1f802e0 032000e0 152003b0  #........ ... ..
 154a0 5df804fb 30b50546 85b00024 2b8a9c42  ]...0..F...$+..B
 154b0 11da2146 01220df1 0f032846 f4f7d8fd  ..!F."....(F....
 154c0 9df80f30 00930548 054b0421 002207f0  ...0...H.K.!."..
 154d0 abfe0134 eae705b0 30bd00bf 9c3b0020  ...4....0....;. 
 154e0 87fa0100 73b50546 0e460446 631bb342  ....s..F.F.Fc..B
 154f0 09da14f8 013b0093 0448054b 04210022  .....;...H.K.!."
 15500 07f092fe f2e702b0 70bd00bf 9c3b0020  ........p....;. 
 15510 87fa0100 002008b5 0146f4f7 0afd28b1  ..... ...F....(.
 15520 82681288 072a03d8 f4f719fd 002008bd  .h...*....... ..
 15530 02680832 026008bd 10b50446 0068038a  .h.2.`.....F.h..
 15540 8b4208db 89b2f4f7 c1fe0028 20600cbf  .B.........( `..
 15550 06200020 10bd0a20 10bdf8b5 0f461546  . . ... .....F.F
 15560 1c46fff7 97fe0646 40b13946 fff704fe  .F.....F@.9F....
 15570 03460028 0cbf0720 002001e0 07203346  .F.(... . ... 3F
 15580 05b12e60 04b12360 f8bd37b5 15461c46  ...`..#`..7..F.F
 15590 01aa6b46 fff7e1ff 0db1019b 2b600cb1  ..kF........+`..
 155a0 009b2360 03b030bd 012801d0 032801d1  ..#`..0..(...(..
 155b0 01207047 00207047 07b5c0b2 01a90422  . pG. pG......."
 155c0 04f0c6f9 014620b9 01a80a46 0b46fef7  .....F ....F.F..
 155d0 97ff03b0 5df804fb 10b596b0 0368cdf8  ....]........h..
 155e0 05308388 adf80930 124b8df8 041003f1  .0.....0.K......
 155f0 10000df1 0b0153f8 044b41f8 044b8342  ......S..KA..K.B
 15600 f9d10df1 1b0302f1 100152f8 040b43f8  ..........R...C.
 15610 040b8a42 f9d10ba9 01a82a22 04f062f9  ...B......*"..b.
 15620 014620b9 0ba80a46 0b46fef7 69ff16b0  .F ....F.F..i...
 15630 10bd00bf ae3b0020 13b5084c 23784bb9  .....;. ...L#xK.
 15640 074b6946 188c0522 04f092f9 18b90123  .KiF...".......#
 15650 237000e0 002002b0 10bd00bf 4a220020  #p... ......J". 
 15660 783b0020 30b587b0 04460021 02a81022  x;. 0....F.!..."
 15670 f3f7cffc 64b12346 03f11005 02ac1868  ....d.#F.......h
 15680 59682246 03c20833 ab421446 f7d10be0  Yh"F...3.B.F....
 15690 1c4b02ac 03f11005 18685968 224603c2  .K.......hYh"F..
 156a0 0833ab42 1446f7d1 174802a9 1022f3f7  .3.B.F...H..."..
 156b0 97fc20b3 144c02ab 06ad1a46 03caaa42  .. ..L.....F...B
 156c0 20606160 134604f1 0804f6d1 0020fff7   `a`.F....... ..
 156d0 73ff0321 684604f0 32f90146 20b96846  s..!hF..2..F .hF
 156e0 0a460b46 fef70cff 0120fff7 65ff0021  .F.F..... ..e..!
 156f0 6846054a 0091adf8 0410fff7 6dff07b0  hF.J........m...
 15700 30bd00bf 8ffa0100 ae3b0020 014b0360  0........;. .K.`
 15710 00207047 ae3b0020 10b586b0 03a80321  . pG.;. .......!
 15720 04f022f8 03a8fef7 7fff0028 61d136a1  .."........(a.6.
 15730 d1e90001 03aa0b23 03f0a3ff 03a8fef7  .......#........
 15740 73ff48b9 4ff40000 002103aa 0b2303f0  s.H.O....!...#..
 15750 aaff03a8 fef768ff 044610b1 2848cb21  ......h..F..(H.!
 15760 3ee040f2 7f200021 03aa0b23 03f0beff  >.@.. .!...#....
 15770 03a8fef7 59ff28b1 2148d121 22461346  ....Y.(.!H.!"F.F
 15780 f4f7a6fa 03a80321 03f0c2ff 03a802a9  .......!........
 15790 03220df1 0703fef7 b3fe50b9 9df80730  ."........P....0
 157a0 032b08d1 02a807f0 72fc9df8 0a1003f0  .+......r.......
 157b0 13fd0446 10b11248 d72111e0 02a80321  ...F...H.!.....!
 157c0 03f0afff 02a803a9 08220df1 0703fef7  ........."......
 157d0 97fe18b9 9df80730 082b03d0 0848df21  .......0.+...H.!
 157e0 0022cce7 0748fff7 09fe2046 fff73aff  ."...H.... F..:.
 157f0 00e00446 204606b0 10bd00bf aff30080  ...F F..........
 15800 9ffa0100 d8000020 ffffffff ff9f0020  ....... ....... 
 15810 10b50748 f4f7f0fd 044638b1 1c220021  ...H.....F8..".!
 15820 f3f7f7fb 034ad368 0133d360 204610bd  .....J.h.3.` F..
 15830 c03b0020 dc3b0020 08b50146 30b10448  .;. .;. ...F0..H
 15840 f4f7eefd 034a1369 01331361 08bd00bf  .....J.i.3.a....
 15850 c03b0020 dc3b0020 037bdb07 01d50389  .;. .;. .{......
 15860 0bb94089 7047c088 984228bf 18467047  ..@.pG...B(..FpG
 15870 38b51546 2b460422 f4f7fafb 044658b9  8..F+F.".....FX.
 15880 284607f0 04fc2b46 23f8020b 184607f0  (F....+F#....F..
 15890 fefb6880 204638bd 042038bd 37b50446  ..h. F8.. 8.7..F
 158a0 0d4601a8 114607f0 d7fb0df1 06002946  .F...F........)F
 158b0 07f0d2fb 20460421 f4f779fc 034610b1  .... F.!..y..F..
 158c0 02680198 10601846 03b030bd 2de9ff41  .h...`.F..0.-..A
 158d0 98460b88 c3f30133 012b0646 17463cd0  .F.....3.+.F.F<.
 158e0 022b5ed1 10460021 03aafff7 c1ff0446  .+^..F.!.......F
 158f0 002857d1 38460421 f4f7e1fb 3046bdf8  .(W.8F.!....0F..
 15900 0e10fff7 39fc0546 e0b9bdf8 0e304ff6  ....9..F.....0O.
 15910 ff729342 14d00093 2748284b 04212246  .r.B....'H(K.!"F
 15920 07f082fc 05213046 fff726fc 014638b1  .....!0F..&..F8.
 15930 bdf80e30 00933046 22462346 00f074fa  ...0..0F"F#F..t.
 15940 05242fe0 006918b1 f4f709fb b4622c61  .$/..i.......b,a
 15950 bdf80c30 b562ab82 03e0856a 0db32b69  ...0.b.....j..+i
 15960 fbb12869 08b92f61 02e03946 f4f763fc  ..(i../a..9F..c.
 15970 2869ac8a 038a1c1b 002c07dd f4f7effa  (i.......,......
 15980 0023b362 0a242b61 ab8213e0 11d1ab69  .#.b.$+a.......i
 15990 c8f80030 0a9b2a69 1a60b462 2c61ac82  ...0..*i.`.b,a..
 159a0 03e00a24 3846f4f7 dafa2046 04b0bde8  ...$8F.... F....
 159b0 f0810124 0027f5e7 9c3b0020 b0fa0100  ...$.'...;. ....
 159c0 10b58988 04461046 128afff7 67ff0146  .....F.F....g..F
 159d0 28b12046 03f0eafc 044608b9 03e00624  (. F.....F.....$
 159e0 0020f4f7 bcfa2046 10bd0000 73b51b4c  . .... F....s..L
 159f0 206808f0 59f81a4b de7ac6eb c6008000   h..Y..K.z......
 15a00 08f008f8 25460346 2060e8b1 154a0092  ....%F.F `...J..
 15a10 15483146 1c22f4f7 bbfc08b1 0b2414e0  .H1F.".......$..
 15a20 00f082f9 044680b9 01f07afd 044660b9  .....F....z..F`.
 15a30 0e4b0090 01930e48 04210a22 234607f0  .K.....H.!."#F..
 15a40 85fc0028 ead106e0 06242868 08f02cf8  ...(.....$(h..,.
 15a50 00232b60 204602b0 70bd00bf 4c220020  .#+` F..p...L". 
 15a60 783b0020 d1fa0100 c03b0020 e5fa0100  x;. .....;. ....
 15a70 dc3b0020 08207047 30b52a4a 936a0c46  .;. . pG0.*J.j.F
 15a80 013387b0 93620421 0022274b 05462748  .3...b.!."'K.F'H
 15a90 07f0cafb 2068fff7 05fd2448 244b0421  .... h....$H$K.!
 15aa0 002207f0 c1fb2046 0421fff7 45fd0028  .".... F.!..E..(
 15ab0 36d12368 03aa1868 d98800f0 8af92068  6.#h...h...... h
 15ac0 0421f4f7 fcfa2368 1a8abdf8 0e309a42  .!....#h.....0.B
 15ad0 25d19df8 0c30172b 03d8164a 52f82330  %....0.+...JR.#0
 15ae0 c3b9fef7 2ffe2846 052105aa 04abfff7  ..../.(F.!......
 15af0 4cfd0446 48b90090 01909df8 0d200598  L..FH........ ..
 15b00 04992346 00f06cf9 00e00724 fef722fe  ..#F..l....$..".
 15b10 204605e0 284603a9 22469847 00e00a20   F..(F.."F.G... 
 15b20 07b030bd dc3b0020 48fb0100 9c3b0020  ..0..;. H....;. 
 15b30 ecfd0100 f0fa0100 f0b50446 8bb00d46  ...........F...F
 15b40 10460821 1646fff7 f7fc0028 56d12046  .F.!.F.....(V. F
 15b50 0df10b01 fff7a2fa 00284fd1 9df80b30  .........(O....0
 15b60 03f00103 83f00107 0bb90026 29e03368  ...........&).3h
 15b70 05aa1868 d98800f0 67f9bdf8 1430adf8  ...h....g....0..
 15b80 1c30bdf8 1630adf8 1e30bdf8 1830adf8  .0...0...0...0..
 15b90 2030bdf8 1a30adf8 22301023 adf82430   0...0.."0.#..$0
 15ba0 20464ff4 407307a9 adf82630 fcf770f8   FO.@s....&0..p.
 15bb0 30b92046 07a9fcf7 25fb0028 d5d01de0  0. F....%..(....
 15bc0 0126fef7 bffd2046 052104aa 03abfff7  .&.... F.!......
 15bd0 dcfc0446 78b96a78 37b90498 03993346  ...Fx.jx7.....3F
 15be0 00f03ef9 044606e0 00900190 03990498  ..>..F..........
 15bf0 234600f0 f5f8fef7 adfd2046 0bb0f0bd  #F........ F....
 15c00 f7b51646 07464d78 fef79cfd 214b1a68  ...F.FMx....!K.h
 15c10 144674b1 2189b942 04d1a17a 11b9e17a  .Ft.!..B...z...z
 15c20 a94201d0 2468f4e7 11681960 194a01b9  .B..$h...h.`.J..
 15c30 5260fef7 8ffdf4b1 30460221 fff77cfc  R`......0F.!..|.
 15c40 0546d0b9 336801aa 1868d988 00f005f9  .F..3h...h......
 15c50 bdf80430 1bb1012b 11d00a25 0de02e46  ...0...+...%...F
 15c60 e36813b1 28462169 98470b48 2146f4f7  .h..(F!i.G.H!F..
 15c70 d7fb3046 0be00520 09e02b46 00e01023  ..0F... ..+F...#
 15c80 0649ca69 01322e46 ca611d46 e8e703b0  .I.i.2.F.a.F....
 15c90 f0bd00bf 70220020 50220020 dc3b0020  ....p". P". .;. 
 15ca0 08b5fff7 b5fd30b1 05238380 6423c380  ......0..#..d#..
 15cb0 4381014b 836108bd 795a0100 37b5f4f7  C..K.a..yZ..7...
 15cc0 7ffd02ab 002243f8 082d0546 0193fef7  ....."C..-.F....
 15cd0 39fd134a 13688bb1 93e80300 691a0029  9..J.h......i..)
 15ce0 0adb1468 0e492468 146004b9 49600021  ...h.I$h.`..I`.!
 15cf0 19600199 0b600193 0346ece7 fef72afd  .`...`...F....*.
 15d00 009c4cb1 074a2089 136a1321 01331362  ..L..J ..j.!.3.b
 15d10 fcf7c4f9 2468f4e7 6ff00040 03b030bd  ....$h..o..@..0.
 15d20 70220020 dc3b0020 37b5134d 286807f0  p". .;. 7..M(h..
 15d30 bbfe124b 002283e8 0c00114b 1c7b0cb9  ...K.".....K.{..
 15d40 002016e0 04eb8400 800007f0 63fe0346  . ..........c..F
 15d50 286048b1 0b4a0092 21460b48 1422f4f7  (`H..J..!F.H."..
 15d60 17fb0446 08b9ebe7 06242868 07f09cfe  ...F.....$(h....
 15d70 204603b0 30bd00bf 6c220020 70220020   F..0...l". p". 
 15d80 783b0020 66fb0100 50220020 2de9f047  x;. f...P". -..G
 15d90 089e0024 1c603460 81468846 15461f46  ...$.`4`.F.F.F.F
 15da0 fff7b8fb 824610b9 0620bde8 f087adb2  .....F... ......
 15db0 291df4f7 5dfa0028 f6d080f8 009080f8  )...]..(........
 15dc0 0180031d 4580c7f8 00a02046 3360bde8  ....E..... F3`..
 15dd0 f0870378 13704378 53704388 53807047  ...x.pCxSpC.S.pG
 15de0 f0b585b0 0d460b9c 1f4603a9 a31c0646  .....F...F.....F
 15df0 00910120 1146dab2 02abfff7 c7ff0398  ... .F..........
 15e00 0a9920f8 027b2246 f3f7f8f8 054a936a  .. ..{"F.....J.j
 15e10 01339362 30462946 029afff7 d1fd05b0  .3.b0F)F........
 15e20 f0bd00bf dc3b0020 1fb5adf8 0e3003ab  .....;. .....0..
 15e30 00930423 bdf81840 01930223 adf80c40  ...#...@...#...@
 15e40 fff7ceff 04b010bd 03881380 43885380  ............C.S.
 15e50 83889380 c388d380 70470388 13807047  ........pG....pG
 15e60 7fb51e46 03ab0546 0c460093 11461320  ...F...F.F...F. 
 15e70 022202ab fff78aff 30b9039b 029a1e80  ."......0.......
 15e80 28462146 fff79cfd 04b070bd 034b1a68  (F!F......p..K.h
 15e90 026002b9 58601860 704700bf 78220020  .`..X`.`pG..x". 
 15ea0 40f20742 1a600722 1a717047 037adb06  @..B.`.".qpG.z..
 15eb0 01d402f0 3bb90020 70472de9 f041069c  ....;.. pG-..A..
 15ec0 0f468046 16462046 00215022 1d46f3f7  .F.F.F F.!P".F..
 15ed0 a0f884f8 06803b68 2360bb88 a3802b78  ......;h#`....+x
 15ee0 03f00303 032b22d1 6b882381 d5e90223  .....+".k.#....#
 15ef0 05f12101 c4e90423 05f11103 04f11802  ..!....#........
 15f00 53f8040b 42f8040b 8b42f9d1 94f82830  S...B....B....(0
 15f10 43f00103 003684f8 283094f8 4a3018bf  C....6..(0..J0..
 15f20 012666f3 41036ff3 820384f8 4a302b78  .&f.A.o.....J0+x
 15f30 5a0711d5 05f12103 04f12902 05f13101  Z.....!...)...1.
 15f40 53f8040b 42f8040b 8b42f9d1 94f83930  S...B....B....90
 15f50 43f00103 84f83930 2b781b07 10d505f1  C.....90+x......
 15f60 310304f1 3a024135 53f8041b 42f8041b  1...:.A5S...B...
 15f70 ab42f9d1 94f84a30 43f00103 84f84a30  .B....J0C.....J0
 15f80 bde8f081 70b590b0 4389adf8 20300023  ....p...C... 0.#
 15f90 0022adf8 22300023 cde90a23 0c4600f1  .".."0.#...#.F..
 15fa0 5b020cae 00f16b03 10685168 354603c5  [.....k..hQh5F..
 15fb0 08329a42 2e46f7d1 08a86946 1f2203f0  .2.B.F....iF."..
 15fc0 6dfc6846 fef730fb 30b10823 2371237d  m.hF..0.0..##q#}
 15fd0 206043f0 02032375 10b070bd 10b58cb0   `C...#u..p.....
 15fe0 0446adf8 04000df1 060301f1 100251f8  .F............Q.
 15ff0 040b43f8 040b9142 f9d101a8 06a91522  ..C....B......."
 16000 03f0ddfb 06a80df1 02010222 0df10103  ..........."....
 16010 fef776fa 58b99df8 0130022b 06d1bdf8  ..v.X....0.+....
 16020 0200a042 14bf0c20 002000e0 0c200cb0  ...B... . ... ..
 16030 10bd38b5 05460c46 408905f1 5b01fff7  ..8..F.F@...[...
 16040 cdff2060 10b90523 6b7338bd 237d43f0  .. `...#ks8.#}C.
 16050 02032375 38bd1fb5 052202a9 044603f0  ..#u8...."...F..
 16060 c7fb02a8 0df10601 02220df1 0503fef7  ........."......
 16070 47fa58b9 9df80530 022b06d1 bdf80600  G.X....0.+......
 16080 a04214bf 0c200020 00e00c20 04b010bd  .B... . ... ....
 16090 70b50546 0c461646 40899ab1 02f11801  p..F.F.F@.......
 160a0 fff79cff 206040b9 96f84a30 9b070dd5  .... `@...J0....
 160b0 2b7a43f0 08032b72 08e0237d 43f00203  +zC...+r..#}C...
 160c0 237503e0 fff7c7ff 05232360 23680bb9  #u.......##`#h..
 160d0 06236b73 70bd037a db0601d4 02f0b2b8  .#ksp..z........
 160e0 7047037a db0601d4 02f054b8 70470000  pG.z......T.pG..
 160f0 014610b1 0148f4f7 93b97047 80220020  .F...H....pG.". 
 16100 10b50648 f4f778f9 044620b1 00214ff4  ...H..x..F ..!O.
 16110 8072f2f7 7eff2046 10bd00bf 80220020  .r..~. F.....". 
 16120 30b9074b 1a681268 1a603ab9 5b607047  0..K.h.h.`:.[`pG
 16130 03681b68 03600bb9 014b5860 704700bf  .h.h.`...KX`pG..
 16140 78220020 f0b51d46 1b7d43f0 020387b0  x". ...F.}C.....
 16150 07462b75 10460121 1646fff7 edf90446  .F+u.F.!.F.....F
 16160 286008bb 336805aa 1868d988 01f008fd  (`..3h...h......
 16170 0e4b0093 0e4b0193 0e4b0293 04212246  .K...K...K...!"F
 16180 0d4b0e48 039707f0 4ff805a8 01f0fcfc  .K.H....O.......
 16190 0b4b0a48 04212246 07f046f8 9df81430  .K.H.!"F..F....0
 161a0 0bb103f5 a0642c60 07b0f0bd dafb0100  .....d,`........
 161b0 ddfb0100 e0fb0100 bcfb0100 9c3b0020  .............;. 
 161c0 ecfd0100 f0b5027a 467e837e d70644bf  .......zF~.~..D.
 161d0 06f0fe06 03f0fe03 12f0010f 08bf1e46  ...............F
 161e0 0446f007 9bb00d46 44d50da8 1021fef7  .F.....FD....!..
 161f0 54fa0028 40f0c980 60890da9 01f040fd  T..(@...`.....@.
 16200 002840f0 c28094f8 703043f0 010384f8  .(@.....p0C.....
 16210 70300daf 04f18102 0df1440e 3b4603cb  p0........D.;F..
 16220 73451060 51601f46 02f10802 f6d104a8  sE.`Q`.F........
 16230 0221fef7 32fa0028 40f0a780 06a80821  .!..2..(@......!
 16240 fef72bfa 002840f0 a0806089 04a901f0  ..+..(@...`.....
 16250 81fd0028 40f09980 94f87030 43f00203  ...(@.....p0C...
 16260 84f87030 dde90623 c4e91e23 bdf81030  ..p0...#...#...0
 16270 a4f87230 b10754d5 01a8fff7 47fa0028  ..r0..T.....G..(
 16280 40f08380 019b11aa 03f1100c 96461868  @............F.h
 16290 59681746 03c70833 63453a46 f7d16089  Yh.F...3cE:F..`.
 162a0 714601f0 cbfd0028 6fd194f8 70306089  qF.....(o...p0`.
 162b0 43f00403 84f87030 fef7ecff 002863d0  C.....p0.....(c.
 162c0 15a9fff7 29f89df8 55308df8 0830179b  ....)...U0...0..
 162d0 60891a68 cdf80920 9b88adf8 0d3002a9  `..h... .....0..
 162e0 01f028fe 002850d1 94f87030 43f01003  ..(..(P...p0C...
 162f0 84f87030 019b04f1 910203f1 100153f8  ..p0..........S.
 16300 040b42f8 040b8b42 f9d19df8 083084f8  ..B....B.....0..
 16310 8030ddf8 0930c4f8 b130bdf8 0d30a4f8  .0...0...0...0..
 16320 b5307207 1cd509a8 1021fef7 b6f960bb  .0r......!....`.
 16330 608909a9 01f066fe 38bb94f8 703043f0  `.....f.8...p0C.
 16340 080384f8 703009ae 04f1a102 0daf3346  ....p0........3F
 16350 03cbbb42 10605160 1e4602f1 0802f6d1  ...B.`Q`.F......
 16360 237adb07 01d4a37b b3b96089 fef792ff  #z.....{..`.....
 16370 28b190f8 443043f0 050380f8 4430ff23  (...D0C.....D0.#
 16380 63730023 2b6003e0 07200823 28602b71  cs.#+`... .#(`+q
 16390 2b7d43f0 02032b75 1bb0f0bd 10b588b0  +}C...+u........
 163a0 0c461046 69461f22 03f078fa 6846fef7  .F.FiF."..x.hF..
 163b0 3bf92060 08b010bd 427c1307 06d5c37d  ;. `....B|.....}
 163c0 190742bf 037a43f0 10030372 d20706d5  ..B..zC....r....
 163d0 c37ddb07 42bf037a 43f02003 0372017a  .}..B..zC. ..r.z
 163e0 837e427e 11f0100f 1cbf03f0 fe0302f0  .~B~............
 163f0 fe0211f0 010f08bf 134613f0 010218bf  .........F......
 16400 03228273 9a0742bf 827b42f0 0c028273  .".s..B..{B....s
 16410 5b0742bf 837b43f0 10038373 70470000  [.B..{C....spG..
 16420 37b50546 837b0093 0c46114b 11480421  7..F.{...F.K.H.!
 16430 002206f0 f9feab7b c3b92b7a db0703d5  .".....{..+z....
 16440 237d43f0 010310e0 6889fef7 23ff28b1  #}C.....h...#.(.
 16450 90f84430 43f00503 80f84430 ff236b73  ..D0C.....D0.#ks
 16460 00232360 237d43f0 02032375 03b030bd  .##`#}C...#u..0.
 16470 e5fb0100 9c3b0020 1021fef7 0eb92de9  .....;. .!....-.
 16480 f04186b0 80464089 0c9c0f46 15461e46  .A...F@....F.F.F
 16490 fef700ff 30b301a9 fef73eff 98f80800  ....0.....>.....
 164a0 9df80510 029b9df8 07e0049a 10f00100  ................
 164b0 0cd03970 19682960 9b88ab80 86f800e0  ..9p.h)`........
 164c0 13682360 9388a380 00200ce0 87f800e0  .h#`..... ......
 164d0 17682f60 9288aa80 31701a68 22609b88  .h/`....1p.h"`..
 164e0 a38000e0 072006b0 bde8f081 70b50646  ..... ......p..F
 164f0 0d480068 002590b1 4489b442 0cd1ff29  .H.h.%..D..B...)
 16500 02d0447b 8c4207d1 b2f1ff3f 047a07d0  ..D{.B.....?.z..
 16510 04f00104 a24203d0 05460068 ebe770bd  .....B...F.h..p.
 16520 0bb11d60 70bd70bd 78220020 f0b51021  ...`p.p.x". ...!
 16530 8bb00646 10461c46 1746fef7 fdff0546  ...F.F.F.F.....F
 16540 206030b1 08232371 237d43f0 02032375   `0..##q#}C...#u
 16550 48e03b68 06aa1868 d98801f0 2bfd224b  H.;h...h....+."K
 16560 0093224b 0193224b 02930421 2a46214b  .."K.."K...!*F!K
 16570 21480396 06f058fe 06a801f0 31fd1e48  !H....X.....1..H
 16580 1e4b0421 2a4606f0 4ffefef7 dbf805ab  .K.!*F..O.......
 16590 30460721 4ff0ff32 fff7a8ff 034620b9  0F.!O..2.....F .
 165a0 05232360 08232371 1ae0827b 22f01002  .##`.##q...{"...
 165b0 827300f1 e90606aa 0aaf1546 03cdbd42  .s.........F...B
 165c0 30607160 2a4606f1 0806f6d1 93f8b820  0`q`*F......... 
 165d0 42f00802 83f8b820 18462146 fff720ff  B...... .F!F.. .
 165e0 fef7b8f8 0bb0f0bd dafb0100 ddfb0100  ................
 165f0 fafb0100 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 16600 f0b50721 89b00646 10461c46 1746fef7  ...!...F.F.F.F..
 16610 93ff0546 206030b1 08232371 237d43f0  ...F `0..##q#}C.
 16620 02032375 45e03b68 06aa1868 d98801f0  ..#uE.;h...h....
 16630 45fc214b 0093214b 0193214b 02930421  E.!K..!K..!K...!
 16640 2a46204b 20480396 06f0eefd 06a801f0  *F K H..........
 16650 4bfc1d48 1d4b0421 2a4606f0 e5fdfef7  K..H.K.!*F......
 16660 71f83046 07214ff0 ff3205ab fff73eff  q.0F.!O..2....>.
 16670 20b90523 23600823 237118e0 827b22f0   ..##`.##q...{".
 16680 08028273 90f8b820 42f01002 80f8b820  ...s... B...... 
 16690 9df81820 80f8c820 08aa52f8 071dc0f8  ... ... ..R.....
 166a0 f9109288 a0f8fd20 2146fff7 b9fefef7  ....... !F......
 166b0 51f809b0 f0bd00bf dafb0100 ddfb0100  Q...............
 166c0 04fc0100 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 166d0 f0b51021 8bb00646 10461c46 1746fef7  ...!...F.F.F.F..
 166e0 2bff0546 206030b1 08232371 237d43f0  +..F `0..##q#}C.
 166f0 02032375 48e03b68 06aa1868 d98801f0  ..#uH.;h...h....
 16700 75fb224b 0093224b 0193224b 02930421  u."K.."K.."K...!
 16710 2a46214b 21480396 06f086fd 06a801f0  *F!K!H..........
 16720 7bfb1e48 1e4b0421 2a4606f0 7dfdfef7  {..H.K.!*F..}...
 16730 09f805ab 30460721 4ff0ff32 fff7d6fe  ....0F.!O..2....
 16740 034620b9 05232360 08232371 1ae0827b  .F ..##`.##q...{
 16750 22f00402 827300f1 d90606aa 0aaf1546  "....s.........F
 16760 03cdbd42 30607160 2a4606f1 0806f6d1  ...B0`q`*F......
 16770 93f8b820 42f00402 83f8b820 18462146  ... B...... .F!F
 16780 fff74efe fdf7e6ff 0bb0f0bd dafb0100  ..N.............
 16790 ddfb0100 11fc0100 bcfb0100 9c3b0020  .............;. 
 167a0 ecfd0100 f0b50a21 8bb00646 10461c46  .......!...F.F.F
 167b0 1746fef7 c1fe0546 206030b1 08232371  .F.....F `0..##q
 167c0 237d43f0 02032375 41e03b68 06aa1868  #}C...#uA.;h...h
 167d0 d98801f0 95fa1f4b 00931f4b 01931f4b  .......K...K...K
 167e0 02930421 2a461e4b 1e480396 06f01cfd  ...!*F.K.H......
 167f0 06a801f0 91fa1b48 1b4b0421 2a4606f0  .......H.K.!*F..
 16800 13fdfdf7 9fff3046 07214ff0 ff3205ab  ......0F.!O..2..
 16810 fff76cfe 20b90523 23600823 237114e0  ..l. ..##`.##q..
 16820 827b22f0 02028273 90f8b820 dde90867  .{"....s... ...g
 16830 42f00202 80f8b820 bdf81820 a0f8ba20  B...... ... ... 
 16840 c0e93067 2146fff7 ebfdfdf7 83ff0bb0  ..0g!F..........
 16850 f0bd00bf dafb0100 ddfb0100 19fc0100  ................
 16860 bcfb0100 9c3b0020 ecfd0100 f0b51021  .....;. .......!
 16870 8bb00646 10461c46 1746fef7 5dfe0546  ...F.F.F.F..]..F
 16880 206030b1 08232371 237d43f0 02032375   `0..##q#}C...#u
 16890 48e03b68 06aa1868 d98801f0 c9f9224b  H.;h...h......"K
 168a0 0093224b 0193224b 02930421 2a46214b  .."K.."K...!*F!K
 168b0 21480396 06f0b8fc 06a801f0 cff91e48  !H.............H
 168c0 1e4b0421 2a4606f0 affcfdf7 3bff05ab  .K.!*F......;...
 168d0 30460721 4ff0ff32 fff708fe 034620b9  0F.!O..2.....F .
 168e0 05232360 08232371 1ae0827b 22f00102  .##`.##q...{"...
 168f0 827390f8 b82042f0 010280f8 b82000f1  .s... B...... ..
 16900 c90606aa 0aaf1546 03cdbd42 30607160  .......F...B0`q`
 16910 2a4606f1 0806f6d1 18462146 fff780fd  *F.......F!F....
 16920 fdf718ff 0bb0f0bd dafb0100 ddfb0100  ................
 16930 23fc0100 bcfb0100 9c3b0020 ecfd0100  #........;. ....
 16940 f0b50621 89b00646 10461c46 1746fef7  ...!...F.F.F.F..
 16950 f3fd0546 20600028 5dd13b68 06aa1868  ...F `.(].;h...h
 16960 d98800f0 9fff2d4b 00932d4b 01932d4b  ......-K..-K..-K
 16970 02932a46 04212c4b 2c480396 06f054fc  ..*F.!,K,H....T.
 16980 06a800f0 cbff2a46 2848294b 042106f0  ......*F(H)K.!..
 16990 4bfcfdf7 d7fe3046 ff214ff0 ff3205ab  K.....0F.!O..2..
 169a0 fff7a4fd 054628b1 0598fff7 b9fb2846  .....F(.......(F
 169b0 fff79efb fff7a4fb 054650b3 00234373  .........FP..#Cs
 169c0 4681fff7 63fa0698 bdf81c30 c5f80f00  F...c......0....
 169d0 a5f81330 6889fef7 5dfc18b9 08232371  ...0h...]....##q
 169e0 072307e0 90f82130 db0705d5 07232371  .#....!0.....##q
 169f0 40f20743 23600ce0 06a800f0 60ff20b9  @..C#`......`. .
 16a00 0a232371 40f20a43 f4e7237d 43f00103  .##q@..C..#}C...
 16a10 2375fdf7 9ffe09b0 f0bd00bf dafb0100  #u..............
 16a20 ddfb0100 2cfc0100 bcfb0100 9c3b0020  ....,........;. 
 16a30 ecfd0100 034bdb7b 03f01c00 c3f34003  .....K.{......@.
 16a40 18437047 783b0020 37b50546 0c46fff7  .CpGx;. 7..F.F..
 16a50 f1ff02a9 01f8040d 688901f0 27fb00b1  ........h...'...
 16a60 206003b0 30bd38b1 032803d9 042803d1   `..0.8..(...(..
 16a70 0a207047 01207047 ff207047 10b50446  . pG. pG. pG...F
 16a80 fff714fa c0b2fff7 eeff637b 984206d1  ..........c{.B..
 16a90 207a00f0 0600831f 58425841 10bd0120   z......XBXA... 
 16aa0 10bd0000 f0b51021 8bb00646 10461c46  .......!...F.F.F
 16ab0 1746fef7 41fd0546 206030b1 08232371  .F..A..F `0..##q
 16ac0 237d43f0 02032375 53e03b68 06aa1868  #}C...#uS.;h...h
 16ad0 d98800f0 85ff284b 0093284b 0193284b  ......(K..(K..(K
 16ae0 02932a46 0421274b 27480396 06f09cfb  ..*F.!'K'H......
 16af0 06a800f0 8bff2a46 2348244b 042106f0  ......*F#H$K.!..
 16b00 93fbfdf7 1ffe3046 01214ff0 ff3205ab  ......0F.!O..2..
 16b10 fff7ecfc 054610b9 05232360 27e006ab  .....F...##`'...
 16b20 00f12b06 0aaf1a46 03caba42 30607160  ..+....F...B0`q`
 16b30 134606f1 0806f6d1 2b7adb07 02d50223  .F......+z.....#
 16b40 6b7310e0 2846fff7 b1f9c0b2 fff78bff  ks..(F..........
 16b50 6b7b9842 02bf2b7a 43f00403 2b722846  k{.B..+zC...+r(F
 16b60 fff78cff 18b1237d 43f00103 2375fdf7  ......#}C...#u..
 16b70 f1fd0bb0 f0bd00bf dafb0100 ddfb0100  ................
 16b80 35fc0100 bcfb0100 9c3b0020 ecfd0100  5........;. ....
 16b90 f0b50621 89b00646 10461d46 1746fef7  ...!...F.F.F.F..
 16ba0 cbfc0446 286020b1 2b7d43f0 02032b75  ...F(` .+}C...+u
 16bb0 55e03b68 06aa1868 d98800f0 73fe294b  U.;h...h....s.)K
 16bc0 0093294b 0193294b 02932246 0421284b  ..)K..)K.."F.!(K
 16bd0 28480396 06f028fb 06a800f0 9ffe2246  (H....(......."F
 16be0 2448254b 042106f0 1ffbfdf7 abfd2146  $H%K.!........!F
 16bf0 30460122 05abfff7 79fc0446 68b30698  0F."....y..Fh...
 16c00 bdf81c30 c4f81500 a4f81930 06a800f0  ...0.......0....
 16c10 56fe28b9 0a232b71 40f20a43 2b601ce0  V.(..#+q@..C+`..
 16c20 2046fff7 c9fb237a 13f0100f 14bf0923   F....#z.......#
 16c30 01236373 2046fff7 39f9c6b2 3046fff7  .#cs F..9...0F..
 16c40 12ff637b 984208bf 2e722046 fff716ff  ..c{.B...r F....
 16c50 18b12b7d 43f00103 2b75fdf7 7bfd09b0  ..+}C...+u..{...
 16c60 f0bd00bf dafb0100 ddfb0100 3dfc0100  ............=...
 16c70 bcfb0100 9c3b0020 ecfd0100 2de9f041  .....;. ....-..A
 16c80 07469ab0 0d46fdf7 5dfd3846 ff214ff0  .F...F..].8F.!O.
 16c90 ff3203ab fff72afc 044608b3 2b7dde07  .2....*..F..+}..
 16ca0 0ed5427b 474bd5f8 108053f8 22600021  ..B{GK....S."`.!
 16cb0 18222846 f2f7adf9 20462946 4246b047  ."(F.... F)FBF.G
 16cc0 637b2e68 ff2b00d0 26b10398 fff728fa  c{.h.+..&.....(.
 16cd0 012606e0 f3f774fd 00f57060 606000e0  .&....t...p```..
 16ce0 06462979 11b13846 00f05eff fdf732fd  .F)y..8F..^...2.
 16cf0 002c64d0 2a7d9007 05d53846 2968c2f3  .,d.*}....8F)h..
 16d00 c002fbf7 15fb2b68 33b92b7a 23b13846  ......+h3.+z#.8F
 16d10 05f10801 fbf7e6fa 2b68002b 3fd1002e  ........+h.+?...
 16d20 42d0237a 99063bd5 fdf70cfd 6089fef7  B.#z..;.....`...
 16d30 b1fa94f8 b830da06 054608d5 224604ab  .....0...F.."F..
 16d40 52f8f90f 94f8c870 516803c3 09e08079  R......pQh.....y
 16d50 fef72afc 2b460746 53f8080f 596804aa  ..*.+F.FS...Yh..
 16d60 03c2fdf7 f7fc257a 05f00805 06aeedb2  ......%z........
 16d70 04a92a46 04f17003 38460096 fff79df8  ..*F..p.8F......
 16d80 304601f0 6dfb3846 009604a9 2a4604f1  0F..m.8F....*F..
 16d90 b803fff7 92f83046 01f066fb 00e01eb1  ......0F..f.....
 16da0 2046fff7 a5f90ae0 2b7ddb07 07d52846   F......+}....(F
 16db0 00211822 f2f72df9 01232b75 63e71ab0  .!."..-..#+uc...
 16dc0 bde8f081 68fc0100 2de9f043 87b00746  ....h...-..C...F
 16dd0 89469046 00211822 6846f2f7 1af9fdf7  .F.F.!."hF......
 16de0 b1fc3846 ff214ff0 ff320023 fff77efb  ..8F.!O..2.#..~.
 16df0 044688b3 437b052b 0fd0062b 4ff0ff03  .F..C{.+...+O...
 16e00 23d14373 9df81430 057a43f0 0803c5f3  #.Cs...0.zC.....
 16e10 c0058df8 14300126 3be0b9f1 000f0dd1  .....0.&;.......
 16e20 07234373 037adb07 01d5837b 43b99df8  .#Cs.z.....{C...
 16e30 143043f0 01038df8 143001e0 ff234373  .0C......0...#Cs
 16e40 257a0026 c5f3c005 23e04373 00260823  %z.&....#.Cs.&.#
 16e50 8df80430 35461ce0 b9f1000f 36d14e46  ...05F......6.NF
 16e60 4d463846 fef716fa b8b390f8 443068f3  MF8F........D0h.
 16e70 000380f8 443025b1 dbb243f0 020380f8  ....D0%...C.....
 16e80 443056b3 90f84430 43f00403 80f84430  D0V...D0C.....D0
 16e90 23e0b9f1 000fe4d0 637bff2b 0dd19df8  #.......c{.+....
 16ea0 143043f0 02038df8 1430b9f1 000f02d0  .0C......0......
 16eb0 09f50074 00e04c46 0094fdf7 4bfc3846  ...t..LF....K.8F
 16ec0 6946fff7 dbfe07b0 bde8f083 9df81430  iF.............0
 16ed0 43f00203 8df81430 eae7002c dcd19df8  C......0...,....
 16ee0 143043f0 02038df8 1430e5e7 2de9f041  .0C......0..-..A
 16ef0 184a136b 88b00133 13630646 0c460868  .J.k...3.c.F.F.h
 16f00 01220021 0df10703 f3f7b2f8 8046d8b9  .".!.........F..
 16f10 20680121 f3f7d3f8 9df80750 0e2d15d8   h.!.......P.-..
 16f20 0d4b53f8 25708fb1 41461822 02a8f2f7  .KS.%p..AF."....
 16f30 70f83046 29462246 02abb847 304602a9  p.0F)F"F...G0F..
 16f40 fff79cfe 029802e0 0a2000e0 082008b0  ......... ... ..
 16f50 bde8f081 dc3b0020 80fb0100 03464278  .....;. .....FBx
 16f60 19784088 02f00102 fff72ebf 03460122  .x@..........F."
 16f70 40881978 fff728bf 70b5aab0 00211822  @..x..(.p....!."
 16f80 054608a8 f2f745f8 fdf7dcfb 00222889  .F....E......"(.
 16f90 ff211346 fff7aafa 044668b9 fff7b0f8  .!.F.....Fh.....
 16fa0 044610b9 06230893 52e02b89 43810423  .F...#..R.+.C..#
 16fb0 4373fef7 6bff04e0 437b082b 08d10423  Cs..k...C{.+...#
 16fc0 43739df8 343043f0 01038df8 34303fe0  Cs..40C.....40?.
 16fd0 032b06d1 9df83430 43f00103 8df83430  .+....40C.....40
 16fe0 03e02889 fff737f8 00240026 fdf7b2fb  ..(...7..$.&....
 16ff0 08990cb9 08463de0 21bb1eb3 9df80f40  .....F=.!......@
 17000 20220ea8 f2f705f8 8df83e40 01ab93e8   "........>@....
 17010 03006b89 adf84030 d5e90023 cde91223  ..k...@0...#...#
 17020 9df85030 0e9016ac adf83c10 43f00103  ..P0......<.C...
 17030 21460ea8 8df85030 01f0bcf9 002818bf  !F....P0.....(..
 17040 00240c94 288908a9 fff718fe 002011e0  .$..(........ ..
 17050 2889fef7 1ff910b9 07230893 08e003a9  (........#......
 17060 fef75af9 079b1868 9b880190 adf80830  ..Z....h.......0
 17070 0126bbe7 2ab070bd 037adb07 4cbf3b30  .&..*.p..z..L.;0
 17080 4b307047 f7b52f4f 067abb7b 8df80030  K0pG../O.z.{...0
 17090 fb7bc3f3 00030d46 8df80130 0446fff7  .{.....F...0.F..
 170a0 c9fc06f0 01061023 8df80330 8df80200  .......#...0....
 170b0 397c7b7c 16b18df8 041005e0 e27c1a40  9|{|.........|.@
 170c0 237d8df8 04200b40 60898df8 05303146  #}... .@`....01F
 170d0 6a4600f0 3dfc78bb bdf80430 009826b1  jF..=.x....0..&.
 170e0 c4f80f00 a4f81330 18e0c4f8 1500a4f8  .......0........
 170f0 19302046 fff760f9 237a13f0 100f14bf  .0 F..`.#z......
 17100 09230123 63732046 fef7d0fe c6b23046  .#.#cs F......0F
 17110 fff7a9fc 637b9842 08bf2e72 2046fff7  ....c{.B...r F..
 17120 abfffff7 a9f92860 50b10823 2b712b7d  ......(`P..#+q+}
 17130 43f00203 2b7503e0 28600eb9 08232b71  C...+u..(`...#+q
 17140 03b0f0bd 783b0020 037adb07 4cbf4b30  ....x;. .z..L.K0
 17150 3b307047 f0b51021 8bb00646 10461c46  ;0pG...!...F.F.F
 17160 1746fef7 e9f90546 206030b1 08232371  .F.....F `0..##q
 17170 237d43f0 02032375 40e03b68 06aa1868  #}C...#u@.;h...h
 17180 d98800f0 95fc1e4b 00931e4b 01931e4b  .......K...K...K
 17190 02930421 2a461d4b 03961d48 06f044f8  ...!*F.K...H..D.
 171a0 06a800f0 9bfc1a48 1a4b0421 2a4606f0  .......H.K.!*F..
 171b0 3bf8fdf7 c7fa3046 02214ff0 ff3205ab  ;.....0F.!O..2..
 171c0 fff794f9 064610b9 05232360 14e0fff7  .....F...##`....
 171d0 bbff0aaf 06ab0546 1a4603ca ba422860  .......F.F...B(`
 171e0 69601346 05f10805 f6d1337a db0603d4  i`.F......3z....
 171f0 30462146 01f04df8 fdf7acfa 0bb0f0bd  0F!F..M.........
 17200 dafb0100 ddfb0100 46fc0100 bcfb0100  ........F.......
 17210 9c3b0020 ecfd0100 2de9f341 02aef3f7  .;. ....-..A....
 17220 cffa0024 46f8084d 80460196 fdf78afa  ...$F..M.F......
 17230 1f4991e8 28009de8 01402246 1f460c46  .I..(....@"F.F.F
 17240 dbb15968 d3f800c0 c1eb0801 002911db  ..Yh.........)..
 17250 2ab93f68 164a002f 08bf1546 05e01168  *.?h.J./...F...h
 17260 09681160 002908bf 15461860 002808bf  .h.`.)...F.`.(..
 17270 9e461846 1a466346 e2e78de8 01406560  .F.F.FcF.....@e`
 17280 2760fdf7 67fa009c 6cb16089 0d210022  '`..g...l.`..!."
 17290 fbf74ef8 009b1b68 009303b9 01962046  ..N....h...... F
 172a0 fef726ff efe76ff0 004002b0 bde8f081  ..&...o..@......
 172b0 78220020 70b50546 86b0fdf7 43fa2846  x". p..F....C.(F
 172c0 ff214ff0 ff320023 fff710f9 064618b1  .!O..2.#.....F..
 172d0 02230093 002414e0 fef712ff 044610b9  .#...$.......F..
 172e0 06230093 0de0037a 458143f0 01030372  .#.....zE.C....r
 172f0 4673fef7 cbfd9df8 143043f0 01038df8  Fs.......0C.....
 17300 1430fdf7 27fa1cb1 28466946 fff7b6fc  .0..'...(FiF....
 17310 009806b0 70bd70b5 8eb00546 0c461646  ....p.p....F.F.F
 17320 00211822 6846f1f7 74fefdf7 0bfa2846  .!."hF..t.....(F
 17330 ff214ff0 ff320023 fff7d8f8 08b10223  .!O..2.#.......#
 17340 03e0fef7 ddfe0623 08b90093 28e0149a  .......#....(...
 17350 43734581 037a12b9 43f00103 01e043f0  CsE..z..C.....C.
 17360 09030372 fef792fd dde91223 cde90823  ...r.......#...#
 17370 2346adf8 1a60adf8 18500aac 03f11006  #F...`...P......
 17380 18685968 224603c2 0833b342 1446f7d1  .hYh"F...3.B.F..
 17390 9df81430 43f00103 8df81430 06ab0493  ...0C......0....
 173a0 fdf7d8f9 28466946 fff768fc 00980eb0  ....(FiF..h.....
 173b0 70bd0000 f0b50121 a7b00646 10461c46  p......!...F.F.F
 173c0 1746fef7 b9f80546 20600028 77d13b68  .F.....F `.(w.;h
 173d0 04aa1868 d98800f0 55fe3a4b 00933a4b  ...h....U.:K..:K
 173e0 01933a4b 02930421 2a46394b 39480396  ..:K...!*F9K9H..
 173f0 05f01aff 04a800f0 49fe3648 364b0421  ........I.6H6K.!
 17400 2a4605f0 11fffdf7 9df93046 fdf742ff  *F........0F..B.
 17410 10b90723 23601be0 90f82130 df0705d4  ...##`....!0....
 17420 40f20743 23600723 237111e0 05a9fdf7  @..C#`.##q......
 17430 73ff0aa8 29462022 f1f7ebfd 9df81730  s...)F ".......0
 17440 8df82e30 099b1868 0a909b88 adf82c30  ...0...h......,0
 17450 fdf780f9 2368002b 31d19df8 1030d907  ....#h.+1....0..
 17460 05d50aa8 12a900f0 abff2060 01e00523  .......... `...#
 17470 23602368 6bb99df8 103013f0 040f9df8  #`#hk....0......
 17480 923002d1 9a0702d4 03e09b07 01d41023  .0.............#
 17490 23602368 7bb9dde9 16019df8 9230bdf8  #`#h{........0..
 174a0 5020c3f3 4003cde9 00010293 304618a9  P ..@.......0F..
 174b0 fff731ff 02e03046 fff7fcfe 206027b0  ..1...0F.... `'.
 174c0 f0bd00bf dafb0100 ddfb0100 4dfc0100  ............M...
 174d0 bcfb0100 9c3b0020 ecfd0100 08b5fef7  .....;. ........
 174e0 97f930b1 06238380 4123c380 4381014b  ..0..#..A#..C..K
 174f0 836108bd ed6e0100 10b586b0 04461822  .a...n.......F."
 17500 68460021 f1f785fd 07230093 20460223  hF.!.....#.. F.#
 17510 69468df8 1430fff7 b1fb06b0 10bd0000  iF...0..........
 17520 37b5124d 286806f0 bffa114b 002283e8  7..M(h.....K."..
 17530 0c00104b 5c7b0cb9 002015e0 200206f0  ...K\{... .. ...
 17540 69fa0346 286050b1 0b4a0092 21460b48  i..F(`P..J..!F.H
 17550 4ff48072 f2f71cff 044608b9 ece70624  O..r.....F.....$
 17560 286806f0 a1fa2046 03b030bd 9c220020  (h.... F..0..". 
 17570 78220020 783b0020 55fc0100 80220020  x". x;. U....". 
 17580 7fb50646 13480c46 154606f0 e5fa6846  ...F.H.F.F....hF
 17590 31461022 05f0c4fd 0e486946 802206f0  1F.".....HiF."..
 175a0 e1fa08b1 112012e0 21466846 102205f0  ..... ..!FhF."..
 175b0 b7fd0848 01216a46 2b4606f0 93ff0446  ...H.!jF+F.....F
 175c0 0028efd1 28461021 05f09dfd 204604b0  .(..(F.!.... F..
 175d0 70bd00bf a0220020 2de9f041 1d461368  p....". -..A.F.h
 175e0 2b605368 6b600b68 ab604b68 eb600f46  +`Shk`.h.`Kh.`.F
 175f0 16462946 2a468046 fff7c2ff 044668bb  .F)F*F.F.....Fh.
 17600 2246184b 18480421 05f00efe 40461021  "F.K.H.!....@F.!
 17610 fdf768ff 2246154b 13480421 05f004fe  ..h."F.K.H.!....
 17620 38461021 fdf75eff 2246114b 0e480421  8F.!..^."F.K.H.!
 17630 05f0fafd 30461021 fdf754ff 22460d4b  ....0F.!..T."F.K
 17640 09480421 05f0f0fd 28461021 fdf74aff  .H.!....(F.!..J.
 17650 0548094b 04212246 05f0e6fd 2046bde8  .H.K.!"F.... F..
 17660 f08100bf 9cfc0100 9c3b0020 b3fc0100  .........;. ....
 17670 bcfc0100 c5fc0100 ecfd0100 2de9f04f  ............-..O
 17680 8bb09046 1c460022 644b9df8 50b09df8  ...F.F."dK..P...
 17690 54a0169f 189d0646 89466148 042105f0  T......F.FaH.!..
 176a0 c3fd3046 1021fdf7 1dff0022 5d4b5c48  ..0F.!....."]K\H
 176b0 042105f0 b9fd4846 1021fdf7 13ffcdf8  .!....HF.!......
 176c0 00b0cdf8 04a05648 574b0421 002205f0  ......VHWK.!."..
 176d0 abfd0022 554b5248 042105f0 a5fd3846  ..."UKRH.!....8F
 176e0 0621fdf7 fffe0022 514b4d48 042105f0  .!....."QKMH.!..
 176f0 9bfd1798 0621fdf7 f5fe0022 4d4b4848  .....!....."MKHH
 17700 042105f0 91fd4046 0721fdf7 ebfe0022  .!....@F.!....."
 17710 494b4348 042105f0 87fd2046 0721fdf7  IKCH.!.... F.!..
 17720 e1fed8f8 0030cdf8 0a30b8f8 0430adf8  .....0...0...0..
 17730 0e3098f8 06308df8 10302368 cdf81130  .0...0...0#h...0
 17740 a388adf8 1530a379 8df809a0 8df81730  .....0.y.......0
 17750 33483a4b 8df808b0 04210022 0df1080a  3H:K.....!."....
 17760 05f062fd 50461021 fdf7bcfe 4ff0000b  ..b.PF.!....O...
 17770 19f80b30 1af80b20 534005f8 0b300bf1  ...0... S@...0..
 17780 010bbbf1 100ff3d1 30462946 2a46fff7  ........0F)F*F..
 17790 f7fe0446 08b11126 34e0179b 09940df1  ...F...&4.......
 177a0 18091868 9b880690 a9f80430 3b68cdf8  ...h.......0;h..
 177b0 1e30bb88 adf82230 1948214b 04212246  .0...."0.H!K.!"F
 177c0 05f032fd 48465946 fdf78cfe 6b1e19f8  ..2.HFYF....k...
 177d0 041013f8 012f0134 4a40102c 1a70f6d1  ...../.4J@.,.p..
 177e0 30462946 2a46fff7 cbfe0646 0028d2d1  0F)F*F.....F.(..
 177f0 0b48144b 04213246 05f016fd 28462146  .H.K.!2F....(F!F
 17800 fdf770fe 00960648 0f4b0421 002205f0  ..p....H.K.!."..
 17810 0bfd3046 0bb0bde8 f08f00bf cffc0100  ..0F............
 17820 9c3b0020 e6fc0100 eefc0100 01fd0100  .;. ............
 17830 0afd0100 13fd0100 1efd0100 29fd0100  ............)...
 17840 32fd0100 3bfd0100 4efd0100 13b5094a  2...;...N......J
 17850 d36a0133 d3620c46 01aa0621 6b46fdf7  .j.3.b.F...!kF..
 17860 94fe20b9 01980099 2246fef7 a9f802b0  .. ....."F......
 17870 10bd00bf dc3b0020 38b50d46 0446fdf7  .....;. 8..F.F..
 17880 49fe2860 30b92868 f2f769fb 00232b60  I.(`0.(h..i..#+`
 17890 062038bd 611c89b2 f2f7eafc 0028f2d0  . 8.a........(..
 178a0 002038bd 03781370 43785370 83789370  . 8..x.pCxSp.x.p
 178b0 c378d370 03791371 43795371 70470378  .x.p.y.qCySqpG.x
 178c0 042b0246 15d84378 012b12d8 837813f0  .+.F..Cx.+...x..
 178d0 e2000ed1 d378073b 092b0bd8 137913f0  .....x.;.+...y..
 178e0 f00f07d1 537913f0 f00f0cbf 01200020  ....Sy....... . 
 178f0 70470020 7047002a 14bf0122 02220270  pG. pG.*...".".p
 17900 1a784270 5a788270 9a78c270 da780271  .xBpZx.p.x.p.x.q
 17910 1a794271 5b798371 70470000 7fb50378  .yBq[y.qpG.....x
 17920 00934378 01938378 0293c378 03930379  ..Cx...x...x...y
 17930 04934379 05930448 044b0421 002205f0  ..Cy...H.K.!."..
 17940 73fc07b0 5df804fb 9c3b0020 00fe0100  s...]....;. ....
 17950 f0b587b0 05460f46 062005a9 1646fff7  .....F.F. ...F..
 17960 8bff0446 38bb059b 3a461868 d9883346  ...F8...:F.h..3F
 17970 fff7c1ff 134b1449 0395002f 18bf1946  .....K.I.../...F
 17980 124b0093 124b0193 2246124b 02911248  .K...K.."F.K...H
 17990 042105f0 49fc3046 fff7c0ff 0e480f4b  .!..I.0F.....H.K
 179a0 04212246 05f040fc 28460599 fff74eff  .!"F..@.(F....N.
 179b0 05940546 00e00625 0598f2f7 d0fa2846  ...F...%......(F
 179c0 07b0f0bd 2cfc0100 3dfc0100 60fe0100  ....,...=...`...
 179d0 ddfb0100 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 179e0 00f11003 50f8041b 42f8041b 9842f9d1  ....P...B....B..
 179f0 70470323 00f8013b 02f11003 52f8041b  pG.#...;....R...
 17a00 40f8041b 9a42f9d1 70470000 10b50421  @....B..pG.....!
 17a10 04460022 0448054b 05f006fc 20461021  .F.".H.K.... F.!
 17a20 bde81040 fdf75ebd 9c3b0020 63fe0100  ...@..^..;. c...
 17a30 70b586b0 05460e46 102005a9 fff71cff  p....F.F. ......
 17a40 044610bb 059b3246 1868d988 fff7d1ff  .F....2F.h......
 17a50 114b0093 114b0193 114b0293 04212246  .K...K...K...!"F
 17a60 104b0395 104805f0 dffb3046 fff7ceff  .K...H....0F....
 17a70 0d480e4b 04212246 05f0d6fb 28460599  .H.K.!"F....(F..
 17a80 fff7e4fe 05940546 00e00625 0598f2f7  .......F...%....
 17a90 66fa2846 06b070bd 60fe0100 ddfb0100  f.(F..p.`.......
 17aa0 35fc0100 bcfb0100 9c3b0020 ecfd0100  5........;. ....
 17ab0 00f11003 50f8041b 42f8041b 9842f9d1  ....P...B....B..
 17ac0 70470423 00f8013b 02f11003 52f8041b  pG.#...;....R...
 17ad0 40f8041b 9a42f9d1 70470000 10b50421  @....B..pG.....!
 17ae0 04460022 0448054b 05f09efb 20461021  .F.".H.K.... F.!
 17af0 bde81040 fdf7f6bc 9c3b0020 63fe0100  ...@.....;. c...
 17b00 70b586b0 05460e46 102005a9 fff7b4fe  p....F.F. ......
 17b10 044610bb 059b3246 1868d988 fff7d1ff  .F....2F.h......
 17b20 114b0093 114b0193 114b0293 04212246  .K...K...K...!"F
 17b30 104b0395 104805f0 77fb3046 fff7ceff  .K...H..w.0F....
 17b40 0d480e4b 04212246 05f06efb 28460599  .H.K.!"F..n.(F..
 17b50 fff77cfe 05940546 00e00625 0598f2f7  ..|....F...%....
 17b60 fef92846 06b070bd 60fe0100 ddfb0100  ..(F..p.`.......
 17b70 46fc0100 bcfb0100 9c3b0020 ecfd0100  F........;. ....
 17b80 03781370 70470000 07b50378 00930448  .x.ppG.....x...H
 17b90 044b0421 002205f0 47fb03b0 5df804fb  .K.!."..G...]...
 17ba0 9c3b0020 6afe0100 70b586b0 06460d46  .;. j...p....F.F
 17bb0 012005a9 fff760fe 044630bb 059b8df8  . ....`..F0.....
 17bc0 10501b68 144806ad 05221a70 15f8082d  .P.h.H...".p...-
 17bd0 5a70124b 0093124b 0193124b 02930421  Zp.K...K...K...!
 17be0 2246114b 039605f0 1ffb2846 fff7ccff  "F.K......(F....
 17bf0 09480e4b 04212246 05f016fb 30460599  .H.K.!"F....0F..
 17c00 fff724fe 05940546 00e00625 0598f2f7  ..$....F...%....
 17c10 a6f92846 06b070bd 9c3b0020 60fe0100  ..(F..p..;. `...
 17c20 ddfb0100 e0fb0100 bcfb0100 ecfd0100  ................
 17c30 00f11003 50f8041b 42f8041b 9842f9d1  ....P...B....B..
 17c40 70470623 00f8013b 02f11003 52f8041b  pG.#...;....R...
 17c50 40f8041b 9a42f9d1 70470000 10b50421  @....B..pG.....!
 17c60 04460022 0448054b 05f0defa 20461021  .F.".H.K.... F.!
 17c70 bde81040 fdf736bc 9c3b0020 bf0a0200  ...@..6..;. ....
 17c80 70b586b0 05460e46 102005a9 fff7f4fd  p....F.F. ......
 17c90 044610bb 059b3246 1868d988 fff7d1ff  .F....2F.h......
 17ca0 114b0093 114b0193 114b0293 04212246  .K...K...K...!"F
 17cb0 104b0395 104805f0 b7fa3046 fff7ceff  .K...H....0F....
 17cc0 0d480e4b 04212246 05f0aefa 28460599  .H.K.!"F....(F..
 17cd0 fff7bcfd 05940546 00e00625 0598f2f7  .......F...%....
 17ce0 3ef92846 06b070bd 60fe0100 ddfb0100  >.(F..p.`.......
 17cf0 23fc0100 bcfb0100 9c3b0020 ecfd0100  #........;. ....
 17d00 38b51446 054605f0 c2f92080 a81c05f0  8..F.F.... .....
 17d10 cef9c4e9 020138bd 37b50b4c 03880093  ......8.7..L....
 17d20 05460421 20460022 084b05f0 7dfad5e9  .F.! F.".K..}...
 17d30 02232046 cde90023 04210022 044b05f0  .# F...#.!.".K..
 17d40 73fa03b0 30bd00bf 9c3b0020 74fe0100  s...0....;. t...
 17d50 81fe0100 70b586b0 06460d46 0a2005a9  ....p....F.F. ..
 17d60 fff78afd 04460028 2dd1059b 1b680722  .....F.(-....h."
 17d70 1a70059b 29881868 013005f0 6df9059b  .p..)..h.0..m...
 17d80 1868d5e9 02230330 05f072f9 114b0093  .h...#.0..r..K..
 17d90 114b0193 114b0293 04212246 104b1148  .K...K...!"F.K.H
 17da0 039605f0 41fa2846 fff7b6ff 0d480e4b  ....A.(F.....H.K
 17db0 04212246 05f038fa 30460599 fff746fd  .!"F..8.0F....F.
 17dc0 05940546 00e00625 0598f2f7 c8f82846  ...F...%......(F
 17dd0 06b070bd 60fe0100 ddfb0100 19fc0100  ..p.`...........
 17de0 bcfb0100 9c3b0020 ecfd0100 00f11003  .....;. ........
 17df0 50f8041b 42f8041b 9842f9d1 70470823  P...B....B..pG.#
 17e00 00f8013b 02f11003 52f8041b 40f8041b  ...;....R...@...
 17e10 9a42f9d1 70470000 10b50421 04460022  .B..pG.....!.F."
 17e20 0448054b 05f000fa 20461021 bde81040  .H.K.... F.!...@
 17e30 fdf758bb 9c3b0020 90fe0100 70b586b0  ..X..;. ....p...
 17e40 184b0093 184b0193 184b0293 0022184b  .K...K...K...".K
 17e50 03900e46 04460421 164805f0 e5f93046  ...F.F.!.H....0F
 17e60 fff7daff 1348144b 04210022 05f0dcf9  .....H.K.!."....
 17e70 102005a9 fff700fd 054660b9 059b3246  . .......F`...2F
 17e80 1868d988 fff7bbff 20460599 fff7defc  .h...... F......
 17e90 05950446 00e00624 0598f2f7 60f82046  ...F...$....`. F
 17ea0 06b070bd 60fe0100 ddfb0100 11fc0100  ..p.`...........
 17eb0 bcfb0100 9c3b0020 ecfd0100 13460178  .....;. .....F.x
 17ec0 03f8011b 50f8011f c2f80110 82889a80  ....P...........
 17ed0 70470923 03701378 437052f8 013fc0f8  pG.#.p.xCpR..?..
 17ee0 02309388 c3807047 30b50f4d 037887b0  .0....pG0..M.x..
 17ef0 04460093 28460421 00220c4b 05f094f9  .F..(F.!.".K....
 17f00 a3790093 63790193 23790293 e3780393  .y..cy..#y...x..
 17f10 a3780493 63780593 28460421 0022044b  .x..cx..(F.!.".K
 17f20 05f082f9 07b030bd 9c3b0020 40f30100  ......0..;. @...
 17f30 7fee0100 70b586b0 184b0093 184b0193  ....p....K...K..
 17f40 184b0293 0022184b 03900e46 04460421  .K...".K...F.F.!
 17f50 164805f0 69f93046 fff7c6ff 1348144b  .H..i.0F.....H.K
 17f60 04210022 05f060f9 072005a9 fff784fc  .!."..`.. ......
 17f70 054660b9 059b3246 1868d988 fff7a9ff  .F`...2F.h......
 17f80 20460599 fff762fc 05950446 00e00624   F....b....F...$
 17f90 0598f1f7 e4ff2046 06b070bd 60fe0100  ...... F..p.`...
 17fa0 ddfb0100 04fc0100 bcfb0100 9c3b0020  .............;. 
 17fb0 ecfd0100 00f11003 50f8041b 42f8041b  ........P...B...
 17fc0 9842f9d1 70470a23 00f8013b 02f11003  .B..pG.#...;....
 17fd0 52f8041b 40f8041b 9a42f9d1 70470000  R...@....B..pG..
 17fe0 10b50421 04460022 0448054b 05f01cf9  ...!.F.".H.K....
 17ff0 20461021 bde81040 fdf774ba 9c3b0020   F.!...@..t..;. 
 18000 95fe0100 70b586b0 184b0093 184b0193  ....p....K...K..
 18010 184b0293 0022184b 03900e46 04460421  .K...".K...F.F.!
 18020 164805f0 01f93046 fff7daff 1348144b  .H....0F.....H.K
 18030 04210022 05f0f8f8 102005a9 fff71cfc  .!."..... ......
 18040 054660b9 059b3246 1868d988 fff7bbff  .F`...2F.h......
 18050 20460599 fff7fafb 05950446 00e00624   F.........F...$
 18060 0598f1f7 7cff2046 06b070bd 60fe0100  ....|. F..p.`...
 18070 ddfb0100 fafb0100 bcfb0100 9c3b0020  .............;. 
 18080 ecfd0100 03781370 70470000 07b50378  .....x.ppG.....x
 18090 00930448 044b0421 002205f0 c5f803b0  ...H.K.!."......
 180a0 5df804fb 9c3b0020 9efe0100 70b586b0  ]....;. ....p...
 180b0 05460e46 012005a9 fff7defb 044610bb  .F.F. .......F..
 180c0 059b1448 1b680b22 1a703278 5a70124b  ...H.h.".p2xZp.K
 180d0 0093124b 0193124b 02930421 2246114b  ...K...K...!"F.K
 180e0 039505f0 a1f83046 fff7d0ff 09480e4b  ......0F.....H.K
 180f0 04212246 05f098f8 28460599 fff7a6fb  .!"F....(F......
 18100 05940546 00e00625 0598f1f7 28ff2846  ...F...%....(.(F
 18110 06b070bd 9c3b0020 60fe0100 ddfb0100  ..p..;. `.......
 18120 4dfc0100 bcfb0100 ecfd0100 10b5027c  M..............|
 18130 03460ab1 827dd2b9 5a7c5107 02d4da7d  .F...}..Z|Q....}
 18140 520711d5 1c7a5a7d d97b14f0 010f02eb  R....zZ}.{......
 18150 82020a44 14bf0d49 0d49885c 032813d8  ...D...I.I.\.(..
 18160 dfe800f0 02050d0d 00201873 10bd0222  ......... .s..."
 18170 1a731a7a 42f00802 1a720120 10bd0122  .s.zB....r. ..."
 18180 44f00804 1a731c72 10bd00bf eafe0100  D....s.r........
 18190 d1fe0100 2de9f043 99b00df1 20080aad  ....-..C.... ...
 181a0 0e460095 0df11e01 42460df1 1f030446  .F......BF.....F
 181b0 fef765f9 00283bd1 14aa04f1 1b0304f1  ..e..(;.........
 181c0 2b0e9146 18685968 174603c7 08337345  +..F.hYh.F...3sE
 181d0 3a46f7d1 0ca80721 012204f1 0f03fff7  :F.....!."......
 181e0 8afb0721 002204f1 15030ea8 fff783fb  ...!."..........
 181f0 2046fef7 41ff9df8 1e300093 03959df8   F..A....0......
 18200 1f300193 10ad0146 cdf80880 04954846  .0.....F......HF
 18210 0caa0eab fff732fa 50b96089 2946fff7  ......2.P.`.)F..
 18220 07fc28b9 237adb07 09d40223 637306e0  ..(.#z.....#cs..
 18230 337d3060 43f00203 33750823 337119b0  3}0`C...3u.#3q..
 18240 bde8f083 f0b585b0 06460c46 fef714ff  .........F.F....
 18250 6f460346 6a4600f1 100e1868 59681546  oF.FjF.....hYh.F
 18260 03c50833 73452a46 f7d17089 3946fff7  ...3sE*F..p.9F..
 18270 47fc38b1 237d2060 43f00203 23750823  G.8.#} `C...#u.#
 18280 237104e0 337adb07 5cbf0323 737305b0  #q..3z..\..#ss..
 18290 f0bd2de9 f0479cb0 0df12008 0aaf0c46  ..-..G.... ....F
 182a0 00970df1 1e014246 0df11f03 0546fef7  ......BF.....F..
 182b0 e6f80028 5bd105f1 1b0614ab 05f12b0e  ...([.........+.
 182c0 b1469a46 30687168 1a4603c2 08367645  .F.F0hqh.F...6vE
 182d0 1346f7d1 0ca80721 012205f1 0f03fff7  .F.....!."......
 182e0 0afb0721 002205f1 15030ea8 fff703fb  ...!."..........
 182f0 2846fef7 29ff9df8 1e300093 03979df8  (F..)....0......
 18300 1f300193 10af0146 cdf80880 04975046  .0.....F......PF
 18310 0caa0eab fff7b2f9 48bb3046 39461022  ........H.0F9F."
 18320 f0f75efe 20b140f2 04432360 042320e0  ..^. .@..C#`.# .
 18330 484605f1 4b0105f1 3b0218ab fff74cf9  HF..K...;.....L.
 18340 a8b918ab 05f15b06 1caf1a46 03caba42  ......[....F...B
 18350 30607160 134606f1 0806f6d1 2b7adb07  0`q`.F......+z..
 18360 44bf0523 6b73237d 43f00103 05e02060  D..#ks#}C..... `
 18370 08232371 237d43f0 02032375 1cb0bde8  .##q#}C...#u....
 18380 f0870000 024b5b69 03b11847 08207047  .....K[i...G. pG
 18390 783b0020 024b9b69 03b11847 08207047  x;. .K.i...G. pG
 183a0 783b0020 024bdb69 03b11847 08207047  x;. .K.i...G. pG
 183b0 783b0020 03460a46 01201946 fff7e2bf  x;. .F.F. .F....
 183c0 03460a46 02201946 fff7dcbf 03460a46  .F.F. .F.....F.F
 183d0 03201946 fff7d6bf 01460320 fff7dabf  . .F.....F. ....
 183e0 01460320 fff7debf 8b798371 0b680360  .F. .....y.q.h.`
 183f0 8b888380 0b890381 00238372 70478b79  .........#.rpG.y
 18400 83710b68 03608b88 83800b89 0381d1e9  .q.h.`..........
 18410 0423c0e9 0423037e 43f00103 03760023  .#...#.~C....v.#
 18420 43767047 10b591f8 2820d207 88b00446  CvpG....( .....F
 18430 0b460fd4 91f83920 d0070bd4 91f84a20  .F....9 ......J 
 18440 d20707d4 6846fff7 daff2046 6946fff7  ....hF.... FiF..
 18450 a9ff03e0 20461946 fff79cff 08b010bd  .... F.F........
 18460 01460120 fff7debf 10b50446 21460220  .F. .......F!F. 
 18470 fff7d8ff 70b9a179 ff290bd0 94f83900  ....p..y.)....9.
 18480 10f00100 06d02046 04f12902 bde81040  ...... F..)....@
 18490 fdf7a2b8 10bd0000 10b50949 0c220446  ...........I.".F
 184a0 f0f79efd 48b9a37b 3bb9e37b 2bb904f1  ....H..{;..{+...
 184b0 0c00bde8 104004f0 eabd0020 10bd00bf  .....@..... ....
 184c0 48020020 38b50246 80b1094b 084603f1  H.. 8..F...K.F..
 184d0 100453f8 045b40f8 045ba342 f9d101f1  ..S..[@..[.B....
 184e0 0c001146 04f0b8fd 002038bd 032038bd  ...F..... 8.. 8.
 184f0 48020020 70b50546 08460c46 fff7ccff  H.. p..F.F.F....
 18500 06462846 56b10221 f1f7b2fe 08b90620  .F(FV..!....... 
 18510 70bd3146 04f0a0fd 002070bd 21461022  p.1F..... p.!F."
 18520 f1f726fd 0028f2d1 70bd13b5 1446028a  ..&..(..p....F..
 18530 521a022a 06d0102a 12d12346 f1f798fd  R..*...*..#F....
 18540 00200ee0 0df10603 f1f792fd 0df10600  . ..............
 18550 04f09dfd 2146adf8 0600fff7 b3ff00e0  ....!F..........
 18560 042002b0 10bd0000 2de9f043 03784678  . ......-..C.xFx
 18570 0f2b95b0 044600f0 ff810ad8 082b31d0  .+...F.......+1.
 18580 02d8052b 13d0c6e3 0c2b3dd0 0e2b55d0  ...+.....+=..+U.
 18590 c1e3302b 1bd003d8 132b00f0 fe81bae3  ..0+.....+......
 185a0 3e2b00f0 2a82572b 00f0a283 b3e38578  >+..*.W+.......x
 185b0 033004f0 6cfd0db9 637900e0 00230190  .0..l...cy...#..
 185c0 02930095 ac48ad4b 04210022 19e08578  .....H.K.!."...x
 185d0 033004f0 5cfd0095 01900421 a648a84b  .0..\......!.H.K
 185e0 00229ee3 85780330 04f051fd 0db96379  ."...x.0..Q...cy
 185f0 00e00023 01900293 9f48a24b 00950421  ...#.....H.K...!
 18600 002204f0 11fe8ee3 90f80280 033004f0  ."...........0..
 18610 3efd0746 a01d6679 04f039fd 054604f1  >..F..fy..9..F..
 18620 080004f0 34fdcdf8 00800490 01970296  ....4...........
 18630 03959148 944b0421 0022f1e2 022e05d8  ...H.K.!."......
 18640 00968d48 914b0421 002292e1 90f80280  ...H.K.!."......
 18650 033004f0 1cfdc0f3 8527c5b2 cdf80080  .0.......'......
 18660 01970295 84488a4b 04210022 04f0dcfd  .....H.K.!."....
 18670 032e00f0 108394f8 0580cdf8 00807e48  ..............~H
 18680 844b0421 002204f0 cffd052f 04f10606  .K.!."...../....
 18690 00f08180 082f00f0 8d80042f 40f0fb82  ...../...../@...
 186a0 b8f1000f 40f0f782 013d082d 00f2f382  ....@....=.-....
 186b0 dfe815f0 09002600 5100f102 f102f102  ......&.Q.......
 186c0 f102f102 6000e01d 94f80680 04f0dffc  ....`...........
 186d0 074604f1 0a00667a 04f0d9fc 054604f1  .F....fz.....F..
 186e0 0c0004f0 d4fccdf8 00800490 01970296  ................
 186f0 03956148 684b0421 002204f0 95fdcae2  ..aHhK.!."......
 18700 5d48664b 04210022 04f08efd 04f10e05  ]HfK.!."........
 18710 4e3415f8 083c0093 15f8073c 019315f8  N4...<.....<....
 18720 063c0293 15f8053c 039315f8 043c0493  .<.....<.....<..
 18730 15f8033c 059315f8 023c0693 15f8013c  ...<.....<.....<
 18740 07934d48 564b0421 00220835 04f06cfd  ..MHVK.!.".5..l.
 18750 a542ded1 9fe204f1 0a0004f0 9dfc0446  .B.............F
 18760 304604f0 99fc0094 01900421 42484d4b  0F.........!BHMK
 18770 0022f3e0 e37a0093 a37a0193 637a0293  ."...z...z..cz..
 18780 237a0393 e3790493 a3790593 3a48464b  #z...y...y..:HFK
 18790 04210022 41e0052d 40f07d82 304604f0  .!."A..-@.}.0F..
 187a0 76fc0090 94f90830 01933348 3f4b0421  v......0..3H?K.!
 187b0 0022d3e0 153d1a2d 00f26d82 dfe815f0  ."...=.-..m.....
 187c0 1b006b02 7e00a900 6b02d100 d1004d00  ..k.~...k.....M.
 187d0 6b026b02 6b026b02 6b02d100 c0006b02  k.k.k.k.k.....k.
 187e0 6b026b02 6b026b02 6b026b02 6b026b02  k.k.k.k.k.k.k.k.
 187f0 6b026b02 30003046 04f049fc 0090237a  k.k.0.0F..I...#z
 18800 0193637a 0293a37a 0393e37a 0493237b  ..cz...z...z..#{
 18810 05931948 264b0421 002204f0 05fd3ae2  ...H&K.!."....:.
 18820 304604f0 34fc0746 04f10800 04f02ffc  0F..4..F....../.
 18830 064604f1 0a0004f0 2afc0546 04f10c00  .F......*..F....
 18840 04f025fc 00970390 01960295 0a48194b  ..%..........H.K
 18850 04210022 04f0e8fc 1de204f1 0a0004f0  .!."............
 18860 1bfc0446 304604f0 17fc0094 01900421  ...F0F.........!
 18870 0148114b 002271e0 9c3b0020 03ff0100  .H.K."q..;. ....
 18880 3aff0100 64ff0100 92ff0100 dbff0100  :...d...........
 18890 0c000200 3c000200 48000200 7f000200  ....<...H.......
 188a0 8a000200 b3000200 c8000200 e2000200  ................
 188b0 f4000200 15010200 3b010200 637d0093  ........;...c}..
 188c0 237d0193 e37c0293 a37c0393 637c0493  #}...|...|..c|..
 188d0 237c0593 e37b0693 a37b0793 7e487f4b  #|...{...{..~H.K
 188e0 04210022 04f0a0fc 637b0093 237b0193  .!."....c{..#{..
 188f0 e37a0293 a37a0393 637a0493 237a0593  .z...z..cz..#z..
 18900 e3790693 a3790793 7348754b 04210022  .y...y..sHuK.!."
 18910 13e0a379 0093e379 0193237a 0293637a  ...y...y..#z..cz
 18920 0393a37a 0493e37a 0593237b 0693637b  ...z...z..#{..c{
 18930 07936948 6b4b0421 002204f0 75fcaae1  ..iHkK.!."..u...
 18940 304604f0 a4fb0546 04f10800 04f09ffb  0F.....F........
 18950 654b0190 60480095 04210022 04f064fc  eK..`H...!."..d.
 18960 99e13046 04f093fb 604b0090 5a480421  ..0F....`K..ZH.!
 18970 002204f0 59fc8ee1 043004f0 88fba378  ."..Y....0.....x
 18980 0093e378 0193c3b2 c0f38520 02930390  ...x....... ....
 18990 04215148 564b0022 a0e18578 00950421  .!QHVK."...x...!
 189a0 012311fb 05339e42 04d00196 4a48514b  .#...3.B....JHQK
 189b0 0022b6e1 4848504b 002204f0 35fc002d  ."..HHPK."..5..-
 189c0 00f0b181 033404eb 45062046 04f05ffb  .....4..E. F.._.
 189d0 07463046 04f05bfb 013d0190 00973e48  .F0F..[..=....>H
 189e0 464b0421 002204f0 1ffc15f0 ff0504f1  FK.!."..........
 189f0 020406f1 0206e8d1 95e18778 7b1e0330  ...........x{..0
 18a00 092b00f2 6e81dfe8 13f00a00 8300ca00  .+..n...........
 18a10 2d015101 0e01ed00 6c016c01 0a00e678  -.Q.....l.l....x
 18a20 002e52d1 201d04f0 32fb0090 a3790193  ..R. ...2....y..
 18a30 e3790293 637b0393 237b0493 e37a0593  .y..c{..#{...z..
 18a40 a37a0693 637a0793 237a0893 22482c4b  .z..cz..#z.."H,K
 18a50 04213246 04f0e8fb 0a2f04f1 0e051fd1  .!2F...../......
 18a60 e37c0093 a37c0193 637c0293 237c0393  .|...|..c|..#|..
 18a70 e37b0493 a37b0593 637e0693 237e0793  .{...{..c~..#~..
 18a80 e37d0893 a37d0993 637d0a93 237d0b93  .}...}..c}..#}..
 18a90 11481c4b 04213246 04f0c6fb 04f11a05  .H.K.!2F........
 18aa0 284604f0 f4fa0646 a81c04f0 f0fa0446  (F.....F.......F
 18ab0 281d04f0 ecfa0096 02900194 ab790393  (............y..
 18ac0 0548114b 04210022 08e10096 02480f4b  .H.K.!.".....H.K
 18ad0 04210022 1ce100bf 9c3b0020 4d010200  .!.".....;. M...
 18ae0 78f70100 78010200 a0010200 b3010200  x...x...........
 18af0 bd010200 f6010200 3a020200 67020200  ........:...g...
 18b00 7a020200 c9020200 01030200 28030200  z...........(...
 18b10 257b0096 e3780193 23790293 63790393  %{...x..#y..cy..
 18b20 e37a0493 a37a0593 637a0693 237a0793  .z...z..cz..#z..
 18b30 e3790893 a3790993 28440a95 90f90a30  .y...y..(D.....0
 18b40 0b937a48 7a4b0421 002204f0 6dfb002d  ..zHzK.!."..m..-
 18b50 00f0e980 0d340caf 38460021 2022f0f7  .....4..8F.! "..
 18b60 58fa082d 2e46a8bf 082604eb 0609b846  X..-.F...&.....F
 18b70 14f8013b 6f4a4046 0421f0f7 6afc4c45  ...;oJ@F.!..j.LE
 18b80 08f10308 f4d1ad1b edb20097 67486a4b  ............gHjK
 18b90 04210022 04f048fb 002ddcd1 c3e0e578  .!."..H..-.....x
 18ba0 d5b9201d 04f073fa 8046a01d 04f06ffa  .. ...s..F....o.
 18bb0 074604f1 080004f0 6afa0646 04f10a00  .F......j..F....
 18bc0 04f065fa cdf80080 03900197 02965748  ..e...........WH
 18bd0 5a4b0421 2a4681e0 00955448 584b0421  ZK.!*F....THXK.!
 18be0 002295e0 04f053fa 8046601d 04f04ffa  ."....S..F`...O.
 18bf0 0746e01d 04f04bfa 064604f1 090004f0  .F....K..F......
 18c00 46fa0546 04f10b00 04f041fa 4d4b0490  F..F......A.MK..
 18c10 4648cdf8 00800197 02960395 04210022  FH...........!."
 18c20 04f002fb 7fe004f0 32fa8046 601d04f0  ........2..F`...
 18c30 2efa0746 e01d04f0 2afa0646 04f10900  ...F....*..F....
 18c40 04f025fa 054604f1 0b0004f0 20facdf8  ..%..F...... ...
 18c50 00800490 01970296 03953448 3a4b0421  ..........4H:K.!
 18c60 0022dde7 e578ddb9 201d04f0 10fa2a46  ."...x.. .....*F
 18c70 00900421 2d48354b 04f0d6fa 651d0d34  ...!-H5K....e..4
 18c80 15f8013f 00932948 2a4b0421 002204f0  ...?..)H*K.!."..
 18c90 cbfaa542 f4d12548 2d4b0421 002224e0  ...B..%H-K.!."$.
 18ca0 00952248 2b4b0421 002231e0 04f0eff9  .."H+K.!."1.....
 18cb0 074604f1 090004f0 eff90646 601d04f0  .F.........F`...
 18cc0 ebf90546 04f10d00 04f0e1f9 224b0390  ...F........"K..
 18cd0 16480097 01960295 04210022 04f0a4fa  .H.......!."....
 18ce0 21e01248 1d4b0421 002204f0 9dfa1ae0  !..H.K.!."......
 18cf0 022e05d0 00960d48 194b0421 002207e0  .......H.K.!."..
 18d00 023004f0 c4f9174b 00900848 04210022  .0.....K...H.!."
 18d10 04f08afa 07e08de8 48000448 124b0421  ........H..H.K.!
 18d20 002204f0 81fa15b0 bde8f083 9c3b0020  ."...........;. 
 18d30 52030200 89fa0100 b7030200 bb030200  R...............
 18d40 03040200 34040200 94040200 f5040200  ....4...........
 18d50 ecfd0100 1e050200 49050200 76050200  ........I...v...
 18d60 89050200 ae050200 c6050200 2de9f04f  ............-..O
 18d70 0b2a89b0 894659dd 91f80180 08f1ff33  .*...FY........3
 18d80 182b51d8 0ffa88f4 e000861c 06eb0801  .+Q.............
 18d90 91424bda 00231e46 09eb0007 fd180133  .BK..#.F.......3
 18da0 ad784345 2e44f7db 0e4406eb 08039342  .xCE.D...D.....B
 18db0 3cdcfe23 0df11900 00210622 8df81830  <..#.....!."...0
 18dc0 4fea440a f0f725f9 04ebc404 a51c0024  O.D...%........$
 18dd0 a34609eb 04039b78 8df80430 04eb0803  .F.....x...0....
 18de0 4b449b78 8df80530 062303fb 04a34b44  KD.x...0.#....KD
 18df0 53f8020f 02909b88 adf80c30 3b1901a8  S..........0;...
 18e00 9a788df8 062005eb 0b034b44 049309eb  .x... ....KD....
 18e10 06039344 1b5d8df8 07300134 f8f71cfe  ...D.]...0.4....
 18e20 4445d6db 002002e0 0a2000e0 0c2009b0  DE... ... ... ..
 18e30 bde8f08f 022a30b5 13dd8878 00230a4c  .....*0....x.#.L
 18e40 e5180833 1c4414f8 084c8442 05d16b68  ...3.D...L.B..kh
 18e50 0231023a bde83040 1847382b efd10020  .1.:..0@.G8+... 
 18e60 30bd0c20 30bd00bf 50060200 2de9f043  0.. 0...P...-..C
 18e70 112a89b0 0e463fdd 4f780223 03eb0713  .*...F?.Ox.#....
 18e80 9a4239d1 00233db2 04930593 4fea4508  .B9..#=.....O.E.
 18e90 4feac509 0123c5eb 05155c1c 013bbb42  O....#....\..;.B
 18ea0 28da335d 8df80430 f3190622 1b5d8df8  (.3]...0...".]..
 18eb0 05306243 02eb0803 33443a44 53f80a0d  .0bC....3D:DS...
 18ec0 02909b88 adf80c30 06eb0903 01a8195d  .......0.......]
 18ed0 8df81810 134453f8 0a2dcdf8 19209b88  .....DS..-... ..
 18ee0 adf81d30 73191b5d 8df80730 f8f7b4fd  ...0s..]...0....
 18ef0 2346d2e7 002000e0 0c2009b0 bde8f083  #F... ... ......
 18f00 022af8b5 15dd8e78 b2eb860f 11dd0227  .*.....x.......'
 18f10 cd1c07fb 0611cc1c a54208d0 284604f0  .........B..(F..
 18f20 b6f807fb 065004f0 b2f80235 f4e70020  .....P.....5... 
 18f30 f8bd0c20 f8bd0a2a 1fb50c46 3add0846  ... ...*...F:..F
 18f40 10f8013b 8df80430 04f0a1f8 adf80600  ...;...0........
 18f50 e01c04f0 9cf8adf8 0800601d 04f097f8  ..........`.....
 18f60 adf80a00 e01d04f0 92f8adf8 0c0004f1  ................
 18f70 090004f0 8cf8bdf8 0820adf8 0e00052a  ......... .....*
 18f80 16d9bdf8 0a30b3f5 486f11d8 9a420fd8  .....0..Ho...B..
 18f90 bdf80c30 b3f5fa7f 0ad20a38 80b240f6  ...0.......8..@.
 18fa0 76439842 04d801a8 f9f7a8f8 002002e0  vC.B......... ..
 18fb0 0a2000e0 0c2004b0 10bd0c2a 1fb50c46  . ... .....*...F
 18fc0 18dd0846 10f8013b 8df80c30 04f05ff8  ...F...;...0.._.
 18fd0 adf80800 e01c04f0 6af8cde9 000104f1  ........j.......
 18fe0 0b0004f0 54f8adf8 0a006846 fdf7c4ff  ....T.....hF....
 18ff0 002000e0 0c2004b0 10bd092a 1fb50c46  . ... .....*...F
 19000 37dd0b78 8df80430 881c4b78 8df80530  7..x...0..Kx...0
 19010 04f03df8 adf80600 201d04f0 38f8adf8  ..=..... ...8...
 19020 0800a01d 04f033f8 adf80a00 04f10800  ......3.........
 19030 04f02df8 9df80530 adf80c00 93b9bdf8  ..-....0........
 19040 0830063b 9bb240f6 7a429342 0fd8bdf8  .0.;..@.zB.B....
 19050 0a30b3f5 fa7f0ad2 0a3880b2 40f67643  .0.......8..@.vC
 19060 984204d8 01a8f8f7 c3fc0020 02e00a20  .B......... ... 
 19070 00e00c20 04b010bd 30b5122a 89b00546  ... ....0..*...F
 19080 0c4663dd 0a2801d1 1e2a5fdd 23788df8  .Fc..(...*_.#x..
 19090 0030a01c 63788df8 013003f0 f8ff2379  .0..cx...0....#y
 190a0 8df80430 63798df8 05302346 0a2d53f8  ...0cy...0#F.-S.
 190b0 062fadf8 02009b88 cdf80620 adf80a30  ./......... ...0
 190c0 11d12346 0c2553f8 0c2fcdf8 13209b88  ..#F.%S../... ..
 190d0 adf81730 234653f8 122fcdf8 19209b88  ...0#FS../... ..
 190e0 adf81d30 0ce00021 06220df1 1300eff7  ...0...!."......
 190f0 90ff0df1 19000021 0622eff7 8aff0025  .......!.".....%
 19100 05f10c00 204403f0 c2ffadf8 0c0005f1  .... D..........
 19110 0e002044 03f0bbff adf80e00 05f11000  .. D............
 19120 20442c44 03f0b3ff a37c8df8 12309df8   D,D.....|...0..
 19130 0130adf8 10001bb9 9df80430 012b03d8  .0.........0.+..
 19140 6846f8f7 c3fc02e0 0a2000e0 0c2009b0  hF....... ... ..
 19150 30bd022a 07b50cdd 8b788df8 0430c81c  0..*.....x...0..
 19160 03f095ff adf80600 01a8fdf7 fffe0020  ............... 
 19170 00e00c20 03b05df8 04fb032a 13b50c46  ... ..]....*...F
 19180 0fdd8b78 8df80430 c81c03f0 80ff6379  ...x...0......cy
 19190 adf80600 01a88df8 0530fdf7 dffe0020  .........0..... 
 191a0 00e00c20 02b010bd 032a13b5 0c460fdd  ... .....*...F..
 191b0 8b788df8 0630c81c 03f069ff 6379adf8  .x...0....i.cy..
 191c0 040001a8 8df80730 f8f7ecfb 002000e0  .......0..... ..
 191d0 0c2002b0 10bd0000 30b129b1 034b1880  . ......0.)..K..
 191e0 034b0020 19707047 03207047 ba230020  .K. .ppG. pG.#. 
 191f0 b8230020 70b50f4c a3690646 0133a361  .#. p..L.i.F.3.a
 19200 fff7b2f9 30787278 00230b4d e9180833  ....0xrx.#.M...3
 19210 1d4415f8 085c8542 05d14b68 02323146  .D...\.B..Kh.21F
 19220 bde87040 1847282b efd1e369 0133e361  ..p@.G(+...i.3.a
 19230 082070bd 1c3b0020 88060200 38b50446  . p..;. ....8..F
 19240 4068fff7 d7ff6168 05460448 f1f7e8f8  @h....ah.F.H....
 19250 21460348 f1f7e4f8 284638bd 5c3b0020  !F.H....(F8.\;. 
 19260 403b0020 38b50378 0e3b012b 054608d8  @;. 8..x.;.+.F..
 19270 c3780bb9 037923b1 2846fbf7 dbf90020  .x...y#.(F..... 
 19280 38bd0a48 f1f7b8f8 034630b9 29460848  8..H.....F0.)F.H
 19290 f1f7c6f8 4ff0ff30 38bd0024 10221c70  ....O..08..$.".p
 192a0 5a705d60 fbf7d8fa e9e700bf 403b0020  Zp]`........@;. 
 192b0 5c3b0020 70b588b0 05a90546 fbf713fa  \;. p......F....
 192c0 04460028 40d1bdf8 14302348 c3f30b02  .F.(@....0#H....
 192d0 c3f30133 0193bdf8 16300092 04212246  ...3.....0...!"F
 192e0 02931e4b 03f0a0ff 2846fcf7 dbf82246  ...K....(F...."F
 192f0 1b4b1948 042103f0 97ffbdf8 16202b8a  .K.H.!....... +.
 19300 9a4220d1 bdf81460 c6f30b06 fbf71afa  .B ....`........
 19310 3046fbf7 bfff48b1 07ab0093 2a4605a9  0F....H.....*F..
 19320 06abfcf7 d3fa0025 044600e0 0724fbf7  .......%.F...$..
 19330 11fa14b1 012c0cd0 06e03046 07a9069b  .....,....0F....
 19340 98470798 01e00a24 2846f0f7 08fe2046  .G.....$(F.... F
 19350 00e00020 08b070bd 9c3b0020 e1050200  ... ..p..;. ....
 19360 ecfd0100 f8b50446 0f4d238a 28888342  .......F.M#.(..B
 19370 0f4602d8 0c600e20 f8bd0021 f0f7d9fd  .F...`. ...!....
 19380 064660b1 21460022 2b88f0f7 4efe30b9  .F`.!F."+...N.0.
 19390 20462988 f0f793fe 3e600120 f8bd3046   F).....>`. ..0F
 193a0 f0f7ddfd 0620f8bd ba230020 2de9ff47  ..... ...#. -..G
 193b0 06460f46 00253846 02a9fff7 d3ff0128  .F.F.%8F.......(
 193c0 044604d0 0e2848d1 4ff00108 01e04ff0  .F...(H.O.....O.
 193d0 0008029c b6f804a0 218a0df1 10090df1  ........!.......
 193e0 0e004aea 053529f8 045d03f0 35fe2046  ..J..5)..]..5. F
 193f0 0421f0f7 dcfe0446 80b10368 d9f80000  .!.....F...h....
 19400 18600df1 0e0003f0 42fecdf8 00a00190  .`......B.......
 19410 04211548 154b0022 03f006ff 0294dcb1  .!.H.K."........
 19420 04210022 124b1048 03f0fefe 0298fcf7  .!.".K.H........
 19430 39f80d48 0f4b0421 002203f0 f5fe0298  9..H.K.!."......
 19440 fbf750fa 044640b9 b38d0133 b3850125  ..P..F@....3...%
 19450 b8f1000f afd003e0 06243846 f0f77ffd  .........$8F....
 19460 204604b0 bde8f087 9c3b0020 12060200   F.......;. ....
 19470 39060200 ecfd0100 38b50446 0d460846  9.......8..F.F.F
 19480 218803f0 e9fda81c 618803f0 e5fd281d  !.......a.....(.
 19490 a18803f0 e1fda81d e18803f0 ddfd05f1  ................
 194a0 08002189 03f0d8fd 05f10a00 618903f0  ..!.........a...
 194b0 d3fd05f1 0c00a189 03f0cefd 002038bd  ............. 8.
 194c0 2de9ff41 1e4d0e46 41ea8021 14460746  -..A.M.FA..!.F.F
 194d0 89b22846 984603f0 bffdac70 24b1e81c  ..(F.F.....p$...
 194e0 41462246 eff78afd 0022164b 16480097  AF"F.....".K.H..
 194f0 04210196 029403f0 97fe1148 e11cfbf7  .!.........H....
 19500 f1ff1148 114b0421 002203f0 8dfe0c48  ...H.K.!.".....H
 19510 f5f71afe 58b10728 0cbf1424 11240094  ....X..(...$.$..
 19520 09480b4b 04210022 03f07efe 04e0094a  .H.K.!."..~....J
 19530 53690133 53610446 204604b0 bde8f081  Si.3Sa.F F......
 19540 103c0020 b0060200 9c3b0020 ecfd0100  .<. .....;. ....
 19550 e1060200 1c3b0020 10b50446 03f097fd  .....;. ...F....
 19560 0146a278 e31cc0f3 8520c9b2 bde81040  .F.x..... .....@
 19570 fff7a6bf 38b50446 0d460846 42f20601  ....8..F.F.FB...
 19580 03f06afd 0f23ab70 e1882389 8b4237d3  ..j..#.p..#..B7.
 19590 a378032b 34d8e378 012b31d8 2379032b  .x.+4..x.+1.#y.+
 195a0 2ed82378 042b2bd8 62784ab3 12f0f80f  ..#x.++.bxJ.....
 195b0 26d19a1e 012a03d9 012b07d0 202300e0  &....*...+.. #..
 195c0 a0239942 1cd3b1f5 804f19d8 e81c03f0  .#.B.....O......
 195d0 43fd681d 218903f0 3ffd2378 eb71a378  C.h.!...?.#x.q.x
 195e0 2b72e378 6b722346 002053f8 0a2fc5f8  +r.xkr#F. S../..
 195f0 0a209b88 eb816378 2b742379 6b7438bd  . ....cx+t#ykt8.
 19600 4ff0ff30 38bd70b5 14460646 0d461046  O..08.p..F.F.F.F
 19610 42f20801 03f020fd 2023a370 0eb97db9  B..... . #.p..}.
 19620 01e01f2d 0cd8e01c 00212022 eff7f1fc  ...-.....! "....
 19630 e570201d 31462a46 eff7e0fc 002070bd  .p .1F*F..... p.
 19640 122070bd 70b51446 06460d46 104642f2  . p.p..F.F.F.FB.
 19650 090103f0 01fd2023 a3700eb9 7db901e0  ...... #.p..}...
 19660 1f2d0cd8 e01c0021 2022eff7 d2fce570  .-.....! ".....p
 19670 201d3146 2a46eff7 c1fc0020 70bd1220   .1F*F..... p.. 
 19680 70bdd0b5 14460646 0f461046 40f60141  p....F.F.F.F@..A
 19690 03f0e2fc 0823a370 e01c3246 3b46bde8  .....#.p..2F;F..
 196a0 d04003f0 e5bcd0b5 14460646 0f461046  .@.......F.F.F.F
 196b0 40f66341 03f0d0fc 0823a370 e01c3246  @.cA.....#.p..2F
 196c0 3b46bde8 d04003f0 d3bc70b5 14460646  ;F...@....p..F.F
 196d0 0d461046 40f20641 03f0befc 0323a370  .F.F@..A.....#.p
 196e0 e0183146 03f0b8fc 657170bd d0b51446  ..1F....eqp....F
 196f0 06460f46 104642f2 010103f0 adfc0823  .F.F.FB........#
 19700 a370e01c 32463b46 bde8d040 03f0b0bc  .p..2F;F...@....
 19710 10b542f2 02010446 03f09efc 0023a370  ..B....F.....#.p
 19720 10bd10b5 42f20301 044603f0 95fc0023  ....B....F.....#
 19730 a37010bd 38b50c46 05460846 42f20a01  .p..8..F.F.FB...
 19740 03f08afc 0123a370 e57038bd 70b51446  .....#.p.p8.p..F
 19750 06460d46 104642f2 0c0103f0 7dfc0223  .F.F.FB.....}..#
 19760 a370e670 257170bd 10b540f6 03410446  .p.p%qp...@..A.F
 19770 03f072fc 0023a370 10bd10b5 42f20701  ..r..#.p....B...
 19780 044603f0 69fc0023 a37010bd 10b542f2  .F..i..#.p....B.
 19790 0e010446 03f060fc 0023a370 10bd38b5  ...F..`..#.p..8.
 197a0 0c460546 084642f2 130103f0 55fc0e23  .F.F.FB.....U..#
 197b0 a3702846 e11cbde8 3840fff7 5dbe70b5  .p(F....8@..].p.
 197c0 0c460646 084642f2 1a0103f0 45fc3546  .F.F.FB.....E.5F
 197d0 1223a370 e01c35f8 021b03f0 3dfc0534  .#.p..5.....=..4
 197e0 123655f8 043b44f8 043bb542 f9d170bd  .6U..;D..;.B..p.
 197f0 38b50c46 05460846 42f21b01 03f02cfc  8..F.F.FB.....,.
 19800 0223a370 e01c2946 bde83840 03f024bc  .#.p..)F..8@..$.
 19810 38b50c46 05460846 42f22001 03f01cfc  8..F.F.FB. .....
 19820 0e23a370 e01c2988 03f016fc 601d6988  .#.p..).....`.i.
 19830 03f012fc e01da988 03f00efc 04f10900  ................
 19840 e98803f0 09fc04f1 0b002989 03f004fc  ..........).....
 19850 04f10d00 698903f0 fffb04f1 0f00a989  ....i...........
 19860 bde83840 03f0f8bb 38b50c46 05460846  ..8@....8..F.F.F
 19870 42f22101 03f0f0fb 0323a370 e0182988  B.!......#.p..).
 19880 03f0eafb ab786371 38bd10b5 42f21801  .....xcq8...B...
 19890 044603f0 e1fb0023 a37010bd 38b50d46  .F.....#.p..8..F
 198a0 04460846 42f21901 03f0d6fb 1c23ab70  .F.FB........#.p
 198b0 2188e81c 03f0d0fb d4e90223 681d03f0  !..........#h...
 198c0 d7fb1034 34f80e1c 05f10d00 03f0c4fb  ...44...........
 198d0 0f3504f1 100354f8 042b45f8 042b9c42  .5....T..+E..+.B
 198e0 f9d138bd 70b50546 0c460846 42f22701  ..8.p..F.F.FB.'.
 198f0 03f0b2fb 2723a370 2b78012b 1dd8e370  ....'#.p+x.+...p
 19900 2b4605f1 270053f8 012f6260 9b882381  +F..'.S../b`..#.
 19910 05f11703 04f10a02 194653f8 046b42f8  .........FS..kB.
 19920 046b8342 f9d10735 1a3455f8 043b44f8  .k.B...5.4U..;D.
 19930 043b8d42 f9d10020 70bd1220 70bd10b5  .;.B... p.. p...
 19940 42f22901 044603f0 87fb0020 a07010bd  B.)..F..... .p..
 19950 38b50546 0c460846 42f22d01 03f07cfb  8..F.F.FB.-...|.
 19960 01239d42 a3709abf e5700020 122038bd  .#.B.p...p. . 8.
 19970 38b50546 0c460846 42f22e01 03f06cfb  8..F.F.FB.....l.
 19980 0223a370 6b1e9bb2 4af2b712 934205d8  .#.pk...J....B..
 19990 e01c2946 03f060fb 002038bd 122038bd  ..)F..`.. 8.. 8.
 199a0 37b50546 0c460868 01220021 0df10703  7..F.F.h.".!....
 199b0 f0f75efb 002840f0 09819df8 07308649  ..^..(@......0.I
 199c0 0a18415c 994257d1 013b512b 00f2f980  ..A\.BW..;Q+....
 199d0 dfe813f0 59005e00 63006800 6d007200  ....Y.^.c.h.m.r.
 199e0 77007c00 81008600 8b009000 95009a00  w.|.............
 199f0 9f00a400 ab00b200 b900f700 f700c000  ................
 19a00 c700ce00 d500f700 dc00f700 e300ea00  ................
 19a10 f700f700 f700f700 f700f700 f700f700  ................
 19a20 f700f700 f700f700 f700f700 f700f700  ................
 19a30 f700f700 f700f700 f700f700 f700f700  ................
 19a40 f700f700 f700f700 f700f700 f700f700  ................
 19a50 f700f700 f700f700 f700f700 f700f700  ................
 19a60 f700f700 f700f700 f700f700 f700f700  ................
 19a70 f700f700 f700f100 00f10800 00f2a880  ................
 19a80 d8289cd1 a4e05549 cb680133 cb6098e0  .(....UI.h.3.`..
 19a90 52494b69 01334b61 93e05049 cb690133  RIKi.3Ka..PI.i.3
 19aa0 cb618ee0 4d494b6a 01334b62 89e04b49  .a..MIKj.3Kb..KI
 19ab0 cb6a0133 cb6284e0 48494b6b 01334b63  .j.3.b..HIKk.3Kc
 19ac0 7fe04649 cb6b0133 cb637ae0 43494b6c  ..FI.k.3.cz.CIKl
 19ad0 01334b64 75e04149 cb6c0133 cb6470e0  .3Kdu.AI.l.3.dp.
 19ae0 3e494b6d 01334b65 6be03c49 cb6d0133  >IKm.3Kek.<I.m.3
 19af0 cb6566e0 39494b6e 01334b66 61e03749  .ef.9IKn.3Kfa.7I
 19b00 cb6e0133 cb665ce0 34494b6f 01334b67  .n.3.f\.4IKo.3Kg
 19b10 57e03249 cb6f0133 cb6752e0 2f49d1f8  W.2I.o.3.gR./I..
 19b20 84300133 c1f88430 4be02c49 d1f88c30  .0.3...0K.,I...0
 19b30 0133c1f8 8c3044e0 2849d1f8 94300133  .3...0D.(I...0.3
 19b40 c1f89430 3de02549 d1f89c30 0133c1f8  ...0=.%I...0.3..
 19b50 9c3036e0 2149d1f8 a4300133 c1f8a430  .06.!I...0.3...0
 19b60 2fe01e49 d1f8ac30 0133c1f8 ac3028e0  /..I...0.3...0(.
 19b70 1a49d1f8 b4300133 c1f8b430 21e01749  .I...0.3...0!..I
 19b80 d1f8bc30 0133c1f8 bc301ae0 1349d1f8  ...0.3...0...I..
 19b90 c4300133 c1f8c430 13e01049 d1f8cc30  .0.3...0...I...0
 19ba0 0133c1f8 cc300ce0 0c49d1f8 d4300133  .3...0...I...0.3
 19bb0 c1f8d430 05e00949 d1f8dc30 0133c1f8  ...0...I...0.3..
 19bc0 dc305368 28462146 984702e0 042000e0  .0Sh(F!F.G... ..
 19bd0 032003b0 30bd00bf 04070200 143d0020  . ..0........=. 
 19be0 10b50c46 13460421 2246bde8 1040fbf7  ...F.F.!"F...@..
 19bf0 ccbc0000 01385128 00f2f480 dfe810f0  .....8Q(........
 19c00 52005700 5c006100 66006b00 70007500  R.W.\.a.f.k.p.u.
 19c10 7a007f00 84008900 8e009300 98009f00  z...............
 19c20 a600ad00 b400f200 f200bb00 c200c900  ................
 19c30 d000f200 d700f200 de00e500 f200f200  ................
 19c40 f200f200 f200f200 f200f200 f200f200  ................
 19c50 f200f200 f200f200 f200f200 f200f200  ................
 19c60 f200f200 f200f200 f200f200 f200f200  ................
 19c70 f200f200 f200f200 f200f200 f200f200  ................
 19c80 f200f200 f200f200 f200f200 f200f200  ................
 19c90 f200f200 f200f200 f200f200 f200f200  ................
 19ca0 f200ec00 504a1369 01331361 70474e4a  ....PJ.i.3.apGNJ
 19cb0 93690133 93617047 4b4a136a 01331362  .i.3.apGKJ.j.3.b
 19cc0 7047494a 936a0133 93627047 464a136b  pGIJ.j.3.bpGFJ.k
 19cd0 01331363 7047444a 936b0133 93637047  .3.cpGDJ.k.3.cpG
 19ce0 414a136c 01331364 70473f4a 936c0133  AJ.l.3.dpG?J.l.3
 19cf0 93647047 3c4a136d 01331365 70473a4a  .dpG<J.m.3.epG:J
 19d00 936d0133 93657047 374a136e 01331366  .m.3.epG7J.n.3.f
 19d10 7047354a 936e0133 93667047 324a136f  pG5J.n.3.fpG2J.o
 19d20 01331367 7047304a 936f0133 93677047  .3.gpG0J.o.3.gpG
 19d30 2d4ad2f8 80300133 c2f88030 70472a4a  -J...0.3...0pG*J
 19d40 d2f88830 0133c2f8 88307047 264ad2f8  ...0.3...0pG&J..
 19d50 90300133 c2f89030 7047234a d2f89830  .0.3...0pG#J...0
 19d60 0133c2f8 98307047 1f4ad2f8 a0300133  .3...0pG.J...0.3
 19d70 c2f8a030 70471c4a d2f8a830 0133c2f8  ...0pG.J...0.3..
 19d80 a8307047 184ad2f8 b0300133 c2f8b030  .0pG.J...0.3...0
 19d90 7047154a d2f8b830 0133c2f8 b8307047  pG.J...0.3...0pG
 19da0 114ad2f8 c0300133 c2f8c030 70470e4a  .J...0.3...0pG.J
 19db0 d2f8c830 0133c2f8 c8307047 0a4ad2f8  ...0.3...0pG.J..
 19dc0 d0300133 c2f8d030 7047074a d2f8d830  .0.3...0pG.J...0
 19dd0 0133c2f8 d8307047 034ad2f8 e0300133  .3...0pG.J...0.3
 19de0 c2f8e030 704700bf 143d0020 00487047  ...0pG...=. .HpG
 19df0 000e0020 13b50446 faf7a4fc 204601a9  ... ...F.... F..
 19e00 6a46fff7 edfe0098 08b1fbf7 25fd0446  jF..........%..F
 19e10 faf7a0fc 204602b0 10bd1629 98bf1721  .... F.....)...!
 19e20 01817047 08b5fbf7 f3fc40b1 04238380  ..pG......@..#..
 19e30 034b1b88 c3801723 4381024b 836108bd  .K.....#C..K.a..
 19e40 bc230020 a1990100 07b5094b 0948f022  .#. .......K.H."
 19e50 1a800023 084a0192 00930421 362203f0  ...#.J.....!6"..
 19e60 75fa0028 14bf0b20 002003b0 5df804fb  u..(... . ..]...
 19e70 bc230020 143d0020 dc070200 37b50b68  .#. .=. ....7..h
 19e80 05461878 0c46fff7 b5fefaf7 5bfc2846  .F.x.F......[.(F
 19e90 01a96a46 fff7a4fe 054688b9 0098258a  ..jF.....F....%.
 19ea0 fbf7dafc 291a0029 03dd2046 4942f0f7  ....)..).. FIB..
 19eb0 06f92246 01980099 fbf782fd 00240546  .."F.........$.F
 19ec0 faf748fc 2046f0f7 4af82846 03b030bd  ..H. F..J.(F..0.
 19ed0 2de9f041 048ab4f5 007f8046 0e461546  -..A.......F.F.F
 19ee0 05d90023 13800a20 0b60bde8 f081fff7  ...#... .`......
 19ef0 7dff0746 00214046 22463b46 f0f7b8f8  }..F.!@F"F;F....
 19f00 37600020 2c80bde8 f08138b5 0c460546  7`. ,.....8..F.F
 19f10 fbf700fb 206030b9 2068f0f7 20f80023  .... `0. h.. ..#
 19f20 23600620 38bd2946 f0f7a2f9 0028f3d0  #`. 8.)F.....(..
 19f30 002038bd 002a03db 04d092b2 f0f718b8  . 8..*..........
 19f40 03207047 10467047 70b50546 86b00846  . pG.FpGp..F...F
 19f50 0e460521 fbf7f0fa 0446f8b9 336805aa  .F.!.....F..3h..
 19f60 1868d988 00f08cfe 0e4b0093 0e4b0193  .h.......K...K..
 19f70 0e4b0293 04212246 0d4b0e48 039503f0  .K...!"F.K.H....
 19f80 53f905a8 00f08efe 0a480b4b 04212246  S........H.K.!"F
 19f90 03f04af9 284605a9 f9f7c6f9 204606b0  ..J.(F...... F..
 19fa0 70bd00bf dafb0100 e0070200 e4070200  p...............
 19fb0 bcfb0100 9c3b0020 ecfd0100 70b50646  .....;. ....p..F
 19fc0 86b00846 0d460321 fbf7b6fa 04460028  ...F.F.!.....F.(
 19fd0 32d12b68 04aa1868 d98800f0 79fe1b4b  2.+h...h....y..K
 19fe0 00931b4b 01931b4b 02932246 04211a4b  ...K...K.."F.!.K
 19ff0 1a480396 03f018f9 04a800f0 73fe2246  .H..........s."F
 1a000 1648174b 042103f0 0ff9faf7 9bfb2146  .H.K.!........!F
 1a010 304605aa fff7e4fd 044648b9 0598bdf8  0F.......FH.....
 1a020 1010fff7 fafe0598 fbf716fc 054600e0  .............F..
 1a030 0025faf7 8ffb00e0 00253046 21462a46  .%.......%0F!F*F
 1a040 f9f78cf9 204606b0 70bd00bf dafb0100  .... F..p.......
 1a050 e0070200 f6070200 bcfb0100 9c3b0020  .............;. 
 1a060 ecfd0100 30b587b0 174b0093 174b0193  ....0....K...K..
 1a070 174b0293 0c460022 0421164b 03900546  .K...F.".!.K...F
 1a080 154803f0 d1f82046 00f04cfe 134b1248  .H.... F..L..K.H
 1a090 04210022 03f0c8f8 238893b1 62889a42  .!."....#...b..B
 1a0a0 0fd30520 05a9fff7 30ff58b9 059b2246  ... ....0.X..."F
 1a0b0 1868d988 00f02dfe 28460599 fff7defe  .h....-.(F......
 1a0c0 00e00320 07b030bd 60fe0100 e0070200  ... ..0.`.......
 1a0d0 fe070200 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 1a0e0 2de9f041 07468ab0 08460c46 0221fbf7  -..A.F...F.F.!..
 1a0f0 23fa0546 002859d1 236804aa 1868d988  #..F.(Y.#h...h..
 1a100 00f022fe 2d4b0093 2d4b0193 2d4b0293  ..".-K..-K..-K..
 1a110 04212a46 2c4b2d48 039703f0 85f804a8  .!*F,K-H........
 1a120 00f01afe 29482a4b 04212a46 03f07cf8  ....)H*K.!*F..|.
 1a130 20680221 eff7c3ff 23681b8a b3b39df8   h.!....#h......
 1a140 1060012e 04d0022e 2ed14ff0 120801e0  .`........O.....
 1a150 4ff00408 20464146 fbf7eef9 28bb2368  O... FAF....(.#h
 1a160 186802f0 94ff012e adf81400 09d0022e  .h..............
 1a170 11d12068 31461022 0df11603 eff778ff  .. h1F."......x.
 1a180 08e02368 18680230 02f081ff 0df11601  ..#h.h.0........
 1a190 fef798f9 40b92068 4146eff7 90ff3846  ....@. hAF....8F
 1a1a0 05a9f9f7 eef8c7e7 0a200546 38462946  ......... .F8F)F
 1a1b0 f9f718f9 28460ab0 bde8f081 dafb0100  ....(F..........
 1a1c0 e0070200 0c080200 bcfb0100 9c3b0020  .............;. 
 1a1d0 ecfd0100 f0b587b0 1e461e4b 00931e4b  .........F.K...K
 1a1e0 01931e4b 02930c46 1d4b0390 04210546  ...K...F.K...!.F
 1a1f0 17461c48 002203f0 17f82046 00f0d2fd  .F.H.".... F....
 1a200 194b1848 04210022 03f00ef8 2388c3b1  .K.H.!."....#...
 1a210 62889a42 15d30720 05a9fff7 76feb0b9  b..B... ....v...
 1a220 059b2246 1868d988 00f0b0fd 05983946  .."F.h........9F
 1a230 b2b2eff7 9dfe30b1 0598eff7 90fe0620  ......0........ 
 1a240 05e00320 03e02846 0599fff7 17fe07b0  ... ..(F........
 1a250 f0bd00bf 60fe0100 e0070200 1a080200  ....`...........
 1a260 bcfb0100 9c3b0020 ecfd0100 30b587b0  .....;. ....0...
 1a270 174b0093 174b0193 174b0293 0d460390  .K...K...K...F..
 1a280 04210022 154b0446 154802f0 cdff1448  .!.".K.F.H.....H
 1a290 144b0421 002202f0 c7ff2868 0121eff7  .K.!."....(h.!..
 1a2a0 0eff2868 018a69b1 00210422 05abeff7  ..(h..i..!."....
 1a2b0 dffe30b9 204605a9 f9f7bbf8 28680421  ..0. F......(h.!
 1a2c0 ede70a21 2046f9f7 e9f80020 07b030bd  ...! F..... ..0.
 1a2d0 dafb0100 e0070200 2e080200 bcfb0100  ................
 1a2e0 9c3b0020 ecfd0100 f0b587b0 224b0093  .;. ........"K..
 1a2f0 224b0193 224b0293 0d46224b 03900421  "K.."K...F"K...!
 1a300 06461746 20480022 02f08eff 284600f0  .F.F H."....(F..
 1a310 6dfd1e4b 1c480421 002202f0 85ff2b88  m..K.H.!."....+.
 1a320 ebb16a88 9a421ad3 06a90023 41f8043d  ..j..B.....#A..=
 1a330 0520fff7 eafd0446 b0b9059b 2a461868  . .....F....*F.h
 1a340 d98800f0 4afd0598 3946fef7 d3f80446  ....J...9F.....F
 1a350 48b90599 2cb93046 fff790fd 0ae00320  H...,.0F....... 
 1a360 08e02046 06e00624 0598eff7 f8fd0023  .. F...$.......#
 1a370 0593eee7 07b0f0bd 60fe0100 e0070200  ........`.......
 1a380 42080200 bcfb0100 9c3b0020 ecfd0100  B........;. ....
 1a390 f0b50746 89b00846 0c460221 fbf7ccf8  ...F...F.F.!....
 1a3a0 05460028 3ed12368 04aa1868 d98800f0  .F.(>.#h...h....
 1a3b0 2ffd204b 0093204b 0193204b 02930421  /. K.. K.. K...!
 1a3c0 2a461f4b 1f480397 02f02eff 04a800f0  *F.K.H..........
 1a3d0 27fd1c48 1c4b0421 2a4602f0 25ff2068  '..H.K.!*F..%. h
 1a3e0 0221eff7 6cfe2368 1b8adbb1 9df81060  .!..l.#h.......`
 1a3f0 20463146 fbf7a0f8 98b92368 186802f0   F1F......#h.h..
 1a400 46fe2368 adf81400 1b683846 023305a9  F.#h.....h8F.3..
 1a410 023e0696 0793f9f7 71f82068 9df81010  .>......q. h....
 1a420 dfe70546 38462946 f9f77ef8 284609b0  ...F8F)F..~.(F..
 1a430 f0bd00bf dafb0100 e0070200 50080200  ............P...
 1a440 bcfb0100 9c3b0020 ecfd0100 f0b587b0  .....;. ........
 1a450 1c4b0093 1c4b0193 1c4b0293 0d460022  .K...K...K...F."
 1a460 04211b4b 03900746 1a4802f0 ddfe2846  .!.K...F.H....(F
 1a470 00f0f0fc 184b1748 04210022 02f0d4fe  .....K.H.!."....
 1a480 2b88a3b1 06a90026 41f8046d 0320fff7  +......&A..m. ..
 1a490 3cfd0446 78b9059b 2a461868 d98800f0  <..Fx...*F.h....
 1a4a0 d3fc0599 2cb93846 fff7e8fc 08e00320  ....,.8F....... 
 1a4b0 06e02046 04e00598 eff751fd 0596f0e7  .. F......Q.....
 1a4c0 07b0f0bd 60fe0100 e0070200 5e080200  ....`.......^...
 1a4d0 bcfb0100 9c3b0020 ecfd0100 70b586b0  .....;. ....p...
 1a4e0 154b164e 0093164b 0193164b 02930c46  .K.N...K...K...F
 1a4f0 05460390 04213046 0022134b 02f094fe  .F...!0F.".K....
 1a500 124b3046 00220421 02f08efe 20680121  .K0F.".!.... h.!
 1a510 eff7d5fd 05a90df1 12022068 fff7d8fc  .......... h....
 1a520 04462146 2846059a bdf81230 f9f788f8  .F!F(F.....0....
 1a530 204606b0 70bd00bf dafb0100 9c3b0020   F..p........;. 
 1a540 e0070200 67080200 bcfb0100 ecfd0100  ....g...........
 1a550 f0b587b0 1c4b0093 1c4b0193 1c4b0293  .....K...K...K..
 1a560 0d460022 04211b4b 03900746 1a4802f0  .F.".!.K...F.H..
 1a570 5bfe2846 00f08efc 184b1748 04210022  [.(F.....K.H.!."
 1a580 02f052fe 2b88a3b1 06a90026 41f8046d  ..R.+......&A..m
 1a590 0520fff7 bafc0446 78b9059b 2a461868  . .....Fx...*F.h
 1a5a0 d98800f0 6efc0599 2cb93846 fff766fc  ....n...,.8F..f.
 1a5b0 08e00320 06e02046 04e00598 eff7cffc  ... .. F........
 1a5c0 0596f0e7 07b0f0bd 60fe0100 e0070200  ........`.......
 1a5d0 70080200 bcfb0100 9c3b0020 ecfd0100  p........;. ....
 1a5e0 70b586b0 154b164e 0093164b 0193164b  p....K.N...K...K
 1a5f0 02930c46 05460390 04213046 0022134b  ...F.F...!0F.".K
 1a600 02f012fe 124b3046 00220421 02f00cfe  .....K0F.".!....
 1a610 20680121 eff753fd 05a90df1 12022068   h.!..S....... h
 1a620 fff756fc 04462146 2846059a bdf81230  ..V..F!F(F.....0
 1a630 f9f722f8 204606b0 70bd00bf dafb0100  ..". F..p.......
 1a640 9c3b0020 e0070200 7e080200 bcfb0100  .;. ....~.......
 1a650 ecfd0100 70b586b0 154b164e 0093164b  ....p....K.N...K
 1a660 0193164b 02930c46 05460390 04213046  ...K...F.F...!0F
 1a670 0022134b 02f0d8fd 124b3046 00220421  .".K.....K0F.".!
 1a680 02f0d2fd 20680121 eff719fd 05a90df1  .... h.!........
 1a690 12022068 fff71cfc 04462146 2846059a  .. h.....F!F(F..
 1a6a0 bdf81230 f8f7fdff 204606b0 70bd00bf  ...0.... F..p...
 1a6b0 dafb0100 9c3b0020 e0070200 9a080200  .....;. ........
 1a6c0 bcfb0100 ecfd0100 f0b587b0 214b0093  ............!K..
 1a6d0 214b0193 214b0293 0d46214b 03900421  !K..!K...F!K...!
 1a6e0 06461746 1f480022 02f09efd 284600f0  .F.F.H."....(F..
 1a6f0 f7fb1d4b 1b480421 002202f0 95fd2b88  ...K.H.!."....+.
 1a700 13b36a88 9a421fd3 06a90023 41f8043d  ..j..B.....#A..=
 1a710 0520fff7 fafb0446 58b9059b 2a461868  . .....FX...*F.h
 1a720 d98800f0 d4fb0598 3946fdf7 e3fe0446  ........9F.....F
 1a730 20b10598 eff713fc 00230593 05992cb9   ........#....,.
 1a740 3046fff7 9bfb02e0 032000e0 204607b0  0F....... .. F..
 1a750 f0bd00bf 60fe0100 e0070200 a8080200  ....`...........
 1a760 bcfb0100 9c3b0020 ecfd0100 f0b50746  .....;. .......F
 1a770 89b00846 0c460221 faf7defe 05460028  ...F.F.!.....F.(
 1a780 48d12368 04aa1868 d98800f0 bbfb254b  H.#h...h......%K
 1a790 0093254b 0193254b 02930421 2a46244b  ..%K..%K...!*F$K
 1a7a0 24480397 02f040fd 04a800f0 b3fb2148  $H....@.......!H
 1a7b0 214b0421 2a4602f0 37fd2068 0221eff7  !K.!*F..7. h.!..
 1a7c0 7efc2368 1b8a2bb3 9df81060 042e1fdd  ~.#h..+....`....
 1a7d0 20463146 faf7b0fe d8b92368 186802f0   F1F......#h.h..
 1a7e0 56fc2368 adf81400 18680230 02f04ffc  V.#h.....h.0..O.
 1a7f0 2368adf8 16001b68 38460433 05a9043e  #h.....h8F.3...>
 1a800 06960793 f8f7a6fe 20689df8 1010d6e7  ........ h......
 1a810 04200546 38462946 f8f7e0fe 284609b0  . .F8F)F....(F..
 1a820 f0bd00bf dafb0100 e0070200 bc080200  ................
 1a830 bcfb0100 9c3b0020 ecfd0100 30b585b0  .....;. ....0...
 1a840 0d4b0e4d 00930e4b 01930e4b 02930446  .K.M...K...K...F
 1a850 03900421 28460022 0b4b02f0 e5fc2846  ...!(F.".K....(F
 1a860 04210022 094b02f0 dffc2046 f8f731ff  .!.".K.... F..1.
 1a870 002005b0 30bd00bf dafb0100 9c3b0020  . ..0........;. 
 1a880 e0070200 0c090200 bcfb0100 ecfd0100  ................
 1a890 2de9f041 86b01f46 264b0093 264b0193  -..A...F&K..&K..
 1a8a0 264b0293 0d46264b 03900421 06469046  &K...F&K...!.F.F
 1a8b0 24480022 02f0b8fc 284600f0 73fb224b  $H."....(F..s."K
 1a8c0 20480421 002202f0 affc2b88 0bb90320   H.!."....+.... 
 1a8d0 2ce06b88 3b44b3f5 007ff8dc 3046fff7  ,.k.;D......0F..
 1a8e0 89fa0438 b842f2dd 06a90023 41f8043d  ...8.B.....#A..=
 1a8f0 0520fff7 0afb0446 60b9059b 2a461868  . .....F`...*F.h
 1a900 d98800f0 36fb0598 41463a46 fff712fb  ....6...AF:F....
 1a910 044620b1 0598eff7 22fb0023 05930599  .F ....."..#....
 1a920 1cb93046 fff7aafa 00e02046 06b0bde8  ..0F...... F....
 1a930 f08100bf 60fe0100 e0070200 da080200  ....`...........
 1a940 bcfb0100 9c3b0020 ecfd0100 70b588b0  .....;. ....p...
 1a950 00230646 0d460846 05210693 0793adf8  .#.F.F.F.!......
 1a960 1630faf7 e9fd0446 30bb2b68 06aa1868  .0.....F0.+h...h
 1a970 d98800f0 07fb164b 0093164b 0193164b  .......K...K...K
 1a980 02932246 0421154b 15480396 02f04cfc  .."F.!.K.H....L.
 1a990 06a800f0 07fb2246 124b1148 042102f0  ......"F.K.H.!..
 1a9a0 43fc2868 0521eff7 8afb2868 07a90df1  C.(h.!....(h....
 1a9b0 1602fff7 8dfa0446 bdf81630 00933046  .......F...0..0F
 1a9c0 214606aa 079bf8f7 95fe2046 08b070bd  !F........ F..p.
 1a9d0 dafb0100 e0070200 e9080200 bcfb0100  ................
 1a9e0 9c3b0020 ecfd0100 f0b587b0 1d4b0093  .;. .........K..
 1a9f0 1d4b0193 1d4b0293 0e460022 04211c4b  .K...K...F.".!.K
 1aa00 03900746 1b4802f0 0ffc3046 00f0e4fa  ...F.H....0F....
 1aa10 1848194b 04210022 02f006fc 357815f0  .H.K.!."....5x..
 1aa20 fe0513d1 06a90220 41f8045d fff76dfa  ....... A..]..m.
 1aa30 044678b9 059b3246 1868d988 00f0c7fa  .Fx...2F.h......
 1aa40 05992cb9 3846fff7 19fa08e0 032006e0  ..,.8F....... ..
 1aa50 204604e0 0598eff7 82fa0595 f0e707b0   F..............
 1aa60 f0bd00bf 60fe0100 e0070200 f8080200  ....`...........
 1aa70 bcfb0100 9c3b0020 ecfd0100 7fb5134b  .....;. .......K
 1aa80 0093134b 0193134b 02930e46 03900421  ...K...K...F...!
 1aa90 0022114b 05461148 02f0c6fb 0f48104b  .".K.F.H.....H.K
 1aaa0 04210022 02f0c0fb 30460121 faf744fd  .!."....0F.!..D.
 1aab0 044620b9 33681868 d98800f0 9dfa2846  .F .3h.h......(F
 1aac0 2146f8f7 35fe2046 04b070bd dafb0100  !F..5. F..p.....
 1aad0 e0070200 07090200 bcfb0100 9c3b0020  .............;. 
 1aae0 ecfd0100 2de9f041 86b01f46 204b0093  ....-..A...F K..
 1aaf0 204b0193 204b0293 0d46204b 03900421   K.. K...F K...!
 1ab00 06469046 1e480022 02f08efb 284600f0  .F.F.H."....(F..
 1ab10 81fa1c4b 1a480421 002202f0 85fb2b88  ...K.H.!."....+.
 1ab20 03b306a9 002341f8 043d0320 fff7edf9  .....#A..=. ....
 1ab30 044660b9 059b2a46 1868d988 00f064fa  .F`...*F.h....d.
 1ab40 05984146 3a46fff7 f5f90446 20b10598  ..AF:F.....F ...
 1ab50 eff705fa 00230593 05992cb9 3046fff7  .....#....,.0F..
 1ab60 8df902e0 032000e0 204606b0 bde8f081  ..... .. F......
 1ab70 60fe0100 e0070200 16090200 bcfb0100  `...............
 1ab80 9c3b0020 ecfd0100 2de9f041 86b01f46  .;. ....-..A...F
 1ab90 204b0093 204b0193 204b0293 0d46204b   K.. K.. K...F K
 1aba0 03900421 06469046 1e480022 02f03cfb  ...!.F.F.H."..<.
 1abb0 284600f0 49fa1c4b 1a480421 002202f0  (F..I..K.H.!."..
 1abc0 33fb2b88 03b306a9 002341f8 043d0320  3.+......#A..=. 
 1abd0 fff79bf9 044660b9 059b2a46 1868d988  .....F`...*F.h..
 1abe0 00f02cfa 05984146 3a46fff7 a3f90446  ..,...AF:F.....F
 1abf0 20b10598 eff7b3f9 00230593 05992cb9   ........#....,.
 1ac00 3046fff7 3bf902e0 032000e0 204606b0  0F..;.... .. F..
 1ac10 bde8f081 60fe0100 e0070200 21090200  ....`.......!...
 1ac20 bcfb0100 9c3b0020 ecfd0100 30b585b0  .....;. ....0...
 1ac30 0d4b0e4d 00930e4b 01930e4b 02930446  .K.M...K...K...F
 1ac40 03900421 28460022 0b4b02f0 edfa2846  ...!(F.".K....(F
 1ac50 04210022 094b02f0 e7fa2046 f8f77efd  .!.".K.... F..~.
 1ac60 002005b0 30bd00bf dafb0100 9c3b0020  . ..0........;. 
 1ac70 e0070200 2e090200 bcfb0100 ecfd0100  ................
 1ac80 43781370 4388a2f8 01300379 d3707047  Cx.pC....0.y.ppG
 1ac90 01230370 13784370 b2f80130 4380d378  .#.p.xCp...0C..x
 1aca0 03717047 1fb50378 0093b0f8 01300193  .qpG...x.....0..
 1acb0 c3780293 0448054b 04210022 02f0b4fa  .x...H.K.!."....
 1acc0 05b05df8 04fb00bf 9c3b0020 3b090200  ..]......;. ;...
 1acd0 b0f80130 13807047 03230370 1388a0f8  ...0..pG.#.p....
 1ace0 01307047 07b50388 00930448 044b0421  .0pG.......H.K.!
 1acf0 002202f0 99fa03b0 5df804fb 9c3b0020  ."......]....;. 
 1ad00 61090200 b0f80130 1380b0f8 03305380  a......0.....0S.
 1ad10 70470423 03701388 a0f80130 5388a0f8  pG.#.p.....0S...
 1ad20 03307047 07b50388 00934388 01930448  .0pG......C....H
 1ad30 044b0421 002202f0 77fa03b0 5df804fb  .K.!."..w...]...
 1ad40 9c3b0020 68090200 43781370 70470523  .;. h...Cx.ppG.#
 1ad50 03701378 43707047 07b50378 00930448  .p.xCppG...x...H
 1ad60 044b0421 002202f0 5ffa03b0 5df804fb  .K.!.".._...]...
 1ad70 9c3b0020 8e090200 b0f80130 1380b0f8  .;. .......0....
 1ad80 03305380 b0f80530 93807047 06230370  .0S....0..pG.#.p
 1ad90 1388a0f8 01305388 a0f80330 9388a0f8  .....0S....0....
 1ada0 05307047 1fb50388 00934388 01938388  .0pG......C.....
 1adb0 02930448 044b0421 002202f0 35fa05b0  ...H.K.!."..5...
 1adc0 5df804fb 9c3b0020 98090200 b0f80130  ]....;. .......0
 1add0 1380b0f8 03305380 70470823 03701388  .....0S.pG.#.p..
 1ade0 a0f80130 5388a0f8 03307047 07b50388  ...0S....0pG....
 1adf0 00934388 01930448 044b0421 002202f0  ..C....H.K.!."..
 1ae00 13fa03b0 5df804fb 9c3b0020 68090200  ....]....;. h...
 1ae10 43781370 70470923 03701378 43707047  Cx.ppG.#.p.xCppG
 1ae20 07b50378 00930448 044b0421 002202f0  ...x...H.K.!."..
 1ae30 fbf903b0 5df804fb 9c3b0020 cb090200  ....]....;. ....
 1ae40 b0f80130 13807047 0a230370 1388a0f8  ...0..pG.#.p....
 1ae50 01307047 07b50388 00930448 044b0421  .0pG.......H.K.!
 1ae60 002202f0 e1f903b0 5df804fb 9c3b0020  ."......]....;. 
 1ae70 80090200 b0f80130 1380b0f8 03305380  .......0.....0S.
 1ae80 70470c23 03701388 a0f80130 5388a0f8  pG.#.p.....0S...
 1ae90 03307047 07b50388 00934388 01930448  .0pG......C....H
 1aea0 044b0421 002202f0 bff903b0 5df804fb  .K.!."......]...
 1aeb0 9c3b0020 d5090200 70470f23 03707047  .;. ....pG.#.ppG
 1aec0 b0f80130 1380b0f8 03305380 70471023  ...0.....0S.pG.#
 1aed0 03701388 a0f80130 5388a0f8 03307047  .p.....0S....0pG
 1aee0 07b50388 00934388 01930448 044b0421  ......C....H.K.!
 1aef0 002202f0 99f903b0 5df804fb 9c3b0020  ."......]....;. 
 1af00 68090200 43781370 70471123 03701378  h...Cx.ppG.#.p.x
 1af10 43707047 07b50378 00930448 044b0421  CppG...x...H.K.!
 1af20 002202f0 81f903b0 5df804fb 9c3b0020  ."......]....;. 
 1af30 cb090200 b0f80130 13807047 b0f80130  .......0..pG...0
 1af40 13807047 07b50388 00930448 044b0421  ..pG.......H.K.!
 1af50 002202f0 69f903b0 5df804fb 9c3b0020  ."..i...]....;. 
 1af60 80090200 b0f80130 1380b0f8 03305380  .......0.....0S.
 1af70 70471623 03701388 a0f80130 5388a0f8  pG.#.p.....0S...
 1af80 03307047 b0f80130 1380b0f8 03305380  .0pG...0.....0S.
 1af90 70471723 03701388 a0f80130 5388a0f8  pG.#.p.....0S...
 1afa0 03307047 07b50388 00934388 01930448  .0pG......C....H
 1afb0 044b0421 002202f0 37f903b0 5df804fb  .K.!."..7...]...
 1afc0 9c3b0020 d5090200 43781370 70471823  .;. ....Cx.ppG.#
 1afd0 03701378 43707047 07b50378 00930448  .p.xCppG...x...H
 1afe0 044b0421 002202f0 1ff903b0 5df804fb  .K.!."......]...
 1aff0 9c3b0020 ed090200 70471923 03707047  .;. ....pG.#.ppG
 1b000 b0f80130 13807047 1b230370 1388a0f8  ...0..pG.#.p....
 1b010 01307047 07b50388 00930448 044b0421  .0pG.......H.K.!
 1b020 002202f0 01f903b0 5df804fb 9c3b0020  ."......]....;. 
 1b030 80090200 b0f80130 13807047 1d230370  .......0..pG.#.p
 1b040 1388a0f8 01307047 07b50388 00930448  .....0pG.......H
 1b050 044b0421 002202f0 e7f803b0 5df804fb  .K.!."......]...
 1b060 9c3b0020 80090200 1e230370 704710b5  .;. .....#.ppG..
 1b070 1446faf7 61fa0628 0cbf1123 002304b1  .F..a..(...#.#..
 1b080 237010bd 2de9f047 88b00729 06460c46  #p..-..G...).F.F
 1b090 15469946 9df84070 5fd009b1 002f5cd0  .F.F..@p_..../\.
 1b0a0 f9f750fb 304606a9 05aafef7 99fd059b  ..P.0F..........
 1b0b0 6bb194b9 2b681878 fef79cfd 06980599  k...+h.x........
 1b0c0 2a46faf7 7dfc0446 28b90546 00e00724  *F..}..F(..F...$
 1b0d0 f9f740fb 41e00e27 0025234a ddf81880  ..@.A..'.%#J....
 1b0e0 1369ddf8 14a00133 1361faf7 13fa0646  .i.....3.a.....F
 1b0f0 70b30521 eff7bcf8 58b3bdf8 4430adf8  p..!....X...D0..
 1b100 1d300521 07aa8df8 1c908df8 1f70fff7  .0.!.........p..
 1b110 bffd164b 0093164b 0193164b 0293b8f8  ...K...K...K....
 1b120 04300393 04210022 134b1448 02f07cf8  .0...!.".K.H..|.
 1b130 07a8fff7 b7fd1148 114b0421 002202f0  .......H.K.!."..
 1b140 73f84046 51463246 faf73afc 0028bfd0  s.@FQF2F..:..(..
 1b150 00263046 eef703ff bae72846 eef7fffe  .&0F......(F....
 1b160 204608b0 bde8f087 143d0020 60fe0100   F.......=. `...
 1b170 e0070200 e4070200 bcfb0100 9c3b0020  .............;. 
 1b180 ecfd0100 f8b5bdf8 18501e46 002d038a  .........P.F.-..
 1b190 14bf0624 14242344 8b421746 1cdc2146  ...$.$#D.B.F..!F
 1b1a0 eff766f8 0446c8b1 394601f0 55ffa01c  ..f..F..9F..U...
 1b1b0 314601f0 51ff201d 1db12946 01f04cff  1F..Q. ...)F..L.
 1b1c0 08e0079b 03f11002 53f8041b 40f8041b  ........S...@...
 1b1d0 9342f9d1 0020f8bd 0420f8bd 0620f8bd  .B... ... ... ..
 1b1e0 f7b50f46 09880546 164619b3 028a0432  ...F...F.F.....2
 1b1f0 9a4221dc 02ac24f8 021d2046 01f02cff  .B!...$... F..,.
 1b200 28462146 0222eef7 b3fe20b1 089b1122  (F!F.".... ...."
 1b210 1a700620 11e03188 adf80610 204601f0  .p. ..1..... F..
 1b220 1bff2846 21460222 eef7a2fe 0028edd1  ..(F!F.".....(..
 1b230 38803080 012000e0 002003b0 f0bd0000  8.0.. ... ......
 1b240 10b50446 8068eef7 8afe2146 0248bde8  ...F.h....!F.H..
 1b250 1040eff7 e5b800bf e0230020 2de9f041  .@.......#. -..A
 1b260 07461e46 49b102f0 040802f0 08045ffa  .F.FI........._.
 1b270 88f8e4b2 02f01002 08e002f0 200802f0  ............ ...
 1b280 40045ffa 88f8e4b2 22f07f02 d2b2b8f1  @._.....".......
 1b290 000f04d1 1cb912b9 0020bde8 f081f9f7  ......... ......
 1b2a0 51fa3846 f9f7f6ff 074600b1 456cf9f7  Q.8F.....F..El..
 1b2b0 51fa17b9 0720bde8 f081b8f1 000f07d0  Q.... ..........
 1b2c0 ea0705d4 05233370 40f20510 bde8f081  .....#3p@.......
 1b2d0 002ce1d0 ab07f5d5 dee7f0b5 1d464ff6  .,...........FO.
 1b2e0 ff739842 85b00646 0c461746 0dd1e369  .s.B...F.F.F...i
 1b2f0 00970193 e18aa769 3046221d 0223b847  .......i0F"..#.G
 1b300 b0b18df8 0f000920 0ee00a7d 930704d4  ....... ...}....
 1b310 03238df8 0f300820 06e00021 0df10f03  .#...0. ...!....
 1b320 fff79cff 0028e2d0 15b19df8 0f302b70  .....(.......0+p
 1b330 05b0f0bd f0b585b0 1f460023 8df80f30  .........F.#...0
 1b340 4ff6ff73 98420546 0c461646 0bd1fef7  O..s.B.F.F.F....
 1b350 4dfd4ff6 ff739d42 7060b060 12d02846  M.O..s.Bp`.`..(F
 1b360 fef748fd 0fe00a7d d30704d4 02238df8  ..H....}.....#..
 1b370 0f300820 16e00121 0df10f03 fff76eff  .0. ...!......n.
 1b380 80b9e4e7 f0200138 7080e369 00960193  ..... .8p..i....
 1b390 e18aa669 2846221d 0123b047 30b18df8  ...i(F"..#.G0...
 1b3a0 0f000920 17b19df8 0f303b70 05b0f0bd  ... .....0;p....
 1b3b0 2de9f041 06461848 88461546 1f46eff7  -..A.F.H.F.F.F..
 1b3c0 1bf80446 10b32022 0021edf7 22fe3046  ...F.. ".!..".0F
 1b3d0 231d06f1 100250f8 041b43f8 041b9042  #.....P...C....B
 1b3e0 f9d10e4a 84f81480 1388a761 01339bb2  ...J.......a.3..
 1b3f0 1380069a e2610a4a e3825168 00202060  .....a.J..Qh.  `
 1b400 0c605460 2db12b80 bde8f081 0620bde8  .`T`-.+...... ..
 1b410 f0812846 bde8f081 c0230020 dc230020  ..(F.....#. .#. 
 1b420 00240020 70b586b0 0e4602a9 15461c46  .$. p....F...F.F
 1b430 fdf748f8 38b90a9b 009302a8 31462a46  ..H.8.......1F*F
 1b440 2346fff7 b5ff06b0 70bd0000 014b1888  #F......p....K..
 1b450 704700bf dc230020 034b1b68 13b1da8a  pG...#. .K.h....
 1b460 8242fad1 18467047 00240020 70b50646  .B...FpG.$. p..F
 1b470 08461546 1c46fff7 efff0146 30b13046  .F.F.F.....F0.0F
 1b480 2a462346 bde87040 fff727bf 01232370  *F#F..p@..'..##p
 1b490 052070bd 70b50e46 154610b9 0a4b1c68  . p.p..F.F...K.h
 1b4a0 0be00468 09e0e38a ab4208d8 201d3146  ...h.....B.. .1F
 1b4b0 1022edf7 95fd20b1 2468002c f3d10020  .".... .$h.,... 
 1b4c0 70bd2046 70bd00bf 00240020 70b50646  p. Fp....$. p..F
 1b4d0 08461546 1c46fff7 bfff0146 18b94cb1  .F.F.F.....F..L.
 1b4e0 01232370 06e03046 2a462346 bde87040  .##p..0F*F#F..p@
 1b4f0 fff720bf 052070bd 2de9f043 89b00546  .. .. p.-..C...F
 1b500 0e460846 0df11302 0321fff7 b0fd0446  .F.F.....!.....F
 1b510 002857d1 33683f4e 1868d988 05aafff7  .(W.3h?N.h......
 1b520 d7fb3d4b 00933d4b 02932246 04213c4b  ..=K..=K.."F.!<K
 1b530 3c480196 039501f0 77fe05a8 fff7d2fb  <H......w.......
 1b540 22463848 384b0421 01f06efe 8df81340  "F8H8K.!..n....@
 1b550 f9f7f8f8 21462846 07aafef7 41fb3746  ....!F(F....A.7F
 1b560 044610b9 079bb3f8 0690f9f7 f3f84cbb  .F............L.
 1b570 f9f7d0ff 804618b1 0321eef7 79fe20b9  .....F...!..y. .
 1b580 11238df8 13300624 1ee008ae 032126f8  .#...0.$.....!&.
 1b590 089d3246 fff7a0fb 244b0395 8de88800  ..2F....$K......
 1b5a0 234b0293 22460421 1d4b1e48 01f03cfe  #K.."F.!.K.H..<.
 1b5b0 3046fff7 97fb1b48 1b4b0421 224601f0  0F.....H.K.!"F..
 1b5c0 33fe01e0 4ff00008 9df81330 00930023  3...O......0...#
 1b5d0 01932146 28464246 0223fff7 53fd0446  ..!F(FBF.#..S..F
 1b5e0 98b9f9f7 aff82846 07a906aa fef7f8fa  ......(F........
 1b5f0 069840b1 bdf81410 fef70ffc 069a137b  ..@............{
 1b600 43f00103 1373f9f7 a5f82046 09b0bde8  C....s.... F....
 1b610 f08300bf e0070200 dafb0100 ee070200  ................
 1b620 bcfb0100 9c3b0020 ecfd0100 60fe0100  .....;. ....`...
 1b630 f6070200 2de9f04f 89b008aa 00258046  ....-..O.....%.F
 1b640 0e460846 02f8055d 0521fff7 10fd0446  .F.F...].!.....F
 1b650 002840f0 ae803368 5f4e1868 d98807aa  .(@...3h_N.h....
 1b660 fff750fb 5d4b0093 5d4b0293 04212246  ..P.]K..]K...!"F
 1b670 5c4b5d48 0196cdf8 0c8001f0 d5fd07a8  \K]H............
 1b680 fff750fb 2246594b 57480421 01f0ccfd  ..P."FYKWH.!....
 1b690 bdf81c30 bdf81e20 9a4200d3 2bb90122  ...0... .B..+.."
 1b6a0 8df81b20 00250a24 84e04046 fef7a2fb  ... .%.$..@F....
 1b6b0 82460028 78d0f9f7 2dff0546 18b10221  .F.(x...-..F...!
 1b6c0 eef7d6fd 20b91123 8df81b30 06246de0  .... ..#...0.$m.
 1b6d0 022106aa fff73bfb 454b4348 cdf80c80  .!....;.EKCH....
 1b6e0 8de84800 434b0293 04212246 3d4b01f0  ..H.CK...!"F=K..
 1b6f0 9bfd06a8 fff730fb 3c4b3b48 04212246  ......0.<K;H.!"F
 1b700 01f092fd 2f683c4b 7c701e68 a146002e  ..../h<K|p.h.F..
 1b710 5dd0f38a bdf81e20 9a4258d3 bdf81c20  ]...... .BX.... 
 1b720 9a423ad8 06f1040b 5846fcf7 b5fe7b78  .B:.....XF....{x
 1b730 049038b1 13b90123 7b7001e0 012b46d1  ..8....#{p...+F.
 1b740 042106e0 13b90223 7b7001e0 022b3ed1  .!.....#{p...+>.
 1b750 12212b8a 0b445345 39dc2846 eef788fd  .!+..DSE9.(F....
 1b760 0590e0b1 f18a01f0 77fc7b78 059a012b  ........w.{x...+
 1b770 06d0022b 0fd15b46 02320bf1 100104e0  ...+..[F.2......
 1b780 901c0499 01f068fc 05e053f8 040b42f8  ......h...S...B.
 1b790 040b8b42 f9d109f1 01093668 b7e70a23  ...B......6h...#
 1b7a0 8df81b30 052401e0 07240546 bdf81c30  ...0.$...$.F...0
 1b7b0 00e02b46 9df81b20 40468de8 0c002146  ..+F... @F....!F
 1b7c0 2a460423 fff75efc 09b0bde8 f08fb9f1  *F.#..^.........
 1b7d0 000fe4d0 0023ede7 e0070200 dafb0100  .....#..........
 1b7e0 fe070200 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 1b7f0 60fe0100 0c080200 00240020 2de9f04f  `........$. -..O
 1b800 8fb00eae 002506f8 1d5d0746 88460846  .....%...].F.F.F
 1b810 32460721 fff72bfc 04460028 40f0a280  2F.!..+..F.(@...
 1b820 d8f80030 6e4d1868 d98808aa fff7a4fa  ...0nM.h........
 1b830 6c4b0093 6c4b0293 04212246 6b4b6c48  lK..lK...!"FkKlH
 1b840 01950397 01f0f0fc 08a8fff7 abfa2246  .............."F
 1b850 684b6748 042101f0 e7fcbdf8 2030bdf8  hKgH.!...... 0..
 1b860 22200595 9a4200d3 2bb90122 8df81b20  " ...B..+.."... 
 1b870 00250a24 77e0d8f8 00a0f9f7 4bfe0546  .%.$w.......K..F
 1b880 20b91123 8df81b30 0624a6e0 0121eef7   ..#...0.$...!..
 1b890 effc0028 f5d04ff0 070b80f8 00b03846  ...(..O.......8F
 1b8a0 fef7a8fa 80460028 00f09680 524badf8  .....F.(....RK..
 1b8b0 1c40d3f8 00b0adf8 1e40bbf1 000f26d0  .@.......@....&.
 1b8c0 bbf81630 bdf82220 9a4220d3 bdf82020  ...0.." .B ...  
 1b8d0 9a4255d8 0bf10400 fcf7defd bdf82430  .BU...........$0
 1b8e0 83424dd1 0eaa0023 22f8103d 38465946  .BM....#"..=8FYF
 1b8f0 3346fff7 1ffd0446 a8b95046 07210c9a  3F.....F..PF.!..
 1b900 bdf83430 eef726fc 002847d0 38e00096  ..40..&..(G.8...
 1b910 284607a9 0df11e02 4346fff7 61fc0128  (F......CF..a..(
 1b920 14bf0446 00242b8a 002c56d1 012b14d9  ...F.$+..,V..+..
 1b930 324b0093 059b0193 314b0293 2c482b4b  2K......1K..,H+K
 1b940 03970421 224601f0 6ffc2a4b 28480421  ...!"F..o.*K(H.!
 1b950 224601f0 69fc2346 05e00a23 8df81b30  "F..i.#F...#...0
 1b960 05243ae0 2b469df8 1b203846 8de80c00  .$:.+F... 8F....
 1b970 21462a46 0623fff7 85fb0fb0 bde8f08f  !F*F.#..........
 1b980 00962846 07a90df1 1e024346 fff728fc  ..(F......CF..(.
 1b990 0446012c c7d1dbf8 00b08ee7 bdf81c30  .F.,...........0
 1b9a0 bbf81690 13b9adf8 1c9004e0 bdf81e30  ...............0
 1b9b0 01339945 02d1adf8 1e90ece7 00962846  .3.E..........(F
 1b9c0 07a90df1 1e024346 fff70afc adf81c90  ......CF........
 1b9d0 0446adf8 1e90dce7 5c46bdf8 2030c2e7  .F......\F.. 0..
 1b9e0 e0070200 dafb0100 1a080200 bcfb0100  ................
 1b9f0 9c3b0020 ecfd0100 00240020 60fe0100  .;. .....$. `...
 1ba00 2e080200 2de9f04f 0b680e46 198a0729  ....-..O.h.F...)
 1ba10 91b08046 02d01529 40f00981 30460df1  ...F...)@...0F..
 1ba20 1b02fff7 24fb0446 002840f0 f3803368  ....$..F.(@...3h
 1ba30 814f1868 d98807aa fff7c8f9 7f4b0093  .O.h.........K..
 1ba40 7f4b0293 04212246 7e4b7f48 0197cdf8  .K...!"F~K.H....
 1ba50 0c8001f0 e9fb07a8 fff7c8f9 7b4b7a48  ............{KzH
 1ba60 04212246 01f0e0fb bdf81c50 bdf81e30  .!"F.......P...0
 1ba70 0597ab42 00d32db9 01238df8 1b300027  ...B..-..#...0.'
 1ba80 0a24c9e0 3368da88 072a06d0 152a17d1  .$..3h...*...*..
 1ba90 1a6808ad 531d1532 09e01868 053001f0  .h..S..2...h.0..
 1baa0 f6fa08a9 fcf70efd 88b10a23 09e01868  ...........#...h
 1bab0 59682c46 03c40833 93422546 f7d106e0  Yh,F...3.B%F....
 1bac0 04232546 27468df8 1b301c46 a4e00026  .#%F'F...0.F...&
 1bad0 40468df8 1b60bdf8 1c50fef7 8bf90446  @F...`...P.....F
 1bae0 002800f0 9180f9f7 15fd0746 28b91123  .(.........F(..#
 1baf0 8df81b30 00250620 56e00221 eef7b8fb  ...0.%. V..!....
 1bb00 0028f4d0 b246b346 584608a9 bdf81e20  .(...F.FXF..... 
 1bb10 fff7c0fc 83460028 40d0c28a bdf81c30  .....F.(@......0
 1bb20 9a42f1d3 10aa0023 22f8103d 40465946  .B.....#"..=@FYF
 1bb30 0df11b03 fff7fefb 10b1bbf8 165030e0  .............P0.
 1bb40 bdf83c90 e21e4a45 d8bfa4f1 04090eb1  ..<...JE........
 1bb50 4e4526d1 3a8a0232 4a44a242 20dc09f1  NE&.:..2JD.B ...
 1bb60 02013846 89b2eef7 83fb0646 48b91123  ..8F.......FH..#
 1bb70 4e468df8 1b30bbf8 1650baf1 000f46d0  NF...0...P....F.
 1bb80 1ce0bbf8 161001f0 67fab01c 0e994a46  ........g.....JF
 1bb90 edf734fa 4e464ff0 010ab5e7 052000e0  ..4.NFO...... ..
 1bba0 4e46baf1 000f09d1 9df81b30 13b90a23  NF.........0...#
 1bbb0 8df81b30 002808bf 052029e0 0df1400a  ...0.(... )...@.
 1bbc0 02360024 0af8286d 8df81b40 3868f988  .6.$..(m...@8h..
 1bbd0 5246fff7 20f91e4b 0093059b 01931d4b  RF.. ..K.......K
 1bbe0 02930421 2246174b 1748cdf8 0c8001f0  ...!"F.K.H......
 1bbf0 1bfb5046 fff714f9 1348144b 04212246  ..PF.....H.K.!"F
 1bc00 01f012fb 204603e0 07460720 00e00620  .... F...F. ... 
 1bc10 044601e0 00252f46 9df81b30 40468de8  .F...%/F...0@F..
 1bc20 28002146 3a460823 fff72cfa 00e00a20  (.!F:F.#..,.... 
 1bc30 11b0bde8 f08f00bf e0070200 dafb0100  ................
 1bc40 42080200 bcfb0100 9c3b0020 ecfd0100  B........;. ....
 1bc50 60fe0100 50080200 2de9f047 8ab00aae  `...P...-..G....
 1bc60 002506f8 165d0746 88460846 32460321  .%...].F.F.F2F.!
 1bc70 fff7fdf9 04460028 69d1d8f8 0030dff8  .....F.(i....0..
 1bc80 08811868 d98805aa fff7daf8 374b0093  ...h........7K..
 1bc90 374b0293 22460421 364b3748 cdf80480  7K.."F.!6K7H....
 1bca0 039701f0 c1fa05a8 fff7d4f8 22463248  ............"F2H
 1bcb0 324b0421 01f0b8fa 3846bdf8 1410adf8  2K.!....8F......
 1bcc0 184006aa 3346fff7 01fc0446 00283bd1  .@..3F.....F.(;.
 1bcd0 3846ddf8 20a0bdf8 2490fef7 8bf80646  8F.. ...$......F
 1bce0 80b3f9f7 17fc0546 a0b10aa9 0b2301f8  .......F.....#..
 1bcf0 153d0122 eef73cf9 60b94e45 dcbf06f1  .=."..<.`.NE....
 1bd00 ff361ffa 86f92846 51464a46 eef730f9  .6....(FQFJF..0.
 1bd10 064620b1 11238df8 12300624 14e0184b  .F ..#...0.$...K
 1bd20 03978de8 0801174b 02933246 1248114b  .......K..2F.H.K
 1bd30 042101f0 79fa1048 104b0421 324601f0  .!..y..H.K.!2F..
 1bd40 73fa05e0 07240546 bdf81460 00e02e46  s....$.F...`...F
 1bd50 9df81230 38468de8 48002146 2a460a23  ...08F..H.!F*F.#
 1bd60 fff790f9 0ab0bde8 f08700bf dafb0100  ................
 1bd70 5e080200 bcfb0100 9c3b0020 ecfd0100  ^........;. ....
 1bd80 60fe0100 67080200 e0070200 2de9f047  `...g.......-..G
 1bd90 8ab00025 80460c46 8df81250 fef72af8  ...%.F.F...P..*.
 1bda0 07460028 7cd02046 05210df1 1202fff7  .F.(|. F.!......
 1bdb0 5ef90646 002875d1 2368414c 1868d988  ^..F.(u.#hAL.h..
 1bdc0 05aafff7 57f83f4b 00933f4b 02933246  ....W.?K..?K..2F
 1bdd0 04213e4b 3e480194 cdf80c80 01f024fa  .!>K>H........$.
 1bde0 05a8fff7 57f83246 39483a4b 042101f0  ....W.2F9H:K.!..
 1bdf0 1bfabdf8 1630adf8 18304046 bdf81410  .....0...0@F....
 1be00 06aa0df1 1203fff7 61fba146 0646c8b9  ........a..F.F..
 1be10 bdf82440 bdf81830 ba1e2344 9a4207dd  ..$@...0..#D.B..
 1be20 0b238df8 12300546 bdf81430 08263ae0  .#...0.F...0.&:.
 1be30 ddf820a0 f9f76efb 054630b9 11238df8  .. ...n..F0..#..
 1be40 12300626 bdf81430 2de00aa9 0d2301f8  .0.&...0-....#..
 1be50 153d0122 eef78cf8 0028efd1 a742dcbf  .=.".....(...B..
 1be60 07f1ff34 a4b22246 28465146 eef780f8  ...4.."F(FQF....
 1be70 04460028 e2d1184b 1548cdf8 0c808de8  .F.(...K.H......
 1be80 0802164b 02930421 2246104b 01f0ccf9  ...K...!"F.K....
 1be90 104b0f48 04212246 01f0c6f9 234602e0  .K.H.!"F....#F..
 1bea0 05460726 2b469df8 12204046 8de80c00  .F.&+F... @F....
 1beb0 31462a46 0c23fff7 e5f80ab0 bde8f087  1F*F.#..........
 1bec0 e0070200 dafb0100 70080200 bcfb0100  ........p.......
 1bed0 9c3b0020 ecfd0100 60fe0100 7e080200  .;. ....`...~...
 1bee0 2de9f04f 8bb0544b 0093544d 544b0293  -..O..TK..TMTK..
 1bef0 0e460390 04210022 524b0195 0df12809  .F...!."RK....(.
 1bf00 80465148 01f090f9 00244f48 4f4b0421  .FQH.....$OHOK.!
 1bf10 002201f0 89f909f8 114d0121 30464a46  .".......M.!0FJF
 1bf20 fff7a5f8 aa460146 002878d1 33681868  .....F.F.(x.3h.h
 1bf30 d988fef7 c1ff3068 0121eef7 c0f84046  ......0h.!....@F
 1bf40 fdf758ff 05460028 62d0f9f7 e3fa0746  ..X..F.(b......F
 1bf50 20b91123 8df81730 04460fe0 0121eef7   ..#...0.F...!..
 1bf60 87f90446 38b10121 fef7a7ff 3c8a2c1b  ...F8..!....<.,.
 1bf70 1ffa84fb 32e01123 8df81730 06254ce0  ....2..#...0.%L.
 1bf80 bbf1000f 2ed03046 02214a46 fff76ff8  ......0F.!JF..o.
 1bf90 05460028 40d13368 186801f0 78f80221  .F.(@.3h.h..x..!
 1bfa0 04463068 eef78bf8 0aaa4046 22f8105d  .F0h......@F"..]
 1bfb0 21464b46 fff78afa 054670bb bdf82450  !FKF.....Fp...$P
 1bfc0 08995d45 28bf5d46 38462a46 edf7d0ff  ..]E(.]F8F*F....
 1bfd0 0028d0d1 c5eb0b0b 1ffa8bfb 33681b8a  .(..........3h..
 1bfe0 012bcdd8 1a4b1848 cdf80c80 8de80804  .+...K.H........
 1bff0 184b0293 04210022 124b01f0 15f90025  .K...!.".K.....%
 1c000 1148124b 04210022 01f00ef9 2c4604e0  .H.K.!."....,F..
 1c010 04460725 074600e0 00242946 00e02746  .F.%.F...$)F..'F
 1c020 9df81730 40468de8 18003a46 0e23fff7  ...0@F....:F.#..
 1c030 29f80bb0 bde8f08f dafb0100 e0070200  )...............
 1c040 fa090200 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 1c050 60fe0100 9a080200 2de9f04f 0b680d46  `.......-..O.h.F
 1c060 198a0729 97b08046 02d01529 40f01f81  ...)...F...)@...
 1c070 28460df1 2302fef7 faff0446 002840f0  (F..#......F.(@.
 1c080 09812b68 9c4f1868 d98809aa fef718ff  ..+h.O.h........
 1c090 9a4b0093 9a4b0293 04212246 994b9a48  .K...K...!"F.K.H
 1c0a0 0197cdf8 0c8001f0 bff809a8 fef718ff  ................
 1c0b0 964b9548 04212246 01f0b6f8 bdf82460  .K.H.!"F......$`
 1c0c0 bdf82630 0697b342 00d32eb9 01238df8  ..&0...B.....#..
 1c0d0 23300027 0a24dfe0 28680521 0aaafcf7  #0.'.$..(h.!....
 1c0e0 24fa0546 28b10423 8df82330 bdf82460  $..F(..#..#0..$`
 1c0f0 efe70aa8 fcf7d0f9 a0f52050 80b20128  .......... P...(
 1c100 bdf82460 04d91023 8df82330 274655e0  ..$`...#..#0'FU.
 1c110 40468df8 2340fdf7 6dfe8146 002800f0  @F..#@..m..F.(..
 1c120 e180f9f7 f7f90746 20b10221 eef7a0f8  .......F ..!....
 1c130 059020b9 11238df8 23300624 ace0744b  .. ..#..#0.$..tK
 1c140 8df82050 d3f800a0 2c462a46 0de05846  .. P....,F*F..XF
 1c150 0792fcf7 a1f9a0f5 205080b2 0128079a  ........ P...(..
 1c160 2ed9baf8 1640daf8 00a0baf1 000f3ad0  .....@........:.
 1c170 baf81630 bdf82410 9942f4d8 bdf82610  ...0..$..B....&.
 1c180 9942c0f0 b2800af1 040b002a dfd15846  .B.........*..XF
 1c190 0aa91022 ecf724ff 03460028 40f0a080  ..."..$..F.(@...
 1c1a0 16aa4ff6 ff7022f8 103d5146 fff7c2f8  ..O..p"..=QF....
 1c1b0 58b30e23 baf81660 8df82330 08246be0  X..#...`..#0.$k.
 1c1c0 0eab0193 00952346 38464946 fef7daff  ......#F8FIF....
 1c1d0 04460028 dbd00628 baf81660 3ad11123  .F.(...(...`:..#
 1c1e0 8df82330 58e05ab3 4ff6ff74 0eab0193  ..#0X.Z.O..t....
 1c1f0 00952346 38464946 fef7c4ff 06280446  ..#F8FIF.....(.F
 1c200 1fd11123 8df82330 1be0bdf8 5430022b  ...#..#0....T0.+
 1c210 4fd0102b cdd1149b 0eac03f1 10051868  O..+...........h
 1c220 59682246 03c20833 ab421446 f7d10025  Yh"F...3.B.F...%
 1c230 9df82030 062b4bd0 142b4bd0 002b40d0  .. 0.+K..+K..+@.
 1c240 00243b8a 022b04d8 0a238df8 23300524  .$;..+...#..#0.$
 1c250 22e00cb1 042c1fd1 05980221 08aafef7  "....,.....!....
 1c260 54fe2c4b 0093069b 01932b4b 02930421  T.,K......+K...!
 1c270 0022244b 2448cdf8 0c8000f0 d5ff08a8  ."$K$H..........
 1c280 fef748fe 2048214b 04210022 00f0ccff  ..H. H!K.!."....
 1c290 002401e0 00263746 9df82330 40468de8  .$...&7F..#0@F..
 1c2a0 48002146 3a461023 fef7ecfe 21e00a20  H.!F:F.#....!.. 
 1c2b0 1fe01498 00f0ebfe 05460028 3ff479af  .........F.(?.y.
 1c2c0 b6e70db1 062300e0 14238df8 203003e0  .....#...#.. 0..
 1c2d0 15b9b5e7 002db3d1 baf81620 144642e7  .....-..... .FB.
 1c2e0 002240e7 07240746 d6e7002a 7ff47eaf  ."@..$.F...*..~.
 1c2f0 a6e717b0 bde8f08f e0070200 dafb0100  ................
 1c300 a8080200 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 1c310 00240020 60fe0100 bc080200 2de9f043  .$. `.......-..C
 1c320 8bb00aaf 002507f8 155d0646 88460846  .....%...].F.F.F
 1c330 3a460321 fef79bfe 04460028 60d1d8f8  :F.!.....F.(`...
 1c340 0030dff8 f4901868 d98805aa fef7f2fd  .0.....h........
 1c350 324b0093 324b0293 22460421 314b3248  2K..2K.."F.!1K2H
 1c360 cdf80490 039600f0 5fff05a8 fef7eafd  ........_.......
 1c370 22462e4b 2c480421 00f056ff 0321d8f8  "F.K,H.!..V..!..
 1c380 0000edf7 9cfefdf7 31fd0346 d8f80000  ........1..F....
 1c390 0693028a 08922146 edf76afe 3046bdf8  ......!F..j.0F..
 1c3a0 141006aa 3b46fff7 61f80446 10b1bdf8  ....;F..a..F....
 1c3b0 143026e0 f9f7aef8 054630b9 11238df8  .0&......F0..#..
 1c3c0 13300624 bdf81430 1be00121 edf750ff  .0.$...0...!..P.
 1c3d0 0028f3d0 13230370 154b1348 03968de8  .(...#.p.K.H....
 1c3e0 0802144b 02930421 22460e4b 00f01cff  ...K...!"F.K....
 1c3f0 0e4b0d48 04212246 00f016ff 234600e0  .K.H.!"F....#F..
 1c400 2b469df8 13203046 8de80c00 21462a46  +F... 0F....!F*F
 1c410 1223fef7 37fe0bb0 bde8f083 dafb0100  .#..7...........
 1c420 fd080200 bcfb0100 9c3b0020 ecfd0100  .........;. ....
 1c430 60fe0100 0c090200 e0070200 70b58ab0  `...........p...
 1c440 06460d46 08460df1 13020321 fef70ffe  .F.F.F.....!....
 1c450 04460028 31d12b68 05aa1868 d988fef7  .F.(1.+h...h....
 1c460 6dfd174b 0093174b 0193174b 02930421  m..K...K...K...!
 1c470 2246164b 16480396 00f0d6fe 05a8fef7  "F.K.H..........
 1c480 61fd2246 134b1248 042100f0 cdfe0321  a."F.K.H.!.....!
 1c490 2868edf7 14fefdf7 a9fc0346 28680693  (h.........F(h..
 1c4a0 028a0892 2146edf7 e3fd3046 bdf81410  ....!F....0F....
 1c4b0 06aa0df1 1303fef7 d9ff0ab0 70bd00bf  ............p...
 1c4c0 dafb0100 e0070200 d0080200 bcfb0100  ................
 1c4d0 9c3b0020 ecfd0100 10b50446 206820b1  .;. .......F h .
 1c4e0 03682360 fef7acfe f8e710bd 2de9f04f  .h#`........-..O
 1c4f0 87b006aa 00248146 0f460846 02f8054d  .....$.F.F.F...M
 1c500 0521fef7 b4fd0646 002840f0 e7803b68  .!.....F.(@...;h
 1c510 744d1868 d98805aa fef724fd 724b0093  tM.h......$.rK..
 1c520 724b0293 04213246 714b7248 0195cdf8  rK...!2FqKrH....
 1c530 0c9000f0 79fe05a8 fef734fd 32466e4b  ....y.....4.2FnK
 1c540 6c480421 00f070fe 38680521 edf7b7fd  lH.!..p.8h.!....
 1c550 bdf81440 2046fef7 7fffaa46 28b90123  ...@ F.....F(..#
 1c560 8df81330 05268346 55e06448 edf744ff  ...0.&.FU.dH..D.
 1c570 83460028 7ad03146 0c22ecf7 4afdf8f7  .F.(z.1F."..J...
 1c580 c9ffcbf8 080018b9 5846fef7 59fe6de0  ........XF..Y.m.
 1c590 bdf81430 abf80430 bdf81630 abf80630  ...0...0...0...0
 1c5a0 f8f7d0f8 4846f8f7 75fe0028 77d0026b  ....HF..u..(w..k
 1c5b0 bdf81410 bdf81640 1346b046 13b19d88  .......@.F.F....
 1c5c0 8d425cd9 b8f1000f 60d1cbf8 0020c0f8  .B\.....`.... ..
 1c5d0 30b03c68 6cb1dbf8 08002168 e288edf7  0.<hl.....!h....
 1c5e0 c7fc0028 59d00923 bdf81440 8df81330  ...(Y..#...@...0
 1c5f0 0646f8f7 aff8002e 71d13868 0521edf7  .F......q.8h.!..
 1c600 d6fd0546 38600028 4cd11123 bdf81440  ...F8`.(L..#...@
 1c610 8df81330 0626f8f7 95f84846 f8f73afe  ...0.&....HF..:.
 1c620 88b1bbf1 000f0fd0 b8f1000f 03d1036b  ...............k
 1c630 1b680363 03e0dbf8 0030c8f8 00305846  .h.c.....0...0XF
 1c640 fef7fefd 00e00726 f8f784f8 00259df8  .......&.....%..
 1c650 13304846 8de81800 31462a46 1623fef7  .0HF....1F*F.#..
 1c660 11fd0023 3b6007b0 bde8f08f 09238df8  ...#;`.......#..
 1c670 1330bdf8 14400626 4ff0000b cbe702d1  .0...@.&O.......
 1c680 dd88a542 9ed89846 1b6897e7 d8f80030  ...B...F.h.....0
 1c690 cbf80030 c8f800b0 9be7e468 9ae70726  ...0.......h...&
 1c6a0 0446a6e7 05aa0068 0521fef7 72fc144b  .F.....h.!..r..K
 1c6b0 cdf80c90 8de80804 124b0293 32460421  .........K..2F.!
 1c6c0 0b4b0c48 00f0b0fd 05a8fef7 6bfc0948  .K.H........k..H
 1c6d0 094b0421 324600f0 a7fdb8e7 a346072e  .K.!2F.......F..
 1c6e0 99d1b3e7 e0070200 dafb0100 da080200  ................
 1c6f0 bcfb0100 9c3b0020 ecfd0100 e0230020  .....;. .....#. 
 1c700 60fe0100 e9080200 2de9f04f 8bb08046  `.......-..O...F
 1c710 0c460846 0df11202 0221fef7 a8fc0646  .F.F.....!.....F
 1c720 002840f0 a0802368 04aa1868 d988fef7  .(@...#h...h....
 1c730 4bfc564b 0093564b 0193564b 02930421  K.VK..VK..VK...!
 1c740 3246554b 5548cdf8 0c8000f0 6dfd04a8  2FUKUH......m...
 1c750 fef742fc 5148524b 04213246 00f064fd  ..B.QHRK.!2F..d.
 1c760 f8f7d8fe 814620b9 11238df8 12300626  .....F ..#...0.&
 1c770 7be00121 edf77cfd 0028f5d0 0121fef7  {..!..|..(...!..
 1c780 3cfcf7f7 dfff4046 f8f784fd 044618b1  <.....@F.....F..
 1c790 036b0593 066300e0 0726f7f7 dbff002c  .k...c...&.....,
 1c7a0 54d09df8 104014f0 01044cd0 059d0023  T....@....L....#
 1c7b0 002d5ed0 ea881bb1 9c88a988 a14202d0  .-^..........B..
 1c7c0 3ab1ac88 53e0d988 9b681b8a 0b449342  :...S....h...D.B
 1c7d0 4dd1ab68 1b8a1344 b3f5007f 02ddac88  M..h...D........
 1c7e0 0d232be0 2b462d68 e2e7bbf8 04309c42  .#+.+F-h.....0.B
 1c7f0 12d15f46 002f43d0 b868d7f8 00b0028a  .._F./C..h......
 1c800 0aeb0503 0021edf7 33fcbb68 bc881b8a  .....!..3..h....
 1c810 1d44bbf1 000fe8d1 2046fef7 1dfe0146  .D...... F.....F
 1c820 88b34046 06aa0df1 1303cdf8 18a00895  ..@F............
 1c830 fef753fd 10b3bc88 9df81330 8df81230  ..S........0...0
 1c840 002b18bf 092605a8 fff746fe 9df81230  .+...&....F....0
 1c850 40468de8 18003146 4a461823 fef712fc  @F....1FJF.#....
 1c860 0bb0bde8 f08f4ff0 00090024 eee70723  ......O....$...#
 1c870 e4e7fdf7 bbfa059f 8246bbe7 0546b8e7  .........F...F..
 1c880 3c463b46 dae70123 d8e700bf dafb0100  <F;F...#........
 1c890 e0070200 f8080200 bcfb0100 9c3b0020  .............;. 
 1c8a0 ecfd0100 f0b50b68 1b8a022b 87b00746  .......h...+...F
 1c8b0 0d4601d8 0a2040e0 08460022 0321fef7  .F... @..F.".!..
 1c8c0 d6fb0446 002837d1 2b6805aa 1868d988  ...F.(7.+h...h..
 1c8d0 fef796fb 1a4b0093 1a4b0193 1a4b0293  .....K...K...K..
 1c8e0 04212246 194b1a48 039700f0 9dfc05a8  .!"F.K.H........
 1c8f0 fef790fb 174b1648 04212246 00f094fc  .....K.H.!"F....
 1c900 bdf81430 002bd5d0 28680321 edf7d7fb  ...0.+..(h.!....
 1c910 fdf76cfa 06462868 058a2146 2a463346  ..l..F(h..!F*F3F
 1c920 edf7a6fb 3846bdf8 14100094 32462b46  ....8F......2F+F
 1c930 f5f719fd 204600e0 062007b0 f0bd00bf  .... F... ......
 1c940 dafb0100 e0070200 16090200 bcfb0100  ................
 1c950 9c3b0020 ecfd0100 2de9f043 0b681b8a  .;. ....-..C.h..
 1c960 022b87b0 06460d46 02d80025 0a245fe0  .+...F.F...%.$_.
 1c970 08460022 0321fef7 7afb0446 002856d1  .F.".!..z..F.(V.
 1c980 2b68dff8 e4801868 d98805aa fef752fb  +h.....h......R.
 1c990 2e4b0093 2e4b0293 04212246 2d4b2e48  .K...K...!"F-K.H
 1c9a0 cdf80480 039600f0 3ffc05a8 fef74cfb  ........?.....L.
 1c9b0 2a4b2948 04212246 00f036fc bdf81430  *K)H.!"F..6....0
 1c9c0 002bd2d0 28680321 edf779fb fdf70efa  .+..(h.!..y.....
 1c9d0 81462868 058a2146 2a464b46 0127edf7  .F(h..!F*FKF.'..
 1c9e0 47fb2b46 bdf81410 00973046 4a46f5f7  G.+F......0FJF..
 1c9f0 bafcf8f7 8ffd0546 30b33946 edf738fc  .......F0.9F..8.
 1ca00 10b33946 fef730fb 154b0396 8de80801  ..9F..0..K......
 1ca10 144b0293 22461048 0e4b0421 00f004fc  .K.."F.H.K.!....
 1ca20 0d480e4b 04212246 00f0fefb 00e00025  .H.K.!"F.......%
 1ca30 00230093 01933046 21462a46 1d23fef7  .#....0F!F*F.#..
 1ca40 21fb07b0 bde8f083 0624f1e7 dafb0100  !........$......
 1ca50 21090200 bcfb0100 9c3b0020 ecfd0100  !........;. ....
 1ca60 60fe0100 2e090200 e0070200 73b5204d  `...........s. M
 1ca70 286801f0 19f80023 2b601e4b 1e891c46  (h.....#+`.K...F
 1ca80 16b9a47a 1cb310e0 700100f0 c3ff0346  ...z....p......F
 1ca90 286018b3 184a0092 18483146 2022edf7  (`...J...H1F "..
 1caa0 77fc0028 edd00b24 19e004eb 44008000  w..(...$....D...
 1cab0 00f0b0ff 124a0346 106078b1 114a0092  .....J.F.`x..J..
 1cac0 11482146 0c22edf7 63fc0028 ebd10f4b  .H!F."..c..(...K
 1cad0 002083e8 09000e4b 188006e0 06242868  . .....K.....$(h
 1cae0 00f0e2ff 00232b60 204602b0 70bd00bf  .....#+` F..p...
 1caf0 08240020 783b0020 080a0200 c0230020  .$. x;. .....#. 
 1cb00 fc230020 1f0a0200 e0230020 00240020  .#. .....#. .$. 
 1cb10 dc230020 38b55368 18681546 fbf7bcfc  .#. 8.Sh.h.F....
 1cb20 024610b9 2a485621 4ce0a0f5 2852042a  .F..*HV!L...(R.*
 1cb30 45d8dfe8 02f00310 1b273900 2c7814b1  E........'9.,x..
 1cb40 23485a21 3de0ab68 22489860 ecf782fa  #HZ!=..h"H.`....
 1cb50 ad68a881 26e02878 10b11d48 602130e0  .h..&.(x...H`!0.
 1cb60 ab681d4a 9a60ab68 022209e0 287810b1  .h.J.`.h."..(x..
 1cb70 17486621 25e0ab68 184a9a60 ab680122  .Hf!%..h.J.`.h."
 1cb80 9a8138bd 2b78012b 02d01148 6c2118e0  ..8.+x.+...Hl!..
 1cb90 aa689368 062b18d1 1268114b 11689288  .h.h.+...h.K.h..
 1cba0 19609a80 002038bd 287810b1 08487521  .`... 8.(x...Hu!
 1cbb0 07e0ab68 0b4a9a60 ab680822 e0e70448  ...h.J.`.h."...H
 1cbc0 7b210022 1346edf7 83f80d20 38bd00bf  {!.".F..... 8...
 1cbd0 5c0a0200 68020020 16240020 14240020  \...h.. .$. .$. 
 1cbe0 18240020 0c240020 00487047 68020020  .$. .$. .HpGh.. 
 1cbf0 38b50546 ecf72efa 1f280446 09dc064b  8..F.....(.F...K
 1cc00 29461846 2246ecf7 f9f90346 00201855  )F.F"F.....F. .U
 1cc10 38bd0320 38bd00bf 68020020 00210248  8.. 8...h.. .!.H
 1cc20 0a46f6f7 c1bf00bf 3c0a0200 01460148  .F......<....F.H
 1cc30 f7f705bc 3c0a0200 08b51378 1bb10b48  ....<......x...H
 1cc40 3a210022 06e05068 09498842 05d00748  :!."..Ph.I.B...H
 1cc50 3b211a46 1346edf7 3bf89168 49680b70  ;!.F.F..;..hIh.p
 1cc60 92680121 91811846 08bd00bf 6a0a0200  .h.!...F....j...
 1cc70 88030020 00210248 0a46f6f7 95bf00bf  ... .!.H.F......
 1cc80 7c0a0200 01460148 f7f7d9bb 7c0a0200  |....F.H....|...
 1cc90 2de9f041 00240646 90460d46 27464445  -..A.$.F.F.F'FDE
 1cca0 21dab379 ff2b08d0 aa799a42 18d12846  !..y.+...y.B..(F
 1ccb0 31460622 ecf794f9 90b9337e db070bd5  1F."......3~....
 1ccc0 2a893389 9a420bd1 d5e90401 d6e90423  *.3..B.........#
 1ccd0 994208bf 904203d1 737ebb42 07dd0137  .B...B..s~.B...7
 1cce0 01345035 dbe74ff0 ff30bde8 f0812046  .4P5..O..0.... F
 1ccf0 bde8f081 144b2de9 f0410024 d3f80080  .....K-..A.$....
 1cd00 124d0646 27464445 17dab379 ff2b08d0  .M.F'FDE...y.+..
 1cd10 aa799a42 0ed12846 31460622 ecf760f9  .y.B..(F1F."..`.
 1cd20 40b93389 13b12a89 9a4203d1 b37abb42  @.3...*..B...z.B
 1cd30 07dd0137 01341035 e5e74ff0 ff30bde8  ...7.4.5..O..0..
 1cd40 f0812046 bde8f081 a0270020 20240020  .. F.....'.  $. 
 1cd50 10b590f8 2830d907 86b00446 1bd50389  ....(0.....F....
 1cd60 0093d0e9 0423cde9 022390f8 4a302348  .....#...#..J0#H
 1cd70 c3f34003 00220493 0421214b 00f054fa  ..@.."...!!K..T.
 1cd80 04f11800 1021f8f7 adfb1c48 1d4b0421  .....!.....H.K.!
 1cd90 002200f0 49fa94f8 3930da07 10d50022  ."..I...90....."
 1cda0 194b1648 042100f0 3ffa04f1 29001021  .K.H.!..?...)..!
 1cdb0 f8f798fb 1148134b 04210022 00f034fa  .....H.K.!."..4.
 1cdc0 94f84a30 db0710d5 0022104b 0b480421  ..J0.....".K.H.!
 1cdd0 00f02afa 04f13a00 1021f8f7 83fb0748  ..*...:..!.....H
 1cde0 084b0421 002200f0 1ffa0448 084b0421  .K.!.".....H.K.!
 1cdf0 002206b0 bde81040 00f016ba 9c3b0020  .".....@.....;. 
 1ce00 9c0a0200 4c060200 90fe0100 c40a0200  ....L...........
 1ce10 ecfd0100 1fb58379 ff2b0446 10d00022  .......y.+.F..."
 1ce20 00931048 104b0421 00f0fef9 20460621  ...H.K.!.... F.!
 1ce30 f8f758fb 0b480d4b 04210022 00f0f4f9  ..X..H.K.!."....
 1ce40 237edb07 0bd52389 0093d4e9 04230548  #~....#......#.H
 1ce50 cde90223 04210022 054b00f0 e5f904b0  ...#.!.".K......
 1ce60 10bd00bf 9c3b0020 e7f30100 4c060200  .....;. ....L...
 1ce70 ca0a0200 022870b5 0d461446 17d00328  .....(p..F.F...(
 1ce80 37d00128 42d10421 0022214b 2148224e  7..(B..!."!K!H"N
 1ce90 00f0caf9 2846fff7 bdff1e48 1f4b0421  ....(F.....H.K.!
 1cea0 002200f0 c1f92846 31461d4b 12e00421  ."....(F1F.K...!
 1ceb0 00221c4b 17481c4e 00f0b6f9 2846fff7  .".K.H.N....(F..
 1cec0 a9ff1448 154b0421 002200f0 adf9174b  ...H.K.!.".....K
 1ced0 28463146 1a68fff7 dbfe421c 014601d1  (F1F.h....B..F..
 1cee0 052070bd 50222046 02fb0161 ecf786f8  . p.P" F...a....
 1cef0 0ae00846 fff7fefe 431cf1d0 0c4b03eb  ...F....C....K..
 1cf00 00100fc8 84e80f00 002070bd 082070bd  ......... p.. p.
 1cf10 f90a0200 9c3b0020 20250020 ecfd0100  .....;.  %. ....
 1cf20 a4270020 e30a0200 60260020 a8270020  .'. ....`&. .'. 
 1cf30 20240020 70b50228 8ab00c46 04d00328   $. p..(...F...(
 1cf40 52d00128 6dd123e0 0022374b 3748384e  R..(m.#.."7K7H8N
 1cf50 042100f0 69f92046 fff7fafe 02a82146  .!..i. F......!F
 1cf60 fbf74dfa 35683349 02a82a46 fff790fe  ..M.5h3I..*F....
 1cf70 411c0ad1 032d05dd 00952c48 2e4b0421  A....-....,H.K.!
 1cf80 002222e0 6b1c3360 28465022 294b25e0  ."".k.3`(FP")K%.
 1cf90 00222a4b 25482a4e 042100f0 45f92046  ."*K%H*N.!..E. F
 1cfa0 fff7d6fe 02a82146 fbf729fa 35682549  ......!F..).5h%I
 1cfb0 2a4602a8 fff76cfe 421c0dd1 032d08dd  *F....l.B....-..
 1cfc0 1a48214b 00950421 002200f0 2df90620  .H!K...!."..-.. 
 1cfd0 28e06b1c 33602846 1a4b5022 02fb0030  (.k.3`(F.KP"...0
 1cfe0 2146ecf7 0bf81ae0 02a8fbf7 fdf902a8  !F..............
 1cff0 fff780fe 431c0bd1 144b1868 032805dd  ....C....K.h.(..
 1d000 00900421 0948124b 0022dee7 421c1a60  ...!.H.K."..B..`
 1d010 104b03eb 001594e8 0f0085e8 0f000020  .K............. 
 1d020 00e00820 0ab070bd 0e0b0200 9c3b0020  ... ..p......;. 
 1d030 a8270020 60260020 240b0200 560b0200  .'. `&. $...V...
 1d040 a4270020 20250020 6b0b0200 a0270020  .'.  %. k....'. 
 1d050 9c0b0200 20240020 0170090a 41707047  .... $. .p..AppG
 1d060 0b0a0170 43700b0c 090e8370 c1707047  ...pCp.....p.ppG
 1d070 110a0270 4170110c 120ec270 1a0a0371  ...pAp.....p...q
 1d080 42711a0c 1b0e8170 8271c371 70474278  Bq.....p.q.qpGBx
 1d090 007840ea 02207047 82784378 0178c078  .x@.. pG.xCx.x.x
 1d0a0 120442ea 03230b43 43ea0060 70472de9  ..B..#.CC..`pG-.
 1d0b0 f0434478 90f80280 06782202 4fea0844  .CDx.....x".O..D
 1d0c0 00252243 00230027 2b433243 c67890f8  .%"C.#.'+C2C.x..
 1d0d0 05803b43 00253406 2b430579 c6794fea  ..;C.%4.+C.y.yO.
 1d0e0 08272243 90f80680 00242243 2b432243  .'"C.....$"C+C"C
 1d0f0 3b434fea 08472243 3b433106 20461043  ;CO..G"C;C1. F.C
 1d100 1943bde8 f08310b5 01390023 8b4206da  .C.......9.#.B..
 1d110 c25c445c c4544254 01330139 f6e710bd  .\D\.TBT.3.9....
 1d120 10b51044 0b465c1a 944204da 13f8014b  ...D.F\..B.....K
 1d130 00f8014d f7e710bd 034b1a78 0ab90122  ...M.....K.x..."
 1d140 1a700020 704700bf ac270020 044b81e8  .p. pG...'. .K..
 1d150 05005a68 00208860 11600831 59607047  ..Zh. .`.`.1Y`pG
 1d160 b8030020 00000000 2de9f04f 1c460368  ... ....-..O.F.h
 1d170 85b00546 88469146 002b47d0 4368002b  ...F.F.F.+G.Ch.+
 1d180 44d0274e 337a6846 01330021 3372edf7  D.'N3zhF.3.!3r..
 1d190 69fbb246 38b9dde9 00231fa1 d1e90001  i..F8....#......
 1d1a0 90429941 02dbedf7 7dfb08e0 1d4ea2fb  .B.A....}....N..
 1d1b0 060106fb 0311029b c01841eb e3712060  ..........A..q `
 1d1c0 61602268 6368dff8 58b0dae9 00678ae8  a`"hch..X....g..
 1d1d0 0c00a4f8 08809af8 083084f8 0b90a372  .........0.....r
 1d1e0 6b68bdf8 38209b68 28462146 0c329847  kh..8 .h(F!F.2.G
 1d1f0 70b9dbe9 002316f5 7a7647f1 00079642  p....#..zvG....B
 1d200 77eb0303 04da8bf8 080001e0 4ff0ff30  w...........O..0
 1d210 05b0bde8 f08f00bf 7fc18556 00000000  ...........V....
 1d220 802c0020 40420f00 08b470b5 a7b02bab  .,. @B....p...+.
 1d230 06460d46 144606a8 53f8042b 02938021  .F.F.F..S..+...!
 1d240 ecf7f4f8 7f28a8bf 7f2080b2 00902946  .....(... ....)F
 1d250 30462246 03abfff7 87ff27b0 bde87040  0F"F......'...p@
 1d260 01b07047 02207047 02207047 02207047  ..pG. pG. pG. pG
 1d270 38b50c46 1546ecf7 9dfa70b1 084b1b68  8..F.F....p..K.h
 1d280 2bb90848 21682289 e37a00f0 47fc04f1  +..H!h"..z..G...
 1d290 0c00a5f1 0c01ecf7 87fa0020 38bd00bf  ........... 8...
 1d2a0 142d0020 fa0b0200 0346064a 5a60064a  .-. .....F.JZ`.J
 1d2b0 9a60064a da600020 054a1860 1a619861  .`.J.`. .J.`.a.a
 1d2c0 58617047 65d20100 71d20100 69d20100  XapGe...q...i...
 1d2d0 6dd20100 f8b50d4e 34680746 0d4634b1  m......N4h.F.F4.
 1d2e0 20683946 00f00ffc 68b1a468 f7e77368   h9F....h..h..sh
 1d2f0 074a2f60 ac601d60 d3680835 01337560  .J/`.`.`.h.5.3u`
 1d300 d3602046 f8bd4ff0 ff30f8bd c0030020  .` F..O..0..... 
 1d310 f83d0020 38b50a4b 197879b9 094c0125  .=. 8..K.xy..L.%
 1d320 20461022 1d70ebf7 74fe0423 23716571   F.".p..t..##qeq
 1d330 21460548 bde83840 fff7ccbf 002038bd  !F.H..8@..... 8.
 1d340 ad270020 f83d0020 180c0200 f8b5079f  .'. .=. ........
 1d350 04461546 11fb02f2 0e460c32 0021ebf7  .F.F.....F.2.!..
 1d360 58fe2671 65713846 2146bde8 f840fff7  X.&qeq8F!F...@..
 1d370 b1bf4ff0 ff307047 08b500f0 3ff90000  ..O..0pG....?...
 1d380 08b50020 00f00cf8 0020fff7 f2ff0348  ... ..... .....H
 1d390 0521bde8 084000f0 25b800bf c8030020  .!...@..%...... 
 1d3a0 0d4a08b5 031e1068 07da0c49 03448b42  .J.....h...I.D.B
 1d3b0 08d201f0 05fc1623 09e00949 091a9942  .......#...I...B
 1d3c0 02db0344 136008bd 01f0fafb 0c230360  ...D.`.......#.`
 1d3d0 4ff0ff30 08bd00bf 04040020 143e0020  O..0....... .>. 
 1d3e0 50fe0020 024b1860 024b1960 704700bf  P.. .K.`.K.`pG..
 1d3f0 b0270020 b4270020 002208b5 02485521  .'. .'. ."...HU!
 1d400 1346ecf7 65fc00bf 1d0c0200 b0f1807f  .F..e...........
 1d410 08b502d3 0a484321 04e0b1f1 807f05d3  .....HC!........
 1d420 07484421 00221346 ecf752fc 401a0302  .HD!.".F..R.@...
 1d430 46bf6fea 40206fea 5020c0f3 160008bd  F.o.@ o.P ......
 1d440 1d0c0200 38b50446 ecf773fa 024670b9  ....8..F..s..Fp.
 1d450 0d486721 1346ecf7 3bfcd5f8 04152046  .Hg!.F..;..... F
 1d460 fff7d4ff 02280ddc 084b1b68 1c44084d  .....(...K.h.D.M
 1d470 24f07f44 c5f84c45 ecf75bfa 0028ecd1  $..D..LE..[..(..
 1d480 fff7baff 38bd00bf 1d0c0200 083e0020  ....8........>. 
 1d490 00100140 f8b5ecf7 43fa0746 ecf749fa  ...@....C..F..I.
 1d4a0 08b9fff7 a9ff0f4d 0f4ea968 d6f80405  .......M.N.h....
 1d4b0 fff7acff 2c6890fb f4f42046 edf786f9  ....,h.... F....
 1d4c0 0023c6f8 4c312868 ab6800fb 043424f0  .#..L1(h.h...4$.
 1d4d0 7f442044 ac60fff7 b5ff3846 bde8f840  .D D.`....8F...@
 1d4e0 ecf724ba 083e0020 00100140 10b50446  ..$..>. ...@...F
 1d4f0 ecf71ffa 024620b9 0c48b621 1346ecf7  .....F ..H.!.F..
 1d500 e7fb54b1 0a4b5a68 18689b68 944228bf  ..T..KZh.h.h.B(.
 1d510 144600fb 0430fff7 95ffbff3 4f8f30bf  .F...0......O.0.
 1d520 1cb1bde8 1040fff7 b5bf10bd 1d0c0200  .....@..........
 1d530 083e0020 4ff40043 b3fbf0f3 5843d0f5  .>. O..C....XC..
 1d540 004070b5 0d4605d0 00222848 d6211346  .@p..F..."(H.!.F
 1d550 ecf7befb 264a4ff4 80011360 b1fbf3f3  ....&JO....`....
 1d560 53604ff0 80430121 90601446 d960c3f8  S`O..C.!.`.F.`..
 1d570 0401c3f8 18159960 4ff08043 d3f80421  .......`O..C...!
 1d580 002af9d0 d3f81834 03f00113 b3f1011f  .*.....4........
 1d590 f2d1ecf7 c5f96901 164dc9b2 064685f8  ......i..M...F..
 1d5a0 11131120 1449ebf7 bbff4ff4 00332b60  ... .I....O..3+`
 1d5b0 03f18043 a3f57043 01224ff0 ff315a60  ...C..pC."O..1Z`
 1d5c0 9a60c3f8 4813c3f8 08134ff4 0021c3f8  .`..H.....O..!..
 1d5d0 04130021 c3f84c11 2168c3f8 4c153046  ...!..L.!h..L.0F
 1d5e0 1a60bde8 7040ecf7 a1b900bf 1d0c0200  .`..p@..........
 1d5f0 083e0020 00e100e0 95d40100 084b1b68  .>. .........K.h
 1d600 db0700d5 00bebff3 4f8f0649 064bca68  ........O..I.K.h
 1d610 02f4e062 1343cb60 bff34f8f fee700bf  ...b.C.`..O.....
 1d620 f0ed00e0 00ed00e0 0400fa05 024b1868  .............K.h
 1d630 00f00100 704700bf f0ed00e0 38b50024  ....pG......8..$
 1d640 064d2b69 a8699847 002804db 25440134  .M+i.i.G.(..%D.4
 1d650 082ca870 f4d12046 38bd00bf b8270020  .,.p.. F8....'. 
 1d660 38b51c4c d4f82031 f3b10023 c4f82031  8..L.. 1...#.. 1
 1d670 fff7e4ff 002807dd 174bc4f8 44350123  .....(...K..D5.#
 1d680 c4f84805 a3600fe0 144c6369 0bb1a069  ..H..`...Lci...i
 1d690 9847104b 4ff48072 c3f80823 0122da60  .G.KO..r...#.".`
 1d6a0 23786ff3 82032370 0a4dd5f8 103183b1  #xo...#p.M...1..
 1d6b0 0a4c0023 c5f81031 a069e368 61789847  .L.#...1.i.hax.G
 1d6c0 002804da 237843f0 02032370 38bd0123  .(..#xC...#p8..#
 1d6d0 2b6038bd 00200040 ba270020 b8270020  +`8.. .@.'. .'. 
 1d6e0 10b550b9 064c2078 10f00100 05d1e360  ..P..L x.......`
 1d6f0 029b2161 6261a361 10bd4ff0 ff3010bd  ..!aba.a..O..0..
 1d700 b8270020 38b5eff3 108572b6 0d4c2378  .'. 8.....r..L#x
 1d710 5b0713d4 fff792ff 00280fdd 0a4b4ff4  [........(...KO.
 1d720 8072c3f8 0423a21c c3f84425 0122c3f8  .r...#....D%."..
 1d730 48059a60 237843f0 04032370 05b962b6  H..`#xC...#p..b.
 1d740 38bd00bf b8270020 00200040 114b1b78  8....'. . .@.K.x
 1d750 82b0da07 8df80710 19d513f0 040f0e4b  ...............K
 1d760 03d0d3f8 2021002a fbd00022 c3f82021  .... !.*...".. !
 1d770 0df10702 c3f84425 0122c3f8 48259a60  ......D%."..H%.`
 1d780 054bd3f8 2021002a fad00122 da6002b0  .K.. !.*...".`..
 1d790 704700bf b8270020 00200040 2de9f843  pG...'. . .@-..C
 1d7a0 0c469146 98469df8 20709df8 24600028  .F.F.F.. p..$`.(
 1d7b0 41d1614d 2b78db07 3dd400f0 2fff0246  A.aM+x..=.../..F
 1d7c0 10b95e48 ee211be0 b9f1080f 33d1b8f1  ..^H.!......3...
 1d7d0 010f30d1 012f2ed0 022f0cbf 0e200020  ..0../.../... . 
 1d7e0 012e10d1 92f90230 002b40f0 010003db  .......0.+@.....
 1d7f0 92f90330 002b12da 504840f2 11110022  ...0.+..PH@...."
 1d800 1346ecf7 65fab4f5 e13f11d0 7adcb4f5  .F..e....?..z...
 1d810 964f0bd0 6adcb4f5 165f10d0 0be0b4f5  .O..j...._......
 1d820 e13f05d0 6edcb4f5 964f49d1 444b07e0  .?..n....OI.DK..
 1d830 4ff0eb73 04e04ff0 ff30bde8 f883414b  O..s..O..0....AK
 1d840 41490024 c1f80045 4ff0ff34 c1f80843  AI.$...EO..4...C
 1d850 92f90070 c1f80c75 92f90170 c1f81475  ...p...u...p...u
 1d860 012e09d1 384992f9 0240c1f8 084592f9  ....8I...@...E..
 1d870 0320c1f8 102503e0 c1f80845 c1f81045  . ...%.....E...E
 1d880 314c3249 c4f82435 c4f86c05 0220ebf7  1L2I..$5..l.. ..
 1d890 47fe2f4b 04221a60 0823c4f8 00351023  G./K.".`.#...5.#
 1d8a0 c4f80433 2b4bc4f8 34350123 c4f83835  ...3+K..45.#..85
 1d8b0 23602b78 43f00103 2b700020 bde8f883  #`+xC...+p. ....
 1d8c0 14dcb4f5 165fb6d1 1f4b0021 c3f80015  ....._...K.!....
 1d8d0 4ff0ff31 c3f80813 92f90010 c3f80c15  O..1............
 1d8e0 92f90110 c3f81415 164bbbe7 b4f5164f  .........K.....O
 1d8f0 02d14ff4 1d03a3e7 b4f5614f 9bd14ff4  ..O.......aO..O.
 1d900 6b039de7 b4f5e12f 02d14ff0 e86397e7  k....../..O..c..
 1d910 05dcb4f5 613f8ed1 4ff06c73 90e7b4f5  ....a?..O.ls....
 1d920 612f02d1 4ff07063 8ae70b4b 9c4282d1  a/..O.pc...K.B..
 1d930 4ff08053 84e700bf b8270020 2b0c0200  O..S.....'. +...
 1d940 00a04e00 00502700 00200040 61d60100  ..N..P'.. .@a...
 1d950 00e100e0 b9270020 40420f00 01207047  .....'. @B... pG
 1d960 70470000 c3688268 19680129 10b509d1  pG...h.h.h.)....
 1d970 59685c18 844205d1 60689a60 01445960  Yh\..B..`h.`.DY`
 1d980 d36009e0 01230360 0d4b4361 19690161  .`...#.`.KCa.i.a
 1d990 18610369 58610346 11680129 0ed15968  .a.iXa.F.h.)..Yh
 1d9a0 58189042 0ad15068 01445960 50691169  X..B..Ph.DY`Pi.i
 1d9b0 01614861 d1689268 8a60d160 184610bd  .aHa.h.h.`.`.F..
 1d9c0 08040020 172910b5 04461bd9 01230360  ... .)...F...#.`
 1d9d0 0d4b4160 1b689847 a0b10c4b db681a68  .KA`.h.G...K.h.h
 1d9e0 022a01d0 a342f9d2 9a68a260 e3609c60  .*...B...h.`.`.`
 1d9f0 a3682046 dc60fff7 b5ff054b bde81040  .h F.`.....K...@
 1da00 1b681847 10bd00bf 24040020 08040020  .h.G....$.. ... 
 1da10 20040020 f8b508b9 0020f8bd 1f4b1f30   .. ..... ...K.0
 1da20 1b6820f0 0f049847 0028f5d0 1c4b1869  .h ....G.(...K.i
 1da30 0368022b 29d04268 a2421ed3 04f12003  .h.+).Bh.B.... .
 1da40 9a420169 456911d3 03198668 121b0127  .B.iEi.....h...'
 1da50 07515a60 002280e8 1400d860 9e60f360  .QZ`.".....`.`.`
 1da60 83601961 5d614b61 2b6103e0 00230360  .`.a]aKa+a...#.`
 1da70 29614d61 00f11004 02e00069 d8e70024  )aMa.......i...$
 1da80 084b1b68 98472046 f8bd2046 fff788fc  .K.h.G F.. F....
 1da90 431cf4d0 2146fff7 95ffc7e7 24040020  C...!F......$.. 
 1daa0 08040020 20040020 10b50446 60b1074b  ...  .. ...F`..K
 1dab0 1b689847 40b1a4f1 1000fff7 53ff044b  .h.G@.......S..K
 1dac0 bde81040 1b681847 10bd00bf 24040020  ...@.h.G....$.. 
 1dad0 20040020 884230b5 01eb0204 08d2431e   .. .B0.......C.
 1dae0 a14204d0 11f8012b 03f8012f f8e730bd  .B.....+.../..0.
 1daf0 81182346 151beb42 04d013f8 015d01f8  ..#F...B.....]..
 1db00 015df7e7 30bd10f8 012b11f8 013bd31a  .]..0....+...;..
 1db10 01d1002a f7d11846 70470000 0fb40b4b  ...*...FpG.....K
 1db20 1b6807b5 33b9ecf7 4bfe0949 02460948  .h..3...K..I.F.H
 1db30 ebf76ffc 05aa0499 06480192 ebf767fc  ..o......H....g.
 1db40 03b05df8 04eb04b0 704700bf 142d0020  ..].....pG...-. 
 1db50 3c0c0200 380c0200 00214ff4 8c72ebf7  <...8....!O..r..
 1db60 58ba0000 c02af0b5 07d0b2f5 807f06d0  X....*..........
 1db70 802a40f0 db800a23 02e00c23 00e00e23  .*@....#...#...#
 1db80 036000f1 08034360 52090024 944210d0  .`....C`R..$.B..
 1db90 01eb8407 bd787e78 2d0445ea 062511f8  .....x~x-.E..%..
 1dba0 24603543 fe7845ea 066543f8 24500134  $`5C.xE..eC.$P.4
 1dbb0 ece70268 0c2a31d0 0e2a66d0 0a2a40f0  ...h.*1..*f..*@.
 1dbc0 b8800025 5c4adc68 52f82510 1a685b4e  ...%\J.hR.%..h[N
 1dbd0 5140c4f3 07220135 b05c220e 4140b25c  Q@...".5.\".A@.\
 1dbe0 81ea0241 e2b20a2d b25c81ea 0261c4f3  ...A...-.\...a..
 1dbf0 074203f1 1003b25c 81ea0222 53f80c1c  .B.....\..."S...
 1dc00 1a6082ea 010253f8 081c5a60 82ea0102  .`....S...Z`....
 1dc10 84ea0204 9a60dc60 d4d18ae0 0024464a  .....`.`.....$FJ
 1dc20 586952f8 24101a68 444d4a40 c0f30721  XiR.$..hDMJ@...!
 1dc30 0134695c 4a40010e 082c695c 82ea0142  .4i\J@...,i\...B
 1dc40 c1b203f1 1803695c 82ea0162 c0f30741  ......i\...b...A
 1dc50 695c82ea 012253f8 141c1a60 82ea0102  i\..."S....`....
 1dc60 53f8101c 5a6082ea 010253f8 0c1c9a60  S...Z`....S....`
 1dc70 82ea0102 53f8081c da6082ea 010280ea  ....S....`......
 1dc80 02001a61 5861cad1 53e00025 2a4adc69  ...aXa..S..%*J.i
 1dc90 52f82510 1a68294e 5140c4f3 07220135  R.%..h)NQ@...".5
 1dca0 b05c220e 4140b25c 586881ea 0241e2b2  .\".A@.\Xh...A..
 1dcb0 072db25c 81ea0261 c4f30742 03f12003  .-.\...a...B.. .
 1dcc0 b25c81ea 022153f8 182c1960 81ea0001  .\...!S..,.`....
 1dcd0 53f8140c 596081ea 020180ea 0100c2b2  S...Y`..........
 1dce0 9960b25c 53f8101c d86081ea 02014fea  .`.\S....`....O.
 1dcf0 1062b25c 81ea0261 c0f30722 c0f30740  .b.\...a..."...@
 1dd00 b25c81ea 0221325c 81ea0242 53f80c1c  .\...!2\...BS...
 1dd10 1a6182ea 010253f8 081c5a61 82ea0102  .a....S...Za....
 1dd20 84ea0204 9a61dc61 b0d102e0 6ff01f00  .....a.a....o...
 1dd30 f0bd0020 f0bd00bf 4c1d0200 4c0c0200  ... ....L...L...
 1dd40 2de9f74f 8d784b78 0c784768 4e7a91f8  -..O.xKx.xGhNz..
 1dd50 0de02d04 45ea0325 cb782543 45ea0363  ..-.E..%.x%CE..c
 1dd60 3d684c79 5d408b79 1b0443ea 04230c79  =hLy]@.y..C..#.y
 1dd70 2343cc79 43ea0463 7c686340 8c7a2404  #C.yC..c|hc@.z$.
 1dd80 44ea0624 0e7a3443 ce7a44ea 0664be68  D..$.z4C.zD..d.h
 1dd90 74408e7b 360446ea 0e2691f8 0ce0c97b  t@.{6.F..&.....{
 1dda0 46ea0e06 46ea0161 fe684e40 01684910  F...F..a.hN@.hI.
 1ddb0 01390191 07f11001 0198dff8 40e30028  .9..........@..(
 1ddc0 8846cc48 01f12001 4fea1667 5ffa85fc  .F.H.. .O..g_...
 1ddd0 40f3be80 50f82790 5ef82c70 dff82083  @...P.'.^.,p.. .
 1dde0 dff820c3 89ea0709 51f8207c 89ea0709  .. .....Q. |....
 1ddf0 c3f30727 4fea156a 58f82770 50f82aa0  ...'O..jX.'pP.*.
 1de00 89ea0707 c4f30749 4fea136b 5cf82990  .......IO..k\.).
 1de10 50f82bb0 87ea0909 dfb2c3f3 07435ef8  P.+..........C^.
 1de20 27708aea 070a51f8 1c7c8aea 0707c4f3  'p....Q..|......
 1de30 072a58f8 2aa087ea 0a07c6f3 074a5cf8  .*X.*........J\.
 1de40 2aa087ea 0a0ae7b2 240e5ef8 277050f8  *.......$.^.'pP.
 1de50 24408bea 070b51f8 187c8bea 0707c6f3  $@....Q..|......
 1de60 072b58f8 2bb087ea 0b07c5f3 074bc5f3  .+X.+........K..
 1de70 07255cf8 2bb087ea 0b075ffa 86fb5ef8  .%\.+....._...^.
 1de80 2b606640 51f8144c 744058f8 25607440  +`f@Q..Lt@X.%`t@
 1de90 5cf82360 6640330e 5ffa89f4 50f82330  \.#`f@3._...P.#0
 1dea0 5ef82450 caf30724 5d4051f8 103c58f8  ^.$P...$]@Q..<X.
 1deb0 24406b40 6340c7f3 07445ffa 87fb5cf8  $@k@c@...D_...\.
 1dec0 24505ef8 2bb05ffa 8af45d40 4fea1963  $P^.+._...]@O..c
 1ded0 5ef82440 50f82330 5c4051f8 0c3c6340  ^.$@P.#0\@Q..<c@
 1dee0 c7f30724 3f0e58f8 24406340 c6f30744  ...$?.X.$@c@...D
 1def0 5cf82440 63404fea 1a64caf3 074a50f8  \.$@c@O..d...JP.
 1df00 24408bea 040b51f8 084c8bea 0404c6f3  $@....Q..L......
 1df10 072bf6b2 58f82bb0 50f82700 5ef82660  .+..X.+.P.'.^.&`
 1df20 84ea0b04 c9f3074b c9f30729 464051f8  .......K...)F@Q.
 1df30 040c58f8 29705cf8 2bb07040 5cf82a60  ..X.)p\.+.p@\.*`
 1df40 78404640 01980138 84ea0b04 019033e7  x@F@...8......3.
 1df50 50f82710 5ef82cc0 dff8a4a1 dff8a491  P.'.^.,.........
 1df60 c3f30727 8cea010c d8f80010 5af82770  ...'........Z.'p
 1df70 8cea0101 7940c4f3 07475ffa 84fb59f8  ....y@...G_...Y.
 1df80 27705ef8 2bb081ea 070cdfb2 290e5ef8  'p^.+.......).^.
 1df90 277050f8 21104f40 d8f80410 7940c4f3  'pP.!.O@....y@..
 1dfa0 0727240e 5af82770 7940c6f3 074759f8  .'$.Z.'py@...GY.
 1dfb0 27707940 1f0ec3f3 074350f8 277050f8  'py@.....CP.'pP.
 1dfc0 240059f8 23308bea 070bd8f8 08708bea  $.Y.#0.......p..
 1dfd0 0707c6f3 072bf6b2 5af82bb0 5ef82660  .....+..Z.+.^.&`
 1dfe0 87ea0b07 86ea0004 c5f3074b d8f80c00  ...........K....
 1dff0 59f82bb0 c5f30725 60405af8 25406040  Y.+....%`@Z.%@`@
 1e000 58405ffa 8cf43c4b 050e1e5d d8f81040  X@_...<K...]...@
 1e010 74405e5d c1f30725 87ea0b07 84ea0664  t@^]...%.......d
 1e020 5e5dc7f3 074584ea 06245e5d 84ea0646  ^]...E...$^]...F
 1e030 ccb21d5d d8f81440 6c404fea 1c655d5d  ...]...@l@O..e]]
 1e040 84ea0564 c7f30725 5d5d84ea 0524c0f3  ...d...%]]...$..
 1e050 07455d5d 84ea0545 fcb23f0e 13f804e0  .E]]...E..?.....
 1e060 d8f81840 8eea0404 4fea116e c1f30741  ...@....O..n...A
 1e070 13f80ee0 84ea0e64 c0f3072e c0b213f8  .......d........
 1e080 0ee0df5d 84ea0e24 ccf3074e ccf3072c  ...]...$...N...,
 1e090 13f80ee0 84ea0e44 13f800e0 d8f81c00  .......D........
 1e0a0 16708eea 000080ea 076013f8 0c705b5c  .p.......`...p[\
 1e0b0 1571310a 5170310c 9170290a 5171290c  .q1.Qp1..p).Qq).
 1e0c0 80ea0720 9171210a 80ea0343 5172210c  ... .q!....CQr!.
 1e0d0 9172190a 360e2d0e 14721373 240e5173  .r..6.-..r.s$.Qs
 1e0e0 190c1b0e d670d571 d4729173 d37303b0  .....p.q.r.s.s..
 1e0f0 bde8f08f 74290200 4c0c0200 741d0200  ....t)..L...t...
 1e100 74210200 74250200 2de9f74f 8d784b78  t!..t%..-..O.xKx
 1e110 0c784668 0f7991f8 0e802d04 45ea0325  .xFh.y....-.E..%
 1e120 cb782543 45ea0363 35688c79 5d404b79  .x%CE..c5h.y]@Ky
 1e130 240444ea 0324cb79 3c4344ea 03637468  $.D..$.y<CD..cth
 1e140 4f7a5c40 8b7a1b04 43ea0723 0f7a3b43  Oz\@.z..C..#.z;C
 1e150 cf7a43ea 0763b768 7b404f7b 4fea0848  .zC..c.h{@O{O..H
 1e160 48ea0728 0f7bc97b 48ea0708 48ea0168  H..(.{.{H...H..h
 1e170 f16888ea 01080168 49100139 019106f1  .h.....hI..9....
 1e180 10010198 d24e0028 8c46d248 01f12001  .....N.(.F.H.. .
 1e190 4fea1467 5ffa85fe 40f3c680 50f82790  O..g_...@...P.'.
 1e1a0 56f82e70 dff834c3 dff834e3 89ea0709  V..p..4...4.....
 1e1b0 51f8207c 89ea0709 c8f30727 4fea136a  Q. |.......'O..j
 1e1c0 5cf82770 50f82aa0 89ea0707 c3f30749  \.'pP.*........I
 1e1d0 4fea186b 5ef82990 50f82bb0 87ea0909  O..k^.).P.+.....
 1e1e0 e7b256f8 27708aea 070a51f8 1c7c8aea  ..V.'p....Q..|..
 1e1f0 0707c5f3 072a5cf8 2aa087ea 0a07c8f3  .....*\.*.......
 1e200 074a5ef8 2aa087ea 0a0adfb2 c3f30723  .J^.*..........#
 1e210 56f82770 5cf82330 8bea070b 51f8187c  V.'p\.#0....Q..|
 1e220 8bea0707 c4f3072b c4f30744 5cf82bb0  .......+...D\.+.
 1e230 87ea0b07 c5f3074b 2d0e5ef8 2bb050f8  .......K-.^.+.P.
 1e240 255087ea 0b075ffa 88fb56f8 2b8085ea  %P...._...V.+...
 1e250 080851f8 145c88ea 05055d40 5ef82430  ..Q..\....]@^.$0
 1e260 5ffa89f4 85ea0308 4fea1a63 56f82450  _.......O..cV.$P
 1e270 50f82330 c8f30724 5d4051f8 103c5cf8  P.#0...$]@Q..<\.
 1e280 24406b40 6340c7f3 07445ffa 87fb5ef8  $@k@c@...D_...^.
 1e290 245056f8 2bb05ffa 8af45d40 3b0e56f8  $PV.+._...]@;.V.
 1e2a0 244050f8 23305c40 51f80c3c 6340c9f3  $@P.#0\@Q..<c@..
 1e2b0 0724c7f3 07275cf8 24406340 c8f30744  .$...'\.$@c@...D
 1e2c0 5ef82440 5c404fea 18635ffa 88f850f8  ^.$@\@O..c_...P.
 1e2d0 23308bea 030b51f8 083c8bea 0303caf3  #0....Q..<......
 1e2e0 072bcaf3 074a5cf8 2bb056f8 286083ea  .+...J\.+.V.(`..
 1e2f0 0b03c9f3 074b4fea 19695ef8 2bb050f8  .....KO..i^.+.P.
 1e300 290086ea 000851f8 040c5cf8 276088ea  ).....Q...\.'`..
 1e310 00007040 5ef82a60 80ea0608 01980138  ..p@^.*`.......8
 1e320 83ea0b03 01902ce7 50f82710 56f82ee0  ......,.P.'.V...
 1e330 dff8a8a1 dff8a891 c8f30727 8eea010e  ...........'....
 1e340 dcf80010 5af82770 8eea0101 7940c3f3  ....Z.'p....y@..
 1e350 07475ffa 83fb59f8 277056f8 2bb081ea  .G_...Y.'pV.+...
 1e360 070ee7b2 190e56f8 277050f8 21104f40  ......V.'pP.!.O@
 1e370 dcf80410 7940c5f3 0727c3f3 07235af8  ....y@...'...#Z.
 1e380 27705af8 23307940 c8f30747 59f82770  'pZ.#0y@...GY.'p
 1e390 79404fea 18675ffa 88f850f8 277056f8  y@O..g_...P.'pV.
 1e3a0 28608bea 070bdcf8 08708bea 0707c4f3  (`.......p......
 1e3b0 072bc4f3 07445af8 2bb087ea 0b07c5f3  .+...DZ.+.......
 1e3c0 074b2d0e 59f82bb0 50f82500 86ea0005  .K-.Y.+.P.%.....
 1e3d0 dcf80c00 68405840 59f82430 5ffa8ef4  ....h@X@Y.$0_...
 1e3e0 58403d4b 0d0e1e5d dcf81040 74405e5d  X@=K...]...@t@^]
 1e3f0 c0f30725 87ea0b07 84ea0664 5e5dc7f3  ...%.......d^]..
 1e400 074584ea 06245e5d 84ea0646 ccb21d5d  .E...$^]...F...]
 1e410 dcf81440 6c403d0e 5d5d84ea 0564cef3  ...@l@=.]]...d..
 1e420 07255d5d 84ea0524 c0f30745 5d5d84ea  .%]]...$...E]]..
 1e430 0545fcb2 c7f30727 13f80480 dcf81840  .E.....'.......@
 1e440 88ea0404 4fea1068 c0b213f8 088084ea  ....O..h........
 1e450 0864c1f3 0728c1f3 074113f8 0880df5d  .d...(...A.....]
 1e460 84ea0824 cef30748 4fea1e6e 13f80880  ...$...HO..n....
 1e470 13f80ee0 84ea0844 13f80080 dcf81c00  .......D........
 1e480 5b5c1670 310a5170 310c88ea 00009170  [\.p1.Qp1......p
 1e490 290a80ea 0e605171 290c80ea 07209171  )....`Qq).... .q
 1e4a0 210a80ea 03435172 210c9172 190a360e  !....CQr!..r..6.
 1e4b0 15711472 2d0e240e 13735173 190c1b0e  .q.r-.$..sQs....
 1e4c0 d670d571 d4729173 d37303b0 bde8f08f  .p.q.r.s.s......
 1e4d0 4c0d0200 4c190200 742d0200 4c110200  L...L...t-..L...
 1e4e0 4c150200 012908b5 11461a46 02d1fff7  L....)...F.F....
 1e4f0 27fc01e0 fff708fe 002008bd 20b10023  '........ .. ..#
 1e500 c1800360 18467047 03207047 f8b5164b  ...`.FpG. pG...K
 1e510 1b680446 1bb320b3 ebf7eaff 0746ebf7  .h.F.. ......F..
 1e520 fff92568 06466db1 eb7b23f0 0203eb73  ..%h.Fm..{#....s
 1e530 2846ecf7 3bf87b7b 687b8342 94bf0024  (F..;.{{h{.B...$
 1e540 012403e0 e3880133 e3802c46 3046ebf7  .$.....3..,F0F..
 1e550 edf914b1 2846ebf7 d7ff0020 f8bd0920  ....(F..... ... 
 1e560 f8bd0320 f8bd00bf 282f0020 f8b52a4b  ... ....(/. ..*K
 1e570 1b680546 0e46002b 47d00028 47d0ebf7  .h.F.F.+G..(G...
 1e580 b7ff0446 ebf7ccf9 ea880746 1ab1013a  ...F.......F...:
 1e590 ea800026 1fe006b3 e37be561 43f00203  ...&.....{.aC...
 1e5a0 e3732968 81b194f8 0de00b46 587b7045  .s)h.......FX{pE
 1e5b0 04d8d86c 1a4618b1 0346f7e7 13461ab1  ...l.F...F...F..
 1e5c0 da6ce264 dc6401e0 e1642c60 31462046  .l.d.d...d,`1F F
 1e5d0 ebf7b2ff 01260025 00e00625 3846ebf7  .....&.%...%8F..
 1e5e0 a5f9b6b1 0020ebf7 8fffe37b 03f00203  ..... .....{....
 1e5f0 03f0ff00 73b1ebf7 93f9e37b 23f00203  ....s......{#...
 1e600 e373ebf7 93f90620 f8bd0920 f8bd0320  .s..... ... ... 
 1e610 f8bd2846 f8bd00bf 282f0020 00487047  ..(F....(/. .HpG
 1e620 742e0200 53b94ab9 002908bf 00281cbf  t...S.J..)...(..
 1e630 4ff0ff31 4ff0ff30 00f03cb8 82b0ec46  O..1O..0..<....F
 1e640 2de90050 00f01ef8 ddf804e0 02b00cbc  -..P............
 1e650 704700bf 2de9f041 069c1546 06460f46  pG..-..A...F.F.F
 1e660 984600f0 29f805fb 01f300fb 0838a5fb  .F..)........8..
 1e670 0023b21a 434467eb 0303c4e9 0023bde8  .#..CDg......#..
 1e680 f08100bf 2de9f041 069c9046 06460f46  ....-..A...F.F.F
 1e690 1d4600f0 5ff900fb 05f5a0fb 082308fb  .F.._........#..
 1e6a0 0155b21a 2b4467eb 0303c4e9 0023bde8  .U..+Dg......#..
 1e6b0 f08100bf 704700bf 00292de9 f043c0f2  ....pG...)-..C..
 1e6c0 a6800026 002bc0f2 9c808846 94469e46  ...&.+.....F.F.F
 1e6d0 15460446 0f46002b 3dd18a42 59d9b2fa  .F.F.F.+=..BY...
 1e6e0 82f33bb1 c3f12002 9f4020fa 02f29d40  ..;... ..@ ....@
 1e6f0 17439c40 290c220c b7fbf1fe a8b201fb  .C.@).".........
 1e700 1e7742ea 074700fb 0ef3bb42 0ad97f19  .wB..G.....B....
 1e710 0ef1ff32 80f00581 bb4240f2 0281aef1  ...2.....B@.....
 1e720 020e2f44 ff1aa4b2 b7fbf1f3 01fb1377  ../D...........w
 1e730 44ea0747 00fb03f0 b84208d9 7f1903f1  D..G.....B......
 1e740 ff3280f0 f080b842 40f2ed80 023b43ea  .2.....B@....;C.
 1e750 0e430022 03e08b42 0fd90022 1346341c  .C."...B...".F4.
 1e760 18bf0124 60424ff0 000565eb 45015840  ...$`BO...e.E.X@
 1e770 51400019 6941bde8 f083b3fa 83f2002a  Q@..iA.........*
 1e780 40f08680 8b4202d3 844500f2 db800123  @....B...E.....#
 1e790 e5e712b9 0123b3fb f2f5b5fa 85f00028  .....#.........(
 1e7a0 3bd1781b 4fea154e 1ffa85fc 0122b0fb  ;.x.O..N....."..
 1e7b0 fef8210c 0efb1807 41ea0747 0cfb08f3  ..!.....A..G....
 1e7c0 bb4207d9 7f1908f1 ff3102d2 bb4200f2  .B.......1...B..
 1e7d0 bd808846 ff1aa4b2 b7fbfef3 0efb1377  ...F...........w
 1e7e0 44ea0747 0cfb03fc bc4507d9 7f1903f1  D..G.....E......
 1e7f0 ff3102d2 bc4500f2 a7800b46 43ea0843  .1...E.....FC..C
 1e800 ade75242 6fea0606 63eb4303 5de74042  ..RBo...c.C.].@B
 1e810 61eb4101 4ff0ff36 54e7c0f1 200224fa  a.A.O..6T... .$.
 1e820 02f107fa 00f38540 4fea154e d7401943  .......@O..N.@.C
 1e830 b7fbfef2 0b0c0efb 12771ffa 85fc43ea  .........w....C.
 1e840 07430cfb 02f79f42 04fa00f4 07d95b19  .C.....B......[.
 1e850 02f1ff30 74d29f42 72d9023a 2b44df1b  ...0t..Br..:+D..
 1e860 89b2b7fb fef80efb 187341ea 03430cfb  .........sA..C..
 1e870 08f79f42 08d95b19 08f1ff31 5cd29f42  ...B..[....1\..B
 1e880 5ad9a8f1 02082b44 d81b48ea 02428ee7  Z.....+D..H..B..
 1e890 c2f12003 2cfa03f1 0efa02fe 20fa03f7  .. .,....... ...
 1e8a0 41ea0e0e 08fa02f0 28fa03f1 4fea1e45  A.......(...O..E
 1e8b0 3843b1fb f5f8030c 05fb1811 1ffa8ef7  8C..............
 1e8c0 43ea0141 07fb08f3 8b420cfa 02fc09d9  C..A.....B......
 1e8d0 11eb0e01 08f1ff39 30d28b42 2ed9a8f1  .......90..B....
 1e8e0 02087144 c91a80b2 b1fbf5f3 05fb1311  ..qD............
 1e8f0 40ea0141 07fb03f7 8f4208d9 11eb0e01  @..A.....B......
 1e900 03f1ff30 16d28f42 14d9023b 714443ea  ...0...B...;qDC.
 1e910 0843c91b a3fb0c89 494509d3 05d00022  .C......IE....."
 1e920 1de79646 fee61346 11e79440 4445f6d2  ...F...F...@DE..
 1e930 013bf4e7 0346eae7 8846a5e7 c846d1e7  .;...F...F...F..
 1e940 02468ce7 13460ae7 023b57e7 a8f10208  .F...F...;W.....
 1e950 2f443fe7 2de9f041 002b44d1 8a421546  /D?.-..A.+D..B.F
 1e960 04464fd9 b2fa82f7 0e464fb1 c7f12003  .FO......FO... .
 1e970 b94020fa 03f602fa 07f50e43 00fa07f4  .@ ........C....
 1e980 4fea154e 230cb6fb fef0afb2 0efb1061  O..N#..........a
 1e990 43ea0143 07fb00f1 994209d9 5b1900f1  C..C.....B..[...
 1e9a0 ff3280f0 ec809942 40f2e980 02382b44  .2.....B@....8+D
 1e9b0 5a1aa4b2 b2fbfef3 0efb1322 44ea0242  Z.........."D..B
 1e9c0 07fb03f7 974208d9 521903f1 ff3180f0  .....B..R....1..
 1e9d0 d8809742 40f2d580 023b43ea 00400026  ...B@....;C..@.&
 1e9e0 3146bde8 f0818b42 47d8b3fa 83f6002e  1F.....BG.......
 1e9f0 48d18b42 02d38242 00f2cd80 01203146  H..B...B..... 1F
 1ea00 bde8f081 12b90125 b5fbf2f5 b5fa85f8  .......%........
 1ea10 b8f1000f 77d14a1b 4fea154e afb20126  ....w.J.O..N...&
 1ea20 b2fbfef0 230c0efb 102143ea 014107fb  ....#....!C..A..
 1ea30 00f38b42 07d94919 00f1ff32 02d28b42  ...B..I....2...B
 1ea40 00f2ba80 1046c91a a4b2b1fb fef30efb  .....F..........
 1ea50 131144ea 014407fb 03f7a742 08d96419  ..D..D.....B..d.
 1ea60 03f1ff32 80f08f80 a74240f2 8c80023b  ...2.....B@....;
 1ea70 43ea0040 3146bde8 f0810026 30463146  C..@1F.....&0F1F
 1ea80 bde8f081 c6f12004 22fa04f5 b3402b43  ...... ."....@+C
 1ea90 20fa04fc 01fa06f7 21fa04f5 4fea134e   .......!...O..N
 1eaa0 4cea0707 b5fbfef8 390c0efb 18551ffa  L.......9....U..
 1eab0 83fc41ea 05450cfb 08f1a942 02fa06f2  ..A..E.....B....
 1eac0 04d9ed18 08f1ff34 67d3a046 6d1abfb2  .......4g..Fm...
 1ead0 b5fbfef4 0efb1455 47ea0541 0cfb04fc  .......UG..A....
 1eae0 8c4504d9 c91804f1 ff355cd3 2c4644ea  .E.......5\.,FD.
 1eaf0 0844cceb 0101a4fb 02239942 48d344d0  .D.......#.BH.D.
 1eb00 20460026 6ce7c8f1 200401fa 08f305fa   F.&l... .......
 1eb10 08f520fa 04f7e140 4fea154e 1f43b1fb  .. ....@O..N.C..
 1eb20 fef63a0c 0efb1611 1ffa85fc 42ea0143  ..:.........B..C
 1eb30 0cfb06f2 9a4200fa 08f407d9 5b1906f1  .....B......[...
 1eb40 ff3137d2 9a4235d9 023e2b44 9b1abfb2  .17..B5..>+D....
 1eb50 b3fbfef0 0efb1033 47ea0343 0cfb00f1  .......3G..C....
 1eb60 994207d9 5b1900f1 ff3221d2 99421fd9  .B..[....2!..B..
 1eb70 02382b44 5a1a40ea 06466746 50e71046  .8+DZ.@..FgFP..F
 1eb80 16e70b46 29e71346 72e7b040 9042b7d2  ...F)..Fr..@.B..
 1eb90 601e0026 24e73046 22e7a942 95d9a8f1  `..&$.0F"..B....
 1eba0 02081d44 92e78c45 a0d9023c 19449ee7  ...D...E...<.D..
 1ebb0 1046dfe7 0e46c9e7 02382944 43e700bf  .F...F...8)DC...
 1ebc0 014b1868 704700bf 50080020 70b50f4e  .K.hpG..P.. p..N
 1ebd0 0f4d761b b61018bf 002405d0 013455f8  .Mv......$...4U.
 1ebe0 043b9847 a642f9d1 0a4e0b4d 761b00f0  .;.G.B...N.Mv...
 1ebf0 15f8b610 18bf0024 06d00134 55f8043b  .......$...4U..;
 1ec00 9847a642 f9d170bd 70bd00bf 54080020  .G.B..p.p...T.. 
 1ec10 54080020 54080020 54080020 f8b500bf  T.. T.. T.. ....
 1ec20 f8bc08bc 9e467047 f8b500bf f8bc08bc  .....FpG........
 1ec30 9e467047 6572726f 72207365 7474696e  .FpGerror settin
 1ec40 67206164 76657274 6973656d 656e7420  g advertisement 
 1ec50 64617461 3b207263 3d25640a 00657272  data; rc=%d..err
 1ec60 6f722065 6e61626c 696e6720 61647665  or enabling adve
 1ec70 72746973 656d656e 743b2072 633d2564  rtisement; rc=%d
 1ec80 0a006d61 696e2e63 0068616e 646c653d  ..main.c.handle=
 1ec90 2564206f 75725f6f 74615f61 6464725f  %d our_ota_addr_
 1eca0 74797065 3d256420 6f75725f 6f74615f  type=%d our_ota_
 1ecb0 61646472 3d00206f 75725f69 645f6164  addr=. our_id_ad
 1ecc0 64725f74 7970653d 2564206f 75725f69  dr_type=%d our_i
 1ecd0 645f6164 64723d00 20706565 725f6f74  d_addr=. peer_ot
 1ece0 615f6164 64725f74 7970653d 25642070  a_addr_type=%d p
 1ecf0 6565725f 6f74615f 61646472 3d002070  eer_ota_addr=. p
 1ed00 6565725f 69645f61 6464725f 74797065  eer_id_addr_type
 1ed10 3d256420 70656572 5f69645f 61646472  =%d peer_id_addr
 1ed20 3d002063 6f6e6e5f 6974766c 3d256420  =. conn_itvl=%d 
 1ed30 636f6e6e 5f6c6174 656e6379 3d256420  conn_latency=%d 
 1ed40 73757065 72766973 696f6e5f 74696d65  supervision_time
 1ed50 6f75743d 25642065 6e637279 70746564  out=%d encrypted
 1ed60 3d256420 61757468 656e7469 63617465  =%d authenticate
 1ed70 643d2564 20626f6e 6465643d 25640a00  d=%d bonded=%d..
 1ed80 65737461 626c6973 68656400 6661696c  established.fail
 1ed90 65640063 6f6e6e65 6374696f 6e202573  ed.connection %s
 1eda0 3b207374 61747573 3d256420 00646973  ; status=%d .dis
 1edb0 636f6e6e 6563743b 20726561 736f6e3d  connect; reason=
 1edc0 25642000 656e6372 79707469 6f6e2063  %d .encryption c
 1edd0 68616e67 65206576 656e743b 20737461  hange event; sta
 1ede0 7475733d 25642000 0a0a7375 62736372  tus=%d ...subscr
 1edf0 69626520 6576656e 743b2063 6f6e6e5f  ibe event; conn_
 1ee00 68616e64 6c653d25 64206174 74725f68  handle=%d attr_h
 1ee10 616e646c 653d2564 20726561 736f6e3d  andle=%d reason=
 1ee20 25642070 7265766e 3d256420 6375726e  %d prevn=%d curn
 1ee30 3d256420 70726576 693d2564 20637572  =%d previ=%d cur
 1ee40 693d2564 0a00626c 65707270 685f6d62  i=%d..bleprph_mb
 1ee50 75665f64 61746100 626c6570 72706800  uf_data.bleprph.
 1ee60 626c652d 6770696f 00696f5f 706f6c6c  ble-gpio.io_poll
 1ee70 5f746173 6b002573 30782530 32780025  _task.%s0x%02x.%
 1ee80 3032783a 25303278 3a253032 783a2530  02x:%02x:%02x:%0
 1ee90 32783a25 3032783a 25303278 00b76dc9  2x:%02x:%02x..m.
 1eea0 07710016 b0e1457e 899e653a 5c000000  .q....E~..e:\...
 1eeb0 01000000 48010020 00000000 88010020  ....H.. ....... 
 1eec0 01000000 e0ee0100 00000000 00010020  ............... 
 1eed0 00000000 00000000 00000000 00000000  ................
 1eee0 2b71a259 b458c812 99994395 122f4659  +q.Y.X....C../FY
 1eef0 01676174 745f7376 722e6300 25303278  .gatt_svr.c.%02x
 1ef00 25303278 25303278 25303278 2d002530  %02x%02x%02x-.%0
 1ef10 32782530 32782d25 30327825 3032782d  2x%02x-%02x%02x-
 1ef20 00726567 69737465 72656420 73657276  .registered serv
 1ef30 69636520 25732077 69746820 68616e64  ice %s with hand
 1ef40 6c653d25 640a0072 65676973 74657269  le=%d..registeri
 1ef50 6e672063 68617261 63746572 69737469  ng characteristi
 1ef60 63202573 20776974 68206465 665f6861  c %s with def_ha
 1ef70 6e646c65 3d256420 76616c5f 68616e64  ndle=%d val_hand
 1ef80 6c653d25 640a0072 65676973 74657269  le=%d..registeri
 1ef90 6e672064 65736372 6970746f 72202573  ng descriptor %s
 1efa0 20776974 68206861 6e646c65 3d25640a   with handle=%d.
 1efb0 00496e73 74727563 74696f6e 20726563  .Instruction rec
 1efc0 65697665 643a2070 696e3d25 752c2064  eived: pin=%u, d
 1efd0 69723d25 752c2076 616c3d25 750a0053  ir=%u, val=%u..S
 1efe0 65747469 6e672050 696e2025 64206173  etting Pin %d as
 1eff0 206f7574 7075742e 2e2e0a00 53657474   output.....Sett
 1f000 696e6720 50696e20 25642061 7320696e  ing Pin %d as in
 1f010 7075742e 2e2e0a00 466f756e 64206469  put.....Found di
 1f020 73637265 70656e63 79206f6e 2070696e  screpency on pin
 1f030 3a202564 0a00b86d c9077100 16b0e145  : %d...m..q....E
 1f040 7e899e65 3a5c0168 616c5f63 70757469  ~..e:\.hal_cputi
 1f050 6d652e63 00000000 00000000 01000000  me.c............
 1f060 ffffffff 02000000 ffffffff ffffffff  ................
 1f070 ffffffff 03000000 ffffffff ffffffff  ................
 1f080 ffffffff ffffffff ffffffff ffffffff  ................
 1f090 ffffffff 04000000 b5940000 00000000  ................
 1f0a0 69646c65 006f732e 63006f73 5f63616c  idle.os.c.os_cal
 1f0b0 6c6f7574 2e630041 73736572 74202573  lout.c.Assert %s
 1f0c0 3b206661 696c6564 20696e20 25733a25  ; failed in %s:%
 1f0d0 640a0055 6e68616e 646c6564 20696e74  d..Unhandled int
 1f0e0 65727275 70742028 256c6429 2c206578  errupt (%ld), ex
 1f0f0 63657074 696f6e20 73702030 78253038  ception sp 0x%08
 1f100 6c780a00 2072303a 30782530 386c7820  lx.. r0:0x%08lx 
 1f110 2072313a 30782530 386c7820 2072323a   r1:0x%08lx  r2:
 1f120 30782530 386c7820 2072333a 30782530  0x%08lx  r3:0x%0
 1f130 386c780a 00207234 3a307825 30386c78  8lx.. r4:0x%08lx
 1f140 20207235 3a307825 30386c78 20207236    r5:0x%08lx  r6
 1f150 3a307825 30386c78 20207237 3a307825  :0x%08lx  r7:0x%
 1f160 30386c78 0a002072 383a3078 2530386c  08lx.. r8:0x%08l
 1f170 78202072 393a3078 2530386c 78207231  x  r9:0x%08lx r1
 1f180 303a3078 2530386c 78207231 313a3078  0:0x%08lx r11:0x
 1f190 2530386c 780a0072 31323a30 78253038  %08lx..r12:0x%08
 1f1a0 6c782020 6c723a30 78253038 6c782020  lx  lr:0x%08lx  
 1f1b0 70633a30 78253038 6c782070 73723a30  pc:0x%08lx psr:0
 1f1c0 78253038 6c780a00 49435352 3a307825  x%08lx..ICSR:0x%
 1f1d0 30386c78 20484653 523a3078 2530386c  08lx HFSR:0x%08l
 1f1e0 78204346 53523a30 78253038 6c780a00  x CFSR:0x%08lx..
 1f1f0 42464152 3a307825 30386c78 204d4d46  BFAR:0x%08lx MMF
 1f200 41523a30 78253038 6c780a00 6f735f6d  AR:0x%08lx..os_m
 1f210 6275662e 63006f73 5f736368 65642e63  buf.c.os_sched.c
 1f220 006f735f 74696d65 2e63006f 735f6d75  .os_time.c.os_mu
 1f230 7465782e 6300626c 655f6c6c 2e630062  tex.c.ble_ll.c.b
 1f240 6c655f6c 6c00626c 655f6c6c 5f616476  le_ll.ble_ll_adv
 1f250 2e630062 6c655f6c 6c5f636f 6e6e2e63  .c.ble_ll_conn.c
 1f260 00626c65 5f6c6c5f 636f6e6e 0000f401  .ble_ll_conn....
 1f270 fa009600 64004b00 32001e00 1400626c  ....d.K.2.....bl
 1f280 655f6c6c 5f636f6e 6e5f6863 692e6300  e_ll_conn_hci.c.
 1f290 626c655f 6c6c5f63 74726c2e 63000b07  ble_ll_ctrl.c...
 1f2a0 01160c00 00010808 00000501 08171702  ................
 1f2b0 00000808 01000100 00000001 00000008  ................
 1f2c0 02020010 0020626c 655f6c6c 5f686369  ..... ble_ll_hci
 1f2d0 2e630062 6c655f6c 6c5f7265 736f6c76  .c.ble_ll_resolv
 1f2e0 2e630062 6c655f6c 6c5f7363 616e2e63  .c.ble_ll_scan.c
 1f2f0 00626c65 5f6c6c5f 73636865 642e6300  .ble_ll_sched.c.
 1f300 20000000 00400000 00000000 00002822   ....@........("
 1f310 00000000 00000000 00f7ffff 09000000  ................
 1f320 00300008 626c655f 70687900 626c655f  .0..ble_phy.ble_
 1f330 7068792e 6300656e 7472792d 25643d7b  phy.c.entry-%d={
 1f340 61646472 5f747970 653d2564 20616464  addr_type=%d add
 1f350 723d007d 20004741 50207072 6f636564  r=.} .GAP proced
 1f360 75726520 696e6974 69617465 643a2073  ure initiated: s
 1f370 65742077 68697465 6c697374 3b200063  et whitelist; .c
 1f380 6f756e74 3d256420 00474150 2070726f  ount=%d .GAP pro
 1f390 63656475 72652069 6e697469 61746564  cedure initiated
 1f3a0 3a207374 6f702061 64766572 74697369  : stop advertisi
 1f3b0 6e672e0a 00474150 2070726f 63656475  ng...GAP procedu
 1f3c0 72652069 6e697469 61746564 3a206164  re initiated: ad
 1f3d0 76657274 6973653b 20006469 73635f6d  vertise; .disc_m
 1f3e0 6f64653d 25642070 6565725f 61646472  ode=%d peer_addr
 1f3f0 5f747970 653d2564 20706565 725f6164  _type=%d peer_ad
 1f400 64723d00 6e6f6e65 00206164 765f6368  dr=.none. adv_ch
 1f410 616e6e65 6c5f6d61 703d2564 206f776e  annel_map=%d own
 1f420 5f616464 725f7479 70653d25 64206164  _addr_type=%d ad
 1f430 765f6669 6c746572 5f706f6c 6963793d  v_filter_policy=
 1f440 25642061 64765f69 74766c5f 6d696e3d  %d adv_itvl_min=
 1f450 25642061 64765f69 74766c5f 6d61783d  %d adv_itvl_max=
 1f460 25642061 64765f64 6174615f 6c656e3d  %d adv_data_len=
 1f470 25640047 41502070 726f6365 64757265  %d.GAP procedure
 1f480 20696e69 74696174 65643a20 64697363   initiated: disc
 1f490 6f766572 793b2000 6f776e5f 61646472  overy; .own_addr
 1f4a0 5f747970 653d2564 2066696c 7465725f  _type=%d filter_
 1f4b0 706f6c69 63793d25 64207061 73736976  policy=%d passiv
 1f4c0 653d2564 206c696d 69746564 3d256420  e=%d limited=%d 
 1f4d0 66696c74 65725f64 75706c69 63617465  filter_duplicate
 1f4e0 733d2564 20006475 72617469 6f6e3d66  s=%d .duration=f
 1f4f0 6f726576 65720064 75726174 696f6e3d  orever.duration=
 1f500 25646d73 00474150 2070726f 63656475  %dms.GAP procedu
 1f510 72652069 6e697469 61746564 3a20636f  re initiated: co
 1f520 6e6e6563 743b2000 4e2f4100 20736361  nnect; .N/A. sca
 1f530 6e5f6974 766c3d25 64207363 616e5f77  n_itvl=%d scan_w
 1f540 696e646f 773d2564 20697476 6c5f6d69  indow=%d itvl_mi
 1f550 6e3d2564 20697476 6c5f6d61 783d2564  n=%d itvl_max=%d
 1f560 206c6174 656e6379 3d256420 73757065   latency=%d supe
 1f570 72766973 696f6e5f 74696d65 6f75743d  rvision_timeout=
 1f580 2564206d 696e5f63 655f6c65 6e3d2564  %d min_ce_len=%d
 1f590 206d6178 5f63655f 6c656e3d 2564206f   max_ce_len=%d o
 1f5a0 776e5f61 6464725f 74797065 3d256400  wn_addr_type=%d.
 1f5b0 47415020 70726f63 65647572 6520696e  GAP procedure in
 1f5c0 69746961 7465643a 20746572 6d696e61  itiated: termina
 1f5d0 74652063 6f6e6e65 6374696f 6e3b2063  te connection; c
 1f5e0 6f6e6e5f 68616e64 6c653d25 64206863  onn_handle=%d hc
 1f5f0 695f7265 61736f6e 3d25640a 00474150  i_reason=%d..GAP
 1f600 2070726f 63656475 72652069 6e697469   procedure initi
 1f610 61746564 3a206361 6e63656c 20636f6e  ated: cancel con
 1f620 6e656374 696f6e0a 00474150 2070726f  nection..GAP pro
 1f630 63656475 72652069 6e697469 61746564  cedure initiated
 1f640 3a200063 6f6e6e65 6374696f 6e207061  : .connection pa
 1f650 72616d65 74657220 75706461 74653b20  rameter update; 
 1f660 636f6e6e 5f68616e 646c653d 25642069  conn_handle=%d i
 1f670 74766c5f 6d696e3d 25642069 74766c5f  tvl_min=%d itvl_
 1f680 6d61783d 2564206c 6174656e 63793d25  max=%d latency=%
 1f690 64207375 70657276 6973696f 6e5f7469  d supervision_ti
 1f6a0 6d656f75 743d2564 206d696e 5f63655f  meout=%d min_ce_
 1f6b0 6c656e3d 2564206d 61785f63 655f6c65  len=%d max_ce_le
 1f6c0 6e3d2564 0073656e 64207061 73736b65  n=%d.send passke
 1f6d0 79206163 74696f6e 20726571 75657374  y action request
 1f6e0 2025640a 00626c65 5f676170 00000000   %d..ble_gap....
 1f6f0 07000000 23270100 09000000 052f0100  ....#'......./..
 1f700 03000000 392b0100 03000000 892f0100  ....9+......./..
 1f710 04000000 a32c0100 05000000 312d0100  .....,......1-..
 1f720 08000000 93270100 0c000000 d92d0100  .....'.......-..
 1f730 0d000000 49300100 47415454 2070726f  ....I0..GATT pro
 1f740 63656475 72652069 6e697469 61746564  cedure initiated
 1f750 3a202573 00253032 78253032 78253032  : %s.%02x%02x%02
 1f760 78253032 782d2530 32782530 32782d25  x%02x-%02x%02x-%
 1f770 30327825 3032782d 25303278 25303278  02x%02x-%02x%02x
 1f780 25303278 25303278 25303278 25303278  %02x%02x%02x%02x
 1f790 25303278 25303278 00657863 68616e67  %02x%02x.exchang
 1f7a0 65206d74 750a0064 6973636f 76657220  e mtu..discover 
 1f7b0 616c6c20 73657276 69636573 0a006469  all services..di
 1f7c0 73636f76 65722073 65727669 63652062  scover service b
 1f7d0 79207575 69643b20 75756964 3d006669  y uuid; uuid=.fi
 1f7e0 6e642069 6e636c75 64656420 73657276  nd included serv
 1f7f0 69636573 3b200073 74617274 5f68616e  ices; .start_han
 1f800 646c653d 25642065 6e645f68 616e646c  dle=%d end_handl
 1f810 653d2564 0a006469 73636f76 65722061  e=%d..discover a
 1f820 6c6c2063 68617261 63746572 69737469  ll characteristi
 1f830 63733b20 00646973 636f7665 72206368  cs; .discover ch
 1f840 61726163 74657269 73746963 73206279  aracteristics by
 1f850 20757569 643b2000 73746172 745f6861   uuid; .start_ha
 1f860 6e646c65 3d256420 656e645f 68616e64  ndle=%d end_hand
 1f870 6c653d25 64207575 69643d00 64697363  le=%d uuid=.disc
 1f880 6f766572 20616c6c 20646573 63726970  over all descrip
 1f890 746f7273 3b200063 68725f76 616c5f68  tors; .chr_val_h
 1f8a0 616e646c 653d2564 20656e64 5f68616e  andle=%d end_han
 1f8b0 646c653d 25640a00 72656164 3b200061  dle=%d..read; .a
 1f8c0 74745f68 616e646c 653d2564 0a007265  tt_handle=%d..re
 1f8d0 61642062 79207575 69643b20 00726561  ad by uuid; .rea
 1f8e0 64206c6f 6e673b20 002c0072 65616420  d long; .,.read 
 1f8f0 6d756c74 69706c65 3b200061 74745f68  multiple; .att_h
 1f900 616e646c 65733d00 25732564 00777269  andles=.%s%d.wri
 1f910 7465206e 6f207273 703b2000 6174745f  te no rsp; .att_
 1f920 68616e64 6c653d25 64206c65 6e3d2564  handle=%d len=%d
 1f930 0a007772 6974653b 20007772 69746520  ..write; .write 
 1f940 6c6f6e67 3b200077 72697465 2072656c  long; .write rel
 1f950 6961626c 653b2000 6e6f7469 66793b20  iable; .notify; 
 1f960 00696e64 69636174 653b2000 626c655f  .indicate; .ble_
 1f970 67617474 6300626c 655f6761 7474635f  gattc.ble_gattc_
 1f980 70726f63 5f706f6f 6c000000 03000000  proc_pool.......
 1f990 d52e0100 04000000 792e0100 05000000  ........y.......
 1f9a0 a72e0100 08000000 2f2e0100 0c000000  ......../.......
 1f9b0 ad280100 0d000000 f9280100 f5240100  .(.......(...$..
 1f9c0 3d250100 8d250100 dd250100 31260100  =%...%...%..1&..
 1f9d0 81260100 cd260100 1d270100 85270100  .&...&...'...'..
 1f9e0 05280100 61280100 3d2a0100 472c0100  .(..a(..=*..G,..
 1f9f0 632f0100 752c0100 626c655f 67617474  c/..u,..ble_gatt
 1fa00 735f636c 745f6366 675f706f 6f6c0062  s_clt_cfg_pool.b
 1fa10 6c655f67 61747473 00626c65 5f68732e  le_gatts.ble_hs.
 1fa20 6300626c 655f6873 00484349 436d6450  c.ble_hs.HCICmdP
 1fa30 6f6f6c00 4843494f 73457665 6e74506f  ool.HCIOsEventPo
 1fa40 6f6c0000 08011000 20001000 40000610  ol...... ...@...
 1fa50 08010300 00000000 00000000 00000000  ................
 1fa60 00000000 2c010000 626c655f 68735f63  ....,...ble_hs_c
 1fa70 6f6e6e2e 6300626c 655f6873 5f636f6e  onn.c.ble_hs_con
 1fa80 6e5f706f 6f6c0030 78253032 782000ef  n_pool.0x%02x ..
 1fa90 8de2164f ec430dbf 5bdd34c0 531eb862  ...O.C..[.4.S..b
 1faa0 6c655f68 735f7374 61727475 702e6300  le_hs_startup.c.
 1fab0 7278206f 6e20756e 6b6e6f77 6e204c32  rx on unknown L2
 1fac0 43415020 6368616e 6e656c3a 2025640a  CAP channel: %d.
 1fad0 00626c65 5f6c3263 61705f63 68616e5f  .ble_l2cap_chan_
 1fae0 706f6f6c 00626c65 5f6c3263 61700000  pool.ble_l2cap..
 1faf0 00000000 755a0100 00000000 755a0100  ....uZ......uZ..
 1fb00 00000000 755a0100 00000000 755a0100  ....uZ......uZ..
 1fb10 00000000 755a0100 00000000 755a0100  ....uZ......uZ..
 1fb20 00000000 755a0100 00000000 755a0100  ....uZ......uZ..
 1fb30 00000000 755a0100 395b0100 015c0100  ....uZ..9[...\..
 1fb40 00000000 755a0100 4c324341 50202d20  ....uZ..L2CAP - 
 1fb50 72786564 20736967 6e616c6c 696e6720  rxed signalling 
 1fb60 6d73673a 2000626c 655f6c32 6361705f  msg: .ble_l2cap_
 1fb70 7369675f 70726f63 5f706f6f 6c000000  sig_proc_pool...
 1fb80 00000000 41690100 916b0100 a56a0100  ....Ai...k...j..
 1fb90 55710100 45610100 6d680100 a5670100  Uq..Ea..mh...g..
 1fba0 d1660100 01660100 2d650100 b5730100  .f...f..-e...s..
 1fbb0 a15e0100 a15e0100 a15e0100 25736564  .^...^...^..%sed
 1fbc0 20257320 636f6d6d 616e643a 2025733b   %s command: %s;
 1fbd0 20636f6e 6e3d2564 20007278 00736d00   conn=%d .rx.sm.
 1fbe0 6661696c 0072785f 6b65795f 666c6167  fail.rx_key_flag
 1fbf0 733d3078 25303278 0a007369 676e2069  s=0x%02x..sign i
 1fc00 6e666f00 69642061 64647220 696e666f  nfo.id addr info
 1fc10 00696420 696e666f 006d6173 74657220  .id info.master 
 1fc20 69640065 6e632069 6e666f00 70616972  id.enc info.pair
 1fc30 20726571 00636f6e 6669726d 00706169   req.confirm.pai
 1fc40 72207273 70007261 6e646f6d 00736563  r rsp.random.sec
 1fc50 20726571 00626c65 5f736d5f 70726f63   req.ble_sm_proc
 1fc60 5f706f6f 6c000000 85700100 e3600100  _pool....p...`..
 1fc70 d7600100 33600100 91600100 855f0100  .`..3`...`..._..
 1fc80 9d630100 c5610100 496a0100 00000000  .c...a..Ij......
 1fc90 00000000 20202020 25733d00 626c655f  ....    %s=.ble_
 1fca0 736d5f61 6c675f73 3128290a 20202020  sm_alg_s1().    
 1fcb0 6b3d000a 20202020 72313d00 0a202020  k=..    r1=..   
 1fcc0 2072323d 000a2020 20206f75 743d0062   r2=..    out=.b
 1fcd0 6c655f73 6d5f616c 675f6331 28290a20  le_sm_alg_c1(). 
 1fce0 2020206b 3d000a20 20202072 3d000a20     k=..    r=.. 
 1fcf0 20202069 61743d25 64207261 743d2564     iat=%d rat=%d
 1fd00 000a2020 20206961 3d000a20 20202072  ..    ia=..    r
 1fd10 613d000a 20202020 70726571 3d000a20  a=..    preq=.. 
 1fd20 20202070 7265733d 000a2020 20207031     pres=..    p1
 1fd30 3d000a20 20202070 323d000a 20202020  =..    p2=..    
 1fd40 6f75745f 656e635f 64617461 3d000a20  out_enc_data=.. 
 1fd50 20202072 633d2564 0a00626c 655f736d     rc=%d..ble_sm
 1fd60 5f616c67 5f663428 290a2020 2020753d  _alg_f4().    u=
 1fd70 000a2020 2020763d 000a2020 2020783d  ..    v=..    x=
 1fd80 000a2020 20207a3d 30782530 32780a00  ..    z=0x%02x..
 1fd90 626c655f 736d5f61 6c675f66 3528290a  ble_sm_alg_f5().
 1fda0 0077006e 31006e32 006d6163 6b657900  .w.n1.n2.mackey.
 1fdb0 6c746b00 626c655f 736d5f61 6c675f66  ltk.ble_sm_alg_f
 1fdc0 3628290a 00696f63 61700061 31740061  6()..iocap.a1t.a
 1fdd0 31006132 74006132 00726573 00626c65  1.a2t.a2.res.ble
 1fde0 5f736d5f 616c675f 67322829 0a007600  _sm_alg_g2()..v.
 1fdf0 20202020 70617373 6b65793d 25750a00      passkey=%u..
 1fe00 696f5f63 61703d25 64206f6f 625f6461  io_cap=%d oob_da
 1fe10 74615f66 6c61673d 25642061 75746872  ta_flag=%d authr
 1fe20 65713d30 78253032 78206d61 635f656e  eq=0x%02x mac_en
 1fe30 635f6b65 795f7369 7a653d25 6420696e  c_key_size=%d in
 1fe40 69745f6b 65795f64 6973743d 25642072  it_key_dist=%d r
 1fe50 6573705f 6b65795f 64697374 3d256400  esp_key_dist=%d.
 1fe60 74780076 616c7565 3d007265 61736f6e  tx.value=.reason
 1fe70 3d256400 65646976 3d307825 30347820  =%d.ediv=0x%04x 
 1fe80 0072616e 643d3078 25303136 6c6c7800  .rand=0x%016llx.
 1fe90 69726b3d 00736967 5f6b6579 3d006175  irk=.sig_key=.au
 1fea0 74687265 713d3078 25303278 00626c65  threq=0x%02x.ble
 1feb0 5f736d5f 636d642e 63007075 626c6963  _sm_cmd.c.public
 1fec0 206b6579 0064686b 65792063 6865636b   key.dhkey check
 1fed0 00000003 00030000 03000302 02020002  ................
 1fee0 00000000 00020203 00020000 02000200  ................
 1fef0 00020002 03030200 03000000 00000303  ................
 1ff00 02000344 6973636f 6e6e6563 74696f6e  ...Disconnection
 1ff10 20436f6d 706c6574 653a2073 74617475   Complete: statu
 1ff20 733d2575 2068616e 646c653d 25752072  s=%u handle=%u r
 1ff30 6561736f 6e3d2575 0a00456e 63727970  eason=%u..Encryp
 1ff40 74206b65 79207265 66726573 683a2073  t key refresh: s
 1ff50 74617475 733d2575 2068616e 646c653d  tatus=%u handle=
 1ff60 25750a00 456e6372 79707420 6368616e  %u..Encrypt chan
 1ff70 67653a20 73746174 75733d25 75206861  ge: status=%u ha
 1ff80 6e646c65 3d257520 73746174 653d2575  ndle=%u state=%u
 1ff90 0a005265 6d6f7465 20566572 73696f6e  ..Remote Version
 1ffa0 20496e66 6f3a2073 74617475 733d2575   Info: status=%u
 1ffb0 2068616e 646c653d 25752076 6572735f   handle=%u vers_
 1ffc0 6e723d25 7520636f 6d706964 3d257520  nr=%u compid=%u 
 1ffd0 73756276 65723d25 750a0049 6e76616c  subver=%u..Inval
 1ffe0 69642063 6f6d6d61 6e642063 6f6d706c  id command compl
 1fff0 6574653a 206c656e 3d256420 28657870  ete: len=%d (exp
 20000 65637465 64203e3d 20332900 436f6d6d  ected >= 3).Comm
 20010 616e6420 636f6d70 6c657465 3a20636d  and complete: cm
 20020 645f706b 74733d25 75206f67 663d3078  d_pkts=%u ogf=0x
 20030 2578206f 63663d30 78257800 20737461  %x ocf=0x%x. sta
 20040 7475733d 25752000 6863695f 7665723d  tus=%u .hci_ver=
 20050 25752068 63695f72 65763d25 75206c6d  %u hci_rev=%u lm
 20060 705f7665 723d2575 206d6672 673d2575  p_ver=%u mfrg=%u
 20070 206c6d70 5f737562 7665723d 25750073   lmp_subver=%u.s
 20080 7570705f 636d6473 3d002530 32783a25  upp_cmds=.%02x:%
 20090 3032783a 25303278 3a253032 783a2530  02x:%02x:%02x:%0
 200a0 32783a25 3032783a 25303278 3a253032  2x:%02x:%02x:%02
 200b0 783a0073 7570705f 66656174 3d307825  x:.supp_feat=0x%
 200c0 6c782530 386c7800 62645f61 6464723d  lx%08lx.bd_addr=
 200d0 25783a25 783a2578 3a25783a 25783a25  %x:%x:%x:%x:%x:%
 200e0 78006861 6e646c65 3d257520 72737369  x.handle=%u rssi
 200f0 3d256400 68616e64 6c653d25 75206368  =%d.handle=%u ch
 20100 616e6d61 703d2578 2e25782e 25782e25  anmap=%x.%x.%x.%
 20110 782e2578 0074786f 63743d25 75207478  x.%x.txoct=%u tx
 20120 74696d65 3d257520 72786f63 743d2575  time=%u rxoct=%u
 20130 20727874 696d653d 25750073 74617465   rxtime=%u.state
 20140 733d3078 256c7825 30386c78 00656e63  s=0x%lx%08lx.enc
 20150 64617461 3d307825 30327825 30327825  data=0x%02x%02x%
 20160 30327825 30327825 30327825 30327825  02x%02x%02x%02x%
 20170 30327825 30327800 72616e64 3d307825  02x%02x.rand=0x%
 20180 30327825 30327825 30327825 30327825  02x%02x%02x%02x%
 20190 30327825 30327825 30327825 30327800  02x%02x%02x%02x.
 201a0 74786f63 743d2575 20747874 696d653d  txoct=%u txtime=
 201b0 25750068 616e646c 653d2575 00436f6d  %u.handle=%u.Com
 201c0 6d616e64 20537461 7475733a 20737461  mand Status: sta
 201d0 7475733d 25752063 6d645f70 6b74733d  tus=%u cmd_pkts=
 201e0 2575206f 63663d30 78257820 6f67663d  %u ocf=0x%x ogf=
 201f0 30782578 0a004552 523a204e 756d6265  0x%x..ERR: Numbe
 20200 72206f66 20436f6d 706c6574 65642050  r of Completed P
 20210 61636b65 74732062 6164206c 656e6774  ackets bad lengt
 20220 683a206e 756d5f68 616e646c 65733d25  h: num_handles=%
 20230 75206c65 6e3d2575 0a004e75 6d626572  u len=%u..Number
 20240 206f6620 436f6d70 6c657465 64205061   of Completed Pa
 20250 636b6574 733a206e 756d5f68 616e646c  ckets: num_handl
 20260 65733d25 750a0068 616e646c 653a2575  es=%u..handle:%u
 20270 20706b74 733a2575 0a004c45 20636f6e   pkts:%u..LE con
 20280 6e656374 696f6e20 636f6d70 6c657465  nection complete
 20290 2e206861 6e646c65 3d257520 726f6c65  . handle=%u role
 202a0 3d257520 70616464 72747970 653d2575  =%u paddrtype=%u
 202b0 20616464 723d2578 2e25782e 25782e25   addr=%x.%x.%x.%
 202c0 782e2578 2e257820 006c6f63 616c5f72  x.%x.%x .local_r
 202d0 70613d25 782e2578 2e25782e 25782e25  pa=%x.%x.%x.%x.%
 202e0 782e2578 20706565 725f7270 613d2578  x.%x peer_rpa=%x
 202f0 2e25782e 25782e25 782e2578 2e257820  .%x.%x.%x.%x.%x 
 20300 00697476 6c3d2575 206c6174 656e6379  .itvl=%u latency
 20310 3d257520 7370766e 5f746d6f 3d257520  =%u spvn_tmo=%u 
 20320 6d63613d 25750a00 4c452063 6f6e6e65  mca=%u..LE conne
 20330 6374696f 6e20636f 6d706c65 74652e20  ction complete. 
 20340 4641494c 20287374 61747573 3d257529  FAIL (status=%u)
 20350 0a004c45 20616476 65727469 73696e67  ..LE advertising
 20360 20726570 6f72742e 206c656e 3d257520   report. len=%u 
 20370 6e756d3d 25752065 76747970 653d2575  num=%u evtype=%u
 20380 20616464 72747970 653d2575 20616464   addrtype=%u add
 20390 723d2578 2e25782e 25782e25 782e2578  r=%x.%x.%x.%x.%x
 203a0 2e257820 6164766c 656e3d25 75207273  .%x advlen=%u rs
 203b0 73693d25 640a0025 730a004c 4520436f  si=%d..%s..LE Co
 203c0 6e6e6563 74696f6e 20557064 61746520  nnection Update 
 203d0 436f6d70 6c657465 2e206861 6e646c65  Complete. handle
 203e0 3d257520 6974766c 3d257520 6c617465  =%u itvl=%u late
 203f0 6e63793d 25752074 696d656f 75743d25  ncy=%u timeout=%
 20400 750a004c 4520436f 6e6e6563 74696f6e  u..LE Connection
 20410 20557064 61746520 436f6d70 6c657465   Update Complete
 20420 2e204641 494c2028 73746174 75733d25  . FAIL (status=%
 20430 75290a00 4c452044 61746120 4c656e67  u)..LE Data Leng
 20440 74682043 68616e67 652e2068 616e646c  th Change. handl
 20450 653d2575 206d6178 5f74785f 62797465  e=%u max_tx_byte
 20460 733d2575 206d6178 5f74785f 74696d65  s=%u max_tx_time
 20470 3d257520 6d61785f 72785f62 79746573  =%u max_rx_bytes
 20480 3d257520 6d61785f 72785f74 696d653d  =%u max_rx_time=
 20490 25750a00 4c452052 656d6f74 6520436f  %u..LE Remote Co
 204a0 6e6e6563 74696f6e 20506172 616d6574  nnection Paramet
 204b0 65722052 65717565 73742e20 68616e64  er Request. hand
 204c0 6c653d25 75206d69 6e5f6974 766c3d25  le=%u min_itvl=%
 204d0 75206d61 785f6974 766c3d25 75206c61  u max_itvl=%u la
 204e0 74656e63 793d2575 2074696d 656f7574  tency=%u timeout
 204f0 3d25750a 004c4520 52656d6f 74652055  =%u..LE Remote U
 20500 73656420 46656174 75726573 2e206861  sed Features. ha
 20510 6e646c65 3d257520 66656174 3d004c45  ndle=%u feat=.LE
 20520 2052656d 6f746520 55736564 20466561   Remote Used Fea
 20530 74757265 732e2046 41494c20 28737461  tures. FAIL (sta
 20540 7475733d 2575290a 004c4520 4c544b20  tus=%u)..LE LTK 
 20550 5265712e 2068616e 646c653d 25752072  Req. handle=%u r
 20560 616e643d 256c7825 6c782065 6e636469  and=%lx%lx encdi
 20570 763d2575 0a000955 6e6b6e6f 776e204c  v=%u...Unknown L
 20580 45206576 656e740a 00455252 3a204175  E event..ERR: Au
 20590 74685079 6c64546d 6f457665 6e742062  thPyldTmoEvent b
 205a0 6164206c 656e6774 68202575 0a004175  ad length %u..Au
 205b0 74685079 6c64546d 6f3a2068 616e646c  thPyldTmo: handl
 205c0 653d2575 0a00556e 6b6e6f77 6e206576  e=%u..Unknown ev
 205d0 656e7420 30782578 206c656e 3d25750a  ent 0x%x len=%u.
 205e0 00686f73 745f6863 695f6461 74615f72  .host_hci_data_r
 205f0 7828293a 2068616e 646c653d 25752070  x(): handle=%u p
 20600 623d2578 206c656e 3d257520 64617461  b=%x len=%u data
 20610 3d00686f 73742074 78206863 69206461  =.host tx hci da
 20620 74613b20 68616e64 6c653d25 64206c65  ta; handle=%d le
 20630 6e677468 3d25640a 00686f73 745f6863  ngth=%d..host_hc
 20640 695f6461 74615f74 7828293a 20000000  i_data_tx(): ...
 20650 01000000 79900100 02000000 6d8d0100  ....y.......m...
 20660 03000000 fb8f0100 05000000 bb8f0100  ................
 20670 06000000 378f0100 0a000000 79900100  ....7.......y...
 20680 0b000000 6d8e0100 05000000 a9910100  ....m...........
 20690 08000000 7b910100 13000000 018f0100  ....{...........
 206a0 30000000 53910100 3e000000 358e0100  0...S...>...5...
 206b0 686f7374 5f686369 5f636d64 5f73656e  host_hci_cmd_sen
 206c0 643a206f 67663d30 78253032 78206f63  d: ogf=0x%02x oc
 206d0 663d3078 25303278 206c656e 3d25640a  f=0x%02x len=%d.
 206e0 00686f73 745f6863 695f636d 645f7365  .host_hci_cmd_se
 206f0 6e642066 61696c75 72653b20 72633d25  nd failure; rc=%
 20700 640a0000 01000000 499f0100 02000000  d.......I.......
 20710 f9b40100 03000000 bd9f0100 04000000  ................
 20720 35b60100 05000000 e1a00100 06000000  5...............
 20730 fdb70100 07000000 6da20100 08000000  ........m.......
 20740 05ba0100 09000000 91a30100 0a000000  ................
 20750 59bc0100 0b000000 dda40100 0c000000  Y...............
 20760 8dbd0100 0d000000 e1a50100 0e000000  ................
 20770 e1be0100 0f000000 55a60100 10000000  ........U.......
 20780 59c00100 11000000 6da70100 12000000  Y.......m.......
 20790 1dc30100 13000000 3da80100 16000000  ........=.......
 207a0 edc40100 17000000 4da90100 18000000  ........M.......
 207b0 09c70100 19000000 7daa0100 1b000000  ........}.......
 207c0 a5c80100 1d000000 59c90100 1e000000  ........Y.......
 207d0 2dac0100 52000000 3dc40100 626c655f  -...R...=...ble_
 207e0 61747400 6572726f 72207273 70006d74  att.error rsp.mt
 207f0 75207265 71006d74 75207273 70006669  u req.mtu rsp.fi
 20800 6e642069 6e666f20 72657100 66696e64  nd info req.find
 20810 20696e66 6f207273 70006669 6e642074   info rsp.find t
 20820 79706520 76616c75 65207265 71006669  ype value req.fi
 20830 6e642074 79706520 76616c75 65207273  nd type value rs
 20840 70007265 61642074 79706520 72657100  p.read type req.
 20850 72656164 20747970 65207273 70007265  read type rsp.re
 20860 61642072 65710072 65616420 72737000  ad req.read rsp.
 20870 72656164 20626c6f 62207265 71007265  read blob req.re
 20880 61642062 6c6f6220 72737000 72657164  ad blob rsp.reqd
 20890 206d756c 74207265 71007265 6164206d   mult req.read m
 208a0 756c7420 72737000 72656164 2067726f  ult rsp.read gro
 208b0 75702074 79706520 72657100 72656164  up type req.read
 208c0 2067726f 75702074 79706520 72737000   group type rsp.
 208d0 77726974 6520636d 64007072 65702077  write cmd.prep w
 208e0 72697465 20726571 00707265 70207772  rite req.prep wr
 208f0 69746520 72737000 65786563 20777269  ite rsp.exec wri
 20900 74652072 65710065 78656320 77726974  te req.exec writ
 20910 65207273 70006e6f 74696679 20726571  e rsp.notify req
 20920 00696e64 69636174 65207265 7100696e  .indicate req.in
 20930 64696361 74652072 73700072 65715f6f  dicate rsp.req_o
 20940 703d2564 2068616e 646c653d 30782530  p=%d handle=0x%0
 20950 34782065 72726f72 5f636f64 653d2564  4x error_code=%d
 20960 006d7475 3d256400 73746172 745f6861  .mtu=%d.start_ha
 20970 6e646c65 3d307825 30347820 656e645f  ndle=0x%04x end_
 20980 68616e64 6c653d30 78253034 7800666f  handle=0x%04x.fo
 20990 726d6174 3d256400 73746172 745f6861  rmat=%d.start_ha
 209a0 6e646c65 3d307825 30347820 656e645f  ndle=0x%04x end_
 209b0 68616e64 6c653d30 78253034 78206174  handle=0x%04x at
 209c0 74725f74 7970653d 2564006c 656e6774  tr_type=%d.lengt
 209d0 683d2564 0068616e 646c653d 30782530  h=%d.handle=0x%0
 209e0 3478206f 66667365 743d2564 00666c61  4x offset=%d.fla
 209f0 67733d30 78253032 78007265 6164206d  gs=0x%02x.read m
 20a00 756c7420 72657100 626c655f 6174745f  ult req.ble_att_
 20a10 7376725f 656e7472 795f706f 6f6c0062  svr_entry_pool.b
 20a20 6c655f61 74745f73 76725f70 7265705f  le_att_svr_prep_
 20a30 656e7472 795f706f 6f6c0000 01000000  entry_pool......
 20a40 58020020 00000000 c8020020 00000000  X.. ....... ....
 20a50 00000000 00000000 00000000 626c655f  ............ble_
 20a60 7376635f 6761702e 6300626c 655f7376  svc_gap.c.ble_sv
 20a70 635f6761 74742e63 00000000 01000000  c_gatt.c........
 20a80 68030020 00000000 88030020 00000000  h.. ....... ....
 20a90 00000000 00000000 00000000 65646976  ............ediv
 20aa0 3d257520 72616e64 3d256c6c 75206175  =%u rand=%llu au
 20ab0 7468656e 74696361 7465643d 2564206c  thenticated=%d l
 20ac0 746b3d00 6373726b 3d006564 69763d30  tk=.csrk=.ediv=0
 20ad0 78253032 78207261 6e643d30 78256c6c  x%02x rand=0x%ll
 20ae0 7820006c 6f6f6b69 6e672075 70207065  x .looking up pe
 20af0 65722073 65633b20 006c6f6f 6b696e67  er sec; .looking
 20b00 20757020 6f757220 7365633b 20007065   up our sec; .pe
 20b10 72736973 74696e67 20706565 72207365  rsisting peer se
 20b20 633b2000 6572726f 72207065 72736973  c; .error persis
 20b30 74696e67 20706565 72207365 633b2074  ting peer sec; t
 20b40 6f6f206d 616e7920 656e7472 69657320  oo many entries 
 20b50 28256429 0a007065 72736973 74696e67  (%d)..persisting
 20b60 206f7572 20736563 3b200065 72726f72   our sec; .error
 20b70 20706572 73697374 696e6720 6f757220   persisting our 
 20b80 7365633b 20746f6f 206d616e 7920656e  sec; too many en
 20b90 74726965 73202825 64290a00 6572726f  tries (%d)..erro
 20ba0 72207065 72736973 74696e67 20636363  r persisting ccc
 20bb0 643b2074 6f6f206d 616e7920 656e7472  d; too many entr
 20bc0 69657320 28256429 0a000008 00000006  ies (%d)........
 20bd0 0f002020 01070219 00000007 070e0502  ..  ............
 20be0 0220001c 12020001 03000e03 06000400  . ..............
 20bf0 40270700 00070701 02005b74 733d256c  @'........[ts=%l
 20c00 75737362 2c206d6f 643d2575 206c6576  ussb, mod=%u lev
 20c10 656c3d25 755d2000 73746174 0068616c  el=%u] .stat.hal
 20c20 5f6f735f 7469636b 2e630068 616c5f75  _os_tick.c.hal_u
 20c30 6172742e 63000000 440c0200 256c753a  art.c...D...%lu:
 20c40 00000000 55970000 00000000 637c777b  ....U.......c|w{
 20c50 f26b6fc5 3001672b fed7ab76 ca82c97d  .ko.0.g+...v...}
 20c60 fa5947f0 add4a2af 9ca472c0 b7fd9326  .YG.......r....&
 20c70 363ff7cc 34a5e5f1 71d83115 04c723c3  6?..4...q.1...#.
 20c80 1896059a 071280e2 eb27b275 09832c1a  .........'.u..,.
 20c90 1b6e5aa0 523bd6b3 29e32f84 53d100ed  .nZ.R;..)./.S...
 20ca0 20fcb15b 6acbbe39 4a4c58cf d0efaafb   ..[j..9JLX.....
 20cb0 434d3385 45f9027f 503c9fa8 51a3408f  CM3.E...P<..Q.@.
 20cc0 929d38f5 bcb6da21 10fff3d2 cd0c13ec  ..8....!........
 20cd0 5f974417 c4a77e3d 645d1973 60814fdc  _.D...~=d].s`.O.
 20ce0 222a9088 46eeb814 de5e0bdb e0323a0a  "*..F....^...2:.
 20cf0 4906245c c2d3ac62 9195e479 e7c8376d  I.$\...b...y..7m
 20d00 8dd54ea9 6c56f4ea 657aae08 ba78252e  ..N.lV..ez...x%.
 20d10 1ca6b4c6 e8dd741f 4bbd8b8a 703eb566  ......t.K...p>.f
 20d20 4803f60e 613557b9 86c11d9e e1f89811  H...a5W.........
 20d30 69d98e94 9b1e87e9 ce5528df 8ca1890d  i........U(.....
 20d40 bfe64268 41992d0f b054bb16 51f4a750  ..BhA.-..T..Q..P
 20d50 7e416553 1a17a4c3 3a275e96 3bab6bcb  ~AeS....:'^.;.k.
 20d60 1f9d45f1 acfa58ab 4be30393 2030fa55  ..E...X.K... 0.U
 20d70 ad766df6 88cc7691 f5024c25 4fe5d7fc  .vm...v...L%O...
 20d80 c52acbd7 26354480 b562a38f deb15a49  .*..&5D..b....ZI
 20d90 25ba1b67 45ea0e98 5dfec0e1 c32f7502  %..gE...]..../u.
 20da0 814cf012 8d4697a3 6bd3f9c6 038f5fe7  .L...F..k....._.
 20db0 15929c95 bf6d7aeb 955259da d4be832d  .....mz..RY....-
 20dc0 587421d3 49e06929 8ec9c844 75c2896a  Xt!.I.i)...Du..j
 20dd0 f48e7978 99583e6b 27b971dd bee14fb6  ..yx.X>k'.q...O.
 20de0 f088ad17 c920ac66 7dce3ab4 63df4a18  ..... .f}.:.c.J.
 20df0 e51a3182 97513360 62537f45 b16477e0  ..1..Q3`bS.E.dw.
 20e00 bb6bae84 fe81a01c f9082b94 70486858  .k........+.pHhX
 20e10 8f45fd19 94de6c87 527bf8b7 ab73d323  .E....l.R{...s.#
 20e20 724b02e2 e31f8f57 6655ab2a b2eb2807  rK.....WfU.*..(.
 20e30 2fb5c203 86c57b9a d33708a5 302887f2  /.....{..7..0(..
 20e40 23bfa5b2 02036aba ed16825c 8acf1c2b  #.....j....\...+
 20e50 a779b492 f307f2f0 4e69e2a1 65daf4cd  .y......Ni..e...
 20e60 0605bed5 d134621f c4a6fe8a 342e539d  .....4b.....4.S.
 20e70 a2f355a0 058ae132 a4f6eb75 0b83ec39  ..U....2...u...9
 20e80 4060efaa 5e719f06 bd6e1051 3e218af9  @`..^q...n.Q>!..
 20e90 96dd063d dd3e05ae 4de6bd46 91548db5  ...=.>..M..F.T..
 20ea0 71c45d05 0406d46f 605015ff 1998fb24  q.]....o`P.....$
 20eb0 d6bde997 894043cc 67d99e77 b0e842bd  .....@C.g..w..B.
 20ec0 07898b88 e7195b38 79c8eedb a17c0a47  ......[8y....|.G
 20ed0 7c420fe9 f8841ec9 00000000 09808683  |B..............
 20ee0 322bed48 1e1170ac 6c5a724e fd0efffb  2+.H..p.lZrN....
 20ef0 0f853856 3daed51e 362d3927 0a0fd964  ..8V=...6-9'...d
 20f00 685ca621 9b5b54d1 24362e3a 0c0a67b1  h\.!.[T.$6.:..g.
 20f10 9357e70f b4ee96d2 1b9b919e 80c0c54f  .W.............O
 20f20 61dc20a2 5a774b69 1c121a16 e293ba0a  a. .ZwKi........
 20f30 c0a02ae5 3c22e043 121b171d 0e090d0b  ..*.<".C........
 20f40 f28bc7ad 2db6a8b9 141ea9c8 57f11985  ....-.......W...
 20f50 af75074c ee99ddbb a37f60fd f701269f  .u.L......`...&.
 20f60 5c72f5bc 44663bc5 5bfb7e34 8b432976  \r..Df;.[.~4.C)v
 20f70 cb23c6dc b6edfc68 b8e4f163 d731dcca  .#.....h...c.1..
 20f80 42638510 13972240 84c61120 854a247d  Bc...."@... .J$}
 20f90 d2bb3df8 aef93211 c729a16d 1d9e2f4b  ..=...2..).m../K
 20fa0 dcb230f3 0d8652ec 77c1e3d0 2bb3166c  ..0...R.w...+..l
 20fb0 a970b999 119448fa 47e96422 a8fc8cc4  .p....H.G.d"....
 20fc0 a0f03f1a 567d2cd8 223390ef 87494ec7  ..?.V},."3...IN.
 20fd0 d938d1c1 8ccaa2fe 98d40b36 a6f581cf  .8.........6....
 20fe0 a57ade28 dab78e26 3fadbfa4 2c3a9de4  .z.(...&?...,:..
 20ff0 5078920d 6a5fcc9b 547e4662 f68d13c2  Px..j_..T~Fb....
 21000 90d8b8e8 2e39f75e 82c3aff5 9f5d80be  .....9.^.....]..
 21010 69d0937c 6fd52da9 cf2512b3 c8ac993b  i..|o.-..%.....;
 21020 10187da7 e89c636e db3bbb7b cd267809  ..}...cn.;.{.&x.
 21030 6e5918f4 ec9ab701 834f9aa8 e6956e65  nY.......O....ne
 21040 aaffe67e 21bccf08 ef15e8e6 bae79bd9  ...~!...........
 21050 4a6f36ce ea9f09d4 29b07cd6 31a4b2af  Jo6.....).|.1...
 21060 2a3f2331 c6a59430 35a266c0 744ebc37  *?#1...05.f.tN.7
 21070 fc82caa6 e090d0b0 33a7d815 f104984a  ........3......J
 21080 41ecdaf7 7fcd500e 1791f62f 764dd68d  A.....P..../vM..
 21090 43efb04d ccaa4d54 e49604df 9ed1b5e3  C..M..MT........
 210a0 4c6a881b c12c1fb8 4665517f 9d5eea04  Lj...,..FeQ..^..
 210b0 018c355d fa877473 fb0b412e b3671d5a  ..5]..ts..A..g.Z
 210c0 92dbd252 e9105633 6dd64713 9ad7618c  ...R..V3m.G...a.
 210d0 37a10c7a 59f8148e eb133c89 cea927ee  7..zY.....<...'.
 210e0 b761c935 e11ce5ed 7a47b13c 9cd2df59  .a.5....zG.<...Y
 210f0 55f2733f 1814ce79 73c737bf 53f7cdea  U.s?...ys.7.S...
 21100 5ffdaa5b df3d6f14 7844db86 caaff381  _..[.=o.xD......
 21110 b968c43e 3824342c c2a3405f 161dc372  .h.>8$4,..@_...r
 21120 bce2250c 283c498b ff0d9541 39a80171  ..%.(<I....A9..q
 21130 080cb3de d8b4e49c 6456c190 7bcb8461  ........dV..{..a
 21140 d532b670 486c5c74 d0b85742 5051f4a7  .2.pHl\t..WBPQ..
 21150 537e4165 c31a17a4 963a275e cb3bab6b  S~Ae.....:'^.;.k
 21160 f11f9d45 abacfa58 934be303 552030fa  ...E...X.K..U 0.
 21170 f6ad766d 9188cc76 25f5024c fc4fe5d7  ..vm...v%..L.O..
 21180 d7c52acb 80263544 8fb562a3 49deb15a  ..*..&5D..b.I..Z
 21190 6725ba1b 9845ea0e e15dfec0 02c32f75  g%...E...]..../u
 211a0 12814cf0 a38d4697 c66bd3f9 e7038f5f  ..L...F..k....._
 211b0 9515929c ebbf6d7a da955259 2dd4be83  ......mz..RY-...
 211c0 d3587421 2949e069 448ec9c8 6a75c289  .Xt!)I.iD...ju..
 211d0 78f48e79 6b99583e dd27b971 b6bee14f  x..yk.X>.'.q...O
 211e0 17f088ad 66c920ac b47dce3a 1863df4a  ....f. ..}.:.c.J
 211f0 82e51a31 60975133 4562537f e0b16477  ...1`.Q3EbS...dw
 21200 84bb6bae 1cfe81a0 94f9082b 58704868  ..k........+XpHh
 21210 198f45fd 8794de6c b7527bf8 23ab73d3  ..E....l.R{.#.s.
 21220 e2724b02 57e31f8f 2a6655ab 07b2eb28  .rK.W...*fU....(
 21230 032fb5c2 9a86c57b a5d33708 f2302887  ./.....{..7..0(.
 21240 b223bfa5 ba02036a 5ced1682 2b8acf1c  .#.....j\...+...
 21250 92a779b4 f0f307f2 a14e69e2 cd65daf4  ..y......Ni..e..
 21260 d50605be 1fd13462 8ac4a6fe 9d342e53  ......4b.....4.S
 21270 a0a2f355 32058ae1 75a4f6eb 390b83ec  ...U2...u...9...
 21280 aa4060ef 065e719f 51bd6e10 f93e218a  .@`..^q.Q.n..>!.
 21290 3d96dd06 aedd3e05 464de6bd b591548d  =.....>.FM....T.
 212a0 0571c45d 6f0406d4 ff605015 241998fb  .q.]o....`P.$...
 212b0 97d6bde9 cc894043 7767d99e bdb0e842  ......@Cwg.....B
 212c0 8807898b 38e7195b db79c8ee 47a17c0a  ....8..[.y..G.|.
 212d0 e97c420f c9f8841e 00000000 83098086  .|B.............
 212e0 48322bed ac1e1170 4e6c5a72 fbfd0eff  H2+....pNlZr....
 212f0 560f8538 1e3daed5 27362d39 640a0fd9  V..8.=..'6-9d...
 21300 21685ca6 d19b5b54 3a24362e b10c0a67  !h\...[T:$6....g
 21310 0f9357e7 d2b4ee96 9e1b9b91 4f80c0c5  ..W.........O...
 21320 a261dc20 695a774b 161c121a 0ae293ba  .a. iZwK........
 21330 e5c0a02a 433c22e0 1d121b17 0b0e090d  ...*C<".........
 21340 adf28bc7 b92db6a8 c8141ea9 8557f119  .....-.......W..
 21350 4caf7507 bbee99dd fda37f60 9ff70126  L.u........`...&
 21360 bc5c72f5 c544663b 345bfb7e 768b4329  .\r..Df;4[.~v.C)
 21370 dccb23c6 68b6edfc 63b8e4f1 cad731dc  ..#.h...c.....1.
 21380 10426385 40139722 2084c611 7d854a24  .Bc.@.." ...}.J$
 21390 f8d2bb3d 11aef932 6dc729a1 4b1d9e2f  ...=...2m.).K../
 213a0 f3dcb230 ec0d8652 d077c1e3 6c2bb316  ...0...R.w..l+..
 213b0 99a970b9 fa119448 2247e964 c4a8fc8c  ..p....H"G.d....
 213c0 1aa0f03f d8567d2c ef223390 c787494e  ...?.V},."3...IN
 213d0 c1d938d1 fe8ccaa2 3698d40b cfa6f581  ..8.....6.......
 213e0 28a57ade 26dab78e a43fadbf e42c3a9d  (.z.&....?...,:.
 213f0 0d507892 9b6a5fcc 62547e46 c2f68d13  .Px..j_.bT~F....
 21400 e890d8b8 5e2e39f7 f582c3af be9f5d80  ....^.9.......].
 21410 7c69d093 a96fd52d b3cf2512 3bc8ac99  |i...o.-..%.;...
 21420 a710187d 6ee89c63 7bdb3bbb 09cd2678  ...}n..c{.;...&x
 21430 f46e5918 01ec9ab7 a8834f9a 65e6956e  .nY.......O.e..n
 21440 7eaaffe6 0821bccf e6ef15e8 d9bae79b  ~....!..........
 21450 ce4a6f36 d4ea9f09 d629b07c af31a4b2  .Jo6.....).|.1..
 21460 312a3f23 30c6a594 c035a266 37744ebc  1*?#0....5.f7tN.
 21470 a6fc82ca b0e090d0 1533a7d8 4af10498  .........3..J...
 21480 f741ecda 0e7fcd50 2f1791f6 8d764dd6  .A.....P/....vM.
 21490 4d43efb0 54ccaa4d dfe49604 e39ed1b5  MC..T..M........
 214a0 1b4c6a88 b8c12c1f 7f466551 049d5eea  .Lj...,..FeQ..^.
 214b0 5d018c35 73fa8774 2efb0b41 5ab3671d  ]..5s..t...AZ.g.
 214c0 5292dbd2 33e91056 136dd647 8c9ad761  R...3..V.m.G...a
 214d0 7a37a10c 8e59f814 89eb133c eecea927  z7...Y.....<...'
 214e0 35b761c9 ede11ce5 3c7a47b1 599cd2df  5.a.....<zG.Y...
 214f0 3f55f273 791814ce bf73c737 ea53f7cd  ?U.sy....s.7.S..
 21500 5b5ffdaa 14df3d6f 867844db 81caaff3  [_....=o.xD.....
 21510 3eb968c4 2c382434 5fc2a340 72161dc3  >.h.,8$4_..@r...
 21520 0cbce225 8b283c49 41ff0d95 7139a801  ...%.(<IA...q9..
 21530 de080cb3 9cd8b4e4 906456c1 617bcb84  .........dV.a{..
 21540 70d532b6 74486c5c 42d0b857 a75051f4  p.2.tHl\B..W.PQ.
 21550 65537e41 a4c31a17 5e963a27 6bcb3bab  eS~A....^.:'k.;.
 21560 45f11f9d 58abacfa 03934be3 fa552030  E...X.....K..U 0
 21570 6df6ad76 769188cc 4c25f502 d7fc4fe5  m..vv...L%....O.
 21580 cbd7c52a 44802635 a38fb562 5a49deb1  ...*D.&5...bZI..
 21590 1b6725ba 0e9845ea c0e15dfe 7502c32f  .g%...E...].u../
 215a0 f012814c 97a38d46 f9c66bd3 5fe7038f  ...L...F..k._...
 215b0 9c951592 7aebbf6d 59da9552 832dd4be  ....z..mY..R.-..
 215c0 21d35874 692949e0 c8448ec9 896a75c2  !.Xti)I..D...ju.
 215d0 7978f48e 3e6b9958 71dd27b9 4fb6bee1  yx..>k.Xq.'.O...
 215e0 ad17f088 ac66c920 3ab47dce 4a1863df  .....f. :.}.J.c.
 215f0 3182e51a 33609751 7f456253 77e0b164  1...3`.Q.EbSw..d
 21600 ae84bb6b a01cfe81 2b94f908 68587048  ...k....+...hXpH
 21610 fd198f45 6c8794de f8b7527b d323ab73  ...El.....R{.#.s
 21620 02e2724b 8f57e31f ab2a6655 2807b2eb  ..rK.W...*fU(...
 21630 c2032fb5 7b9a86c5 08a5d337 87f23028  ../.{......7..0(
 21640 a5b223bf 6aba0203 825ced16 1c2b8acf  ..#.j....\...+..
 21650 b492a779 f2f0f307 e2a14e69 f4cd65da  ...y......Ni..e.
 21660 bed50605 621fd134 fe8ac4a6 539d342e  ....b..4....S.4.
 21670 55a0a2f3 e132058a eb75a4f6 ec390b83  U....2...u...9..
 21680 efaa4060 9f065e71 1051bd6e 8af93e21  ..@`..^q.Q.n..>!
 21690 063d96dd 05aedd3e bd464de6 8db59154  .=.....>.FM....T
 216a0 5d0571c4 d46f0406 15ff6050 fb241998  ].q..o....`P.$..
 216b0 e997d6bd 43cc8940 9e7767d9 42bdb0e8  ....C..@.wg.B...
 216c0 8b880789 5b38e719 eedb79c8 0a47a17c  ....[8....y..G.|
 216d0 0fe97c42 1ec9f884 00000000 86830980  ..|B............
 216e0 ed48322b 70ac1e11 724e6c5a fffbfd0e  .H2+p...rNlZ....
 216f0 38560f85 d51e3dae 3927362d d9640a0f  8V....=.9'6-.d..
 21700 a621685c 54d19b5b 2e3a2436 67b10c0a  .!h\T..[.:$6g...
 21710 e70f9357 96d2b4ee 919e1b9b c54f80c0  ...W.........O..
 21720 20a261dc 4b695a77 1a161c12 ba0ae293   .a.KiZw........
 21730 2ae5c0a0 e0433c22 171d121b 0d0b0e09  *....C<"........
 21740 c7adf28b a8b92db6 a9c8141e 198557f1  ......-.......W.
 21750 074caf75 ddbbee99 60fda37f 269ff701  .L.u....`...&...
 21760 f5bc5c72 3bc54466 7e345bfb 29768b43  ..\r;.Df~4[.)v.C
 21770 c6dccb23 fc68b6ed f163b8e4 dccad731  ...#.h...c.....1
 21780 85104263 22401397 112084c6 247d854a  ..Bc"@... ..$}.J
 21790 3df8d2bb 3211aef9 a16dc729 2f4b1d9e  =...2....m.)/K..
 217a0 30f3dcb2 52ec0d86 e3d077c1 166c2bb3  0...R.....w..l+.
 217b0 b999a970 48fa1194 642247e9 8cc4a8fc  ...pH...d"G.....
 217c0 3f1aa0f0 2cd8567d 90ef2233 4ec78749  ?...,.V}.."3N..I
 217d0 d1c1d938 a2fe8cca 0b3698d4 81cfa6f5  ...8.....6......
 217e0 de28a57a 8e26dab7 bfa43fad 9de42c3a  .(.z.&....?...,:
 217f0 920d5078 cc9b6a5f 4662547e 13c2f68d  ..Px..j_FbT~....
 21800 b8e890d8 f75e2e39 aff582c3 80be9f5d  .....^.9.......]
 21810 937c69d0 2da96fd5 12b3cf25 993bc8ac  .|i.-.o....%.;..
 21820 7da71018 636ee89c bb7bdb3b 7809cd26  }...cn...{.;x..&
 21830 18f46e59 b701ec9a 9aa8834f 6e65e695  ..nY.......One..
 21840 e67eaaff cf0821bc e8e6ef15 9bd9bae7  .~....!.........
 21850 36ce4a6f 09d4ea9f 7cd629b0 b2af31a4  6.Jo....|.)...1.
 21860 23312a3f 9430c6a5 66c035a2 bc37744e  #1*?.0..f.5..7tN
 21870 caa6fc82 d0b0e090 d81533a7 984af104  ..........3..J..
 21880 daf741ec 500e7fcd f62f1791 d68d764d  ..A.P..../....vM
 21890 b04d43ef 4d54ccaa 04dfe496 b5e39ed1  .MC.MT..........
 218a0 881b4c6a 1fb8c12c 517f4665 ea049d5e  ..Lj...,Q.Fe...^
 218b0 355d018c 7473fa87 412efb0b 1d5ab367  5]..ts..A....Z.g
 218c0 d25292db 5633e910 47136dd6 618c9ad7  .R..V3..G.m.a...
 218d0 0c7a37a1 148e59f8 3c89eb13 27eecea9  .z7...Y.<...'...
 218e0 c935b761 e5ede11c b13c7a47 df599cd2  .5.a.....<zG.Y..
 218f0 733f55f2 ce791814 37bf73c7 cdea53f7  s?U..y..7.s...S.
 21900 aa5b5ffd 6f14df3d db867844 f381caaf  .[_.o..=..xD....
 21910 c43eb968 342c3824 405fc2a3 c372161d  .>.h4,8$@_...r..
 21920 250cbce2 498b283c 9541ff0d 017139a8  %...I.(<.A...q9.
 21930 b3de080c e49cd8b4 c1906456 84617bcb  ..........dV.a{.
 21940 b670d532 5c74486c 5742d0b8 f4a75051  .p.2\tHlWB....PQ
 21950 4165537e 17a4c31a 275e963a ab6bcb3b  AeS~....'^.:.k.;
 21960 9d45f11f fa58abac e303934b 30fa5520  .E...X.....K0.U 
 21970 766df6ad cc769188 024c25f5 e5d7fc4f  vm...v...L%....O
 21980 2acbd7c5 35448026 62a38fb5 b15a49de  *...5D.&b....ZI.
 21990 ba1b6725 ea0e9845 fec0e15d 2f7502c3  ..g%...E...]/u..
 219a0 4cf01281 4697a38d d3f9c66b 8f5fe703  L...F......k._..
 219b0 929c9515 6d7aebbf 5259da95 be832dd4  ....mz..RY....-.
 219c0 7421d358 e0692949 c9c8448e c2896a75  t!.X.i)I..D...ju
 219d0 8e7978f4 583e6b99 b971dd27 e14fb6be  .yx.X>k..q.'.O..
 219e0 88ad17f0 20ac66c9 ce3ab47d df4a1863  .... .f..:.}.J.c
 219f0 1a3182e5 51336097 537f4562 6477e0b1  .1..Q3`.S.Ebdw..
 21a00 6bae84bb 81a01cfe 082b94f9 48685870  k........+..HhXp
 21a10 45fd198f de6c8794 7bf8b752 73d323ab  E....l..{..Rs.#.
 21a20 4b02e272 1f8f57e3 55ab2a66 eb2807b2  K..r..W.U.*f.(..
 21a30 b5c2032f c57b9a86 3708a5d3 2887f230  .../.{..7...(..0
 21a40 bfa5b223 036aba02 16825ced cf1c2b8a  ...#.j....\...+.
 21a50 79b492a7 07f2f0f3 69e2a14e daf4cd65  y.......i..N...e
 21a60 05bed506 34621fd1 a6fe8ac4 2e539d34  ....4b.......S.4
 21a70 f355a0a2 8ae13205 f6eb75a4 83ec390b  .U....2...u...9.
 21a80 60efaa40 719f065e 6e1051bd 218af93e  `..@q..^n.Q.!..>
 21a90 dd063d96 3e05aedd e6bd464d 548db591  ..=.>.....FMT...
 21aa0 c45d0571 06d46f04 5015ff60 98fb2419  .].q..o.P..`..$.
 21ab0 bde997d6 4043cc89 d99e7767 e842bdb0  ....@C....wg.B..
 21ac0 898b8807 195b38e7 c8eedb79 7c0a47a1  .....[8....y|.G.
 21ad0 420fe97c 841ec9f8 00000000 80868309  B..|............
 21ae0 2bed4832 1170ac1e 5a724e6c 0efffbfd  +.H2.p..ZrNl....
 21af0 8538560f aed51e3d 2d392736 0fd9640a  .8V....=-9'6..d.
 21b00 5ca62168 5b54d19b 362e3a24 0a67b10c  \.!h[T..6.:$.g..
 21b10 57e70f93 ee96d2b4 9b919e1b c0c54f80  W.............O.
 21b20 dc20a261 774b695a 121a161c 93ba0ae2  . .awKiZ........
 21b30 a02ae5c0 22e0433c 1b171d12 090d0b0e  .*..".C<........
 21b40 8bc7adf2 b6a8b92d 1ea9c814 f1198557  .......-.......W
 21b50 75074caf 99ddbbee 7f60fda3 01269ff7  u.L......`...&..
 21b60 72f5bc5c 663bc544 fb7e345b 4329768b  r..\f;.D.~4[C)v.
 21b70 23c6dccb edfc68b6 e4f163b8 31dccad7  #.....h...c.1...
 21b80 63851042 97224013 c6112084 4a247d85  c..B."@... .J$}.
 21b90 bb3df8d2 f93211ae 29a16dc7 9e2f4b1d  .=...2..).m../K.
 21ba0 b230f3dc 8652ec0d c1e3d077 b3166c2b  .0...R.....w..l+
 21bb0 70b999a9 9448fa11 e9642247 fc8cc4a8  p....H...d"G....
 21bc0 f03f1aa0 7d2cd856 3390ef22 494ec787  .?..},.V3.."IN..
 21bd0 38d1c1d9 caa2fe8c d40b3698 f581cfa6  8.........6.....
 21be0 7ade28a5 b78e26da adbfa43f 3a9de42c  z.(...&....?:..,
 21bf0 78920d50 5fcc9b6a 7e466254 8d13c2f6  x..P_..j~FbT....
 21c00 d8b8e890 39f75e2e c3aff582 5d80be9f  ....9.^.....]...
 21c10 d0937c69 d52da96f 2512b3cf ac993bc8  ..|i.-.o%.....;.
 21c20 187da710 9c636ee8 3bbb7bdb 267809cd  .}...cn.;.{.&x..
 21c30 5918f46e 9ab701ec 4f9aa883 956e65e6  Y..n....O....ne.
 21c40 ffe67eaa bccf0821 15e8e6ef e79bd9ba  ..~....!........
 21c50 6f36ce4a 9f09d4ea b07cd629 a4b2af31  o6.J.....|.)...1
 21c60 3f23312a a59430c6 a266c035 4ebc3774  ?#1*..0..f.5N.7t
 21c70 82caa6fc 90d0b0e0 a7d81533 04984af1  ...........3..J.
 21c80 ecdaf741 cd500e7f 91f62f17 4dd68d76  ...A.P..../.M..v
 21c90 efb04d43 aa4d54cc 9604dfe4 d1b5e39e  ..MC.MT.........
 21ca0 6a881b4c 2c1fb8c1 65517f46 5eea049d  j..L,...eQ.F^...
 21cb0 8c355d01 877473fa 0b412efb 671d5ab3  .5]..ts..A..g.Z.
 21cc0 dbd25292 105633e9 d647136d d7618c9a  ..R..V3..G.m.a..
 21cd0 a10c7a37 f8148e59 133c89eb a927eece  ..z7...Y.<...'..
 21ce0 61c935b7 1ce5ede1 47b13c7a d2df599c  a.5.....G.<z..Y.
 21cf0 f2733f55 14ce7918 c737bf73 f7cdea53  .s?U..y..7.s...S
 21d00 fdaa5b5f 3d6f14df 44db8678 aff381ca  ..[_=o..D..x....
 21d10 68c43eb9 24342c38 a3405fc2 1dc37216  h.>.$4,8.@_...r.
 21d20 e2250cbc 3c498b28 0d9541ff a8017139  .%..<I.(..A...q9
 21d30 0cb3de08 b4e49cd8 56c19064 cb84617b  ........V..d..a{
 21d40 32b670d5 6c5c7448 b85742d0 01000000  2.p.l\tH.WB.....
 21d50 02000000 04000000 08000000 10000000  ................
 21d60 20000000 40000000 80000000 1b000000   ...@...........
 21d70 36000000 c66363a5 f87c7c84 ee777799  6....cc..||..ww.
 21d80 f67b7b8d fff2f20d d66b6bbd de6f6fb1  .{{......kk..oo.
 21d90 91c5c554 60303050 02010103 ce6767a9  ...T`00P.....gg.
 21da0 562b2b7d e7fefe19 b5d7d762 4dababe6  V++}.......bM...
 21db0 ec76769a 8fcaca45 1f82829d 89c9c940  .vv....E.......@
 21dc0 fa7d7d87 effafa15 b25959eb 8e4747c9  .}}......YY..GG.
 21dd0 fbf0f00b 41adadec b3d4d467 5fa2a2fd  ....A......g_...
 21de0 45afafea 239c9cbf 53a4a4f7 e4727296  E...#...S....rr.
 21df0 9bc0c05b 75b7b7c2 e1fdfd1c 3d9393ae  ...[u.......=...
 21e00 4c26266a 6c36365a 7e3f3f41 f5f7f702  L&&jl66Z~??A....
 21e10 83cccc4f 6834345c 51a5a5f4 d1e5e534  ...Oh44\Q......4
 21e20 f9f1f108 e2717193 abd8d873 62313153  .....qq....sb11S
 21e30 2a15153f 0804040c 95c7c752 46232365  *..?.......RF##e
 21e40 9dc3c35e 30181828 379696a1 0a05050f  ...^0..(7.......
 21e50 2f9a9ab5 0e070709 24121236 1b80809b  /.......$..6....
 21e60 dfe2e23d cdebeb26 4e272769 7fb2b2cd  ...=...&N''i....
 21e70 ea75759f 1209091b 1d83839e 582c2c74  .uu.........X,,t
 21e80 341a1a2e 361b1b2d dc6e6eb2 b45a5aee  4...6..-.nn..ZZ.
 21e90 5ba0a0fb a45252f6 763b3b4d b7d6d661  [....RR.v;;M...a
 21ea0 7db3b3ce 5229297b dde3e33e 5e2f2f71  }...R)){...>^//q
 21eb0 13848497 a65353f5 b9d1d168 00000000  .....SS....h....
 21ec0 c1eded2c 40202060 e3fcfc1f 79b1b1c8  ...,@  `....y...
 21ed0 b65b5bed d46a6abe 8dcbcb46 67bebed9  .[[..jj....Fg...
 21ee0 7239394b 944a4ade 984c4cd4 b05858e8  r99K.JJ..LL..XX.
 21ef0 85cfcf4a bbd0d06b c5efef2a 4faaaae5  ...J...k...*O...
 21f00 edfbfb16 864343c5 9a4d4dd7 66333355  .....CC..MM.f33U
 21f10 11858594 8a4545cf e9f9f910 04020206  .....EE.........
 21f20 fe7f7f81 a05050f0 783c3c44 259f9fba  .....PP.x<<D%...
 21f30 4ba8a8e3 a25151f3 5da3a3fe 804040c0  K....QQ.]....@@.
 21f40 058f8f8a 3f9292ad 219d9dbc 70383848  ....?...!...p88H
 21f50 f1f5f504 63bcbcdf 77b6b6c1 afdada75  ....c...w......u
 21f60 42212163 20101030 e5ffff1a fdf3f30e  B!!c ..0........
 21f70 bfd2d26d 81cdcd4c 180c0c14 26131335  ...m...L....&..5
 21f80 c3ecec2f be5f5fe1 359797a2 884444cc  .../.__.5....DD.
 21f90 2e171739 93c4c457 55a7a7f2 fc7e7e82  ...9...WU....~~.
 21fa0 7a3d3d47 c86464ac ba5d5de7 3219192b  z==G.dd..]].2..+
 21fb0 e6737395 c06060a0 19818198 9e4f4fd1  .ss..``......OO.
 21fc0 a3dcdc7f 44222266 542a2a7e 3b9090ab  ....D""fT**~;...
 21fd0 0b888883 8c4646ca c7eeee29 6bb8b8d3  .....FF....)k...
 21fe0 2814143c a7dede79 bc5e5ee2 160b0b1d  (..<...y.^^.....
 21ff0 addbdb76 dbe0e03b 64323256 743a3a4e  ...v...;d22Vt::N
 22000 140a0a1e 924949db 0c06060a 4824246c  .....II.....H$$l
 22010 b85c5ce4 9fc2c25d bdd3d36e 43acacef  .\\....]...nC...
 22020 c46262a6 399191a8 319595a4 d3e4e437  .bb.9...1......7
 22030 f279798b d5e7e732 8bc8c843 6e373759  .yy....2...Cn77Y
 22040 da6d6db7 018d8d8c b1d5d564 9c4e4ed2  .mm........d.NN.
 22050 49a9a9e0 d86c6cb4 ac5656fa f3f4f407  I....ll..VV.....
 22060 cfeaea25 ca6565af f47a7a8e 47aeaee9  ...%.ee..zz.G...
 22070 10080818 6fbabad5 f0787888 4a25256f  ....o....xx.J%%o
 22080 5c2e2e72 381c1c24 57a6a6f1 73b4b4c7  \..r8..$W...s...
 22090 97c6c651 cbe8e823 a1dddd7c e874749c  ...Q...#...|.tt.
 220a0 3e1f1f21 964b4bdd 61bdbddc 0d8b8b86  >..!.KK.a.......
 220b0 0f8a8a85 e0707090 7c3e3e42 71b5b5c4  .....pp.|>>Bq...
 220c0 cc6666aa 904848d8 06030305 f7f6f601  .ff..HH.........
 220d0 1c0e0e12 c26161a3 6a35355f ae5757f9  .....aa.j55_.WW.
 220e0 69b9b9d0 17868691 99c1c158 3a1d1d27  i..........X:..'
 220f0 279e9eb9 d9e1e138 ebf8f813 2b9898b3  '......8....+...
 22100 22111133 d26969bb a9d9d970 078e8e89  "..3.ii....p....
 22110 339494a7 2d9b9bb6 3c1e1e22 15878792  3...-...<.."....
 22120 c9e9e920 87cece49 aa5555ff 50282878  ... ...I.UU.P((x
 22130 a5dfdf7a 038c8c8f 59a1a1f8 09898980  ...z....Y.......
 22140 1a0d0d17 65bfbfda d7e6e631 844242c6  ....e......1.BB.
 22150 d06868b8 824141c3 299999b0 5a2d2d77  .hh..AA.)...Z--w
 22160 1e0f0f11 7bb0b0cb a85454fc 6dbbbbd6  ....{....TT.m...
 22170 2c16163a a5c66363 84f87c7c 99ee7777  ,..:..cc..||..ww
 22180 8df67b7b 0dfff2f2 bdd66b6b b1de6f6f  ..{{......kk..oo
 22190 5491c5c5 50603030 03020101 a9ce6767  T...P`00......gg
 221a0 7d562b2b 19e7fefe 62b5d7d7 e64dabab  }V++....b....M..
 221b0 9aec7676 458fcaca 9d1f8282 4089c9c9  ..vvE.......@...
 221c0 87fa7d7d 15effafa ebb25959 c98e4747  ..}}......YY..GG
 221d0 0bfbf0f0 ec41adad 67b3d4d4 fd5fa2a2  .....A..g...._..
 221e0 ea45afaf bf239c9c f753a4a4 96e47272  .E...#...S....rr
 221f0 5b9bc0c0 c275b7b7 1ce1fdfd ae3d9393  [....u.......=..
 22200 6a4c2626 5a6c3636 417e3f3f 02f5f7f7  jL&&Zl66A~??....
 22210 4f83cccc 5c683434 f451a5a5 34d1e5e5  O...\h44.Q..4...
 22220 08f9f1f1 93e27171 73abd8d8 53623131  ......qqs...Sb11
 22230 3f2a1515 0c080404 5295c7c7 65462323  ?*......R...eF##
 22240 5e9dc3c3 28301818 a1379696 0f0a0505  ^...(0...7......
 22250 b52f9a9a 090e0707 36241212 9b1b8080  ./......6$......
 22260 3ddfe2e2 26cdebeb 694e2727 cd7fb2b2  =...&...iN''....
 22270 9fea7575 1b120909 9e1d8383 74582c2c  ..uu........tX,,
 22280 2e341a1a 2d361b1b b2dc6e6e eeb45a5a  .4..-6....nn..ZZ
 22290 fb5ba0a0 f6a45252 4d763b3b 61b7d6d6  .[....RRMv;;a...
 222a0 ce7db3b3 7b522929 3edde3e3 715e2f2f  .}..{R))>...q^//
 222b0 97138484 f5a65353 68b9d1d1 00000000  ......SSh.......
 222c0 2cc1eded 60402020 1fe3fcfc c879b1b1  ,...`@  .....y..
 222d0 edb65b5b bed46a6a 468dcbcb d967bebe  ..[[..jjF....g..
 222e0 4b723939 de944a4a d4984c4c e8b05858  Kr99..JJ..LL..XX
 222f0 4a85cfcf 6bbbd0d0 2ac5efef e54faaaa  J...k...*....O..
 22300 16edfbfb c5864343 d79a4d4d 55663333  ......CC..MMUf33
 22310 94118585 cf8a4545 10e9f9f9 06040202  ......EE........
 22320 81fe7f7f f0a05050 44783c3c ba259f9f  ......PPDx<<.%..
 22330 e34ba8a8 f3a25151 fe5da3a3 c0804040  .K....QQ.]....@@
 22340 8a058f8f ad3f9292 bc219d9d 48703838  .....?...!..Hp88
 22350 04f1f5f5 df63bcbc c177b6b6 75afdada  .....c...w..u...
 22360 63422121 30201010 1ae5ffff 0efdf3f3  cB!!0 ..........
 22370 6dbfd2d2 4c81cdcd 14180c0c 35261313  m...L.......5&..
 22380 2fc3ecec e1be5f5f a2359797 cc884444  /.....__.5....DD
 22390 392e1717 5793c4c4 f255a7a7 82fc7e7e  9...W....U....~~
 223a0 477a3d3d acc86464 e7ba5d5d 2b321919  Gz==..dd..]]+2..
 223b0 95e67373 a0c06060 98198181 d19e4f4f  ..ss..``......OO
 223c0 7fa3dcdc 66442222 7e542a2a ab3b9090  ....fD""~T**.;..
 223d0 830b8888 ca8c4646 29c7eeee d36bb8b8  ......FF)....k..
 223e0 3c281414 79a7dede e2bc5e5e 1d160b0b  <(..y.....^^....
 223f0 76addbdb 3bdbe0e0 56643232 4e743a3a  v...;...Vd22Nt::
 22400 1e140a0a db924949 0a0c0606 6c482424  ......II....lH$$
 22410 e4b85c5c 5d9fc2c2 6ebdd3d3 ef43acac  ..\\]...n....C..
 22420 a6c46262 a8399191 a4319595 37d3e4e4  ..bb.9...1..7...
 22430 8bf27979 32d5e7e7 438bc8c8 596e3737  ..yy2...C...Yn77
 22440 b7da6d6d 8c018d8d 64b1d5d5 d29c4e4e  ..mm....d.....NN
 22450 e049a9a9 b4d86c6c faac5656 07f3f4f4  .I....ll..VV....
 22460 25cfeaea afca6565 8ef47a7a e947aeae  %.....ee..zz.G..
 22470 18100808 d56fbaba 88f07878 6f4a2525  .....o....xxoJ%%
 22480 725c2e2e 24381c1c f157a6a6 c773b4b4  r\..$8...W...s..
 22490 5197c6c6 23cbe8e8 7ca1dddd 9ce87474  Q...#...|.....tt
 224a0 213e1f1f dd964b4b dc61bdbd 860d8b8b  !>....KK.a......
 224b0 850f8a8a 90e07070 427c3e3e c471b5b5  ......ppB|>>.q..
 224c0 aacc6666 d8904848 05060303 01f7f6f6  ..ff..HH........
 224d0 121c0e0e a3c26161 5f6a3535 f9ae5757  ......aa_j55..WW
 224e0 d069b9b9 91178686 5899c1c1 273a1d1d  .i......X...':..
 224f0 b9279e9e 38d9e1e1 13ebf8f8 b32b9898  .'..8........+..
 22500 33221111 bbd26969 70a9d9d9 89078e8e  3"....iip.......
 22510 a7339494 b62d9b9b 223c1e1e 92158787  .3...-.."<......
 22520 20c9e9e9 4987cece ffaa5555 78502828   ...I.....UUxP((
 22530 7aa5dfdf 8f038c8c f859a1a1 80098989  z........Y......
 22540 171a0d0d da65bfbf 31d7e6e6 c6844242  .....e..1.....BB
 22550 b8d06868 c3824141 b0299999 775a2d2d  ..hh..AA.)..wZ--
 22560 111e0f0f cb7bb0b0 fca85454 d66dbbbb  .....{....TT.m..
 22570 3a2c1616 63a5c663 7c84f87c 7799ee77  :,..c..c|..|w..w
 22580 7b8df67b f20dfff2 6bbdd66b 6fb1de6f  {..{....k..ko..o
 22590 c55491c5 30506030 01030201 67a9ce67  .T..0P`0....g..g
 225a0 2b7d562b fe19e7fe d762b5d7 abe64dab  +}V+.....b....M.
 225b0 769aec76 ca458fca 829d1f82 c94089c9  v..v.E.......@..
 225c0 7d87fa7d fa15effa 59ebb259 47c98e47  }..}....Y..YG..G
 225d0 f00bfbf0 adec41ad d467b3d4 a2fd5fa2  ......A..g...._.
 225e0 afea45af 9cbf239c a4f753a4 7296e472  ..E...#...S.r..r
 225f0 c05b9bc0 b7c275b7 fd1ce1fd 93ae3d93  .[....u.......=.
 22600 266a4c26 365a6c36 3f417e3f f702f5f7  &jL&6Zl6?A~?....
 22610 cc4f83cc 345c6834 a5f451a5 e534d1e5  .O..4\h4..Q..4..
 22620 f108f9f1 7193e271 d873abd8 31536231  ....q..q.s..1Sb1
 22630 153f2a15 040c0804 c75295c7 23654623  .?*......R..#eF#
 22640 c35e9dc3 18283018 96a13796 050f0a05  .^...(0...7.....
 22650 9ab52f9a 07090e07 12362412 809b1b80  ../......6$.....
 22660 e23ddfe2 eb26cdeb 27694e27 b2cd7fb2  .=...&..'iN'....
 22670 759fea75 091b1209 839e1d83 2c74582c  u..u........,tX,
 22680 1a2e341a 1b2d361b 6eb2dc6e 5aeeb45a  ..4..-6.n..nZ..Z
 22690 a0fb5ba0 52f6a452 3b4d763b d661b7d6  ..[.R..R;Mv;.a..
 226a0 b3ce7db3 297b5229 e33edde3 2f715e2f  ..}.){R).>../q^/
 226b0 84971384 53f5a653 d168b9d1 00000000  ....S..S.h......
 226c0 ed2cc1ed 20604020 fc1fe3fc b1c879b1  .,.. `@ ......y.
 226d0 5bedb65b 6abed46a cb468dcb bed967be  [..[j..j.F....g.
 226e0 394b7239 4ade944a 4cd4984c 58e8b058  9Kr9J..JL..LX..X
 226f0 cf4a85cf d06bbbd0 ef2ac5ef aae54faa  .J...k...*....O.
 22700 fb16edfb 43c58643 4dd79a4d 33556633  ....C..CM..M3Uf3
 22710 85941185 45cf8a45 f910e9f9 02060402  ....E..E........
 22720 7f81fe7f 50f0a050 3c44783c 9fba259f  ....P..P<Dx<..%.
 22730 a8e34ba8 51f3a251 a3fe5da3 40c08040  ..K.Q..Q..].@..@
 22740 8f8a058f 92ad3f92 9dbc219d 38487038  ......?...!.8Hp8
 22750 f504f1f5 bcdf63bc b6c177b6 da75afda  ......c...w..u..
 22760 21634221 10302010 ff1ae5ff f30efdf3  !cB!.0 .........
 22770 d26dbfd2 cd4c81cd 0c14180c 13352613  .m...L.......5&.
 22780 ec2fc3ec 5fe1be5f 97a23597 44cc8844  ./.._.._..5.D..D
 22790 17392e17 c45793c4 a7f255a7 7e82fc7e  .9...W....U.~..~
 227a0 3d477a3d 64acc864 5de7ba5d 192b3219  =Gz=d..d]..].+2.
 227b0 7395e673 60a0c060 81981981 4fd19e4f  s..s`..`....O..O
 227c0 dc7fa3dc 22664422 2a7e542a 90ab3b90  ...."fD"*~T*..;.
 227d0 88830b88 46ca8c46 ee29c7ee b8d36bb8  ....F..F.)....k.
 227e0 143c2814 de79a7de 5ee2bc5e 0b1d160b  .<(..y..^..^....
 227f0 db76addb e03bdbe0 32566432 3a4e743a  .v...;..2Vd2:Nt:
 22800 0a1e140a 49db9249 060a0c06 246c4824  ....I..I....$lH$
 22810 5ce4b85c c25d9fc2 d36ebdd3 acef43ac  \..\.]...n....C.
 22820 62a6c462 91a83991 95a43195 e437d3e4  b..b..9...1..7..
 22830 798bf279 e732d5e7 c8438bc8 37596e37  y..y.2...C..7Yn7
 22840 6db7da6d 8d8c018d d564b1d5 4ed29c4e  m..m.....d..N..N
 22850 a9e049a9 6cb4d86c 56faac56 f407f3f4  ..I.l..lV..V....
 22860 ea25cfea 65afca65 7a8ef47a aee947ae  .%..e..ez..z..G.
 22870 08181008 bad56fba 7888f078 256f4a25  ......o.x..x%oJ%
 22880 2e725c2e 1c24381c a6f157a6 b4c773b4  .r\..$8...W...s.
 22890 c65197c6 e823cbe8 dd7ca1dd 749ce874  .Q...#...|..t..t
 228a0 1f213e1f 4bdd964b bddc61bd 8b860d8b  .!>.K..K..a.....
 228b0 8a850f8a 7090e070 3e427c3e b5c471b5  ....p..p>B|>..q.
 228c0 66aacc66 48d89048 03050603 f601f7f6  f..fH..H........
 228d0 0e121c0e 61a3c261 355f6a35 57f9ae57  ....a..a5_j5W..W
 228e0 b9d069b9 86911786 c15899c1 1d273a1d  ..i......X...':.
 228f0 9eb9279e e138d9e1 f813ebf8 98b32b98  ..'..8........+.
 22900 11332211 69bbd269 d970a9d9 8e89078e  .3".i..i.p......
 22910 94a73394 9bb62d9b 1e223c1e 87921587  ..3...-.."<.....
 22920 e920c9e9 ce4987ce 55ffaa55 28785028  . ...I..U..U(xP(
 22930 df7aa5df 8c8f038c a1f859a1 89800989  .z........Y.....
 22940 0d171a0d bfda65bf e631d7e6 42c68442  ......e..1..B..B
 22950 68b8d068 41c38241 99b02999 2d775a2d  h..hA..A..).-wZ-
 22960 0f111e0f b0cb7bb0 54fca854 bbd66dbb  ......{.T..T..m.
 22970 163a2c16 6363a5c6 7c7c84f8 777799ee  .:,.cc..||..ww..
 22980 7b7b8df6 f2f20dff 6b6bbdd6 6f6fb1de  {{......kk..oo..
 22990 c5c55491 30305060 01010302 6767a9ce  ..T.00P`....gg..
 229a0 2b2b7d56 fefe19e7 d7d762b5 ababe64d  ++}V......b....M
 229b0 76769aec caca458f 82829d1f c9c94089  vv....E.......@.
 229c0 7d7d87fa fafa15ef 5959ebb2 4747c98e  }}......YY..GG..
 229d0 f0f00bfb adadec41 d4d467b3 a2a2fd5f  .......A..g...._
 229e0 afafea45 9c9cbf23 a4a4f753 727296e4  ...E...#...Srr..
 229f0 c0c05b9b b7b7c275 fdfd1ce1 9393ae3d  ..[....u.......=
 22a00 26266a4c 36365a6c 3f3f417e f7f702f5  &&jL66Zl??A~....
 22a10 cccc4f83 34345c68 a5a5f451 e5e534d1  ..O.44\h...Q..4.
 22a20 f1f108f9 717193e2 d8d873ab 31315362  ....qq....s.11Sb
 22a30 15153f2a 04040c08 c7c75295 23236546  ..?*......R.##eF
 22a40 c3c35e9d 18182830 9696a137 05050f0a  ..^...(0...7....
 22a50 9a9ab52f 0707090e 12123624 80809b1b  .../......6$....
 22a60 e2e23ddf ebeb26cd 2727694e b2b2cd7f  ..=...&.''iN....
 22a70 75759fea 09091b12 83839e1d 2c2c7458  uu..........,,tX
 22a80 1a1a2e34 1b1b2d36 6e6eb2dc 5a5aeeb4  ...4..-6nn..ZZ..
 22a90 a0a0fb5b 5252f6a4 3b3b4d76 d6d661b7  ...[RR..;;Mv..a.
 22aa0 b3b3ce7d 29297b52 e3e33edd 2f2f715e  ...})){R..>.//q^
 22ab0 84849713 5353f5a6 d1d168b9 00000000  ....SS....h.....
 22ac0 eded2cc1 20206040 fcfc1fe3 b1b1c879  ..,.  `@.......y
 22ad0 5b5bedb6 6a6abed4 cbcb468d bebed967  [[..jj....F....g
 22ae0 39394b72 4a4ade94 4c4cd498 5858e8b0  99KrJJ..LL..XX..
 22af0 cfcf4a85 d0d06bbb efef2ac5 aaaae54f  ..J...k...*....O
 22b00 fbfb16ed 4343c586 4d4dd79a 33335566  ....CC..MM..33Uf
 22b10 85859411 4545cf8a f9f910e9 02020604  ....EE..........
 22b20 7f7f81fe 5050f0a0 3c3c4478 9f9fba25  ....PP..<<Dx...%
 22b30 a8a8e34b 5151f3a2 a3a3fe5d 4040c080  ...KQQ.....]@@..
 22b40 8f8f8a05 9292ad3f 9d9dbc21 38384870  .......?...!88Hp
 22b50 f5f504f1 bcbcdf63 b6b6c177 dada75af  .......c...w..u.
 22b60 21216342 10103020 ffff1ae5 f3f30efd  !!cB..0 ........
 22b70 d2d26dbf cdcd4c81 0c0c1418 13133526  ..m...L.......5&
 22b80 ecec2fc3 5f5fe1be 9797a235 4444cc88  ../.__.....5DD..
 22b90 1717392e c4c45793 a7a7f255 7e7e82fc  ..9...W....U~~..
 22ba0 3d3d477a 6464acc8 5d5de7ba 19192b32  ==Gzdd..]]....+2
 22bb0 737395e6 6060a0c0 81819819 4f4fd19e  ss..``......OO..
 22bc0 dcdc7fa3 22226644 2a2a7e54 9090ab3b  ....""fD**~T...;
 22bd0 8888830b 4646ca8c eeee29c7 b8b8d36b  ....FF....)....k
 22be0 14143c28 dede79a7 5e5ee2bc 0b0b1d16  ..<(..y.^^......
 22bf0 dbdb76ad e0e03bdb 32325664 3a3a4e74  ..v...;.22Vd::Nt
 22c00 0a0a1e14 4949db92 06060a0c 24246c48  ....II......$$lH
 22c10 5c5ce4b8 c2c25d9f d3d36ebd acacef43  \\....]...n....C
 22c20 6262a6c4 9191a839 9595a431 e4e437d3  bb.....9...1..7.
 22c30 79798bf2 e7e732d5 c8c8438b 3737596e  yy....2...C.77Yn
 22c40 6d6db7da 8d8d8c01 d5d564b1 4e4ed29c  mm........d.NN..
 22c50 a9a9e049 6c6cb4d8 5656faac f4f407f3  ...Ill..VV......
 22c60 eaea25cf 6565afca 7a7a8ef4 aeaee947  ..%.ee..zz.....G
 22c70 08081810 babad56f 787888f0 25256f4a  .......oxx..%%oJ
 22c80 2e2e725c 1c1c2438 a6a6f157 b4b4c773  ..r\..$8...W...s
 22c90 c6c65197 e8e823cb dddd7ca1 74749ce8  ..Q...#...|.tt..
 22ca0 1f1f213e 4b4bdd96 bdbddc61 8b8b860d  ..!>KK.....a....
 22cb0 8a8a850f 707090e0 3e3e427c b5b5c471  ....pp..>>B|...q
 22cc0 6666aacc 4848d890 03030506 f6f601f7  ff..HH..........
 22cd0 0e0e121c 6161a3c2 35355f6a 5757f9ae  ....aa..55_jWW..
 22ce0 b9b9d069 86869117 c1c15899 1d1d273a  ...i......X...':
 22cf0 9e9eb927 e1e138d9 f8f813eb 9898b32b  ...'..8........+
 22d00 11113322 6969bbd2 d9d970a9 8e8e8907  ..3"ii....p.....
 22d10 9494a733 9b9bb62d 1e1e223c 87879215  ...3...-.."<....
 22d20 e9e920c9 cece4987 5555ffaa 28287850  .. ...I.UU..((xP
 22d30 dfdf7aa5 8c8c8f03 a1a1f859 89898009  ..z........Y....
 22d40 0d0d171a bfbfda65 e6e631d7 4242c684  .......e..1.BB..
 22d50 6868b8d0 4141c382 9999b029 2d2d775a  hh..AA.....)--wZ
 22d60 0f0f111e b0b0cb7b 5454fca8 bbbbd66d  .......{TT.....m
 22d70 16163a2c 52096ad5 3036a538 bf40a39e  ..:,R.j.06.8.@..
 22d80 81f3d7fb 7ce33982 9b2fff87 348e4344  ....|.9../..4.CD
 22d90 c4dee9cb 547b9432 a6c2233d ee4c950b  ....T{.2..#=.L..
 22da0 42fac34e 082ea166 28d924b2 765ba249  B..N...f(.$.v[.I
 22db0 6d8bd125 72f8f664 86689816 d4a45ccc  m..%r..d.h....\.
 22dc0 5d65b692 6c704850 fdedb9da 5e154657  ]e..lpHP....^.FW
 22dd0 a78d9d84 90d8ab00 8cbcd30a f7e45805  ..............X.
 22de0 b8b34506 d02c1e8f ca3f0f02 c1afbd03  ..E..,...?......
 22df0 01138a6b 3a911141 4f67dcea 97f2cfce  ...k:..AOg......
 22e00 f0b4e673 96ac7422 e7ad3585 e2f937e8  ...s..t"..5...7.
 22e10 1c75df6e 47f11a71 1d29c589 6fb7620e  .u.nG..q.)..o.b.
 22e20 aa18be1b fc563e4b c6d27920 9adbc0fe  .....V>K..y ....
 22e30 78cd5af4 1fdda833 8807c731 b1121059  x.Z....3...1...Y
 22e40 2780ec5f 60517fa9 19b54a0d 2de57a9f  '.._`Q....J.-.z.
 22e50 93c99cef a0e03b4d ae2af5b0 c8ebbb3c  ......;M.*.....<
 22e60 83539961 172b047e ba77d626 e1691463  .S.a.+.~.w.&.i.c
 22e70 55210c7d 06080507 43000000           U!.}....C...    

/Users/briangiori/dev/newt/blegpio/bin/blegpio/apps/blegpio/blegpio.elf:     file format elf32-littlearm


/Users/briangiori/dev/newt/blegpio/bin/blegpio/apps/blegpio/blegpio.elf:     file format elf32-littlearm

Contents of section .data:
 200000d8 59aed409 3447fb34 9b5f8000 00800010  Y...4G.4._......
 200000e8 0000472a 0000fb34 9b5f8000 00800010  ..G*...4._......
 200000f8 0000482a 00000000 9dee0100 7d880000  ..H*........}...
 20000108 00000000 00000000 0a000000 00000000  ................
 20000118 36f00100 15870000 00000000 00000000  6...............
 20000128 10000000 f01d0020 00000000 00000000  ....... ........
 20000138 00000000 00000000 00000000 00000000  ................
 20000148 fb349b5f 80000080 00100000 11180000  .4._............
 20000158 fb349b5f 80000080 00100000 452a0000  .4._........E*..
 20000168 fb349b5f 80000080 00100000 462a0000  .4._........F*..
 20000178 fb349b5f 80000080 00100000 442a0000  .4._........D*..
 20000188 de000020 c9890000 00000000 00000000  ... ............
 20000198 02000000 00000000 68010020 c9890000  ........h.. ....
 200001a8 00000000 00000000 10000000 00000000  ................
 200001b8 ee000020 c9890000 00000000 00000000  ... ............
 200001c8 02000000 00000000 58010020 c9890000  ........X.. ....
 200001d8 00000000 00000000 10000000 00000000  ................
 200001e8 78010020 c9890000 00000000 00000000  x.. ............
 200001f8 08000000 00000000 00000000 00000000  ................
 20000208 00000000 00000000 00000000 00000000  ................
 20000218 0090d003 00000000 1c020020 00000000  ........... ....
 20000228 24020020 00000000 2c020020 00000000  $.. ....,.. ....
 20000238 34020020 00110000 00000000 00000000  4.. ............
 20000248 fb349b5f 80000080 00100000 00000000  .4._............
 20000258 fb349b5f 80000080 00100000 00180000  .4._............
 20000268 6e696d62 6c650000 00000000 00000000  nimble..........
 20000278 00000000 00000000 00000000 00000000  ................
 20000288 fb349b5f 80000080 00100000 012a0000  .4._.........*..
 20000298 fb349b5f 80000080 00100000 022a0000  .4._.........*..
 200002a8 fb349b5f 80000080 00100000 032a0000  .4._.........*..
 200002b8 fb349b5f 80000080 00100000 042a0000  .4._.........*..
 200002c8 58030020 15cb0100 00000000 00000000  X.. ............
 200002d8 02000000 00000000 88020020 15cb0100  ........... ....
 200002e8 00000000 00000000 02000000 00000000  ................
 200002f8 98020020 15cb0100 00000000 00000000  ... ............
 20000308 02000000 00000000 a8020020 15cb0100  ........... ....
 20000318 00000000 00000000 08000000 00000000  ................
 20000328 b8020020 15cb0100 00000000 00000000  ... ............
 20000338 02000000 00000000 00000000 00000000  ................
 20000348 00000000 00000000 00000000 00000000  ................
 20000358 fb349b5f 80000080 00100000 002a0000  .4._.........*..
 20000368 fb349b5f 80000080 00100000 01180000  .4._............
 20000378 fb349b5f 80000080 00100000 052a0000  .4._.........*..
 20000388 78030020 39cc0100 00000000 00000000  x.. 9...........
 20000398 20000000 00000000 00000000 00000000   ...............
 200003a8 00000000 00000000 00000000 00000000  ................
 200003b8 00000000 b8030020 00000000 c0030020  ....... ....... 
 200003c8 00000000 00000000 00800000 00000000  ................
 200003d8 00800000 00a00300 00000000 00200400  ............. ..
 200003e8 00a00300 00000000 00c00700 00100000  ................
 200003f8 00000000 00d00700 00300000 143e0020  .........0...>. 
 20000408 02000000 00000000 08040020 08040020  ........... ... 
 20000418 08040020 08040020 61d90100 5dd90100  ... ... a...]...
 20000428 00000000 14070020 7c070020 e4070020  ....... |.. ... 
 20000438 00000000 00000000 00000000 00000000  ................
 20000448 00000000 00000000 00000000 00000000  ................
 20000458 00000000 782e0200 00000000 00000000  ....x...........
 20000468 00000000 00000000 00000000 00000000  ................
 20000478 00000000 00000000 00000000 00000000  ................
 20000488 00000000 00000000 00000000 00000000  ................
 20000498 00000000 00000000 00000000 00000000  ................
 200004a8 00000000 00000000 00000000 00000000  ................
 200004b8 00000000 00000000 00000000 00000000  ................
 200004c8 00000000 00000000 01000000 00000000  ................
 200004d8 0e33cdab 34126de6 ecde0500 0b000000  .3..4.m.........
 200004e8 00000000 00000000 00000000 00000000  ................
 200004f8 00000000 00000000 00000000 00000000  ................
 20000508 00000000 00000000 00000000 00000000  ................
 20000518 00000000 00000000 00000000 00000000  ................
 20000528 00000000 00000000 00000000 00000000  ................
 20000538 00000000 00000000 00000000 00000000  ................
 20000548 00000000 00000000 00000000 00000000  ................
 20000558 00000000 00000000 00000000 00000000  ................
 20000568 00000000 00000000 00000000 00000000  ................
 20000578 00000000 00000000 00000000 00000000  ................
 20000588 00000000 00000000 00000000 00000000  ................
 20000598 00000000 00000000 00000000 00000000  ................
 200005a8 00000000 00000000 00000000 00000000  ................
 200005b8 00000000 00000000 00000000 00000000  ................
 200005c8 00000000 00000000 00000000 00000000  ................
 200005d8 00000000 00000000 00000000 00000000  ................
 200005e8 00000000 00000000 00000000 00000000  ................
 200005f8 00000000 00000000 00000000 00000000  ................
 20000608 00000000 00000000 00000000 00000000  ................
 20000618 00000000 00000000 00000000 00000000  ................
 20000628 00000000 00000000 00000000 00000000  ................
 20000638 00000000 00000000 00000000 00000000  ................
 20000648 00000000 00000000 00000000 00000000  ................
 20000658 00000000 00000000 00000000 00000000  ................
 20000668 00000000 00000000 00000000 00000000  ................
 20000678 00000000 00000000 00000000 00000000  ................
 20000688 00000000 00000000 00000000 00000000  ................
 20000698 00000000 00000000 00000000 00000000  ................
 200006a8 00000000 00000000 00000000 00000000  ................
 200006b8 00000000 00000000 00000000 00000000  ................
 200006c8 00000000 00000000 00000000 00000000  ................
 200006d8 00000000 00000000 00000000 00000000  ................
 200006e8 00000000 00000000 00000000 00000000  ................
 200006f8 00000000 00000000 00000000 00000000  ................
 20000708 00000000 00000000 00000000 00000000  ................
 20000718 00000000 00000000 00000000 00000000  ................
 20000728 00000000 00000000 00000000 00000000  ................
 20000738 00000000 00000000 00000000 00000000  ................
 20000748 00000000 00000000 00000000 00000000  ................
 20000758 00000000 00000000 00000000 00000000  ................
 20000768 00000000 00000000 00000000 00000000  ................
 20000778 00000000 00000000 00000000 00000000  ................
 20000788 00000000 00000000 00000000 00000000  ................
 20000798 00000000 00000000 00000000 00000000  ................
 200007a8 00000000 00000000 00000000 00000000  ................
 200007b8 00000000 00000000 00000000 00000000  ................
 200007c8 00000000 00000000 00000000 00000000  ................
 200007d8 00000000 00000000 00000000 00000000  ................
 200007e8 00000000 00000000 00000000 00000000  ................
 200007f8 00000000 00000000 00000000 00000000  ................
 20000808 00000000 00000000 00000000 00000000  ................
 20000818 00000000 00000000 00000000 00000000  ................
 20000828 00000000 00000000 00000000 00000000  ................
 20000838 00000000 00000000 00000000 00000000  ................
 20000848 00000000 00000000 28040020           ........(..     
   text	   data	    bss	    dec	    hex	filename
 110196	   1916	  14008	 126120	  1eca8	/Users/briangiori/dev/newt/blegpio/bin/blegpio/apps/blegpio/blegpio.elf
