
/Users/briangiori/dev/newt/blegpio/bin/nrf52_boot/apps/boot/boot.elf:     file format elf32-littlearm
/Users/briangiori/dev/newt/blegpio/bin/nrf52_boot/apps/boot/boot.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000033f9

Program Header:
0x70000001 off    0x0000e76c vaddr 0x0000676c paddr 0x0000676c align 2**2
         filesz 0x00000018 memsz 0x00000018 flags r--
    LOAD off    0x00008000 vaddr 0x00000000 paddr 0x00000000 align 2**15
         filesz 0x00006784 memsz 0x00006784 flags r-x
    LOAD off    0x000100d8 vaddr 0x200000d8 paddr 0x00006784 align 2**15
         filesz 0x000004f4 memsz 0x000004f4 flags rw-
    LOAD off    0x000105d0 vaddr 0x200005d0 paddr 0x00006c80 align 2**15
         filesz 0x00000000 memsz 0x00000a08 flags rw-
    LOAD off    0x00018000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x000000d8 flags rw-
private flags = 5000202: [Version5 EABI] [soft-float ABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .text         0000676c  00000000  00000000  00008000  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.extab    00000000  0000676c  0000676c  000105cc  2**0  CONTENTS
  2 .ARM.exidx    00000018  0000676c  0000676c  0000e76c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .vector_relocation 000000d8  20000000  20000000  00018000  2**0  ALLOC
  4 .data         000004f4  200000d8  00006784  000100d8  2**3  CONTENTS, ALLOC, LOAD, DATA
  5 .bssnz        00000000  200005cc  200005cc  000105cc  2**0  CONTENTS
  6 .bss          00000a08  200005d0  00006c80  000105d0  2**3  ALLOC
  7 .stack_dummy  000001b0  20000fd8  20000fd8  000105d0  2**3  CONTENTS, READONLY
  8 .ARM.attributes 0000002a  00000000  00000000  00010780  2**0  CONTENTS, READONLY
  9 .comment      00000070  00000000  00000000  000107aa  2**0  CONTENTS, READONLY
 10 .svc_table    00000004  00000000  00000000  0001081a  2**0  CONTENTS, READONLY
 11 .debug_info   000202a8  00000000  00000000  0001081e  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000875c  00000000  00000000  00030ac6  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000ef0f  00000000  00000000  00039222  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000013a0  00000000  00000000  00048138  2**3  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001450  00000000  00000000  000494d8  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000cc3b  00000000  00000000  0004a928  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00005048  00000000  00000000  00057563  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_frame  00002db4  00000000  00000000  0005c5ac  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
0000676c l    d  .ARM.extab	00000000 .ARM.extab
0000676c l    d  .ARM.exidx	00000000 .ARM.exidx
20000000 l    d  .vector_relocation	00000000 .vector_relocation
200000d8 l    d  .data	00000000 .data
200005cc l    d  .bssnz	00000000 .bssnz
200005d0 l    d  .bss	00000000 .bss
20000fd8 l    d  .stack_dummy	00000000 .stack_dummy
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .svc_table	00000000 .svc_table
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 gcc_startup_nrf52.o
000001b0 l       *ABS*	00000000 Stack_Size
00000000 l       *ABS*	00000000 Heap_Size
00000000 l    df *ABS*	00000000 /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/../lib/gcc/arm-none-eabi/4.9.3/../../../../arm-none-eabi/lib/armv7e-m/crt0.o
00000000 l    df *ABS*	00000000 boot.c
200000d8 l     O .data	00000014 my_conf
00000000 l    df *ABS*	00000000 nffs.c
00000274 l     F .text	00000028 nffs_lock
0000029c l     F .text	00000024 nffs_unlock
000002c0 l     F .text	00000012 nffs_getpos
000002d2 l     F .text	00000018 nffs_closedir
000002ea l     F .text	0000001c nffs_readdir
00000306 l     F .text	00000026 nffs_opendir
0000032c l     F .text	00000024 nffs_mkdir
00000350 l     F .text	00000026 nffs_rename
00000376 l     F .text	00000022 nffs_unlink
00000398 l     F .text	0000001c nffs_file_len
000003b4 l     F .text	0000001c nffs_seek
000003d0 l     F .text	0000002a nffs_write
000003fa l     F .text	00000024 nffs_read
0000041e l     F .text	0000001a nffs_close
00000438 l     F .text	00000038 nffs_open
00000470 l     F .text	00000030 nffs_dirent_is_dir
000004a0 l     F .text	0000003c nffs_dirent_name
200005d0 l     O .bss	0000000c nffs_mutex
200005dc l     O .bss	0000001c nffs_log_console_handler
000061c4 l     O .text	00000040 nffs_ops
00000000 l    df *ABS*	00000000 nffs_cache.c
000005f4 l     F .text	00000028 nffs_cache_inode_free_blocks
0000061c l     F .text	0000001c nffs_cache_inode_free
00000638 l     F .text	00000028 nffs_cache_inode_alloc
00000660 l     F .text	0000001c nffs_cache_block_alloc
0000067c l     F .text	00000048 nffs_cache_block_acquire
200000ec l     O .data	00000008 nffs_cache_inode_list
00000000 l    df *ABS*	00000000 nffs_config.c
00000000 l    df *ABS*	00000000 nffs_dir.c
00000000 l    df *ABS*	00000000 nffs_file.c
00000000 l    df *ABS*	00000000 nffs_flash.c
00000000 l    df *ABS*	00000000 nffs_format.c
00000000 l    df *ABS*	00000000 nffs_hash.c
00000e6c l     F .text	00000034 nffs_hash_find_reorder
00000000 l    df *ABS*	00000000 nffs_inode.c
000010a0 l     F .text	00000048 nffs_inode_read_filename_chunk
00001134 l     F .text	000000a8 nffs_inode_dec_refcnt_priv
000013d4 l     F .text	000000a4 nffs_inode_unlink_from_ram_priv
200005f8 l     O .bss	00000004 nffs_inode_unlink_list
00000000 l    df *ABS*	00000000 nffs_misc.c
200005fc l     O .bss	00000001 total_gc_cycles.7305
00000000 l    df *ABS*	00000000 nffs_path.c
00001d30 l     F .text	0000003e nffs_path_find_child.isra.0
00000000 l    df *ABS*	00000000 nffs_restore.c
00001f66 l     F .text	00000038 nffs_restore_dummy_inode
00001fa0 l     F .text	00000460 nffs_restore_area_contents
200005fe l     O .bss	00000002 nffs_restore_largest_block_data_len
00000000 l    df *ABS*	00000000 nffs_write.c
00000000 l    df *ABS*	00000000 nffs_area.c
00000000 l    df *ABS*	00000000 nffs_block.c
00000000 l    df *ABS*	00000000 nffs_crc.c
00000000 l    df *ABS*	00000000 nffs_gc.c
00002f9c l     F .text	00000048 nffs_gc_copy_object.isra.0
00002fe4 l     F .text	00000050 nffs_gc_block_chain_copy
00003034 l     F .text	0000016c nffs_gc_block_chain
00000000 l    df *ABS*	00000000 system_nrf52.c
00000000 l    df *ABS*	00000000 flash_map.c
20000600 l     O .bss	00000004 flash_map
20000604 l     O .bss	00000004 flash_map_entries
00000000 l    df *ABS*	00000000 hal_flash.c
000036a4 l     F .text	0000001c hal_flash_check_addr
00000000 l    df *ABS*	00000000 hal_system_start.c
00000000 l    df *ABS*	00000000 inline.c
00000000 l    df *ABS*	00000000 malloc.c
000037ec l     F .text	00000004 malloc_lock_nop
000037f0 l     F .text	00000002 malloc_unlock_nop
000037f4 l     F .text	00000060 __free_block
200000f8 l     O .data	00000018 __malloc_head
20000110 l     O .data	00000004 malloc_unlock
20000114 l     O .data	00000004 malloc_lock
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 bootutil_misc.c
000039d0 l     F .text	00000060 boot_conf_set
20000118 l     O .data	00000018 boot_conf_handler
20000608 l     O .bss	00000008 boot_main
20000610 l     O .bss	00000008 boot_test
00000000 l    df *ABS*	00000000 loader.c
00003ba4 l     F .text	00000030 boot_find_image_slot
00003bd4 l     F .text	00000044 boot_image_check
00003c18 l     F .text	00000024 boot_erase_area
00003c3c l     F .text	00000074 boot_copy_area
00003cb0 l     F .text	00000168 boot_copy_image
20000618 l     O .bss	00000004 tmpbuf.4443
2000061c l     O .bss	00000004 scratch_sz.4451
20000620 l     O .bss	00000008 boot_state
20000628 l     O .bss	00000004 boot_req
2000062c l     O .bss	00000400 buf.4476
00000000 l    df *ABS*	00000000 image_validate.c
00000000 l    df *ABS*	00000000 cmsis_nvic.c
00000000 l    df *ABS*	00000000 sha256.c
00004814 l     F .text	00000080 mbedtls_sha256_update.part.0
00006361 l     O .text	00000040 sha256_padding
000063a4 l     O .text	00000100 K
00000000 l    df *ABS*	00000000 os.c
00000000 l    df *ABS*	00000000 os_arch_arm.c
00000000 l    df *ABS*	00000000 os_callout.c
00000000 l    df *ABS*	00000000 os_eventq.c
00000000 l    df *ABS*	00000000 os_fault.c
00000000 l    df *ABS*	00000000 os_heap.c
00004c88 l     F .text	00000030 os_malloc_lock
00004cb8 l     F .text	0000002c os_malloc_unlock
20000a30 l     O .bss	0000000c os_malloc_mutex
00000000 l    df *ABS*	00000000 os_mempool.c
00000000 l    df *ABS*	00000000 os_mutex.c
00000000 l    df *ABS*	00000000 os_sched.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00005294 l     F .text	00000044 os_deltatime
20000a40 l     O .bss	00000030 basetod
00000000 l    df *ABS*	00000000 HAL_CM4.S
00005392 l       .text	00000000 SVC_User
000053b0 l       .text	00000000 SVC_Done
00000000 l    df *ABS*	00000000 os_sanity.c
00005420 l     F .text	0000001c os_sanity_check_list_lock
0000543c l     F .text	00000018 os_sanity_check_list_unlock
00000000 l    df *ABS*	00000000 crc16.c
000064e6 l     O .text	00000200 crc16tab
00000000 l    df *ABS*	00000000 config.c
00005520 l     F .text	00000018 conf_parse_and_lookup
20000a74 l     O .bss	00000001 conf_cmd_inited
00000000 l    df *ABS*	00000000 config_file.c
00005686 l     F .text	00000060 conf_file_load
000057ec l     F .text	00000070 conf_file_save
20000148 l     O .data	00000010 conf_file_itf
00000000 l    df *ABS*	00000000 config_line.c
00000000 l    df *ABS*	00000000 config_store.c
00005932 l     F .text	00000004 conf_load_cb
00005936 l     F .text	00000032 conf_dup_check_cb
00000000 l    df *ABS*	00000000 log.c
20000a80 l     O .bss	00000001 log_inited
20000158 l     O .data	00000008 g_log_list
00000000 l    df *ABS*	00000000 log_console.c
00005a3c l     F .text	00000004 log_console_append
00005a40 l     F .text	00000004 log_console_read
00005a44 l     F .text	00000004 log_console_walk
00005a48 l     F .text	00000004 log_console_flush
00000000 l    df *ABS*	00000000 fs_file.c
00000000 l    df *ABS*	00000000 fs_mkdir.c
00000000 l    df *ABS*	00000000 fs_mount.c
00000000 l    df *ABS*	00000000 fsutil.c
00000000 l    df *ABS*	00000000 hal_bsp.c
00000000 l    df *ABS*	00000000 libc_stubs.c
00000000 l    df *ABS*	00000000 os_bsp.c
20000160 l     O .data	0000003c bsp_flash_areas
00000000 l    df *ABS*	00000000 sbrk.c
2000019c l     O .data	00000004 brk
00000000 l    df *ABS*	00000000 hal_flash.c
00005bc0 l     F .text	00000024 nrf52k_flash_wait_ready
00005be4 l     F .text	00000058 nrf52k_flash_erase_sector
00005c3c l     F .text	00000004 nrf52k_flash_init
00005c40 l     F .text	000000c8 nrf52k_flash_write
00005d08 l     F .text	00000010 nrf52k_flash_read
00005d18 l     F .text	00000024 nrf52k_flash_sector_info
00006704 l     O .text	00000014 nrf52k_flash_funcs
00000000 l    df *ABS*	00000000 hal_os_tick.c
00005d3c l     F .text	00000014 nrf52_os_tick_counter.part.0
00005d50 l     F .text	00000038 sub24
00005d88 l     F .text	00000050 nrf52_os_tick_set_ocmp
00005dd8 l     F .text	00000058 nrf52_timer_handler
00000000 l    df *ABS*	00000000 hal_system.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 realloc.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtok_r.c
00000000 l    df *ABS*	00000000 strsep.c
00000000 l    df *ABS*	00000000 strpbrk.c
00000000 l    df *ABS*	00000000 base64.c
00006726 l     O .text	00000041 base64_chars
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/../lib/gcc/arm-none-eabi/4.9.3/armv7e-m/crti.o
00000000 l    df *ABS*	00000000 /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/../lib/gcc/arm-none-eabi/4.9.3/armv7e-m/crtn.o
00000000 l    df *ABS*	00000000 impure.c
200001a0 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 SVC_Table.S
00000000 l       .svc_table	00000000 SVC_End
00000000 l    df *ABS*	00000000 
00006784 l       .ARM.exidx	00000000 __exidx_end
0000676c l       .text	00000000 __exidx_start
00000000 l       *UND*	00000000 _ram_start
00000000 l       *UND*	00000000 __deregister_frame_info
200005cc l       .data	00000000 __init_array_end
200005cc l       .data	00000000 __preinit_array_end
200005cc l       .data	00000000 __init_array_start
00000000 l       *UND*	00000000 _Jv_RegisterClasses
200005cc l       .data	00000000 __preinit_array_start
00000000 l       *UND*	00000000 __register_frame_info
00000c78 g     F .text	00000024 nffs_file_close
20000fd8 g       .bss	00000000 __HeapBase
20000e58 g     O .bss	00000008 g_os_task_list
000049a0 g     F .text	0000004c os_idle_task
00000ebc g     F .text	00000006 nffs_hash_id_is_inode
0000398e g     F .text	00000010 strcpy
00000000 g       .svc_table	00000000 SVC_Count
20000a88 g     O .bss	0000001c nffs_cache_inode_pool
20000aa4 g     O .bss	00000001 nffs_scratch_area_idx
00003438  w    F .text	00000002 TIMER2_IRQHandler
20000130 g     O .data	00000008 g_os_mempool_list
00001712 g     F .text	00000032 nffs_inode_read_filename
00003438  w    F .text	00000002 RTC0_IRQHandler
00003e18 g     F .text	00000164 boot_go
00003854 g     F .text	00000050 add_malloc_block
00005b14 g     F .text	0000002a fsutil_write_file
00004bf8 g     F .text	00000054 os_eventq_put
20000aa8 g     O .bss	00000004 nffs_cache_inode_mem
200000d8 g       .data	00000000 __data_start__
00005f56 g     F .text	0000001c strtok_r
000066f0 g     O .text	00000014 nrf52k_flash_dev
0000408c g     F .text	00000014 NVIC_SetVector
00005ab0 g     F .text	0000000c fs_seek
00003438  w    F .text	00000002 SWI0_EGU0_IRQHandler
00002d90 g     F .text	0000002e nffs_block_read_data
0000128c g     F .text	0000001a nffs_inode_data_len
00004adc g     F .text	0000009c os_arch_os_init
0000342a  w    F .text	00000002 HardFault_Handler
000006c4 g     F .text	0000001c nffs_cache_inode_range
000019e2 g     F .text	0000000c nffs_inode_unsetflags
00003438  w    F .text	00000002 SWI2_EGU2_IRQHandler
000053e0 g     F .text	0000000c SysTick_Handler
00003438  w    F .text	00000002 GPIOTE_IRQHandler
00002c40 g     F .text	0000002c nffs_block_entry_free
00004dc0 g     F .text	00000052 os_memblock_put
00003438  w    F .text	00000002 PWM1_IRQHandler
00005990 g     F .text	0000000c conf_dst_register
000037dc g     F .text	0000000a system_start
00003ab4 g     F .text	00000044 boot_vect_write_main
000012a6 g     F .text	0000000e nffs_inode_parent_id
000053b6 g     F .text	0000002a PendSV_Handler
20000e68 g     O .bss	00000004 g_os_sanity_num_secs
00003428  w    F .text	00000002 NMI_Handler
000012dc g     F .text	00000088 nffs_inode_delete_from_disk
000040a0 g     F .text	00000008 mbedtls_sha256_init
00000000 g       .text	00000000 __isr_vector_start
00005a10 g     F .text	00000014 log_init
00004a5c g     F .text	00000014 os_arch_ctx_sw
000049ec g     F .text	00000038 os_init_idle_task
20000148 g       .data	00000000 __aeabi_unwind_cpp_pr0
20000aac g     O .bss	0000001c nffs_dir_pool
00005ea8 g     F .text	00000010 system_debugger_connected
00003438  w    F .text	00000002 POWER_CLOCK_IRQHandler
00006134 g     F .text	0000000c __errno
00006784 g       .ARM.exidx	00000000 __etext
00002b54 g     F .text	00000016 nffs_area_is_scratch
000033b8 g     F .text	00000040 nffs_gc_until
00002400 g     F .text	000001e8 nffs_restore_sweep
00001644 g     F .text	00000034 nffs_inode_is_dummy
00003438  w    F .text	00000002 RADIO_IRQHandler
00003b98 g     F .text	0000000c boot_clear_status
00000ef8 g     F .text	00000024 nffs_hash_find_inode
00004e28 g     F .text	00000090 os_mutex_release
20000c9c g     O .bss	00000004 nffs_hash_next_dir_id
00005464 g     F .text	00000020 os_sanity_check_register
200005cc g       .bssnz	00000000 __bssnz_start__
20000a7c g     O .bss	00000004 conf_load_srcs
00001678 g     F .text	0000009a nffs_inode_from_entry
00002dbe g     F .text	00000014 nffs_block_is_dummy
00003438  w    F .text	00000002 PDM_IRQHandler
00005484 g     F .text	00000028 crc16_ccitt
00000d88 g     F .text	00000020 nffs_flash_loc
0000489c g     F .text	00000104 mbedtls_sha256_finish
00003438  w    F .text	00000002 TEMP_IRQHandler
00004a82 g     F .text	0000000a os_arch_in_critical
00002f32 g     F .text	00000016 nffs_crc_disk_block_fill
00003438  w    F .text	00000002 QDEC_IRQHandler
00005b5c g     F .text	00000020 bsp_init
00002bbc g     F .text	00000068 nffs_area_find_corrupt_scratch
00003438  w    F .text	00000002 TIMER3_IRQHandler
00002b74 g     F .text	00000040 nffs_area_to_disk
00004a54 g     F .text	00000006 timer_handler
00002c6c g     F .text	0000001a nffs_block_entry_reserve
00005050 g     F .text	00000074 os_sched_sleep
00005ed4 g     F .text	00000016 memcpy
00001d20 g     F .text	00000010 nffs_misc_ready
000054f0 g     F .text	00000030 conf_parse_name
0000599c g     F .text	0000002c conf_load
00001a64 g     F .text	00000040 nffs_misc_gc_if_oom
20000a78 g     O .bss	00000004 conf_handlers
000004dc g     F .text	00000018 nffs_detect
000025e8 g     F .text	00000194 nffs_restore_full
00004fe4 g     F .text	00000030 os_sched_ctx_sw_hook
20000ca0 g     O .bss	00000004 nffs_hash_next_block_id
20000ac8 g     O .bss	00000004 nffs_lost_found_dir
200000f4 g     O .data	00000004 SystemCoreClock
00002eac g     F .text	00000048 nffs_crc_flash
00001070 g     F .text	00000030 nffs_hash_init
00003438  w    F .text	00000002 SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
00004a8c g     F .text	0000003a os_arch_task_stack_init
00000c14 g     F .text	0000001e nffs_file_seek
000038a4 g     F .text	00000094 malloc
00005560 g     F .text	00000020 conf_str_from_bytes
00004c4c g     F .text	00000024 __assert_func
00005174 g     F .text	0000003c os_sched_wakeup_ticks
00002c24 g     F .text	0000001c nffs_block_entry_alloc
00002efe g     F .text	00000034 nffs_crc_disk_block_validate
000007d8 g     F .text	00000024 nffs_cache_insert_block
00003430  w    F .text	00000002 UsageFault_Handler
20000e48 g     O .bss	00000008 g_callout_list
00004ce4 g     F .text	00000018 os_malloc
00003438  w    F .text	00000002 UARTE0_UART0_IRQHandler
20000acc g     O .bss	0000001c nffs_file_pool
2000fe50 g       *ABS*	00000000 __HeapLimit
200005d0 g       .bss	00000000 __bss_start__
00005a78 g     F .text	0000000c fs_open
00003720 g     F .text	0000003c hal_flash_write
00003438  w    F .text	00000002 TIMER4_IRQHandler
00000948 g     F .text	00000044 nffs_config_init
00002e60 g     F .text	0000004a nffs_block_delete_from_ram
00000c9c g     F .text	0000004c nffs_flash_read
000040a8 g     F .text	000000a0 mbedtls_sha256_starts
00004894 g     F .text	00000008 mbedtls_sha256_update
00001578 g     F .text	000000a2 nffs_inode_read
00000924 g     F .text	00000024 nffs_cache_clear
20000e50 g     O .bss	00000004 g_current_task
00004a70 g     F .text	0000000c os_arch_save_sr
00004d30 g     F .text	00000068 os_mempool_init
000011f6 g     F .text	0000001c nffs_inode_read_disk
20000e60 g     O .bss	00000001 g_task_id
00005b40 g     F .text	00000010 bsp_flash_dev
00000db4 g     F .text	00000054 nffs_format_area
000054d0 g     F .text	00000020 conf_handler_lookup
000009e0 g     F .text	00000030 nffs_dir_read
00003a50 g     F .text	00000020 boot_vect_read_main
00000ec4 g     F .text	00000014 nffs_hash_id_is_block
00005354 g     F .text	00000016 os_set_env
00006140 g     F .text	00000050 __libc_init_array
20000e6c g     O .bss	0000000c g_os_sanity_check_mu
20000b9c g     O .bss	00000100 nffs_flash_buf
000000d8 g     F .text	00000000 _mainCRTStartup
0000161a g     F .text	00000008 nffs_inode_unlink_from_ram
20000cac g     O .bss	00000004 nffs_gc_count
00004cfc g     F .text	00000016 os_free
00005b7c g     F .text	00000044 _sbrk
00005e30 g     F .text	00000048 os_tick_idle
00003438  w    F .text	00000002 I2S_IRQHandler
00006190 g     F .text	00000000 _init
20000a84 g     O .bss	00000004 fs_root_ops
000006e0 g     F .text	0000002c nffs_cache_inode_delete
0000375c g     F .text	00000080 hal_flash_erase
00005600 g     F .text	0000001c conf_file_dst
00003438  w    F .text	00000002 SWI4_EGU4_IRQHandler
00002b1c g     F .text	00000038 nffs_area_magic_is_set
00001dc4 g     F .text	0000000a nffs_path_parser_new
00003b7c g     F .text	0000001c boot_write_status
00000000  w      *UND*	00000000 __libc_fini_array
000010e8 g     F .text	0000001c nffs_inode_entry_alloc
00003438  w    F .text	00000002 TIMER0_IRQHandler
00004a24 g     F .text	00000030 os_init
00001364 g     F .text	00000070 nffs_inode_remove_child
20000ae8 g     O .bss	0000001c nffs_cache_block_pool
000033f8 g     F .text	00000030 Reset_Handler
000031a0 g     F .text	00000218 nffs_gc
000017d4 g     F .text	000000fc nffs_inode_rename
000053ec g     F .text	0000001e os_default_irq_asm
000051b0 g     F .text	0000000c os_sched_next_task
00000b34 g     F .text	000000e0 nffs_file_open
00000f74 g     F .text	00000068 nffs_hash_insert
00004f98 g     F .text	0000004c os_sched_insert
20000b04 g     O .bss	00000004 nffs_current_area_descs
00004e12 g     F .text	00000014 os_mutex_init
00002cf8 g     F .text	00000038 nffs_block_to_disk
200005cc g       .bssnz	00000000 __bssnz_end__
00003438  w    F .text	00000002 TIMER1_IRQHandler
00005138 g     F .text	0000003c os_sched_os_timer_exp
20000000 g       .vector_relocation	00000000 __vector_tbl_reloc__
00001a24 g     F .text	00000040 nffs_misc_validate_scratch
00003438  w    F .text	00000002 PWM2_IRQHandler
20000b08 g     O .bss	0000001c nffs_inode_entry_pool
20000e78 g     O .bss	00000050 g_os_sanity_task
200005cc g       .data	00000000 __data_end__
00005a24 g     F .text	00000018 log_register
00003438  w    F .text	00000002 ECB_IRQHandler
0000162a g     F .text	00000018 nffs_inode_unlink
20000e64 g     O .bss	00000004 g_os_time
00002b6a g     F .text	0000000a nffs_area_is_current_version
20000fd8 g       .bss	00000000 __bss_end__
00003438  w    F .text	00000002 SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
00001212 g     F .text	00000034 nffs_inode_write_disk
00003438 g     F .text	00000002 Default_Handler
00005ad4 g     F .text	00000014 fs_register
000000d8 g     F .text	00000000 _start
00001dd0 g     F .text	00000070 nffs_path_find
000056e8 g     F .text	00000104 conf_file_compress
00002c86 g     F .text	0000001c nffs_block_read_disk
00005fc0 g     F .text	0000009c base64_encode
0000536a g     F .text	00000006 os_arch_init_task_stack
00005a90 g     F .text	00000014 fs_read
000039ae g     F .text	00000020 strncmp
20000fc8 g     O .bss	00000004 conf_save_dst
00001b30 g     F .text	00000030 nffs_misc_set_num_areas
00000f58 g     F .text	0000001a nffs_hash_id_is_dummy
000007b4 g     F .text	00000024 nffs_cache_inode_refresh
20000cf0 g     O .bss	00000050 g_idle_task
00000fdc g     F .text	00000094 nffs_hash_remove
00005a84 g     F .text	0000000c fs_close
20000a70 g     O .bss	00000004 g_os_sanity_check_list
000011dc g     F .text	0000001a nffs_inode_entry_reserve
00004d98 g     F .text	00000028 os_memblock_get
000050c4 g     F .text	00000074 os_sched_wakeup
000019b8 g     F .text	00000020 nffs_inode_is_deleted
00000000  w      *UND*	00000000 software_init_hook
00005eea g     F .text	00000058 realloc
00003b38 g     F .text	0000000c bootutil_cfg_register
00004c70 g     F .text	00000018 os_default_irq
00000ed8 g     F .text	00000020 nffs_hash_find
20000e54 g     O .bss	00000004 g_os_last_ctx_sw_time
000014ec g     F .text	0000008c nffs_inode_filename_cmp_flash
00005eb8 g     F .text	0000001c memcmp
00004ac8 g     F .text	00000014 os_arch_init
0000277c g     F .text	000003a0 nffs_write_to_file
20000b24 g     O .bss	00000001 nffs_num_areas
00002ca2 g     F .text	00000054 nffs_block_write_disk
0000585c g     F .text	0000007a conf_line_parse
000055a4 g     F .text	00000040 conf_commit
000004f4 g     F .text	00000100 nffs_init
20000b28 g     O .bss	00000004 nffs_file_mem
00001622 g     F .text	00000008 nffs_inode_unlink_from_ram_corrupt_ok
00005abc g     F .text	0000000c fs_unlink
00000d3c g     F .text	0000004c nffs_flash_copy
20000b2c g     O .bss	00000004 nffs_cache_block_mem
20000b30 g     O .bss	00000004 nffs_inode_mem
20000d40 g     O .bss	00000004 g_os_idle_ctr
00003438  w    F .text	00000002 SAADC_IRQHandler
20000b34 g     O .bss	0000000c nffs_log
00003964 g     F .text	00000010 memset
00000000 g       .text	000000d8 __isr_vector
00004d12 g     F .text	0000001c os_realloc
0000014c g     F .text	00000128 main
00005ae8 g     F .text	0000002c fsutil_read_file
00003438  w    F .text	00000002 CCM_AAR_IRQHandler
00003438  w    F .text	00000002 WDT_IRQHandler
00000a10 g     F .text	00000038 nffs_dir_close
00001aa4 g     F .text	0000008c nffs_misc_reserve_space
00005370 g     F .text	00000046 SVC_Handler
000019f4 g     F .text	00000030 nffs_misc_validate_root_dir
00000da8 g     F .text	0000000c nffs_flash_loc_expand
000036e4 g     F .text	0000003c hal_flash_read
00000000  w      *UND*	00000000 hardware_init_hook
00000f1c g     F .text	00000028 nffs_hash_find_block
20000cb0 g     O .bss	00000040 boot_img_hdrs
00003a70 g     F .text	00000044 boot_vect_write_test
00005a4c g     F .text	0000002c log_console_handler_init
00004bc4 g     F .text	00000034 os_callout_wakeup_ticks
00003438  w    F .text	00000002 SWI5_EGU5_IRQHandler
00004148 g     F .text	000006cc mbedtls_sha256_process
00000a48 g     F .text	000000ec nffs_file_new
000054c0 g     F .text	00000010 conf_register
00002d30 g     F .text	00000060 nffs_block_from_hash_entry_no_ptrs
00005f42 g     F .text	00000014 strcmp
00005014 g     F .text	0000000c os_sched_get_current_task
00003a30 g     F .text	00000020 boot_vect_read_test
00001e56 g     F .text	00000020 nffs_path_unlink
00002bb4 g     F .text	00000008 nffs_area_free_space
000055e4 g     F .text	0000001c conf_file_src
0000070c g     F .text	000000a8 nffs_cache_inode_ensure
00005aa4 g     F .text	0000000c fs_write
0000343c g     F .text	000000c0 SystemInit
00003438  w    F .text	00000002 RNG_IRQHandler
0000619c g     F .text	00000000 _fini
000059c8 g     F .text	00000048 conf_save_one
000018d0 g     F .text	000000e8 nffs_inode_update
00002ef4 g     F .text	0000000a nffs_crc_disk_block_hdr
20000b40 g     O .bss	00000004 nffs_areas
00000e08 g     F .text	00000064 nffs_format_from_scratch_area
00005020 g     F .text	00000030 os_sched
00000000  w      *UND*	00000000 atexit
000034fc g     F .text	00000014 flash_area_init
00001d6e g     F .text	00000056 nffs_path_parse_next
00003f7c g     F .text	000000e4 bootutil_img_validate
00004eb8 g     F .text	000000e0 os_mutex_pend
00000000 g       .svc_table	00000000 SVC_Table
00003438  w    F .text	00000002 RTC2_IRQHandler
00001744 g     F .text	00000090 nffs_inode_add_child
20010000 g       *ABS*	00000000 __StackTop
00001248 g     F .text	00000044 nffs_inode_calc_data_length
200005c8 g     O .data	00000004 _impure_ptr
000012b4 g     F .text	00000020 nffs_inode_inc_refcnt
00003438  w    F .text	00000002 PWM0_IRQHandler
00003438  w    F .text	00000002 SWI3_EGU3_IRQHandler
00005ac8 g     F .text	0000000c fs_rename
00005f72 g     F .text	0000001c strsep
000058d6 g     F .text	0000005c conf_line_make
00001478 g     F .text	00000074 nffs_inode_filename_cmp_ram
20000b44 g     O .bss	0000001c nffs_block_entry_pool
00001e78 g     F .text	000000a0 nffs_path_rename
00003b44 g     F .text	00000038 boot_read_status
00003510 g     F .text	0000007c flash_area_to_sectors
0000605c g     F .text	000000ac base64_decode
00000ce8 g     F .text	00000054 nffs_flash_write
00001f18 g     F .text	0000004e nffs_path_new_dir
00002dd4 g     F .text	0000008c nffs_block_from_hash_entry
20000ca4 g     O .bss	00000004 nffs_hash
00004b7c g     F .text	00000048 os_callout_tick
00001be8 g     F .text	00000138 nffs_misc_reset
000000d8 g       .text	00000000 __isr_vector_end
000007fc g     F .text	00000128 nffs_cache_seek
00003438  w    F .text	00000002 RTC1_IRQHandler
00000ea0 g     F .text	0000000c nffs_hash_id_is_dir
0000098c g     F .text	00000054 nffs_dir_open
0000561c g     F .text	0000006a conf_getnext_line
00002f80 g     F .text	0000001c nffs_crc_disk_inode_fill
00001b60 g     F .text	00000060 nffs_misc_set_max_block_data_len
20010000 g       *ABS*	00000000 __stack
00003438  w    F .text	00000002 SWI1_EGU1_IRQHandler
00001e40 g     F .text	00000016 nffs_path_find_inode_entry
20000138 g     O .data	00000008 g_os_run_list
20000d44 g     O .bss	00000100 g_idle_task_stack
00004060 g     F .text	0000002c NVIC_Relocate
00005968 g     F .text	00000028 conf_src_register
20000a2c g     O .bss	00000004 os_flags
00004a7c g     F .text	00000006 os_arch_restore_sr
20000fcc g     O .bss	0000000c g_hal_os_tick
00006108 g     F .text	0000002a base64_decode_len
2000fe50 g       *ABS*	000001b0 __StackLimit
20000e44 g     O .bss	00000004 g_os_started
00000c32 g     F .text	00000046 nffs_file_read
000019ee g     F .text	00000006 nffs_inode_getflags
00003438  w    F .text	00000002 SPIM2_SPIS2_SPI2_IRQHandler
00003438  w    F .text	00000002 NFCT_IRQHandler
00003af8 g     F .text	00000040 boot_read_image_headers
000037e6 g     F .text	00000006 exit
20000b60 g     O .bss	00000002 nffs_block_max_data_sz
000052d8 g     F .text	0000000c os_time_get
20000b68 g     O .bss	00000010 g_log_info
00005538 g     F .text	00000028 conf_bytes_from_str
00001bc0 g     F .text	00000028 nffs_misc_create_lost_found_dir
20000ec8 g     O .bss	00000100 g_os_sanity_task_stack
00005580 g     F .text	00000024 conf_set_value
00005b56 g     F .text	00000006 _exit
000051e0 g     F .text	000000b4 os_task_init
0000342e  w    F .text	00000002 BusFault_Handler
20000b78 g     O .bss	00000004 nffs_root_dir
0000399e g     F .text	00000010 strlen
000052e4 g     F .text	00000070 os_time_advance
20000b84 g     O .bss	00000018 nffs_config
000051bc g     F .text	00000024 os_sched_resort
000012d4 g     F .text	00000006 nffs_inode_dec_refcnt
000036c0 g     F .text	00000024 hal_flash_init
00003438  w    F .text	00000002 MWU_IRQHandler
00003974 g     F .text	0000001a strchr
0000358c g     F .text	00000118 flash_area_to_nffs_desc
0000342c  w    F .text	00000002 MemoryManagement_Handler
00000f44 g     F .text	00000014 nffs_hash_entry_is_dummy
00003438  w    F .text	00000002 COMP_LPCOMP_IRQHandler
00001104 g     F .text	00000030 nffs_inode_entry_free
00002f48 g     F .text	00000038 nffs_crc_disk_inode_validate
20000140 g     O .data	00000008 g_os_sleep_list
20000ca8 g     O .bss	00000004 nffs_hash_next_file_id
000054ac g     F .text	00000014 conf_init
00005454 g     F .text	0000000e os_sanity_check_init
000019d8 g     F .text	0000000a nffs_inode_setflags
20000b7c g     O .bss	00000004 nffs_dir_mem
20000b80 g     O .bss	00000004 nffs_block_entry_mem
00005f8e g     F .text	00000030 strpbrk
00005b50 g     F .text	00000006 _close
00000eac g     F .text	00000010 nffs_hash_id_is_file
00003938 g     F .text	0000002c free
00005e78 g     F .text	00000030 system_reset



Disassembly of section .text:

00000000 <__isr_vector>:
       0:	20010000 	.word	0x20010000
       4:	000033f9 	.word	0x000033f9
       8:	00003429 	.word	0x00003429
       c:	0000342b 	.word	0x0000342b
	...
      2c:	00005371 	.word	0x00005371
	...
      38:	000053b7 	.word	0x000053b7
      3c:	000053e1 	.word	0x000053e1
      40:	00003439 	.word	0x00003439
      44:	00003439 	.word	0x00003439
      48:	00003439 	.word	0x00003439
      4c:	00003439 	.word	0x00003439
      50:	00003439 	.word	0x00003439
      54:	00003439 	.word	0x00003439
      58:	00003439 	.word	0x00003439
      5c:	00003439 	.word	0x00003439
      60:	00003439 	.word	0x00003439
      64:	00003439 	.word	0x00003439
      68:	00003439 	.word	0x00003439
      6c:	00003439 	.word	0x00003439
      70:	00003439 	.word	0x00003439
      74:	00003439 	.word	0x00003439
      78:	00003439 	.word	0x00003439
      7c:	00003439 	.word	0x00003439
      80:	00003439 	.word	0x00003439
      84:	00003439 	.word	0x00003439
      88:	00003439 	.word	0x00003439
      8c:	00003439 	.word	0x00003439
      90:	00003439 	.word	0x00003439
      94:	00003439 	.word	0x00003439
      98:	00003439 	.word	0x00003439
      9c:	00003439 	.word	0x00003439
      a0:	00003439 	.word	0x00003439
      a4:	00003439 	.word	0x00003439
      a8:	00003439 	.word	0x00003439
      ac:	00003439 	.word	0x00003439
      b0:	00003439 	.word	0x00003439
      b4:	00003439 	.word	0x00003439
	...
      c0:	00003439 	.word	0x00003439
      c4:	00003439 	.word	0x00003439
      c8:	00003439 	.word	0x00003439
      cc:	00003439 	.word	0x00003439
      d0:	00003439 	.word	0x00003439
      d4:	00003439 	.word	0x00003439

000000d8 <_mainCRTStartup>:
      d8:	4b15      	ldr	r3, [pc, #84]	; (130 <_mainCRTStartup+0x58>)
      da:	2b00      	cmp	r3, #0
      dc:	bf08      	it	eq
      de:	4b13      	ldreq	r3, [pc, #76]	; (12c <_mainCRTStartup+0x54>)
      e0:	469d      	mov	sp, r3
      e2:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
      e6:	2100      	movs	r1, #0
      e8:	468b      	mov	fp, r1
      ea:	460f      	mov	r7, r1
      ec:	4813      	ldr	r0, [pc, #76]	; (13c <_mainCRTStartup+0x64>)
      ee:	4a14      	ldr	r2, [pc, #80]	; (140 <_mainCRTStartup+0x68>)
      f0:	1a12      	subs	r2, r2, r0
      f2:	f003 fc37 	bl	3964 <memset>
      f6:	4b0f      	ldr	r3, [pc, #60]	; (134 <_mainCRTStartup+0x5c>)
      f8:	2b00      	cmp	r3, #0
      fa:	d000      	beq.n	fe <_mainCRTStartup+0x26>
      fc:	4798      	blx	r3
      fe:	4b0e      	ldr	r3, [pc, #56]	; (138 <_mainCRTStartup+0x60>)
     100:	2b00      	cmp	r3, #0
     102:	d000      	beq.n	106 <_mainCRTStartup+0x2e>
     104:	4798      	blx	r3
     106:	2000      	movs	r0, #0
     108:	2100      	movs	r1, #0
     10a:	0004      	movs	r4, r0
     10c:	000d      	movs	r5, r1
     10e:	480d      	ldr	r0, [pc, #52]	; (144 <_mainCRTStartup+0x6c>)
     110:	2800      	cmp	r0, #0
     112:	d002      	beq.n	11a <_mainCRTStartup+0x42>
     114:	480c      	ldr	r0, [pc, #48]	; (148 <_mainCRTStartup+0x70>)
     116:	f3af 8000 	nop.w
     11a:	f006 f811 	bl	6140 <__libc_init_array>
     11e:	0020      	movs	r0, r4
     120:	0029      	movs	r1, r5
     122:	f000 f813 	bl	14c <main>
     126:	f003 fb5e 	bl	37e6 <exit>
     12a:	bf00      	nop
     12c:	00080000 	.word	0x00080000
     130:	20010000 	.word	0x20010000
	...
     13c:	200005d0 	.word	0x200005d0
     140:	20000fd8 	.word	0x20000fd8
	...

0000014c <main>:
}
#endif

int
main(void)
{
     14c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint8_t img_starts[2];
    int cnt;
    int total;
    struct boot_rsp rsp;
    int rc;
    struct boot_req req = {
     150:	f04f 080c 	mov.w	r8, #12
}
#endif

int
main(void)
{
     154:	f6ad 4d8c 	subw	sp, sp, #3212	; 0xc8c
    uint8_t img_starts[2];
    int cnt;
    int total;
    struct boot_rsp rsp;
    int rc;
    struct boot_req req = {
     158:	2100      	movs	r1, #0
     15a:	4642      	mov	r2, r8
     15c:	a804      	add	r0, sp, #16
     15e:	ad22      	add	r5, sp, #136	; 0x88
     160:	f10d 0904 	add.w	r9, sp, #4
     164:	f003 fbfe 	bl	3964 <memset>
     168:	9504      	str	r5, [sp, #16]
     16a:	f8cd 9014 	str.w	r9, [sp, #20]
        .br_area_descs = descs,
        .br_slot_areas = img_starts,
    };

    os_init();
     16e:	f004 fc59 	bl	4a24 <os_init>

    rc = hal_flash_init();
     172:	f003 faa5 	bl	36c0 <hal_flash_init>
    assert(rc == 0);
     176:	4606      	mov	r6, r0
     178:	b110      	cbz	r0, 180 <main+0x34>
     17a:	483c      	ldr	r0, [pc, #240]	; (26c <Stack_Size+0xbc>)
     17c:	2193      	movs	r1, #147	; 0x93
     17e:	e058      	b.n	232 <Stack_Size+0x82>

    cnt = BOOT_AREA_DESC_MAX;
     180:	f44f 7380 	mov.w	r3, #256	; 0x100
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_0, &cnt, descs);
     184:	2001      	movs	r0, #1
     186:	a902      	add	r1, sp, #8
     188:	462a      	mov	r2, r5
    os_init();

    rc = hal_flash_init();
    assert(rc == 0);

    cnt = BOOT_AREA_DESC_MAX;
     18a:	9302      	str	r3, [sp, #8]
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_0, &cnt, descs);
     18c:	f003 f9c0 	bl	3510 <flash_area_to_sectors>
    img_starts[0] = 0;
    total = cnt;
     190:	9c02      	ldr	r4, [sp, #8]
    rc = hal_flash_init();
    assert(rc == 0);

    cnt = BOOT_AREA_DESC_MAX;
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_0, &cnt, descs);
    img_starts[0] = 0;
     192:	f889 6000 	strb.w	r6, [r9]
    total = cnt;

    cnt = BOOT_AREA_DESC_MAX - total;
     196:	f5c4 7380 	rsb	r3, r4, #256	; 0x100
    assert(cnt >= 0);
     19a:	2b00      	cmp	r3, #0
    cnt = BOOT_AREA_DESC_MAX;
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_0, &cnt, descs);
    img_starts[0] = 0;
    total = cnt;

    cnt = BOOT_AREA_DESC_MAX - total;
     19c:	9302      	str	r3, [sp, #8]
    assert(cnt >= 0);
     19e:	da05      	bge.n	1ac <main+0x60>
     1a0:	4832      	ldr	r0, [pc, #200]	; (26c <Stack_Size+0xbc>)
     1a2:	219b      	movs	r1, #155	; 0x9b
     1a4:	4632      	mov	r2, r6
     1a6:	4613      	mov	r3, r2
     1a8:	f004 fd50 	bl	4c4c <__assert_func>
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_1, &cnt, &descs[total]);
     1ac:	2002      	movs	r0, #2
     1ae:	a902      	add	r1, sp, #8
     1b0:	fb08 5204 	mla	r2, r8, r4, r5
     1b4:	f003 f9ac 	bl	3510 <flash_area_to_sectors>
    assert(rc == 0);
     1b8:	4607      	mov	r7, r0
     1ba:	b110      	cbz	r0, 1c2 <Stack_Size+0x12>
     1bc:	482b      	ldr	r0, [pc, #172]	; (26c <Stack_Size+0xbc>)
     1be:	219d      	movs	r1, #157	; 0x9d
     1c0:	e7f0      	b.n	1a4 <main+0x58>
    img_starts[1] = total;
    total += cnt;
     1c2:	9b02      	ldr	r3, [sp, #8]

    cnt = BOOT_AREA_DESC_MAX - total;
    assert(cnt >= 0);
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_1, &cnt, &descs[total]);
    assert(rc == 0);
    img_starts[1] = total;
     1c4:	f889 4001 	strb.w	r4, [r9, #1]
    total += cnt;
     1c8:	441c      	add	r4, r3

    cnt = BOOT_AREA_DESC_MAX - total;
     1ca:	f5c4 7380 	rsb	r3, r4, #256	; 0x100
    assert(cnt >= 0);
     1ce:	2b00      	cmp	r3, #0
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_1, &cnt, &descs[total]);
    assert(rc == 0);
    img_starts[1] = total;
    total += cnt;

    cnt = BOOT_AREA_DESC_MAX - total;
     1d0:	9302      	str	r3, [sp, #8]
    assert(cnt >= 0);
     1d2:	da02      	bge.n	1da <Stack_Size+0x2a>
     1d4:	4825      	ldr	r0, [pc, #148]	; (26c <Stack_Size+0xbc>)
     1d6:	21a2      	movs	r1, #162	; 0xa2
     1d8:	e009      	b.n	1ee <Stack_Size+0x3e>
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_SCRATCH, &cnt, &descs[total]);
     1da:	fb08 5204 	mla	r2, r8, r4, r5
     1de:	2003      	movs	r0, #3
     1e0:	a902      	add	r1, sp, #8
     1e2:	f003 f995 	bl	3510 <flash_area_to_sectors>
    assert(rc == 0);
     1e6:	4605      	mov	r5, r0
     1e8:	b118      	cbz	r0, 1f2 <Stack_Size+0x42>
     1ea:	4820      	ldr	r0, [pc, #128]	; (26c <Stack_Size+0xbc>)
     1ec:	21a4      	movs	r1, #164	; 0xa4
     1ee:	463a      	mov	r2, r7
     1f0:	e7d9      	b.n	1a6 <main+0x5a>
    req.br_scratch_area_idx = total;
    total += cnt;
     1f2:	9b02      	ldr	r3, [sp, #8]

    cnt = BOOT_AREA_DESC_MAX - total;
    assert(cnt >= 0);
    rc = flash_area_to_sectors(FLASH_AREA_IMAGE_SCRATCH, &cnt, &descs[total]);
    assert(rc == 0);
    req.br_scratch_area_idx = total;
     1f4:	f88d 4019 	strb.w	r4, [sp, #25]
    total += cnt;
     1f8:	441c      	add	r4, r3

    req.br_num_image_areas = total;
     1fa:	f88d 4018 	strb.w	r4, [sp, #24]

    conf_init();
     1fe:	f005 f955 	bl	54ac <conf_init>
    /*
     * Make sure we have enough left to initialize the NFFS with the
     * right number of maximum areas otherwise the file-system will not
     * be readable.
     */
    cnt = NFFS_AREA_MAX;
     202:	2308      	movs	r3, #8
    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS, &cnt, nffs_descs);
     204:	2004      	movs	r0, #4
     206:	a903      	add	r1, sp, #12
     208:	aa07      	add	r2, sp, #28
    /*
     * Make sure we have enough left to initialize the NFFS with the
     * right number of maximum areas otherwise the file-system will not
     * be readable.
     */
    cnt = NFFS_AREA_MAX;
     20a:	9303      	str	r3, [sp, #12]
    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS, &cnt, nffs_descs);
     20c:	f003 f9be 	bl	358c <flash_area_to_nffs_desc>
    assert(rc == 0);
     210:	b110      	cbz	r0, 218 <Stack_Size+0x68>
     212:	4816      	ldr	r0, [pc, #88]	; (26c <Stack_Size+0xbc>)
     214:	2152      	movs	r1, #82	; 0x52
     216:	e015      	b.n	244 <Stack_Size+0x94>

    /*
     * Initializes the flash driver and file system for use by the boot loader.
     */
    rc = nffs_init();
     218:	f000 f96c 	bl	4f4 <nffs_init>
    if (rc == 0) {
     21c:	b910      	cbnz	r0, 224 <Stack_Size+0x74>
        /* Look for an nffs file system in internal flash.  If no file
         * system gets detected, all subsequent file operations will fail,
         * but the boot loader should proceed anyway.
         */
        nffs_detect(nffs_descs);
     21e:	a807      	add	r0, sp, #28
     220:	f000 f95c 	bl	4dc <nffs_detect>
    }

    rc = conf_file_src(&my_conf);
     224:	4812      	ldr	r0, [pc, #72]	; (270 <Stack_Size+0xc0>)
     226:	f005 f9dd 	bl	55e4 <conf_file_src>
    assert(rc == 0);
     22a:	4605      	mov	r5, r0
     22c:	b118      	cbz	r0, 236 <Stack_Size+0x86>
     22e:	480f      	ldr	r0, [pc, #60]	; (26c <Stack_Size+0xbc>)
     230:	2161      	movs	r1, #97	; 0x61
     232:	2200      	movs	r2, #0
     234:	e7b7      	b.n	1a6 <main+0x5a>
    rc = conf_file_dst(&my_conf);
     236:	480e      	ldr	r0, [pc, #56]	; (270 <Stack_Size+0xc0>)
     238:	f005 f9e2 	bl	5600 <conf_file_dst>
    assert(rc == 0);
     23c:	4604      	mov	r4, r0
     23e:	b118      	cbz	r0, 248 <Stack_Size+0x98>
     240:	480a      	ldr	r0, [pc, #40]	; (26c <Stack_Size+0xbc>)
     242:	2163      	movs	r1, #99	; 0x63
     244:	462a      	mov	r2, r5
     246:	e7ae      	b.n	1a6 <main+0x5a>
#ifdef NFFS_PRESENT
    setup_for_nffs();
#elif FCB_PRESENT
    setup_for_fcb();
#endif
    bootutil_cfg_register();
     248:	f003 fc76 	bl	3b38 <bootutil_cfg_register>
          boot_ser_stack, BOOT_SER_STACK_SZ, BOOT_SER_CONS_INPUT);
        assert(rc == 0);
        os_start();
    }
#endif
    rc = boot_go(&req, &rsp);
     24c:	a804      	add	r0, sp, #16
     24e:	a907      	add	r1, sp, #28
     250:	f003 fde2 	bl	3e18 <boot_go>
    assert(rc == 0);
     254:	b118      	cbz	r0, 25e <Stack_Size+0xae>
     256:	4805      	ldr	r0, [pc, #20]	; (26c <Stack_Size+0xbc>)
     258:	21c1      	movs	r1, #193	; 0xc1
     25a:	4622      	mov	r2, r4
     25c:	e7a3      	b.n	1a6 <main+0x5a>

    system_start((void *)(rsp.br_image_addr + rsp.br_hdr->ih_hdr_size));
     25e:	9b07      	ldr	r3, [sp, #28]
     260:	8918      	ldrh	r0, [r3, #8]
     262:	9b09      	ldr	r3, [sp, #36]	; 0x24
     264:	4418      	add	r0, r3
     266:	f003 fab9 	bl	37dc <system_start>
     26a:	bf00      	nop
     26c:	000061a8 	.word	0x000061a8
     270:	200000d8 	.word	0x200000d8

00000274 <nffs_lock>:
    .f_name = "nffs"
};

static void
nffs_lock(void)
{
     274:	b508      	push	{r3, lr}
    int rc;

    rc = os_mutex_pend(&nffs_mutex, 0xffffffff);
     276:	4807      	ldr	r0, [pc, #28]	; (294 <nffs_lock+0x20>)
     278:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
     27c:	f004 fe1c 	bl	4eb8 <os_mutex_pend>
    assert(rc == 0 || rc == OS_NOT_STARTED);
     280:	b138      	cbz	r0, 292 <nffs_lock+0x1e>
     282:	2809      	cmp	r0, #9
     284:	d005      	beq.n	292 <nffs_lock+0x1e>
     286:	2200      	movs	r2, #0
     288:	4803      	ldr	r0, [pc, #12]	; (298 <nffs_lock+0x24>)
     28a:	216d      	movs	r1, #109	; 0x6d
     28c:	4613      	mov	r3, r2
     28e:	f004 fcdd 	bl	4c4c <__assert_func>
     292:	bd08      	pop	{r3, pc}
     294:	200005d0 	.word	0x200005d0
     298:	000061b8 	.word	0x000061b8

0000029c <nffs_unlock>:
}

static void
nffs_unlock(void)
{
     29c:	b508      	push	{r3, lr}
    int rc;

    rc = os_mutex_release(&nffs_mutex);
     29e:	4806      	ldr	r0, [pc, #24]	; (2b8 <nffs_unlock+0x1c>)
     2a0:	f004 fdc2 	bl	4e28 <os_mutex_release>
    assert(rc == 0 || rc == OS_NOT_STARTED);
     2a4:	b138      	cbz	r0, 2b6 <nffs_unlock+0x1a>
     2a6:	2809      	cmp	r0, #9
     2a8:	d005      	beq.n	2b6 <nffs_unlock+0x1a>
     2aa:	2200      	movs	r2, #0
     2ac:	4803      	ldr	r0, [pc, #12]	; (2bc <nffs_unlock+0x20>)
     2ae:	2176      	movs	r1, #118	; 0x76
     2b0:	4613      	mov	r3, r2
     2b2:	f004 fccb 	bl	4c4c <__assert_func>
     2b6:	bd08      	pop	{r3, pc}
     2b8:	200005d0 	.word	0x200005d0
     2bc:	000061b8 	.word	0x000061b8

000002c0 <nffs_getpos>:
 *
 * @return                  The file offset, in bytes.
 */
static uint32_t
nffs_getpos(const struct fs_file *fs_file)
{
     2c0:	b510      	push	{r4, lr}
     2c2:	4604      	mov	r4, r0
    uint32_t offset;
    const struct nffs_file *file = (const struct nffs_file *)fs_file;

    nffs_lock();
     2c4:	f7ff ffd6 	bl	274 <nffs_lock>
    offset = file->nf_offset;
     2c8:	6864      	ldr	r4, [r4, #4]
    nffs_unlock();
     2ca:	f7ff ffe7 	bl	29c <nffs_unlock>

    return offset;
}
     2ce:	4620      	mov	r0, r4
     2d0:	bd10      	pop	{r4, pc}

000002d2 <nffs_closedir>:
 *
 * @return                      0 on success; nonzero on failure.
 */
static int
nffs_closedir(struct fs_dir *fs_dir)
{
     2d2:	b510      	push	{r4, lr}
     2d4:	4604      	mov	r4, r0
    int rc;
    struct nffs_dir *dir = (struct nffs_dir *)fs_dir;

    nffs_lock();
     2d6:	f7ff ffcd 	bl	274 <nffs_lock>
    rc = nffs_dir_close(dir);
     2da:	4620      	mov	r0, r4
     2dc:	f000 fb98 	bl	a10 <nffs_dir_close>
     2e0:	4604      	mov	r4, r0
    nffs_unlock();
     2e2:	f7ff ffdb 	bl	29c <nffs_unlock>

    return rc;
}
     2e6:	4620      	mov	r0, r4
     2e8:	bd10      	pop	{r4, pc}

000002ea <nffs_readdir>:
 *                                  parent directory;
 *                              other nonzero on error.
 */
static int
nffs_readdir(struct fs_dir *fs_dir, struct fs_dirent **out_fs_dirent)
{
     2ea:	b538      	push	{r3, r4, r5, lr}
     2ec:	4605      	mov	r5, r0
     2ee:	460c      	mov	r4, r1
    int rc;
    struct nffs_dir *dir = (struct nffs_dir *)fs_dir;
    struct nffs_dirent **out_dirent = (struct nffs_dirent **)out_fs_dirent;

    nffs_lock();
     2f0:	f7ff ffc0 	bl	274 <nffs_lock>
    rc = nffs_dir_read(dir, out_dirent);
     2f4:	4621      	mov	r1, r4
     2f6:	4628      	mov	r0, r5
     2f8:	f000 fb72 	bl	9e0 <nffs_dir_read>
     2fc:	4604      	mov	r4, r0
    nffs_unlock();
     2fe:	f7ff ffcd 	bl	29c <nffs_unlock>

    return rc;
}
     302:	4620      	mov	r0, r4
     304:	bd38      	pop	{r3, r4, r5, pc}

00000306 <nffs_opendir>:
 *                                  exist;
 *                              other nonzero on error.
 */
static int
nffs_opendir(const char *path, struct fs_dir **out_fs_dir)
{
     306:	b538      	push	{r3, r4, r5, lr}
     308:	4605      	mov	r5, r0
     30a:	460c      	mov	r4, r1
    int rc;
    struct nffs_dir **out_dir = (struct nffs_dir **)out_fs_dir;

    nffs_lock();
     30c:	f7ff ffb2 	bl	274 <nffs_lock>

    if (!nffs_misc_ready()) {
     310:	f001 fd06 	bl	1d20 <nffs_misc_ready>
     314:	b128      	cbz	r0, 322 <nffs_opendir+0x1c>
        rc = FS_EUNINIT;
        goto done;
    }

    rc = nffs_dir_open(path, out_dir);
     316:	4621      	mov	r1, r4
     318:	4628      	mov	r0, r5
     31a:	f000 fb37 	bl	98c <nffs_dir_open>
     31e:	4604      	mov	r4, r0
     320:	e000      	b.n	324 <nffs_opendir+0x1e>
    struct nffs_dir **out_dir = (struct nffs_dir **)out_fs_dir;

    nffs_lock();

    if (!nffs_misc_ready()) {
        rc = FS_EUNINIT;
     322:	240d      	movs	r4, #13
    }

    rc = nffs_dir_open(path, out_dir);

done:
    nffs_unlock();
     324:	f7ff ffba 	bl	29c <nffs_unlock>
    return rc;
}
     328:	4620      	mov	r0, r4
     32a:	bd38      	pop	{r3, r4, r5, pc}

0000032c <nffs_mkdir>:
 * @return                      0 on success;
 *                              nonzero on failure.
 */
static int
nffs_mkdir(const char *path)
{
     32c:	b510      	push	{r4, lr}
     32e:	4604      	mov	r4, r0
    int rc;

    nffs_lock();
     330:	f7ff ffa0 	bl	274 <nffs_lock>

    if (!nffs_misc_ready()) {
     334:	f001 fcf4 	bl	1d20 <nffs_misc_ready>
     338:	b128      	cbz	r0, 346 <nffs_mkdir+0x1a>
        rc = FS_EUNINIT;
        goto done;
    }

    rc = nffs_path_new_dir(path, NULL);
     33a:	4620      	mov	r0, r4
     33c:	2100      	movs	r1, #0
     33e:	f001 fdeb 	bl	1f18 <nffs_path_new_dir>
     342:	4604      	mov	r4, r0
     344:	e000      	b.n	348 <nffs_mkdir+0x1c>
    int rc;

    nffs_lock();

    if (!nffs_misc_ready()) {
        rc = FS_EUNINIT;
     346:	240d      	movs	r4, #13
    if (rc != 0) {
        goto done;
    }

done:
    nffs_unlock();
     348:	f7ff ffa8 	bl	29c <nffs_unlock>
    return rc;
}
     34c:	4620      	mov	r0, r4
     34e:	bd10      	pop	{r4, pc}

00000350 <nffs_rename>:
 * @return                  0 on success;
 *                          nonzero on failure.
 */
static int
nffs_rename(const char *from, const char *to)
{
     350:	b538      	push	{r3, r4, r5, lr}
     352:	4605      	mov	r5, r0
     354:	460c      	mov	r4, r1
    int rc;

    nffs_lock();
     356:	f7ff ff8d 	bl	274 <nffs_lock>

    if (!nffs_misc_ready()) {
     35a:	f001 fce1 	bl	1d20 <nffs_misc_ready>
     35e:	b128      	cbz	r0, 36c <nffs_rename+0x1c>
        rc = FS_EUNINIT;
        goto done;
    }

    rc = nffs_path_rename(from, to);
     360:	4621      	mov	r1, r4
     362:	4628      	mov	r0, r5
     364:	f001 fd88 	bl	1e78 <nffs_path_rename>
     368:	4604      	mov	r4, r0
     36a:	e000      	b.n	36e <nffs_rename+0x1e>
    int rc;

    nffs_lock();

    if (!nffs_misc_ready()) {
        rc = FS_EUNINIT;
     36c:	240d      	movs	r4, #13
    }

    rc = 0;

done:
    nffs_unlock();
     36e:	f7ff ff95 	bl	29c <nffs_unlock>
    return rc;
}
     372:	4620      	mov	r0, r4
     374:	bd38      	pop	{r3, r4, r5, pc}

00000376 <nffs_unlink>:
 *
 * @return                  0 on success; nonzero on failure.
 */
static int
nffs_unlink(const char *path)
{
     376:	b510      	push	{r4, lr}
     378:	4604      	mov	r4, r0
    int rc;

    nffs_lock();
     37a:	f7ff ff7b 	bl	274 <nffs_lock>

    if (!nffs_misc_ready()) {
     37e:	f001 fccf 	bl	1d20 <nffs_misc_ready>
     382:	b120      	cbz	r0, 38e <nffs_unlink+0x18>
        rc = FS_EUNINIT;
        goto done;
    }

    rc = nffs_path_unlink(path);
     384:	4620      	mov	r0, r4
     386:	f001 fd66 	bl	1e56 <nffs_path_unlink>
     38a:	4604      	mov	r4, r0
     38c:	e000      	b.n	390 <nffs_unlink+0x1a>
    int rc;

    nffs_lock();

    if (!nffs_misc_ready()) {
        rc = FS_EUNINIT;
     38e:	240d      	movs	r4, #13
    }

    rc = 0;

done:
    nffs_unlock();
     390:	f7ff ff84 	bl	29c <nffs_unlock>
    return rc;
}
     394:	4620      	mov	r0, r4
     396:	bd10      	pop	{r4, pc}

00000398 <nffs_file_len>:
 *
 * @return                  0 on success; nonzero on failure.
 */
static int
nffs_file_len(const struct fs_file *fs_file, uint32_t *out_len)
{
     398:	b538      	push	{r3, r4, r5, lr}
     39a:	4605      	mov	r5, r0
     39c:	460c      	mov	r4, r1
    int rc;
    const struct nffs_file *file = (const struct nffs_file *)fs_file;

    nffs_lock();
     39e:	f7ff ff69 	bl	274 <nffs_lock>
    rc = nffs_inode_data_len(file->nf_inode_entry, out_len);
     3a2:	4621      	mov	r1, r4
     3a4:	6828      	ldr	r0, [r5, #0]
     3a6:	f000 ff71 	bl	128c <nffs_inode_data_len>
     3aa:	4604      	mov	r4, r0
    nffs_unlock();
     3ac:	f7ff ff76 	bl	29c <nffs_unlock>

    return rc;
}
     3b0:	4620      	mov	r0, r4
     3b2:	bd38      	pop	{r3, r4, r5, pc}

000003b4 <nffs_seek>:
 *
 * @return                  0 on success; nonzero on failure.
 */
static int
nffs_seek(struct fs_file *fs_file, uint32_t offset)
{
     3b4:	b538      	push	{r3, r4, r5, lr}
     3b6:	4605      	mov	r5, r0
     3b8:	460c      	mov	r4, r1
    int rc;
    struct nffs_file *file = (struct nffs_file *)fs_file;

    nffs_lock();
     3ba:	f7ff ff5b 	bl	274 <nffs_lock>
    rc = nffs_file_seek(file, offset);
     3be:	4621      	mov	r1, r4
     3c0:	4628      	mov	r0, r5
     3c2:	f000 fc27 	bl	c14 <nffs_file_seek>
     3c6:	4604      	mov	r4, r0
    nffs_unlock();
     3c8:	f7ff ff68 	bl	29c <nffs_unlock>

    return rc;
}
     3cc:	4620      	mov	r0, r4
     3ce:	bd38      	pop	{r3, r4, r5, pc}

000003d0 <nffs_write>:
 *
 * @return                  0 on success; nonzero on failure.
 */
static int
nffs_write(struct fs_file *fs_file, const void *data, int len)
{
     3d0:	b570      	push	{r4, r5, r6, lr}
     3d2:	4606      	mov	r6, r0
     3d4:	460d      	mov	r5, r1
     3d6:	4614      	mov	r4, r2
    int rc;
    struct nffs_file *file = (struct nffs_file *)fs_file;

    nffs_lock();
     3d8:	f7ff ff4c 	bl	274 <nffs_lock>

    if (!nffs_misc_ready()) {
     3dc:	f001 fca0 	bl	1d20 <nffs_misc_ready>
     3e0:	b130      	cbz	r0, 3f0 <nffs_write+0x20>
        rc = FS_EUNINIT;
        goto done;
    }

    rc = nffs_write_to_file(file, data, len);
     3e2:	4622      	mov	r2, r4
     3e4:	4630      	mov	r0, r6
     3e6:	4629      	mov	r1, r5
     3e8:	f002 f9c8 	bl	277c <nffs_write_to_file>
     3ec:	4604      	mov	r4, r0
     3ee:	e000      	b.n	3f2 <nffs_write+0x22>
    struct nffs_file *file = (struct nffs_file *)fs_file;

    nffs_lock();

    if (!nffs_misc_ready()) {
        rc = FS_EUNINIT;
     3f0:	240d      	movs	r4, #13
    }

    rc = 0;

done:
    nffs_unlock();
     3f2:	f7ff ff53 	bl	29c <nffs_unlock>
    return rc;
}
     3f6:	4620      	mov	r0, r4
     3f8:	bd70      	pop	{r4, r5, r6, pc}

000003fa <nffs_read>:
 * @return                  0 on success; nonzero on failure.
 */
static int
nffs_read(struct fs_file *fs_file, uint32_t len, void *out_data,
          uint32_t *out_len)
{
     3fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     3fc:	4607      	mov	r7, r0
     3fe:	460e      	mov	r6, r1
     400:	4615      	mov	r5, r2
     402:	461c      	mov	r4, r3
    int rc;
    struct nffs_file *file = (struct nffs_file *)fs_file;

    nffs_lock();
     404:	f7ff ff36 	bl	274 <nffs_lock>
    rc = nffs_file_read(file, len, out_data, out_len);
     408:	4623      	mov	r3, r4
     40a:	4631      	mov	r1, r6
     40c:	462a      	mov	r2, r5
     40e:	4638      	mov	r0, r7
     410:	f000 fc0f 	bl	c32 <nffs_file_read>
     414:	4604      	mov	r4, r0
    nffs_unlock();
     416:	f7ff ff41 	bl	29c <nffs_unlock>

    return rc;
}
     41a:	4620      	mov	r0, r4
     41c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000041e <nffs_close>:
 *
 * @return                  0 on success; nonzero on failure.
 */
static int
nffs_close(struct fs_file *fs_file)
{
     41e:	b510      	push	{r4, lr}
    int rc;
    struct nffs_file *file = (struct nffs_file *)fs_file;

    if (file == NULL) {
     420:	4604      	mov	r4, r0
     422:	b138      	cbz	r0, 434 <nffs_close+0x16>
        return 0;
    }

    nffs_lock();
     424:	f7ff ff26 	bl	274 <nffs_lock>
    rc = nffs_file_close(file);
     428:	4620      	mov	r0, r4
     42a:	f000 fc25 	bl	c78 <nffs_file_close>
     42e:	4604      	mov	r4, r0
    nffs_unlock();
     430:	f7ff ff34 	bl	29c <nffs_unlock>
{
    int rc;
    struct nffs_file *file = (struct nffs_file *)fs_file;

    if (file == NULL) {
        return 0;
     434:	4620      	mov	r0, r4
    nffs_lock();
    rc = nffs_file_close(file);
    nffs_unlock();

    return rc;
}
     436:	bd10      	pop	{r4, pc}

00000438 <nffs_open>:
 *
 * @return                  0 on success; nonzero on failure.
 */
static int
nffs_open(const char *path, uint8_t access_flags, struct fs_file **out_fs_file)
{
     438:	b573      	push	{r0, r1, r4, r5, r6, lr}
     43a:	4606      	mov	r6, r0
     43c:	460c      	mov	r4, r1
     43e:	4615      	mov	r5, r2
    int rc;
    struct nffs_file *out_file;

    nffs_lock();
     440:	f7ff ff18 	bl	274 <nffs_lock>

    if (!nffs_misc_ready()) {
     444:	f001 fc6c 	bl	1d20 <nffs_misc_ready>
     448:	b148      	cbz	r0, 45e <nffs_open+0x26>
        rc = FS_EUNINIT;
        goto done;
    }

    rc = nffs_file_open(&out_file, path, access_flags);
     44a:	4622      	mov	r2, r4
     44c:	a801      	add	r0, sp, #4
     44e:	4631      	mov	r1, r6
     450:	f000 fb70 	bl	b34 <nffs_file_open>
    if (rc != 0) {
     454:	4604      	mov	r4, r0
     456:	b918      	cbnz	r0, 460 <nffs_open+0x28>
        goto done;
    }
    *out_fs_file = (struct fs_file *)out_file;
     458:	9b01      	ldr	r3, [sp, #4]
     45a:	602b      	str	r3, [r5, #0]
     45c:	e000      	b.n	460 <nffs_open+0x28>
    struct nffs_file *out_file;

    nffs_lock();

    if (!nffs_misc_ready()) {
        rc = FS_EUNINIT;
     45e:	240d      	movs	r4, #13
    if (rc != 0) {
        goto done;
    }
    *out_fs_file = (struct fs_file *)out_file;
done:
    nffs_unlock();
     460:	f7ff ff1c 	bl	29c <nffs_unlock>
    if (rc != 0) {
     464:	b10c      	cbz	r4, 46a <nffs_open+0x32>
        *out_fs_file = NULL;
     466:	2300      	movs	r3, #0
     468:	602b      	str	r3, [r5, #0]
    }
    return rc;
}
     46a:	4620      	mov	r0, r4
     46c:	b002      	add	sp, #8
     46e:	bd70      	pop	{r4, r5, r6, pc}

00000470 <nffs_dirent_is_dir>:
 * @return                      1: The entry is a directory;
 *                              0: The entry is a regular file.
 */
static int
nffs_dirent_is_dir(const struct fs_dirent *fs_dirent)
{
     470:	b510      	push	{r4, lr}
     472:	4604      	mov	r4, r0
    uint32_t id;
    const struct nffs_dirent *dirent = (const struct nffs_dirent *)fs_dirent;

    nffs_lock();
     474:	f7ff fefe 	bl	274 <nffs_lock>

    assert(dirent != NULL && dirent->nde_inode_entry != NULL);
     478:	b10c      	cbz	r4, 47e <nffs_dirent_is_dir+0xe>
     47a:	6823      	ldr	r3, [r4, #0]
     47c:	b933      	cbnz	r3, 48c <nffs_dirent_is_dir+0x1c>
     47e:	2200      	movs	r2, #0
     480:	4806      	ldr	r0, [pc, #24]	; (49c <nffs_dirent_is_dir+0x2c>)
     482:	f240 212e 	movw	r1, #558	; 0x22e
     486:	4613      	mov	r3, r2
     488:	f004 fbe0 	bl	4c4c <__assert_func>
    id = dirent->nde_inode_entry->nie_hash_entry.nhe_id;
     48c:	685c      	ldr	r4, [r3, #4]

    nffs_unlock();
     48e:	f7ff ff05 	bl	29c <nffs_unlock>

    return nffs_hash_id_is_dir(id);
     492:	4620      	mov	r0, r4
}
     494:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    assert(dirent != NULL && dirent->nde_inode_entry != NULL);
    id = dirent->nde_inode_entry->nie_hash_entry.nhe_id;

    nffs_unlock();

    return nffs_hash_id_is_dir(id);
     498:	f000 bd02 	b.w	ea0 <nffs_hash_id_is_dir>
     49c:	000061b8 	.word	0x000061b8

000004a0 <nffs_dirent_name>:
 * @return                      0 on success; nonzero on failure.
 */
static int
nffs_dirent_name(const struct fs_dirent *fs_dirent, size_t max_len,
                 char *out_name, uint8_t *out_name_len)
{
     4a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     4a2:	4604      	mov	r4, r0
     4a4:	460f      	mov	r7, r1
     4a6:	4616      	mov	r6, r2
     4a8:	461d      	mov	r5, r3
    int rc;
    struct nffs_dirent *dirent = (struct nffs_dirent *)fs_dirent;

    nffs_lock();
     4aa:	f7ff fee3 	bl	274 <nffs_lock>

    assert(dirent != NULL && dirent->nde_inode_entry != NULL);
     4ae:	b10c      	cbz	r4, 4b4 <nffs_dirent_name+0x14>
     4b0:	6820      	ldr	r0, [r4, #0]
     4b2:	b930      	cbnz	r0, 4c2 <nffs_dirent_name+0x22>
     4b4:	2200      	movs	r2, #0
     4b6:	4808      	ldr	r0, [pc, #32]	; (4d8 <nffs_dirent_name+0x38>)
     4b8:	f44f 7105 	mov.w	r1, #532	; 0x214
     4bc:	4613      	mov	r3, r2
     4be:	f004 fbc5 	bl	4c4c <__assert_func>
    rc = nffs_inode_read_filename(dirent->nde_inode_entry, max_len, out_name,
     4c2:	4639      	mov	r1, r7
     4c4:	4632      	mov	r2, r6
     4c6:	462b      	mov	r3, r5
     4c8:	f001 f923 	bl	1712 <nffs_inode_read_filename>
     4cc:	4604      	mov	r4, r0
                                  out_name_len);

    nffs_unlock();
     4ce:	f7ff fee5 	bl	29c <nffs_unlock>

    return rc;
}
     4d2:	4620      	mov	r0, r4
     4d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     4d6:	bf00      	nop
     4d8:	000061b8 	.word	0x000061b8

000004dc <nffs_detect>:
 *                          FS_ECORRUPT if no valid file system was detected;
 *                          other nonzero on error.
 */
int
nffs_detect(const struct nffs_area_desc *area_descs)
{
     4dc:	b510      	push	{r4, lr}
     4de:	4604      	mov	r4, r0
    int rc;

    nffs_lock();
     4e0:	f7ff fec8 	bl	274 <nffs_lock>
    rc = nffs_restore_full(area_descs);
     4e4:	4620      	mov	r0, r4
     4e6:	f002 f87f 	bl	25e8 <nffs_restore_full>
     4ea:	4604      	mov	r4, r0
    nffs_unlock();
     4ec:	f7ff fed6 	bl	29c <nffs_unlock>

    return rc;
}
     4f0:	4620      	mov	r0, r4
     4f2:	bd10      	pop	{r4, pc}

000004f4 <nffs_init>:
 *
 * @return                  0 on success; nonzero on error.
 */
int
nffs_init(void)
{
     4f4:	b570      	push	{r4, r5, r6, lr}
    int rc;

    nffs_config_init();
     4f6:	f000 fa27 	bl	948 <nffs_config_init>

    nffs_cache_clear();
     4fa:	f000 fa13 	bl	924 <nffs_cache_clear>

    rc = os_mutex_init(&nffs_mutex);
     4fe:	4831      	ldr	r0, [pc, #196]	; (5c4 <nffs_init+0xd0>)
     500:	f004 fc87 	bl	4e12 <os_mutex_init>
    if (rc != 0) {
     504:	2800      	cmp	r0, #0
     506:	d158      	bne.n	5ba <nffs_init+0xc6>
        return FS_EOS;
    }

    free(nffs_file_mem);
     508:	4d2f      	ldr	r5, [pc, #188]	; (5c8 <nffs_init+0xd4>)
    nffs_file_mem = malloc(
        OS_MEMPOOL_BYTES(nffs_config.nc_num_files, sizeof (struct nffs_file)));
     50a:	4c30      	ldr	r4, [pc, #192]	; (5cc <nffs_init+0xd8>)
    rc = os_mutex_init(&nffs_mutex);
    if (rc != 0) {
        return FS_EOS;
    }

    free(nffs_file_mem);
     50c:	6828      	ldr	r0, [r5, #0]
     50e:	f004 fbf5 	bl	4cfc <os_free>
    nffs_file_mem = malloc(
        OS_MEMPOOL_BYTES(nffs_config.nc_num_files, sizeof (struct nffs_file)));
     512:	68a0      	ldr	r0, [r4, #8]
     514:	260c      	movs	r6, #12
    if (rc != 0) {
        return FS_EOS;
    }

    free(nffs_file_mem);
    nffs_file_mem = malloc(
     516:	4370      	muls	r0, r6
     518:	f004 fbe4 	bl	4ce4 <os_malloc>
     51c:	6028      	str	r0, [r5, #0]
        OS_MEMPOOL_BYTES(nffs_config.nc_num_files, sizeof (struct nffs_file)));
    if (nffs_file_mem == NULL) {
     51e:	b908      	cbnz	r0, 524 <nffs_init+0x30>
        return FS_ENOMEM;
     520:	2005      	movs	r0, #5
     522:	bd70      	pop	{r4, r5, r6, pc}
    }

    free(nffs_inode_mem);
     524:	4d2a      	ldr	r5, [pc, #168]	; (5d0 <nffs_init+0xdc>)
     526:	6828      	ldr	r0, [r5, #0]
     528:	f004 fbe8 	bl	4cfc <os_free>
    nffs_inode_mem = malloc(
        OS_MEMPOOL_BYTES(nffs_config.nc_num_inodes,
     52c:	6823      	ldr	r3, [r4, #0]
    if (nffs_file_mem == NULL) {
        return FS_ENOMEM;
    }

    free(nffs_inode_mem);
    nffs_inode_mem = malloc(
     52e:	2018      	movs	r0, #24
     530:	4358      	muls	r0, r3
     532:	f004 fbd7 	bl	4ce4 <os_malloc>
     536:	6028      	str	r0, [r5, #0]
        OS_MEMPOOL_BYTES(nffs_config.nc_num_inodes,
                        sizeof (struct nffs_inode_entry)));
    if (nffs_inode_mem == NULL) {
     538:	2800      	cmp	r0, #0
     53a:	d0f1      	beq.n	520 <nffs_init+0x2c>
        return FS_ENOMEM;
    }

    free(nffs_block_entry_mem);
     53c:	4d25      	ldr	r5, [pc, #148]	; (5d4 <nffs_init+0xe0>)
     53e:	6828      	ldr	r0, [r5, #0]
     540:	f004 fbdc 	bl	4cfc <os_free>
    nffs_block_entry_mem = malloc(
        OS_MEMPOOL_BYTES(nffs_config.nc_num_blocks,
     544:	6860      	ldr	r0, [r4, #4]
    if (nffs_inode_mem == NULL) {
        return FS_ENOMEM;
    }

    free(nffs_block_entry_mem);
    nffs_block_entry_mem = malloc(
     546:	4370      	muls	r0, r6
     548:	f004 fbcc 	bl	4ce4 <os_malloc>
     54c:	6028      	str	r0, [r5, #0]
        OS_MEMPOOL_BYTES(nffs_config.nc_num_blocks,
                         sizeof (struct nffs_hash_entry)));
    if (nffs_block_entry_mem == NULL) {
     54e:	2800      	cmp	r0, #0
     550:	d0e6      	beq.n	520 <nffs_init+0x2c>
        return FS_ENOMEM;
    }

    free(nffs_cache_inode_mem);
     552:	4d21      	ldr	r5, [pc, #132]	; (5d8 <nffs_init+0xe4>)
     554:	6828      	ldr	r0, [r5, #0]
     556:	f004 fbd1 	bl	4cfc <os_free>
    nffs_cache_inode_mem = malloc(
        OS_MEMPOOL_BYTES(nffs_config.nc_num_cache_inodes,
     55a:	6923      	ldr	r3, [r4, #16]
    if (nffs_block_entry_mem == NULL) {
        return FS_ENOMEM;
    }

    free(nffs_cache_inode_mem);
    nffs_cache_inode_mem = malloc(
     55c:	2024      	movs	r0, #36	; 0x24
     55e:	4358      	muls	r0, r3
     560:	f004 fbc0 	bl	4ce4 <os_malloc>
     564:	6028      	str	r0, [r5, #0]
        OS_MEMPOOL_BYTES(nffs_config.nc_num_cache_inodes,
                         sizeof (struct nffs_cache_inode)));
    if (nffs_cache_inode_mem == NULL) {
     566:	2800      	cmp	r0, #0
     568:	d0da      	beq.n	520 <nffs_init+0x2c>
        return FS_ENOMEM;
    }

    free(nffs_cache_block_mem);
     56a:	4d1c      	ldr	r5, [pc, #112]	; (5dc <nffs_init+0xe8>)
     56c:	6828      	ldr	r0, [r5, #0]
     56e:	f004 fbc5 	bl	4cfc <os_free>
    nffs_cache_block_mem = malloc(
        OS_MEMPOOL_BYTES(nffs_config.nc_num_cache_blocks,
     572:	6960      	ldr	r0, [r4, #20]
    if (nffs_cache_inode_mem == NULL) {
        return FS_ENOMEM;
    }

    free(nffs_cache_block_mem);
    nffs_cache_block_mem = malloc(
     574:	0140      	lsls	r0, r0, #5
     576:	f004 fbb5 	bl	4ce4 <os_malloc>
     57a:	6028      	str	r0, [r5, #0]
        OS_MEMPOOL_BYTES(nffs_config.nc_num_cache_blocks,
                         sizeof (struct nffs_cache_block)));
    if (nffs_cache_block_mem == NULL) {
     57c:	2800      	cmp	r0, #0
     57e:	d0cf      	beq.n	520 <nffs_init+0x2c>
        return FS_ENOMEM;
    }

    free(nffs_dir_mem);
     580:	4d17      	ldr	r5, [pc, #92]	; (5e0 <nffs_init+0xec>)
     582:	6828      	ldr	r0, [r5, #0]
     584:	f004 fbba 	bl	4cfc <os_free>
    nffs_dir_mem = malloc(
        OS_MEMPOOL_BYTES(nffs_config.nc_num_dirs,
     588:	68e0      	ldr	r0, [r4, #12]
    if (nffs_cache_block_mem == NULL) {
        return FS_ENOMEM;
    }

    free(nffs_dir_mem);
    nffs_dir_mem = malloc(
     58a:	00c0      	lsls	r0, r0, #3
     58c:	f004 fbaa 	bl	4ce4 <os_malloc>
     590:	6028      	str	r0, [r5, #0]
        OS_MEMPOOL_BYTES(nffs_config.nc_num_dirs,
                         sizeof (struct nffs_dir)));
    if (nffs_dir_mem == NULL) {
     592:	2800      	cmp	r0, #0
     594:	d0c4      	beq.n	520 <nffs_init+0x2c>
        return FS_ENOMEM;
    }

    log_init();
     596:	f005 fa3b 	bl	5a10 <log_init>
    log_console_handler_init(&nffs_log_console_handler);
     59a:	4812      	ldr	r0, [pc, #72]	; (5e4 <nffs_init+0xf0>)
     59c:	f005 fa56 	bl	5a4c <log_console_handler_init>
    log_register("nffs", &nffs_log, &nffs_log_console_handler);
     5a0:	4911      	ldr	r1, [pc, #68]	; (5e8 <nffs_init+0xf4>)
     5a2:	4a10      	ldr	r2, [pc, #64]	; (5e4 <nffs_init+0xf0>)
     5a4:	4811      	ldr	r0, [pc, #68]	; (5ec <nffs_init+0xf8>)
     5a6:	f005 fa3d 	bl	5a24 <log_register>

    rc = nffs_misc_reset();
     5aa:	f001 fb1d 	bl	1be8 <nffs_misc_reset>
    if (rc != 0) {
     5ae:	4604      	mov	r4, r0
     5b0:	b928      	cbnz	r0, 5be <nffs_init+0xca>
        return rc;
    }

    fs_register(&nffs_ops);
     5b2:	480f      	ldr	r0, [pc, #60]	; (5f0 <nffs_init+0xfc>)
     5b4:	f005 fa8e 	bl	5ad4 <fs_register>
     5b8:	e001      	b.n	5be <nffs_init+0xca>

    nffs_cache_clear();

    rc = os_mutex_init(&nffs_mutex);
    if (rc != 0) {
        return FS_EOS;
     5ba:	200a      	movs	r0, #10
     5bc:	bd70      	pop	{r4, r5, r6, pc}
     5be:	4620      	mov	r0, r4
        return rc;
    }

    fs_register(&nffs_ops);
    return 0;
}
     5c0:	bd70      	pop	{r4, r5, r6, pc}
     5c2:	bf00      	nop
     5c4:	200005d0 	.word	0x200005d0
     5c8:	20000b28 	.word	0x20000b28
     5cc:	20000b84 	.word	0x20000b84
     5d0:	20000b30 	.word	0x20000b30
     5d4:	20000b80 	.word	0x20000b80
     5d8:	20000aa8 	.word	0x20000aa8
     5dc:	20000b2c 	.word	0x20000b2c
     5e0:	20000b7c 	.word	0x20000b7c
     5e4:	200005dc 	.word	0x200005dc
     5e8:	20000b34 	.word	0x20000b34
     5ec:	000061bf 	.word	0x000061bf
     5f0:	000061c4 	.word	0x000061c4

000005f4 <nffs_cache_inode_free_blocks>:
    return entry;
}

static void
nffs_cache_inode_free_blocks(struct nffs_cache_inode *cache_inode)
{
     5f4:	b510      	push	{r4, lr}
     5f6:	4604      	mov	r4, r0
    struct nffs_cache_block *cache_block;

    while ((cache_block = TAILQ_FIRST(&cache_inode->nci_block_list)) != NULL) {
     5f8:	69a1      	ldr	r1, [r4, #24]
     5fa:	b159      	cbz	r1, 614 <nffs_cache_inode_free_blocks+0x20>
        TAILQ_REMOVE(&cache_inode->nci_block_list, cache_block, ncb_link);
     5fc:	680b      	ldr	r3, [r1, #0]
     5fe:	684a      	ldr	r2, [r1, #4]
     600:	b10b      	cbz	r3, 606 <nffs_cache_inode_free_blocks+0x12>
     602:	605a      	str	r2, [r3, #4]
     604:	e000      	b.n	608 <nffs_cache_inode_free_blocks+0x14>
     606:	61e2      	str	r2, [r4, #28]
     608:	684a      	ldr	r2, [r1, #4]

static void
nffs_cache_block_free(struct nffs_cache_block *entry)
{
    if (entry != NULL) {
        os_memblock_put(&nffs_cache_block_pool, entry);
     60a:	4803      	ldr	r0, [pc, #12]	; (618 <nffs_cache_inode_free_blocks+0x24>)
nffs_cache_inode_free_blocks(struct nffs_cache_inode *cache_inode)
{
    struct nffs_cache_block *cache_block;

    while ((cache_block = TAILQ_FIRST(&cache_inode->nci_block_list)) != NULL) {
        TAILQ_REMOVE(&cache_inode->nci_block_list, cache_block, ncb_link);
     60c:	6013      	str	r3, [r2, #0]

static void
nffs_cache_block_free(struct nffs_cache_block *entry)
{
    if (entry != NULL) {
        os_memblock_put(&nffs_cache_block_pool, entry);
     60e:	f004 fbd7 	bl	4dc0 <os_memblock_put>
     612:	e7f1      	b.n	5f8 <nffs_cache_inode_free_blocks+0x4>

    while ((cache_block = TAILQ_FIRST(&cache_inode->nci_block_list)) != NULL) {
        TAILQ_REMOVE(&cache_inode->nci_block_list, cache_block, ncb_link);
        nffs_cache_block_free(cache_block);
    }
}
     614:	bd10      	pop	{r4, pc}
     616:	bf00      	nop
     618:	20000ae8 	.word	0x20000ae8

0000061c <nffs_cache_inode_free>:

static void
nffs_cache_inode_free(struct nffs_cache_inode *entry)
{
     61c:	b510      	push	{r4, lr}
    if (entry != NULL) {
     61e:	4604      	mov	r4, r0
     620:	b138      	cbz	r0, 632 <nffs_cache_inode_free+0x16>
        nffs_cache_inode_free_blocks(entry);
     622:	f7ff ffe7 	bl	5f4 <nffs_cache_inode_free_blocks>
        os_memblock_put(&nffs_cache_inode_pool, entry);
     626:	4621      	mov	r1, r4
     628:	4802      	ldr	r0, [pc, #8]	; (634 <nffs_cache_inode_free+0x18>)
    }
}
     62a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static void
nffs_cache_inode_free(struct nffs_cache_inode *entry)
{
    if (entry != NULL) {
        nffs_cache_inode_free_blocks(entry);
        os_memblock_put(&nffs_cache_inode_pool, entry);
     62e:	f004 bbc7 	b.w	4dc0 <os_memblock_put>
     632:	bd10      	pop	{r4, pc}
     634:	20000a88 	.word	0x20000a88

00000638 <nffs_cache_inode_alloc>:
    return 0;
}

static struct nffs_cache_inode *
nffs_cache_inode_alloc(void)
{
     638:	b510      	push	{r4, lr}
    struct nffs_cache_inode *entry;

    entry = os_memblock_get(&nffs_cache_inode_pool);
     63a:	4808      	ldr	r0, [pc, #32]	; (65c <nffs_cache_inode_alloc+0x24>)
     63c:	f004 fbac 	bl	4d98 <os_memblock_get>
    if (entry != NULL) {
     640:	4604      	mov	r4, r0
     642:	b140      	cbz	r0, 656 <nffs_cache_inode_alloc+0x1e>
        memset(entry, 0, sizeof *entry);
     644:	2224      	movs	r2, #36	; 0x24
     646:	2100      	movs	r1, #0
     648:	f003 f98c 	bl	3964 <memset>
        TAILQ_INIT(&entry->nci_block_list);
     64c:	4623      	mov	r3, r4
     64e:	2200      	movs	r2, #0
     650:	f843 2f18 	str.w	r2, [r3, #24]!
     654:	61e3      	str	r3, [r4, #28]
    }

    return entry;
}
     656:	4620      	mov	r0, r4
     658:	bd10      	pop	{r4, pc}
     65a:	bf00      	nop
     65c:	20000a88 	.word	0x20000a88

00000660 <nffs_cache_block_alloc>:

static void nffs_cache_reclaim_blocks(void);

static struct nffs_cache_block *
nffs_cache_block_alloc(void)
{
     660:	b510      	push	{r4, lr}
    struct nffs_cache_block *entry;

    entry = os_memblock_get(&nffs_cache_block_pool);
     662:	4805      	ldr	r0, [pc, #20]	; (678 <nffs_cache_block_alloc+0x18>)
     664:	f004 fb98 	bl	4d98 <os_memblock_get>
    if (entry != NULL) {
     668:	4604      	mov	r4, r0
     66a:	b118      	cbz	r0, 674 <nffs_cache_block_alloc+0x14>
        memset(entry, 0, sizeof *entry);
     66c:	2100      	movs	r1, #0
     66e:	2220      	movs	r2, #32
     670:	f003 f978 	bl	3964 <memset>
    }

    return entry;
}
     674:	4620      	mov	r0, r4
     676:	bd10      	pop	{r4, pc}
     678:	20000ae8 	.word	0x20000ae8

0000067c <nffs_cache_block_acquire>:
    }
}

static struct nffs_cache_block *
nffs_cache_block_acquire(void)
{
     67c:	b508      	push	{r3, lr}
    struct nffs_cache_block *cache_block;

    cache_block = nffs_cache_block_alloc();
     67e:	f7ff ffef 	bl	660 <nffs_cache_block_alloc>
    if (cache_block == NULL) {
     682:	4602      	mov	r2, r0
     684:	b9b8      	cbnz	r0, 6b6 <nffs_cache_block_acquire+0x3a>
static void
nffs_cache_reclaim_blocks(void)
{
    struct nffs_cache_inode *cache_inode;

    TAILQ_FOREACH_REVERSE(cache_inode, &nffs_cache_inode_list,
     686:	4b0d      	ldr	r3, [pc, #52]	; (6bc <nffs_cache_block_acquire+0x40>)
     688:	685b      	ldr	r3, [r3, #4]
     68a:	685b      	ldr	r3, [r3, #4]
     68c:	681a      	ldr	r2, [r3, #0]
     68e:	b16a      	cbz	r2, 6ac <nffs_cache_block_acquire+0x30>
                          nffs_cache_inode_list, nci_link) {
        if (!TAILQ_EMPTY(&cache_inode->nci_block_list)) {
     690:	6993      	ldr	r3, [r2, #24]
     692:	b14b      	cbz	r3, 6a8 <nffs_cache_block_acquire+0x2c>
            nffs_cache_inode_free_blocks(cache_inode);
     694:	4610      	mov	r0, r2
     696:	f7ff ffad 	bl	5f4 <nffs_cache_inode_free_blocks>
    struct nffs_cache_block *cache_block;

    cache_block = nffs_cache_block_alloc();
    if (cache_block == NULL) {
        nffs_cache_reclaim_blocks();
        cache_block = nffs_cache_block_alloc();
     69a:	f7ff ffe1 	bl	660 <nffs_cache_block_alloc>
    }

    assert(cache_block != NULL);
     69e:	4602      	mov	r2, r0
     6a0:	b948      	cbnz	r0, 6b6 <nffs_cache_block_acquire+0x3a>
     6a2:	4807      	ldr	r0, [pc, #28]	; (6c0 <nffs_cache_block_acquire+0x44>)
     6a4:	213f      	movs	r1, #63	; 0x3f
     6a6:	e003      	b.n	6b0 <nffs_cache_block_acquire+0x34>
static void
nffs_cache_reclaim_blocks(void)
{
    struct nffs_cache_inode *cache_inode;

    TAILQ_FOREACH_REVERSE(cache_inode, &nffs_cache_inode_list,
     6a8:	6853      	ldr	r3, [r2, #4]
     6aa:	e7ee      	b.n	68a <nffs_cache_block_acquire+0xe>
            nffs_cache_inode_free_blocks(cache_inode);
            return;
        }
    }

    assert(0);
     6ac:	4804      	ldr	r0, [pc, #16]	; (6c0 <nffs_cache_block_acquire+0x44>)
     6ae:	21e6      	movs	r1, #230	; 0xe6
    if (cache_block == NULL) {
        nffs_cache_reclaim_blocks();
        cache_block = nffs_cache_block_alloc();
    }

    assert(cache_block != NULL);
     6b0:	4613      	mov	r3, r2
     6b2:	f004 facb 	bl	4c4c <__assert_func>

    return cache_block;
}
     6b6:	4610      	mov	r0, r2
     6b8:	bd08      	pop	{r3, pc}
     6ba:	bf00      	nop
     6bc:	200000ec 	.word	0x200000ec
     6c0:	00006204 	.word	0x00006204

000006c4 <nffs_cache_inode_range>:
nffs_cache_inode_range(const struct nffs_cache_inode *cache_inode,
                      uint32_t *out_start, uint32_t *out_end)
{
    struct nffs_cache_block *cache_block;

    cache_block = TAILQ_FIRST(&cache_inode->nci_block_list);
     6c4:	6983      	ldr	r3, [r0, #24]
    if (cache_block == NULL) {
     6c6:	b90b      	cbnz	r3, 6cc <nffs_cache_inode_range+0x8>
        *out_start = 0;
     6c8:	600b      	str	r3, [r1, #0]
     6ca:	e007      	b.n	6dc <nffs_cache_inode_range+0x18>
        *out_end = 0;
        return;
    }

    *out_start = cache_block->ncb_file_offset;
     6cc:	69db      	ldr	r3, [r3, #28]
     6ce:	600b      	str	r3, [r1, #0]

    cache_block = TAILQ_LAST(&cache_inode->nci_block_list,
     6d0:	69c3      	ldr	r3, [r0, #28]
     6d2:	685b      	ldr	r3, [r3, #4]
     6d4:	6819      	ldr	r1, [r3, #0]
                             nffs_cache_block_list);
    *out_end = cache_block->ncb_file_offset +
     6d6:	8b08      	ldrh	r0, [r1, #24]
     6d8:	69cb      	ldr	r3, [r1, #28]
     6da:	4403      	add	r3, r0
     6dc:	6013      	str	r3, [r2, #0]
     6de:	4770      	bx	lr

000006e0 <nffs_cache_inode_delete>:
static struct nffs_cache_inode *
nffs_cache_inode_find(const struct nffs_inode_entry *inode_entry)
{
    struct nffs_cache_inode *cur;

    TAILQ_FOREACH(cur, &nffs_cache_inode_list, nci_link) {
     6e0:	4a09      	ldr	r2, [pc, #36]	; (708 <nffs_cache_inode_delete+0x28>)
     6e2:	6813      	ldr	r3, [r2, #0]
     6e4:	b14b      	cbz	r3, 6fa <nffs_cache_inode_delete+0x1a>
        if (cur->nci_inode.ni_inode_entry == inode_entry) {
     6e6:	6899      	ldr	r1, [r3, #8]
     6e8:	4281      	cmp	r1, r0
     6ea:	d104      	bne.n	6f6 <nffs_cache_inode_delete+0x16>
    entry = nffs_cache_inode_find(inode_entry);
    if (entry == NULL) {
        return;
    }

    TAILQ_REMOVE(&nffs_cache_inode_list, entry, nci_link);
     6ec:	6819      	ldr	r1, [r3, #0]
     6ee:	6858      	ldr	r0, [r3, #4]
     6f0:	b121      	cbz	r1, 6fc <nffs_cache_inode_delete+0x1c>
     6f2:	6048      	str	r0, [r1, #4]
     6f4:	e003      	b.n	6fe <nffs_cache_inode_delete+0x1e>
static struct nffs_cache_inode *
nffs_cache_inode_find(const struct nffs_inode_entry *inode_entry)
{
    struct nffs_cache_inode *cur;

    TAILQ_FOREACH(cur, &nffs_cache_inode_list, nci_link) {
     6f6:	681b      	ldr	r3, [r3, #0]
     6f8:	e7f4      	b.n	6e4 <nffs_cache_inode_delete+0x4>
     6fa:	4770      	bx	lr
    entry = nffs_cache_inode_find(inode_entry);
    if (entry == NULL) {
        return;
    }

    TAILQ_REMOVE(&nffs_cache_inode_list, entry, nci_link);
     6fc:	6050      	str	r0, [r2, #4]
     6fe:	685a      	ldr	r2, [r3, #4]
    nffs_cache_inode_free(entry);
     700:	4618      	mov	r0, r3
    entry = nffs_cache_inode_find(inode_entry);
    if (entry == NULL) {
        return;
    }

    TAILQ_REMOVE(&nffs_cache_inode_list, entry, nci_link);
     702:	6011      	str	r1, [r2, #0]
    nffs_cache_inode_free(entry);
     704:	f7ff bf8a 	b.w	61c <nffs_cache_inode_free>
     708:	200000ec 	.word	0x200000ec

0000070c <nffs_cache_inode_ensure>:
}

int
nffs_cache_inode_ensure(struct nffs_cache_inode **out_cache_inode,
                        struct nffs_inode_entry *inode_entry)
{
     70c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
static struct nffs_cache_inode *
nffs_cache_inode_find(const struct nffs_inode_entry *inode_entry)
{
    struct nffs_cache_inode *cur;

    TAILQ_FOREACH(cur, &nffs_cache_inode_list, nci_link) {
     70e:	4d27      	ldr	r5, [pc, #156]	; (7ac <nffs_cache_inode_ensure+0xa0>)
     710:	682c      	ldr	r4, [r5, #0]
}

int
nffs_cache_inode_ensure(struct nffs_cache_inode **out_cache_inode,
                        struct nffs_inode_entry *inode_entry)
{
     712:	4607      	mov	r7, r0
     714:	460e      	mov	r6, r1
static struct nffs_cache_inode *
nffs_cache_inode_find(const struct nffs_inode_entry *inode_entry)
{
    struct nffs_cache_inode *cur;

    TAILQ_FOREACH(cur, &nffs_cache_inode_list, nci_link) {
     716:	b124      	cbz	r4, 722 <nffs_cache_inode_ensure+0x16>
        if (cur->nci_inode.ni_inode_entry == inode_entry) {
     718:	68a3      	ldr	r3, [r4, #8]
     71a:	42b3      	cmp	r3, r6
     71c:	d042      	beq.n	7a4 <nffs_cache_inode_ensure+0x98>
static struct nffs_cache_inode *
nffs_cache_inode_find(const struct nffs_inode_entry *inode_entry)
{
    struct nffs_cache_inode *cur;

    TAILQ_FOREACH(cur, &nffs_cache_inode_list, nci_link) {
     71e:	6824      	ldr	r4, [r4, #0]
     720:	e7f9      	b.n	716 <nffs_cache_inode_ensure+0xa>
static struct nffs_cache_inode *
nffs_cache_inode_acquire(void)
{
    struct nffs_cache_inode *entry;

    entry = nffs_cache_inode_alloc();
     722:	f7ff ff89 	bl	638 <nffs_cache_inode_alloc>
    if (entry == NULL) {
     726:	4604      	mov	r4, r0
     728:	b9d8      	cbnz	r0, 762 <nffs_cache_inode_ensure+0x56>
        entry = TAILQ_LAST(&nffs_cache_inode_list, nffs_cache_inode_list);
     72a:	686b      	ldr	r3, [r5, #4]
     72c:	685b      	ldr	r3, [r3, #4]
     72e:	6818      	ldr	r0, [r3, #0]
        assert(entry != NULL);
     730:	b910      	cbnz	r0, 738 <nffs_cache_inode_ensure+0x2c>
     732:	481f      	ldr	r0, [pc, #124]	; (7b0 <nffs_cache_inode_ensure+0xa4>)
     734:	2180      	movs	r1, #128	; 0x80
     736:	e010      	b.n	75a <nffs_cache_inode_ensure+0x4e>

        TAILQ_REMOVE(&nffs_cache_inode_list, entry, nci_link);
     738:	6803      	ldr	r3, [r0, #0]
     73a:	6842      	ldr	r2, [r0, #4]
     73c:	b10b      	cbz	r3, 742 <nffs_cache_inode_ensure+0x36>
     73e:	605a      	str	r2, [r3, #4]
     740:	e001      	b.n	746 <nffs_cache_inode_ensure+0x3a>
     742:	491a      	ldr	r1, [pc, #104]	; (7ac <nffs_cache_inode_ensure+0xa0>)
     744:	604a      	str	r2, [r1, #4]
     746:	6842      	ldr	r2, [r0, #4]
     748:	6013      	str	r3, [r2, #0]
        nffs_cache_inode_free(entry);
     74a:	f7ff ff67 	bl	61c <nffs_cache_inode_free>

        entry = nffs_cache_inode_alloc();
     74e:	f7ff ff73 	bl	638 <nffs_cache_inode_alloc>
    }

    assert(entry != NULL);
     752:	4604      	mov	r4, r0
     754:	b928      	cbnz	r0, 762 <nffs_cache_inode_ensure+0x56>
     756:	4816      	ldr	r0, [pc, #88]	; (7b0 <nffs_cache_inode_ensure+0xa4>)
     758:	2188      	movs	r1, #136	; 0x88
     75a:	4622      	mov	r2, r4
     75c:	4623      	mov	r3, r4
     75e:	f004 fa75 	bl	4c4c <__assert_func>
nffs_cache_inode_populate(struct nffs_cache_inode *cache_inode,
                         struct nffs_inode_entry *inode_entry)
{
    int rc;

    memset(cache_inode, 0, sizeof *cache_inode);
     762:	2100      	movs	r1, #0
     764:	2224      	movs	r2, #36	; 0x24
     766:	4620      	mov	r0, r4
     768:	f003 f8fc 	bl	3964 <memset>

    rc = nffs_inode_from_entry(&cache_inode->nci_inode, inode_entry);
     76c:	4631      	mov	r1, r6
     76e:	f104 0008 	add.w	r0, r4, #8
     772:	f000 ff81 	bl	1678 <nffs_inode_from_entry>
    if (rc != 0) {
     776:	4606      	mov	r6, r0
     778:	b970      	cbnz	r0, 798 <nffs_cache_inode_ensure+0x8c>
        return rc;
    }

    rc = nffs_inode_calc_data_length(cache_inode->nci_inode.ni_inode_entry,
     77a:	68a0      	ldr	r0, [r4, #8]
     77c:	f104 0120 	add.w	r1, r4, #32
     780:	f000 fd62 	bl	1248 <nffs_inode_calc_data_length>
                                     &cache_inode->nci_file_size);
    if (rc != 0) {
     784:	4606      	mov	r6, r0
     786:	b938      	cbnz	r0, 798 <nffs_cache_inode_ensure+0x8c>
    rc = nffs_cache_inode_populate(cache_inode, inode_entry);
    if (rc != 0) {
        goto done;
    }

    TAILQ_INSERT_HEAD(&nffs_cache_inode_list, cache_inode, nci_link);
     788:	682b      	ldr	r3, [r5, #0]
     78a:	6023      	str	r3, [r4, #0]
     78c:	b903      	cbnz	r3, 790 <nffs_cache_inode_ensure+0x84>
     78e:	4b07      	ldr	r3, [pc, #28]	; (7ac <nffs_cache_inode_ensure+0xa0>)
     790:	605c      	str	r4, [r3, #4]
     792:	602c      	str	r4, [r5, #0]
     794:	6065      	str	r5, [r4, #4]
     796:	e005      	b.n	7a4 <nffs_cache_inode_ensure+0x98>

done:
    if (rc == 0) {
        *out_cache_inode = cache_inode;
    } else {
        nffs_cache_inode_free(cache_inode);
     798:	4620      	mov	r0, r4
     79a:	f7ff ff3f 	bl	61c <nffs_cache_inode_free>
        *out_cache_inode = NULL;
     79e:	2300      	movs	r3, #0
     7a0:	603b      	str	r3, [r7, #0]
     7a2:	e001      	b.n	7a8 <nffs_cache_inode_ensure+0x9c>

    rc = 0;

done:
    if (rc == 0) {
        *out_cache_inode = cache_inode;
     7a4:	603c      	str	r4, [r7, #0]
     7a6:	2600      	movs	r6, #0
    } else {
        nffs_cache_inode_free(cache_inode);
        *out_cache_inode = NULL;
    }
    return rc;
}
     7a8:	4630      	mov	r0, r6
     7aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     7ac:	200000ec 	.word	0x200000ec
     7b0:	00006204 	.word	0x00006204

000007b4 <nffs_cache_inode_refresh>:
{
    struct nffs_cache_inode *cache_inode;
    struct nffs_inode_entry *inode_entry;
    int rc;

    TAILQ_FOREACH(cache_inode, &nffs_cache_inode_list, nci_link) {
     7b4:	4b07      	ldr	r3, [pc, #28]	; (7d4 <nffs_cache_inode_refresh+0x20>)
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_cache_inode_refresh(void)
{
     7b6:	b510      	push	{r4, lr}
    struct nffs_cache_inode *cache_inode;
    struct nffs_inode_entry *inode_entry;
    int rc;

    TAILQ_FOREACH(cache_inode, &nffs_cache_inode_list, nci_link) {
     7b8:	681c      	ldr	r4, [r3, #0]
        /* Clear entire block list. */
        nffs_cache_inode_free_blocks(cache_inode);
     7ba:	4620      	mov	r0, r4
{
    struct nffs_cache_inode *cache_inode;
    struct nffs_inode_entry *inode_entry;
    int rc;

    TAILQ_FOREACH(cache_inode, &nffs_cache_inode_list, nci_link) {
     7bc:	b14c      	cbz	r4, 7d2 <nffs_cache_inode_refresh+0x1e>
        /* Clear entire block list. */
        nffs_cache_inode_free_blocks(cache_inode);
     7be:	f7ff ff19 	bl	5f4 <nffs_cache_inode_free_blocks>

        inode_entry = cache_inode->nci_inode.ni_inode_entry;
        rc = nffs_inode_from_entry(&cache_inode->nci_inode, inode_entry);
     7c2:	f104 0008 	add.w	r0, r4, #8
     7c6:	68a1      	ldr	r1, [r4, #8]
     7c8:	f000 ff56 	bl	1678 <nffs_inode_from_entry>
        if (rc != 0) {
     7cc:	b908      	cbnz	r0, 7d2 <nffs_cache_inode_refresh+0x1e>
{
    struct nffs_cache_inode *cache_inode;
    struct nffs_inode_entry *inode_entry;
    int rc;

    TAILQ_FOREACH(cache_inode, &nffs_cache_inode_list, nci_link) {
     7ce:	6824      	ldr	r4, [r4, #0]
     7d0:	e7f3      	b.n	7ba <nffs_cache_inode_refresh+0x6>

        /* File size remains valid. */
    }

    return 0;
}
     7d2:	bd10      	pop	{r4, pc}
     7d4:	200000ec 	.word	0x200000ec

000007d8 <nffs_cache_insert_block>:
void
nffs_cache_insert_block(struct nffs_cache_inode *cache_inode,
                        struct nffs_cache_block *cache_block,
                        int tail)
{
    if (tail) {
     7d8:	b132      	cbz	r2, 7e8 <nffs_cache_insert_block+0x10>
        TAILQ_INSERT_TAIL(&cache_inode->nci_block_list, cache_block, ncb_link);
     7da:	2300      	movs	r3, #0
     7dc:	600b      	str	r3, [r1, #0]
     7de:	69c3      	ldr	r3, [r0, #28]
     7e0:	604b      	str	r3, [r1, #4]
     7e2:	6019      	str	r1, [r3, #0]
     7e4:	61c1      	str	r1, [r0, #28]
     7e6:	4770      	bx	lr
    } else {
        TAILQ_INSERT_HEAD(&cache_inode->nci_block_list, cache_block, ncb_link);
     7e8:	6983      	ldr	r3, [r0, #24]
     7ea:	600b      	str	r3, [r1, #0]
     7ec:	b10b      	cbz	r3, 7f2 <nffs_cache_insert_block+0x1a>
     7ee:	6059      	str	r1, [r3, #4]
     7f0:	e000      	b.n	7f4 <nffs_cache_insert_block+0x1c>
     7f2:	61c1      	str	r1, [r0, #28]
     7f4:	f840 1f18 	str.w	r1, [r0, #24]!
     7f8:	6048      	str	r0, [r1, #4]
     7fa:	4770      	bx	lr

000007fc <nffs_cache_seek>:
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_cache_seek(struct nffs_cache_inode *cache_inode, uint32_t seek_offset,
                struct nffs_cache_block **out_cache_block)
{
     7fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint32_t block_start;
    uint32_t block_end;
    int rc;

    /* Empty files have no blocks that can be cached. */
    if (cache_inode->nci_file_size == 0) {
     800:	6a03      	ldr	r3, [r0, #32]
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_cache_seek(struct nffs_cache_inode *cache_inode, uint32_t seek_offset,
                struct nffs_cache_block **out_cache_block)
{
     802:	b089      	sub	sp, #36	; 0x24
     804:	4606      	mov	r6, r0
     806:	4688      	mov	r8, r1
     808:	4617      	mov	r7, r2
    uint32_t block_start;
    uint32_t block_end;
    int rc;

    /* Empty files have no blocks that can be cached. */
    if (cache_inode->nci_file_size == 0) {
     80a:	2b00      	cmp	r3, #0
     80c:	f000 8082 	beq.w	914 <nffs_cache_seek+0x118>
        return FS_ENOENT;
    }

    nffs_cache_inode_range(cache_inode, &cache_start, &cache_end);
     810:	a901      	add	r1, sp, #4
     812:	aa02      	add	r2, sp, #8
     814:	f7ff ff56 	bl	6c4 <nffs_cache_inode_range>
    if (cache_end != 0 && seek_offset < cache_start) {
     818:	9d02      	ldr	r5, [sp, #8]
     81a:	b17d      	cbz	r5, 83c <nffs_cache_seek+0x40>
     81c:	9b01      	ldr	r3, [sp, #4]
     81e:	4598      	cmp	r8, r3
     820:	d204      	bcs.n	82c <nffs_cache_seek+0x30>
        /* Seeking prior to cache.  Iterate backwards from cache start. */
        cache_block = TAILQ_FIRST(&cache_inode->nci_block_list);
     822:	69b3      	ldr	r3, [r6, #24]
        block_entry = cache_block->ncb_block.nb_prev;
     824:	f8d3 9014 	ldr.w	r9, [r3, #20]
        block_end = cache_block->ncb_file_offset;
     828:	69dd      	ldr	r5, [r3, #28]
     82a:	e00b      	b.n	844 <nffs_cache_seek+0x48>
        cache_block = NULL;
    } else if (seek_offset < cache_end) {
     82c:	45a8      	cmp	r8, r5
     82e:	d205      	bcs.n	83c <nffs_cache_seek+0x40>
        /* Seeking within cache.  Iterate backwards from cache end. */
        cache_block = TAILQ_LAST(&cache_inode->nci_block_list,
     830:	69f3      	ldr	r3, [r6, #28]
     832:	685b      	ldr	r3, [r3, #4]
     834:	681c      	ldr	r4, [r3, #0]
                                 nffs_cache_block_list);
        block_entry = cache_block->ncb_block.nb_hash_entry;
     836:	f8d4 9008 	ldr.w	r9, [r4, #8]
     83a:	e004      	b.n	846 <nffs_cache_seek+0x4a>
         * sought-after block is adjacent to cache end, its cache entry will
         * get appended to the current cache.  Otherwise, the current cache
         * will be freed and replaced with the single requested block.
         */
        cache_block = NULL;
        block_entry =
     83c:	68b3      	ldr	r3, [r6, #8]
            cache_inode->nci_inode.ni_inode_entry->nie_last_block_entry;
        block_end = cache_inode->nci_file_size;
     83e:	6a35      	ldr	r5, [r6, #32]
         * sought-after block is adjacent to cache end, its cache entry will
         * get appended to the current cache.  Otherwise, the current cache
         * will be freed and replaced with the single requested block.
         */
        cache_block = NULL;
        block_entry =
     840:	f8d3 9010 	ldr.w	r9, [r3, #16]
        /* Seeking beyond end of cache.  Iterate backwards from file end.  If
         * sought-after block is adjacent to cache end, its cache entry will
         * get appended to the current cache.  Otherwise, the current cache
         * will be freed and replaced with the single requested block.
         */
        cache_block = NULL;
     844:	2400      	movs	r4, #0
        block_end = cache_inode->nci_file_size;
    }

    /* Scan backwards until we find the block containing the seek offest. */
    while (1) {
        if (block_end <= cache_start) {
     846:	9b01      	ldr	r3, [sp, #4]
     848:	429d      	cmp	r5, r3
     84a:	d819      	bhi.n	880 <nffs_cache_seek+0x84>
            /* We are looking before the start of the cache.  Allocate a new
             * cache block and prepend it to the cache.
             */
            assert(cache_block == NULL);
     84c:	b134      	cbz	r4, 85c <nffs_cache_seek+0x60>
     84e:	2200      	movs	r2, #0
     850:	4833      	ldr	r0, [pc, #204]	; (920 <nffs_cache_seek+0x124>)
     852:	f240 11a9 	movw	r1, #425	; 0x1a9
     856:	4613      	mov	r3, r2
     858:	f004 f9f8 	bl	4c4c <__assert_func>
            cache_block = nffs_cache_block_acquire();
     85c:	f7ff ff0e 	bl	67c <nffs_cache_block_acquire>
                          struct nffs_hash_entry *block_entry,
                          uint32_t end_offset)
{
    int rc;

    rc = nffs_block_from_hash_entry(&cache_block->ncb_block, block_entry);
     860:	4649      	mov	r1, r9
        if (block_end <= cache_start) {
            /* We are looking before the start of the cache.  Allocate a new
             * cache block and prepend it to the cache.
             */
            assert(cache_block == NULL);
            cache_block = nffs_cache_block_acquire();
     862:	4604      	mov	r4, r0
                          struct nffs_hash_entry *block_entry,
                          uint32_t end_offset)
{
    int rc;

    rc = nffs_block_from_hash_entry(&cache_block->ncb_block, block_entry);
     864:	3008      	adds	r0, #8
     866:	f002 fab5 	bl	2dd4 <nffs_block_from_hash_entry>
    if (rc != 0) {
     86a:	4602      	mov	r2, r0
     86c:	2800      	cmp	r0, #0
     86e:	d154      	bne.n	91a <nffs_cache_seek+0x11e>
        return rc;
    }

    cache_block->ncb_file_offset = end_offset -
     870:	8b23      	ldrh	r3, [r4, #24]
     872:	1aed      	subs	r5, r5, r3
     874:	61e5      	str	r5, [r4, #28]
                                           block_end);
            if (rc != 0) {
                return rc;
            }

            nffs_cache_insert_block(cache_inode, cache_block, 0);
     876:	4630      	mov	r0, r6
     878:	4621      	mov	r1, r4
     87a:	f7ff ffad 	bl	7d8 <nffs_cache_insert_block>
     87e:	e000      	b.n	882 <nffs_cache_seek+0x86>
        }

        /* Calculate the file offset of the start of this block.  This is used
         * to determine if this block contains the sought-after offset.
         */
        if (cache_block != NULL) {
     880:	b11c      	cbz	r4, 88a <nffs_cache_seek+0x8e>
            /* Current block is cached. */
            block_start = cache_block->ncb_file_offset;
     882:	69e5      	ldr	r5, [r4, #28]
            pred_entry = cache_block->ncb_block.nb_prev;
     884:	f8d4 9014 	ldr.w	r9, [r4, #20]
     888:	e00a      	b.n	8a0 <nffs_cache_seek+0xa4>
        } else {
            /* We are looking beyond the end of the cache.  Read the data block
             * from flash.
             */
            rc = nffs_block_from_hash_entry(&block, block_entry);
     88a:	a803      	add	r0, sp, #12
     88c:	4649      	mov	r1, r9
     88e:	f002 faa1 	bl	2dd4 <nffs_block_from_hash_entry>
            if (rc != 0) {
     892:	2800      	cmp	r0, #0
     894:	d141      	bne.n	91a <nffs_cache_seek+0x11e>
                return rc;
            }

            block_start = block_end - block.nb_data_len;
     896:	f8bd 301c 	ldrh.w	r3, [sp, #28]
            pred_entry = block.nb_prev;
     89a:	f8dd 9018 	ldr.w	r9, [sp, #24]
            rc = nffs_block_from_hash_entry(&block, block_entry);
            if (rc != 0) {
                return rc;
            }

            block_start = block_end - block.nb_data_len;
     89e:	1aed      	subs	r5, r5, r3
            pred_entry = block.nb_prev;
        }

        if (block_start <= seek_offset) {
     8a0:	4545      	cmp	r5, r8
     8a2:	d831      	bhi.n	908 <nffs_cache_seek+0x10c>
            /* This block contains the requested address; iteration is
             * complete.
             */
           if (cache_block == NULL) {
     8a4:	46a0      	mov	r8, r4
     8a6:	bb54      	cbnz	r4, 8fe <nffs_cache_seek+0x102>
                /* The block isn't cached, so it must come after the cache end.
                 * Append it to the cache if it directly follows.  Otherwise,
                 * erase the current cache and populate it with this single
                 * block.
                 */
                cache_block = nffs_cache_block_acquire();
     8a8:	f7ff fee8 	bl	67c <nffs_cache_block_acquire>
                cache_block->ncb_block = block;
     8ac:	f10d 0c0c 	add.w	ip, sp, #12
                /* The block isn't cached, so it must come after the cache end.
                 * Append it to the cache if it directly follows.  Otherwise,
                 * erase the current cache and populate it with this single
                 * block.
                 */
                cache_block = nffs_cache_block_acquire();
     8b0:	4680      	mov	r8, r0
                cache_block->ncb_block = block;
     8b2:	f100 0e08 	add.w	lr, r0, #8
     8b6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
     8ba:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
     8be:	f8dc 3000 	ldr.w	r3, [ip]
     8c2:	f8ce 3000 	str.w	r3, [lr]
static struct nffs_hash_entry *
nffs_cache_inode_last_entry(struct nffs_cache_inode *cache_inode)
{
    struct nffs_cache_block *cache_block;

    if (TAILQ_EMPTY(&cache_inode->nci_block_list)) {
     8c6:	69b3      	ldr	r3, [r6, #24]
                 * erase the current cache and populate it with this single
                 * block.
                 */
                cache_block = nffs_cache_block_acquire();
                cache_block->ncb_block = block;
                cache_block->ncb_file_offset = block_start;
     8c8:	f8c8 501c 	str.w	r5, [r8, #28]
static struct nffs_hash_entry *
nffs_cache_inode_last_entry(struct nffs_cache_inode *cache_inode)
{
    struct nffs_cache_block *cache_block;

    if (TAILQ_EMPTY(&cache_inode->nci_block_list)) {
     8cc:	b17b      	cbz	r3, 8ee <nffs_cache_seek+0xf2>
        return NULL;
    }

    cache_block = TAILQ_LAST(&cache_inode->nci_block_list,
     8ce:	69f3      	ldr	r3, [r6, #28]
     8d0:	685a      	ldr	r2, [r3, #4]
                             nffs_cache_block_list);
    return cache_block->ncb_block.nb_hash_entry;
     8d2:	6812      	ldr	r2, [r2, #0]
     8d4:	6892      	ldr	r2, [r2, #8]
                cache_block = nffs_cache_block_acquire();
                cache_block->ncb_block = block;
                cache_block->ncb_file_offset = block_start;

                last_cached_entry = nffs_cache_inode_last_entry(cache_inode);
                if (last_cached_entry != NULL &&
     8d6:	b152      	cbz	r2, 8ee <nffs_cache_seek+0xf2>
     8d8:	454a      	cmp	r2, r9
     8da:	d108      	bne.n	8ee <nffs_cache_seek+0xf2>
nffs_cache_insert_block(struct nffs_cache_inode *cache_inode,
                        struct nffs_cache_block *cache_block,
                        int tail)
{
    if (tail) {
        TAILQ_INSERT_TAIL(&cache_inode->nci_block_list, cache_block, ncb_link);
     8dc:	f8c8 4000 	str.w	r4, [r8]
     8e0:	f8c8 3004 	str.w	r3, [r8, #4]
     8e4:	f8c3 8000 	str.w	r8, [r3]
     8e8:	f8c6 801c 	str.w	r8, [r6, #28]
     8ec:	e007      	b.n	8fe <nffs_cache_seek+0x102>
                if (last_cached_entry != NULL &&
                    last_cached_entry == pred_entry) {

                    nffs_cache_insert_block(cache_inode, cache_block, 1);
                } else {
                    nffs_cache_inode_free_blocks(cache_inode);
     8ee:	4630      	mov	r0, r6
     8f0:	f7ff fe80 	bl	5f4 <nffs_cache_inode_free_blocks>
                    nffs_cache_insert_block(cache_inode, cache_block, 0);
     8f4:	4630      	mov	r0, r6
     8f6:	4641      	mov	r1, r8
     8f8:	2200      	movs	r2, #0
     8fa:	f7ff ff6d 	bl	7d8 <nffs_cache_insert_block>
                }
            }

            if (out_cache_block != NULL) {
     8fe:	b15f      	cbz	r7, 918 <nffs_cache_seek+0x11c>
                *out_cache_block = cache_block;
     900:	f8c7 8000 	str.w	r8, [r7]
        }
        block_entry = pred_entry;
        block_end = block_start;
    }

    return 0;
     904:	2000      	movs	r0, #0
     906:	e008      	b.n	91a <nffs_cache_seek+0x11e>
            }
            break;
        }

        /* Prepare for next iteration. */
        if (cache_block != NULL) {
     908:	2c00      	cmp	r4, #0
     90a:	d09c      	beq.n	846 <nffs_cache_seek+0x4a>
            cache_block = TAILQ_PREV(cache_block, nffs_cache_block_list,
     90c:	6863      	ldr	r3, [r4, #4]
     90e:	685b      	ldr	r3, [r3, #4]
     910:	681c      	ldr	r4, [r3, #0]
     912:	e798      	b.n	846 <nffs_cache_seek+0x4a>
    uint32_t block_end;
    int rc;

    /* Empty files have no blocks that can be cached. */
    if (cache_inode->nci_file_size == 0) {
        return FS_ENOENT;
     914:	2006      	movs	r0, #6
     916:	e000      	b.n	91a <nffs_cache_seek+0x11e>
        }
        block_entry = pred_entry;
        block_end = block_start;
    }

    return 0;
     918:	4638      	mov	r0, r7
}
     91a:	b009      	add	sp, #36	; 0x24
     91c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     920:	00006204 	.word	0x00006204

00000924 <nffs_cache_clear>:
/**
 * Frees all cached inodes and blocks.
 */
void
nffs_cache_clear(void)
{
     924:	b508      	push	{r3, lr}
    struct nffs_cache_inode *entry;

    while ((entry = TAILQ_FIRST(&nffs_cache_inode_list)) != NULL) {
     926:	4a07      	ldr	r2, [pc, #28]	; (944 <nffs_cache_clear+0x20>)
     928:	6810      	ldr	r0, [r2, #0]
     92a:	b150      	cbz	r0, 942 <nffs_cache_clear+0x1e>
        TAILQ_REMOVE(&nffs_cache_inode_list, entry, nci_link);
     92c:	6803      	ldr	r3, [r0, #0]
     92e:	6841      	ldr	r1, [r0, #4]
     930:	b10b      	cbz	r3, 936 <nffs_cache_clear+0x12>
     932:	6059      	str	r1, [r3, #4]
     934:	e000      	b.n	938 <nffs_cache_clear+0x14>
     936:	6051      	str	r1, [r2, #4]
     938:	6842      	ldr	r2, [r0, #4]
     93a:	6013      	str	r3, [r2, #0]
        nffs_cache_inode_free(entry);
     93c:	f7ff fe6e 	bl	61c <nffs_cache_inode_free>
     940:	e7f1      	b.n	926 <nffs_cache_clear+0x2>
    }
}
     942:	bd08      	pop	{r3, pc}
     944:	200000ec 	.word	0x200000ec

00000948 <nffs_config_init>:
};

void
nffs_config_init(void)
{
    if (nffs_config.nc_num_inodes == 0) {
     948:	4b0f      	ldr	r3, [pc, #60]	; (988 <nffs_config_init+0x40>)
     94a:	681a      	ldr	r2, [r3, #0]
     94c:	b90a      	cbnz	r2, 952 <nffs_config_init+0xa>
        nffs_config.nc_num_inodes = nffs_config_dflt.nc_num_inodes;
     94e:	2264      	movs	r2, #100	; 0x64
     950:	601a      	str	r2, [r3, #0]
    }
    if (nffs_config.nc_num_blocks == 0) {
     952:	685a      	ldr	r2, [r3, #4]
     954:	b912      	cbnz	r2, 95c <nffs_config_init+0x14>
        nffs_config.nc_num_blocks = nffs_config_dflt.nc_num_blocks;
     956:	4a0c      	ldr	r2, [pc, #48]	; (988 <nffs_config_init+0x40>)
     958:	2164      	movs	r1, #100	; 0x64
     95a:	6051      	str	r1, [r2, #4]
    }
    if (nffs_config.nc_num_files == 0) {
     95c:	689a      	ldr	r2, [r3, #8]
     95e:	b912      	cbnz	r2, 966 <nffs_config_init+0x1e>
        nffs_config.nc_num_files = nffs_config_dflt.nc_num_files;
     960:	4a09      	ldr	r2, [pc, #36]	; (988 <nffs_config_init+0x40>)
     962:	2104      	movs	r1, #4
     964:	6091      	str	r1, [r2, #8]
    }
    if (nffs_config.nc_num_cache_inodes == 0) {
     966:	691a      	ldr	r2, [r3, #16]
     968:	b912      	cbnz	r2, 970 <nffs_config_init+0x28>
        nffs_config.nc_num_cache_inodes = nffs_config_dflt.nc_num_cache_inodes;
     96a:	4a07      	ldr	r2, [pc, #28]	; (988 <nffs_config_init+0x40>)
     96c:	2104      	movs	r1, #4
     96e:	6111      	str	r1, [r2, #16]
    }
    if (nffs_config.nc_num_cache_blocks == 0) {
     970:	695a      	ldr	r2, [r3, #20]
     972:	b912      	cbnz	r2, 97a <nffs_config_init+0x32>
        nffs_config.nc_num_cache_blocks = nffs_config_dflt.nc_num_cache_blocks;
     974:	4a04      	ldr	r2, [pc, #16]	; (988 <nffs_config_init+0x40>)
     976:	2140      	movs	r1, #64	; 0x40
     978:	6151      	str	r1, [r2, #20]
    }
    if (nffs_config.nc_num_dirs == 0) {
     97a:	68db      	ldr	r3, [r3, #12]
     97c:	b913      	cbnz	r3, 984 <nffs_config_init+0x3c>
        nffs_config.nc_num_dirs = nffs_config_dflt.nc_num_dirs;
     97e:	4b02      	ldr	r3, [pc, #8]	; (988 <nffs_config_init+0x40>)
     980:	2204      	movs	r2, #4
     982:	60da      	str	r2, [r3, #12]
     984:	4770      	bx	lr
     986:	bf00      	nop
     988:	20000b84 	.word	0x20000b84

0000098c <nffs_dir_open>:
    return 0;
}

int
nffs_dir_open(const char *path, struct nffs_dir **out_dir)
{
     98c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
     98e:	460f      	mov	r7, r1
    struct nffs_inode_entry *parent_inode_entry;
    struct nffs_dir *dir;
    int rc;

    rc = nffs_path_find_inode_entry(path, &parent_inode_entry);
     990:	a901      	add	r1, sp, #4
     992:	f001 fa55 	bl	1e40 <nffs_path_find_inode_entry>
    if (rc != 0) {
     996:	4604      	mov	r4, r0
     998:	b9c8      	cbnz	r0, 9ce <nffs_dir_open+0x42>
        return rc;
    }

    if (!nffs_hash_id_is_dir(parent_inode_entry->nie_hash_entry.nhe_id)) {
     99a:	9b01      	ldr	r3, [sp, #4]
     99c:	6858      	ldr	r0, [r3, #4]
     99e:	f000 fa7f 	bl	ea0 <nffs_hash_id_is_dir>
     9a2:	b1b0      	cbz	r0, 9d2 <nffs_dir_open+0x46>
static struct nffs_dir *
nffs_dir_alloc(void)
{
    struct nffs_dir *dir;

    dir = os_memblock_get(&nffs_dir_pool);
     9a4:	480d      	ldr	r0, [pc, #52]	; (9dc <nffs_dir_open+0x50>)
     9a6:	f004 f9f7 	bl	4d98 <os_memblock_get>
    if (dir != NULL) {
     9aa:	4606      	mov	r6, r0
     9ac:	b198      	cbz	r0, 9d6 <nffs_dir_open+0x4a>
        memset(dir, 0, sizeof *dir);
     9ae:	4621      	mov	r1, r4
     9b0:	2208      	movs	r2, #8
    dir = nffs_dir_alloc();
    if (dir == NULL) {
        return FS_ENOMEM;
    }

    dir->nd_parent_inode_entry = parent_inode_entry;
     9b2:	4635      	mov	r5, r6
{
    struct nffs_dir *dir;

    dir = os_memblock_get(&nffs_dir_pool);
    if (dir != NULL) {
        memset(dir, 0, sizeof *dir);
     9b4:	f002 ffd6 	bl	3964 <memset>
    dir = nffs_dir_alloc();
    if (dir == NULL) {
        return FS_ENOMEM;
    }

    dir->nd_parent_inode_entry = parent_inode_entry;
     9b8:	9801      	ldr	r0, [sp, #4]
     9ba:	f845 0b04 	str.w	r0, [r5], #4
    nffs_inode_inc_refcnt(dir->nd_parent_inode_entry);
     9be:	f000 fc79 	bl	12b4 <nffs_inode_inc_refcnt>
    memset(&dir->nd_dirent, 0, sizeof dir->nd_dirent);
     9c2:	4628      	mov	r0, r5
     9c4:	4621      	mov	r1, r4
     9c6:	2204      	movs	r2, #4
     9c8:	f002 ffcc 	bl	3964 <memset>

    *out_dir = dir;
     9cc:	603e      	str	r6, [r7, #0]
     9ce:	4620      	mov	r0, r4
     9d0:	e002      	b.n	9d8 <nffs_dir_open+0x4c>
    if (rc != 0) {
        return rc;
    }

    if (!nffs_hash_id_is_dir(parent_inode_entry->nie_hash_entry.nhe_id)) {
        return FS_EINVAL;
     9d2:	2004      	movs	r0, #4
     9d4:	e000      	b.n	9d8 <nffs_dir_open+0x4c>
    }

    dir = nffs_dir_alloc();
    if (dir == NULL) {
        return FS_ENOMEM;
     9d6:	2005      	movs	r0, #5
    memset(&dir->nd_dirent, 0, sizeof dir->nd_dirent);

    *out_dir = dir;

    return 0;
}
     9d8:	b003      	add	sp, #12
     9da:	bdf0      	pop	{r4, r5, r6, r7, pc}
     9dc:	20000aac 	.word	0x20000aac

000009e0 <nffs_dir_read>:

int
nffs_dir_read(struct nffs_dir *dir, struct nffs_dirent **out_dirent)
{
     9e0:	b570      	push	{r4, r5, r6, lr}
     9e2:	4604      	mov	r4, r0
    struct nffs_inode_entry *child;
    int rc;

    if (dir->nd_dirent.nde_inode_entry == NULL) {
     9e4:	6840      	ldr	r0, [r0, #4]
    return 0;
}

int
nffs_dir_read(struct nffs_dir *dir, struct nffs_dirent **out_dirent)
{
     9e6:	460e      	mov	r6, r1
    struct nffs_inode_entry *child;
    int rc;

    if (dir->nd_dirent.nde_inode_entry == NULL) {
     9e8:	b910      	cbnz	r0, 9f0 <nffs_dir_read+0x10>
        child = SLIST_FIRST(&dir->nd_parent_inode_entry->nie_child_list);
     9ea:	6823      	ldr	r3, [r4, #0]
     9ec:	691d      	ldr	r5, [r3, #16]
     9ee:	e003      	b.n	9f8 <nffs_dir_read+0x18>
    } else {
        child = SLIST_NEXT(dir->nd_dirent.nde_inode_entry, nie_sibling_next);
     9f0:	68c5      	ldr	r5, [r0, #12]
        rc = nffs_inode_dec_refcnt(dir->nd_dirent.nde_inode_entry);
     9f2:	f000 fc6f 	bl	12d4 <nffs_inode_dec_refcnt>
        if (rc != 0) {
     9f6:	b950      	cbnz	r0, a0e <nffs_dir_read+0x2e>
            /* XXX: Need to clean up anything? */
            return rc;
        }
    }
    dir->nd_dirent.nde_inode_entry = child;
     9f8:	6065      	str	r5, [r4, #4]

    if (child == NULL) {
     9fa:	b915      	cbnz	r5, a02 <nffs_dir_read+0x22>
        *out_dirent = NULL;
     9fc:	6035      	str	r5, [r6, #0]
        return FS_ENOENT;
     9fe:	2006      	movs	r0, #6
     a00:	bd70      	pop	{r4, r5, r6, pc}
    }

    nffs_inode_inc_refcnt(child);
     a02:	4628      	mov	r0, r5
    *out_dirent = &dir->nd_dirent;
     a04:	3404      	adds	r4, #4
    if (child == NULL) {
        *out_dirent = NULL;
        return FS_ENOENT;
    }

    nffs_inode_inc_refcnt(child);
     a06:	f000 fc55 	bl	12b4 <nffs_inode_inc_refcnt>
    *out_dirent = &dir->nd_dirent;
     a0a:	6034      	str	r4, [r6, #0]

    return 0;
     a0c:	2000      	movs	r0, #0
}
     a0e:	bd70      	pop	{r4, r5, r6, pc}

00000a10 <nffs_dir_close>:

int
nffs_dir_close(struct nffs_dir *dir)
{
     a10:	b510      	push	{r4, lr}
    int rc;

    if (dir == NULL) {
     a12:	4604      	mov	r4, r0
     a14:	b908      	cbnz	r0, a1a <nffs_dir_close+0xa>
        return 0;
     a16:	2000      	movs	r0, #0
     a18:	bd10      	pop	{r4, pc}
    }

    if (dir->nd_dirent.nde_inode_entry != NULL) {
     a1a:	6840      	ldr	r0, [r0, #4]
     a1c:	b920      	cbnz	r0, a28 <nffs_dir_close+0x18>
        if (rc != 0) {
            return rc;
        }
    }

    rc = nffs_inode_dec_refcnt(dir->nd_parent_inode_entry);
     a1e:	6820      	ldr	r0, [r4, #0]
     a20:	f000 fc58 	bl	12d4 <nffs_inode_dec_refcnt>
    if (rc != 0) {
     a24:	b960      	cbnz	r0, a40 <nffs_dir_close+0x30>
     a26:	e004      	b.n	a32 <nffs_dir_close+0x22>
    if (dir == NULL) {
        return 0;
    }

    if (dir->nd_dirent.nde_inode_entry != NULL) {
        rc = nffs_inode_dec_refcnt(dir->nd_dirent.nde_inode_entry);
     a28:	f000 fc54 	bl	12d4 <nffs_inode_dec_refcnt>
        if (rc != 0) {
     a2c:	2800      	cmp	r0, #0
     a2e:	d0f6      	beq.n	a1e <nffs_dir_close+0xe>
     a30:	bd10      	pop	{r4, pc}
nffs_dir_free(struct nffs_dir *dir)
{
    int rc;

    if (dir != NULL) {
        rc = os_memblock_put(&nffs_dir_pool, dir);
     a32:	4804      	ldr	r0, [pc, #16]	; (a44 <nffs_dir_close+0x34>)
     a34:	4621      	mov	r1, r4
     a36:	f004 f9c3 	bl	4dc0 <os_memblock_put>
        if (rc != 0) {
     a3a:	2800      	cmp	r0, #0
     a3c:	d0eb      	beq.n	a16 <nffs_dir_close+0x6>
            return FS_EOS;
     a3e:	200a      	movs	r0, #10
    if (rc != 0) {
        return rc;
    }

    return 0;
}
     a40:	bd10      	pop	{r4, pc}
     a42:	bf00      	nop
     a44:	20000aac 	.word	0x20000aac

00000a48 <nffs_file_new>:
 */
int
nffs_file_new(struct nffs_inode_entry *parent, const char *filename,
              uint8_t filename_len, int is_dir,
              struct nffs_inode_entry **out_inode_entry)
{
     a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     a4c:	b088      	sub	sp, #32
     a4e:	4605      	mov	r5, r0
    struct nffs_inode_entry *inode_entry;
    uint32_t offset;
    uint8_t area_idx;
    int rc;

    rc = nffs_inode_entry_reserve(&inode_entry);
     a50:	a801      	add	r0, sp, #4
 */
int
nffs_file_new(struct nffs_inode_entry *parent, const char *filename,
              uint8_t filename_len, int is_dir,
              struct nffs_inode_entry **out_inode_entry)
{
     a52:	460e      	mov	r6, r1
     a54:	4617      	mov	r7, r2
     a56:	4698      	mov	r8, r3
    struct nffs_inode_entry *inode_entry;
    uint32_t offset;
    uint8_t area_idx;
    int rc;

    rc = nffs_inode_entry_reserve(&inode_entry);
     a58:	f000 fbc0 	bl	11dc <nffs_inode_entry_reserve>
    if (rc != 0) {
     a5c:	4604      	mov	r4, r0
     a5e:	2800      	cmp	r0, #0
     a60:	d15a      	bne.n	b18 <nffs_file_new+0xd0>
        goto err;
    }

    rc = nffs_misc_reserve_space(sizeof disk_inode + filename_len,
     a62:	f107 0014 	add.w	r0, r7, #20
     a66:	f10d 0103 	add.w	r1, sp, #3
     a6a:	aa02      	add	r2, sp, #8
     a6c:	f001 f81a 	bl	1aa4 <nffs_misc_reserve_space>
                                 &area_idx, &offset);
    if (rc != 0) {
     a70:	4604      	mov	r4, r0
     a72:	2800      	cmp	r0, #0
     a74:	d150      	bne.n	b18 <nffs_file_new+0xd0>
        goto err;
    }

    memset(&disk_inode, 0xff, sizeof disk_inode);
     a76:	a803      	add	r0, sp, #12
     a78:	21ff      	movs	r1, #255	; 0xff
     a7a:	2214      	movs	r2, #20
     a7c:	f002 ff72 	bl	3964 <memset>
    if (is_dir) {
     a80:	f1b8 0f00 	cmp.w	r8, #0
     a84:	d001      	beq.n	a8a <nffs_file_new+0x42>
        disk_inode.ndi_id = nffs_hash_next_dir_id++;
     a86:	4a28      	ldr	r2, [pc, #160]	; (b28 <nffs_file_new+0xe0>)
     a88:	e000      	b.n	a8c <nffs_file_new+0x44>
    } else {
        disk_inode.ndi_id = nffs_hash_next_file_id++;
     a8a:	4a28      	ldr	r2, [pc, #160]	; (b2c <nffs_file_new+0xe4>)
     a8c:	6813      	ldr	r3, [r2, #0]
     a8e:	1c59      	adds	r1, r3, #1
     a90:	6011      	str	r1, [r2, #0]
     a92:	9303      	str	r3, [sp, #12]
    }
    disk_inode.ndi_seq = 0;
    disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
     a94:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    if (is_dir) {
        disk_inode.ndi_id = nffs_hash_next_dir_id++;
    } else {
        disk_inode.ndi_id = nffs_hash_next_file_id++;
    }
    disk_inode.ndi_seq = 0;
     a98:	2300      	movs	r3, #0
     a9a:	f8ad 3018 	strh.w	r3, [sp, #24]
    disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
     a9e:	9205      	str	r2, [sp, #20]
    if (parent == NULL) {
     aa0:	b105      	cbz	r5, aa4 <nffs_file_new+0x5c>
        disk_inode.ndi_parent_id = NFFS_ID_NONE;
    } else {
        disk_inode.ndi_parent_id = parent->nie_hash_entry.nhe_id;
     aa2:	686a      	ldr	r2, [r5, #4]
     aa4:	9204      	str	r2, [sp, #16]
    }
    disk_inode.ndi_filename_len = filename_len;
    disk_inode.ndi_flags = 0;
    nffs_crc_disk_inode_fill(&disk_inode, filename);
     aa6:	a803      	add	r0, sp, #12
     aa8:	4631      	mov	r1, r6
        disk_inode.ndi_parent_id = NFFS_ID_NONE;
    } else {
        disk_inode.ndi_parent_id = parent->nie_hash_entry.nhe_id;
    }
    disk_inode.ndi_filename_len = filename_len;
    disk_inode.ndi_flags = 0;
     aaa:	f88d 301c 	strb.w	r3, [sp, #28]
    if (parent == NULL) {
        disk_inode.ndi_parent_id = NFFS_ID_NONE;
    } else {
        disk_inode.ndi_parent_id = parent->nie_hash_entry.nhe_id;
    }
    disk_inode.ndi_filename_len = filename_len;
     aae:	f88d 701d 	strb.w	r7, [sp, #29]
    disk_inode.ndi_flags = 0;
    nffs_crc_disk_inode_fill(&disk_inode, filename);
     ab2:	f002 fa65 	bl	2f80 <nffs_crc_disk_inode_fill>

    rc = nffs_inode_write_disk(&disk_inode, filename, area_idx, offset);
     ab6:	a803      	add	r0, sp, #12
     ab8:	4631      	mov	r1, r6
     aba:	f89d 2003 	ldrb.w	r2, [sp, #3]
     abe:	9b02      	ldr	r3, [sp, #8]
     ac0:	f000 fba7 	bl	1212 <nffs_inode_write_disk>
    if (rc != 0) {
     ac4:	4604      	mov	r4, r0
     ac6:	bb38      	cbnz	r0, b18 <nffs_file_new+0xd0>
        goto err;
    }

    inode_entry->nie_hash_entry.nhe_id = disk_inode.ndi_id;
     ac8:	9e01      	ldr	r6, [sp, #4]
     aca:	9b03      	ldr	r3, [sp, #12]
     acc:	6073      	str	r3, [r6, #4]
    inode_entry->nie_hash_entry.nhe_flash_loc =
        nffs_flash_loc(area_idx, offset);
     ace:	9902      	ldr	r1, [sp, #8]
     ad0:	f89d 0003 	ldrb.w	r0, [sp, #3]
     ad4:	f000 f958 	bl	d88 <nffs_flash_loc>
    inode_entry->nie_refcnt = 1;
     ad8:	9901      	ldr	r1, [sp, #4]
    if (rc != 0) {
        goto err;
    }

    inode_entry->nie_hash_entry.nhe_id = disk_inode.ndi_id;
    inode_entry->nie_hash_entry.nhe_flash_loc =
     ada:	60b0      	str	r0, [r6, #8]
        nffs_flash_loc(area_idx, offset);
    inode_entry->nie_refcnt = 1;
     adc:	2301      	movs	r3, #1
     ade:	750b      	strb	r3, [r1, #20]
    inode_entry->nie_last_block_entry = NULL;
     ae0:	610c      	str	r4, [r1, #16]

    if (parent != NULL) {
     ae2:	b12d      	cbz	r5, af0 <nffs_file_new+0xa8>
        rc = nffs_inode_add_child(parent, inode_entry);
     ae4:	4628      	mov	r0, r5
     ae6:	f000 fe2d 	bl	1744 <nffs_inode_add_child>
        if (rc != 0) {
     aea:	4604      	mov	r4, r0
     aec:	b9a0      	cbnz	r0, b18 <nffs_file_new+0xd0>
     aee:	e00b      	b.n	b08 <nffs_file_new+0xc0>
            goto err;
        }
    } else {
        assert(disk_inode.ndi_id == NFFS_ID_ROOT_DIR);
     af0:	9b03      	ldr	r3, [sp, #12]
     af2:	b12b      	cbz	r3, b00 <nffs_file_new+0xb8>
     af4:	480e      	ldr	r0, [pc, #56]	; (b30 <nffs_file_new+0xe8>)
     af6:	217b      	movs	r1, #123	; 0x7b
     af8:	462a      	mov	r2, r5
     afa:	462b      	mov	r3, r5
     afc:	f004 f8a6 	bl	4c4c <__assert_func>
        nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_INTREE);
     b00:	4608      	mov	r0, r1
     b02:	2120      	movs	r1, #32
     b04:	f000 ff68 	bl	19d8 <nffs_inode_setflags>
    }

    nffs_hash_insert(&inode_entry->nie_hash_entry);
     b08:	9801      	ldr	r0, [sp, #4]
     b0a:	f000 fa33 	bl	f74 <nffs_hash_insert>
    *out_inode_entry = inode_entry;
     b0e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     b10:	9a01      	ldr	r2, [sp, #4]
     b12:	601a      	str	r2, [r3, #0]

    return 0;
     b14:	2000      	movs	r0, #0
     b16:	e003      	b.n	b20 <nffs_file_new+0xd8>

err:
    nffs_inode_entry_free(inode_entry);
     b18:	9801      	ldr	r0, [sp, #4]
     b1a:	f000 faf3 	bl	1104 <nffs_inode_entry_free>
    return rc;
     b1e:	4620      	mov	r0, r4
}
     b20:	b008      	add	sp, #32
     b22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     b26:	bf00      	nop
     b28:	20000c9c 	.word	0x20000c9c
     b2c:	20000ca8 	.word	0x20000ca8
     b30:	00006211 	.word	0x00006211

00000b34 <nffs_file_open>:
 * @return                  0 on success; nonzero on failure.
 */
int
nffs_file_open(struct nffs_file **out_file, const char *path,
               uint8_t access_flags)
{
     b34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     b38:	4680      	mov	r8, r0
    int rc;

    file = NULL;

    /* Reject invalid access flag combinations. */
    if (!(access_flags & (FS_ACCESS_READ | FS_ACCESS_WRITE))) {
     b3a:	0790      	lsls	r0, r2, #30
 * @return                  0 on success; nonzero on failure.
 */
int
nffs_file_open(struct nffs_file **out_file, const char *path,
               uint8_t access_flags)
{
     b3c:	b08a      	sub	sp, #40	; 0x28
     b3e:	460f      	mov	r7, r1
     b40:	4616      	mov	r6, r2
    int rc;

    file = NULL;

    /* Reject invalid access flag combinations. */
    if (!(access_flags & (FS_ACCESS_READ | FS_ACCESS_WRITE))) {
     b42:	d05e      	beq.n	c02 <nffs_file_open+0xce>
        rc = FS_EINVAL;
        goto err;
    }
    if (access_flags & (FS_ACCESS_APPEND | FS_ACCESS_TRUNCATE) &&
     b44:	f012 030c 	ands.w	r3, r2, #12
     b48:	d003      	beq.n	b52 <nffs_file_open+0x1e>
     b4a:	0791      	lsls	r1, r2, #30
     b4c:	d559      	bpl.n	c02 <nffs_file_open+0xce>
        !(access_flags & FS_ACCESS_WRITE)) {

        rc = FS_EINVAL;
        goto err;
    }
    if (access_flags & FS_ACCESS_APPEND &&
     b4e:	2b0c      	cmp	r3, #12
     b50:	d057      	beq.n	c02 <nffs_file_open+0xce>
static struct nffs_file *
nffs_file_alloc(void)
{
    struct nffs_file *file;

    file = os_memblock_get(&nffs_file_pool);
     b52:	482f      	ldr	r0, [pc, #188]	; (c10 <nffs_file_open+0xdc>)
     b54:	f004 f920 	bl	4d98 <os_memblock_get>
    if (file != NULL) {
     b58:	4605      	mov	r5, r0
     b5a:	2800      	cmp	r0, #0
     b5c:	d053      	beq.n	c06 <nffs_file_open+0xd2>
        memset(file, 0, sizeof *file);
     b5e:	220c      	movs	r2, #12
     b60:	2100      	movs	r1, #0
     b62:	f002 feff 	bl	3964 <memset>
    if (file == NULL) {
        rc = FS_ENOMEM;
        goto err;
    }

    nffs_path_parser_new(&parser, path);
     b66:	a805      	add	r0, sp, #20
     b68:	4639      	mov	r1, r7
     b6a:	f001 f92b 	bl	1dc4 <nffs_path_parser_new>
    rc = nffs_path_find(&parser, &inode, &parent);
     b6e:	a805      	add	r0, sp, #20
     b70:	a904      	add	r1, sp, #16
     b72:	aa03      	add	r2, sp, #12
     b74:	f001 f92c 	bl	1dd0 <nffs_path_find>
    if (rc == FS_ENOENT && parser.npp_token_type == NFFS_PATH_TOKEN_LEAF) {
     b78:	2806      	cmp	r0, #6
        rc = FS_ENOMEM;
        goto err;
    }

    nffs_path_parser_new(&parser, path);
    rc = nffs_path_find(&parser, &inode, &parent);
     b7a:	4604      	mov	r4, r0
    if (rc == FS_ENOENT && parser.npp_token_type == NFFS_PATH_TOKEN_LEAF) {
     b7c:	d10d      	bne.n	b9a <nffs_file_open+0x66>
     b7e:	9b05      	ldr	r3, [sp, #20]
     b80:	2b02      	cmp	r3, #2
     b82:	d138      	bne.n	bf6 <nffs_file_open+0xc2>
        /* The path is valid, but the file does not exist.  This is an error
         * for read-only opens.
         */
        if (!(access_flags & FS_ACCESS_WRITE)) {
     b84:	07b2      	lsls	r2, r6, #30
     b86:	d536      	bpl.n	bf6 <nffs_file_open+0xc2>
            goto err;
        }

        /* Make sure the parent directory exists. */
        if (parent == NULL) {
     b88:	9803      	ldr	r0, [sp, #12]
     b8a:	2800      	cmp	r0, #0
     b8c:	d033      	beq.n	bf6 <nffs_file_open+0xc2>
            goto err;
        }

        /* Create a new file at the specified path. */
        rc = nffs_file_new(parent, parser.npp_token, parser.npp_token_len, 0,
     b8e:	f89d 2020 	ldrb.w	r2, [sp, #32]
     b92:	9500      	str	r5, [sp, #0]
     b94:	9907      	ldr	r1, [sp, #28]
     b96:	2300      	movs	r3, #0
     b98:	e010      	b.n	bbc <nffs_file_open+0x88>
                           &file->nf_inode_entry);
        if (rc != 0) {
            goto err;
        }
    } else if (rc == 0) {
     b9a:	bb60      	cbnz	r0, bf6 <nffs_file_open+0xc2>
        /* The file already exists. */

        /* Reject an attempt to open a directory. */
        if (nffs_hash_id_is_dir(inode->nie_hash_entry.nhe_id)) {
     b9c:	9b04      	ldr	r3, [sp, #16]
     b9e:	6858      	ldr	r0, [r3, #4]
     ba0:	f000 f97e 	bl	ea0 <nffs_hash_id_is_dir>
     ba4:	bb30      	cbnz	r0, bf4 <nffs_file_open+0xc0>
            rc = FS_EINVAL;
            goto err;
        }

        if (access_flags & FS_ACCESS_TRUNCATE) {
     ba6:	0733      	lsls	r3, r6, #28
     ba8:	d50d      	bpl.n	bc6 <nffs_file_open+0x92>
            /* The user is truncating the file.  Unlink the old file and create
             * a new one in its place.
             */
            nffs_path_unlink(path);
     baa:	4638      	mov	r0, r7
     bac:	f001 f953 	bl	1e56 <nffs_path_unlink>
            rc = nffs_file_new(parent, parser.npp_token, parser.npp_token_len,
     bb0:	f89d 2020 	ldrb.w	r2, [sp, #32]
     bb4:	9803      	ldr	r0, [sp, #12]
     bb6:	9907      	ldr	r1, [sp, #28]
     bb8:	9500      	str	r5, [sp, #0]
     bba:	4623      	mov	r3, r4
     bbc:	f7ff ff44 	bl	a48 <nffs_file_new>
                               0, &file->nf_inode_entry);
            if (rc != 0) {
     bc0:	4604      	mov	r4, r0
     bc2:	b9c0      	cbnz	r0, bf6 <nffs_file_open+0xc2>
     bc4:	e001      	b.n	bca <nffs_file_open+0x96>
            }
        } else {
            /* The user is not truncating the file.  Point the file handle to
             * the existing inode.
             */
            file->nf_inode_entry = inode;
     bc6:	9b04      	ldr	r3, [sp, #16]
     bc8:	602b      	str	r3, [r5, #0]
    } else {
        /* Invalid path. */
        goto err;
    }

    if (access_flags & FS_ACCESS_APPEND) {
     bca:	f006 0304 	and.w	r3, r6, #4
     bce:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     bd2:	b133      	cbz	r3, be2 <nffs_file_open+0xae>
        rc = nffs_inode_data_len(file->nf_inode_entry, &file->nf_offset);
     bd4:	6828      	ldr	r0, [r5, #0]
     bd6:	1d29      	adds	r1, r5, #4
     bd8:	f000 fb58 	bl	128c <nffs_inode_data_len>
        if (rc != 0) {
     bdc:	4604      	mov	r4, r0
     bde:	b950      	cbnz	r0, bf6 <nffs_file_open+0xc2>
     be0:	e000      	b.n	be4 <nffs_file_open+0xb0>
            goto err;
        }
    } else {
        file->nf_offset = 0;
     be2:	606a      	str	r2, [r5, #4]
    }
    nffs_inode_inc_refcnt(file->nf_inode_entry);
     be4:	6828      	ldr	r0, [r5, #0]
     be6:	f000 fb65 	bl	12b4 <nffs_inode_inc_refcnt>
    file->nf_access_flags = access_flags;
     bea:	722e      	strb	r6, [r5, #8]

    *out_file = file;

    return 0;
     bec:	2000      	movs	r0, #0
        file->nf_offset = 0;
    }
    nffs_inode_inc_refcnt(file->nf_inode_entry);
    file->nf_access_flags = access_flags;

    *out_file = file;
     bee:	f8c8 5000 	str.w	r5, [r8]

    return 0;
     bf2:	e009      	b.n	c08 <nffs_file_open+0xd4>
    } else if (rc == 0) {
        /* The file already exists. */

        /* Reject an attempt to open a directory. */
        if (nffs_hash_id_is_dir(inode->nie_hash_entry.nhe_id)) {
            rc = FS_EINVAL;
     bf4:	2404      	movs	r4, #4
nffs_file_free(struct nffs_file *file)
{
    int rc;

    if (file != NULL) {
        rc = os_memblock_put(&nffs_file_pool, file);
     bf6:	4806      	ldr	r0, [pc, #24]	; (c10 <nffs_file_open+0xdc>)
     bf8:	4629      	mov	r1, r5
     bfa:	f004 f8e1 	bl	4dc0 <os_memblock_put>
     bfe:	4620      	mov	r0, r4
     c00:	e002      	b.n	c08 <nffs_file_open+0xd4>

    file = NULL;

    /* Reject invalid access flag combinations. */
    if (!(access_flags & (FS_ACCESS_READ | FS_ACCESS_WRITE))) {
        rc = FS_EINVAL;
     c02:	2004      	movs	r0, #4
     c04:	e000      	b.n	c08 <nffs_file_open+0xd4>
        goto err;
    }

    file = nffs_file_alloc();
    if (file == NULL) {
        rc = FS_ENOMEM;
     c06:	2005      	movs	r0, #5
    return 0;

err:
    nffs_file_free(file);
    return rc;
}
     c08:	b00a      	add	sp, #40	; 0x28
     c0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     c0e:	bf00      	nop
     c10:	20000acc 	.word	0x20000acc

00000c14 <nffs_file_seek>:
 *
 * @return                  0 on success; nonzero on failure.
 */
int
nffs_file_seek(struct nffs_file *file, uint32_t offset)
{ 
     c14:	b537      	push	{r0, r1, r2, r4, r5, lr}
     c16:	4604      	mov	r4, r0
     c18:	460d      	mov	r5, r1
    uint32_t len;
    int rc;

    rc = nffs_inode_data_len(file->nf_inode_entry, &len);
     c1a:	6800      	ldr	r0, [r0, #0]
     c1c:	a901      	add	r1, sp, #4
     c1e:	f000 fb35 	bl	128c <nffs_inode_data_len>
    if (rc != 0) {
     c22:	b920      	cbnz	r0, c2e <nffs_file_seek+0x1a>
        return rc;
    }

    if (offset > len) {
     c24:	9b01      	ldr	r3, [sp, #4]
     c26:	429d      	cmp	r5, r3
        return FS_EOFFSET;
    }

    file->nf_offset = offset;
     c28:	bf94      	ite	ls
     c2a:	6065      	strls	r5, [r4, #4]
    if (rc != 0) {
        return rc;
    }

    if (offset > len) {
        return FS_EOFFSET;
     c2c:	2003      	movhi	r0, #3
    }

    file->nf_offset = offset;
    return 0;
}
     c2e:	b003      	add	sp, #12
     c30:	bd30      	pop	{r4, r5, pc}

00000c32 <nffs_file_read>:
 * @return                  0 on success; nonzero on failure.
 */
int
nffs_file_read(struct nffs_file *file, uint32_t len, void *out_data,
               uint32_t *out_len)
{
     c32:	b5f0      	push	{r4, r5, r6, r7, lr}
     c34:	b085      	sub	sp, #20
     c36:	4605      	mov	r5, r0
     c38:	460f      	mov	r7, r1
     c3a:	4616      	mov	r6, r2
     c3c:	461c      	mov	r4, r3
    uint32_t bytes_read;
    int rc;

    if (!nffs_misc_ready()) {
     c3e:	f001 f86f 	bl	1d20 <nffs_misc_ready>
     c42:	b190      	cbz	r0, c6a <nffs_file_read+0x38>
        return FS_EUNINIT;
    }

    if (!(file->nf_access_flags & FS_ACCESS_READ)) {
     c44:	7a2b      	ldrb	r3, [r5, #8]
     c46:	07db      	lsls	r3, r3, #31
     c48:	d511      	bpl.n	c6e <nffs_file_read+0x3c>
        return FS_EACCESS;
    }

    rc = nffs_inode_read(file->nf_inode_entry, file->nf_offset, len, out_data,
     c4a:	ab03      	add	r3, sp, #12
     c4c:	9300      	str	r3, [sp, #0]
     c4e:	e895 0003 	ldmia.w	r5, {r0, r1}
     c52:	463a      	mov	r2, r7
     c54:	4633      	mov	r3, r6
     c56:	f000 fc8f 	bl	1578 <nffs_inode_read>
                        &bytes_read);
    if (rc != 0) {
     c5a:	b958      	cbnz	r0, c74 <nffs_file_read+0x42>
        return rc;
    }

    file->nf_offset += bytes_read;
     c5c:	686b      	ldr	r3, [r5, #4]
     c5e:	9a03      	ldr	r2, [sp, #12]
     c60:	4413      	add	r3, r2
     c62:	606b      	str	r3, [r5, #4]
    if (out_len != NULL) {
     c64:	b12c      	cbz	r4, c72 <nffs_file_read+0x40>
        *out_len = bytes_read;
     c66:	6022      	str	r2, [r4, #0]
     c68:	e004      	b.n	c74 <nffs_file_read+0x42>
{
    uint32_t bytes_read;
    int rc;

    if (!nffs_misc_ready()) {
        return FS_EUNINIT;
     c6a:	200d      	movs	r0, #13
     c6c:	e002      	b.n	c74 <nffs_file_read+0x42>
    }

    if (!(file->nf_access_flags & FS_ACCESS_READ)) {
        return FS_EACCESS;
     c6e:	200c      	movs	r0, #12
     c70:	e000      	b.n	c74 <nffs_file_read+0x42>
    file->nf_offset += bytes_read;
    if (out_len != NULL) {
        *out_len = bytes_read;
    }

    return 0;
     c72:	4620      	mov	r0, r4
}
     c74:	b005      	add	sp, #20
     c76:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000c78 <nffs_file_close>:
 *
 * @return                  0 on success; nonzero on failure.
 */
int
nffs_file_close(struct nffs_file *file)
{
     c78:	b510      	push	{r4, lr}
     c7a:	4604      	mov	r4, r0
    int rc;

    rc = nffs_inode_dec_refcnt(file->nf_inode_entry);
     c7c:	6800      	ldr	r0, [r0, #0]
     c7e:	f000 fb29 	bl	12d4 <nffs_inode_dec_refcnt>
    if (rc != 0) {
     c82:	b938      	cbnz	r0, c94 <nffs_file_close+0x1c>
nffs_file_free(struct nffs_file *file)
{
    int rc;

    if (file != NULL) {
        rc = os_memblock_put(&nffs_file_pool, file);
     c84:	4804      	ldr	r0, [pc, #16]	; (c98 <nffs_file_close+0x20>)
     c86:	4621      	mov	r1, r4
     c88:	f004 f89a 	bl	4dc0 <os_memblock_put>
        if (rc != 0) {
     c8c:	2800      	cmp	r0, #0
            return FS_EOS;
     c8e:	bf0c      	ite	eq
     c90:	2000      	moveq	r0, #0
     c92:	200a      	movne	r0, #10
    if (rc != 0) {
        return rc;
    }

    return 0;
}
     c94:	bd10      	pop	{r4, pc}
     c96:	bf00      	nop
     c98:	20000acc 	.word	0x20000acc

00000c9c <nffs_flash_read>:
 *                              FS_EHW on flash error.
 */
int
nffs_flash_read(uint8_t area_idx, uint32_t area_offset, void *data,
                uint32_t len)
{
     c9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    const struct nffs_area *area;
    int rc;

    assert(area_idx < nffs_num_areas);
     c9e:	4d0f      	ldr	r5, [pc, #60]	; (cdc <nffs_flash_read+0x40>)
     ca0:	782d      	ldrb	r5, [r5, #0]
     ca2:	4285      	cmp	r5, r0
 *                              FS_EHW on flash error.
 */
int
nffs_flash_read(uint8_t area_idx, uint32_t area_offset, void *data,
                uint32_t len)
{
     ca4:	461c      	mov	r4, r3
    const struct nffs_area *area;
    int rc;

    assert(area_idx < nffs_num_areas);
     ca6:	d805      	bhi.n	cb4 <nffs_flash_read+0x18>
     ca8:	2200      	movs	r2, #0
     caa:	480d      	ldr	r0, [pc, #52]	; (ce0 <nffs_flash_read+0x44>)
     cac:	2131      	movs	r1, #49	; 0x31
     cae:	4613      	mov	r3, r2
     cb0:	f003 ffcc 	bl	4c4c <__assert_func>

    area = nffs_areas + area_idx;
     cb4:	4d0b      	ldr	r5, [pc, #44]	; (ce4 <nffs_flash_read+0x48>)
     cb6:	682e      	ldr	r6, [r5, #0]
     cb8:	0100      	lsls	r0, r0, #4
     cba:	1835      	adds	r5, r6, r0

    if (area_offset + len > area->na_length) {
     cbc:	440c      	add	r4, r1
     cbe:	686f      	ldr	r7, [r5, #4]
     cc0:	42bc      	cmp	r4, r7
     cc2:	d809      	bhi.n	cd8 <nffs_flash_read+0x3c>
        return FS_EOFFSET;
    }

    rc = hal_flash_read(area->na_flash_id, area->na_offset + area_offset, data,
     cc4:	5834      	ldr	r4, [r6, r0]
     cc6:	7be8      	ldrb	r0, [r5, #15]
     cc8:	4421      	add	r1, r4
     cca:	f002 fd0b 	bl	36e4 <hal_flash_read>
                        len);
    if (rc != 0) {
        return FS_EHW;
    }

    return 0;
     cce:	2800      	cmp	r0, #0
     cd0:	bf14      	ite	ne
     cd2:	2002      	movne	r0, #2
     cd4:	2000      	moveq	r0, #0
     cd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert(area_idx < nffs_num_areas);

    area = nffs_areas + area_idx;

    if (area_offset + len > area->na_length) {
        return FS_EOFFSET;
     cd8:	2003      	movs	r0, #3
    if (rc != 0) {
        return FS_EHW;
    }

    return 0;
}
     cda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     cdc:	20000b24 	.word	0x20000b24
     ce0:	0000621d 	.word	0x0000621d
     ce4:	20000b40 	.word	0x20000b40

00000ce8 <nffs_flash_write>:
 *                              FS_EFLASH_ERROR on flash error.
 */
int
nffs_flash_write(uint8_t area_idx, uint32_t area_offset, const void *data,
                 uint32_t len)
{
     ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    struct nffs_area *area;
    int rc;

    assert(area_idx < nffs_num_areas);
     cea:	4c11      	ldr	r4, [pc, #68]	; (d30 <nffs_flash_write+0x48>)
     cec:	7824      	ldrb	r4, [r4, #0]
     cee:	4284      	cmp	r4, r0
 *                              FS_EFLASH_ERROR on flash error.
 */
int
nffs_flash_write(uint8_t area_idx, uint32_t area_offset, const void *data,
                 uint32_t len)
{
     cf0:	461d      	mov	r5, r3
    struct nffs_area *area;
    int rc;

    assert(area_idx < nffs_num_areas);
     cf2:	d805      	bhi.n	d00 <nffs_flash_write+0x18>
     cf4:	2200      	movs	r2, #0
     cf6:	480f      	ldr	r0, [pc, #60]	; (d34 <nffs_flash_write+0x4c>)
     cf8:	2157      	movs	r1, #87	; 0x57
     cfa:	4613      	mov	r3, r2
     cfc:	f003 ffa6 	bl	4c4c <__assert_func>
    area = nffs_areas + area_idx;
     d00:	4c0d      	ldr	r4, [pc, #52]	; (d38 <nffs_flash_write+0x50>)
     d02:	6826      	ldr	r6, [r4, #0]
     d04:	0100      	lsls	r0, r0, #4
     d06:	1834      	adds	r4, r6, r0

    if (area_offset + len > area->na_length) {
     d08:	440d      	add	r5, r1
     d0a:	6867      	ldr	r7, [r4, #4]
     d0c:	42bd      	cmp	r5, r7
     d0e:	d80a      	bhi.n	d26 <nffs_flash_write+0x3e>
        return FS_EOFFSET;
    }

    if (area_offset < area->na_cur) {
     d10:	68a7      	ldr	r7, [r4, #8]
     d12:	42b9      	cmp	r1, r7
     d14:	d307      	bcc.n	d26 <nffs_flash_write+0x3e>
        return FS_EOFFSET;
    }

    rc = hal_flash_write(area->na_flash_id, area->na_offset + area_offset,
     d16:	5836      	ldr	r6, [r6, r0]
     d18:	7be0      	ldrb	r0, [r4, #15]
     d1a:	4431      	add	r1, r6
     d1c:	f002 fd00 	bl	3720 <hal_flash_write>
                         data, len);
    if (rc != 0) {
     d20:	b918      	cbnz	r0, d2a <nffs_flash_write+0x42>
        return FS_EHW;
    }

    area->na_cur = area_offset + len;
     d22:	60a5      	str	r5, [r4, #8]

    return 0;
     d24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    assert(area_idx < nffs_num_areas);
    area = nffs_areas + area_idx;

    if (area_offset + len > area->na_length) {
        return FS_EOFFSET;
     d26:	2003      	movs	r0, #3
     d28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    rc = hal_flash_write(area->na_flash_id, area->na_offset + area_offset,
                         data, len);
    if (rc != 0) {
        return FS_EHW;
     d2a:	2002      	movs	r0, #2
    }

    area->na_cur = area_offset + len;

    return 0;
}
     d2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     d2e:	bf00      	nop
     d30:	20000b24 	.word	0x20000b24
     d34:	0000621d 	.word	0x0000621d
     d38:	20000b40 	.word	0x20000b40

00000d3c <nffs_flash_copy>:
 */
int
nffs_flash_copy(uint8_t area_idx_from, uint32_t area_offset_from,
                uint8_t area_idx_to, uint32_t area_offset_to,
                uint32_t len)
{
     d3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     d40:	9c08      	ldr	r4, [sp, #32]
     d42:	4680      	mov	r8, r0
     d44:	460e      	mov	r6, r1
     d46:	4691      	mov	r9, r2
     d48:	461f      	mov	r7, r3
    uint32_t chunk_len;
    int rc;

    /* Copy data in chunks small enough to fit in the flash buffer. */
    while (len > 0) {
     d4a:	b1bc      	cbz	r4, d7c <nffs_flash_copy+0x40>
     d4c:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
     d50:	4625      	mov	r5, r4
     d52:	bf28      	it	cs
     d54:	f44f 7580 	movcs.w	r5, #256	; 0x100
            chunk_len = sizeof nffs_flash_buf;
        } else {
            chunk_len = len;
        }

        rc = nffs_flash_read(area_idx_from, area_offset_from, nffs_flash_buf,
     d58:	4640      	mov	r0, r8
     d5a:	4631      	mov	r1, r6
     d5c:	4a09      	ldr	r2, [pc, #36]	; (d84 <nffs_flash_copy+0x48>)
     d5e:	462b      	mov	r3, r5
     d60:	f7ff ff9c 	bl	c9c <nffs_flash_read>
                             chunk_len);
        if (rc != 0) {
     d64:	b958      	cbnz	r0, d7e <nffs_flash_copy+0x42>
            return rc;
        }

        rc = nffs_flash_write(area_idx_to, area_offset_to, nffs_flash_buf,
     d66:	4648      	mov	r0, r9
     d68:	4639      	mov	r1, r7
     d6a:	4a06      	ldr	r2, [pc, #24]	; (d84 <nffs_flash_copy+0x48>)
     d6c:	462b      	mov	r3, r5
     d6e:	f7ff ffbb 	bl	ce8 <nffs_flash_write>
                              chunk_len);
        if (rc != 0) {
     d72:	b920      	cbnz	r0, d7e <nffs_flash_copy+0x42>
            return rc;
        }

        area_offset_from += chunk_len;
     d74:	442e      	add	r6, r5
        area_offset_to += chunk_len;
     d76:	442f      	add	r7, r5
        len -= chunk_len;
     d78:	1b64      	subs	r4, r4, r5
     d7a:	e7e6      	b.n	d4a <nffs_flash_copy+0xe>
    }

    return 0;
     d7c:	4620      	mov	r0, r4
}
     d7e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     d82:	bf00      	nop
     d84:	20000b9c 	.word	0x20000b9c

00000d88 <nffs_flash_loc>:
 * location.
 */
uint32_t
nffs_flash_loc(uint8_t area_idx, uint32_t area_offset)
{
    assert(area_offset <= 0x00ffffff);
     d88:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
 * Compresses a flash-area-index,flash-area-offset pair into a 32-bit flash
 * location.
 */
uint32_t
nffs_flash_loc(uint8_t area_idx, uint32_t area_offset)
{
     d8c:	b508      	push	{r3, lr}
    assert(area_offset <= 0x00ffffff);
     d8e:	d305      	bcc.n	d9c <nffs_flash_loc+0x14>
     d90:	2200      	movs	r2, #0
     d92:	4804      	ldr	r0, [pc, #16]	; (da4 <nffs_flash_loc+0x1c>)
     d94:	21a3      	movs	r1, #163	; 0xa3
     d96:	4613      	mov	r3, r2
     d98:	f003 ff58 	bl	4c4c <__assert_func>
    return area_idx << 24 | area_offset;
}
     d9c:	ea41 6000 	orr.w	r0, r1, r0, lsl #24
     da0:	bd08      	pop	{r3, pc}
     da2:	bf00      	nop
     da4:	0000621d 	.word	0x0000621d

00000da8 <nffs_flash_loc_expand>:
 */
void
nffs_flash_loc_expand(uint32_t flash_loc, uint8_t *out_area_idx,
                     uint32_t *out_area_offset)
{
    *out_area_idx = flash_loc >> 24;
     da8:	0e03      	lsrs	r3, r0, #24
    *out_area_offset = flash_loc & 0x00ffffff;
     daa:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 */
void
nffs_flash_loc_expand(uint32_t flash_loc, uint8_t *out_area_idx,
                     uint32_t *out_area_offset)
{
    *out_area_idx = flash_loc >> 24;
     dae:	700b      	strb	r3, [r1, #0]
    *out_area_offset = flash_loc & 0x00ffffff;
     db0:	6010      	str	r0, [r2, #0]
     db2:	4770      	bx	lr

00000db4 <nffs_format_area>:
/**
 * Formats a single scratch area.
 */
int
nffs_format_area(uint8_t area_idx, int is_scratch)
{
     db4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    struct nffs_disk_area disk_area;
    struct nffs_area *area;
    uint32_t write_len;
    int rc;

    area = nffs_areas + area_idx;
     db8:	4f12      	ldr	r7, [pc, #72]	; (e04 <nffs_format_area+0x50>)
     dba:	683b      	ldr	r3, [r7, #0]
     dbc:	0104      	lsls	r4, r0, #4
     dbe:	191d      	adds	r5, r3, r4
/**
 * Formats a single scratch area.
 */
int
nffs_format_area(uint8_t area_idx, int is_scratch)
{
     dc0:	b086      	sub	sp, #24
     dc2:	4606      	mov	r6, r0
     dc4:	4688      	mov	r8, r1
    uint32_t write_len;
    int rc;

    area = nffs_areas + area_idx;

    rc = hal_flash_erase(area->na_flash_id, area->na_offset, area->na_length);
     dc6:	7be8      	ldrb	r0, [r5, #15]
     dc8:	5919      	ldr	r1, [r3, r4]
     dca:	686a      	ldr	r2, [r5, #4]
     dcc:	f002 fcc6 	bl	375c <hal_flash_erase>
    if (rc != 0) {
     dd0:	b9a0      	cbnz	r0, dfc <nffs_format_area+0x48>
        return FS_EHW;
    }
    area->na_cur = 0;
     dd2:	60a8      	str	r0, [r5, #8]

    nffs_area_to_disk(area, &disk_area);
     dd4:	4669      	mov	r1, sp
     dd6:	4628      	mov	r0, r5
     dd8:	f001 fecc 	bl	2b74 <nffs_area_to_disk>

    if (is_scratch) {
     ddc:	f1b8 0f00 	cmp.w	r8, #0
     de0:	d005      	beq.n	dee <nffs_format_area+0x3a>
        nffs_areas[area_idx].na_id = NFFS_AREA_ID_NONE;
     de2:	683b      	ldr	r3, [r7, #0]
     de4:	441c      	add	r4, r3
     de6:	23ff      	movs	r3, #255	; 0xff
     de8:	81a3      	strh	r3, [r4, #12]
        write_len = sizeof disk_area - sizeof disk_area.nda_id;
     dea:	2317      	movs	r3, #23
     dec:	e000      	b.n	df0 <nffs_format_area+0x3c>
    } else {
        write_len = sizeof disk_area;
     dee:	2318      	movs	r3, #24
    }

    rc = nffs_flash_write(area_idx, 0, &disk_area.nda_magic, write_len);
     df0:	4630      	mov	r0, r6
     df2:	2100      	movs	r1, #0
     df4:	466a      	mov	r2, sp
     df6:	f7ff ff77 	bl	ce8 <nffs_flash_write>
     dfa:	e000      	b.n	dfe <nffs_format_area+0x4a>

    area = nffs_areas + area_idx;

    rc = hal_flash_erase(area->na_flash_id, area->na_offset, area->na_length);
    if (rc != 0) {
        return FS_EHW;
     dfc:	2002      	movs	r0, #2
    if (rc != 0) {
        return rc;
    }

    return 0;
}
     dfe:	b006      	add	sp, #24
     e00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     e04:	20000b40 	.word	0x20000b40

00000e08 <nffs_format_from_scratch_area>:
 * actually a scratch area, this function falls back to a slower full format
 * operation.
 */
int
nffs_format_from_scratch_area(uint8_t area_idx, uint8_t area_id)
{
     e08:	b530      	push	{r4, r5, lr}
    struct nffs_disk_area disk_area;
    int rc;

    assert(area_idx < nffs_num_areas);
     e0a:	4b15      	ldr	r3, [pc, #84]	; (e60 <nffs_format_from_scratch_area+0x58>)
     e0c:	781b      	ldrb	r3, [r3, #0]
     e0e:	4283      	cmp	r3, r0
 * actually a scratch area, this function falls back to a slower full format
 * operation.
 */
int
nffs_format_from_scratch_area(uint8_t area_idx, uint8_t area_id)
{
     e10:	b087      	sub	sp, #28
     e12:	4604      	mov	r4, r0
     e14:	460d      	mov	r5, r1
    struct nffs_disk_area disk_area;
    int rc;

    assert(area_idx < nffs_num_areas);
     e16:	d805      	bhi.n	e24 <nffs_format_from_scratch_area+0x1c>
     e18:	2200      	movs	r2, #0
     e1a:	4812      	ldr	r0, [pc, #72]	; (e64 <nffs_format_from_scratch_area+0x5c>)
     e1c:	2125      	movs	r1, #37	; 0x25
     e1e:	4613      	mov	r3, r2
     e20:	f003 ff14 	bl	4c4c <__assert_func>
    rc = nffs_flash_read(area_idx, 0, &disk_area, sizeof disk_area);
     e24:	2100      	movs	r1, #0
     e26:	466a      	mov	r2, sp
     e28:	2318      	movs	r3, #24
     e2a:	f7ff ff37 	bl	c9c <nffs_flash_read>
    if (rc != 0) {
     e2e:	b9a8      	cbnz	r0, e5c <nffs_format_from_scratch_area+0x54>
        return rc;
    }

    nffs_areas[area_idx].na_id = area_id;
     e30:	4b0d      	ldr	r3, [pc, #52]	; (e68 <nffs_format_from_scratch_area+0x60>)
     e32:	681b      	ldr	r3, [r3, #0]
     e34:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    if (!nffs_area_is_scratch(&disk_area)) {
     e38:	4668      	mov	r0, sp
    rc = nffs_flash_read(area_idx, 0, &disk_area, sizeof disk_area);
    if (rc != 0) {
        return rc;
    }

    nffs_areas[area_idx].na_id = area_id;
     e3a:	819d      	strh	r5, [r3, #12]
    if (!nffs_area_is_scratch(&disk_area)) {
     e3c:	f001 fe8a 	bl	2b54 <nffs_area_is_scratch>
     e40:	4601      	mov	r1, r0
     e42:	b918      	cbnz	r0, e4c <nffs_format_from_scratch_area+0x44>
        rc = nffs_format_area(area_idx, 0);
     e44:	4620      	mov	r0, r4
     e46:	f7ff ffb5 	bl	db4 <nffs_format_area>
     e4a:	e007      	b.n	e5c <nffs_format_from_scratch_area+0x54>
        if (rc != 0) {
            return rc;
        }
    } else {
        disk_area.nda_id = area_id;
     e4c:	aa06      	add	r2, sp, #24
        rc = nffs_flash_write(area_idx, NFFS_AREA_OFFSET_ID,
     e4e:	4620      	mov	r0, r4
        rc = nffs_format_area(area_idx, 0);
        if (rc != 0) {
            return rc;
        }
    } else {
        disk_area.nda_id = area_id;
     e50:	f802 5d01 	strb.w	r5, [r2, #-1]!
        rc = nffs_flash_write(area_idx, NFFS_AREA_OFFSET_ID,
     e54:	2117      	movs	r1, #23
     e56:	2301      	movs	r3, #1
     e58:	f7ff ff46 	bl	ce8 <nffs_flash_write>
            return rc;
        }
    }

    return 0;
}
     e5c:	b007      	add	sp, #28
     e5e:	bd30      	pop	{r4, r5, pc}
     e60:	20000b24 	.word	0x20000b24
     e64:	0000622a 	.word	0x0000622a
     e68:	20000b40 	.word	0x20000b40

00000e6c <nffs_hash_find_reorder>:
    struct nffs_hash_entry *prev;
    struct nffs_hash_list *list;
    int idx;

    idx = nffs_hash_fn(id);
    list = nffs_hash + idx;
     e6c:	4b0b      	ldr	r3, [pc, #44]	; (e9c <nffs_hash_find_reorder+0x30>)
    return id % NFFS_HASH_SIZE;
}

static struct nffs_hash_entry *
nffs_hash_find_reorder(uint32_t id)
{
     e6e:	b570      	push	{r4, r5, r6, lr}
    struct nffs_hash_entry *prev;
    struct nffs_hash_list *list;
    int idx;

    idx = nffs_hash_fn(id);
    list = nffs_hash + idx;
     e70:	681d      	ldr	r5, [r3, #0]
}

static int
nffs_hash_fn(uint32_t id)
{
    return id % NFFS_HASH_SIZE;
     e72:	b2c4      	uxtb	r4, r0
    int idx;

    idx = nffs_hash_fn(id);
    list = nffs_hash + idx;

    prev = NULL;
     e74:	2200      	movs	r2, #0
    SLIST_FOREACH(entry, list, nhe_next) {
     e76:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
     e7a:	460b      	mov	r3, r1
     e7c:	b163      	cbz	r3, e98 <nffs_hash_find_reorder+0x2c>
        if (entry->nhe_id == id) {
     e7e:	685e      	ldr	r6, [r3, #4]
     e80:	4286      	cmp	r6, r0
     e82:	d106      	bne.n	e92 <nffs_hash_find_reorder+0x26>
            /* Put entry at the front of the list. */
            if (prev != NULL) {
     e84:	b142      	cbz	r2, e98 <nffs_hash_find_reorder+0x2c>
                SLIST_NEXT(prev, nhe_next) = SLIST_NEXT(entry, nhe_next);
     e86:	6818      	ldr	r0, [r3, #0]
     e88:	6010      	str	r0, [r2, #0]
                SLIST_INSERT_HEAD(list, entry, nhe_next);
     e8a:	6019      	str	r1, [r3, #0]
     e8c:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
     e90:	e002      	b.n	e98 <nffs_hash_find_reorder+0x2c>

    idx = nffs_hash_fn(id);
    list = nffs_hash + idx;

    prev = NULL;
    SLIST_FOREACH(entry, list, nhe_next) {
     e92:	461a      	mov	r2, r3
     e94:	681b      	ldr	r3, [r3, #0]
     e96:	e7f1      	b.n	e7c <nffs_hash_find_reorder+0x10>
        }

        prev = entry;
    }

    return NULL;
     e98:	4618      	mov	r0, r3
}
     e9a:	bd70      	pop	{r4, r5, r6, pc}
     e9c:	20000ca4 	.word	0x20000ca4

00000ea0 <nffs_hash_id_is_dir>:

int
nffs_hash_id_is_dir(uint32_t id)
{
    return id >= NFFS_ID_DIR_MIN && id < NFFS_ID_DIR_MAX;
}
     ea0:	f1b0 5f80 	cmp.w	r0, #268435456	; 0x10000000
     ea4:	bf2c      	ite	cs
     ea6:	2000      	movcs	r0, #0
     ea8:	2001      	movcc	r0, #1
     eaa:	4770      	bx	lr

00000eac <nffs_hash_id_is_file>:

int
nffs_hash_id_is_file(uint32_t id)
{
    return id >= NFFS_ID_FILE_MIN && id < NFFS_ID_FILE_MAX;
     eac:	f100 4070 	add.w	r0, r0, #4026531840	; 0xf0000000
}
     eb0:	f1b0 4fe0 	cmp.w	r0, #1879048192	; 0x70000000
     eb4:	bf2c      	ite	cs
     eb6:	2000      	movcs	r0, #0
     eb8:	2001      	movcc	r0, #1
     eba:	4770      	bx	lr

00000ebc <nffs_hash_id_is_inode>:

int
nffs_hash_id_is_inode(uint32_t id)
{
    return nffs_hash_id_is_dir(id) || nffs_hash_id_is_file(id);
}
     ebc:	43c0      	mvns	r0, r0
     ebe:	0fc0      	lsrs	r0, r0, #31
     ec0:	4770      	bx	lr
	...

00000ec4 <nffs_hash_id_is_block>:

int
nffs_hash_id_is_block(uint32_t id)
{
    return id >= NFFS_ID_BLOCK_MIN && id < NFFS_ID_BLOCK_MAX;
}
     ec4:	4b03      	ldr	r3, [pc, #12]	; (ed4 <nffs_hash_id_is_block+0x10>)
}

int
nffs_hash_id_is_block(uint32_t id)
{
    return id >= NFFS_ID_BLOCK_MIN && id < NFFS_ID_BLOCK_MAX;
     ec6:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
}
     eca:	4298      	cmp	r0, r3
     ecc:	bf8c      	ite	hi
     ece:	2000      	movhi	r0, #0
     ed0:	2001      	movls	r0, #1
     ed2:	4770      	bx	lr
     ed4:	7ffffffe 	.word	0x7ffffffe

00000ed8 <nffs_hash_find>:
    int idx;

    idx = nffs_hash_fn(id);
    list = nffs_hash + idx;

    SLIST_FOREACH(entry, list, nhe_next) {
     ed8:	4b06      	ldr	r3, [pc, #24]	; (ef4 <nffs_hash_find+0x1c>)
}

static int
nffs_hash_fn(uint32_t id)
{
    return id % NFFS_HASH_SIZE;
     eda:	b2c2      	uxtb	r2, r0
    int idx;

    idx = nffs_hash_fn(id);
    list = nffs_hash + idx;

    SLIST_FOREACH(entry, list, nhe_next) {
     edc:	681b      	ldr	r3, [r3, #0]
     ede:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     ee2:	b123      	cbz	r3, eee <nffs_hash_find+0x16>
        if (entry->nhe_id == id) {
     ee4:	685a      	ldr	r2, [r3, #4]
     ee6:	4282      	cmp	r2, r0
     ee8:	d001      	beq.n	eee <nffs_hash_find+0x16>
    int idx;

    idx = nffs_hash_fn(id);
    list = nffs_hash + idx;

    SLIST_FOREACH(entry, list, nhe_next) {
     eea:	681b      	ldr	r3, [r3, #0]
     eec:	e7f9      	b.n	ee2 <nffs_hash_find+0xa>
            return entry;
        }
    }

    return NULL;
}
     eee:	4618      	mov	r0, r3
     ef0:	4770      	bx	lr
     ef2:	bf00      	nop
     ef4:	20000ca4 	.word	0x20000ca4

00000ef8 <nffs_hash_find_inode>:

struct nffs_inode_entry *
nffs_hash_find_inode(uint32_t id)
{
     ef8:	b510      	push	{r4, lr}
     efa:	4604      	mov	r4, r0
    struct nffs_hash_entry *entry;

    assert(nffs_hash_id_is_inode(id));
     efc:	f7ff ffde 	bl	ebc <nffs_hash_id_is_inode>
     f00:	4602      	mov	r2, r0
     f02:	b920      	cbnz	r0, f0e <nffs_hash_find_inode+0x16>
     f04:	4804      	ldr	r0, [pc, #16]	; (f18 <nffs_hash_find_inode+0x20>)
     f06:	2172      	movs	r1, #114	; 0x72
     f08:	4613      	mov	r3, r2
     f0a:	f003 fe9f 	bl	4c4c <__assert_func>

    entry = nffs_hash_find_reorder(id);
     f0e:	4620      	mov	r0, r4
    return (struct nffs_inode_entry *)entry;
}
     f10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
    struct nffs_hash_entry *entry;

    assert(nffs_hash_id_is_inode(id));

    entry = nffs_hash_find_reorder(id);
     f14:	f7ff bfaa 	b.w	e6c <nffs_hash_find_reorder>
     f18:	00006238 	.word	0x00006238

00000f1c <nffs_hash_find_block>:
    return (struct nffs_inode_entry *)entry;
}

struct nffs_hash_entry *
nffs_hash_find_block(uint32_t id)
{
     f1c:	b508      	push	{r3, lr}
    struct nffs_hash_entry *entry;

    assert(nffs_hash_id_is_block(id));
     f1e:	4b07      	ldr	r3, [pc, #28]	; (f3c <nffs_hash_find_block+0x20>)
}

int
nffs_hash_id_is_block(uint32_t id)
{
    return id >= NFFS_ID_BLOCK_MIN && id < NFFS_ID_BLOCK_MAX;
     f20:	f100 4200 	add.w	r2, r0, #2147483648	; 0x80000000
struct nffs_hash_entry *
nffs_hash_find_block(uint32_t id)
{
    struct nffs_hash_entry *entry;

    assert(nffs_hash_id_is_block(id));
     f24:	429a      	cmp	r2, r3
     f26:	d905      	bls.n	f34 <nffs_hash_find_block+0x18>
     f28:	2200      	movs	r2, #0
     f2a:	4805      	ldr	r0, [pc, #20]	; (f40 <nffs_hash_find_block+0x24>)
     f2c:	217d      	movs	r1, #125	; 0x7d
     f2e:	4613      	mov	r3, r2
     f30:	f003 fe8c 	bl	4c4c <__assert_func>

    entry = nffs_hash_find_reorder(id);
    return entry;
}
     f34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
    struct nffs_hash_entry *entry;

    assert(nffs_hash_id_is_block(id));

    entry = nffs_hash_find_reorder(id);
     f38:	f7ff bf98 	b.w	e6c <nffs_hash_find_reorder>
     f3c:	7ffffffe 	.word	0x7ffffffe
     f40:	00006238 	.word	0x00006238

00000f44 <nffs_hash_entry_is_dummy>:
    return entry;
}

int
nffs_hash_entry_is_dummy(struct nffs_hash_entry *he)
{
     f44:	b510      	push	{r4, lr}
        return(he->nhe_flash_loc == NFFS_FLASH_LOC_NONE);
     f46:	2100      	movs	r1, #0
     f48:	6884      	ldr	r4, [r0, #8]
     f4a:	20ff      	movs	r0, #255	; 0xff
     f4c:	f7ff ff1c 	bl	d88 <nffs_flash_loc>
}
     f50:	1a23      	subs	r3, r4, r0
     f52:	4258      	negs	r0, r3
     f54:	4158      	adcs	r0, r3
     f56:	bd10      	pop	{r4, pc}

00000f58 <nffs_hash_id_is_dummy>:

int
nffs_hash_id_is_dummy(uint32_t id)
{
     f58:	b510      	push	{r4, lr}
    struct nffs_hash_entry *he = nffs_hash_find(id);
     f5a:	f7ff ffbd 	bl	ed8 <nffs_hash_find>
    if (he != NULL) {
     f5e:	b138      	cbz	r0, f70 <nffs_hash_id_is_dummy+0x18>
        return(he->nhe_flash_loc == NFFS_FLASH_LOC_NONE);
     f60:	6884      	ldr	r4, [r0, #8]
     f62:	2100      	movs	r1, #0
     f64:	20ff      	movs	r0, #255	; 0xff
     f66:	f7ff ff0f 	bl	d88 <nffs_flash_loc>
     f6a:	1a23      	subs	r3, r4, r0
     f6c:	4258      	negs	r0, r3
     f6e:	4158      	adcs	r0, r3
    }
    return 0;
}
     f70:	bd10      	pop	{r4, pc}
	...

00000f74 <nffs_hash_insert>:

void
nffs_hash_insert(struct nffs_hash_entry *entry)
{
     f74:	b538      	push	{r3, r4, r5, lr}
    struct nffs_hash_list *list;
    struct nffs_inode_entry *nie;
    int idx;

    assert(nffs_hash_find(entry->nhe_id) == NULL);
     f76:	6844      	ldr	r4, [r0, #4]
    return 0;
}

void
nffs_hash_insert(struct nffs_hash_entry *entry)
{
     f78:	4605      	mov	r5, r0
    struct nffs_hash_list *list;
    struct nffs_inode_entry *nie;
    int idx;

    assert(nffs_hash_find(entry->nhe_id) == NULL);
     f7a:	4620      	mov	r0, r4
     f7c:	f7ff ffac 	bl	ed8 <nffs_hash_find>
     f80:	b118      	cbz	r0, f8a <nffs_hash_insert+0x16>
     f82:	4814      	ldr	r0, [pc, #80]	; (fd4 <nffs_hash_insert+0x60>)
     f84:	219a      	movs	r1, #154	; 0x9a
     f86:	2200      	movs	r2, #0
     f88:	e012      	b.n	fb0 <nffs_hash_insert+0x3c>
    idx = nffs_hash_fn(entry->nhe_id);
    list = nffs_hash + idx;
     f8a:	4b13      	ldr	r3, [pc, #76]	; (fd8 <nffs_hash_insert+0x64>)
}

static int
nffs_hash_fn(uint32_t id)
{
    return id % NFFS_HASH_SIZE;
     f8c:	b2e2      	uxtb	r2, r4
    struct nffs_inode_entry *nie;
    int idx;

    assert(nffs_hash_find(entry->nhe_id) == NULL);
    idx = nffs_hash_fn(entry->nhe_id);
    list = nffs_hash + idx;
     f8e:	681b      	ldr	r3, [r3, #0]

    SLIST_INSERT_HEAD(list, entry, nhe_next);
     f90:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
     f94:	6029      	str	r1, [r5, #0]

    if (nffs_hash_id_is_inode(entry->nhe_id)) {
     f96:	4620      	mov	r0, r4

    assert(nffs_hash_find(entry->nhe_id) == NULL);
    idx = nffs_hash_fn(entry->nhe_id);
    list = nffs_hash + idx;

    SLIST_INSERT_HEAD(list, entry, nhe_next);
     f98:	f843 5022 	str.w	r5, [r3, r2, lsl #2]

    if (nffs_hash_id_is_inode(entry->nhe_id)) {
     f9c:	f7ff ff8e 	bl	ebc <nffs_hash_id_is_inode>
     fa0:	b170      	cbz	r0, fc0 <nffs_hash_insert+0x4c>
        nie = nffs_hash_find_inode(entry->nhe_id);
     fa2:	4620      	mov	r0, r4
     fa4:	f7ff ffa8 	bl	ef8 <nffs_hash_find_inode>
        assert(nie);
     fa8:	4602      	mov	r2, r0
     faa:	b920      	cbnz	r0, fb6 <nffs_hash_insert+0x42>
     fac:	4809      	ldr	r0, [pc, #36]	; (fd4 <nffs_hash_insert+0x60>)
     fae:	21a2      	movs	r1, #162	; 0xa2
     fb0:	4613      	mov	r3, r2
     fb2:	f003 fe4b 	bl	4c4c <__assert_func>
        nffs_inode_setflags(nie, NFFS_INODE_FLAG_INHASH);
     fb6:	2140      	movs	r1, #64	; 0x40
    } else {
        assert(nffs_hash_find(entry->nhe_id));
    }
}
     fb8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    SLIST_INSERT_HEAD(list, entry, nhe_next);

    if (nffs_hash_id_is_inode(entry->nhe_id)) {
        nie = nffs_hash_find_inode(entry->nhe_id);
        assert(nie);
        nffs_inode_setflags(nie, NFFS_INODE_FLAG_INHASH);
     fbc:	f000 bd0c 	b.w	19d8 <nffs_inode_setflags>
    } else {
        assert(nffs_hash_find(entry->nhe_id));
     fc0:	4620      	mov	r0, r4
     fc2:	f7ff ff89 	bl	ed8 <nffs_hash_find>
     fc6:	4602      	mov	r2, r0
     fc8:	b910      	cbnz	r0, fd0 <nffs_hash_insert+0x5c>
     fca:	4802      	ldr	r0, [pc, #8]	; (fd4 <nffs_hash_insert+0x60>)
     fcc:	21a5      	movs	r1, #165	; 0xa5
     fce:	e7ef      	b.n	fb0 <nffs_hash_insert+0x3c>
     fd0:	bd38      	pop	{r3, r4, r5, pc}
     fd2:	bf00      	nop
     fd4:	00006238 	.word	0x00006238
     fd8:	20000ca4 	.word	0x20000ca4

00000fdc <nffs_hash_remove>:
    }
}

void
nffs_hash_remove(struct nffs_hash_entry *entry)
{
     fdc:	b570      	push	{r4, r5, r6, lr}
    struct nffs_hash_list *list;
    struct nffs_inode_entry *nie = NULL;
    int idx;

    if (nffs_hash_id_is_inode(entry->nhe_id)) {
     fde:	6846      	ldr	r6, [r0, #4]
    }
}

void
nffs_hash_remove(struct nffs_hash_entry *entry)
{
     fe0:	4604      	mov	r4, r0
    struct nffs_hash_list *list;
    struct nffs_inode_entry *nie = NULL;
    int idx;

    if (nffs_hash_id_is_inode(entry->nhe_id)) {
     fe2:	4630      	mov	r0, r6
     fe4:	f7ff ff6a 	bl	ebc <nffs_hash_id_is_inode>
     fe8:	4605      	mov	r5, r0
        nie = nffs_hash_find_inode(entry->nhe_id);
     fea:	4630      	mov	r0, r6
{
    struct nffs_hash_list *list;
    struct nffs_inode_entry *nie = NULL;
    int idx;

    if (nffs_hash_id_is_inode(entry->nhe_id)) {
     fec:	b18d      	cbz	r5, 1012 <nffs_hash_remove+0x36>
        nie = nffs_hash_find_inode(entry->nhe_id);
     fee:	f7ff ff83 	bl	ef8 <nffs_hash_find_inode>
        assert(nie);
     ff2:	4605      	mov	r5, r0
     ff4:	b918      	cbnz	r0, ffe <nffs_hash_remove+0x22>
     ff6:	481c      	ldr	r0, [pc, #112]	; (1068 <nffs_hash_remove+0x8c>)
     ff8:	21b2      	movs	r1, #178	; 0xb2
     ffa:	462a      	mov	r2, r5
     ffc:	e006      	b.n	100c <nffs_hash_remove+0x30>
        assert(nffs_inode_getflags(nie, NFFS_INODE_FLAG_INHASH));
     ffe:	2140      	movs	r1, #64	; 0x40
    1000:	f000 fcf5 	bl	19ee <nffs_inode_getflags>
    1004:	4602      	mov	r2, r0
    1006:	b958      	cbnz	r0, 1020 <nffs_hash_remove+0x44>
    1008:	4817      	ldr	r0, [pc, #92]	; (1068 <nffs_hash_remove+0x8c>)
    100a:	21b3      	movs	r1, #179	; 0xb3
    100c:	4613      	mov	r3, r2
    100e:	f003 fe1d 	bl	4c4c <__assert_func>
    } else {
        assert(nffs_hash_find(entry->nhe_id));
    1012:	f7ff ff61 	bl	ed8 <nffs_hash_find>
    1016:	4602      	mov	r2, r0
    1018:	b910      	cbnz	r0, 1020 <nffs_hash_remove+0x44>
    101a:	4813      	ldr	r0, [pc, #76]	; (1068 <nffs_hash_remove+0x8c>)
    101c:	21b5      	movs	r1, #181	; 0xb5
    101e:	e7f5      	b.n	100c <nffs_hash_remove+0x30>
    }

    idx = nffs_hash_fn(entry->nhe_id);
    list = nffs_hash + idx;
    1020:	4b12      	ldr	r3, [pc, #72]	; (106c <nffs_hash_remove+0x90>)
        assert(nffs_inode_getflags(nie, NFFS_INODE_FLAG_INHASH));
    } else {
        assert(nffs_hash_find(entry->nhe_id));
    }

    idx = nffs_hash_fn(entry->nhe_id);
    1022:	6860      	ldr	r0, [r4, #4]
    list = nffs_hash + idx;
    1024:	681a      	ldr	r2, [r3, #0]
}

static int
nffs_hash_fn(uint32_t id)
{
    return id % NFFS_HASH_SIZE;
    1026:	b2c1      	uxtb	r1, r0
    }

    idx = nffs_hash_fn(entry->nhe_id);
    list = nffs_hash + idx;

    SLIST_REMOVE(list, entry, nffs_hash_entry, nhe_next);
    1028:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    102c:	42a3      	cmp	r3, r4
    102e:	d103      	bne.n	1038 <nffs_hash_remove+0x5c>
    1030:	6823      	ldr	r3, [r4, #0]
    1032:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    1036:	e006      	b.n	1046 <nffs_hash_remove+0x6a>
    1038:	681a      	ldr	r2, [r3, #0]
    103a:	42a2      	cmp	r2, r4
    103c:	d001      	beq.n	1042 <nffs_hash_remove+0x66>
    103e:	4613      	mov	r3, r2
    1040:	e7fa      	b.n	1038 <nffs_hash_remove+0x5c>
    1042:	6822      	ldr	r2, [r4, #0]
    1044:	601a      	str	r2, [r3, #0]

    if (nffs_hash_id_is_inode(entry->nhe_id) && nie) {
    1046:	f7ff ff39 	bl	ebc <nffs_hash_id_is_inode>
    104a:	b120      	cbz	r0, 1056 <nffs_hash_remove+0x7a>
    104c:	b11d      	cbz	r5, 1056 <nffs_hash_remove+0x7a>
        nffs_inode_unsetflags(nie, NFFS_INODE_FLAG_INHASH);
    104e:	4628      	mov	r0, r5
    1050:	2140      	movs	r1, #64	; 0x40
    1052:	f000 fcc6 	bl	19e2 <nffs_inode_unsetflags>
    }
    assert(nffs_hash_find(entry->nhe_id) == NULL);
    1056:	6860      	ldr	r0, [r4, #4]
    1058:	f7ff ff3e 	bl	ed8 <nffs_hash_find>
    105c:	b118      	cbz	r0, 1066 <nffs_hash_remove+0x8a>
    105e:	4802      	ldr	r0, [pc, #8]	; (1068 <nffs_hash_remove+0x8c>)
    1060:	21c0      	movs	r1, #192	; 0xc0
    1062:	2200      	movs	r2, #0
    1064:	e7d2      	b.n	100c <nffs_hash_remove+0x30>
    1066:	bd70      	pop	{r4, r5, r6, pc}
    1068:	00006238 	.word	0x00006238
    106c:	20000ca4 	.word	0x20000ca4

00001070 <nffs_hash_init>:
}

int
nffs_hash_init(void)
{
    1070:	b510      	push	{r4, lr}
    int i;

    free(nffs_hash);
    1072:	4c0a      	ldr	r4, [pc, #40]	; (109c <nffs_hash_init+0x2c>)
    1074:	6820      	ldr	r0, [r4, #0]
    1076:	f002 fc5f 	bl	3938 <free>

    nffs_hash = malloc(NFFS_HASH_SIZE * sizeof *nffs_hash);
    107a:	f44f 6080 	mov.w	r0, #1024	; 0x400
    107e:	f002 fc11 	bl	38a4 <malloc>
    1082:	6020      	str	r0, [r4, #0]
    if (nffs_hash == NULL) {
    1084:	b140      	cbz	r0, 1098 <nffs_hash_init+0x28>
    1086:	2300      	movs	r3, #0
        return FS_ENOMEM;
    }

    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        SLIST_INIT(nffs_hash + i);
    1088:	6822      	ldr	r2, [r4, #0]
    108a:	2000      	movs	r0, #0
    108c:	50d0      	str	r0, [r2, r3]
    108e:	3304      	adds	r3, #4
    nffs_hash = malloc(NFFS_HASH_SIZE * sizeof *nffs_hash);
    if (nffs_hash == NULL) {
        return FS_ENOMEM;
    }

    for (i = 0; i < NFFS_HASH_SIZE; i++) {
    1090:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    1094:	d1f8      	bne.n	1088 <nffs_hash_init+0x18>
    1096:	bd10      	pop	{r4, pc}

    free(nffs_hash);

    nffs_hash = malloc(NFFS_HASH_SIZE * sizeof *nffs_hash);
    if (nffs_hash == NULL) {
        return FS_ENOMEM;
    1098:	2005      	movs	r0, #5
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        SLIST_INIT(nffs_hash + i);
    }

    return 0;
}
    109a:	bd10      	pop	{r4, pc}
    109c:	20000ca4 	.word	0x20000ca4

000010a0 <nffs_inode_read_filename_chunk>:
}

static int
nffs_inode_read_filename_chunk(const struct nffs_inode *inode,
                               uint8_t filename_offset, void *buf, int len)
{
    10a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    10a2:	4616      	mov	r6, r2
    10a4:	461d      	mov	r5, r3
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    assert(filename_offset + len <= inode->ni_filename_len);
    10a6:	18ca      	adds	r2, r1, r3
    10a8:	7b03      	ldrb	r3, [r0, #12]
    10aa:	429a      	cmp	r2, r3
}

static int
nffs_inode_read_filename_chunk(const struct nffs_inode *inode,
                               uint8_t filename_offset, void *buf, int len)
{
    10ac:	460c      	mov	r4, r1
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    assert(filename_offset + len <= inode->ni_filename_len);
    10ae:	dd06      	ble.n	10be <nffs_inode_read_filename_chunk+0x1e>
    10b0:	2200      	movs	r2, #0
    10b2:	480c      	ldr	r0, [pc, #48]	; (10e4 <nffs_inode_read_filename_chunk+0x44>)
    10b4:	f240 21c6 	movw	r1, #710	; 0x2c6
    10b8:	4613      	mov	r3, r2
    10ba:	f003 fdc7 	bl	4c4c <__assert_func>

    nffs_flash_loc_expand(inode->ni_inode_entry->nie_hash_entry.nhe_flash_loc,
    10be:	6803      	ldr	r3, [r0, #0]
    10c0:	f10d 0103 	add.w	r1, sp, #3
    10c4:	6898      	ldr	r0, [r3, #8]
    10c6:	aa01      	add	r2, sp, #4
    10c8:	f7ff fe6e 	bl	da8 <nffs_flash_loc_expand>
    10cc:	9901      	ldr	r1, [sp, #4]
                          &area_idx, &area_offset);
    area_offset += sizeof (struct nffs_disk_inode) + filename_offset;

    rc = nffs_flash_read(area_idx, area_offset, buf, len);
    10ce:	f89d 0003 	ldrb.w	r0, [sp, #3]
    10d2:	3114      	adds	r1, #20

    assert(filename_offset + len <= inode->ni_filename_len);

    nffs_flash_loc_expand(inode->ni_inode_entry->nie_hash_entry.nhe_flash_loc,
                          &area_idx, &area_offset);
    area_offset += sizeof (struct nffs_disk_inode) + filename_offset;
    10d4:	4421      	add	r1, r4

    rc = nffs_flash_read(area_idx, area_offset, buf, len);
    10d6:	4632      	mov	r2, r6
    10d8:	462b      	mov	r3, r5

    assert(filename_offset + len <= inode->ni_filename_len);

    nffs_flash_loc_expand(inode->ni_inode_entry->nie_hash_entry.nhe_flash_loc,
                          &area_idx, &area_offset);
    area_offset += sizeof (struct nffs_disk_inode) + filename_offset;
    10da:	9101      	str	r1, [sp, #4]

    rc = nffs_flash_read(area_idx, area_offset, buf, len);
    10dc:	f7ff fdde 	bl	c9c <nffs_flash_read>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    10e0:	b002      	add	sp, #8
    10e2:	bd70      	pop	{r4, r5, r6, pc}
    10e4:	00006244 	.word	0x00006244

000010e8 <nffs_inode_entry_alloc>:
/** A list of directory inodes with pending unlink operations. */
static struct nffs_hash_list nffs_inode_unlink_list;

struct nffs_inode_entry *
nffs_inode_entry_alloc(void)
{
    10e8:	b510      	push	{r4, lr}
    struct nffs_inode_entry *inode_entry;

    inode_entry = os_memblock_get(&nffs_inode_entry_pool);
    10ea:	4805      	ldr	r0, [pc, #20]	; (1100 <nffs_inode_entry_alloc+0x18>)
    10ec:	f003 fe54 	bl	4d98 <os_memblock_get>
    if (inode_entry != NULL) {
    10f0:	4604      	mov	r4, r0
    10f2:	b118      	cbz	r0, 10fc <nffs_inode_entry_alloc+0x14>
        memset(inode_entry, 0, sizeof *inode_entry);
    10f4:	2100      	movs	r1, #0
    10f6:	2218      	movs	r2, #24
    10f8:	f002 fc34 	bl	3964 <memset>
    }

    return inode_entry;
}
    10fc:	4620      	mov	r0, r4
    10fe:	bd10      	pop	{r4, pc}
    1100:	20000b08 	.word	0x20000b08

00001104 <nffs_inode_entry_free>:

void
nffs_inode_entry_free(struct nffs_inode_entry *inode_entry)
{
    1104:	b510      	push	{r4, lr}
    if (inode_entry != NULL) {
    1106:	4604      	mov	r4, r0
    1108:	b178      	cbz	r0, 112a <nffs_inode_entry_free+0x26>
        assert(nffs_hash_id_is_inode(inode_entry->nie_hash_entry.nhe_id));
    110a:	6840      	ldr	r0, [r0, #4]
    110c:	f7ff fed6 	bl	ebc <nffs_hash_id_is_inode>
    1110:	4602      	mov	r2, r0
    1112:	b920      	cbnz	r0, 111e <nffs_inode_entry_free+0x1a>
    1114:	4805      	ldr	r0, [pc, #20]	; (112c <nffs_inode_entry_free+0x28>)
    1116:	2138      	movs	r1, #56	; 0x38
    1118:	4613      	mov	r3, r2
    111a:	f003 fd97 	bl	4c4c <__assert_func>
        os_memblock_put(&nffs_inode_entry_pool, inode_entry);
    111e:	4621      	mov	r1, r4
    1120:	4803      	ldr	r0, [pc, #12]	; (1130 <nffs_inode_entry_free+0x2c>)
    }
}
    1122:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void
nffs_inode_entry_free(struct nffs_inode_entry *inode_entry)
{
    if (inode_entry != NULL) {
        assert(nffs_hash_id_is_inode(inode_entry->nie_hash_entry.nhe_id));
        os_memblock_put(&nffs_inode_entry_pool, inode_entry);
    1126:	f003 be4b 	b.w	4dc0 <os_memblock_put>
    112a:	bd10      	pop	{r4, pc}
    112c:	00006244 	.word	0x00006244
    1130:	20000b08 	.word	0x20000b08

00001134 <nffs_inode_dec_refcnt_priv>:
}

static int
nffs_inode_dec_refcnt_priv(struct nffs_inode_entry *inode_entry,
                           int ignore_corruption)
{
    1134:	b570      	push	{r4, r5, r6, lr}
    1136:	460e      	mov	r6, r1
    int rc;

    assert(inode_entry);
    1138:	4604      	mov	r4, r0
    113a:	b920      	cbnz	r0, 1146 <nffs_inode_dec_refcnt_priv+0x12>
    113c:	4825      	ldr	r0, [pc, #148]	; (11d4 <nffs_inode_dec_refcnt_priv+0xa0>)
    113e:	f240 115d 	movw	r1, #349	; 0x15d
    1142:	4622      	mov	r2, r4
    1144:	e004      	b.n	1150 <nffs_inode_dec_refcnt_priv+0x1c>
    assert(inode_entry->nie_refcnt > 0);
    1146:	7d02      	ldrb	r2, [r0, #20]
    1148:	b92a      	cbnz	r2, 1156 <nffs_inode_dec_refcnt_priv+0x22>
    114a:	4822      	ldr	r0, [pc, #136]	; (11d4 <nffs_inode_dec_refcnt_priv+0xa0>)
    114c:	f44f 71af 	mov.w	r1, #350	; 0x15e
    1150:	4613      	mov	r3, r2
    1152:	f003 fd7b 	bl	4c4c <__assert_func>

    inode_entry->nie_refcnt--;
    1156:	3a01      	subs	r2, #1
    1158:	b2d2      	uxtb	r2, r2
    115a:	7502      	strb	r2, [r0, #20]
    if (inode_entry->nie_refcnt == 0) {
    115c:	2a00      	cmp	r2, #0
    115e:	d133      	bne.n	11c8 <nffs_inode_dec_refcnt_priv+0x94>
        if (nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
    1160:	6840      	ldr	r0, [r0, #4]
    1162:	f7ff fea3 	bl	eac <nffs_hash_id_is_file>
    1166:	4605      	mov	r5, r0
    1168:	b330      	cbz	r0, 11b8 <nffs_inode_dec_refcnt_priv+0x84>
nffs_inode_delete_from_ram(struct nffs_inode_entry *inode_entry,
                           int ignore_corruption)
{
    int rc;

    if (nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
    116a:	6860      	ldr	r0, [r4, #4]
    116c:	f7ff fe9e 	bl	eac <nffs_hash_id_is_file>
    1170:	b1c0      	cbz	r0, 11a4 <nffs_inode_dec_refcnt_priv+0x70>
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    1172:	7d63      	ldrb	r3, [r4, #21]
static int
nffs_inode_delete_blocks_from_ram(struct nffs_inode_entry *inode_entry)
{
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));
    1174:	6860      	ldr	r0, [r4, #4]
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    1176:	f063 037f 	orn	r3, r3, #127	; 0x7f
    117a:	7563      	strb	r3, [r4, #21]
static int
nffs_inode_delete_blocks_from_ram(struct nffs_inode_entry *inode_entry)
{
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));
    117c:	f7ff fe96 	bl	eac <nffs_hash_id_is_file>
    1180:	4602      	mov	r2, r0
    1182:	b930      	cbnz	r0, 1192 <nffs_inode_dec_refcnt_priv+0x5e>
    1184:	4813      	ldr	r0, [pc, #76]	; (11d4 <nffs_inode_dec_refcnt_priv+0xa0>)
    1186:	f240 1105 	movw	r1, #261	; 0x105
    118a:	e7e1      	b.n	1150 <nffs_inode_dec_refcnt_priv+0x1c>

    while (inode_entry->nie_last_block_entry != NULL) {
        rc = nffs_block_delete_from_ram(inode_entry->nie_last_block_entry);
    118c:	f001 fe68 	bl	2e60 <nffs_block_delete_from_ram>
        if (rc != 0) {
    1190:	b918      	cbnz	r0, 119a <nffs_inode_dec_refcnt_priv+0x66>
{
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));

    while (inode_entry->nie_last_block_entry != NULL) {
    1192:	6920      	ldr	r0, [r4, #16]
    1194:	2800      	cmp	r0, #0
    1196:	d1f9      	bne.n	118c <nffs_inode_dec_refcnt_priv+0x58>
    1198:	e004      	b.n	11a4 <nffs_inode_dec_refcnt_priv+0x70>
         * Record the intention to delete the file
         */
        nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DELETED);

        rc = nffs_inode_delete_blocks_from_ram(inode_entry);
        if (rc == FS_ECORRUPT && ignore_corruption) {
    119a:	2801      	cmp	r0, #1
    119c:	d116      	bne.n	11cc <nffs_inode_dec_refcnt_priv+0x98>
    119e:	b1ae      	cbz	r6, 11cc <nffs_inode_dec_refcnt_priv+0x98>
            inode_entry->nie_last_block_entry = NULL;
    11a0:	2300      	movs	r3, #0
    11a2:	6123      	str	r3, [r4, #16]
        } else if (rc != 0) {
            return rc;
        }
    }

    nffs_cache_inode_delete(inode_entry);
    11a4:	4620      	mov	r0, r4
    11a6:	f7ff fa9b 	bl	6e0 <nffs_cache_inode_delete>
    /*
     * XXX Not deleting empty inode delete records from hash could prevent
     * a case where we could lose delete records in a gc operation
     */
    nffs_hash_remove(&inode_entry->nie_hash_entry);
    11aa:	4620      	mov	r0, r4
    11ac:	f7ff ff16 	bl	fdc <nffs_hash_remove>
    nffs_inode_entry_free(inode_entry);
    11b0:	4620      	mov	r0, r4
    11b2:	f7ff ffa7 	bl	1104 <nffs_inode_entry_free>
    11b6:	e007      	b.n	11c8 <nffs_inode_dec_refcnt_priv+0x94>
 * @param inode_entry           The inode entry to insert.
 */
static void
nffs_inode_insert_unlink_list(struct nffs_inode_entry *inode_entry)
{
    nffs_hash_remove(&inode_entry->nie_hash_entry);
    11b8:	4620      	mov	r0, r4
    11ba:	f7ff ff0f 	bl	fdc <nffs_hash_remove>
    SLIST_INSERT_HEAD(&nffs_inode_unlink_list, &inode_entry->nie_hash_entry,
    11be:	4b06      	ldr	r3, [pc, #24]	; (11d8 <nffs_inode_dec_refcnt_priv+0xa4>)
    11c0:	681a      	ldr	r2, [r3, #0]
    11c2:	6022      	str	r2, [r4, #0]
    11c4:	601c      	str	r4, [r3, #0]
    11c6:	e002      	b.n	11ce <nffs_inode_dec_refcnt_priv+0x9a>
        } else {
            nffs_inode_insert_unlink_list(inode_entry);
        }
    }

    return 0;
    11c8:	2500      	movs	r5, #0
    11ca:	e000      	b.n	11ce <nffs_inode_dec_refcnt_priv+0x9a>
         * Record the intention to delete the file
         */
        nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DELETED);

        rc = nffs_inode_delete_blocks_from_ram(inode_entry);
        if (rc == FS_ECORRUPT && ignore_corruption) {
    11cc:	4605      	mov	r5, r0
            nffs_inode_insert_unlink_list(inode_entry);
        }
    }

    return 0;
}
    11ce:	4628      	mov	r0, r5
    11d0:	bd70      	pop	{r4, r5, r6, pc}
    11d2:	bf00      	nop
    11d4:	00006244 	.word	0x00006244
    11d8:	200005f8 	.word	0x200005f8

000011dc <nffs_inode_entry_reserve>:
 *                                  FS_ENOMEM on memory exhaustion;
 *                                  other nonzero on garbage collection error.
 */
int
nffs_inode_entry_reserve(struct nffs_inode_entry **out_inode_entry)
{
    11dc:	b513      	push	{r0, r1, r4, lr}
    11de:	4604      	mov	r4, r0
    int rc;

    do {
        *out_inode_entry = nffs_inode_entry_alloc();
    11e0:	f7ff ff82 	bl	10e8 <nffs_inode_entry_alloc>
    } while (nffs_misc_gc_if_oom(*out_inode_entry, &rc));
    11e4:	a901      	add	r1, sp, #4
nffs_inode_entry_reserve(struct nffs_inode_entry **out_inode_entry)
{
    int rc;

    do {
        *out_inode_entry = nffs_inode_entry_alloc();
    11e6:	6020      	str	r0, [r4, #0]
    } while (nffs_misc_gc_if_oom(*out_inode_entry, &rc));
    11e8:	f000 fc3c 	bl	1a64 <nffs_misc_gc_if_oom>
    11ec:	2800      	cmp	r0, #0
    11ee:	d1f7      	bne.n	11e0 <nffs_inode_entry_reserve+0x4>

    return rc;
}
    11f0:	9801      	ldr	r0, [sp, #4]
    11f2:	b002      	add	sp, #8
    11f4:	bd10      	pop	{r4, pc}

000011f6 <nffs_inode_read_disk>:
}

int
nffs_inode_read_disk(uint8_t area_idx, uint32_t offset,
                    struct nffs_disk_inode *out_disk_inode)
{
    11f6:	b510      	push	{r4, lr}
    int rc;

    rc = nffs_flash_read(area_idx, offset, out_disk_inode,
    11f8:	2314      	movs	r3, #20
}

int
nffs_inode_read_disk(uint8_t area_idx, uint32_t offset,
                    struct nffs_disk_inode *out_disk_inode)
{
    11fa:	4614      	mov	r4, r2
    int rc;

    rc = nffs_flash_read(area_idx, offset, out_disk_inode,
    11fc:	f7ff fd4e 	bl	c9c <nffs_flash_read>
                         sizeof *out_disk_inode);
    if (rc != 0) {
    1200:	b930      	cbnz	r0, 1210 <nffs_inode_read_disk+0x1a>
        return rc;
    }
    if (!nffs_hash_id_is_inode(out_disk_inode->ndi_id)) {
    1202:	6820      	ldr	r0, [r4, #0]
    1204:	f7ff fe5a 	bl	ebc <nffs_hash_id_is_inode>
    1208:	2800      	cmp	r0, #0
        return FS_EUNEXP;
    }

    return 0;
    120a:	bf0c      	ite	eq
    120c:	2009      	moveq	r0, #9
    120e:	2000      	movne	r0, #0
}
    1210:	bd10      	pop	{r4, pc}

00001212 <nffs_inode_write_disk>:

int
nffs_inode_write_disk(const struct nffs_disk_inode *disk_inode,
                      const char *filename, uint8_t area_idx,
                      uint32_t area_offset)
{
    1212:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1216:	4606      	mov	r6, r0
    1218:	460f      	mov	r7, r1
    121a:	4615      	mov	r5, r2
    121c:	461c      	mov	r4, r3
    int rc;

    rc = nffs_flash_write(area_idx, area_offset, disk_inode,
    121e:	4610      	mov	r0, r2
    1220:	4619      	mov	r1, r3
    1222:	4632      	mov	r2, r6
    1224:	2314      	movs	r3, #20
    1226:	f7ff fd5f 	bl	ce8 <nffs_flash_write>
                          sizeof *disk_inode);
    if (rc != 0) {
    122a:	b950      	cbnz	r0, 1242 <nffs_inode_write_disk+0x30>
        return rc;
    }

    if (disk_inode->ndi_filename_len != 0) {
    122c:	7c73      	ldrb	r3, [r6, #17]
    122e:	b13b      	cbz	r3, 1240 <nffs_inode_write_disk+0x2e>
        rc = nffs_flash_write(area_idx, area_offset + sizeof *disk_inode,
    1230:	4628      	mov	r0, r5
    1232:	f104 0114 	add.w	r1, r4, #20
    1236:	463a      	mov	r2, r7

    ASSERT_IF_TEST(nffs_crc_disk_inode_validate(disk_inode, area_idx,
                                                area_offset) == 0);

    return 0;
}
    1238:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (rc != 0) {
        return rc;
    }

    if (disk_inode->ndi_filename_len != 0) {
        rc = nffs_flash_write(area_idx, area_offset + sizeof *disk_inode,
    123c:	f7ff bd54 	b.w	ce8 <nffs_flash_write>
    }

    ASSERT_IF_TEST(nffs_crc_disk_inode_validate(disk_inode, area_idx,
                                                area_offset) == 0);

    return 0;
    1240:	4618      	mov	r0, r3
}
    1242:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

00001248 <nffs_inode_calc_data_length>:

int
nffs_inode_calc_data_length(struct nffs_inode_entry *inode_entry,
                            uint32_t *out_len)
{
    1248:	b530      	push	{r4, r5, lr}
    124a:	4605      	mov	r5, r0
    124c:	b087      	sub	sp, #28
    struct nffs_hash_entry *cur;
    struct nffs_block block;
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));
    124e:	6840      	ldr	r0, [r0, #4]
}

int
nffs_inode_calc_data_length(struct nffs_inode_entry *inode_entry,
                            uint32_t *out_len)
{
    1250:	460c      	mov	r4, r1
    struct nffs_hash_entry *cur;
    struct nffs_block block;
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));
    1252:	f7ff fe2b 	bl	eac <nffs_hash_id_is_file>
    1256:	4602      	mov	r2, r0
    1258:	b920      	cbnz	r0, 1264 <nffs_inode_calc_data_length+0x1c>
    125a:	480b      	ldr	r0, [pc, #44]	; (1288 <nffs_inode_calc_data_length+0x40>)
    125c:	2191      	movs	r1, #145	; 0x91
    125e:	4613      	mov	r3, r2
    1260:	f003 fcf4 	bl	4c4c <__assert_func>

    *out_len = 0;
    1264:	2300      	movs	r3, #0
    1266:	6023      	str	r3, [r4, #0]

    cur = inode_entry->nie_last_block_entry;
    1268:	6929      	ldr	r1, [r5, #16]
    while (cur != NULL) {
    126a:	b151      	cbz	r1, 1282 <nffs_inode_calc_data_length+0x3a>
        rc = nffs_block_from_hash_entry(&block, cur);
    126c:	a801      	add	r0, sp, #4
    126e:	f001 fdb1 	bl	2dd4 <nffs_block_from_hash_entry>
        if (rc != 0) {
    1272:	b938      	cbnz	r0, 1284 <nffs_inode_calc_data_length+0x3c>
            return rc;
        }

        *out_len += block.nb_data_len;
    1274:	6822      	ldr	r2, [r4, #0]
    1276:	f8bd 3014 	ldrh.w	r3, [sp, #20]

        cur = block.nb_prev;
    127a:	9904      	ldr	r1, [sp, #16]
        rc = nffs_block_from_hash_entry(&block, cur);
        if (rc != 0) {
            return rc;
        }

        *out_len += block.nb_data_len;
    127c:	4413      	add	r3, r2
    127e:	6023      	str	r3, [r4, #0]
    1280:	e7f3      	b.n	126a <nffs_inode_calc_data_length+0x22>

        cur = block.nb_prev;
    }

    return 0;
    1282:	4608      	mov	r0, r1
}
    1284:	b007      	add	sp, #28
    1286:	bd30      	pop	{r4, r5, pc}
    1288:	00006244 	.word	0x00006244

0000128c <nffs_inode_data_len>:

int
nffs_inode_data_len(struct nffs_inode_entry *inode_entry, uint32_t *out_len)
{
    128c:	b513      	push	{r0, r1, r4, lr}
    128e:	4603      	mov	r3, r0
    1290:	460c      	mov	r4, r1
    struct nffs_cache_inode *cache_inode;
    int rc;

    rc = nffs_cache_inode_ensure(&cache_inode, inode_entry);
    1292:	a801      	add	r0, sp, #4
    1294:	4619      	mov	r1, r3
    1296:	f7ff fa39 	bl	70c <nffs_cache_inode_ensure>
    if (rc != 0) {
    129a:	b910      	cbnz	r0, 12a2 <nffs_inode_data_len+0x16>
        return rc;
    }

    *out_len = cache_inode->nci_file_size;
    129c:	9b01      	ldr	r3, [sp, #4]
    129e:	6a1b      	ldr	r3, [r3, #32]
    12a0:	6023      	str	r3, [r4, #0]

    return 0;
}
    12a2:	b002      	add	sp, #8
    12a4:	bd10      	pop	{r4, pc}

000012a6 <nffs_inode_parent_id>:
}

uint32_t
nffs_inode_parent_id(const struct nffs_inode *inode)
{
    if (inode->ni_parent == NULL) {
    12a6:	6883      	ldr	r3, [r0, #8]
    12a8:	b10b      	cbz	r3, 12ae <nffs_inode_parent_id+0x8>
        return NFFS_ID_NONE;
    } else {
        return inode->ni_parent->nie_hash_entry.nhe_id;
    12aa:	6858      	ldr	r0, [r3, #4]
    12ac:	4770      	bx	lr

uint32_t
nffs_inode_parent_id(const struct nffs_inode *inode)
{
    if (inode->ni_parent == NULL) {
        return NFFS_ID_NONE;
    12ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    } else {
        return inode->ni_parent->nie_hash_entry.nhe_id;
    }
}
    12b2:	4770      	bx	lr

000012b4 <nffs_inode_inc_refcnt>:
    return 0;
}

int
nffs_inode_inc_refcnt(struct nffs_inode_entry *inode_entry)
{
    12b4:	b508      	push	{r3, lr}
    assert(inode_entry);
    12b6:	4602      	mov	r2, r0
    12b8:	b928      	cbnz	r0, 12c6 <nffs_inode_inc_refcnt+0x12>
    12ba:	4805      	ldr	r0, [pc, #20]	; (12d0 <nffs_inode_inc_refcnt+0x1c>)
    12bc:	f44f 71b9 	mov.w	r1, #370	; 0x172
    12c0:	4613      	mov	r3, r2
    12c2:	f003 fcc3 	bl	4c4c <__assert_func>
    inode_entry->nie_refcnt++;
    12c6:	7d03      	ldrb	r3, [r0, #20]
    12c8:	3301      	adds	r3, #1
    12ca:	7503      	strb	r3, [r0, #20]
    return 0;
}
    12cc:	2000      	movs	r0, #0
    12ce:	bd08      	pop	{r3, pc}
    12d0:	00006244 	.word	0x00006244

000012d4 <nffs_inode_dec_refcnt>:
int
nffs_inode_dec_refcnt(struct nffs_inode_entry *inode_entry)
{
    int rc;

    rc = nffs_inode_dec_refcnt_priv(inode_entry, 0);
    12d4:	2100      	movs	r1, #0
    12d6:	f7ff bf2d 	b.w	1134 <nffs_inode_dec_refcnt_priv>
	...

000012dc <nffs_inode_delete_from_disk>:
    return 0;
}

int
nffs_inode_delete_from_disk(struct nffs_inode *inode)
{
    12dc:	b530      	push	{r4, r5, lr}
    uint32_t offset;
    uint8_t area_idx;
    int rc;

    /* Make sure it isn't already deleted. */
    assert(inode->ni_parent != NULL);
    12de:	6882      	ldr	r2, [r0, #8]
    return 0;
}

int
nffs_inode_delete_from_disk(struct nffs_inode *inode)
{
    12e0:	b089      	sub	sp, #36	; 0x24
    12e2:	4605      	mov	r5, r0
    uint32_t offset;
    uint8_t area_idx;
    int rc;

    /* Make sure it isn't already deleted. */
    assert(inode->ni_parent != NULL);
    12e4:	b92a      	cbnz	r2, 12f2 <nffs_inode_delete_from_disk+0x16>
    12e6:	481d      	ldr	r0, [pc, #116]	; (135c <nffs_inode_delete_from_disk+0x80>)
    12e8:	f44f 71e6 	mov.w	r1, #460	; 0x1cc
    12ec:	4613      	mov	r3, r2
    12ee:	f003 fcad 	bl	4c4c <__assert_func>

    rc = nffs_misc_reserve_space(sizeof disk_inode, &area_idx, &offset);
    12f2:	2014      	movs	r0, #20
    12f4:	f10d 0107 	add.w	r1, sp, #7
    12f8:	aa02      	add	r2, sp, #8
    12fa:	f000 fbd3 	bl	1aa4 <nffs_misc_reserve_space>
    if (rc != 0) {
    12fe:	bb58      	cbnz	r0, 1358 <nffs_inode_delete_from_disk+0x7c>
        return rc;
    }

    inode->ni_seq++;

    disk_inode.ndi_id = inode->ni_inode_entry->nie_hash_entry.nhe_id;
    1300:	682a      	ldr	r2, [r5, #0]
    rc = nffs_misc_reserve_space(sizeof disk_inode, &area_idx, &offset);
    if (rc != 0) {
        return rc;
    }

    inode->ni_seq++;
    1302:	686b      	ldr	r3, [r5, #4]

    disk_inode.ndi_id = inode->ni_inode_entry->nie_hash_entry.nhe_id;
    1304:	6851      	ldr	r1, [r2, #4]
    1306:	9103      	str	r1, [sp, #12]
    rc = nffs_misc_reserve_space(sizeof disk_inode, &area_idx, &offset);
    if (rc != 0) {
        return rc;
    }

    inode->ni_seq++;
    1308:	3301      	adds	r3, #1

    disk_inode.ndi_id = inode->ni_inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode->ni_seq;
    disk_inode.ndi_parent_id = NFFS_ID_NONE;
    disk_inode.ndi_flags = NFFS_INODE_FLAG_DELETED;
    130a:	2180      	movs	r1, #128	; 0x80
    rc = nffs_misc_reserve_space(sizeof disk_inode, &area_idx, &offset);
    if (rc != 0) {
        return rc;
    }

    inode->ni_seq++;
    130c:	606b      	str	r3, [r5, #4]

    disk_inode.ndi_id = inode->ni_inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode->ni_seq;
    disk_inode.ndi_parent_id = NFFS_ID_NONE;
    disk_inode.ndi_flags = NFFS_INODE_FLAG_DELETED;
    130e:	f88d 101c 	strb.w	r1, [sp, #28]
    if (inode->ni_inode_entry->nie_last_block_entry) {
    1312:	6912      	ldr	r2, [r2, #16]
    }

    inode->ni_seq++;

    disk_inode.ndi_id = inode->ni_inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode->ni_seq;
    1314:	f8ad 3018 	strh.w	r3, [sp, #24]
    disk_inode.ndi_parent_id = NFFS_ID_NONE;
    1318:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    131c:	9304      	str	r3, [sp, #16]
    disk_inode.ndi_flags = NFFS_INODE_FLAG_DELETED;
    if (inode->ni_inode_entry->nie_last_block_entry) {
    131e:	b102      	cbz	r2, 1322 <nffs_inode_delete_from_disk+0x46>
        disk_inode.ndi_lastblock_id =
    1320:	6853      	ldr	r3, [r2, #4]
                          inode->ni_inode_entry->nie_last_block_entry->nhe_id;
    } else {
        disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
    1322:	9305      	str	r3, [sp, #20]
    }
    disk_inode.ndi_filename_len = 0;
    nffs_crc_disk_inode_fill(&disk_inode, "");
    1324:	a803      	add	r0, sp, #12
        disk_inode.ndi_lastblock_id =
                          inode->ni_inode_entry->nie_last_block_entry->nhe_id;
    } else {
        disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
    }
    disk_inode.ndi_filename_len = 0;
    1326:	2300      	movs	r3, #0
    nffs_crc_disk_inode_fill(&disk_inode, "");
    1328:	490d      	ldr	r1, [pc, #52]	; (1360 <nffs_inode_delete_from_disk+0x84>)
        disk_inode.ndi_lastblock_id =
                          inode->ni_inode_entry->nie_last_block_entry->nhe_id;
    } else {
        disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
    }
    disk_inode.ndi_filename_len = 0;
    132a:	f88d 301d 	strb.w	r3, [sp, #29]
    nffs_crc_disk_inode_fill(&disk_inode, "");
    132e:	f001 fe27 	bl	2f80 <nffs_crc_disk_inode_fill>

    rc = nffs_inode_write_disk(&disk_inode, "", area_idx, offset);
    1332:	9b02      	ldr	r3, [sp, #8]
    1334:	490a      	ldr	r1, [pc, #40]	; (1360 <nffs_inode_delete_from_disk+0x84>)
    1336:	f89d 2007 	ldrb.w	r2, [sp, #7]
    133a:	a803      	add	r0, sp, #12
    133c:	f7ff ff69 	bl	1212 <nffs_inode_write_disk>
    /*
     * Flag the incore inode as deleted to the inode won't get updated to
     * disk. This could happen if the refcnt > 0 and there are future appends
     * XXX only do this for files and not directories
     */
    if (nffs_hash_id_is_file(inode->ni_inode_entry->nie_hash_entry.nhe_id)) {
    1340:	682b      	ldr	r3, [r5, #0]
        disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
    }
    disk_inode.ndi_filename_len = 0;
    nffs_crc_disk_inode_fill(&disk_inode, "");

    rc = nffs_inode_write_disk(&disk_inode, "", area_idx, offset);
    1342:	4604      	mov	r4, r0
    /*
     * Flag the incore inode as deleted to the inode won't get updated to
     * disk. This could happen if the refcnt > 0 and there are future appends
     * XXX only do this for files and not directories
     */
    if (nffs_hash_id_is_file(inode->ni_inode_entry->nie_hash_entry.nhe_id)) {
    1344:	6858      	ldr	r0, [r3, #4]
    1346:	f7ff fdb1 	bl	eac <nffs_hash_id_is_file>
    134a:	b120      	cbz	r0, 1356 <nffs_inode_delete_from_disk+0x7a>
        nffs_inode_setflags(inode->ni_inode_entry, NFFS_INODE_FLAG_DELETED);
    134c:	682a      	ldr	r2, [r5, #0]
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    134e:	7d53      	ldrb	r3, [r2, #21]
    1350:	f063 037f 	orn	r3, r3, #127	; 0x7f
    1354:	7553      	strb	r3, [r2, #21]
    1356:	4620      	mov	r0, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    1358:	b009      	add	sp, #36	; 0x24
    135a:	bd30      	pop	{r4, r5, pc}
    135c:	00006244 	.word	0x00006244
    1360:	00006305 	.word	0x00006305

00001364 <nffs_inode_remove_child>:
    return 0;
}

void
nffs_inode_remove_child(struct nffs_inode *child)
{
    1364:	b538      	push	{r3, r4, r5, lr}
}

int
nffs_inode_getflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    return (int)(entry->nie_flags & flag);
    1366:	6803      	ldr	r3, [r0, #0]
    1368:	7d5b      	ldrb	r3, [r3, #21]
    136a:	f003 0320 	and.w	r3, r3, #32
    return 0;
}

void
nffs_inode_remove_child(struct nffs_inode *child)
{
    136e:	4605      	mov	r5, r0
    struct nffs_inode_entry *parent;

    assert(nffs_inode_getflags(child->ni_inode_entry, NFFS_INODE_FLAG_INTREE));
    1370:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1374:	b91b      	cbnz	r3, 137e <nffs_inode_remove_child+0x1a>
    1376:	4816      	ldr	r0, [pc, #88]	; (13d0 <nffs_inode_remove_child+0x6c>)
    1378:	f240 3137 	movw	r1, #823	; 0x337
    137c:	e005      	b.n	138a <nffs_inode_remove_child+0x26>
    parent = child->ni_parent;
    137e:	6884      	ldr	r4, [r0, #8]
    assert(parent != NULL);
    1380:	b934      	cbnz	r4, 1390 <nffs_inode_remove_child+0x2c>
    1382:	4813      	ldr	r0, [pc, #76]	; (13d0 <nffs_inode_remove_child+0x6c>)
    1384:	f240 3139 	movw	r1, #825	; 0x339
    1388:	4622      	mov	r2, r4
    138a:	4613      	mov	r3, r2
    138c:	f003 fc5e 	bl	4c4c <__assert_func>
    assert(nffs_hash_id_is_dir(parent->nie_hash_entry.nhe_id));
    1390:	6860      	ldr	r0, [r4, #4]
    1392:	f7ff fd85 	bl	ea0 <nffs_hash_id_is_dir>
    1396:	4602      	mov	r2, r0
    1398:	b918      	cbnz	r0, 13a2 <nffs_inode_remove_child+0x3e>
    139a:	480d      	ldr	r0, [pc, #52]	; (13d0 <nffs_inode_remove_child+0x6c>)
    139c:	f240 313a 	movw	r1, #826	; 0x33a
    13a0:	e7f3      	b.n	138a <nffs_inode_remove_child+0x26>
    SLIST_REMOVE(&parent->nie_child_list, child->ni_inode_entry,
    13a2:	6923      	ldr	r3, [r4, #16]
    13a4:	682a      	ldr	r2, [r5, #0]
    13a6:	4293      	cmp	r3, r2
    13a8:	d102      	bne.n	13b0 <nffs_inode_remove_child+0x4c>
    13aa:	68db      	ldr	r3, [r3, #12]
    13ac:	6123      	str	r3, [r4, #16]
    13ae:	e006      	b.n	13be <nffs_inode_remove_child+0x5a>
    13b0:	68d9      	ldr	r1, [r3, #12]
    13b2:	4291      	cmp	r1, r2
    13b4:	d001      	beq.n	13ba <nffs_inode_remove_child+0x56>
    13b6:	460b      	mov	r3, r1
    13b8:	e7fa      	b.n	13b0 <nffs_inode_remove_child+0x4c>
    13ba:	68d2      	ldr	r2, [r2, #12]
    13bc:	60da      	str	r2, [r3, #12]
                 nffs_inode_entry, nie_sibling_next);
    SLIST_NEXT(child->ni_inode_entry, nie_sibling_next) = NULL;
    13be:	682b      	ldr	r3, [r5, #0]
    13c0:	2200      	movs	r2, #0
    13c2:	60da      	str	r2, [r3, #12]
}

int
nffs_inode_unsetflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    entry->nie_flags &= ~flag;
    13c4:	7d5a      	ldrb	r2, [r3, #21]
    13c6:	f022 0220 	bic.w	r2, r2, #32
    13ca:	755a      	strb	r2, [r3, #21]
    13cc:	bd38      	pop	{r3, r4, r5, pc}
    13ce:	bf00      	nop
    13d0:	00006244 	.word	0x00006244

000013d4 <nffs_inode_unlink_from_ram_priv>:
                                int ignore_corruption,
                                struct nffs_hash_entry **out_next)
{
    int rc;

    if (inode->ni_parent != NULL) {
    13d4:	6883      	ldr	r3, [r0, #8]

static int
nffs_inode_unlink_from_ram_priv(struct nffs_inode *inode,
                                int ignore_corruption,
                                struct nffs_hash_entry **out_next)
{
    13d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    13da:	4604      	mov	r4, r0
    13dc:	460f      	mov	r7, r1
    13de:	4616      	mov	r6, r2
    int rc;

    if (inode->ni_parent != NULL) {
    13e0:	b10b      	cbz	r3, 13e6 <nffs_inode_unlink_from_ram_priv+0x12>
        nffs_inode_remove_child(inode);
    13e2:	f7ff ffbf 	bl	1364 <nffs_inode_remove_child>

    /*
     * Regardless of whether the inode is removed from hashlist, we record
     * the intention to delete it here.
     */
    nffs_inode_setflags(inode->ni_inode_entry, NFFS_INODE_FLAG_DELETED);
    13e6:	6822      	ldr	r2, [r4, #0]
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    13e8:	7d53      	ldrb	r3, [r2, #21]
    13ea:	f063 037f 	orn	r3, r3, #127	; 0x7f
    13ee:	7553      	strb	r3, [r2, #21]
     * Regardless of whether the inode is removed from hashlist, we record
     * the intention to delete it here.
     */
    nffs_inode_setflags(inode->ni_inode_entry, NFFS_INODE_FLAG_DELETED);

    if (nffs_hash_id_is_dir(inode->ni_inode_entry->nie_hash_entry.nhe_id)) {
    13f0:	6823      	ldr	r3, [r4, #0]
    13f2:	6858      	ldr	r0, [r3, #4]
    13f4:	f7ff fd54 	bl	ea0 <nffs_hash_id_is_dir>
    13f8:	b380      	cbz	r0, 145c <nffs_inode_unlink_from_ram_priv+0x88>
        nffs_inode_insert_unlink_list(inode->ni_inode_entry);
    13fa:	6824      	ldr	r4, [r4, #0]
 * @param inode_entry           The inode entry to insert.
 */
static void
nffs_inode_insert_unlink_list(struct nffs_inode_entry *inode_entry)
{
    nffs_hash_remove(&inode_entry->nie_hash_entry);
    13fc:	4620      	mov	r0, r4
    13fe:	f7ff fded 	bl	fdc <nffs_hash_remove>
    SLIST_INSERT_HEAD(&nffs_inode_unlink_list, &inode_entry->nie_hash_entry,
    1402:	4b1b      	ldr	r3, [pc, #108]	; (1470 <nffs_inode_unlink_from_ram_priv+0x9c>)
    1404:	681a      	ldr	r2, [r3, #0]
    1406:	6022      	str	r2, [r4, #0]
    1408:	601c      	str	r4, [r3, #0]
    140a:	461d      	mov	r5, r3
    struct nffs_inode_entry *child_next;
    struct nffs_inode_entry *child;
    struct nffs_hash_entry *hash_entry;
    int rc;

    while ((hash_entry = SLIST_FIRST(&nffs_inode_unlink_list)) != NULL) {
    140c:	682c      	ldr	r4, [r5, #0]
    140e:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1470 <nffs_inode_unlink_from_ram_priv+0x9c>
    1412:	b344      	cbz	r4, 1466 <nffs_inode_unlink_from_ram_priv+0x92>
        assert(nffs_hash_id_is_dir(hash_entry->nhe_id));
    1414:	6860      	ldr	r0, [r4, #4]
    1416:	f7ff fd43 	bl	ea0 <nffs_hash_id_is_dir>
    141a:	4602      	mov	r2, r0
    141c:	b928      	cbnz	r0, 142a <nffs_inode_unlink_from_ram_priv+0x56>
    141e:	4815      	ldr	r0, [pc, #84]	; (1474 <nffs_inode_unlink_from_ram_priv+0xa0>)
    1420:	f240 11a1 	movw	r1, #417	; 0x1a1
    1424:	4613      	mov	r3, r2
    1426:	f003 fc11 	bl	4c4c <__assert_func>

        SLIST_REMOVE_HEAD(&nffs_inode_unlink_list, nhe_next);
    142a:	f8d8 3000 	ldr.w	r3, [r8]

        inode_entry = (struct nffs_inode_entry *)hash_entry;

        /* Recursively unlink each child. */
        child = SLIST_FIRST(&inode_entry->nie_child_list);
    142e:	6920      	ldr	r0, [r4, #16]
    int rc;

    while ((hash_entry = SLIST_FIRST(&nffs_inode_unlink_list)) != NULL) {
        assert(nffs_hash_id_is_dir(hash_entry->nhe_id));

        SLIST_REMOVE_HEAD(&nffs_inode_unlink_list, nhe_next);
    1430:	681b      	ldr	r3, [r3, #0]
    1432:	f8c8 3000 	str.w	r3, [r8]

        inode_entry = (struct nffs_inode_entry *)hash_entry;

        /* Recursively unlink each child. */
        child = SLIST_FIRST(&inode_entry->nie_child_list);
        while (child != NULL) {
    1436:	b168      	cbz	r0, 1454 <nffs_inode_unlink_from_ram_priv+0x80>
            child_next = SLIST_NEXT(child, nie_sibling_next);
    1438:	f8d0 800c 	ldr.w	r8, [r0, #12]

            if (inout_next != NULL && *inout_next == &child->nie_hash_entry) {
    143c:	b126      	cbz	r6, 1448 <nffs_inode_unlink_from_ram_priv+0x74>
    143e:	6833      	ldr	r3, [r6, #0]
    1440:	4283      	cmp	r3, r0
                *inout_next = &child_next->nie_hash_entry;
    1442:	bf08      	it	eq
    1444:	f8c6 8000 	streq.w	r8, [r6]
            }

            rc = nffs_inode_dec_refcnt_priv(child, ignore_corruption);
    1448:	4639      	mov	r1, r7
    144a:	f7ff fe73 	bl	1134 <nffs_inode_dec_refcnt_priv>
            if (rc != 0) {
    144e:	b968      	cbnz	r0, 146c <nffs_inode_unlink_from_ram_priv+0x98>
                return rc;
            }

            child = child_next;
    1450:	4640      	mov	r0, r8
    1452:	e7f0      	b.n	1436 <nffs_inode_unlink_from_ram_priv+0x62>


        /* The directory is already removed from the hash table; just free its
         * memory.
         */
        nffs_inode_entry_free(inode_entry);
    1454:	4620      	mov	r0, r4
    1456:	f7ff fe55 	bl	1104 <nffs_inode_entry_free>
    145a:	e7d7      	b.n	140c <nffs_inode_unlink_from_ram_priv+0x38>

    if (nffs_hash_id_is_dir(inode->ni_inode_entry->nie_hash_entry.nhe_id)) {
        nffs_inode_insert_unlink_list(inode->ni_inode_entry);
        rc = nffs_inode_process_unlink_list(out_next, ignore_corruption);
    } else {
        rc = nffs_inode_dec_refcnt_priv(inode->ni_inode_entry,
    145c:	6820      	ldr	r0, [r4, #0]
    145e:	4639      	mov	r1, r7
    1460:	f7ff fe68 	bl	1134 <nffs_inode_dec_refcnt_priv>
                                        ignore_corruption);
    }
    if (rc != 0) {
    1464:	b910      	cbnz	r0, 146c <nffs_inode_unlink_from_ram_priv+0x98>
        return rc;
    }

    return 0;
    1466:	2000      	movs	r0, #0
    1468:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
}
    146c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1470:	200005f8 	.word	0x200005f8
    1474:	00006244 	.word	0x00006244

00001478 <nffs_inode_filename_cmp_ram>:

int
nffs_inode_filename_cmp_ram(const struct nffs_inode *inode,
                            const char *name, int name_len,
                            int *result)
{
    1478:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int chunk_len;
    int rem_len;
    int off;
    int rc;

    if (name_len < inode->ni_filename_len) {
    147c:	7b05      	ldrb	r5, [r0, #12]
    147e:	4295      	cmp	r5, r2
    1480:	bfa8      	it	ge
    1482:	4615      	movge	r5, r2
    1484:	2d03      	cmp	r5, #3
    1486:	462c      	mov	r4, r5
    1488:	bfa8      	it	ge
    148a:	2403      	movge	r4, #3

int
nffs_inode_filename_cmp_ram(const struct nffs_inode *inode,
                            const char *name, int name_len,
                            int *result)
{
    148c:	4607      	mov	r7, r0
    148e:	4690      	mov	r8, r2
    if (short_len <= NFFS_SHORT_FILENAME_LEN) {
        chunk_len = short_len;
    } else {
        chunk_len = NFFS_SHORT_FILENAME_LEN;
    }
    *result = strncmp((char *)inode->ni_filename, name, chunk_len);
    1490:	300d      	adds	r0, #13
    1492:	4622      	mov	r2, r4

int
nffs_inode_filename_cmp_ram(const struct nffs_inode *inode,
                            const char *name, int name_len,
                            int *result)
{
    1494:	461e      	mov	r6, r3
    1496:	4689      	mov	r9, r1
    if (short_len <= NFFS_SHORT_FILENAME_LEN) {
        chunk_len = short_len;
    } else {
        chunk_len = NFFS_SHORT_FILENAME_LEN;
    }
    *result = strncmp((char *)inode->ni_filename, name, chunk_len);
    1498:	f002 fa89 	bl	39ae <strncmp>
    149c:	6030      	str	r0, [r6, #0]

    off = chunk_len;
    while (*result == 0 && off < short_len) {
    149e:	6830      	ldr	r0, [r6, #0]
    14a0:	b9c0      	cbnz	r0, 14d4 <nffs_inode_filename_cmp_ram+0x5c>
    14a2:	42ac      	cmp	r4, r5
    14a4:	da19      	bge.n	14da <nffs_inode_filename_cmp_ram+0x62>
        rem_len = short_len - off;
    14a6:	ebc4 0a05 	rsb	sl, r4, r5
        if (rem_len > NFFS_INODE_FILENAME_BUF_SZ) {
            chunk_len = NFFS_INODE_FILENAME_BUF_SZ;
    14aa:	f1ba 0f81 	cmp.w	sl, #129	; 0x81
    14ae:	bf28      	it	cs
    14b0:	f04f 0a80 	movcs.w	sl, #128	; 0x80
        } else {
            chunk_len = rem_len;
        }

        rc = nffs_inode_read_filename_chunk(inode, off,
    14b4:	4638      	mov	r0, r7
    14b6:	b2e1      	uxtb	r1, r4
    14b8:	4a0b      	ldr	r2, [pc, #44]	; (14e8 <nffs_inode_filename_cmp_ram+0x70>)
    14ba:	4653      	mov	r3, sl
    14bc:	f7ff fdf0 	bl	10a0 <nffs_inode_read_filename_chunk>
                                            nffs_inode_filename_buf0,
                                            chunk_len);
        if (rc != 0) {
    14c0:	b978      	cbnz	r0, 14e2 <nffs_inode_filename_cmp_ram+0x6a>
            return rc;
        }

        *result = strncmp((char *)nffs_inode_filename_buf0, name + off,
    14c2:	eb09 0104 	add.w	r1, r9, r4
    14c6:	4808      	ldr	r0, [pc, #32]	; (14e8 <nffs_inode_filename_cmp_ram+0x70>)
    14c8:	4652      	mov	r2, sl
    14ca:	f002 fa70 	bl	39ae <strncmp>
                          chunk_len);
        off += chunk_len;
    14ce:	4454      	add	r4, sl
                                            chunk_len);
        if (rc != 0) {
            return rc;
        }

        *result = strncmp((char *)nffs_inode_filename_buf0, name + off,
    14d0:	6030      	str	r0, [r6, #0]
    14d2:	e7e4      	b.n	149e <nffs_inode_filename_cmp_ram+0x26>

    if (*result == 0) {
        *result = inode->ni_filename_len - name_len;
    }

    return 0;
    14d4:	2000      	movs	r0, #0
    14d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                          chunk_len);
        off += chunk_len;
    }

    if (*result == 0) {
        *result = inode->ni_filename_len - name_len;
    14da:	7b3b      	ldrb	r3, [r7, #12]
    14dc:	ebc8 0303 	rsb	r3, r8, r3
    14e0:	6033      	str	r3, [r6, #0]
    }

    return 0;
}
    14e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    14e6:	bf00      	nop
    14e8:	20000b9c 	.word	0x20000b9c

000014ec <nffs_inode_filename_cmp_flash>:
 */
int
nffs_inode_filename_cmp_flash(const struct nffs_inode *inode1,
                              const struct nffs_inode *inode2,
                              int *result)
{
    14ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int chunk_len;
    int rem_len;
    int off;
    int rc;

    if (inode1->ni_filename_len < inode2->ni_filename_len) {
    14f0:	7b05      	ldrb	r5, [r0, #12]
    14f2:	7b0b      	ldrb	r3, [r1, #12]
        short_len = inode1->ni_filename_len;
    14f4:	429d      	cmp	r5, r3
    14f6:	bf28      	it	cs
    14f8:	461d      	movcs	r5, r3
    14fa:	2d03      	cmp	r5, #3
    14fc:	462c      	mov	r4, r5
    14fe:	bfa8      	it	ge
    1500:	2403      	movge	r4, #3
 */
int
nffs_inode_filename_cmp_flash(const struct nffs_inode *inode1,
                              const struct nffs_inode *inode2,
                              int *result)
{
    1502:	4616      	mov	r6, r2
    1504:	4680      	mov	r8, r0
    1506:	460f      	mov	r7, r1
    if (short_len <= NFFS_SHORT_FILENAME_LEN) {
        chunk_len = short_len;
    } else {
        chunk_len = NFFS_SHORT_FILENAME_LEN;
    }
    *result = strncmp((char *)inode1->ni_filename,
    1508:	300d      	adds	r0, #13
    150a:	310d      	adds	r1, #13
    150c:	4622      	mov	r2, r4
    150e:	f002 fa4e 	bl	39ae <strncmp>
    1512:	6030      	str	r0, [r6, #0]
                      (char *)inode2->ni_filename,
                      chunk_len);

    off = chunk_len;
    while (*result == 0 && off < short_len) {
    1514:	6830      	ldr	r0, [r6, #0]
    1516:	bb08      	cbnz	r0, 155c <nffs_inode_filename_cmp_flash+0x70>
    1518:	42ac      	cmp	r4, r5
    151a:	da22      	bge.n	1562 <nffs_inode_filename_cmp_flash+0x76>
        rem_len = short_len - off;
    151c:	ebc4 0905 	rsb	r9, r4, r5
        if (rem_len > NFFS_INODE_FILENAME_BUF_SZ) {
            chunk_len = NFFS_INODE_FILENAME_BUF_SZ;
    1520:	f1b9 0f81 	cmp.w	r9, #129	; 0x81
    1524:	bf28      	it	cs
    1526:	f04f 0980 	movcs.w	r9, #128	; 0x80
        } else {
            chunk_len = rem_len;
        }

        rc = nffs_inode_read_filename_chunk(inode1, off,
    152a:	fa5f fa84 	uxtb.w	sl, r4
    152e:	4640      	mov	r0, r8
    1530:	4651      	mov	r1, sl
    1532:	4a0f      	ldr	r2, [pc, #60]	; (1570 <nffs_inode_filename_cmp_flash+0x84>)
    1534:	464b      	mov	r3, r9
    1536:	f7ff fdb3 	bl	10a0 <nffs_inode_read_filename_chunk>
                                            nffs_inode_filename_buf0,
                                            chunk_len);
        if (rc != 0) {
    153a:	b9b8      	cbnz	r0, 156c <nffs_inode_filename_cmp_flash+0x80>
            return rc;
        }

        rc = nffs_inode_read_filename_chunk(inode2, off,
    153c:	4638      	mov	r0, r7
    153e:	4651      	mov	r1, sl
    1540:	4a0c      	ldr	r2, [pc, #48]	; (1574 <nffs_inode_filename_cmp_flash+0x88>)
    1542:	464b      	mov	r3, r9
    1544:	f7ff fdac 	bl	10a0 <nffs_inode_read_filename_chunk>
                                            nffs_inode_filename_buf1,
                                            chunk_len);
        if (rc != 0) {
    1548:	b980      	cbnz	r0, 156c <nffs_inode_filename_cmp_flash+0x80>
            return rc;
        }

        *result = strncmp((char *)nffs_inode_filename_buf0,
    154a:	4809      	ldr	r0, [pc, #36]	; (1570 <nffs_inode_filename_cmp_flash+0x84>)
    154c:	464a      	mov	r2, r9
    154e:	f100 0180 	add.w	r1, r0, #128	; 0x80
    1552:	f002 fa2c 	bl	39ae <strncmp>
                          (char *)nffs_inode_filename_buf1,
                          chunk_len);
        off += chunk_len;
    1556:	444c      	add	r4, r9
                                            chunk_len);
        if (rc != 0) {
            return rc;
        }

        *result = strncmp((char *)nffs_inode_filename_buf0,
    1558:	6030      	str	r0, [r6, #0]
    155a:	e7db      	b.n	1514 <nffs_inode_filename_cmp_flash+0x28>

    if (*result == 0) {
        *result = inode1->ni_filename_len - inode2->ni_filename_len;
    }

    return 0;
    155c:	2000      	movs	r0, #0
    155e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                          chunk_len);
        off += chunk_len;
    }

    if (*result == 0) {
        *result = inode1->ni_filename_len - inode2->ni_filename_len;
    1562:	f898 300c 	ldrb.w	r3, [r8, #12]
    1566:	7b3a      	ldrb	r2, [r7, #12]
    1568:	1a9b      	subs	r3, r3, r2
    156a:	6033      	str	r3, [r6, #0]
    }

    return 0;
}
    156c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1570:	20000b9c 	.word	0x20000b9c
    1574:	20000c1c 	.word	0x20000c1c

00001578 <nffs_inode_read>:
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_inode_read(struct nffs_inode_entry *inode_entry, uint32_t offset,
                uint32_t len, void *out_data, uint32_t *out_len)
{
    1578:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    157c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    157e:	4607      	mov	r7, r0
    1580:	460e      	mov	r6, r1
    1582:	4698      	mov	r8, r3
    uint16_t block_off;
    uint16_t chunk_sz;
    uint8_t *dptr;
    int rc;

    if (len == 0) {
    1584:	4614      	mov	r4, r2
    1586:	b922      	cbnz	r2, 1592 <nffs_inode_read+0x1a>
        if (out_len != NULL) {
    1588:	b90d      	cbnz	r5, 158e <nffs_inode_read+0x16>
            *out_len = 0;
        }
        return 0;
    158a:	2000      	movs	r0, #0
    158c:	e042      	b.n	1614 <nffs_inode_read+0x9c>
    uint8_t *dptr;
    int rc;

    if (len == 0) {
        if (out_len != NULL) {
            *out_len = 0;
    158e:	602a      	str	r2, [r5, #0]
    1590:	e7fb      	b.n	158a <nffs_inode_read+0x12>
        }
        return 0;
    }

    rc = nffs_cache_inode_ensure(&cache_inode, inode_entry);
    1592:	4668      	mov	r0, sp
    1594:	4639      	mov	r1, r7
    1596:	f7ff f8b9 	bl	70c <nffs_cache_inode_ensure>
    if (rc != 0) {
    159a:	2800      	cmp	r0, #0
    159c:	d13a      	bne.n	1614 <nffs_inode_read+0x9c>
        return rc;
    }

    src_end = offset + len;
    if (src_end > cache_inode->nci_file_size) {
    159e:	9b00      	ldr	r3, [sp, #0]

    /* Initialize variables for the first iteration. */
    dst_off = src_end - offset;
    src_off = src_end;
    dptr = out_data;
    cache_block = NULL;
    15a0:	9001      	str	r0, [sp, #4]
    if (rc != 0) {
        return rc;
    }

    src_end = offset + len;
    if (src_end > cache_inode->nci_file_size) {
    15a2:	6a1a      	ldr	r2, [r3, #32]
    rc = nffs_cache_inode_ensure(&cache_inode, inode_entry);
    if (rc != 0) {
        return rc;
    }

    src_end = offset + len;
    15a4:	4434      	add	r4, r6
    15a6:	4294      	cmp	r4, r2
    15a8:	bf28      	it	cs
    15aa:	4614      	movcs	r4, r2
    if (src_end > cache_inode->nci_file_size) {
        src_end = cache_inode->nci_file_size;
    }

    /* Initialize variables for the first iteration. */
    dst_off = src_end - offset;
    15ac:	1ba7      	subs	r7, r4, r6
    cache_block = NULL;

    /* Read each relevant block into the destination buffer, iterating in
     * reverse.
     */
    while (dst_off > 0) {
    15ae:	46a2      	mov	sl, r4
    if (src_end > cache_inode->nci_file_size) {
        src_end = cache_inode->nci_file_size;
    }

    /* Initialize variables for the first iteration. */
    dst_off = src_end - offset;
    15b0:	46b9      	mov	r9, r7
    cache_block = NULL;

    /* Read each relevant block into the destination buffer, iterating in
     * reverse.
     */
    while (dst_off > 0) {
    15b2:	f1b9 0f00 	cmp.w	r9, #0
    15b6:	d029      	beq.n	160c <nffs_inode_read+0x94>
        if (cache_block == NULL) {
    15b8:	9b01      	ldr	r3, [sp, #4]
    15ba:	b933      	cbnz	r3, 15ca <nffs_inode_read+0x52>
            rc = nffs_cache_seek(cache_inode, src_off - 1, &cache_block);
    15bc:	9800      	ldr	r0, [sp, #0]
    15be:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    15c2:	aa01      	add	r2, sp, #4
    15c4:	f7ff f91a 	bl	7fc <nffs_cache_seek>
            if (rc != 0) {
    15c8:	bb20      	cbnz	r0, 1614 <nffs_inode_read+0x9c>
                return rc;
            }
        }

        if (cache_block->ncb_file_offset < offset) {
    15ca:	9801      	ldr	r0, [sp, #4]
    15cc:	69c3      	ldr	r3, [r0, #28]
        } else {
            block_off = 0;
        }

        block_end = cache_block->ncb_file_offset +
                    cache_block->ncb_block.nb_data_len;
    15ce:	8b02      	ldrh	r2, [r0, #24]
            if (rc != 0) {
                return rc;
            }
        }

        if (cache_block->ncb_file_offset < offset) {
    15d0:	42b3      	cmp	r3, r6
            block_off = offset - cache_block->ncb_file_offset;
    15d2:	bf3c      	itt	cc
    15d4:	1af1      	subcc	r1, r6, r3
    15d6:	b289      	uxthcc	r1, r1
        } else {
            block_off = 0;
        }

        block_end = cache_block->ncb_file_offset +
    15d8:	4413      	add	r3, r2
        }

        if (cache_block->ncb_file_offset < offset) {
            block_off = offset - cache_block->ncb_file_offset;
        } else {
            block_off = 0;
    15da:	bf28      	it	cs
    15dc:	2100      	movcs	r1, #0
        }

        block_end = cache_block->ncb_file_offset +
                    cache_block->ncb_block.nb_data_len;
        chunk_sz = cache_block->ncb_block.nb_data_len - block_off;
    15de:	1a52      	subs	r2, r2, r1
        if (block_end > src_end) {
    15e0:	42a3      	cmp	r3, r4
            block_off = 0;
        }

        block_end = cache_block->ncb_file_offset +
                    cache_block->ncb_block.nb_data_len;
        chunk_sz = cache_block->ncb_block.nb_data_len - block_off;
    15e2:	b292      	uxth	r2, r2
        if (block_end > src_end) {
            chunk_sz -= block_end - src_end;
    15e4:	bf82      	ittt	hi
    15e6:	1ae3      	subhi	r3, r4, r3
    15e8:	18d2      	addhi	r2, r2, r3
    15ea:	b292      	uxthhi	r2, r2
        }

        dst_off -= chunk_sz;
    15ec:	ebc2 0909 	rsb	r9, r2, r9
        src_off -= chunk_sz;

        rc = nffs_block_read_data(&cache_block->ncb_block, block_off, chunk_sz,
    15f0:	3008      	adds	r0, #8
    15f2:	eb08 0309 	add.w	r3, r8, r9
        if (block_end > src_end) {
            chunk_sz -= block_end - src_end;
        }

        dst_off -= chunk_sz;
        src_off -= chunk_sz;
    15f6:	ebc2 0a0a 	rsb	sl, r2, sl

        rc = nffs_block_read_data(&cache_block->ncb_block, block_off, chunk_sz,
    15fa:	f001 fbc9 	bl	2d90 <nffs_block_read_data>
                                  dptr + dst_off);
        if (rc != 0) {
    15fe:	b948      	cbnz	r0, 1614 <nffs_inode_read+0x9c>
            return rc;
        }

        cache_block = TAILQ_PREV(cache_block, nffs_cache_block_list, ncb_link);
    1600:	9b01      	ldr	r3, [sp, #4]
    1602:	685b      	ldr	r3, [r3, #4]
    1604:	685b      	ldr	r3, [r3, #4]
    1606:	681b      	ldr	r3, [r3, #0]
    1608:	9301      	str	r3, [sp, #4]
    160a:	e7d2      	b.n	15b2 <nffs_inode_read+0x3a>
    }

    if (out_len != NULL) {
    160c:	2d00      	cmp	r5, #0
    160e:	d0bc      	beq.n	158a <nffs_inode_read+0x12>
        *out_len = src_end - offset;
    1610:	602f      	str	r7, [r5, #0]
    }

    return 0;
    1612:	4648      	mov	r0, r9
}
    1614:	b002      	add	sp, #8
    1616:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000161a <nffs_inode_unlink_from_ram>:
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_inode_unlink_from_ram(struct nffs_inode *inode,
                           struct nffs_hash_entry **out_next)
{
    161a:	460a      	mov	r2, r1
    int rc;

    rc = nffs_inode_unlink_from_ram_priv(inode, 0, out_next);
    161c:	2100      	movs	r1, #0
    161e:	f7ff bed9 	b.w	13d4 <nffs_inode_unlink_from_ram_priv>

00001622 <nffs_inode_unlink_from_ram_corrupt_ok>:
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_inode_unlink_from_ram_corrupt_ok(struct nffs_inode *inode,
                                      struct nffs_hash_entry **out_next)
{
    1622:	460a      	mov	r2, r1
    int rc;

    rc = nffs_inode_unlink_from_ram_priv(inode, 1, out_next);
    1624:	2101      	movs	r1, #1
    1626:	f7ff bed5 	b.w	13d4 <nffs_inode_unlink_from_ram_priv>

0000162a <nffs_inode_unlink>:
 *
 * @return                  0 on success; nonzero on failure.
 */
int
nffs_inode_unlink(struct nffs_inode *inode)
{
    162a:	b510      	push	{r4, lr}
    162c:	4604      	mov	r4, r0
    int rc;

    rc = nffs_inode_delete_from_disk(inode);
    162e:	f7ff fe55 	bl	12dc <nffs_inode_delete_from_disk>
    if (rc != 0) {
    1632:	4601      	mov	r1, r0
    1634:	b920      	cbnz	r0, 1640 <nffs_inode_unlink+0x16>
        return rc;
    }

    rc = nffs_inode_unlink_from_ram(inode, NULL);
    1636:	4620      	mov	r0, r4
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    1638:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    rc = nffs_inode_delete_from_disk(inode);
    if (rc != 0) {
        return rc;
    }

    rc = nffs_inode_unlink_from_ram(inode, NULL);
    163c:	f7ff bfed 	b.w	161a <nffs_inode_unlink_from_ram>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    1640:	bd10      	pop	{r4, pc}
	...

00001644 <nffs_inode_is_dummy>:
 * Return true if inode is a dummy inode, that was allocated as a
 * place holder in the case that an inode is restored before it's parent.
 */
int
nffs_inode_is_dummy(struct nffs_inode_entry *inode_entry)
{
    1644:	b538      	push	{r3, r4, r5, lr}
    if (inode_entry->nie_flash_loc == NFFS_FLASH_LOC_NONE) {
    1646:	2100      	movs	r1, #0
    1648:	6885      	ldr	r5, [r0, #8]
 * Return true if inode is a dummy inode, that was allocated as a
 * place holder in the case that an inode is restored before it's parent.
 */
int
nffs_inode_is_dummy(struct nffs_inode_entry *inode_entry)
{
    164a:	4604      	mov	r4, r0
    if (inode_entry->nie_flash_loc == NFFS_FLASH_LOC_NONE) {
    164c:	20ff      	movs	r0, #255	; 0xff
    164e:	f7ff fb9b 	bl	d88 <nffs_flash_loc>
    1652:	4285      	cmp	r5, r0
    1654:	d105      	bne.n	1662 <nffs_inode_is_dummy+0x1e>
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    1656:	7d63      	ldrb	r3, [r4, #21]
    1658:	f043 0301 	orr.w	r3, r3, #1
    165c:	7563      	strb	r3, [r4, #21]
    if (inode_entry->nie_flash_loc == NFFS_FLASH_LOC_NONE) {
        /*
         * set if not already XXX can delete after debug
         */
        nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DUMMY);
        return 1;
    165e:	2001      	movs	r0, #1
    1660:	bd38      	pop	{r3, r4, r5, pc}
    }

    if (inode_entry == nffs_root_dir) {
    1662:	4b04      	ldr	r3, [pc, #16]	; (1674 <nffs_inode_is_dummy+0x30>)
    1664:	681b      	ldr	r3, [r3, #0]
    1666:	429c      	cmp	r4, r3
}

int
nffs_inode_getflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    return (int)(entry->nie_flags & flag);
    1668:	bf1a      	itte	ne
    166a:	7d60      	ldrbne	r0, [r4, #21]
    166c:	f000 0001 	andne.w	r0, r0, #1
        nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DUMMY);
        return 1;
    }

    if (inode_entry == nffs_root_dir) {
        return 0;
    1670:	2000      	moveq	r0, #0
    } else {
        return nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DUMMY);
    }
}
    1672:	bd38      	pop	{r3, r4, r5, pc}
    1674:	20000b78 	.word	0x20000b78

00001678 <nffs_inode_from_entry>:
}

int
nffs_inode_from_entry(struct nffs_inode *out_inode,
                      struct nffs_inode_entry *entry)
{
    1678:	b570      	push	{r4, r5, r6, lr}
    167a:	4604      	mov	r4, r0
    167c:	b088      	sub	sp, #32
    uint32_t area_offset;
    uint8_t area_idx;
    int cached_name_len;
    int rc;

    if (nffs_inode_is_dummy(entry)) {
    167e:	4608      	mov	r0, r1
}

int
nffs_inode_from_entry(struct nffs_inode *out_inode,
                      struct nffs_inode_entry *entry)
{
    1680:	460e      	mov	r6, r1
    uint32_t area_offset;
    uint8_t area_idx;
    int cached_name_len;
    int rc;

    if (nffs_inode_is_dummy(entry)) {
    1682:	f7ff ffdf 	bl	1644 <nffs_inode_is_dummy>
    1686:	4605      	mov	r5, r0
    1688:	b138      	cbz	r0, 169a <nffs_inode_from_entry+0x22>

static void
nffs_inode_restore_from_dummy_entry(struct nffs_inode *out_inode,
                                    struct nffs_inode_entry *inode_entry)
{
    memset(out_inode, 0, sizeof *out_inode);
    168a:	4620      	mov	r0, r4
    168c:	2100      	movs	r1, #0
    168e:	2210      	movs	r2, #16
    1690:	f002 f968 	bl	3964 <memset>
    int cached_name_len;
    int rc;

    if (nffs_inode_is_dummy(entry)) {
        nffs_inode_restore_from_dummy_entry(out_inode, entry);
        return FS_ENOENT;
    1694:	2506      	movs	r5, #6
static void
nffs_inode_restore_from_dummy_entry(struct nffs_inode *out_inode,
                                    struct nffs_inode_entry *inode_entry)
{
    memset(out_inode, 0, sizeof *out_inode);
    out_inode->ni_inode_entry = inode_entry;
    1696:	6026      	str	r6, [r4, #0]
    1698:	e038      	b.n	170c <nffs_inode_from_entry+0x94>
    if (nffs_inode_is_dummy(entry)) {
        nffs_inode_restore_from_dummy_entry(out_inode, entry);
        return FS_ENOENT;
    }

    nffs_flash_loc_expand(entry->nie_hash_entry.nhe_flash_loc,
    169a:	68b0      	ldr	r0, [r6, #8]
    169c:	f10d 0107 	add.w	r1, sp, #7
    16a0:	aa02      	add	r2, sp, #8
    16a2:	f7ff fb81 	bl	da8 <nffs_flash_loc_expand>
                          &area_idx, &area_offset);

    rc = nffs_inode_read_disk(area_idx, area_offset, &disk_inode);
    16a6:	f89d 0007 	ldrb.w	r0, [sp, #7]
    16aa:	9902      	ldr	r1, [sp, #8]
    16ac:	aa03      	add	r2, sp, #12
    16ae:	f7ff fda2 	bl	11f6 <nffs_inode_read_disk>
    if (rc != 0) {
    16b2:	bb50      	cbnz	r0, 170a <nffs_inode_from_entry+0x92>

    /*
     * Relink to parent if possible
     * XXX does this belong here?
     */
    if (disk_inode.ndi_parent_id == NFFS_ID_NONE) {
    16b4:	9804      	ldr	r0, [sp, #16]
    if (rc != 0) {
        return rc;
    }

    out_inode->ni_inode_entry = entry;
    out_inode->ni_seq = disk_inode.ndi_seq;
    16b6:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    16ba:	6063      	str	r3, [r4, #4]

    /*
     * Relink to parent if possible
     * XXX does this belong here?
     */
    if (disk_inode.ndi_parent_id == NFFS_ID_NONE) {
    16bc:	1c43      	adds	r3, r0, #1
    rc = nffs_inode_read_disk(area_idx, area_offset, &disk_inode);
    if (rc != 0) {
        return rc;
    }

    out_inode->ni_inode_entry = entry;
    16be:	6026      	str	r6, [r4, #0]

    /*
     * Relink to parent if possible
     * XXX does this belong here?
     */
    if (disk_inode.ndi_parent_id == NFFS_ID_NONE) {
    16c0:	d101      	bne.n	16c6 <nffs_inode_from_entry+0x4e>
        out_inode->ni_parent = NULL;
    16c2:	60a5      	str	r5, [r4, #8]
    16c4:	e002      	b.n	16cc <nffs_inode_from_entry+0x54>
    } else {
        out_inode->ni_parent = nffs_hash_find_inode(disk_inode.ndi_parent_id);
    16c6:	f7ff fc17 	bl	ef8 <nffs_hash_find_inode>
    16ca:	60a0      	str	r0, [r4, #8]
    }
    out_inode->ni_filename_len = disk_inode.ndi_filename_len;
    16cc:	f89d 301d 	ldrb.w	r3, [sp, #29]
    16d0:	7323      	strb	r3, [r4, #12]

    if (out_inode->ni_filename_len > NFFS_SHORT_FILENAME_LEN) {
    16d2:	2b03      	cmp	r3, #3
    16d4:	d80e      	bhi.n	16f4 <nffs_inode_from_entry+0x7c>
        cached_name_len = NFFS_SHORT_FILENAME_LEN;
    } else {
        cached_name_len = out_inode->ni_filename_len;
    }
    if (cached_name_len != 0) {
    16d6:	b973      	cbnz	r3, 16f6 <nffs_inode_from_entry+0x7e>
        if (rc != 0) {
            return rc;
        }
    }

    if (disk_inode.ndi_flags & NFFS_INODE_FLAG_DELETED) {
    16d8:	f99d 301c 	ldrsb.w	r3, [sp, #28]
    16dc:	2b00      	cmp	r3, #0
    16de:	da15      	bge.n	170c <nffs_inode_from_entry+0x94>
        nffs_inode_setflags(out_inode->ni_inode_entry, NFFS_INODE_FLAG_DELETED);
    16e0:	6822      	ldr	r2, [r4, #0]
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    16e2:	7d53      	ldrb	r3, [r2, #21]
    16e4:	f063 037f 	orn	r3, r3, #127	; 0x7f
    16e8:	7553      	strb	r3, [r2, #21]
    16ea:	7d73      	ldrb	r3, [r6, #21]
    16ec:	f063 037f 	orn	r3, r3, #127	; 0x7f
    16f0:	7573      	strb	r3, [r6, #21]
    16f2:	e00b      	b.n	170c <nffs_inode_from_entry+0x94>
        out_inode->ni_parent = nffs_hash_find_inode(disk_inode.ndi_parent_id);
    }
    out_inode->ni_filename_len = disk_inode.ndi_filename_len;

    if (out_inode->ni_filename_len > NFFS_SHORT_FILENAME_LEN) {
        cached_name_len = NFFS_SHORT_FILENAME_LEN;
    16f4:	2303      	movs	r3, #3
    } else {
        cached_name_len = out_inode->ni_filename_len;
    }
    if (cached_name_len != 0) {
        rc = nffs_flash_read(area_idx, area_offset + sizeof disk_inode,
    16f6:	9902      	ldr	r1, [sp, #8]
    16f8:	f89d 0007 	ldrb.w	r0, [sp, #7]
    16fc:	3114      	adds	r1, #20
    16fe:	f104 020d 	add.w	r2, r4, #13
    1702:	f7ff facb 	bl	c9c <nffs_flash_read>
                             out_inode->ni_filename, cached_name_len);
        if (rc != 0) {
    1706:	2800      	cmp	r0, #0
    1708:	d0e6      	beq.n	16d8 <nffs_inode_from_entry+0x60>
    170a:	4605      	mov	r5, r0
        nffs_inode_setflags(out_inode->ni_inode_entry, NFFS_INODE_FLAG_DELETED);
        nffs_inode_setflags(entry, NFFS_INODE_FLAG_DELETED);
    }

    return 0;
}
    170c:	4628      	mov	r0, r5
    170e:	b008      	add	sp, #32
    1710:	bd70      	pop	{r4, r5, r6, pc}

00001712 <nffs_inode_read_filename>:
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_inode_read_filename(struct nffs_inode_entry *inode_entry, size_t max_len,
                         char *out_name, uint8_t *out_full_len)
{
    1712:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    1714:	4603      	mov	r3, r0
    1716:	460e      	mov	r6, r1
    struct nffs_inode inode;
    int read_len;
    int rc;

    rc = nffs_inode_from_entry(&inode, inode_entry);
    1718:	4668      	mov	r0, sp
    171a:	4619      	mov	r1, r3
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_inode_read_filename(struct nffs_inode_entry *inode_entry, size_t max_len,
                         char *out_name, uint8_t *out_full_len)
{
    171c:	4615      	mov	r5, r2
    struct nffs_inode inode;
    int read_len;
    int rc;

    rc = nffs_inode_from_entry(&inode, inode_entry);
    171e:	f7ff ffab 	bl	1678 <nffs_inode_from_entry>
    if (rc != 0) {
    1722:	b968      	cbnz	r0, 1740 <nffs_inode_read_filename+0x2e>
        return rc;
    }

    if (max_len > inode.ni_filename_len) {
    1724:	f89d 400c 	ldrb.w	r4, [sp, #12]
    1728:	42a6      	cmp	r6, r4
        read_len = inode.ni_filename_len;
    } else {
        read_len = max_len - 1;
    172a:	bf98      	it	ls
    172c:	f106 34ff 	addls.w	r4, r6, #4294967295	; 0xffffffff
    }

    rc = nffs_inode_read_filename_chunk(&inode, 0, out_name, read_len);
    1730:	4668      	mov	r0, sp
    1732:	2100      	movs	r1, #0
    1734:	462a      	mov	r2, r5
    1736:	4623      	mov	r3, r4
    1738:	f7ff fcb2 	bl	10a0 <nffs_inode_read_filename_chunk>
    if (rc != 0) {
    173c:	b900      	cbnz	r0, 1740 <nffs_inode_read_filename+0x2e>
        return rc;
    }

    out_name[read_len] = '\0';
    173e:	5528      	strb	r0, [r5, r4]

    return 0;
}
    1740:	b004      	add	sp, #16
    1742:	bd70      	pop	{r4, r5, r6, pc}

00001744 <nffs_inode_add_child>:

int
nffs_inode_add_child(struct nffs_inode_entry *parent,
                     struct nffs_inode_entry *child)
{
    1744:	b5f0      	push	{r4, r5, r6, r7, lr}
    1746:	4607      	mov	r7, r0
    1748:	b08b      	sub	sp, #44	; 0x2c
    struct nffs_inode child_inode;
    struct nffs_inode cur_inode;
    int cmp;
    int rc;

    assert(nffs_hash_id_is_dir(parent->nie_hash_entry.nhe_id));
    174a:	6840      	ldr	r0, [r0, #4]
}

int
nffs_inode_add_child(struct nffs_inode_entry *parent,
                     struct nffs_inode_entry *child)
{
    174c:	460c      	mov	r4, r1
    struct nffs_inode child_inode;
    struct nffs_inode cur_inode;
    int cmp;
    int rc;

    assert(nffs_hash_id_is_dir(parent->nie_hash_entry.nhe_id));
    174e:	f7ff fba7 	bl	ea0 <nffs_hash_id_is_dir>
    1752:	4602      	mov	r2, r0
    1754:	b918      	cbnz	r0, 175e <nffs_inode_add_child+0x1a>
    1756:	481e      	ldr	r0, [pc, #120]	; (17d0 <nffs_inode_add_child+0x8c>)
    1758:	f44f 7143 	mov.w	r1, #780	; 0x30c
    175c:	e006      	b.n	176c <nffs_inode_add_child+0x28>
}

int
nffs_inode_getflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    return (int)(entry->nie_flags & flag);
    175e:	7d63      	ldrb	r3, [r4, #21]
    struct nffs_inode cur_inode;
    int cmp;
    int rc;

    assert(nffs_hash_id_is_dir(parent->nie_hash_entry.nhe_id));
    assert(!nffs_inode_getflags(child, NFFS_INODE_FLAG_INTREE));
    1760:	069b      	lsls	r3, r3, #26
    1762:	d506      	bpl.n	1772 <nffs_inode_add_child+0x2e>
    1764:	481a      	ldr	r0, [pc, #104]	; (17d0 <nffs_inode_add_child+0x8c>)
    1766:	f240 310d 	movw	r1, #781	; 0x30d
    176a:	2200      	movs	r2, #0
    176c:	4613      	mov	r3, r2
    176e:	f003 fa6d 	bl	4c4c <__assert_func>

    rc = nffs_inode_from_entry(&child_inode, child);
    1772:	a802      	add	r0, sp, #8
    1774:	4621      	mov	r1, r4
    1776:	f7ff ff7f 	bl	1678 <nffs_inode_from_entry>
    if (rc != 0) {
    177a:	bb30      	cbnz	r0, 17ca <nffs_inode_add_child+0x86>
        return rc;
    }

    prev = NULL;
    SLIST_FOREACH(cur, &parent->nie_child_list, nie_sibling_next) {
    177c:	693d      	ldr	r5, [r7, #16]
    rc = nffs_inode_from_entry(&child_inode, child);
    if (rc != 0) {
        return rc;
    }

    prev = NULL;
    177e:	4606      	mov	r6, r0
    SLIST_FOREACH(cur, &parent->nie_child_list, nie_sibling_next) {
    1780:	b19d      	cbz	r5, 17aa <nffs_inode_add_child+0x66>
        assert(cur != child);
    1782:	42a5      	cmp	r5, r4
    1784:	d103      	bne.n	178e <nffs_inode_add_child+0x4a>
    1786:	4812      	ldr	r0, [pc, #72]	; (17d0 <nffs_inode_add_child+0x8c>)
    1788:	f240 3116 	movw	r1, #790	; 0x316
    178c:	e7ed      	b.n	176a <nffs_inode_add_child+0x26>
        rc = nffs_inode_from_entry(&cur_inode, cur);
    178e:	a806      	add	r0, sp, #24
    1790:	4629      	mov	r1, r5
    1792:	f7ff ff71 	bl	1678 <nffs_inode_from_entry>
        if (rc != 0) {
    1796:	b9c0      	cbnz	r0, 17ca <nffs_inode_add_child+0x86>
            return rc;
        }

        rc = nffs_inode_filename_cmp_flash(&child_inode, &cur_inode, &cmp);
    1798:	a802      	add	r0, sp, #8
    179a:	a906      	add	r1, sp, #24
    179c:	aa01      	add	r2, sp, #4
    179e:	f7ff fea5 	bl	14ec <nffs_inode_filename_cmp_flash>
        if (rc != 0) {
    17a2:	b990      	cbnz	r0, 17ca <nffs_inode_add_child+0x86>
            return rc;
        }

        if (cmp < 0) {
    17a4:	9b01      	ldr	r3, [sp, #4]
    17a6:	2b00      	cmp	r3, #0
    17a8:	da04      	bge.n	17b4 <nffs_inode_add_child+0x70>
        }

        prev = cur;
    }

    if (prev == NULL) {
    17aa:	b936      	cbnz	r6, 17ba <nffs_inode_add_child+0x76>
        SLIST_INSERT_HEAD(&parent->nie_child_list, child, nie_sibling_next);
    17ac:	693b      	ldr	r3, [r7, #16]
    17ae:	60e3      	str	r3, [r4, #12]
    17b0:	613c      	str	r4, [r7, #16]
    17b2:	e005      	b.n	17c0 <nffs_inode_add_child+0x7c>
    if (rc != 0) {
        return rc;
    }

    prev = NULL;
    SLIST_FOREACH(cur, &parent->nie_child_list, nie_sibling_next) {
    17b4:	462e      	mov	r6, r5
    17b6:	68ed      	ldr	r5, [r5, #12]
    17b8:	e7e2      	b.n	1780 <nffs_inode_add_child+0x3c>
    }

    if (prev == NULL) {
        SLIST_INSERT_HEAD(&parent->nie_child_list, child, nie_sibling_next);
    } else {
        SLIST_INSERT_AFTER(prev, child, nie_sibling_next);
    17ba:	68f3      	ldr	r3, [r6, #12]
    17bc:	60e3      	str	r3, [r4, #12]
    17be:	60f4      	str	r4, [r6, #12]
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    17c0:	7d63      	ldrb	r3, [r4, #21]
    17c2:	f043 0320 	orr.w	r3, r3, #32
    17c6:	7563      	strb	r3, [r4, #21]
    } else {
        SLIST_INSERT_AFTER(prev, child, nie_sibling_next);
    }
    nffs_inode_setflags(child, NFFS_INODE_FLAG_INTREE);

    return 0;
    17c8:	2000      	movs	r0, #0
}
    17ca:	b00b      	add	sp, #44	; 0x2c
    17cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    17ce:	bf00      	nop
    17d0:	00006244 	.word	0x00006244

000017d4 <nffs_inode_rename>:

int
nffs_inode_rename(struct nffs_inode_entry *inode_entry,
                  struct nffs_inode_entry *new_parent,
                  const char *new_filename)
{
    17d4:	b570      	push	{r4, r5, r6, lr}
    17d6:	4605      	mov	r5, r0
    17d8:	b08c      	sub	sp, #48	; 0x30
    struct nffs_inode_entry *cur;
    struct nffs_inode inode;
    int rc;

    /* Only directories can be ancestors. */
    if (!nffs_hash_id_is_dir(anc->nie_hash_entry.nhe_id)) {
    17da:	6840      	ldr	r0, [r0, #4]

int
nffs_inode_rename(struct nffs_inode_entry *inode_entry,
                  struct nffs_inode_entry *new_parent,
                  const char *new_filename)
{
    17dc:	460c      	mov	r4, r1
    17de:	4616      	mov	r6, r2
    struct nffs_inode_entry *cur;
    struct nffs_inode inode;
    int rc;

    /* Only directories can be ancestors. */
    if (!nffs_hash_id_is_dir(anc->nie_hash_entry.nhe_id)) {
    17e0:	f7ff fb5e 	bl	ea0 <nffs_hash_id_is_dir>
    17e4:	b160      	cbz	r0, 1800 <nffs_inode_rename+0x2c>
    17e6:	4621      	mov	r1, r4
        return 0;
    }

    /* Trace des's heritage until we hit anc or there are no more parents. */
    cur = des;
    while (cur != NULL && cur != anc) {
    17e8:	b141      	cbz	r1, 17fc <nffs_inode_rename+0x28>
    17ea:	42a9      	cmp	r1, r5
    17ec:	d006      	beq.n	17fc <nffs_inode_rename+0x28>
        rc = nffs_inode_from_entry(&inode, cur);
    17ee:	a807      	add	r0, sp, #28
    17f0:	f7ff ff42 	bl	1678 <nffs_inode_from_entry>
        if (rc != 0) {
    17f4:	2800      	cmp	r0, #0
    17f6:	d167      	bne.n	18c8 <nffs_inode_rename+0xf4>
            *out_is_ancestor = 0;
            return rc;
        }
        cur = inode.ni_parent;
    17f8:	9909      	ldr	r1, [sp, #36]	; 0x24
    17fa:	e7f5      	b.n	17e8 <nffs_inode_rename+0x14>
    /* Don't allow a directory to be moved into a descendent directory. */
    rc = nffs_inode_is_ancestor(inode_entry, new_parent, &ancestor);
    if (rc != 0) {
        return rc;
    }
    if (ancestor) {
    17fc:	42a9      	cmp	r1, r5
    17fe:	d060      	beq.n	18c2 <nffs_inode_rename+0xee>
        return FS_EINVAL;
    }

    rc = nffs_inode_from_entry(&inode, inode_entry);
    1800:	a803      	add	r0, sp, #12
    1802:	4629      	mov	r1, r5
    1804:	f7ff ff38 	bl	1678 <nffs_inode_from_entry>
    if (rc != 0) {
    1808:	2800      	cmp	r0, #0
    180a:	d15d      	bne.n	18c8 <nffs_inode_rename+0xf4>
        return rc;
    }

    if (inode.ni_parent != new_parent) {
    180c:	9b05      	ldr	r3, [sp, #20]
    180e:	42a3      	cmp	r3, r4
    1810:	d00d      	beq.n	182e <nffs_inode_rename+0x5a>
        if (inode.ni_parent != NULL) {
    1812:	b113      	cbz	r3, 181a <nffs_inode_rename+0x46>
            nffs_inode_remove_child(&inode);
    1814:	a803      	add	r0, sp, #12
    1816:	f7ff fda5 	bl	1364 <nffs_inode_remove_child>
        }
        if (new_parent != NULL) {
    181a:	b90c      	cbnz	r4, 1820 <nffs_inode_rename+0x4c>
            rc = nffs_inode_add_child(new_parent, inode.ni_inode_entry);
            if (rc != 0) {
                return rc;
            }
        }
        inode.ni_parent = new_parent;
    181c:	9405      	str	r4, [sp, #20]
    181e:	e006      	b.n	182e <nffs_inode_rename+0x5a>
    if (inode.ni_parent != new_parent) {
        if (inode.ni_parent != NULL) {
            nffs_inode_remove_child(&inode);
        }
        if (new_parent != NULL) {
            rc = nffs_inode_add_child(new_parent, inode.ni_inode_entry);
    1820:	4620      	mov	r0, r4
    1822:	9903      	ldr	r1, [sp, #12]
    1824:	f7ff ff8e 	bl	1744 <nffs_inode_add_child>
            if (rc != 0) {
    1828:	2800      	cmp	r0, #0
    182a:	d0f7      	beq.n	181c <nffs_inode_rename+0x48>
    182c:	e04c      	b.n	18c8 <nffs_inode_rename+0xf4>
            }
        }
        inode.ni_parent = new_parent;
    }

    if (new_filename != NULL) {
    182e:	b126      	cbz	r6, 183a <nffs_inode_rename+0x66>
        filename_len = strlen(new_filename);
    1830:	4630      	mov	r0, r6
    1832:	f002 f8b4 	bl	399e <strlen>
    1836:	4604      	mov	r4, r0
    1838:	e012      	b.n	1860 <nffs_inode_rename+0x8c>
    } else {
        filename_len = inode.ni_filename_len;
        nffs_flash_loc_expand(inode_entry->nie_hash_entry.nhe_flash_loc,
    183a:	68a8      	ldr	r0, [r5, #8]
    }

    if (new_filename != NULL) {
        filename_len = strlen(new_filename);
    } else {
        filename_len = inode.ni_filename_len;
    183c:	f89d 4018 	ldrb.w	r4, [sp, #24]
        nffs_flash_loc_expand(inode_entry->nie_hash_entry.nhe_flash_loc,
    1840:	f10d 0107 	add.w	r1, sp, #7
    1844:	aa02      	add	r2, sp, #8
    1846:	f7ff faaf 	bl	da8 <nffs_flash_loc_expand>
                              &area_idx, &area_offset);
        rc = nffs_flash_read(area_idx,
    184a:	9902      	ldr	r1, [sp, #8]
    184c:	f89d 0007 	ldrb.w	r0, [sp, #7]
    1850:	4a1e      	ldr	r2, [pc, #120]	; (18cc <nffs_inode_rename+0xf8>)
    1852:	3114      	adds	r1, #20
    1854:	4623      	mov	r3, r4
    1856:	f7ff fa21 	bl	c9c <nffs_flash_read>
                             area_offset + sizeof (struct nffs_disk_inode),
                             nffs_flash_buf, filename_len);
        if (rc != 0) {
    185a:	2800      	cmp	r0, #0
    185c:	d134      	bne.n	18c8 <nffs_inode_rename+0xf4>
            return rc;
        }

        new_filename = (char *)nffs_flash_buf;
    185e:	4e1b      	ldr	r6, [pc, #108]	; (18cc <nffs_inode_rename+0xf8>)
    }

    rc = nffs_misc_reserve_space(sizeof disk_inode + filename_len,
    1860:	f104 0014 	add.w	r0, r4, #20
    1864:	b280      	uxth	r0, r0
    1866:	f10d 0107 	add.w	r1, sp, #7
    186a:	aa02      	add	r2, sp, #8
    186c:	f000 f91a 	bl	1aa4 <nffs_misc_reserve_space>
                                 &area_idx, &area_offset);
    if (rc != 0) {
    1870:	bb50      	cbnz	r0, 18c8 <nffs_inode_rename+0xf4>
        return rc;
    }

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    1872:	686b      	ldr	r3, [r5, #4]
    1874:	9307      	str	r3, [sp, #28]
    disk_inode.ndi_seq = inode.ni_seq + 1;
    1876:	9b04      	ldr	r3, [sp, #16]
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    1878:	a803      	add	r0, sp, #12
    if (rc != 0) {
        return rc;
    }

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode.ni_seq + 1;
    187a:	3301      	adds	r3, #1
    187c:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    1880:	f7ff fd11 	bl	12a6 <nffs_inode_parent_id>
    disk_inode.ndi_filename_len = filename_len;
    if (inode_entry->nie_last_block_entry &&
    1884:	692b      	ldr	r3, [r5, #16]
        return rc;
    }

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode.ni_seq + 1;
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    1886:	9008      	str	r0, [sp, #32]
    disk_inode.ndi_filename_len = filename_len;
    1888:	f88d 402d 	strb.w	r4, [sp, #45]	; 0x2d
    if (inode_entry->nie_last_block_entry &&
    188c:	b113      	cbz	r3, 1894 <nffs_inode_rename+0xc0>
        inode_entry->nie_last_block_entry->nhe_id != NFFS_ID_NONE)
    188e:	685b      	ldr	r3, [r3, #4]

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode.ni_seq + 1;
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    disk_inode.ndi_filename_len = filename_len;
    if (inode_entry->nie_last_block_entry &&
    1890:	1c5a      	adds	r2, r3, #1
    1892:	d101      	bne.n	1898 <nffs_inode_rename+0xc4>
        inode_entry->nie_last_block_entry->nhe_id != NFFS_ID_NONE)
        disk_inode.ndi_lastblock_id = inode_entry->nie_last_block_entry->nhe_id;
    else 
        disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
    1894:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    nffs_crc_disk_inode_fill(&disk_inode, new_filename);
    1898:	a807      	add	r0, sp, #28
    189a:	4631      	mov	r1, r6
    disk_inode.ndi_filename_len = filename_len;
    if (inode_entry->nie_last_block_entry &&
        inode_entry->nie_last_block_entry->nhe_id != NFFS_ID_NONE)
        disk_inode.ndi_lastblock_id = inode_entry->nie_last_block_entry->nhe_id;
    else 
        disk_inode.ndi_lastblock_id = NFFS_ID_NONE;
    189c:	9309      	str	r3, [sp, #36]	; 0x24
    nffs_crc_disk_inode_fill(&disk_inode, new_filename);
    189e:	f001 fb6f 	bl	2f80 <nffs_crc_disk_inode_fill>

    rc = nffs_inode_write_disk(&disk_inode, new_filename, area_idx,
    18a2:	a807      	add	r0, sp, #28
    18a4:	4631      	mov	r1, r6
    18a6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    18aa:	9b02      	ldr	r3, [sp, #8]
    18ac:	f7ff fcb1 	bl	1212 <nffs_inode_write_disk>
                               area_offset);
    if (rc != 0) {
    18b0:	4604      	mov	r4, r0
    18b2:	b940      	cbnz	r0, 18c6 <nffs_inode_rename+0xf2>
        return rc;
    }

    inode_entry->nie_hash_entry.nhe_flash_loc =
        nffs_flash_loc(area_idx, area_offset);
    18b4:	f89d 0007 	ldrb.w	r0, [sp, #7]
    18b8:	9902      	ldr	r1, [sp, #8]
    18ba:	f7ff fa65 	bl	d88 <nffs_flash_loc>
                               area_offset);
    if (rc != 0) {
        return rc;
    }

    inode_entry->nie_hash_entry.nhe_flash_loc =
    18be:	60a8      	str	r0, [r5, #8]
    18c0:	e001      	b.n	18c6 <nffs_inode_rename+0xf2>
    rc = nffs_inode_is_ancestor(inode_entry, new_parent, &ancestor);
    if (rc != 0) {
        return rc;
    }
    if (ancestor) {
        return FS_EINVAL;
    18c2:	2004      	movs	r0, #4
    18c4:	e000      	b.n	18c8 <nffs_inode_rename+0xf4>
    18c6:	4620      	mov	r0, r4

    inode_entry->nie_hash_entry.nhe_flash_loc =
        nffs_flash_loc(area_idx, area_offset);

    return 0;
}
    18c8:	b00c      	add	sp, #48	; 0x30
    18ca:	bd70      	pop	{r4, r5, r6, pc}
    18cc:	20000b9c 	.word	0x20000b9c

000018d0 <nffs_inode_update>:

int
nffs_inode_update(struct nffs_inode_entry *inode_entry)
{
    18d0:	b570      	push	{r4, r5, r6, lr}
    18d2:	4605      	mov	r5, r0
    18d4:	b08c      	sub	sp, #48	; 0x30
    uint8_t area_idx;
    char *filename;
    int filename_len;
    int rc;

    rc = nffs_inode_from_entry(&inode, inode_entry);
    18d6:	a803      	add	r0, sp, #12
    18d8:	4629      	mov	r1, r5
    18da:	f7ff fecd 	bl	1678 <nffs_inode_from_entry>
    /*
     * if rc == FS_ENOENT, file is dummy is unlinked and so
     * can not be updated to disk.
     */
    if (rc == FS_ENOENT)
    18de:	2806      	cmp	r0, #6
    uint8_t area_idx;
    char *filename;
    int filename_len;
    int rc;

    rc = nffs_inode_from_entry(&inode, inode_entry);
    18e0:	4604      	mov	r4, r0
    /*
     * if rc == FS_ENOENT, file is dummy is unlinked and so
     * can not be updated to disk.
     */
    if (rc == FS_ENOENT)
    18e2:	d109      	bne.n	18f8 <nffs_inode_update+0x28>
        assert(nffs_inode_is_dummy(inode_entry));
    18e4:	4628      	mov	r0, r5
    18e6:	f7ff fead 	bl	1644 <nffs_inode_is_dummy>
    18ea:	4602      	mov	r2, r0
    18ec:	2800      	cmp	r0, #0
    18ee:	d15c      	bne.n	19aa <nffs_inode_update+0xda>
    18f0:	482f      	ldr	r0, [pc, #188]	; (19b0 <nffs_inode_update+0xe0>)
    18f2:	f240 218b 	movw	r1, #651	; 0x28b
    18f6:	e00c      	b.n	1912 <nffs_inode_update+0x42>
    if (rc != 0) {
    18f8:	2800      	cmp	r0, #0
    18fa:	d156      	bne.n	19aa <nffs_inode_update+0xda>
        return rc;
    }

    assert(inode_entry->nie_hash_entry.nhe_flash_loc != NFFS_FLASH_LOC_NONE);
    18fc:	20ff      	movs	r0, #255	; 0xff
    18fe:	4621      	mov	r1, r4
    1900:	68ae      	ldr	r6, [r5, #8]
    1902:	f7ff fa41 	bl	d88 <nffs_flash_loc>
    1906:	4286      	cmp	r6, r0
    1908:	d106      	bne.n	1918 <nffs_inode_update+0x48>
    190a:	4829      	ldr	r0, [pc, #164]	; (19b0 <nffs_inode_update+0xe0>)
    190c:	f44f 7124 	mov.w	r1, #656	; 0x290
    1910:	4622      	mov	r2, r4
    1912:	4613      	mov	r3, r2
    1914:	f003 f99a 	bl	4c4c <__assert_func>

    filename_len = inode.ni_filename_len;
    nffs_flash_loc_expand(inode_entry->nie_hash_entry.nhe_flash_loc,
    1918:	68a8      	ldr	r0, [r5, #8]
        return rc;
    }

    assert(inode_entry->nie_hash_entry.nhe_flash_loc != NFFS_FLASH_LOC_NONE);

    filename_len = inode.ni_filename_len;
    191a:	f89d 6018 	ldrb.w	r6, [sp, #24]
    nffs_flash_loc_expand(inode_entry->nie_hash_entry.nhe_flash_loc,
    191e:	f10d 0107 	add.w	r1, sp, #7
    1922:	aa02      	add	r2, sp, #8
    1924:	f7ff fa40 	bl	da8 <nffs_flash_loc_expand>
                          &area_idx, &area_offset);
    rc = nffs_flash_read(area_idx,
    1928:	9902      	ldr	r1, [sp, #8]
    192a:	f89d 0007 	ldrb.w	r0, [sp, #7]
    192e:	4a21      	ldr	r2, [pc, #132]	; (19b4 <nffs_inode_update+0xe4>)
    1930:	3114      	adds	r1, #20
    1932:	4633      	mov	r3, r6
    1934:	f7ff f9b2 	bl	c9c <nffs_flash_read>
                         area_offset + sizeof (struct nffs_disk_inode),
                         nffs_flash_buf, filename_len);
    if (rc != 0) {
    1938:	2800      	cmp	r0, #0
    193a:	d137      	bne.n	19ac <nffs_inode_update+0xdc>
        return rc;
    }

    filename = (char *)nffs_flash_buf;

    rc = nffs_misc_reserve_space(sizeof disk_inode + filename_len,
    193c:	f106 0014 	add.w	r0, r6, #20
    1940:	f10d 0107 	add.w	r1, sp, #7
    1944:	aa02      	add	r2, sp, #8
    1946:	f000 f8ad 	bl	1aa4 <nffs_misc_reserve_space>
                                 &area_idx, &area_offset);
    if (rc != 0) {
    194a:	4604      	mov	r4, r0
    194c:	bb68      	cbnz	r0, 19aa <nffs_inode_update+0xda>
        return rc;
    }

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    194e:	686b      	ldr	r3, [r5, #4]
    1950:	9307      	str	r3, [sp, #28]
    disk_inode.ndi_seq = inode.ni_seq + 1;
    1952:	9b04      	ldr	r3, [sp, #16]
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    1954:	a803      	add	r0, sp, #12
    if (rc != 0) {
        return rc;
    }

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode.ni_seq + 1;
    1956:	3301      	adds	r3, #1
    1958:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    195c:	f7ff fca3 	bl	12a6 <nffs_inode_parent_id>
    disk_inode.ndi_flags = 0;
    disk_inode.ndi_filename_len = filename_len;

    assert(nffs_hash_id_is_block(inode_entry->nie_last_block_entry->nhe_id));
    1960:	692b      	ldr	r3, [r5, #16]
    }

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode.ni_seq + 1;
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    disk_inode.ndi_flags = 0;
    1962:	f88d 402c 	strb.w	r4, [sp, #44]	; 0x2c
    disk_inode.ndi_filename_len = filename_len;
    1966:	f88d 602d 	strb.w	r6, [sp, #45]	; 0x2d
        return rc;
    }

    disk_inode.ndi_id = inode_entry->nie_hash_entry.nhe_id;
    disk_inode.ndi_seq = inode.ni_seq + 1;
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    196a:	9008      	str	r0, [sp, #32]
    disk_inode.ndi_flags = 0;
    disk_inode.ndi_filename_len = filename_len;

    assert(nffs_hash_id_is_block(inode_entry->nie_last_block_entry->nhe_id));
    196c:	6858      	ldr	r0, [r3, #4]
    196e:	f7ff faa9 	bl	ec4 <nffs_hash_id_is_block>
    1972:	4602      	mov	r2, r0
    1974:	b918      	cbnz	r0, 197e <nffs_inode_update+0xae>
    1976:	480e      	ldr	r0, [pc, #56]	; (19b0 <nffs_inode_update+0xe0>)
    1978:	f240 21aa 	movw	r1, #682	; 0x2aa
    197c:	e7c9      	b.n	1912 <nffs_inode_update+0x42>
    disk_inode.ndi_lastblock_id = inode_entry->nie_last_block_entry->nhe_id;
    197e:	692b      	ldr	r3, [r5, #16]

    nffs_crc_disk_inode_fill(&disk_inode, filename);
    1980:	490c      	ldr	r1, [pc, #48]	; (19b4 <nffs_inode_update+0xe4>)
    disk_inode.ndi_parent_id = nffs_inode_parent_id(&inode);
    disk_inode.ndi_flags = 0;
    disk_inode.ndi_filename_len = filename_len;

    assert(nffs_hash_id_is_block(inode_entry->nie_last_block_entry->nhe_id));
    disk_inode.ndi_lastblock_id = inode_entry->nie_last_block_entry->nhe_id;
    1982:	685b      	ldr	r3, [r3, #4]
    1984:	9309      	str	r3, [sp, #36]	; 0x24

    nffs_crc_disk_inode_fill(&disk_inode, filename);
    1986:	a807      	add	r0, sp, #28
    1988:	f001 fafa 	bl	2f80 <nffs_crc_disk_inode_fill>

    NFFS_LOG(DEBUG, "nffs_inode_update writing inode %x last block %x\n",
             (unsigned int)disk_inode.ndi_id,
             (unsigned int)disk_inode.ndi_lastblock_id);

    rc = nffs_inode_write_disk(&disk_inode, filename, area_idx,
    198c:	a807      	add	r0, sp, #28
    198e:	4909      	ldr	r1, [pc, #36]	; (19b4 <nffs_inode_update+0xe4>)
    1990:	f89d 2007 	ldrb.w	r2, [sp, #7]
    1994:	9b02      	ldr	r3, [sp, #8]
    1996:	f7ff fc3c 	bl	1212 <nffs_inode_write_disk>
                               area_offset);
    if (rc != 0) {
    199a:	4604      	mov	r4, r0
    199c:	b928      	cbnz	r0, 19aa <nffs_inode_update+0xda>
        return rc;
    }

    inode_entry->nie_hash_entry.nhe_flash_loc =
        nffs_flash_loc(area_idx, area_offset);
    199e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    19a2:	9902      	ldr	r1, [sp, #8]
    19a4:	f7ff f9f0 	bl	d88 <nffs_flash_loc>
                               area_offset);
    if (rc != 0) {
        return rc;
    }

    inode_entry->nie_hash_entry.nhe_flash_loc =
    19a8:	60a8      	str	r0, [r5, #8]
    19aa:	4620      	mov	r0, r4
        nffs_flash_loc(area_idx, area_offset);
    return 0;
}
    19ac:	b00c      	add	sp, #48	; 0x30
    19ae:	bd70      	pop	{r4, r5, r6, pc}
    19b0:	00006244 	.word	0x00006244
    19b4:	20000b9c 	.word	0x20000b9c

000019b8 <nffs_inode_is_deleted>:
/*
 * Return true if inode is marked as deleted.
 */
int
nffs_inode_is_deleted(struct nffs_inode_entry *inode_entry)
{
    19b8:	b508      	push	{r3, lr}
    assert(inode_entry);
    19ba:	4602      	mov	r2, r0
    19bc:	b928      	cbnz	r0, 19ca <nffs_inode_is_deleted+0x12>
    19be:	4805      	ldr	r0, [pc, #20]	; (19d4 <nffs_inode_is_deleted+0x1c>)
    19c0:	f240 41eb 	movw	r1, #1259	; 0x4eb
    19c4:	4613      	mov	r3, r2
    19c6:	f003 f941 	bl	4c4c <__assert_func>
}

int
nffs_inode_getflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    return (int)(entry->nie_flags & flag);
    19ca:	7d40      	ldrb	r0, [r0, #21]
nffs_inode_is_deleted(struct nffs_inode_entry *inode_entry)
{
    assert(inode_entry);

    return nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DELETED);
}
    19cc:	f000 0080 	and.w	r0, r0, #128	; 0x80
    19d0:	bd08      	pop	{r3, pc}
    19d2:	bf00      	nop
    19d4:	00006244 	.word	0x00006244

000019d8 <nffs_inode_setflags>:
nffs_inode_setflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    /*
     * We shouldn't be setting flags to already deleted inodes
     */
    entry->nie_flags |= flag;
    19d8:	7d43      	ldrb	r3, [r0, #21]
    19da:	4319      	orrs	r1, r3
    19dc:	7541      	strb	r1, [r0, #21]
    return (int)entry->nie_flags;
}
    19de:	4608      	mov	r0, r1
    19e0:	4770      	bx	lr

000019e2 <nffs_inode_unsetflags>:

int
nffs_inode_unsetflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    entry->nie_flags &= ~flag;
    19e2:	7d43      	ldrb	r3, [r0, #21]
    19e4:	ea23 0101 	bic.w	r1, r3, r1
    19e8:	7541      	strb	r1, [r0, #21]
    return (int)entry->nie_flags;
}
    19ea:	4608      	mov	r0, r1
    19ec:	4770      	bx	lr

000019ee <nffs_inode_getflags>:

int
nffs_inode_getflags(struct nffs_inode_entry *entry, uint8_t flag)
{
    return (int)(entry->nie_flags & flag);
    19ee:	7d40      	ldrb	r0, [r0, #21]
}
    19f0:	4008      	ands	r0, r1
    19f2:	4770      	bx	lr

000019f4 <nffs_misc_validate_root_dir>:
 *                                  directory;
 *                              nonzero on other error.
 */
int
nffs_misc_validate_root_dir(void)
{
    19f4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    struct nffs_inode inode;
    int rc;

    if (nffs_root_dir == NULL) {
    19f6:	4b0a      	ldr	r3, [pc, #40]	; (1a20 <nffs_misc_validate_root_dir+0x2c>)
    19f8:	6819      	ldr	r1, [r3, #0]
    19fa:	b161      	cbz	r1, 1a16 <nffs_misc_validate_root_dir+0x22>
        return FS_ECORRUPT;
    }

    if (nffs_root_dir->nie_hash_entry.nhe_id != NFFS_ID_ROOT_DIR) {
    19fc:	684b      	ldr	r3, [r1, #4]
    19fe:	b953      	cbnz	r3, 1a16 <nffs_misc_validate_root_dir+0x22>
        return FS_ECORRUPT;
    }

    rc = nffs_inode_from_entry(&inode, nffs_root_dir);
    1a00:	4668      	mov	r0, sp
    1a02:	f7ff fe39 	bl	1678 <nffs_inode_from_entry>
    /*
     * nffs_root_dir is automatically flagged a "dummy" inode but it's special
     */
    if (rc != 0 && rc != FS_ENOENT) {
    1a06:	b108      	cbz	r0, 1a0c <nffs_misc_validate_root_dir+0x18>
    1a08:	2806      	cmp	r0, #6
    1a0a:	d105      	bne.n	1a18 <nffs_misc_validate_root_dir+0x24>
        return rc;
    }

    if (inode.ni_parent != NULL) {
    1a0c:	9802      	ldr	r0, [sp, #8]
    1a0e:	3000      	adds	r0, #0
    1a10:	bf18      	it	ne
    1a12:	2001      	movne	r0, #1
    1a14:	e000      	b.n	1a18 <nffs_misc_validate_root_dir+0x24>
{
    struct nffs_inode inode;
    int rc;

    if (nffs_root_dir == NULL) {
        return FS_ECORRUPT;
    1a16:	2001      	movs	r0, #1
    if (inode.ni_parent != NULL) {
        return FS_ECORRUPT;
    }

    return 0;
}
    1a18:	b005      	add	sp, #20
    1a1a:	f85d fb04 	ldr.w	pc, [sp], #4
    1a1e:	bf00      	nop
    1a20:	20000b78 	.word	0x20000b78

00001a24 <nffs_misc_validate_scratch>:
 * @return                      0 if there is a valid scratch area;
 *                              FS_ECORRUPT otherwise.
 */
int
nffs_misc_validate_scratch(void)
{
    1a24:	b510      	push	{r4, lr}
    uint32_t scratch_len;
    int i;

    if (nffs_scratch_area_idx == NFFS_AREA_ID_NONE) {
    1a26:	4b0c      	ldr	r3, [pc, #48]	; (1a58 <nffs_misc_validate_scratch+0x34>)
    1a28:	781b      	ldrb	r3, [r3, #0]
    1a2a:	2bff      	cmp	r3, #255	; 0xff
    1a2c:	d012      	beq.n	1a54 <nffs_misc_validate_scratch+0x30>
        /* No scratch area. */
        return FS_ECORRUPT;
    }

    scratch_len = nffs_areas[nffs_scratch_area_idx].na_length;
    1a2e:	4a0b      	ldr	r2, [pc, #44]	; (1a5c <nffs_misc_validate_scratch+0x38>)
    1a30:	6812      	ldr	r2, [r2, #0]
    1a32:	eb02 1303 	add.w	r3, r2, r3, lsl #4
    1a36:	6858      	ldr	r0, [r3, #4]
    for (i = 0; i < nffs_num_areas; i++) {
    1a38:	4b09      	ldr	r3, [pc, #36]	; (1a60 <nffs_misc_validate_scratch+0x3c>)
    1a3a:	7819      	ldrb	r1, [r3, #0]
    1a3c:	2300      	movs	r3, #0
    1a3e:	428b      	cmp	r3, r1
    1a40:	da06      	bge.n	1a50 <nffs_misc_validate_scratch+0x2c>
    1a42:	eb02 1403 	add.w	r4, r2, r3, lsl #4
        if (nffs_areas[i].na_length > scratch_len) {
    1a46:	6864      	ldr	r4, [r4, #4]
    1a48:	4284      	cmp	r4, r0
    1a4a:	d803      	bhi.n	1a54 <nffs_misc_validate_scratch+0x30>
        /* No scratch area. */
        return FS_ECORRUPT;
    }

    scratch_len = nffs_areas[nffs_scratch_area_idx].na_length;
    for (i = 0; i < nffs_num_areas; i++) {
    1a4c:	3301      	adds	r3, #1
    1a4e:	e7f6      	b.n	1a3e <nffs_misc_validate_scratch+0x1a>
        if (nffs_areas[i].na_length > scratch_len) {
            return FS_ECORRUPT;
        }
    }

    return 0;
    1a50:	2000      	movs	r0, #0
    1a52:	bd10      	pop	{r4, pc}
    uint32_t scratch_len;
    int i;

    if (nffs_scratch_area_idx == NFFS_AREA_ID_NONE) {
        /* No scratch area. */
        return FS_ECORRUPT;
    1a54:	2001      	movs	r0, #1
            return FS_ECORRUPT;
        }
    }

    return 0;
}
    1a56:	bd10      	pop	{r4, pc}
    1a58:	20000aa4 	.word	0x20000aa4
    1a5c:	20000b40 	.word	0x20000b40
    1a60:	20000b24 	.word	0x20000b24

00001a64 <nffs_misc_gc_if_oom>:
 *                                  indicates whether allocation was successful
 *                                  or there was an error.
 */
int
nffs_misc_gc_if_oom(void *resource, int *out_rc)
{
    1a64:	b538      	push	{r3, r4, r5, lr}
    1a66:	460d      	mov	r5, r1
    1a68:	4c0c      	ldr	r4, [pc, #48]	; (1a9c <nffs_misc_gc_if_oom+0x38>)
     * Keeps track of the number of repeated garbage collection cycles.
     * Necessary for ensuring GC stops after all areas have been collected.
     */
    static uint8_t total_gc_cycles;

    if (resource != NULL) {
    1a6a:	b118      	cbz	r0, 1a74 <nffs_misc_gc_if_oom+0x10>
        /* Allocation succeeded.  Reset cycle count in preparation for the next
         * allocation failure.
         */
        total_gc_cycles = 0;
    1a6c:	2000      	movs	r0, #0
    1a6e:	7020      	strb	r0, [r4, #0]
        *out_rc = 0;
    1a70:	6008      	str	r0, [r1, #0]
        return 0;
    1a72:	bd38      	pop	{r3, r4, r5, pc}
    }

    /* If every area has already been garbage collected, there is nothing else
     * that can be done ("- 1" to account for the scratch area).
     */
    if (total_gc_cycles >= nffs_num_areas - 1) {
    1a74:	4a0a      	ldr	r2, [pc, #40]	; (1aa0 <nffs_misc_gc_if_oom+0x3c>)
    1a76:	7821      	ldrb	r1, [r4, #0]
    1a78:	7812      	ldrb	r2, [r2, #0]
    1a7a:	3a01      	subs	r2, #1
    1a7c:	4291      	cmp	r1, r2
    1a7e:	db02      	blt.n	1a86 <nffs_misc_gc_if_oom+0x22>
        *out_rc = FS_ENOMEM;
    1a80:	2205      	movs	r2, #5
    1a82:	602a      	str	r2, [r5, #0]
        return 0;
    1a84:	bd38      	pop	{r3, r4, r5, pc}
    }

    /* Attempt a garbage collection on the next area. */
    *out_rc = nffs_gc(NULL);
    1a86:	f001 fb8b 	bl	31a0 <nffs_gc>
    total_gc_cycles++;
    1a8a:	7823      	ldrb	r3, [r4, #0]
        *out_rc = FS_ENOMEM;
        return 0;
    }

    /* Attempt a garbage collection on the next area. */
    *out_rc = nffs_gc(NULL);
    1a8c:	6028      	str	r0, [r5, #0]
    total_gc_cycles++;
    1a8e:	3301      	adds	r3, #1
    1a90:	7023      	strb	r3, [r4, #0]
    if (*out_rc != 0) {
    1a92:	fab0 f080 	clz	r0, r0
    1a96:	0940      	lsrs	r0, r0, #5
        return 0;
    }

    /* Indicate that garbage collection was successfully performed. */
    return 1;
}
    1a98:	bd38      	pop	{r3, r4, r5, pc}
    1a9a:	bf00      	nop
    1a9c:	200005fc 	.word	0x200005fc
    1aa0:	20000b24 	.word	0x20000b24

00001aa4 <nffs_misc_reserve_space>:
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_misc_reserve_space(uint16_t space,
                        uint8_t *out_area_idx, uint32_t *out_area_offset)
{
    1aa4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t area_idx;
    int rc;
    int i;

    /* Find the first area with sufficient free space. */
    for (i = 0; i < nffs_num_areas; i++) {
    1aa8:	4b1d      	ldr	r3, [pc, #116]	; (1b20 <nffs_misc_reserve_space+0x7c>)
                             uint32_t *out_area_offset)
{
    const struct nffs_area *area;
    uint32_t available;

    area = nffs_areas + area_idx;
    1aaa:	4c1e      	ldr	r4, [pc, #120]	; (1b24 <nffs_misc_reserve_space+0x80>)
    uint8_t area_idx;
    int rc;
    int i;

    /* Find the first area with sufficient free space. */
    for (i = 0; i < nffs_num_areas; i++) {
    1aac:	f893 e000 	ldrb.w	lr, [r3]
        if (i != nffs_scratch_area_idx) {
    1ab0:	4b1d      	ldr	r3, [pc, #116]	; (1b28 <nffs_misc_reserve_space+0x84>)
                             uint32_t *out_area_offset)
{
    const struct nffs_area *area;
    uint32_t available;

    area = nffs_areas + area_idx;
    1ab2:	f8d4 8000 	ldr.w	r8, [r4]
    int rc;
    int i;

    /* Find the first area with sufficient free space. */
    for (i = 0; i < nffs_num_areas; i++) {
        if (i != nffs_scratch_area_idx) {
    1ab6:	f893 c000 	ldrb.w	ip, [r3]
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_misc_reserve_space(uint16_t space,
                        uint8_t *out_area_idx, uint32_t *out_area_offset)
{
    1aba:	4605      	mov	r5, r0
    1abc:	460e      	mov	r6, r1
    1abe:	4617      	mov	r7, r2
    uint8_t area_idx;
    int rc;
    int i;

    /* Find the first area with sufficient free space. */
    for (i = 0; i < nffs_num_areas; i++) {
    1ac0:	2300      	movs	r3, #0
    1ac2:	4573      	cmp	r3, lr
    1ac4:	da0f      	bge.n	1ae6 <nffs_misc_reserve_space+0x42>
        if (i != nffs_scratch_area_idx) {
    1ac6:	4563      	cmp	r3, ip
    1ac8:	d00b      	beq.n	1ae2 <nffs_misc_reserve_space+0x3e>
    1aca:	b2d9      	uxtb	r1, r3
                             uint32_t *out_area_offset)
{
    const struct nffs_area *area;
    uint32_t available;

    area = nffs_areas + area_idx;
    1acc:	eb08 1101 	add.w	r1, r8, r1, lsl #4
    available = area->na_length - area->na_cur;
    1ad0:	6888      	ldr	r0, [r1, #8]
    1ad2:	684a      	ldr	r2, [r1, #4]
    1ad4:	1a12      	subs	r2, r2, r0
    if (available >= space) {
    1ad6:	42aa      	cmp	r2, r5
    1ad8:	d303      	bcc.n	1ae2 <nffs_misc_reserve_space+0x3e>
        *out_area_offset = area->na_cur;
    1ada:	6038      	str	r0, [r7, #0]
    int i;

    /* Find the first area with sufficient free space. */
    for (i = 0; i < nffs_num_areas; i++) {
        if (i != nffs_scratch_area_idx) {
            rc = nffs_misc_reserve_space_area(i, space, out_area_offset);
    1adc:	7033      	strb	r3, [r6, #0]
            if (rc == 0) {
                *out_area_idx = i;
                return 0;
    1ade:	2000      	movs	r0, #0
    1ae0:	e01b      	b.n	1b1a <nffs_misc_reserve_space+0x76>
    uint8_t area_idx;
    int rc;
    int i;

    /* Find the first area with sufficient free space. */
    for (i = 0; i < nffs_num_areas; i++) {
    1ae2:	3301      	adds	r3, #1
    1ae4:	e7ed      	b.n	1ac2 <nffs_misc_reserve_space+0x1e>
    }

    /* No area can accommodate the request.  Garbage collect until an area
     * has enough space.
     */
    rc = nffs_gc_until(space, &area_idx);
    1ae6:	4628      	mov	r0, r5
    1ae8:	f10d 0107 	add.w	r1, sp, #7
    1aec:	f001 fc64 	bl	33b8 <nffs_gc_until>
    if (rc != 0) {
    1af0:	4602      	mov	r2, r0
    1af2:	b958      	cbnz	r0, 1b0c <nffs_misc_reserve_space+0x68>

    /* Now try to reserve space.  If insufficient space was reclaimed with
     * garbage collection, the above call would have failed, so this should
     * succeed.
     */
    rc = nffs_misc_reserve_space_area(area_idx, space, out_area_offset);
    1af4:	f89d 1007 	ldrb.w	r1, [sp, #7]
                             uint32_t *out_area_offset)
{
    const struct nffs_area *area;
    uint32_t available;

    area = nffs_areas + area_idx;
    1af8:	6823      	ldr	r3, [r4, #0]
    1afa:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    available = area->na_length - area->na_cur;
    1afe:	6898      	ldr	r0, [r3, #8]
    1b00:	685b      	ldr	r3, [r3, #4]
    1b02:	1a1b      	subs	r3, r3, r0
    if (available >= space) {
    1b04:	42ab      	cmp	r3, r5
    1b06:	d303      	bcc.n	1b10 <nffs_misc_reserve_space+0x6c>
        *out_area_offset = area->na_cur;
    1b08:	6038      	str	r0, [r7, #0]
     * succeed.
     */
    rc = nffs_misc_reserve_space_area(area_idx, space, out_area_offset);
    assert(rc == 0);

    *out_area_idx = area_idx;
    1b0a:	7031      	strb	r1, [r6, #0]
    1b0c:	4610      	mov	r0, r2
    1b0e:	e004      	b.n	1b1a <nffs_misc_reserve_space+0x76>
    /* Now try to reserve space.  If insufficient space was reclaimed with
     * garbage collection, the above call would have failed, so this should
     * succeed.
     */
    rc = nffs_misc_reserve_space_area(area_idx, space, out_area_offset);
    assert(rc == 0);
    1b10:	4806      	ldr	r0, [pc, #24]	; (1b2c <nffs_misc_reserve_space+0x88>)
    1b12:	21ed      	movs	r1, #237	; 0xed
    1b14:	4613      	mov	r3, r2
    1b16:	f003 f899 	bl	4c4c <__assert_func>

    *out_area_idx = area_idx;

    return rc;
}
    1b1a:	b002      	add	sp, #8
    1b1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1b20:	20000b24 	.word	0x20000b24
    1b24:	20000b40 	.word	0x20000b40
    1b28:	20000aa4 	.word	0x20000aa4
    1b2c:	00006251 	.word	0x00006251

00001b30 <nffs_misc_set_num_areas>:

int
nffs_misc_set_num_areas(uint8_t num_areas)
{
    1b30:	b538      	push	{r3, r4, r5, lr}
    1b32:	4d09      	ldr	r5, [pc, #36]	; (1b58 <nffs_misc_set_num_areas+0x28>)
    if (num_areas == 0) {
    1b34:	4604      	mov	r4, r0
        free(nffs_areas);
    1b36:	6828      	ldr	r0, [r5, #0]
}

int
nffs_misc_set_num_areas(uint8_t num_areas)
{
    if (num_areas == 0) {
    1b38:	b91c      	cbnz	r4, 1b42 <nffs_misc_set_num_areas+0x12>
        free(nffs_areas);
    1b3a:	f003 f8df 	bl	4cfc <os_free>
        nffs_areas = NULL;
    1b3e:	602c      	str	r4, [r5, #0]
    1b40:	e004      	b.n	1b4c <nffs_misc_set_num_areas+0x1c>
    } else {
        nffs_areas = realloc(nffs_areas, num_areas * sizeof *nffs_areas);
    1b42:	0121      	lsls	r1, r4, #4
    1b44:	f003 f8e5 	bl	4d12 <os_realloc>
    1b48:	6028      	str	r0, [r5, #0]
        if (nffs_areas == NULL) {
    1b4a:	b118      	cbz	r0, 1b54 <nffs_misc_set_num_areas+0x24>
            return FS_ENOMEM;
        }
    }

    nffs_num_areas = num_areas;
    1b4c:	4b03      	ldr	r3, [pc, #12]	; (1b5c <nffs_misc_set_num_areas+0x2c>)
    1b4e:	701c      	strb	r4, [r3, #0]

    return 0;
    1b50:	2000      	movs	r0, #0
    1b52:	bd38      	pop	{r3, r4, r5, pc}
        free(nffs_areas);
        nffs_areas = NULL;
    } else {
        nffs_areas = realloc(nffs_areas, num_areas * sizeof *nffs_areas);
        if (nffs_areas == NULL) {
            return FS_ENOMEM;
    1b54:	2005      	movs	r0, #5
    }

    nffs_num_areas = num_areas;

    return 0;
}
    1b56:	bd38      	pop	{r3, r4, r5, pc}
    1b58:	20000b40 	.word	0x20000b40
    1b5c:	20000b24 	.word	0x20000b24

00001b60 <nffs_misc_set_max_block_data_len>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_misc_set_max_block_data_len(uint16_t min_data_len)
{
    1b60:	b530      	push	{r4, r5, lr}
    uint32_t smallest_area;
    uint32_t half_smallest;
    int i;

    smallest_area = -1;
    for (i = 0; i < nffs_num_areas; i++) {
    1b62:	4b14      	ldr	r3, [pc, #80]	; (1bb4 <nffs_misc_set_max_block_data_len+0x54>)
    1b64:	7819      	ldrb	r1, [r3, #0]
        if (nffs_areas[i].na_length < smallest_area) {
    1b66:	4b14      	ldr	r3, [pc, #80]	; (1bb8 <nffs_misc_set_max_block_data_len+0x58>)
    uint32_t smallest_area;
    uint32_t half_smallest;
    int i;

    smallest_area = -1;
    for (i = 0; i < nffs_num_areas; i++) {
    1b68:	2200      	movs	r2, #0
        if (nffs_areas[i].na_length < smallest_area) {
    1b6a:	681c      	ldr	r4, [r3, #0]
{
    uint32_t smallest_area;
    uint32_t half_smallest;
    int i;

    smallest_area = -1;
    1b6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    for (i = 0; i < nffs_num_areas; i++) {
    1b70:	428a      	cmp	r2, r1
    1b72:	da07      	bge.n	1b84 <nffs_misc_set_max_block_data_len+0x24>
    1b74:	eb04 1502 	add.w	r5, r4, r2, lsl #4
    1b78:	3201      	adds	r2, #1
        if (nffs_areas[i].na_length < smallest_area) {
    1b7a:	686d      	ldr	r5, [r5, #4]
    1b7c:	42ab      	cmp	r3, r5
    1b7e:	bf28      	it	cs
    1b80:	462b      	movcs	r3, r5
    1b82:	e7f5      	b.n	1b70 <nffs_misc_set_max_block_data_len+0x10>
 * the specified size.
 */
static uint32_t
nffs_misc_area_capacity_one(uint32_t area_length)
{
    return area_length -
    1b84:	f1a3 022c 	sub.w	r2, r3, #44	; 0x2c
            smallest_area = nffs_areas[i].na_length;
        }
    }

    /* Don't allow a data block size bigger than the smallest area. */
    if (nffs_misc_area_capacity_one(smallest_area) < min_data_len) {
    1b88:	4282      	cmp	r2, r0
    1b8a:	d30f      	bcc.n	1bac <nffs_misc_set_max_block_data_len+0x4c>
 * an area of the specified size.
 */
static uint32_t
nffs_misc_area_capacity_two(uint32_t area_length)
{
    return (area_length - sizeof (struct nffs_disk_area)) / 2 -
    1b8c:	3b18      	subs	r3, #24
    1b8e:	085b      	lsrs	r3, r3, #1
    1b90:	3b14      	subs	r3, #20
    if (nffs_misc_area_capacity_one(smallest_area) < min_data_len) {
        return FS_ECORRUPT;
    }

    half_smallest = nffs_misc_area_capacity_two(smallest_area);
    if (half_smallest < NFFS_BLOCK_MAX_DATA_SZ_MAX) {
    1b92:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    1b96:	4a09      	ldr	r2, [pc, #36]	; (1bbc <nffs_misc_set_max_block_data_len+0x5c>)
        nffs_block_max_data_sz = half_smallest;
    } else {
        nffs_block_max_data_sz = NFFS_BLOCK_MAX_DATA_SZ_MAX;
    1b98:	bf28      	it	cs
    1b9a:	f44f 6300 	movcs.w	r3, #2048	; 0x800
    1b9e:	8013      	strh	r3, [r2, #0]
    }

    if (nffs_block_max_data_sz < min_data_len) {
    1ba0:	8813      	ldrh	r3, [r2, #0]
    1ba2:	4283      	cmp	r3, r0
    1ba4:	d204      	bcs.n	1bb0 <nffs_misc_set_max_block_data_len+0x50>
        nffs_block_max_data_sz = min_data_len;
    1ba6:	4b05      	ldr	r3, [pc, #20]	; (1bbc <nffs_misc_set_max_block_data_len+0x5c>)
    1ba8:	8018      	strh	r0, [r3, #0]
    1baa:	e001      	b.n	1bb0 <nffs_misc_set_max_block_data_len+0x50>
        }
    }

    /* Don't allow a data block size bigger than the smallest area. */
    if (nffs_misc_area_capacity_one(smallest_area) < min_data_len) {
        return FS_ECORRUPT;
    1bac:	2001      	movs	r0, #1
    1bae:	bd30      	pop	{r4, r5, pc}

    if (nffs_block_max_data_sz < min_data_len) {
        nffs_block_max_data_sz = min_data_len;
    }

    return 0;
    1bb0:	2000      	movs	r0, #0
}
    1bb2:	bd30      	pop	{r4, r5, pc}
    1bb4:	20000b24 	.word	0x20000b24
    1bb8:	20000b40 	.word	0x20000b40
    1bbc:	20000b60 	.word	0x20000b60

00001bc0 <nffs_misc_create_lost_found_dir>:

int
nffs_misc_create_lost_found_dir(void)
{
    1bc0:	b508      	push	{r3, lr}
    int rc;

    rc = nffs_path_new_dir("/lost+found", &nffs_lost_found_dir);
    1bc2:	4807      	ldr	r0, [pc, #28]	; (1be0 <nffs_misc_create_lost_found_dir+0x20>)
    1bc4:	4907      	ldr	r1, [pc, #28]	; (1be4 <nffs_misc_create_lost_found_dir+0x24>)
    1bc6:	f000 f9a7 	bl	1f18 <nffs_path_new_dir>
    switch (rc) {
    1bca:	b138      	cbz	r0, 1bdc <nffs_misc_create_lost_found_dir+0x1c>
    1bcc:	280b      	cmp	r0, #11
    1bce:	d105      	bne.n	1bdc <nffs_misc_create_lost_found_dir+0x1c>
    case 0:
        return 0;

    case FS_EEXIST:
        rc = nffs_path_find_inode_entry("/lost+found", &nffs_lost_found_dir);
    1bd0:	4803      	ldr	r0, [pc, #12]	; (1be0 <nffs_misc_create_lost_found_dir+0x20>)
    1bd2:	4904      	ldr	r1, [pc, #16]	; (1be4 <nffs_misc_create_lost_found_dir+0x24>)
        return rc;

    default:
        return rc;
    }
}
    1bd4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    switch (rc) {
    case 0:
        return 0;

    case FS_EEXIST:
        rc = nffs_path_find_inode_entry("/lost+found", &nffs_lost_found_dir);
    1bd8:	f000 b932 	b.w	1e40 <nffs_path_find_inode_entry>
        return rc;

    default:
        return rc;
    }
}
    1bdc:	bd08      	pop	{r3, pc}
    1bde:	bf00      	nop
    1be0:	0000625d 	.word	0x0000625d
    1be4:	20000ac8 	.word	0x20000ac8

00001be8 <nffs_misc_reset>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_misc_reset(void)
{
    1be8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int rc;

    nffs_cache_clear();
    1bea:	f7fe fe9b 	bl	924 <nffs_cache_clear>

    rc = os_mempool_init(&nffs_file_pool, nffs_config.nc_num_files,
    1bee:	4b31      	ldr	r3, [pc, #196]	; (1cb4 <nffs_misc_reset+0xcc>)
    1bf0:	9300      	str	r3, [sp, #0]
    1bf2:	4c31      	ldr	r4, [pc, #196]	; (1cb8 <nffs_misc_reset+0xd0>)
    1bf4:	4b31      	ldr	r3, [pc, #196]	; (1cbc <nffs_misc_reset+0xd4>)
    1bf6:	4832      	ldr	r0, [pc, #200]	; (1cc0 <nffs_misc_reset+0xd8>)
    1bf8:	68a1      	ldr	r1, [r4, #8]
    1bfa:	681b      	ldr	r3, [r3, #0]
    1bfc:	220c      	movs	r2, #12
    1bfe:	f003 f897 	bl	4d30 <os_mempool_init>
                         sizeof (struct nffs_file), nffs_file_mem,
                         "nffs_file_pool");
    if (rc != 0) {
    1c02:	b108      	cbz	r0, 1c08 <nffs_misc_reset+0x20>
        return FS_EOS;
    1c04:	200a      	movs	r0, #10
    1c06:	e053      	b.n	1cb0 <nffs_misc_reset+0xc8>
    }

    rc = os_mempool_init(&nffs_inode_entry_pool, nffs_config.nc_num_inodes,
    1c08:	4b2e      	ldr	r3, [pc, #184]	; (1cc4 <nffs_misc_reset+0xdc>)
    1c0a:	9300      	str	r3, [sp, #0]
    1c0c:	4b2e      	ldr	r3, [pc, #184]	; (1cc8 <nffs_misc_reset+0xe0>)
    1c0e:	482f      	ldr	r0, [pc, #188]	; (1ccc <nffs_misc_reset+0xe4>)
    1c10:	6821      	ldr	r1, [r4, #0]
    1c12:	681b      	ldr	r3, [r3, #0]
    1c14:	2218      	movs	r2, #24
    1c16:	f003 f88b 	bl	4d30 <os_mempool_init>
                         sizeof (struct nffs_inode_entry), nffs_inode_mem,
                         "nffs_inode_entry_pool");
    if (rc != 0) {
    1c1a:	2800      	cmp	r0, #0
    1c1c:	d1f2      	bne.n	1c04 <nffs_misc_reset+0x1c>
        return FS_EOS;
    }

    rc = os_mempool_init(&nffs_block_entry_pool, nffs_config.nc_num_blocks,
    1c1e:	4b2c      	ldr	r3, [pc, #176]	; (1cd0 <nffs_misc_reset+0xe8>)
    1c20:	9300      	str	r3, [sp, #0]
    1c22:	4b2c      	ldr	r3, [pc, #176]	; (1cd4 <nffs_misc_reset+0xec>)
    1c24:	482c      	ldr	r0, [pc, #176]	; (1cd8 <nffs_misc_reset+0xf0>)
    1c26:	6861      	ldr	r1, [r4, #4]
    1c28:	681b      	ldr	r3, [r3, #0]
    1c2a:	220c      	movs	r2, #12
    1c2c:	f003 f880 	bl	4d30 <os_mempool_init>
                         sizeof (struct nffs_hash_entry), nffs_block_entry_mem,
                         "nffs_block_entry_pool");
    if (rc != 0) {
    1c30:	2800      	cmp	r0, #0
    1c32:	d1e7      	bne.n	1c04 <nffs_misc_reset+0x1c>
        return FS_EOS;
    }

    rc = os_mempool_init(&nffs_cache_inode_pool,
    1c34:	4b29      	ldr	r3, [pc, #164]	; (1cdc <nffs_misc_reset+0xf4>)
    1c36:	9300      	str	r3, [sp, #0]
    1c38:	4b29      	ldr	r3, [pc, #164]	; (1ce0 <nffs_misc_reset+0xf8>)
    1c3a:	482a      	ldr	r0, [pc, #168]	; (1ce4 <nffs_misc_reset+0xfc>)
    1c3c:	6921      	ldr	r1, [r4, #16]
    1c3e:	681b      	ldr	r3, [r3, #0]
    1c40:	2224      	movs	r2, #36	; 0x24
    1c42:	f003 f875 	bl	4d30 <os_mempool_init>
                         nffs_config.nc_num_cache_inodes,
                         sizeof (struct nffs_cache_inode),
                         nffs_cache_inode_mem, "nffs_cache_inode_pool");
    if (rc != 0) {
    1c46:	2800      	cmp	r0, #0
    1c48:	d1dc      	bne.n	1c04 <nffs_misc_reset+0x1c>
        return FS_EOS;
    }

    rc = os_mempool_init(&nffs_cache_block_pool,
    1c4a:	4b27      	ldr	r3, [pc, #156]	; (1ce8 <nffs_misc_reset+0x100>)
    1c4c:	9300      	str	r3, [sp, #0]
    1c4e:	4b27      	ldr	r3, [pc, #156]	; (1cec <nffs_misc_reset+0x104>)
    1c50:	4827      	ldr	r0, [pc, #156]	; (1cf0 <nffs_misc_reset+0x108>)
    1c52:	6961      	ldr	r1, [r4, #20]
    1c54:	681b      	ldr	r3, [r3, #0]
    1c56:	2220      	movs	r2, #32
    1c58:	f003 f86a 	bl	4d30 <os_mempool_init>
                         nffs_config.nc_num_cache_blocks,
                         sizeof (struct nffs_cache_block),
                         nffs_cache_block_mem, "nffs_cache_block_pool");
    if (rc != 0) {
    1c5c:	2800      	cmp	r0, #0
    1c5e:	d1d1      	bne.n	1c04 <nffs_misc_reset+0x1c>
        return FS_EOS;
    }

    rc = os_mempool_init(&nffs_dir_pool,
    1c60:	4b24      	ldr	r3, [pc, #144]	; (1cf4 <nffs_misc_reset+0x10c>)
    1c62:	9300      	str	r3, [sp, #0]
    1c64:	4b24      	ldr	r3, [pc, #144]	; (1cf8 <nffs_misc_reset+0x110>)
    1c66:	4825      	ldr	r0, [pc, #148]	; (1cfc <nffs_misc_reset+0x114>)
    1c68:	68e1      	ldr	r1, [r4, #12]
    1c6a:	681b      	ldr	r3, [r3, #0]
    1c6c:	2208      	movs	r2, #8
    1c6e:	f003 f85f 	bl	4d30 <os_mempool_init>
                         nffs_config.nc_num_dirs,
                         sizeof (struct nffs_dir),
                         nffs_dir_mem, "nffs_dir_pool");
    if (rc != 0) {
    1c72:	2800      	cmp	r0, #0
    1c74:	d1c6      	bne.n	1c04 <nffs_misc_reset+0x1c>
        return FS_EOS;
    }

    rc = nffs_hash_init();
    1c76:	f7ff f9fb 	bl	1070 <nffs_hash_init>
    if (rc != 0) {
    1c7a:	4604      	mov	r4, r0
    1c7c:	b9b8      	cbnz	r0, 1cae <nffs_misc_reset+0xc6>
        return rc;
    }

    free(nffs_areas);
    1c7e:	4d20      	ldr	r5, [pc, #128]	; (1d00 <nffs_misc_reset+0x118>)
    1c80:	6828      	ldr	r0, [r5, #0]
    1c82:	f003 f83b 	bl	4cfc <os_free>
    nffs_areas = NULL;
    nffs_num_areas = 0;
    1c86:	4b1f      	ldr	r3, [pc, #124]	; (1d04 <nffs_misc_reset+0x11c>)
    if (rc != 0) {
        return rc;
    }

    free(nffs_areas);
    nffs_areas = NULL;
    1c88:	602c      	str	r4, [r5, #0]
    nffs_num_areas = 0;
    1c8a:	701c      	strb	r4, [r3, #0]

    nffs_root_dir = NULL;
    1c8c:	4b1e      	ldr	r3, [pc, #120]	; (1d08 <nffs_misc_reset+0x120>)
    1c8e:	601c      	str	r4, [r3, #0]
    nffs_lost_found_dir = NULL;
    1c90:	4b1e      	ldr	r3, [pc, #120]	; (1d0c <nffs_misc_reset+0x124>)
    1c92:	601c      	str	r4, [r3, #0]
    nffs_scratch_area_idx = NFFS_AREA_ID_NONE;
    1c94:	4b1e      	ldr	r3, [pc, #120]	; (1d10 <nffs_misc_reset+0x128>)
    1c96:	22ff      	movs	r2, #255	; 0xff
    1c98:	701a      	strb	r2, [r3, #0]

    nffs_hash_next_file_id = NFFS_ID_FILE_MIN;
    1c9a:	4b1e      	ldr	r3, [pc, #120]	; (1d14 <nffs_misc_reset+0x12c>)
    1c9c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1ca0:	601a      	str	r2, [r3, #0]
    nffs_hash_next_dir_id = NFFS_ID_DIR_MIN;
    1ca2:	4b1d      	ldr	r3, [pc, #116]	; (1d18 <nffs_misc_reset+0x130>)
    1ca4:	601c      	str	r4, [r3, #0]
    nffs_hash_next_block_id = NFFS_ID_BLOCK_MIN;
    1ca6:	4b1d      	ldr	r3, [pc, #116]	; (1d1c <nffs_misc_reset+0x134>)
    1ca8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    1cac:	601a      	str	r2, [r3, #0]
    1cae:	4620      	mov	r0, r4

    return 0;
}
    1cb0:	b003      	add	sp, #12
    1cb2:	bd30      	pop	{r4, r5, pc}
    1cb4:	00006269 	.word	0x00006269
    1cb8:	20000b84 	.word	0x20000b84
    1cbc:	20000b28 	.word	0x20000b28
    1cc0:	20000acc 	.word	0x20000acc
    1cc4:	00006278 	.word	0x00006278
    1cc8:	20000b30 	.word	0x20000b30
    1ccc:	20000b08 	.word	0x20000b08
    1cd0:	0000628e 	.word	0x0000628e
    1cd4:	20000b80 	.word	0x20000b80
    1cd8:	20000b44 	.word	0x20000b44
    1cdc:	000062a4 	.word	0x000062a4
    1ce0:	20000aa8 	.word	0x20000aa8
    1ce4:	20000a88 	.word	0x20000a88
    1ce8:	000062ba 	.word	0x000062ba
    1cec:	20000b2c 	.word	0x20000b2c
    1cf0:	20000ae8 	.word	0x20000ae8
    1cf4:	000062d0 	.word	0x000062d0
    1cf8:	20000b7c 	.word	0x20000b7c
    1cfc:	20000aac 	.word	0x20000aac
    1d00:	20000b40 	.word	0x20000b40
    1d04:	20000b24 	.word	0x20000b24
    1d08:	20000b78 	.word	0x20000b78
    1d0c:	20000ac8 	.word	0x20000ac8
    1d10:	20000aa4 	.word	0x20000aa4
    1d14:	20000ca8 	.word	0x20000ca8
    1d18:	20000c9c 	.word	0x20000c9c
    1d1c:	20000ca0 	.word	0x20000ca0

00001d20 <nffs_misc_ready>:
 * @return                  1 if a file system is present; 0 otherwise.
 */
int
nffs_misc_ready(void)
{
    return nffs_root_dir != NULL;
    1d20:	4b02      	ldr	r3, [pc, #8]	; (1d2c <nffs_misc_ready+0xc>)
    1d22:	6818      	ldr	r0, [r3, #0]
}
    1d24:	3000      	adds	r0, #0
    1d26:	bf18      	it	ne
    1d28:	2001      	movne	r0, #1
    1d2a:	4770      	bx	lr
    1d2c:	20000b78 	.word	0x20000b78

00001d30 <nffs_path_find_child.isra.0>:
    parser->npp_path = path;
    parser->npp_off = 0;
}

static int
nffs_path_find_child(struct nffs_inode_entry *parent,
    1d30:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d32:	4604      	mov	r4, r0
    1d34:	b087      	sub	sp, #28
    1d36:	460d      	mov	r5, r1
    1d38:	4616      	mov	r6, r2
    1d3a:	461f      	mov	r7, r3
    struct nffs_inode_entry *cur;
    struct nffs_inode inode;
    int cmp;
    int rc;

    SLIST_FOREACH(cur, &parent->nie_child_list, nie_sibling_next) {
    1d3c:	b18c      	cbz	r4, 1d62 <nffs_path_find_child.isra.0+0x32>
        rc = nffs_inode_from_entry(&inode, cur);
    1d3e:	a802      	add	r0, sp, #8
    1d40:	4621      	mov	r1, r4
    1d42:	f7ff fc99 	bl	1678 <nffs_inode_from_entry>
        if (rc != 0) {
    1d46:	b980      	cbnz	r0, 1d6a <nffs_path_find_child.isra.0+0x3a>
            return rc;
        }

        rc = nffs_inode_filename_cmp_ram(&inode, name, name_len, &cmp);
    1d48:	a802      	add	r0, sp, #8
    1d4a:	4629      	mov	r1, r5
    1d4c:	4632      	mov	r2, r6
    1d4e:	ab01      	add	r3, sp, #4
    1d50:	f7ff fb92 	bl	1478 <nffs_inode_filename_cmp_ram>
        if (rc != 0) {
    1d54:	b948      	cbnz	r0, 1d6a <nffs_path_find_child.isra.0+0x3a>
            return rc;
        }

        if (cmp == 0) {
    1d56:	9801      	ldr	r0, [sp, #4]
    1d58:	2800      	cmp	r0, #0
    1d5a:	d101      	bne.n	1d60 <nffs_path_find_child.isra.0+0x30>
            *out_inode_entry = cur;
    1d5c:	603c      	str	r4, [r7, #0]
    1d5e:	e004      	b.n	1d6a <nffs_path_find_child.isra.0+0x3a>
            return 0;
        }
        if (cmp > 0) {
    1d60:	dd01      	ble.n	1d66 <nffs_path_find_child.isra.0+0x36>
            break;
        }
    }

    return FS_ENOENT;
    1d62:	2006      	movs	r0, #6
    1d64:	e001      	b.n	1d6a <nffs_path_find_child.isra.0+0x3a>
    struct nffs_inode_entry *cur;
    struct nffs_inode inode;
    int cmp;
    int rc;

    SLIST_FOREACH(cur, &parent->nie_child_list, nie_sibling_next) {
    1d66:	68e4      	ldr	r4, [r4, #12]
    1d68:	e7e8      	b.n	1d3c <nffs_path_find_child.isra.0+0xc>
            break;
        }
    }

    return FS_ENOENT;
}
    1d6a:	b007      	add	sp, #28
    1d6c:	bdf0      	pop	{r4, r5, r6, r7, pc}

00001d6e <nffs_path_parse_next>:
#include "nffs/nffs.h"
#include "nffs_priv.h"

int
nffs_path_parse_next(struct nffs_path_parser *parser)
{
    1d6e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    const char *slash_start;
    int token_end;
    int token_len;

    if (parser->npp_token_type == NFFS_PATH_TOKEN_LEAF) {
    1d72:	f8d0 8000 	ldr.w	r8, [r0]
    1d76:	f1b8 0f02 	cmp.w	r8, #2
#include "nffs/nffs.h"
#include "nffs_priv.h"

int
nffs_path_parse_next(struct nffs_path_parser *parser)
{
    1d7a:	4604      	mov	r4, r0
    const char *slash_start;
    int token_end;
    int token_len;

    if (parser->npp_token_type == NFFS_PATH_TOKEN_LEAF) {
    1d7c:	d102      	bne.n	1d84 <nffs_path_parse_next+0x16>
        return FS_EINVAL;
    1d7e:	2004      	movs	r0, #4
    1d80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    slash_start = strchr(parser->npp_path + parser->npp_off, '/');
    1d84:	6847      	ldr	r7, [r0, #4]
    1d86:	6905      	ldr	r5, [r0, #16]
    1d88:	197e      	adds	r6, r7, r5
    1d8a:	4630      	mov	r0, r6
    1d8c:	212f      	movs	r1, #47	; 0x2f
    1d8e:	f001 fdf1 	bl	3974 <strchr>
    if (slash_start == NULL) {
    1d92:	b940      	cbnz	r0, 1da6 <nffs_path_parse_next+0x38>
        if (parser->npp_token_type == NFFS_PATH_TOKEN_NONE) {
    1d94:	f1b8 0f00 	cmp.w	r8, #0
    1d98:	d0f1      	beq.n	1d7e <nffs_path_parse_next+0x10>
            return FS_EINVAL;
        }
        parser->npp_token_type = NFFS_PATH_TOKEN_LEAF;
    1d9a:	2302      	movs	r3, #2
    1d9c:	6023      	str	r3, [r4, #0]
        token_len = strlen(parser->npp_path + parser->npp_off);
    1d9e:	4630      	mov	r0, r6
    1da0:	f001 fdfd 	bl	399e <strlen>
    1da4:	e003      	b.n	1dae <nffs_path_parse_next+0x40>
    } else {
        parser->npp_token_type = NFFS_PATH_TOKEN_BRANCH;
    1da6:	2301      	movs	r3, #1
        token_end = slash_start - parser->npp_path;
    1da8:	1bc0      	subs	r0, r0, r7
            return FS_EINVAL;
        }
        parser->npp_token_type = NFFS_PATH_TOKEN_LEAF;
        token_len = strlen(parser->npp_path + parser->npp_off);
    } else {
        parser->npp_token_type = NFFS_PATH_TOKEN_BRANCH;
    1daa:	6023      	str	r3, [r4, #0]
        token_end = slash_start - parser->npp_path;
        token_len = token_end - parser->npp_off;
    1dac:	1b40      	subs	r0, r0, r5
    }

    if (token_len > NFFS_FILENAME_MAX_LEN) {
    1dae:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    1db2:	dce4      	bgt.n	1d7e <nffs_path_parse_next+0x10>
        return FS_EINVAL;
    }

    parser->npp_token = parser->npp_path + parser->npp_off;
    parser->npp_token_len = token_len;
    1db4:	60e0      	str	r0, [r4, #12]
    parser->npp_off += token_len + 1;
    1db6:	3001      	adds	r0, #1
    1db8:	4428      	add	r0, r5
    1dba:	6120      	str	r0, [r4, #16]

    if (token_len > NFFS_FILENAME_MAX_LEN) {
        return FS_EINVAL;
    }

    parser->npp_token = parser->npp_path + parser->npp_off;
    1dbc:	60a6      	str	r6, [r4, #8]
    parser->npp_token_len = token_len;
    parser->npp_off += token_len + 1;

    return 0;
    1dbe:	2000      	movs	r0, #0
}
    1dc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00001dc4 <nffs_path_parser_new>:

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1dc4:	2300      	movs	r3, #0
    1dc6:	6003      	str	r3, [r0, #0]
    parser->npp_path = path;
    1dc8:	6041      	str	r1, [r0, #4]
    parser->npp_off = 0;
    1dca:	6103      	str	r3, [r0, #16]
    1dcc:	4770      	bx	lr
	...

00001dd0 <nffs_path_find>:
{
    struct nffs_inode_entry *parent;
    struct nffs_inode_entry *inode_entry;
    int rc;

    *out_inode_entry = NULL;
    1dd0:	2300      	movs	r3, #0
 */
int
nffs_path_find(struct nffs_path_parser *parser,
               struct nffs_inode_entry **out_inode_entry,
               struct nffs_inode_entry **out_parent)
{
    1dd2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1dd4:	4605      	mov	r5, r0
    1dd6:	460f      	mov	r7, r1
    struct nffs_inode_entry *parent;
    struct nffs_inode_entry *inode_entry;
    int rc;

    *out_inode_entry = NULL;
    1dd8:	600b      	str	r3, [r1, #0]
    if (out_parent != NULL) {
    1dda:	4616      	mov	r6, r2
    1ddc:	b102      	cbz	r2, 1de0 <nffs_path_find+0x10>
        *out_parent = NULL;
    1dde:	6013      	str	r3, [r2, #0]
    }

    inode_entry = NULL;
    1de0:	9301      	str	r3, [sp, #4]
    while (1) {
        parent = inode_entry;
        rc = nffs_path_parse_next(parser);
    1de2:	4628      	mov	r0, r5
        *out_parent = NULL;
    }

    inode_entry = NULL;
    while (1) {
        parent = inode_entry;
    1de4:	9c01      	ldr	r4, [sp, #4]
        rc = nffs_path_parse_next(parser);
    1de6:	f7ff ffc2 	bl	1d6e <nffs_path_parse_next>
        if (rc != 0) {
    1dea:	bb28      	cbnz	r0, 1e38 <nffs_path_find+0x68>
            return rc;
        }

        switch (parser->npp_token_type) {
    1dec:	682b      	ldr	r3, [r5, #0]
    1dee:	2b01      	cmp	r3, #1
    1df0:	d002      	beq.n	1df8 <nffs_path_find+0x28>
    1df2:	2b02      	cmp	r3, #2
    1df4:	d010      	beq.n	1e18 <nffs_path_find+0x48>
    1df6:	e7f4      	b.n	1de2 <nffs_path_find+0x12>
    1df8:	68ea      	ldr	r2, [r5, #12]
        case NFFS_PATH_TOKEN_BRANCH:
            if (parent == NULL) {
    1dfa:	b91c      	cbnz	r4, 1e04 <nffs_path_find+0x34>
                /* First directory must be root. */
                if (parser->npp_token_len != 0) {
    1dfc:	b9da      	cbnz	r2, 1e36 <nffs_path_find+0x66>
                    return FS_ENOENT;
                }

                inode_entry = nffs_root_dir;
    1dfe:	4b0f      	ldr	r3, [pc, #60]	; (1e3c <nffs_path_find+0x6c>)
    1e00:	681b      	ldr	r3, [r3, #0]
    1e02:	e7ed      	b.n	1de0 <nffs_path_find+0x10>
            } else {
                /* Ignore empty intermediate directory names. */
                if (parser->npp_token_len == 0) {
    1e04:	2a00      	cmp	r2, #0
    1e06:	d0ec      	beq.n	1de2 <nffs_path_find+0x12>
                    break;
                }

                rc = nffs_path_find_child(parent, parser->npp_token,
    1e08:	6920      	ldr	r0, [r4, #16]
    1e0a:	68a9      	ldr	r1, [r5, #8]
    1e0c:	ab01      	add	r3, sp, #4
    1e0e:	f7ff ff8f 	bl	1d30 <nffs_path_find_child.isra.0>
                                          parser->npp_token_len, &inode_entry);
                if (rc != 0) {
    1e12:	2800      	cmp	r0, #0
    1e14:	d0e5      	beq.n	1de2 <nffs_path_find+0x12>
    1e16:	e009      	b.n	1e2c <nffs_path_find+0x5c>
                    goto done;
                }
            }
            break;
        case NFFS_PATH_TOKEN_LEAF:
            if (parent == NULL) {
    1e18:	b16c      	cbz	r4, 1e36 <nffs_path_find+0x66>
                /* First token must be root directory. */
                return FS_ENOENT;
            }

            if (parser->npp_token_len == 0) {
    1e1a:	68ea      	ldr	r2, [r5, #12]
    1e1c:	b90a      	cbnz	r2, 1e22 <nffs_path_find+0x52>
                /* If the path ends with a slash, the leaf is the parent, not
                 * the trailing empty token.
                 */
                inode_entry = parent;
    1e1e:	9401      	str	r4, [sp, #4]
    1e20:	e004      	b.n	1e2c <nffs_path_find+0x5c>
                rc = 0;
            } else {
                rc = nffs_path_find_child(parent, parser->npp_token,
    1e22:	6920      	ldr	r0, [r4, #16]
    1e24:	68a9      	ldr	r1, [r5, #8]
    1e26:	ab01      	add	r3, sp, #4
    1e28:	f7ff ff82 	bl	1d30 <nffs_path_find_child.isra.0>
            goto done;
        }
    }

done:
    *out_inode_entry = inode_entry;
    1e2c:	9b01      	ldr	r3, [sp, #4]
    1e2e:	603b      	str	r3, [r7, #0]
    if (out_parent != NULL) {
    1e30:	b116      	cbz	r6, 1e38 <nffs_path_find+0x68>
        *out_parent = parent;
    1e32:	6034      	str	r4, [r6, #0]
    1e34:	e000      	b.n	1e38 <nffs_path_find+0x68>
        switch (parser->npp_token_type) {
        case NFFS_PATH_TOKEN_BRANCH:
            if (parent == NULL) {
                /* First directory must be root. */
                if (parser->npp_token_len != 0) {
                    return FS_ENOENT;
    1e36:	2006      	movs	r0, #6
    *out_inode_entry = inode_entry;
    if (out_parent != NULL) {
        *out_parent = parent;
    }
    return rc;
}
    1e38:	b003      	add	sp, #12
    1e3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e3c:	20000b78 	.word	0x20000b78

00001e40 <nffs_path_find_inode_entry>:

int
nffs_path_find_inode_entry(const char *filename,
                           struct nffs_inode_entry **out_inode_entry)
{
    1e40:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
}

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1e42:	2200      	movs	r2, #0
    parser->npp_path = path;
    1e44:	9002      	str	r0, [sp, #8]
{
    struct nffs_path_parser parser;
    int rc;

    nffs_path_parser_new(&parser, filename);
    rc = nffs_path_find(&parser, out_inode_entry, NULL);
    1e46:	a801      	add	r0, sp, #4
}

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1e48:	9201      	str	r2, [sp, #4]
    parser->npp_path = path;
    parser->npp_off = 0;
    1e4a:	9205      	str	r2, [sp, #20]
{
    struct nffs_path_parser parser;
    int rc;

    nffs_path_parser_new(&parser, filename);
    rc = nffs_path_find(&parser, out_inode_entry, NULL);
    1e4c:	f7ff ffc0 	bl	1dd0 <nffs_path_find>

    return rc;
}
    1e50:	b007      	add	sp, #28
    1e52:	f85d fb04 	ldr.w	pc, [sp], #4

00001e56 <nffs_path_unlink>:
 *
 * @return                  0 on success; nonzero on failure.
 */
int
nffs_path_unlink(const char *path)
{
    1e56:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    struct nffs_inode_entry *inode_entry;
    struct nffs_inode inode;
    int rc;

    rc = nffs_path_find_inode_entry(path, &inode_entry);
    1e58:	a901      	add	r1, sp, #4
    1e5a:	f7ff fff1 	bl	1e40 <nffs_path_find_inode_entry>
    if (rc != 0) {
    1e5e:	b938      	cbnz	r0, 1e70 <nffs_path_unlink+0x1a>
        return rc;
    }

    rc = nffs_inode_from_entry(&inode, inode_entry);
    1e60:	a802      	add	r0, sp, #8
    1e62:	9901      	ldr	r1, [sp, #4]
    1e64:	f7ff fc08 	bl	1678 <nffs_inode_from_entry>
    if (rc != 0) {
    1e68:	b910      	cbnz	r0, 1e70 <nffs_path_unlink+0x1a>
        return rc;
    }

    rc = nffs_inode_unlink(&inode);
    1e6a:	a802      	add	r0, sp, #8
    1e6c:	f7ff fbdd 	bl	162a <nffs_inode_unlink>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    1e70:	b007      	add	sp, #28
    1e72:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00001e78 <nffs_path_rename>:
 * @return                  0 on success;
 *                          nonzero on failure.
 */
int
nffs_path_rename(const char *from, const char *to)
{
    1e78:	b510      	push	{r4, lr}
    1e7a:	b08e      	sub	sp, #56	; 0x38
}

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1e7c:	2300      	movs	r3, #0
 * @return                  0 on success;
 *                          nonzero on failure.
 */
int
nffs_path_rename(const char *from, const char *to)
{
    1e7e:	460c      	mov	r4, r1

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    parser->npp_path = path;
    1e80:	900a      	str	r0, [sp, #40]	; 0x28
    struct nffs_inode_entry *to_parent;
    struct nffs_inode inode;
    int rc;

    nffs_path_parser_new(&parser, from);
    rc = nffs_path_find(&parser, &from_inode_entry, &from_parent);
    1e82:	a901      	add	r1, sp, #4
    1e84:	a809      	add	r0, sp, #36	; 0x24
    1e86:	aa03      	add	r2, sp, #12
}

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1e88:	9309      	str	r3, [sp, #36]	; 0x24
    parser->npp_path = path;
    parser->npp_off = 0;
    1e8a:	930d      	str	r3, [sp, #52]	; 0x34
    struct nffs_inode_entry *to_parent;
    struct nffs_inode inode;
    int rc;

    nffs_path_parser_new(&parser, from);
    rc = nffs_path_find(&parser, &from_inode_entry, &from_parent);
    1e8c:	f7ff ffa0 	bl	1dd0 <nffs_path_find>
    if (rc != 0) {
    1e90:	2800      	cmp	r0, #0
    1e92:	d13d      	bne.n	1f10 <nffs_path_rename+0x98>
}

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1e94:	9009      	str	r0, [sp, #36]	; 0x24
    parser->npp_path = path;
    parser->npp_off = 0;
    1e96:	900d      	str	r0, [sp, #52]	; 0x34
    if (rc != 0) {
        return rc;
    }

    nffs_path_parser_new(&parser, to);
    rc = nffs_path_find(&parser, &to_inode_entry, &to_parent);
    1e98:	a902      	add	r1, sp, #8
    1e9a:	a809      	add	r0, sp, #36	; 0x24
    1e9c:	aa04      	add	r2, sp, #16

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    parser->npp_path = path;
    1e9e:	940a      	str	r4, [sp, #40]	; 0x28
    if (rc != 0) {
        return rc;
    }

    nffs_path_parser_new(&parser, to);
    rc = nffs_path_find(&parser, &to_inode_entry, &to_parent);
    1ea0:	f7ff ff96 	bl	1dd0 <nffs_path_find>
    switch (rc) {
    1ea4:	b110      	cbz	r0, 1eac <nffs_path_rename+0x34>
    1ea6:	2806      	cmp	r0, #6
    1ea8:	d026      	beq.n	1ef8 <nffs_path_rename+0x80>
    1eaa:	e031      	b.n	1f10 <nffs_path_rename+0x98>
    case 0:
        /* The user is clobbering something with the rename. */
        if (nffs_hash_id_is_dir(from_inode_entry->nie_hash_entry.nhe_id) ^
    1eac:	9b01      	ldr	r3, [sp, #4]
    1eae:	6858      	ldr	r0, [r3, #4]
    1eb0:	f7fe fff6 	bl	ea0 <nffs_hash_id_is_dir>
            nffs_hash_id_is_dir(to_inode_entry->nie_hash_entry.nhe_id)) {
    1eb4:	9b02      	ldr	r3, [sp, #8]
    nffs_path_parser_new(&parser, to);
    rc = nffs_path_find(&parser, &to_inode_entry, &to_parent);
    switch (rc) {
    case 0:
        /* The user is clobbering something with the rename. */
        if (nffs_hash_id_is_dir(from_inode_entry->nie_hash_entry.nhe_id) ^
    1eb6:	4604      	mov	r4, r0
            nffs_hash_id_is_dir(to_inode_entry->nie_hash_entry.nhe_id)) {
    1eb8:	6858      	ldr	r0, [r3, #4]
    1eba:	f7fe fff1 	bl	ea0 <nffs_hash_id_is_dir>
    nffs_path_parser_new(&parser, to);
    rc = nffs_path_find(&parser, &to_inode_entry, &to_parent);
    switch (rc) {
    case 0:
        /* The user is clobbering something with the rename. */
        if (nffs_hash_id_is_dir(from_inode_entry->nie_hash_entry.nhe_id) ^
    1ebe:	4284      	cmp	r4, r0
    1ec0:	d001      	beq.n	1ec6 <nffs_path_rename+0x4e>
            nffs_hash_id_is_dir(to_inode_entry->nie_hash_entry.nhe_id)) {

            /* Cannot clobber one type of file with another. */
            return FS_EINVAL;
    1ec2:	2004      	movs	r0, #4
    1ec4:	e024      	b.n	1f10 <nffs_path_rename+0x98>
        }

        rc = nffs_inode_from_entry(&inode, to_inode_entry);
    1ec6:	a805      	add	r0, sp, #20
    1ec8:	9902      	ldr	r1, [sp, #8]
    1eca:	f7ff fbd5 	bl	1678 <nffs_inode_from_entry>
        if (rc != 0) {
    1ece:	4604      	mov	r4, r0
    1ed0:	b9f0      	cbnz	r0, 1f10 <nffs_path_rename+0x98>

        /*
         * Don't allow renames if the inode has been deleted
         * Side-effect is that we've restored the inode as needed.
         */
        if (nffs_inode_is_deleted(from_inode_entry)) {
    1ed2:	9801      	ldr	r0, [sp, #4]
    1ed4:	f7ff fd70 	bl	19b8 <nffs_inode_is_deleted>
    1ed8:	b120      	cbz	r0, 1ee4 <nffs_path_rename+0x6c>
            assert(0);
    1eda:	480e      	ldr	r0, [pc, #56]	; (1f14 <nffs_path_rename+0x9c>)
    1edc:	f240 1119 	movw	r1, #281	; 0x119
    1ee0:	4622      	mov	r2, r4
    1ee2:	e00e      	b.n	1f02 <nffs_path_rename+0x8a>
            return FS_ENOENT;
        }

        rc = nffs_inode_unlink(&inode);
    1ee4:	a805      	add	r0, sp, #20
    1ee6:	f7ff fba0 	bl	162a <nffs_inode_unlink>
        if (rc != 0) {
    1eea:	b988      	cbnz	r0, 1f10 <nffs_path_rename+0x98>

    default:
        return rc;
    }

    rc = nffs_inode_rename(from_inode_entry, to_parent, parser.npp_token);
    1eec:	9801      	ldr	r0, [sp, #4]
    1eee:	9904      	ldr	r1, [sp, #16]
    1ef0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    1ef2:	f7ff fc6f 	bl	17d4 <nffs_inode_rename>
    1ef6:	e00b      	b.n	1f10 <nffs_path_rename+0x98>
            return rc;
        }
        break;

    case FS_ENOENT:
        assert(to_parent != NULL);
    1ef8:	9a04      	ldr	r2, [sp, #16]
    1efa:	b92a      	cbnz	r2, 1f08 <nffs_path_rename+0x90>
    1efc:	4805      	ldr	r0, [pc, #20]	; (1f14 <nffs_path_rename+0x9c>)
    1efe:	f44f 7192 	mov.w	r1, #292	; 0x124
    1f02:	4613      	mov	r3, r2
    1f04:	f002 fea2 	bl	4c4c <__assert_func>
        if (parser.npp_token_type != NFFS_PATH_TOKEN_LEAF) {
    1f08:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1f0a:	2b02      	cmp	r3, #2
    1f0c:	d1d9      	bne.n	1ec2 <nffs_path_rename+0x4a>
    1f0e:	e7ed      	b.n	1eec <nffs_path_rename+0x74>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    1f10:	b00e      	add	sp, #56	; 0x38
    1f12:	bd10      	pop	{r4, pc}
    1f14:	000062de 	.word	0x000062de

00001f18 <nffs_path_new_dir>:
 *                              FS_ENONT if a required intermediate directory
 *                                  does not exist.
 */
int
nffs_path_new_dir(const char *path, struct nffs_inode_entry **out_inode_entry)
{
    1f18:	b530      	push	{r4, r5, lr}
    1f1a:	b08b      	sub	sp, #44	; 0x2c
    struct nffs_inode_entry *inode_entry;
    struct nffs_inode_entry *parent;
    int rc;

    nffs_path_parser_new(&parser, path);
    rc = nffs_path_find(&parser, &inode_entry, &parent);
    1f1c:	ad03      	add	r5, sp, #12
}

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1f1e:	2300      	movs	r3, #0
 *                              FS_ENONT if a required intermediate directory
 *                                  does not exist.
 */
int
nffs_path_new_dir(const char *path, struct nffs_inode_entry **out_inode_entry)
{
    1f20:	460c      	mov	r4, r1

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    parser->npp_path = path;
    1f22:	9006      	str	r0, [sp, #24]
    struct nffs_inode_entry *inode_entry;
    struct nffs_inode_entry *parent;
    int rc;

    nffs_path_parser_new(&parser, path);
    rc = nffs_path_find(&parser, &inode_entry, &parent);
    1f24:	4629      	mov	r1, r5
    1f26:	a805      	add	r0, sp, #20
    1f28:	aa04      	add	r2, sp, #16
}

void
nffs_path_parser_new(struct nffs_path_parser *parser, const char *path)
{
    parser->npp_token_type = NFFS_PATH_TOKEN_NONE;
    1f2a:	9305      	str	r3, [sp, #20]
    parser->npp_path = path;
    parser->npp_off = 0;
    1f2c:	9309      	str	r3, [sp, #36]	; 0x24
    struct nffs_inode_entry *inode_entry;
    struct nffs_inode_entry *parent;
    int rc;

    nffs_path_parser_new(&parser, path);
    rc = nffs_path_find(&parser, &inode_entry, &parent);
    1f2e:	f7ff ff4f 	bl	1dd0 <nffs_path_find>
    if (rc == 0) {
    1f32:	b198      	cbz	r0, 1f5c <nffs_path_new_dir+0x44>
        return FS_EEXIST;
    }
    if (rc != FS_ENOENT) {
    1f34:	2806      	cmp	r0, #6
    1f36:	d114      	bne.n	1f62 <nffs_path_new_dir+0x4a>
        return rc;
    }
    if (parser.npp_token_type != NFFS_PATH_TOKEN_LEAF || parent == NULL) {
    1f38:	9b05      	ldr	r3, [sp, #20]
    1f3a:	2b02      	cmp	r3, #2
    1f3c:	d111      	bne.n	1f62 <nffs_path_new_dir+0x4a>
    1f3e:	9b04      	ldr	r3, [sp, #16]
    1f40:	b17b      	cbz	r3, 1f62 <nffs_path_new_dir+0x4a>
        return FS_ENOENT;
    }

    rc = nffs_file_new(parent, parser.npp_token, parser.npp_token_len, 1, 
    1f42:	4618      	mov	r0, r3
    1f44:	f89d 2020 	ldrb.w	r2, [sp, #32]
    1f48:	9500      	str	r5, [sp, #0]
    1f4a:	9907      	ldr	r1, [sp, #28]
    1f4c:	2301      	movs	r3, #1
    1f4e:	f7fe fd7b 	bl	a48 <nffs_file_new>
                       &inode_entry);
    if (rc != 0) {
    1f52:	b930      	cbnz	r0, 1f62 <nffs_path_new_dir+0x4a>
        return rc;
    }

    if (out_inode_entry != NULL) {
    1f54:	b124      	cbz	r4, 1f60 <nffs_path_new_dir+0x48>
        *out_inode_entry = inode_entry;
    1f56:	9b03      	ldr	r3, [sp, #12]
    1f58:	6023      	str	r3, [r4, #0]
    1f5a:	e002      	b.n	1f62 <nffs_path_new_dir+0x4a>
    int rc;

    nffs_path_parser_new(&parser, path);
    rc = nffs_path_find(&parser, &inode_entry, &parent);
    if (rc == 0) {
        return FS_EEXIST;
    1f5c:	200b      	movs	r0, #11
    1f5e:	e000      	b.n	1f62 <nffs_path_new_dir+0x4a>

    if (out_inode_entry != NULL) {
        *out_inode_entry = inode_entry;
    }

    return 0;
    1f60:	4620      	mov	r0, r4
}
    1f62:	b00b      	add	sp, #44	; 0x2c
    1f64:	bd30      	pop	{r4, r5, pc}

00001f66 <nffs_restore_dummy_inode>:
 * @return                      0 on success; nonzero on failure.
 */
static int
nffs_restore_dummy_inode(uint32_t id,
                         struct nffs_inode_entry **out_inode_entry)
{
    1f66:	b570      	push	{r4, r5, r6, lr}
    1f68:	4605      	mov	r5, r0
    1f6a:	460e      	mov	r6, r1
    struct nffs_inode_entry *inode_entry;

    inode_entry = nffs_inode_entry_alloc();
    1f6c:	f7ff f8bc 	bl	10e8 <nffs_inode_entry_alloc>
    if (inode_entry == NULL) {
    1f70:	4604      	mov	r4, r0
    1f72:	b190      	cbz	r0, 1f9a <nffs_restore_dummy_inode+0x34>
        return FS_ENOMEM;
    }
    inode_entry->nie_hash_entry.nhe_id = id;
    1f74:	6045      	str	r5, [r0, #4]
    inode_entry->nie_hash_entry.nhe_flash_loc = NFFS_FLASH_LOC_NONE;
    1f76:	2100      	movs	r1, #0
    1f78:	20ff      	movs	r0, #255	; 0xff
    1f7a:	f7fe ff05 	bl	d88 <nffs_flash_loc>
    inode_entry->nie_refcnt = 0;
    1f7e:	2500      	movs	r5, #0
    inode_entry = nffs_inode_entry_alloc();
    if (inode_entry == NULL) {
        return FS_ENOMEM;
    }
    inode_entry->nie_hash_entry.nhe_id = id;
    inode_entry->nie_hash_entry.nhe_flash_loc = NFFS_FLASH_LOC_NONE;
    1f80:	60a0      	str	r0, [r4, #8]
    inode_entry->nie_refcnt = 0;
    inode_entry->nie_last_block_entry = NULL; /* lastblock not available yet */
    nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DUMMY);
    1f82:	2101      	movs	r1, #1
    if (inode_entry == NULL) {
        return FS_ENOMEM;
    }
    inode_entry->nie_hash_entry.nhe_id = id;
    inode_entry->nie_hash_entry.nhe_flash_loc = NFFS_FLASH_LOC_NONE;
    inode_entry->nie_refcnt = 0;
    1f84:	7525      	strb	r5, [r4, #20]
    inode_entry->nie_last_block_entry = NULL; /* lastblock not available yet */
    1f86:	6125      	str	r5, [r4, #16]
    nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DUMMY);
    1f88:	4620      	mov	r0, r4
    1f8a:	f7ff fd25 	bl	19d8 <nffs_inode_setflags>

    nffs_hash_insert(&inode_entry->nie_hash_entry);
    1f8e:	4620      	mov	r0, r4
    1f90:	f7fe fff0 	bl	f74 <nffs_hash_insert>

    *out_inode_entry = inode_entry;
    1f94:	6034      	str	r4, [r6, #0]

    return 0;
    1f96:	4628      	mov	r0, r5
    1f98:	bd70      	pop	{r4, r5, r6, pc}
{
    struct nffs_inode_entry *inode_entry;

    inode_entry = nffs_inode_entry_alloc();
    if (inode_entry == NULL) {
        return FS_ENOMEM;
    1f9a:	2005      	movs	r0, #5
    nffs_hash_insert(&inode_entry->nie_hash_entry);

    *out_inode_entry = inode_entry;

    return 0;
}
    1f9c:	bd70      	pop	{r4, r5, r6, pc}
	...

00001fa0 <nffs_restore_area_contents>:
 *
 * @return                      0 on success; nonzero on failure.
 */
static int
nffs_restore_area_contents(int area_idx)
{
    1fa0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    struct nffs_disk_object disk_object;
    struct nffs_area *area;
    int rc;

    area = nffs_areas + area_idx;
    1fa4:	4bad      	ldr	r3, [pc, #692]	; (225c <nffs_restore_area_contents+0x2bc>)
    1fa6:	681e      	ldr	r6, [r3, #0]
 *
 * @return                      0 on success; nonzero on failure.
 */
static int
nffs_restore_area_contents(int area_idx)
{
    1fa8:	b090      	sub	sp, #64	; 0x40
    1faa:	4607      	mov	r7, r0
    struct nffs_disk_object disk_object;
    struct nffs_area *area;
    int rc;

    area = nffs_areas + area_idx;
    1fac:	eb06 1600 	add.w	r6, r6, r0, lsl #4

    area->na_cur = sizeof (struct nffs_disk_area);
    1fb0:	2318      	movs	r3, #24
    1fb2:	60b3      	str	r3, [r6, #8]
    while (1) {
        rc = nffs_restore_disk_object(area_idx, area->na_cur,  &disk_object);
    1fb4:	f8d6 8008 	ldr.w	r8, [r6, #8]
nffs_restore_disk_object(int area_idx, uint32_t area_offset,
                         struct nffs_disk_object *out_disk_object)
{
    int rc;

    rc = nffs_flash_read(area_idx, area_offset,
    1fb8:	b2fc      	uxtb	r4, r7
    1fba:	4620      	mov	r0, r4
    1fbc:	4641      	mov	r1, r8
    1fbe:	aa0b      	add	r2, sp, #44	; 0x2c
    1fc0:	2314      	movs	r3, #20
    1fc2:	f7fe fe6b 	bl	c9c <nffs_flash_read>
                         &out_disk_object->ndo_un_obj,
                         sizeof(out_disk_object->ndo_un_obj));
    if (rc != 0) {
    1fc6:	b9f8      	cbnz	r0, 2008 <nffs_restore_area_contents+0x68>
        return rc;
    }

    if (nffs_hash_id_is_inode(out_disk_object->ndo_disk_inode.ndi_id)) {
    1fc8:	980b      	ldr	r0, [sp, #44]	; 0x2c
    1fca:	f7fe ff77 	bl	ebc <nffs_hash_id_is_inode>
    1fce:	b108      	cbz	r0, 1fd4 <nffs_restore_area_contents+0x34>
        out_disk_object->ndo_type = NFFS_OBJECT_TYPE_INODE;
    1fd0:	2301      	movs	r3, #1
    1fd2:	e004      	b.n	1fde <nffs_restore_area_contents+0x3e>

    } else if (nffs_hash_id_is_block(out_disk_object->ndo_disk_block.ndb_id)) {
    1fd4:	980b      	ldr	r0, [sp, #44]	; 0x2c
    1fd6:	f7fe ff75 	bl	ec4 <nffs_hash_id_is_block>
    1fda:	b158      	cbz	r0, 1ff4 <nffs_restore_area_contents+0x54>
        out_disk_object->ndo_type = NFFS_OBJECT_TYPE_BLOCK;
    1fdc:	2302      	movs	r3, #2
    1fde:	9308      	str	r3, [sp, #32]
static int
nffs_restore_object(const struct nffs_disk_object *disk_object)
{
    int rc;

    switch (disk_object->ndo_type) {
    1fe0:	f8dd a020 	ldr.w	sl, [sp, #32]

    } else {
        return FS_ECORRUPT;
    }

    out_disk_object->ndo_area_idx = area_idx;
    1fe4:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
static int
nffs_restore_object(const struct nffs_disk_object *disk_object)
{
    int rc;

    switch (disk_object->ndo_type) {
    1fe8:	f1ba 0f01 	cmp.w	sl, #1
    } else {
        return FS_ECORRUPT;
    }

    out_disk_object->ndo_area_idx = area_idx;
    out_disk_object->ndo_offset = area_offset;
    1fec:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
static int
nffs_restore_object(const struct nffs_disk_object *disk_object)
{
    int rc;

    switch (disk_object->ndo_type) {
    1ff0:	d105      	bne.n	1ffe <nffs_restore_area_contents+0x5e>
    1ff2:	e013      	b.n	201c <nffs_restore_area_contents+0x7c>
        out_disk_object->ndo_type = NFFS_OBJECT_TYPE_INODE;

    } else if (nffs_hash_id_is_block(out_disk_object->ndo_disk_block.ndb_id)) {
        out_disk_object->ndo_type = NFFS_OBJECT_TYPE_BLOCK;

    } else if (out_disk_object->ndo_disk_block.ndb_id == NFFS_ID_NONE) {
    1ff4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1ff6:	3301      	adds	r3, #1
    1ff8:	f040 818b 	bne.w	2312 <nffs_restore_area_contents+0x372>
    1ffc:	e1f7      	b.n	23ee <nffs_restore_area_contents+0x44e>
static int
nffs_restore_object(const struct nffs_disk_object *disk_object)
{
    int rc;

    switch (disk_object->ndo_type) {
    1ffe:	f1ba 0f02 	cmp.w	sl, #2
    2002:	f000 80e1 	beq.w	21c8 <nffs_restore_area_contents+0x228>
    2006:	e171      	b.n	22ec <nffs_restore_area_contents+0x34c>
    area = nffs_areas + area_idx;

    area->na_cur = sizeof (struct nffs_disk_area);
    while (1) {
        rc = nffs_restore_disk_object(area_idx, area->na_cur,  &disk_object);
        switch (rc) {
    2008:	2803      	cmp	r0, #3
    200a:	f000 8185 	beq.w	2318 <nffs_restore_area_contents+0x378>
    200e:	2807      	cmp	r0, #7
    2010:	f000 8182 	beq.w	2318 <nffs_restore_area_contents+0x378>
    2014:	2801      	cmp	r0, #1
    2016:	f040 81ea 	bne.w	23ee <nffs_restore_area_contents+0x44e>
    201a:	e17a      	b.n	2312 <nffs_restore_area_contents+0x372>
{
    int rc;

    switch (disk_object->ndo_type) {
    case NFFS_OBJECT_TYPE_INODE:
        rc = nffs_restore_inode(&disk_object->ndo_disk_inode,
    201c:	f89d 9024 	ldrb.w	r9, [sp, #36]	; 0x24
                   uint32_t area_offset)
{
    struct nffs_inode_entry *inode_entry;
    struct nffs_inode_entry *parent;
    struct nffs_inode inode;
    struct nffs_hash_entry *lastblock_entry = NULL;
    2020:	2300      	movs	r3, #0
    int rc;

    new_inode = 0;

    /* Check the inode's CRC.  If the inode is corrupt, discard it. */
    rc = nffs_crc_disk_inode_validate(disk_inode, area_idx, area_offset);
    2022:	a80b      	add	r0, sp, #44	; 0x2c
    2024:	4649      	mov	r1, r9
    2026:	4642      	mov	r2, r8
                   uint32_t area_offset)
{
    struct nffs_inode_entry *inode_entry;
    struct nffs_inode_entry *parent;
    struct nffs_inode inode;
    struct nffs_hash_entry *lastblock_entry = NULL;
    2028:	9302      	str	r3, [sp, #8]
    int rc;

    new_inode = 0;

    /* Check the inode's CRC.  If the inode is corrupt, discard it. */
    rc = nffs_crc_disk_inode_validate(disk_inode, area_idx, area_offset);
    202a:	f000 ff8d 	bl	2f48 <nffs_crc_disk_inode_validate>
    if (rc != 0) {
    202e:	4605      	mov	r5, r0
    2030:	2800      	cmp	r0, #0
    2032:	f040 8159 	bne.w	22e8 <nffs_restore_area_contents+0x348>
        goto err;
    }

    inode_entry = nffs_hash_find_inode(disk_inode->ndi_id);
    2036:	980b      	ldr	r0, [sp, #44]	; 0x2c
    2038:	f7fe ff5e 	bl	ef8 <nffs_hash_find_inode>

    /*
     * Inode has already been restored. Determine whether this version
     * from disk should replace the previous version referenced in RAM.
     */
    if (inode_entry != NULL) {
    203c:	4604      	mov	r4, r0
    203e:	2800      	cmp	r0, #0
    2040:	f000 8087 	beq.w	2152 <nffs_restore_area_contents+0x1b2>

        if (disk_inode->ndi_flags & NFFS_INODE_FLAG_DELETED) {
    2044:	f99d 303c 	ldrsb.w	r3, [sp, #60]	; 0x3c
    2048:	2b00      	cmp	r3, #0
    204a:	da02      	bge.n	2052 <nffs_restore_area_contents+0xb2>
            /*
             * Restore this inode even though deleted on disk
             * so the additional restored blocks have a place to go
             */
            NFFS_LOG(DEBUG, "restoring deleted inode %x\n", disk_inode->ndi_id);
            nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DELETED);
    204c:	2180      	movs	r1, #128	; 0x80
    204e:	f7ff fcc3 	bl	19d8 <nffs_inode_setflags>
                                 int *out_should_replace)
{
    struct nffs_inode old_inode;
    int rc;

    assert(old_inode_entry->nie_hash_entry.nhe_id == disk_inode->ndi_id);
    2052:	6862      	ldr	r2, [r4, #4]
    2054:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2056:	429a      	cmp	r2, r3
    2058:	d003      	beq.n	2062 <nffs_restore_area_contents+0xc2>
    205a:	4881      	ldr	r0, [pc, #516]	; (2260 <nffs_restore_area_contents+0x2c0>)
    205c:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
    2060:	e155      	b.n	230e <nffs_restore_area_contents+0x36e>


    if (nffs_inode_is_dummy(old_inode_entry)) {
    2062:	4620      	mov	r0, r4
    2064:	f7ff faee 	bl	1644 <nffs_inode_is_dummy>
    2068:	b9a0      	cbnz	r0, 2094 <nffs_restore_area_contents+0xf4>
    }

    /*
     * inode is known to be obsolete and needs to be replaced no matter what
     */
    if (nffs_inode_getflags(old_inode_entry, NFFS_INODE_FLAG_OBSOLETE)) {
    206a:	4620      	mov	r0, r4
    206c:	2110      	movs	r1, #16
    206e:	f7ff fcbe 	bl	19ee <nffs_inode_getflags>
    2072:	b978      	cbnz	r0, 2094 <nffs_restore_area_contents+0xf4>
        NFFS_LOG(DEBUG, "inode_gets_replaced obsolete\n");
        *out_should_replace = 2;
        return 0;
    }

    rc = nffs_inode_from_entry(&old_inode, old_inode_entry);
    2074:	a803      	add	r0, sp, #12
    2076:	4621      	mov	r1, r4
    2078:	f7ff fafe 	bl	1678 <nffs_inode_from_entry>
    if (rc != 0) {
    207c:	2800      	cmp	r0, #0
    207e:	f040 81ad 	bne.w	23dc <nffs_restore_area_contents+0x43c>
        *out_should_replace = 0;
        return rc;
    }

    if (old_inode.ni_seq < disk_inode->ndi_seq) {
    2082:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    2086:	9a04      	ldr	r2, [sp, #16]
    2088:	429a      	cmp	r2, r3
    208a:	d303      	bcc.n	2094 <nffs_restore_area_contents+0xf4>
        NFFS_LOG(DEBUG, "inode_gets_replaced seq\n");
        *out_should_replace = 3;
        return 0;
    }

    if (old_inode.ni_seq == disk_inode->ndi_seq) {
    208c:	f040 808d 	bne.w	21aa <nffs_restore_area_contents+0x20a>
        /* This is a duplicate of a previously-read inode.  This should never
         * happen.
         */
        *out_should_replace = 0;
        return FS_EEXIST;
    2090:	200b      	movs	r0, #11
    2092:	e1a3      	b.n	23dc <nffs_restore_area_contents+0x43c>
        if (rc != 0) {
            goto err;
        }

        if (do_add) { /* replace in this case */
            if (!nffs_inode_is_dummy(inode_entry)) {
    2094:	4620      	mov	r0, r4
    2096:	f7ff fad5 	bl	1644 <nffs_inode_is_dummy>
    209a:	bb18      	cbnz	r0, 20e4 <nffs_restore_area_contents+0x144>
                /*
                 * if it's not a dummy, read block from flash
                 */
                rc = nffs_inode_from_entry(&inode, inode_entry);
    209c:	a803      	add	r0, sp, #12
    209e:	4621      	mov	r1, r4
    20a0:	f7ff faea 	bl	1678 <nffs_inode_from_entry>
                if (rc != 0) {
    20a4:	2800      	cmp	r0, #0
    20a6:	f040 8199 	bne.w	23dc <nffs_restore_area_contents+0x43c>
                }

                /*
                 * inode is known to be obsolete
                 */
                if (nffs_inode_getflags(inode_entry, 
    20aa:	4620      	mov	r0, r4
    20ac:	2110      	movs	r1, #16
    20ae:	f7ff fc9e 	bl	19ee <nffs_inode_getflags>
    20b2:	b118      	cbz	r0, 20bc <nffs_restore_area_contents+0x11c>
                                        NFFS_INODE_FLAG_OBSOLETE)) {
                    nffs_inode_unsetflags(inode_entry,
    20b4:	4620      	mov	r0, r4
    20b6:	2110      	movs	r1, #16
    20b8:	f7ff fc93 	bl	19e2 <nffs_inode_unsetflags>
                                          NFFS_INODE_FLAG_OBSOLETE);
                }

                if (inode.ni_parent != NULL) {
    20bc:	9b05      	ldr	r3, [sp, #20]
    20be:	b113      	cbz	r3, 20c6 <nffs_restore_area_contents+0x126>
                    nffs_inode_remove_child(&inode);
    20c0:	a803      	add	r0, sp, #12
    20c2:	f7ff f94f 	bl	1364 <nffs_inode_remove_child>
                 * If the parent is NULL, this inode has been deleted. (old)
                 * XXX if we could count on delete records for every inode,
                 * we wouldn't need to check for the root directory looking
                 * like a delete record because of it's parent ID.
                 */
                if (inode_entry->nie_hash_entry.nhe_id != NFFS_ID_ROOT_DIR) {
    20c6:	6863      	ldr	r3, [r4, #4]
    20c8:	2b00      	cmp	r3, #0
    20ca:	d03a      	beq.n	2142 <nffs_restore_area_contents+0x1a2>
                    if (disk_inode->ndi_flags & NFFS_INODE_FLAG_DELETED ||
    20cc:	f99d 303c 	ldrsb.w	r3, [sp, #60]	; 0x3c
    20d0:	2b00      	cmp	r3, #0
    20d2:	db02      	blt.n	20da <nffs_restore_area_contents+0x13a>
    20d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    20d6:	3301      	adds	r3, #1
    20d8:	d133      	bne.n	2142 <nffs_restore_area_contents+0x1a2>
                        disk_inode->ndi_parent_id == NFFS_ID_NONE) {

                        nffs_inode_setflags(inode_entry,
    20da:	4620      	mov	r0, r4
    20dc:	2180      	movs	r1, #128	; 0x80
    20de:	f7ff fc7b 	bl	19d8 <nffs_inode_setflags>
    20e2:	e02e      	b.n	2142 <nffs_restore_area_contents+0x1a2>
                 */

                /* If it's a directory, it was added as a parent to
                 * one of it's children who were restored first.
                 */
                if (nffs_inode_getflags(inode_entry, 
    20e4:	4620      	mov	r0, r4
    20e6:	2102      	movs	r1, #2
    20e8:	f7ff fc81 	bl	19ee <nffs_inode_getflags>
    20ec:	b170      	cbz	r0, 210c <nffs_restore_area_contents+0x16c>
                                         NFFS_INODE_FLAG_DUMMYPARENT)) {
                    assert(nffs_hash_id_is_dir(inode_entry->nie_hash_entry.nhe_id));
    20ee:	6860      	ldr	r0, [r4, #4]
    20f0:	f7fe fed6 	bl	ea0 <nffs_hash_id_is_dir>
    20f4:	4602      	mov	r2, r0
    20f6:	b928      	cbnz	r0, 2104 <nffs_restore_area_contents+0x164>
    20f8:	4859      	ldr	r0, [pc, #356]	; (2260 <nffs_restore_area_contents+0x2c0>)
    20fa:	f44f 710f 	mov.w	r1, #572	; 0x23c
    20fe:	4613      	mov	r3, r2
    2100:	f002 fda4 	bl	4c4c <__assert_func>
                    nffs_inode_unsetflags(inode_entry, 
    2104:	4620      	mov	r0, r4
    2106:	2102      	movs	r1, #2
    2108:	f7ff fc6b 	bl	19e2 <nffs_inode_unsetflags>
                }

                /*
                 * If it's a file, it was added to store a lastblock
                 */
                if (nffs_inode_getflags(inode_entry, 
    210c:	4620      	mov	r0, r4
    210e:	2108      	movs	r1, #8
    2110:	f7ff fc6d 	bl	19ee <nffs_inode_getflags>
    2114:	b160      	cbz	r0, 2130 <nffs_restore_area_contents+0x190>
                                         NFFS_INODE_FLAG_DUMMYINOBLK)) {
                    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));
    2116:	6860      	ldr	r0, [r4, #4]
    2118:	f7fe fec8 	bl	eac <nffs_hash_id_is_file>
    211c:	4602      	mov	r2, r0
    211e:	b918      	cbnz	r0, 2128 <nffs_restore_area_contents+0x188>
    2120:	484f      	ldr	r0, [pc, #316]	; (2260 <nffs_restore_area_contents+0x2c0>)
    2122:	f240 2146 	movw	r1, #582	; 0x246
    2126:	e7ea      	b.n	20fe <nffs_restore_area_contents+0x15e>
                    nffs_inode_unsetflags(inode_entry, 
    2128:	4620      	mov	r0, r4
    212a:	2108      	movs	r1, #8
    212c:	f7ff fc59 	bl	19e2 <nffs_inode_unsetflags>
                }

                /*
                 * Also, since it's a dummy, clear this flag too
                 */
                if (nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DUMMY)) {
    2130:	4620      	mov	r0, r4
    2132:	2101      	movs	r1, #1
    2134:	f7ff fc5b 	bl	19ee <nffs_inode_getflags>
    2138:	b118      	cbz	r0, 2142 <nffs_restore_area_contents+0x1a2>
                    nffs_inode_unsetflags(inode_entry, NFFS_INODE_FLAG_DUMMY);
    213a:	4620      	mov	r0, r4
    213c:	2101      	movs	r1, #1
    213e:	f7ff fc50 	bl	19e2 <nffs_inode_unsetflags>
 
            /*
             * Update location to reference new location in flash
             */
            inode_entry->nie_hash_entry.nhe_flash_loc =
                                    nffs_flash_loc(area_idx, area_offset);
    2142:	4641      	mov	r1, r8
    2144:	4648      	mov	r0, r9
    2146:	f7fe fe1f 	bl	d88 <nffs_flash_loc>
    struct nffs_hash_entry *lastblock_entry = NULL;
    int new_inode;
    int do_add;
    int rc;

    new_inode = 0;
    214a:	f04f 0800 	mov.w	r8, #0
            }
 
            /*
             * Update location to reference new location in flash
             */
            inode_entry->nie_hash_entry.nhe_flash_loc =
    214e:	60a0      	str	r0, [r4, #8]
    2150:	e011      	b.n	2176 <nffs_restore_area_contents+0x1d6>
                                    nffs_flash_loc(area_idx, area_offset);
        }
        
    } else {
        inode_entry = nffs_inode_entry_alloc();
    2152:	f7fe ffc9 	bl	10e8 <nffs_inode_entry_alloc>
        if (inode_entry == NULL) {
    2156:	4604      	mov	r4, r0
    2158:	2800      	cmp	r0, #0
    215a:	f000 80c7 	beq.w	22ec <nffs_restore_area_contents+0x34c>
            goto err;
        }
        new_inode = 1;
        do_add = 1;

        inode_entry->nie_hash_entry.nhe_id = disk_inode->ndi_id;
    215e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2160:	6043      	str	r3, [r0, #4]
        inode_entry->nie_hash_entry.nhe_flash_loc =
                              nffs_flash_loc(area_idx, area_offset);
    2162:	4641      	mov	r1, r8
    2164:	4648      	mov	r0, r9
    2166:	f7fe fe0f 	bl	d88 <nffs_flash_loc>
        inode_entry->nie_last_block_entry = NULL; /* for now */
    216a:	6125      	str	r5, [r4, #16]
        }
        new_inode = 1;
        do_add = 1;

        inode_entry->nie_hash_entry.nhe_id = disk_inode->ndi_id;
        inode_entry->nie_hash_entry.nhe_flash_loc =
    216c:	60a0      	str	r0, [r4, #8]
                              nffs_flash_loc(area_idx, area_offset);
        inode_entry->nie_last_block_entry = NULL; /* for now */

        nffs_hash_insert(&inode_entry->nie_hash_entry);
    216e:	4620      	mov	r0, r4
    2170:	f7fe ff00 	bl	f74 <nffs_hash_insert>
        inode_entry = nffs_inode_entry_alloc();
        if (inode_entry == NULL) {
            rc = FS_ENOMEM;
            goto err;
        }
        new_inode = 1;
    2174:	46d0      	mov	r8, sl
     * inode object has been restored and the entry is in the hash
     * Check whether the lastblock and parent have also been restored
     * and link up or allocate dummy entries as appropriate.
     */
    if (do_add) {
        inode_entry->nie_refcnt = 1;
    2176:	2301      	movs	r3, #1
    2178:	7523      	strb	r3, [r4, #20]

        if (disk_inode->ndi_flags & NFFS_INODE_FLAG_DELETED) {
    217a:	f99d 303c 	ldrsb.w	r3, [sp, #60]	; 0x3c
    217e:	2b00      	cmp	r3, #0
    2180:	da03      	bge.n	218a <nffs_restore_area_contents+0x1ea>
            /*
             * Restore this inode even though deleted on disk
             * so the additional restored blocks have a place to go
             */
            NFFS_LOG(DEBUG, "restoring deleted inode %x\n", disk_inode->ndi_id);
            nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DELETED);
    2182:	4620      	mov	r0, r4
    2184:	2180      	movs	r1, #128	; 0x80
    2186:	f7ff fc27 	bl	19d8 <nffs_inode_setflags>
        /*
         * Inode has a lastblock on disk.
         * Add reference to last block entry if in hash table
         * otherwise add a dummy block entry for later update
         */
        if (disk_inode->ndi_lastblock_id != NFFS_ID_NONE &&
    218a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    218c:	3301      	adds	r3, #1
    218e:	f040 80c5 	bne.w	231c <nffs_restore_area_contents+0x37c>
                    nffs_hash_next_block_id = lastblock_entry->nhe_id + 1;
                }
            }
        }

        if (disk_inode->ndi_parent_id != NFFS_ID_NONE) {
    2192:	980c      	ldr	r0, [sp, #48]	; 0x30
    2194:	1c43      	adds	r3, r0, #1
    2196:	f040 8101 	bne.w	239c <nffs_restore_area_contents+0x3fc>
            if (rc != 0) {
                goto err;
            }
        } 

        if (inode_entry->nie_hash_entry.nhe_id == NFFS_ID_ROOT_DIR) {
    219a:	6863      	ldr	r3, [r4, #4]
    219c:	b92b      	cbnz	r3, 21aa <nffs_restore_area_contents+0x20a>
            nffs_root_dir = inode_entry;
    219e:	4b31      	ldr	r3, [pc, #196]	; (2264 <nffs_restore_area_contents+0x2c4>)
            nffs_inode_setflags(nffs_root_dir, NFFS_INODE_FLAG_INTREE);
    21a0:	4620      	mov	r0, r4
    21a2:	2120      	movs	r1, #32
                goto err;
            }
        } 

        if (inode_entry->nie_hash_entry.nhe_id == NFFS_ID_ROOT_DIR) {
            nffs_root_dir = inode_entry;
    21a4:	601c      	str	r4, [r3, #0]
            nffs_inode_setflags(nffs_root_dir, NFFS_INODE_FLAG_INTREE);
    21a6:	f7ff fc17 	bl	19d8 <nffs_inode_setflags>
        }
    }

    if (nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
    21aa:	6860      	ldr	r0, [r4, #4]
    21ac:	f7fe fe7e 	bl	eac <nffs_hash_id_is_file>
    21b0:	6863      	ldr	r3, [r4, #4]
    21b2:	b108      	cbz	r0, 21b8 <nffs_restore_area_contents+0x218>
        NFFS_LOG(DEBUG, "restoring file; id=0x%08x\n",
                 inode_entry->nie_hash_entry.nhe_id);
        if (inode_entry->nie_hash_entry.nhe_id >= nffs_hash_next_file_id) {
    21b4:	4a2c      	ldr	r2, [pc, #176]	; (2268 <nffs_restore_area_contents+0x2c8>)
    21b6:	e000      	b.n	21ba <nffs_restore_area_contents+0x21a>
            nffs_hash_next_file_id = inode_entry->nie_hash_entry.nhe_id + 1;
        }
    } else {
        NFFS_LOG(DEBUG, "restoring dir; id=0x%08x\n",
                 inode_entry->nie_hash_entry.nhe_id);
        if (inode_entry->nie_hash_entry.nhe_id >= nffs_hash_next_dir_id) {
    21b8:	4a2c      	ldr	r2, [pc, #176]	; (226c <nffs_restore_area_contents+0x2cc>)
    21ba:	6811      	ldr	r1, [r2, #0]
    21bc:	428b      	cmp	r3, r1
    21be:	f0c0 8095 	bcc.w	22ec <nffs_restore_area_contents+0x34c>
            nffs_hash_next_dir_id = inode_entry->nie_hash_entry.nhe_id + 1;
    21c2:	3301      	adds	r3, #1
    21c4:	6013      	str	r3, [r2, #0]
    21c6:	e091      	b.n	22ec <nffs_restore_area_contents+0x34c>
                                disk_object->ndo_area_idx,
                                disk_object->ndo_offset);
        break;

    case NFFS_OBJECT_TYPE_BLOCK:
        rc = nffs_restore_block(&disk_object->ndo_disk_block,
    21c8:	f89d 9024 	ldrb.w	r9, [sp, #36]	; 0x24
    new_block = 0;

    /* Check the block's CRC.  If the block is corrupt, discard it.  If this
     * block would have superseded another, the old block becomes current.
     */
    rc = nffs_crc_disk_block_validate(disk_block, area_idx, area_offset);
    21cc:	a80b      	add	r0, sp, #44	; 0x2c
    21ce:	4649      	mov	r1, r9
    21d0:	4642      	mov	r2, r8
    21d2:	f000 fe94 	bl	2efe <nffs_crc_disk_block_validate>
    if (rc != 0) {
    21d6:	4605      	mov	r5, r0
    21d8:	2800      	cmp	r0, #0
    21da:	f040 8085 	bne.w	22e8 <nffs_restore_area_contents+0x348>
        goto err;
    }

    entry = nffs_hash_find_block(disk_block->ndb_id);
    21de:	980b      	ldr	r0, [sp, #44]	; 0x2c
    21e0:	f7fe fe9c 	bl	f1c <nffs_hash_find_block>
    if (entry != NULL) {
    21e4:	4604      	mov	r4, r0
    21e6:	2800      	cmp	r0, #0
    21e8:	d042      	beq.n	2270 <nffs_restore_area_contents+0x2d0>

        rc = nffs_block_from_hash_entry_no_ptrs(&block, entry);
    21ea:	a803      	add	r0, sp, #12
    21ec:	4621      	mov	r1, r4
    21ee:	f000 fd9f 	bl	2d30 <nffs_block_from_hash_entry_no_ptrs>
        if (rc != 0 && rc != FS_ENOENT) {
    21f2:	b110      	cbz	r0, 21fa <nffs_restore_area_contents+0x25a>
    21f4:	2806      	cmp	r0, #6
    21f6:	f040 80f1 	bne.w	23dc <nffs_restore_area_contents+0x43c>
        /*
         * If the old block reference is for a 'dummy' block, it was added
         * because the owning inode's lastblock was not yet restored.
         * Update the block hash entry and inode to reference the entry.
         */
        if (nffs_block_is_dummy(entry)) {
    21fa:	4620      	mov	r0, r4
    21fc:	f000 fddf 	bl	2dbe <nffs_block_is_dummy>
    2200:	b1a0      	cbz	r0, 222c <nffs_restore_area_contents+0x28c>

            assert(entry->nhe_id == disk_block->ndb_id);
    2202:	6862      	ldr	r2, [r4, #4]
    2204:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2206:	429a      	cmp	r2, r3
    2208:	d003      	beq.n	2212 <nffs_restore_area_contents+0x272>
    220a:	4815      	ldr	r0, [pc, #84]	; (2260 <nffs_restore_area_contents+0x2c0>)
    220c:	f44f 7150 	mov.w	r1, #832	; 0x340
    2210:	e07d      	b.n	230e <nffs_restore_area_contents+0x36e>

            /*
             * Entry is no longer dummy as it references the correct location
             */
            entry->nhe_flash_loc = nffs_flash_loc(area_idx, area_offset);
    2212:	4641      	mov	r1, r8
    2214:	4648      	mov	r0, r9
    2216:	f7fe fdb7 	bl	d88 <nffs_flash_loc>
    221a:	60a0      	str	r0, [r4, #8]

            inode_entry = nffs_hash_find_inode(disk_block->ndb_inode_id);
    221c:	980c      	ldr	r0, [sp, #48]	; 0x30
    221e:	f7fe fe6b 	bl	ef8 <nffs_hash_find_inode>
    2222:	9002      	str	r0, [sp, #8]

            /*
             * Turn off flags in previously restored inode recording the
             * allocation of a dummy block
             */
            if (inode_entry) {
    2224:	b110      	cbz	r0, 222c <nffs_restore_area_contents+0x28c>
                nffs_inode_unsetflags(inode_entry, NFFS_INODE_FLAG_DUMMYLSTBLK);
    2226:	2104      	movs	r1, #4
    2228:	f7ff fbdb 	bl	19e2 <nffs_inode_unsetflags>
static int
nffs_restore_block_gets_replaced(const struct nffs_block *old_block,
                                 const struct nffs_disk_block *disk_block,
                                 int *out_should_replace)
{
    assert(old_block->nb_hash_entry->nhe_id == disk_block->ndb_id);
    222c:	9803      	ldr	r0, [sp, #12]
    222e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2230:	6842      	ldr	r2, [r0, #4]
    2232:	429a      	cmp	r2, r3
    2234:	d003      	beq.n	223e <nffs_restore_area_contents+0x29e>
    2236:	480a      	ldr	r0, [pc, #40]	; (2260 <nffs_restore_area_contents+0x2c0>)
    2238:	f240 21fa 	movw	r1, #762	; 0x2fa
    223c:	e067      	b.n	230e <nffs_restore_area_contents+0x36e>

    if (nffs_block_is_dummy(old_block->nb_hash_entry)) {
    223e:	f000 fdbe 	bl	2dbe <nffs_block_is_dummy>
    2242:	4605      	mov	r5, r0
    2244:	b118      	cbz	r0, 224e <nffs_restore_area_contents+0x2ae>
        assert(0);
    2246:	4806      	ldr	r0, [pc, #24]	; (2260 <nffs_restore_area_contents+0x2c0>)
    2248:	f240 21fd 	movw	r1, #765	; 0x2fd
    224c:	e05f      	b.n	230e <nffs_restore_area_contents+0x36e>
        *out_should_replace = 1;
        return 0;
    }

    if (old_block->nb_seq < disk_block->ndb_seq) {
    224e:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    2252:	9a04      	ldr	r2, [sp, #16]
    2254:	429a      	cmp	r2, r3
    2256:	d249      	bcs.n	22ec <nffs_restore_area_contents+0x34c>
    2258:	e0c2      	b.n	23e0 <nffs_restore_area_contents+0x440>
    225a:	bf00      	nop
    225c:	20000b40 	.word	0x20000b40
    2260:	000062ea 	.word	0x000062ea
    2264:	20000b78 	.word	0x20000b78
    2268:	20000ca8 	.word	0x20000ca8
    226c:	20000c9c 	.word	0x20000c9c
         * update the existing hash entry to reference the new flash location
         */
        entry->nhe_flash_loc = nffs_flash_loc(area_idx, area_offset);

    } else {
        entry = nffs_block_entry_alloc();
    2270:	f000 fcd8 	bl	2c24 <nffs_block_entry_alloc>
        if (entry == NULL) {
    2274:	4604      	mov	r4, r0
    2276:	2800      	cmp	r0, #0
    2278:	d038      	beq.n	22ec <nffs_restore_area_contents+0x34c>
            rc = FS_ENOMEM;
            goto err;
        }
        new_block = 1;
        entry->nhe_id = disk_block->ndb_id;
    227a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    227c:	6043      	str	r3, [r0, #4]
        entry->nhe_flash_loc = nffs_flash_loc(area_idx, area_offset);
    227e:	4641      	mov	r1, r8
    2280:	4648      	mov	r0, r9
    2282:	f7fe fd81 	bl	d88 <nffs_flash_loc>
    2286:	60a0      	str	r0, [r4, #8]

        /* The block is ready to be inserted into the hash. */

        nffs_hash_insert(entry);
    2288:	4620      	mov	r0, r4
    228a:	f7fe fe73 	bl	f74 <nffs_hash_insert>

        if (disk_block->ndb_id >= nffs_hash_next_block_id) {
    228e:	4a59      	ldr	r2, [pc, #356]	; (23f4 <nffs_restore_area_contents+0x454>)
    2290:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2292:	6811      	ldr	r1, [r2, #0]
    2294:	428b      	cmp	r3, r1
            nffs_hash_next_block_id = disk_block->ndb_id + 1;
    2296:	bf24      	itt	cs
    2298:	3301      	addcs	r3, #1
    229a:	6013      	strcs	r3, [r2, #0]
        entry = nffs_block_entry_alloc();
        if (entry == NULL) {
            rc = FS_ENOMEM;
            goto err;
        }
        new_block = 1;
    229c:	f04f 0801 	mov.w	r8, #1
    }

    /* Make sure the maximum block data size is not set lower than the size of
     * an existing block.
     */
    if (disk_block->ndb_data_len > nffs_restore_largest_block_data_len) {
    22a0:	4b55      	ldr	r3, [pc, #340]	; (23f8 <nffs_restore_area_contents+0x458>)
    22a2:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
    22a6:	8819      	ldrh	r1, [r3, #0]
    NFFS_LOG(DEBUG, "restoring block; id=0x%08x seq=%u inode_id=%u prev_id=%u "
             "data_len=%u\n", disk_block->ndb_id, disk_block->ndb_seq,
             disk_block->ndb_inode_id, disk_block->ndb_prev_id,
             disk_block->ndb_data_len);

    inode_entry = nffs_hash_find_inode(disk_block->ndb_inode_id);
    22a8:	980c      	ldr	r0, [sp, #48]	; 0x30
    }

    /* Make sure the maximum block data size is not set lower than the size of
     * an existing block.
     */
    if (disk_block->ndb_data_len > nffs_restore_largest_block_data_len) {
    22aa:	4291      	cmp	r1, r2
        nffs_restore_largest_block_data_len = disk_block->ndb_data_len;
    22ac:	bf38      	it	cc
    22ae:	801a      	strhcc	r2, [r3, #0]
    NFFS_LOG(DEBUG, "restoring block; id=0x%08x seq=%u inode_id=%u prev_id=%u "
             "data_len=%u\n", disk_block->ndb_id, disk_block->ndb_seq,
             disk_block->ndb_inode_id, disk_block->ndb_prev_id,
             disk_block->ndb_data_len);

    inode_entry = nffs_hash_find_inode(disk_block->ndb_inode_id);
    22b0:	f7fe fe22 	bl	ef8 <nffs_hash_find_inode>
    22b4:	9002      	str	r0, [sp, #8]

    if (inode_entry == NULL) {
    22b6:	b960      	cbnz	r0, 22d2 <nffs_restore_area_contents+0x332>
        /*
         * Owning inode not yet restored.
         * Allocate a dummy inode which temporarily owns this block.
         * It is not yet linked to a parent.
         */
        rc = nffs_restore_dummy_inode(disk_block->ndb_inode_id, &inode_entry);
    22b8:	980c      	ldr	r0, [sp, #48]	; 0x30
    22ba:	a902      	add	r1, sp, #8
    22bc:	f7ff fe53 	bl	1f66 <nffs_restore_dummy_inode>
        if (rc != 0) {
    22c0:	4605      	mov	r5, r0
    22c2:	b958      	cbnz	r0, 22dc <nffs_restore_area_contents+0x33c>
        }
        /*
         * Record that this inode was created because a block was restored
         * before the inode
         */
        nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DUMMYINOBLK);
    22c4:	9802      	ldr	r0, [sp, #8]
    22c6:	2108      	movs	r1, #8
    22c8:	f7ff fb86 	bl	19d8 <nffs_inode_setflags>
        inode_entry->nie_last_block_entry = entry;
    22cc:	9b02      	ldr	r3, [sp, #8]
    22ce:	611c      	str	r4, [r3, #16]
    22d0:	e00c      	b.n	22ec <nffs_restore_area_contents+0x34c>
    } else {
        if (nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DELETED)) {
    22d2:	2180      	movs	r1, #128	; 0x80
    22d4:	f7ff fb8b 	bl	19ee <nffs_inode_getflags>
    22d8:	b140      	cbz	r0, 22ec <nffs_restore_area_contents+0x34c>
            /*
             * don't restore blocks for deleted inodes
             */
            rc = FS_ENOENT;
    22da:	2506      	movs	r5, #6
    }

    return 0;

err:
    if (new_block) {
    22dc:	f1b8 0f00 	cmp.w	r8, #0
    22e0:	d002      	beq.n	22e8 <nffs_restore_area_contents+0x348>
        nffs_block_entry_free(entry);
    22e2:	4620      	mov	r0, r4
    22e4:	f000 fcac 	bl	2c40 <nffs_block_entry_free>
             * If the restore fails the CRC check, the object length field
             * can't be trusted so just start looking for the next valid
             * object in the flash area.
             * XXX Deal with file system corruption
             */
            if (rc == FS_ECORRUPT) {
    22e8:	2d01      	cmp	r5, #1
    22ea:	d012      	beq.n	2312 <nffs_restore_area_contents+0x372>
 * @param disk_object
 */
static int
nffs_restore_disk_object_size(const struct nffs_disk_object *disk_object)
{
    switch (disk_object->ndo_type) {
    22ec:	9b08      	ldr	r3, [sp, #32]
    22ee:	2b01      	cmp	r3, #1
    22f0:	d004      	beq.n	22fc <nffs_restore_area_contents+0x35c>
    22f2:	2b02      	cmp	r3, #2
    22f4:	d108      	bne.n	2308 <nffs_restore_area_contents+0x368>
    case NFFS_OBJECT_TYPE_INODE:
        return sizeof disk_object->ndo_disk_inode +
                      disk_object->ndo_disk_inode.ndi_filename_len;

    case NFFS_OBJECT_TYPE_BLOCK:
        return sizeof disk_object->ndo_disk_block +
    22f6:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
    22fa:	e001      	b.n	2300 <nffs_restore_area_contents+0x360>
static int
nffs_restore_disk_object_size(const struct nffs_disk_object *disk_object)
{
    switch (disk_object->ndo_type) {
    case NFFS_OBJECT_TYPE_INODE:
        return sizeof disk_object->ndo_disk_inode +
    22fc:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
             * XXX Deal with file system corruption
             */
            if (rc == FS_ECORRUPT) {
                area->na_cur++;
            } else {
                area->na_cur += nffs_restore_disk_object_size(&disk_object);
    2300:	68b2      	ldr	r2, [r6, #8]
    case NFFS_OBJECT_TYPE_INODE:
        return sizeof disk_object->ndo_disk_inode +
                      disk_object->ndo_disk_inode.ndi_filename_len;

    case NFFS_OBJECT_TYPE_BLOCK:
        return sizeof disk_object->ndo_disk_block +
    2302:	3314      	adds	r3, #20
             * XXX Deal with file system corruption
             */
            if (rc == FS_ECORRUPT) {
                area->na_cur++;
            } else {
                area->na_cur += nffs_restore_disk_object_size(&disk_object);
    2304:	4413      	add	r3, r2
    2306:	e654      	b.n	1fb2 <nffs_restore_area_contents+0x12>
    case NFFS_OBJECT_TYPE_BLOCK:
        return sizeof disk_object->ndo_disk_block +
                      disk_object->ndo_disk_block.ndb_data_len;

    default:
        assert(0);
    2308:	483c      	ldr	r0, [pc, #240]	; (23fc <nffs_restore_area_contents+0x45c>)
    230a:	f240 4104 	movw	r1, #1028	; 0x404
    230e:	2200      	movs	r2, #0
    2310:	e6f5      	b.n	20fe <nffs_restore_area_contents+0x15e>
        case FS_ECORRUPT:
            /*
             * Invalid object; keep scanning for a valid object ID and CRC
             * Can nffs_restore_disk_object return FS_ECORRUPT? XXX
             */
            area->na_cur++;
    2312:	68b3      	ldr	r3, [r6, #8]
    2314:	3301      	adds	r3, #1
    2316:	e64c      	b.n	1fb2 <nffs_restore_area_contents+0x12>
            break;

        case FS_EEMPTY:
        case FS_EOFFSET:
            /* End of disk encountered; area fully restored. */
            return 0;
    2318:	2000      	movs	r0, #0
    231a:	e068      	b.n	23ee <nffs_restore_area_contents+0x44e>
         * Inode has a lastblock on disk.
         * Add reference to last block entry if in hash table
         * otherwise add a dummy block entry for later update
         */
        if (disk_inode->ndi_lastblock_id != NFFS_ID_NONE &&
                nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
    231c:	6860      	ldr	r0, [r4, #4]
    231e:	f7fe fdc5 	bl	eac <nffs_hash_id_is_file>
        /*
         * Inode has a lastblock on disk.
         * Add reference to last block entry if in hash table
         * otherwise add a dummy block entry for later update
         */
        if (disk_inode->ndi_lastblock_id != NFFS_ID_NONE &&
    2322:	2800      	cmp	r0, #0
    2324:	f43f af35 	beq.w	2192 <nffs_restore_area_contents+0x1f2>
                nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
            lastblock_entry =
              nffs_hash_find_block(disk_inode->ndi_lastblock_id);
    2328:	980d      	ldr	r0, [sp, #52]	; 0x34
    232a:	f7fe fdf7 	bl	f1c <nffs_hash_find_block>
    232e:	4605      	mov	r5, r0
         * Add reference to last block entry if in hash table
         * otherwise add a dummy block entry for later update
         */
        if (disk_inode->ndi_lastblock_id != NFFS_ID_NONE &&
                nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
            lastblock_entry =
    2330:	9002      	str	r0, [sp, #8]
              nffs_hash_find_block(disk_inode->ndi_lastblock_id);

            /*
             * Lastblock has already been restored.
             */
            if (lastblock_entry != NULL) {
    2332:	b180      	cbz	r0, 2356 <nffs_restore_area_contents+0x3b6>
                if (lastblock_entry->nhe_id == disk_inode->ndi_lastblock_id) {
    2334:	6842      	ldr	r2, [r0, #4]
    2336:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    2338:	429a      	cmp	r2, r3
    233a:	f47f af2a 	bne.w	2192 <nffs_restore_area_contents+0x1f2>
                    inode_entry->nie_last_block_entry = lastblock_entry;
    233e:	6120      	str	r0, [r4, #16]
                    /*
                     * This flag should have been turned unset
                     * when the block was restored.
                     */
                    assert(!nffs_inode_getflags(inode_entry,
    2340:	2104      	movs	r1, #4
    2342:	4620      	mov	r0, r4
    2344:	f7ff fb53 	bl	19ee <nffs_inode_getflags>
    2348:	2800      	cmp	r0, #0
    234a:	f43f af22 	beq.w	2192 <nffs_restore_area_contents+0x1f2>
    234e:	482b      	ldr	r0, [pc, #172]	; (23fc <nffs_restore_area_contents+0x45c>)
    2350:	f240 2191 	movw	r1, #657	; 0x291
    2354:	e7db      	b.n	230e <nffs_restore_area_contents+0x36e>
                /*
                 * Insert a temporary reference to a 'dummy' block entry
                 * When block is restored, it will update this dummy and
                 * the entry of this inode is updated to flash location
                 */
                rc = nffs_block_entry_reserve(&lastblock_entry);
    2356:	a802      	add	r0, sp, #8
    2358:	f000 fc88 	bl	2c6c <nffs_block_entry_reserve>
                if (lastblock_entry == NULL) {
    235c:	f8dd 9008 	ldr.w	r9, [sp, #8]
    2360:	f1b9 0f00 	cmp.w	r9, #0
    2364:	d032      	beq.n	23cc <nffs_restore_area_contents+0x42c>
                    rc = FS_ENOMEM;
                    goto err;
                }

                lastblock_entry->nhe_id = disk_inode->ndi_lastblock_id;
    2366:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    2368:	f8c9 3004 	str.w	r3, [r9, #4]
                lastblock_entry->nhe_flash_loc = NFFS_FLASH_LOC_NONE;
    236c:	4629      	mov	r1, r5
    236e:	20ff      	movs	r0, #255	; 0xff
    2370:	f7fe fd0a 	bl	d88 <nffs_flash_loc>
                inode_entry->nie_last_block_entry = lastblock_entry;
    2374:	9b02      	ldr	r3, [sp, #8]
                    rc = FS_ENOMEM;
                    goto err;
                }

                lastblock_entry->nhe_id = disk_inode->ndi_lastblock_id;
                lastblock_entry->nhe_flash_loc = NFFS_FLASH_LOC_NONE;
    2376:	f8c9 0008 	str.w	r0, [r9, #8]
                inode_entry->nie_last_block_entry = lastblock_entry;
                nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DUMMYLSTBLK);
    237a:	2104      	movs	r1, #4
                    goto err;
                }

                lastblock_entry->nhe_id = disk_inode->ndi_lastblock_id;
                lastblock_entry->nhe_flash_loc = NFFS_FLASH_LOC_NONE;
                inode_entry->nie_last_block_entry = lastblock_entry;
    237c:	6123      	str	r3, [r4, #16]
                nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_DUMMYLSTBLK);
    237e:	4620      	mov	r0, r4
    2380:	f7ff fb2a 	bl	19d8 <nffs_inode_setflags>
                nffs_hash_insert(lastblock_entry);
    2384:	9802      	ldr	r0, [sp, #8]
    2386:	f7fe fdf5 	bl	f74 <nffs_hash_insert>

                if (lastblock_entry->nhe_id >= nffs_hash_next_block_id) {
    238a:	4a1a      	ldr	r2, [pc, #104]	; (23f4 <nffs_restore_area_contents+0x454>)
    238c:	9b02      	ldr	r3, [sp, #8]
    238e:	6811      	ldr	r1, [r2, #0]
    2390:	685b      	ldr	r3, [r3, #4]
    2392:	428b      	cmp	r3, r1
                    nffs_hash_next_block_id = lastblock_entry->nhe_id + 1;
    2394:	bf24      	itt	cs
    2396:	3301      	addcs	r3, #1
    2398:	6013      	strcs	r3, [r2, #0]
    239a:	e6fa      	b.n	2192 <nffs_restore_area_contents+0x1f2>
            }
        }

        if (disk_inode->ndi_parent_id != NFFS_ID_NONE) {
            
            parent = nffs_hash_find_inode(disk_inode->ndi_parent_id);
    239c:	f7fe fdac 	bl	ef8 <nffs_hash_find_inode>
    23a0:	9001      	str	r0, [sp, #4]
             * The parent directory for this inode hasn't been restored yet.
             * Add a dummy directory so it can be added as a child.
             * When the parent inode is restored, it's hash entry will be
             * updated with the flash location.
             */
            if (parent == NULL) {
    23a2:	b140      	cbz	r0, 23b6 <nffs_restore_area_contents+0x416>
                if (rc != 0) {
                    goto err;
                }
            }

            rc = nffs_inode_add_child(parent, inode_entry);
    23a4:	9801      	ldr	r0, [sp, #4]
    23a6:	4621      	mov	r1, r4
    23a8:	f7ff f9cc 	bl	1744 <nffs_inode_add_child>
            if (rc != 0) {
    23ac:	2800      	cmp	r0, #0
    23ae:	f43f aef4 	beq.w	219a <nffs_restore_area_contents+0x1fa>
    23b2:	4605      	mov	r5, r0
    23b4:	e00b      	b.n	23ce <nffs_restore_area_contents+0x42e>
             * Add a dummy directory so it can be added as a child.
             * When the parent inode is restored, it's hash entry will be
             * updated with the flash location.
             */
            if (parent == NULL) {
                rc = nffs_restore_dummy_inode(disk_inode->ndi_parent_id,
    23b6:	a901      	add	r1, sp, #4
    23b8:	980c      	ldr	r0, [sp, #48]	; 0x30
    23ba:	f7ff fdd4 	bl	1f66 <nffs_restore_dummy_inode>
                                             &parent);
                /*
                 * Set the dummy parent flag in the new parent.
                 * It's turned off above when restored.
                 */
                nffs_inode_setflags(parent, NFFS_INODE_FLAG_DUMMYPARENT);
    23be:	2102      	movs	r1, #2
             * Add a dummy directory so it can be added as a child.
             * When the parent inode is restored, it's hash entry will be
             * updated with the flash location.
             */
            if (parent == NULL) {
                rc = nffs_restore_dummy_inode(disk_inode->ndi_parent_id,
    23c0:	4605      	mov	r5, r0
                                             &parent);
                /*
                 * Set the dummy parent flag in the new parent.
                 * It's turned off above when restored.
                 */
                nffs_inode_setflags(parent, NFFS_INODE_FLAG_DUMMYPARENT);
    23c2:	9801      	ldr	r0, [sp, #4]
    23c4:	f7ff fb08 	bl	19d8 <nffs_inode_setflags>
                if (rc != 0) {
    23c8:	b90d      	cbnz	r5, 23ce <nffs_restore_area_contents+0x42e>
    23ca:	e7eb      	b.n	23a4 <nffs_restore_area_contents+0x404>
                 * When block is restored, it will update this dummy and
                 * the entry of this inode is updated to flash location
                 */
                rc = nffs_block_entry_reserve(&lastblock_entry);
                if (lastblock_entry == NULL) {
                    rc = FS_ENOMEM;
    23cc:	2505      	movs	r5, #5
    }

    return 0;

err:
    if (new_inode) {
    23ce:	f1b8 0f00 	cmp.w	r8, #0
    23d2:	d089      	beq.n	22e8 <nffs_restore_area_contents+0x348>
        nffs_inode_entry_free(inode_entry);
    23d4:	4620      	mov	r0, r4
    23d6:	f7fe fe95 	bl	1104 <nffs_inode_entry_free>
    23da:	e785      	b.n	22e8 <nffs_restore_area_contents+0x348>

    entry = nffs_hash_find_block(disk_block->ndb_id);
    if (entry != NULL) {

        rc = nffs_block_from_hash_entry_no_ptrs(&block, entry);
        if (rc != 0 && rc != FS_ENOENT) {
    23dc:	4605      	mov	r5, r0
    23de:	e783      	b.n	22e8 <nffs_restore_area_contents+0x348>
        }

        /*
         * update the existing hash entry to reference the new flash location
         */
        entry->nhe_flash_loc = nffs_flash_loc(area_idx, area_offset);
    23e0:	4641      	mov	r1, r8
    23e2:	4648      	mov	r0, r9
    23e4:	f7fe fcd0 	bl	d88 <nffs_flash_loc>
    struct nffs_block block;
    int do_replace;
    int new_block;
    int rc;

    new_block = 0;
    23e8:	46a8      	mov	r8, r5
        }

        /*
         * update the existing hash entry to reference the new flash location
         */
        entry->nhe_flash_loc = nffs_flash_loc(area_idx, area_offset);
    23ea:	60a0      	str	r0, [r4, #8]
    23ec:	e758      	b.n	22a0 <nffs_restore_area_contents+0x300>

        default:
            return rc;
        }
    }
}
    23ee:	b010      	add	sp, #64	; 0x40
    23f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    23f4:	20000ca0 	.word	0x20000ca0
    23f8:	200005fe 	.word	0x200005fe
    23fc:	000062ea 	.word	0x000062ea

00002400 <nffs_restore_sweep>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_restore_sweep(void)
{
    2400:	b5f0      	push	{r4, r5, r6, r7, lr}
    2402:	2400      	movs	r4, #0
    2404:	b09f      	sub	sp, #124	; 0x7c

    /* Iterate through every object in the hash table, deleting all inodes that
     * should be removed.
     */
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        list = nffs_hash + i;
    2406:	4b75      	ldr	r3, [pc, #468]	; (25dc <nffs_restore_sweep+0x1dc>)
    2408:	681b      	ldr	r3, [r3, #0]

        entry = SLIST_FIRST(list);
    240a:	591e      	ldr	r6, [r3, r4]

    /* Iterate through every object in the hash table, deleting all inodes that
     * should be removed.
     */
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        list = nffs_hash + i;
    240c:	191d      	adds	r5, r3, r4

        entry = SLIST_FIRST(list);
        while (entry != NULL) {
    240e:	2e00      	cmp	r6, #0
    2410:	f000 80db 	beq.w	25ca <nffs_restore_sweep+0x1ca>
            next = SLIST_NEXT(entry, nhe_next);
    2414:	6833      	ldr	r3, [r6, #0]
            if (nffs_hash_id_is_inode(entry->nhe_id)) {
    2416:	6870      	ldr	r0, [r6, #4]
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        list = nffs_hash + i;

        entry = SLIST_FIRST(list);
        while (entry != NULL) {
            next = SLIST_NEXT(entry, nhe_next);
    2418:	9302      	str	r3, [sp, #8]
            if (nffs_hash_id_is_inode(entry->nhe_id)) {
    241a:	f7fe fd4f 	bl	ebc <nffs_hash_id_is_inode>
    241e:	2800      	cmp	r0, #0
    2420:	f000 80bf 	beq.w	25a2 <nffs_restore_sweep+0x1a2>
    struct nffs_inode_entry *lost_found_sub;
    struct nffs_inode_entry *child_entry;
    char buf[32];
    int rc;

    if (!nffs_hash_id_is_dir(inode_entry->nie_hash_entry.nhe_id)) {
    2424:	6870      	ldr	r0, [r6, #4]
    2426:	f7fe fd3b 	bl	ea0 <nffs_hash_id_is_dir>
    242a:	2800      	cmp	r0, #0
    242c:	d043      	beq.n	24b6 <nffs_restore_sweep+0xb6>
        /* Not a directory. */
        return 0;
    }

    if (!nffs_inode_is_dummy(inode_entry)) {
    242e:	4630      	mov	r0, r6
    2430:	f7ff f908 	bl	1644 <nffs_inode_is_dummy>
    2434:	2800      	cmp	r0, #0
    2436:	d03e      	beq.n	24b6 <nffs_restore_sweep+0xb6>
        /* Not a dummy. */
        return 0;
    }

    if (SLIST_EMPTY(&inode_entry->nie_child_list)) {
    2438:	6933      	ldr	r3, [r6, #16]
    243a:	2b00      	cmp	r3, #0
    243c:	d03b      	beq.n	24b6 <nffs_restore_sweep+0xb6>
    }

    /* Create a directory in lost+found to hold the dummy directory's
     * contents.
     */
    strcpy(buf, "/lost+found/");
    243e:	4968      	ldr	r1, [pc, #416]	; (25e0 <nffs_restore_sweep+0x1e0>)
    2440:	a816      	add	r0, sp, #88	; 0x58
    2442:	f001 faa4 	bl	398e <strcpy>
    u32toa(&buf[strlen(buf)], inode_entry->nie_hash_entry.nhe_id);
    2446:	a816      	add	r0, sp, #88	; 0x58
    2448:	f001 faa9 	bl	399e <strlen>
    244c:	ab16      	add	r3, sp, #88	; 0x58
    244e:	eb03 0e00 	add.w	lr, r3, r0
    2452:	6877      	ldr	r7, [r6, #4]
u32toa(char *dst, uint32_t val)
{
    uint8_t tmp;
    int idx = 0;
    int i;
    int print = 0;
    2454:	2000      	movs	r0, #0

static void
u32toa(char *dst, uint32_t val)
{
    uint8_t tmp;
    int idx = 0;
    2456:	4602      	mov	r2, r0
    int i;
    int print = 0;

    for (i = 0; i < 8; i++) {
    2458:	4601      	mov	r1, r0
        tmp = val >> 28;
        if (tmp || i == 7) {
    245a:	0f3b      	lsrs	r3, r7, #28
    245c:	d102      	bne.n	2464 <nffs_restore_sweep+0x64>
    245e:	2907      	cmp	r1, #7
    2460:	d103      	bne.n	246a <nffs_restore_sweep+0x6a>
    2462:	e003      	b.n	246c <nffs_restore_sweep+0x6c>
            print = 1;
        }
        if (tmp < 10) {
    2464:	2b09      	cmp	r3, #9
    2466:	d803      	bhi.n	2470 <nffs_restore_sweep+0x70>
    2468:	e000      	b.n	246c <nffs_restore_sweep+0x6c>
            tmp += '0';
        } else {
            tmp += 'a' - 10;
        }
        if (print) {
    246a:	b130      	cbz	r0, 247a <nffs_restore_sweep+0x7a>
        tmp = val >> 28;
        if (tmp || i == 7) {
            print = 1;
        }
        if (tmp < 10) {
            tmp += '0';
    246c:	3330      	adds	r3, #48	; 0x30
    246e:	e000      	b.n	2472 <nffs_restore_sweep+0x72>
        } else {
            tmp += 'a' - 10;
    2470:	3357      	adds	r3, #87	; 0x57
        }
        if (print) {
            dst[idx++] = tmp;
    2472:	f80e 3002 	strb.w	r3, [lr, r2]
    2476:	2001      	movs	r0, #1
    2478:	3201      	adds	r2, #1
    uint8_t tmp;
    int idx = 0;
    int i;
    int print = 0;

    for (i = 0; i < 8; i++) {
    247a:	3101      	adds	r1, #1
    247c:	2908      	cmp	r1, #8
            tmp += 'a' - 10;
        }
        if (print) {
            dst[idx++] = tmp;
        }
        val <<= 4;
    247e:	ea4f 1707 	mov.w	r7, r7, lsl #4
    uint8_t tmp;
    int idx = 0;
    int i;
    int print = 0;

    for (i = 0; i < 8; i++) {
    2482:	d1ea      	bne.n	245a <nffs_restore_sweep+0x5a>
        if (print) {
            dst[idx++] = tmp;
        }
        val <<= 4;
    }
    dst[idx++] = '\0';
    2484:	2300      	movs	r3, #0
    2486:	f80e 3002 	strb.w	r3, [lr, r2]
     * contents.
     */
    strcpy(buf, "/lost+found/");
    u32toa(&buf[strlen(buf)], inode_entry->nie_hash_entry.nhe_id);

    rc = nffs_path_new_dir(buf, &lost_found_sub);
    248a:	a816      	add	r0, sp, #88	; 0x58
    248c:	a911      	add	r1, sp, #68	; 0x44
    248e:	f7ff fd43 	bl	1f18 <nffs_path_new_dir>
    if (rc != 0 && rc != FS_EEXIST) {
    2492:	b148      	cbz	r0, 24a8 <nffs_restore_sweep+0xa8>
    2494:	280b      	cmp	r0, #11
    2496:	d10b      	bne.n	24b0 <nffs_restore_sweep+0xb0>
    2498:	e006      	b.n	24a8 <nffs_restore_sweep+0xa8>
        return rc;
    }

    /* Move each child into the new subdirectory. */
    while ((child_entry = SLIST_FIRST(&inode_entry->nie_child_list)) != NULL) {
        rc = nffs_inode_rename(child_entry, lost_found_sub, NULL);
    249a:	9911      	ldr	r1, [sp, #68]	; 0x44
    249c:	2200      	movs	r2, #0
    249e:	f7ff f999 	bl	17d4 <nffs_inode_rename>
        if (rc != 0) {
    24a2:	2800      	cmp	r0, #0
    24a4:	f040 8097 	bne.w	25d6 <nffs_restore_sweep+0x1d6>
    if (rc != 0 && rc != FS_EEXIST) {
        return rc;
    }

    /* Move each child into the new subdirectory. */
    while ((child_entry = SLIST_FIRST(&inode_entry->nie_child_list)) != NULL) {
    24a8:	6930      	ldr	r0, [r6, #16]
    24aa:	2800      	cmp	r0, #0
    24ac:	d1f5      	bne.n	249a <nffs_restore_sweep+0x9a>
    24ae:	e002      	b.n	24b6 <nffs_restore_sweep+0xb6>
                 * If this is a dummy inode directory, the file system
                 * is corrupt.  Move the directory's children inodes to
                 * the lost+found directory.
                 */
                rc = nffs_restore_migrate_orphan_children(inode_entry);
                if (rc != 0) {
    24b0:	2800      	cmp	r0, #0
    24b2:	f040 8090 	bne.w	25d6 <nffs_restore_sweep+0x1d6>
    /*
     * if this inode was tagged to have a dummy block entry and the
     * flag is still set, that means we didn't find the block and so
     * should remove this inode and all associated blocks.
     */
    if (nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DUMMYLSTBLK)) {
    24b6:	4630      	mov	r0, r6
    24b8:	2104      	movs	r1, #4
    24ba:	f7ff fa98 	bl	19ee <nffs_inode_getflags>
    24be:	b110      	cbz	r0, 24c6 <nffs_restore_sweep+0xc6>
        *out_should_sweep = 1;
        /*nffs_inode_inc_refcnt(inode_entry);*/
        inode_entry->nie_refcnt = 1;
    24c0:	2701      	movs	r7, #1
    24c2:	7537      	strb	r7, [r6, #20]
    24c4:	e05d      	b.n	2582 <nffs_restore_sweep+0x182>
    /*
     * This inode was originally created to hold a block that was restored
     * before the owning inode. If the flag is still set, it means we never
     * restored the inode from disk and so this entry should be deleted.
     */
    if (nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DUMMYINOBLK)) {
    24c6:	4630      	mov	r0, r6
    24c8:	2108      	movs	r1, #8
    24ca:	f7ff fa90 	bl	19ee <nffs_inode_getflags>
    24ce:	b118      	cbz	r0, 24d8 <nffs_restore_sweep+0xd8>
        *out_should_sweep = 2;
        /*nffs_inode_inc_refcnt(inode_entry);*/
        inode_entry->nie_refcnt = 1;
    24d0:	2301      	movs	r3, #1
    24d2:	7533      	strb	r3, [r6, #20]
     * This inode was originally created to hold a block that was restored
     * before the owning inode. If the flag is still set, it means we never
     * restored the inode from disk and so this entry should be deleted.
     */
    if (nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DUMMYINOBLK)) {
        *out_should_sweep = 2;
    24d4:	2702      	movs	r7, #2
    24d6:	e054      	b.n	2582 <nffs_restore_sweep+0x182>
     * location set to LOC_NONE and should have a flag set for the reason.
     * The presence of a dummy inode during the final sweep step indicates
     * file system corruption.  It's assumed that directories have
     * previously migrated all children to /lost+found.
     */
    if (nffs_inode_is_dummy(inode_entry)) {
    24d8:	4630      	mov	r0, r6
    24da:	f7ff f8b3 	bl	1644 <nffs_inode_is_dummy>
    24de:	4607      	mov	r7, r0
    24e0:	b150      	cbz	r0, 24f8 <nffs_restore_sweep+0xf8>
        *out_should_sweep = 3;
        nffs_inode_inc_refcnt(inode_entry);
    24e2:	4630      	mov	r0, r6
    24e4:	f7fe fee6 	bl	12b4 <nffs_inode_inc_refcnt>
        assert(inode_entry->nie_refcnt >= 1);
    24e8:	7d32      	ldrb	r2, [r6, #20]
    24ea:	2a00      	cmp	r2, #0
    24ec:	d143      	bne.n	2576 <nffs_restore_sweep+0x176>
    24ee:	483d      	ldr	r0, [pc, #244]	; (25e4 <nffs_restore_sweep+0x1e4>)
    24f0:	21cc      	movs	r1, #204	; 0xcc
    24f2:	4613      	mov	r3, r2
    24f4:	f002 fbaa 	bl	4c4c <__assert_func>

    /* Determine if the inode has been deleted.  If an inode has no parent (and
     * it isn't the root directory), it has been deleted from the disk and
     * should be swept from the RAM representation.
     */
    if (inode_entry->nie_hash_entry.nhe_id != NFFS_ID_ROOT_DIR) {
    24f8:	6873      	ldr	r3, [r6, #4]
    24fa:	b92b      	cbnz	r3, 2508 <nffs_restore_sweep+0x108>
     *
     * XXX Note that the record of a deletion could be lost if garbage
     * collection erases the delete but leaves inode updates on other
     * partitions which can then be restored.
     */
    if (nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DELETED)) {
    24fc:	4630      	mov	r0, r6
    24fe:	2180      	movs	r1, #128	; 0x80
    2500:	f7ff fa75 	bl	19ee <nffs_inode_getflags>
    2504:	b960      	cbnz	r0, 2520 <nffs_restore_sweep+0x120>
    2506:	e010      	b.n	252a <nffs_restore_sweep+0x12a>
    /* Determine if the inode has been deleted.  If an inode has no parent (and
     * it isn't the root directory), it has been deleted from the disk and
     * should be swept from the RAM representation.
     */
    if (inode_entry->nie_hash_entry.nhe_id != NFFS_ID_ROOT_DIR) {
        rc = nffs_inode_from_entry(&inode, inode_entry);
    2508:	a808      	add	r0, sp, #32
    250a:	4631      	mov	r1, r6
    250c:	f7ff f8b4 	bl	1678 <nffs_inode_from_entry>
        if (rc != 0 && rc != FS_ENOENT) {
    2510:	b108      	cbz	r0, 2516 <nffs_restore_sweep+0x116>
    2512:	2806      	cmp	r0, #6
    2514:	d134      	bne.n	2580 <nffs_restore_sweep+0x180>
            *out_should_sweep = 0;
            return rc;
        }
        if (inode.ni_parent == NULL) {
    2516:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2518:	2b00      	cmp	r3, #0
    251a:	d1ef      	bne.n	24fc <nffs_restore_sweep+0xfc>
            *out_should_sweep = 4;
    251c:	2704      	movs	r7, #4
    251e:	e030      	b.n	2582 <nffs_restore_sweep+0x182>
     * XXX Note that the record of a deletion could be lost if garbage
     * collection erases the delete but leaves inode updates on other
     * partitions which can then be restored.
     */
    if (nffs_inode_getflags(inode_entry, NFFS_INODE_FLAG_DELETED)) {
        rc = nffs_inode_from_entry(&inode, inode_entry);
    2520:	a808      	add	r0, sp, #32
    2522:	4631      	mov	r1, r6
    2524:	f7ff f8a8 	bl	1678 <nffs_inode_from_entry>
        if (rc != 0) {
    2528:	bb48      	cbnz	r0, 257e <nffs_restore_sweep+0x17e>
    }

    /* If this is a file inode, verify that all of its constituent blocks are
     * present.
     */
    if (nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
    252a:	6870      	ldr	r0, [r6, #4]
    252c:	f7fe fcbe 	bl	eac <nffs_hash_id_is_file>
    2530:	b908      	cbnz	r0, 2536 <nffs_restore_sweep+0x136>
            return rc;
        }
    }

    /* This is a valid inode; don't sweep it. */
    *out_should_sweep = 0;
    2532:	4607      	mov	r7, r0
    2534:	e025      	b.n	2582 <nffs_restore_sweep+0x182>

    /* If this is a file inode, verify that all of its constituent blocks are
     * present.
     */
    if (nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
        rc = nffs_restore_validate_block_chain(
    2536:	6937      	ldr	r7, [r6, #16]
    int rc;

    cur = last_block_entry;

    while (cur != NULL) {
        if (nffs_hash_entry_is_dummy(cur)) {
    2538:	4638      	mov	r0, r7
    uint8_t area_idx;
    int rc;

    cur = last_block_entry;

    while (cur != NULL) {
    253a:	b307      	cbz	r7, 257e <nffs_restore_sweep+0x17e>
        if (nffs_hash_entry_is_dummy(cur)) {
    253c:	f7fe fd02 	bl	f44 <nffs_hash_entry_is_dummy>
    2540:	b9b8      	cbnz	r0, 2572 <nffs_restore_sweep+0x172>
            return FS_ENOENT;
        }

        nffs_flash_loc_expand(cur->nhe_flash_loc, &area_idx, &area_offset);
    2542:	68b8      	ldr	r0, [r7, #8]
    2544:	f10d 0107 	add.w	r1, sp, #7
    2548:	aa03      	add	r2, sp, #12
    254a:	f7fe fc2d 	bl	da8 <nffs_flash_loc_expand>

        rc = nffs_block_read_disk(area_idx, area_offset, &disk_block);
    254e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    2552:	9903      	ldr	r1, [sp, #12]
    2554:	aa11      	add	r2, sp, #68	; 0x44
    2556:	f000 fb96 	bl	2c86 <nffs_block_read_disk>
        if (rc != 0) {
    255a:	b930      	cbnz	r0, 256a <nffs_restore_sweep+0x16a>
            return rc;
        }

        rc = nffs_block_from_hash_entry(&block, cur);
    255c:	a816      	add	r0, sp, #88	; 0x58
    255e:	4639      	mov	r1, r7
    2560:	f000 fc38 	bl	2dd4 <nffs_block_from_hash_entry>
        if (rc != 0) {
    2564:	b908      	cbnz	r0, 256a <nffs_restore_sweep+0x16a>
            return rc;
        }

        cur = block.nb_prev;
    2566:	9f19      	ldr	r7, [sp, #100]	; 0x64
    2568:	e7e6      	b.n	2538 <nffs_restore_sweep+0x138>
     * present.
     */
    if (nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
        rc = nffs_restore_validate_block_chain(
                inode_entry->nie_last_block_entry);
        if (rc == FS_ECORRUPT) {
    256a:	2801      	cmp	r0, #1
    256c:	d005      	beq.n	257a <nffs_restore_sweep+0x17a>
            *out_should_sweep = 6;
            return 0;
        } else if (rc == FS_ENOENT) {
    256e:	2806      	cmp	r0, #6
    2570:	d105      	bne.n	257e <nffs_restore_sweep+0x17e>
            *out_should_sweep = 7;
    2572:	2707      	movs	r7, #7
    2574:	e005      	b.n	2582 <nffs_restore_sweep+0x182>
     * The presence of a dummy inode during the final sweep step indicates
     * file system corruption.  It's assumed that directories have
     * previously migrated all children to /lost+found.
     */
    if (nffs_inode_is_dummy(inode_entry)) {
        *out_should_sweep = 3;
    2576:	2703      	movs	r7, #3
    2578:	e003      	b.n	2582 <nffs_restore_sweep+0x182>
     */
    if (nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id)) {
        rc = nffs_restore_validate_block_chain(
                inode_entry->nie_last_block_entry);
        if (rc == FS_ECORRUPT) {
            *out_should_sweep = 6;
    257a:	2706      	movs	r7, #6
    257c:	e001      	b.n	2582 <nffs_restore_sweep+0x182>
            return rc;
        }
    }

    /* This is a valid inode; don't sweep it. */
    *out_should_sweep = 0;
    257e:	2700      	movs	r7, #0
                    return rc;
                }

                /* Determine if this inode needs to be deleted. */
                rc = nffs_restore_should_sweep_inode_entry(inode_entry, &del);
                if (rc != 0) {
    2580:	bb48      	cbnz	r0, 25d6 <nffs_restore_sweep+0x1d6>
                    return rc;
                }

                rc = nffs_inode_from_entry(&inode, inode_entry);
    2582:	a804      	add	r0, sp, #16
    2584:	4631      	mov	r1, r6
    2586:	f7ff f877 	bl	1678 <nffs_inode_from_entry>
                if (rc != 0 && rc != FS_ENOENT) {
    258a:	b108      	cbz	r0, 2590 <nffs_restore_sweep+0x190>
    258c:	2806      	cmp	r0, #6
    258e:	d122      	bne.n	25d6 <nffs_restore_sweep+0x1d6>
                    rc = nffs_inode_rename(inode_entry,
                                           nffs_lost_found_dir, NULL);
                }
#endif

                if (del) {
    2590:	b1cf      	cbz	r7, 25c6 <nffs_restore_sweep+0x1c6>
                     * expect some file system corruption; the children are
                     * subject to garbage collection and may not exist in the
                     * hash.  Remove what is actually present and ignore
                     * corruption errors.
                     */
                    rc = nffs_inode_unlink_from_ram_corrupt_ok(&inode, &next);
    2592:	a804      	add	r0, sp, #16
    2594:	a902      	add	r1, sp, #8
    2596:	f7ff f844 	bl	1622 <nffs_inode_unlink_from_ram_corrupt_ok>
                    if (rc != 0) {
    259a:	b9e0      	cbnz	r0, 25d6 <nffs_restore_sweep+0x1d6>
                        return rc;
                    }
                    next = SLIST_FIRST(list);
    259c:	682b      	ldr	r3, [r5, #0]
    259e:	9302      	str	r3, [sp, #8]
    25a0:	e011      	b.n	25c6 <nffs_restore_sweep+0x1c6>
                }
            } else if (nffs_hash_id_is_block(entry->nhe_id)) {
    25a2:	6870      	ldr	r0, [r6, #4]
    25a4:	f7fe fc8e 	bl	ec4 <nffs_hash_id_is_block>
    25a8:	b168      	cbz	r0, 25c6 <nffs_restore_sweep+0x1c6>
                if (nffs_hash_id_is_dummy(entry->nhe_id)) {
    25aa:	6870      	ldr	r0, [r6, #4]
    25ac:	f7fe fcd4 	bl	f58 <nffs_hash_id_is_dummy>
    25b0:	b930      	cbnz	r0, 25c0 <nffs_restore_sweep+0x1c0>
                    nffs_block_delete_from_ram(entry);
                } else {
                    rc = nffs_block_from_hash_entry(&block, entry);
    25b2:	a80c      	add	r0, sp, #48	; 0x30
    25b4:	4631      	mov	r1, r6
    25b6:	f000 fc0d 	bl	2dd4 <nffs_block_from_hash_entry>
                    if (rc != 0 && rc != FS_ENOENT) {
    25ba:	b120      	cbz	r0, 25c6 <nffs_restore_sweep+0x1c6>
    25bc:	2806      	cmp	r0, #6
    25be:	d002      	beq.n	25c6 <nffs_restore_sweep+0x1c6>
                        nffs_block_delete_from_ram(entry);
    25c0:	4630      	mov	r0, r6
    25c2:	f000 fc4d 	bl	2e60 <nffs_block_delete_from_ram>
                    }
                }
            }

            entry = next;
    25c6:	9e02      	ldr	r6, [sp, #8]
    25c8:	e721      	b.n	240e <nffs_restore_sweep+0xe>
    25ca:	3404      	adds	r4, #4
    int i;

    /* Iterate through every object in the hash table, deleting all inodes that
     * should be removed.
     */
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
    25cc:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
    25d0:	f47f af19 	bne.w	2406 <nffs_restore_sweep+0x6>

            entry = next;
        }
    }

    return 0;
    25d4:	4630      	mov	r0, r6
}
    25d6:	b01f      	add	sp, #124	; 0x7c
    25d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    25da:	bf00      	nop
    25dc:	20000ca4 	.word	0x20000ca4
    25e0:	000062f9 	.word	0x000062f9
    25e4:	000062ea 	.word	0x000062ea

000025e8 <nffs_restore_full>:
 *                          FS_ECORRUPT if no valid file system was detected;
 *                          other nonzero on error.
 */
int
nffs_restore_full(const struct nffs_area_desc *area_descs)
{
    25e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    25ec:	b08a      	sub	sp, #40	; 0x28
    25ee:	4604      	mov	r4, r0
    int use_area;
    int rc;
    int i;

    /* Start from a clean state. */
    rc = nffs_misc_reset();
    25f0:	f7ff fafa 	bl	1be8 <nffs_misc_reset>
    if (rc) {
    25f4:	2800      	cmp	r0, #0
    25f6:	f040 80b2 	bne.w	275e <nffs_restore_full+0x176>
        return rc;
    }
    nffs_restore_largest_block_data_len = 0;
    25fa:	4f5a      	ldr	r7, [pc, #360]	; (2764 <nffs_restore_full+0x17c>)
    nffs_current_area_descs = (struct nffs_area_desc*) area_descs;
    25fc:	4b5a      	ldr	r3, [pc, #360]	; (2768 <nffs_restore_full+0x180>)
    /* Start from a clean state. */
    rc = nffs_misc_reset();
    if (rc) {
        return rc;
    }
    nffs_restore_largest_block_data_len = 0;
    25fe:	8038      	strh	r0, [r7, #0]
    nffs_current_area_descs = (struct nffs_area_desc*) area_descs;
    2600:	601c      	str	r4, [r3, #0]
    2602:	1d25      	adds	r5, r4, #4
    2604:	f504 6841 	add.w	r8, r4, #3088	; 0xc10

    /* Read each area from flash. */
    for (i = 0; area_descs[i].nad_length != 0; i++) {
    2608:	682b      	ldr	r3, [r5, #0]
    260a:	b1e3      	cbz	r3, 2646 <nffs_restore_full+0x5e>
        if (i > NFFS_MAX_AREAS) {
    260c:	4545      	cmp	r5, r8
    260e:	d076      	beq.n	26fe <nffs_restore_full+0x116>
nffs_restore_detect_one_area(uint8_t flash_id, uint32_t area_offset,
                             struct nffs_disk_area *out_disk_area)
{
    int rc;

    rc = hal_flash_read(flash_id, area_offset, out_disk_area,
    2610:	7928      	ldrb	r0, [r5, #4]
    2612:	f855 1c04 	ldr.w	r1, [r5, #-4]
    2616:	aa04      	add	r2, sp, #16
    2618:	2318      	movs	r3, #24
    261a:	f001 f863 	bl	36e4 <hal_flash_read>
                        sizeof *out_disk_area);
    if (rc != 0) {
    261e:	2800      	cmp	r0, #0
    2620:	d16f      	bne.n	2702 <nffs_restore_full+0x11a>
        return FS_EHW;
    }

    if (!nffs_area_magic_is_set(out_disk_area)) {
    2622:	a804      	add	r0, sp, #16
    2624:	f000 fa7a 	bl	2b1c <nffs_area_magic_is_set>
    2628:	b158      	cbz	r0, 2642 <nffs_restore_full+0x5a>
        return FS_ECORRUPT;
    }

    if (!nffs_area_is_current_version(out_disk_area)) {
    262a:	a804      	add	r0, sp, #16
    262c:	f000 fa9d 	bl	2b6a <nffs_area_is_current_version>
    2630:	b138      	cbz	r0, 2642 <nffs_restore_full+0x5a>
        default:
            goto err;
        }

        if (use_area) {
            if (disk_area.nda_id == NFFS_AREA_ID_NONE &&
    2632:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    2636:	2bff      	cmp	r3, #255	; 0xff
    2638:	d168      	bne.n	270c <nffs_restore_full+0x124>
                nffs_scratch_area_idx != NFFS_AREA_ID_NONE) {
    263a:	4b4c      	ldr	r3, [pc, #304]	; (276c <nffs_restore_full+0x184>)
        default:
            goto err;
        }

        if (use_area) {
            if (disk_area.nda_id == NFFS_AREA_ID_NONE &&
    263c:	781b      	ldrb	r3, [r3, #0]
    263e:	2bff      	cmp	r3, #255	; 0xff
    2640:	d064      	beq.n	270c <nffs_restore_full+0x124>
    2642:	350c      	adds	r5, #12
    2644:	e7e0      	b.n	2608 <nffs_restore_full+0x20>
        }
    }

    /* All areas have been restored from flash. */

    if (nffs_scratch_area_idx == NFFS_AREA_ID_NONE) {
    2646:	4b49      	ldr	r3, [pc, #292]	; (276c <nffs_restore_full+0x184>)
    2648:	781a      	ldrb	r2, [r3, #0]
    264a:	2aff      	cmp	r2, #255	; 0xff
    264c:	461e      	mov	r6, r3
    264e:	d142      	bne.n	26d6 <nffs_restore_full+0xee>
     *
     * good_idx = index of source area.
     * bad_idx  = index of destination area; this will be turned into the
     *            scratch area.
     */
    rc = nffs_area_find_corrupt_scratch(&good_idx, &bad_idx);
    2650:	a802      	add	r0, sp, #8
    2652:	f10d 010a 	add.w	r1, sp, #10
    2656:	f000 fab1 	bl	2bbc <nffs_area_find_corrupt_scratch>
    if (rc != 0) {
    265a:	4604      	mov	r4, r0
    265c:	bbb8      	cbnz	r0, 26ce <nffs_restore_full+0xe6>
    265e:	4605      	mov	r5, r0
        return rc;
    }

    /* Invalidate all objects resident in the bad area. */
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        entry = SLIST_FIRST(&nffs_hash[i]);
    2660:	4b43      	ldr	r3, [pc, #268]	; (2770 <nffs_restore_full+0x188>)
    2662:	681b      	ldr	r3, [r3, #0]
    2664:	595c      	ldr	r4, [r3, r5]
        while (entry != NULL) {
    2666:	b1ec      	cbz	r4, 26a4 <nffs_restore_full+0xbc>
            next = SLIST_NEXT(entry, nhe_next);

            nffs_flash_loc_expand(entry->nhe_flash_loc,
    2668:	aa03      	add	r2, sp, #12
    266a:	68a0      	ldr	r0, [r4, #8]

    /* Invalidate all objects resident in the bad area. */
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        entry = SLIST_FIRST(&nffs_hash[i]);
        while (entry != NULL) {
            next = SLIST_NEXT(entry, nhe_next);
    266c:	f8d4 8000 	ldr.w	r8, [r4]

            nffs_flash_loc_expand(entry->nhe_flash_loc,
    2670:	f10d 0107 	add.w	r1, sp, #7
    2674:	f7fe fb98 	bl	da8 <nffs_flash_loc_expand>
                                 &area_idx, &area_offset);
            if (area_idx == bad_idx) {
    2678:	f89d 2007 	ldrb.w	r2, [sp, #7]
    267c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    2680:	429a      	cmp	r2, r3
    2682:	d10d      	bne.n	26a0 <nffs_restore_full+0xb8>
                if (nffs_hash_id_is_block(entry->nhe_id)) {
    2684:	6860      	ldr	r0, [r4, #4]
    2686:	f7fe fc1d 	bl	ec4 <nffs_hash_id_is_block>
    268a:	b128      	cbz	r0, 2698 <nffs_restore_full+0xb0>
                    rc = nffs_block_delete_from_ram(entry);
    268c:	4620      	mov	r0, r4
    268e:	f000 fbe7 	bl	2e60 <nffs_block_delete_from_ram>
                    if (rc != 0) {
    2692:	4604      	mov	r4, r0
    2694:	b120      	cbz	r0, 26a0 <nffs_restore_full+0xb8>
    2696:	e01a      	b.n	26ce <nffs_restore_full+0xe6>
                        return rc;
                    }
                } else {
                    inode_entry = (struct nffs_inode_entry *)entry;
                    nffs_inode_setflags(inode_entry, NFFS_INODE_FLAG_OBSOLETE);
    2698:	4620      	mov	r0, r4
    269a:	2110      	movs	r1, #16
    269c:	f7ff f99c 	bl	19d8 <nffs_inode_setflags>
     * good_idx = index of source area.
     * bad_idx  = index of destination area; this will be turned into the
     *            scratch area.
     */
    rc = nffs_area_find_corrupt_scratch(&good_idx, &bad_idx);
    if (rc != 0) {
    26a0:	4644      	mov	r4, r8
    26a2:	e7e0      	b.n	2666 <nffs_restore_full+0x7e>
    26a4:	3504      	adds	r5, #4
        return rc;
    }

    /* Invalidate all objects resident in the bad area. */
    for (i = 0; i < NFFS_HASH_SIZE; i++) {
    26a6:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
    26aa:	d1d9      	bne.n	2660 <nffs_restore_full+0x78>
    }

    /* Now that the objects in the scratch area have been invalidated, reload
     * everything from the good area.
     */
    rc = nffs_restore_area_contents(good_idx);
    26ac:	f8bd 0008 	ldrh.w	r0, [sp, #8]
    26b0:	f7ff fc76 	bl	1fa0 <nffs_restore_area_contents>
    if (rc != 0) {
    26b4:	4604      	mov	r4, r0
    26b6:	b950      	cbnz	r0, 26ce <nffs_restore_full+0xe6>
        return rc;
    }

    /* Convert the bad area into a scratch area. */
    rc = nffs_format_area(bad_idx, 1);
    26b8:	f89d 000a 	ldrb.w	r0, [sp, #10]
    26bc:	2101      	movs	r1, #1
    26be:	f7fe fb79 	bl	db4 <nffs_format_area>
    if (rc != 0) {
    26c2:	4604      	mov	r4, r0
    26c4:	b918      	cbnz	r0, 26ce <nffs_restore_full+0xe6>
        return rc;
    }
    nffs_scratch_area_idx = bad_idx;
    26c6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    26ca:	7033      	strb	r3, [r6, #0]
    26cc:	e003      	b.n	26d6 <nffs_restore_full+0xee>
         * a garbage collection cycle.  Look for a candidate scratch area.
         */
        rc = nffs_restore_corrupt_scratch();
        if (rc != 0) {
            if (rc == FS_ENOENT) {
                rc = FS_ECORRUPT;
    26ce:	2c06      	cmp	r4, #6
    26d0:	bf08      	it	eq
    26d2:	2401      	moveq	r4, #1
    26d4:	e016      	b.n	2704 <nffs_restore_full+0x11c>
            goto err;
        }
    }

    /* Ensure this file system contains a valid scratch area. */
    rc = nffs_misc_validate_scratch();
    26d6:	f7ff f9a5 	bl	1a24 <nffs_misc_validate_scratch>
    if (rc != 0) {
    26da:	4604      	mov	r4, r0
    26dc:	b990      	cbnz	r0, 2704 <nffs_restore_full+0x11c>
        goto err;
    }

    /* Make sure the file system contains a valid root directory. */
    rc = nffs_misc_validate_root_dir();
    26de:	f7ff f989 	bl	19f4 <nffs_misc_validate_root_dir>
    if (rc != 0) {
    26e2:	4604      	mov	r4, r0
    26e4:	b970      	cbnz	r0, 2704 <nffs_restore_full+0x11c>
        goto err;
    }

    /* Ensure there is a "/lost+found" directory. */
    rc = nffs_misc_create_lost_found_dir();
    26e6:	f7ff fa6b 	bl	1bc0 <nffs_misc_create_lost_found_dir>
    if (rc != 0) {
    26ea:	4604      	mov	r4, r0
    26ec:	b950      	cbnz	r0, 2704 <nffs_restore_full+0x11c>
    }

    /* Delete from RAM any objects that were invalidated when subsequent areas
     * were restored.
     */
    nffs_restore_sweep();
    26ee:	f7ff fe87 	bl	2400 <nffs_restore_sweep>

    /* Set the maximum data block size according to the size of the smallest
     * area.
     */
    rc = nffs_misc_set_max_block_data_len(nffs_restore_largest_block_data_len);
    26f2:	8838      	ldrh	r0, [r7, #0]
    26f4:	f7ff fa34 	bl	1b60 <nffs_misc_set_max_block_data_len>
    if (rc != 0) {
    26f8:	4604      	mov	r4, r0
    26fa:	b918      	cbnz	r0, 2704 <nffs_restore_full+0x11c>
    26fc:	e004      	b.n	2708 <nffs_restore_full+0x120>
    nffs_current_area_descs = (struct nffs_area_desc*) area_descs;

    /* Read each area from flash. */
    for (i = 0; area_descs[i].nad_length != 0; i++) {
        if (i > NFFS_MAX_AREAS) {
            rc = FS_EINVAL;
    26fe:	2404      	movs	r4, #4
    2700:	e000      	b.n	2704 <nffs_restore_full+0x11c>
    int rc;

    rc = hal_flash_read(flash_id, area_offset, out_disk_area,
                        sizeof *out_disk_area);
    if (rc != 0) {
        return FS_EHW;
    2702:	2402      	movs	r4, #2
    nffs_log_contents();

    return 0;

err:
    nffs_misc_reset();
    2704:	f7ff fa70 	bl	1be8 <nffs_misc_reset>
    }

    NFFS_LOG(DEBUG, "CONTENTS\n");
    nffs_log_contents();

    return 0;
    2708:	4620      	mov	r0, r4
    270a:	e028      	b.n	275e <nffs_restore_full+0x176>
            }
        }

        if (use_area) {
            /* Populate RAM with a representation of this area. */
            cur_area_idx = nffs_num_areas;
    270c:	4b19      	ldr	r3, [pc, #100]	; (2774 <nffs_restore_full+0x18c>)
    270e:	781e      	ldrb	r6, [r3, #0]

            rc = nffs_misc_set_num_areas(nffs_num_areas + 1);
    2710:	1c70      	adds	r0, r6, #1
    2712:	b2c0      	uxtb	r0, r0
    2714:	f7ff fa0c 	bl	1b30 <nffs_misc_set_num_areas>
            if (rc != 0) {
    2718:	4604      	mov	r4, r0
    271a:	2800      	cmp	r0, #0
    271c:	d1f2      	bne.n	2704 <nffs_restore_full+0x11c>
                goto err;
            }

            nffs_areas[cur_area_idx].na_offset = area_descs[i].nad_offset;
    271e:	4b16      	ldr	r3, [pc, #88]	; (2778 <nffs_restore_full+0x190>)
    2720:	f855 0c04 	ldr.w	r0, [r5, #-4]
    2724:	6819      	ldr	r1, [r3, #0]
    2726:	0132      	lsls	r2, r6, #4
    2728:	188b      	adds	r3, r1, r2
    272a:	5088      	str	r0, [r1, r2]
            nffs_areas[cur_area_idx].na_length = area_descs[i].nad_length;
    272c:	682a      	ldr	r2, [r5, #0]
    272e:	605a      	str	r2, [r3, #4]
            nffs_areas[cur_area_idx].na_flash_id = area_descs[i].nad_flash_id;
    2730:	792a      	ldrb	r2, [r5, #4]
    2732:	73da      	strb	r2, [r3, #15]
            nffs_areas[cur_area_idx].na_gc_seq = disk_area.nda_gc_seq;
    2734:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    2738:	739a      	strb	r2, [r3, #14]
            nffs_areas[cur_area_idx].na_id = disk_area.nda_id;
    273a:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    273e:	819a      	strh	r2, [r3, #12]

            if (disk_area.nda_id == NFFS_AREA_ID_NONE) {
    2740:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    2744:	2aff      	cmp	r2, #255	; 0xff
    2746:	d104      	bne.n	2752 <nffs_restore_full+0x16a>
                nffs_areas[cur_area_idx].na_cur = NFFS_AREA_OFFSET_ID;
    2748:	2217      	movs	r2, #23
    274a:	609a      	str	r2, [r3, #8]
                nffs_scratch_area_idx = cur_area_idx;
    274c:	4b07      	ldr	r3, [pc, #28]	; (276c <nffs_restore_full+0x184>)
    274e:	701e      	strb	r6, [r3, #0]
    2750:	e777      	b.n	2642 <nffs_restore_full+0x5a>
            } else {
                nffs_areas[cur_area_idx].na_cur =
    2752:	2218      	movs	r2, #24
    2754:	609a      	str	r2, [r3, #8]
                    sizeof (struct nffs_disk_area);
                nffs_restore_area_contents(cur_area_idx);
    2756:	4630      	mov	r0, r6
    2758:	f7ff fc22 	bl	1fa0 <nffs_restore_area_contents>
    275c:	e771      	b.n	2642 <nffs_restore_full+0x5a>
    return 0;

err:
    nffs_misc_reset();
    return rc;
}
    275e:	b00a      	add	sp, #40	; 0x28
    2760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2764:	200005fe 	.word	0x200005fe
    2768:	20000b04 	.word	0x20000b04
    276c:	20000aa4 	.word	0x20000aa4
    2770:	20000ca4 	.word	0x20000ca4
    2774:	20000b24 	.word	0x20000b24
    2778:	20000b40 	.word	0x20000b40

0000277c <nffs_write_to_file>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_write_to_file(struct nffs_file *file, const void *data, int len)
{
    277c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    struct nffs_cache_inode *cache_inode;
    const uint8_t *data_ptr;
    uint16_t chunk_size;
    int rc;

    if (!(file->nf_access_flags & FS_ACCESS_WRITE)) {
    2780:	7a03      	ldrb	r3, [r0, #8]
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_write_to_file(struct nffs_file *file, const void *data, int len)
{
    2782:	b09d      	sub	sp, #116	; 0x74
    2784:	4693      	mov	fp, r2
    struct nffs_cache_inode *cache_inode;
    const uint8_t *data_ptr;
    uint16_t chunk_size;
    int rc;

    if (!(file->nf_access_flags & FS_ACCESS_WRITE)) {
    2786:	079a      	lsls	r2, r3, #30
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_write_to_file(struct nffs_file *file, const void *data, int len)
{
    2788:	4680      	mov	r8, r0
    278a:	9104      	str	r1, [sp, #16]
    struct nffs_cache_inode *cache_inode;
    const uint8_t *data_ptr;
    uint16_t chunk_size;
    int rc;

    if (!(file->nf_access_flags & FS_ACCESS_WRITE)) {
    278c:	f140 81bc 	bpl.w	2b08 <nffs_write_to_file+0x38c>
        return FS_EACCESS;
    }

    if (len == 0) {
    2790:	f1bb 0f00 	cmp.w	fp, #0
    2794:	d101      	bne.n	279a <nffs_write_to_file+0x1e>
        return 0;
    2796:	2000      	movs	r0, #0
    2798:	e1b9      	b.n	2b0e <nffs_write_to_file+0x392>
    }

    rc = nffs_cache_inode_ensure(&cache_inode, file->nf_inode_entry);
    279a:	a80d      	add	r0, sp, #52	; 0x34
    279c:	f8d8 1000 	ldr.w	r1, [r8]
    27a0:	f7fd ffb4 	bl	70c <nffs_cache_inode_ensure>
    if (rc != 0) {
    27a4:	2800      	cmp	r0, #0
    27a6:	f040 81b2 	bne.w	2b0e <nffs_write_to_file+0x392>
    }

    /* The append flag forces all writes to the end of the file, regardless of
     * seek position.
     */
    if (file->nf_access_flags & FS_ACCESS_APPEND) {
    27aa:	f898 3008 	ldrb.w	r3, [r8, #8]
    27ae:	075b      	lsls	r3, r3, #29
    27b0:	d563      	bpl.n	287a <nffs_write_to_file+0xfe>
        file->nf_offset = cache_inode->nci_file_size;
    27b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    27b4:	6a1b      	ldr	r3, [r3, #32]
    27b6:	f8c8 3004 	str.w	r3, [r8, #4]
    27ba:	e05e      	b.n	287a <nffs_write_to_file+0xfe>
    uint16_t chunk_sz;
    int rc;

    assert(data_len <= nffs_block_max_data_sz);

    rc = nffs_cache_inode_ensure(&cache_inode, inode_entry);
    27bc:	a80e      	add	r0, sp, #56	; 0x38
    27be:	f7fd ffa5 	bl	70c <nffs_cache_inode_ensure>
    if (rc != 0) {
    27c2:	4682      	mov	sl, r0
    27c4:	2800      	cmp	r0, #0
    27c6:	f040 81a1 	bne.w	2b0c <nffs_write_to_file+0x390>
        return rc;
    }

    /** Handle the simple append case first. */
    if (file_offset == cache_inode->nci_file_size) {
    27ca:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    27cc:	9a03      	ldr	r2, [sp, #12]
    27ce:	6a23      	ldr	r3, [r4, #32]
    27d0:	429a      	cmp	r2, r3
    27d2:	d16c      	bne.n	28ae <nffs_write_to_file+0x132>
    struct nffs_disk_block disk_block;
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    rc = nffs_block_entry_reserve(&entry);
    27d4:	a811      	add	r0, sp, #68	; 0x44
    27d6:	f000 fa49 	bl	2c6c <nffs_block_entry_reserve>
    if (entry == NULL) {
    27da:	9b11      	ldr	r3, [sp, #68]	; 0x44
    27dc:	2b00      	cmp	r3, #0
    27de:	d061      	beq.n	28a4 <nffs_write_to_file+0x128>
        return FS_ENOMEM;
    }

    inode_entry = cache_inode->nci_inode.ni_inode_entry;

    disk_block.ndb_id = nffs_hash_next_block_id++;
    27e0:	4aa1      	ldr	r2, [pc, #644]	; (2a68 <nffs_write_to_file+0x2ec>)
    rc = nffs_block_entry_reserve(&entry);
    if (entry == NULL) {
        return FS_ENOMEM;
    }

    inode_entry = cache_inode->nci_inode.ni_inode_entry;
    27e2:	68a5      	ldr	r5, [r4, #8]

    disk_block.ndb_id = nffs_hash_next_block_id++;
    27e4:	6813      	ldr	r3, [r2, #0]
    27e6:	9317      	str	r3, [sp, #92]	; 0x5c
    27e8:	1c59      	adds	r1, r3, #1
    disk_block.ndb_seq = 0;
    disk_block.ndb_inode_id = inode_entry->nie_hash_entry.nhe_id;
    27ea:	686b      	ldr	r3, [r5, #4]
    }

    inode_entry = cache_inode->nci_inode.ni_inode_entry;

    disk_block.ndb_id = nffs_hash_next_block_id++;
    disk_block.ndb_seq = 0;
    27ec:	f8ad a068 	strh.w	sl, [sp, #104]	; 0x68
    disk_block.ndb_inode_id = inode_entry->nie_hash_entry.nhe_id;
    27f0:	9318      	str	r3, [sp, #96]	; 0x60
    if (inode_entry->nie_last_block_entry == NULL) {
    27f2:	692b      	ldr	r3, [r5, #16]
        return FS_ENOMEM;
    }

    inode_entry = cache_inode->nci_inode.ni_inode_entry;

    disk_block.ndb_id = nffs_hash_next_block_id++;
    27f4:	6011      	str	r1, [r2, #0]
    disk_block.ndb_seq = 0;
    disk_block.ndb_inode_id = inode_entry->nie_hash_entry.nhe_id;
    if (inode_entry->nie_last_block_entry == NULL) {
    27f6:	2b00      	cmp	r3, #0
    27f8:	d152      	bne.n	28a0 <nffs_write_to_file+0x124>
        disk_block.ndb_prev_id = NFFS_ID_NONE;
    27fa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    } else {
        disk_block.ndb_prev_id = inode_entry->nie_last_block_entry->nhe_id;
    }
    disk_block.ndb_data_len = len;
    nffs_crc_disk_block_fill(&disk_block, data);
    27fe:	a817      	add	r0, sp, #92	; 0x5c
    2800:	9904      	ldr	r1, [sp, #16]
    disk_block.ndb_seq = 0;
    disk_block.ndb_inode_id = inode_entry->nie_hash_entry.nhe_id;
    if (inode_entry->nie_last_block_entry == NULL) {
        disk_block.ndb_prev_id = NFFS_ID_NONE;
    } else {
        disk_block.ndb_prev_id = inode_entry->nie_last_block_entry->nhe_id;
    2802:	9319      	str	r3, [sp, #100]	; 0x64
    }
    disk_block.ndb_data_len = len;
    2804:	f8ad 706c 	strh.w	r7, [sp, #108]	; 0x6c
    nffs_crc_disk_block_fill(&disk_block, data);
    2808:	f000 fb93 	bl	2f32 <nffs_crc_disk_block_fill>

    rc = nffs_block_write_disk(&disk_block, data, &area_idx, &area_offset);
    280c:	a817      	add	r0, sp, #92	; 0x5c
    280e:	9904      	ldr	r1, [sp, #16]
    2810:	aa10      	add	r2, sp, #64	; 0x40
    2812:	ab12      	add	r3, sp, #72	; 0x48
    2814:	f000 fa45 	bl	2ca2 <nffs_block_write_disk>
    if (rc != 0) {
    2818:	4606      	mov	r6, r0
    281a:	2800      	cmp	r0, #0
    281c:	d145      	bne.n	28aa <nffs_write_to_file+0x12e>
        return rc;
    }

    entry->nhe_id = disk_block.ndb_id;
    281e:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    2822:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    2824:	f8c9 3004 	str.w	r3, [r9, #4]
    entry->nhe_flash_loc = nffs_flash_loc(area_idx, area_offset);
    2828:	9912      	ldr	r1, [sp, #72]	; 0x48
    282a:	f89d 0040 	ldrb.w	r0, [sp, #64]	; 0x40
    282e:	f7fe faab 	bl	d88 <nffs_flash_loc>
    2832:	f8c9 0008 	str.w	r0, [r9, #8]
    nffs_hash_insert(entry);
    2836:	9811      	ldr	r0, [sp, #68]	; 0x44
    2838:	f7fe fb9c 	bl	f74 <nffs_hash_insert>

    inode_entry->nie_last_block_entry = entry;
    283c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    283e:	612b      	str	r3, [r5, #16]
     * Need to be written atomically with writing the block out so filesystem
     * remains consistent. nffs_lock is held in nffs_write().
     * The inode will not be updated if it's been unlinked on disk and this
     * is signaled by setting the hash entry's flash location to NONE
     */
    if (inode_entry->nie_hash_entry.nhe_flash_loc != NFFS_FLASH_LOC_NONE) {
    2840:	20ff      	movs	r0, #255	; 0xff
    2842:	4631      	mov	r1, r6
    2844:	f8d5 9008 	ldr.w	r9, [r5, #8]
    2848:	f7fe fa9e 	bl	d88 <nffs_flash_loc>
    284c:	4581      	cmp	r9, r0
    284e:	d002      	beq.n	2856 <nffs_write_to_file+0xda>
        rc = nffs_inode_update(inode_entry);
    2850:	4628      	mov	r0, r5
    2852:	f7ff f83d 	bl	18d0 <nffs_inode_update>
    }

    /* Update cached inode with the new file size. */
    cache_inode->nci_file_size += len;
    2856:	6a21      	ldr	r1, [r4, #32]
    2858:	4439      	add	r1, r7
    285a:	6221      	str	r1, [r4, #32]

    /* Add appended block to the cache. */
    nffs_cache_seek(cache_inode, cache_inode->nci_file_size - 1, NULL);
    285c:	4620      	mov	r0, r4
    285e:	3901      	subs	r1, #1
    2860:	2200      	movs	r2, #0
    2862:	f7fd ffcb 	bl	7fc <nffs_cache_seek>
        if (rc != 0) {
            return rc;
        }

        len -= chunk_size;
        data_ptr += chunk_size;
    2866:	9b04      	ldr	r3, [sp, #16]
    2868:	443b      	add	r3, r7
    286a:	9304      	str	r3, [sp, #16]
        file->nf_offset += chunk_size;
    286c:	f8d8 3004 	ldr.w	r3, [r8, #4]
                              chunk_size);
        if (rc != 0) {
            return rc;
        }

        len -= chunk_size;
    2870:	ebc7 0b0b 	rsb	fp, r7, fp
        data_ptr += chunk_size;
        file->nf_offset += chunk_size;
    2874:	441f      	add	r7, r3
    2876:	f8c8 7004 	str.w	r7, [r8, #4]
        file->nf_offset = cache_inode->nci_file_size;
    }

    /* Write data as a sequence of blocks. */
    data_ptr = data;
    while (len > 0) {
    287a:	f1bb 0f00 	cmp.w	fp, #0
    287e:	dd8a      	ble.n	2796 <nffs_write_to_file+0x1a>
        if (len > nffs_block_max_data_sz) {
    2880:	4b7a      	ldr	r3, [pc, #488]	; (2a6c <nffs_write_to_file+0x2f0>)
    2882:	881b      	ldrh	r3, [r3, #0]
            chunk_size = nffs_block_max_data_sz;
        } else {
            chunk_size = len;
        }

        rc = nffs_write_chunk(file->nf_inode_entry, file->nf_offset, data_ptr,
    2884:	e898 0006 	ldmia.w	r8, {r1, r2}
    }

    /* Write data as a sequence of blocks. */
    data_ptr = data;
    while (len > 0) {
        if (len > nffs_block_max_data_sz) {
    2888:	459b      	cmp	fp, r3
            chunk_size = nffs_block_max_data_sz;
        } else {
            chunk_size = len;
    288a:	bfd4      	ite	le
    288c:	fa1f f78b 	uxthle.w	r7, fp

    /* Write data as a sequence of blocks. */
    data_ptr = data;
    while (len > 0) {
        if (len > nffs_block_max_data_sz) {
            chunk_size = nffs_block_max_data_sz;
    2890:	461f      	movgt	r7, r3
    uint32_t dst_off;
    uint16_t chunk_off;
    uint16_t chunk_sz;
    int rc;

    assert(data_len <= nffs_block_max_data_sz);
    2892:	429f      	cmp	r7, r3
            chunk_size = nffs_block_max_data_sz;
        } else {
            chunk_size = len;
        }

        rc = nffs_write_chunk(file->nf_inode_entry, file->nf_offset, data_ptr,
    2894:	9203      	str	r2, [sp, #12]
    uint32_t dst_off;
    uint16_t chunk_off;
    uint16_t chunk_sz;
    int rc;

    assert(data_len <= nffs_block_max_data_sz);
    2896:	d991      	bls.n	27bc <nffs_write_to_file+0x40>
    2898:	4875      	ldr	r0, [pc, #468]	; (2a70 <nffs_write_to_file+0x2f4>)
    289a:	f44f 7195 	mov.w	r1, #298	; 0x12a
    289e:	e10f      	b.n	2ac0 <nffs_write_to_file+0x344>
    disk_block.ndb_seq = 0;
    disk_block.ndb_inode_id = inode_entry->nie_hash_entry.nhe_id;
    if (inode_entry->nie_last_block_entry == NULL) {
        disk_block.ndb_prev_id = NFFS_ID_NONE;
    } else {
        disk_block.ndb_prev_id = inode_entry->nie_last_block_entry->nhe_id;
    28a0:	685b      	ldr	r3, [r3, #4]
    28a2:	e7ac      	b.n	27fe <nffs_write_to_file+0x82>
    uint8_t area_idx;
    int rc;

    rc = nffs_block_entry_reserve(&entry);
    if (entry == NULL) {
        return FS_ENOMEM;
    28a4:	f04f 0a05 	mov.w	sl, #5
    28a8:	e130      	b.n	2b0c <nffs_write_to_file+0x390>
    }
    disk_block.ndb_data_len = len;
    nffs_crc_disk_block_fill(&disk_block, data);

    rc = nffs_block_write_disk(&disk_block, data, &area_idx, &area_offset);
    if (rc != 0) {
    28aa:	4682      	mov	sl, r0
    28ac:	e12e      	b.n	2b0c <nffs_write_to_file+0x390>
        return rc;
    }

    /** This is not an append; i.e., old data is getting overwritten. */

    dst_off = file_offset + data_len;
    28ae:	9a03      	ldr	r2, [sp, #12]
    data_offset = data_len;
    cache_block = NULL;
    28b0:	900f      	str	r0, [sp, #60]	; 0x3c
        return rc;
    }

    /** This is not an append; i.e., old data is getting overwritten. */

    dst_off = file_offset + data_len;
    28b2:	eb07 0902 	add.w	r9, r7, r2
    data_offset = data_len;
    cache_block = NULL;

    if (dst_off > cache_inode->nci_file_size) {
    28b6:	4599      	cmp	r9, r3
        append_len = dst_off - cache_inode->nci_file_size;
    28b8:	bf86      	itte	hi
    28ba:	ebc3 0309 	rsbhi	r3, r3, r9
    28be:	9308      	strhi	r3, [sp, #32]
    } else {
        append_len = 0;
    28c0:	f8cd a020 	strls.w	sl, [sp, #32]
    }

    do {
        if (cache_block == NULL) {
    28c4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    28c6:	b94b      	cbnz	r3, 28dc <nffs_write_to_file+0x160>
            rc = nffs_cache_seek(cache_inode, dst_off - 1, &cache_block);
    28c8:	980e      	ldr	r0, [sp, #56]	; 0x38
    28ca:	f109 31ff 	add.w	r1, r9, #4294967295	; 0xffffffff
    28ce:	aa0f      	add	r2, sp, #60	; 0x3c
    28d0:	f7fd ff94 	bl	7fc <nffs_cache_seek>
            if (rc != 0) {
    28d4:	4682      	mov	sl, r0
    28d6:	2800      	cmp	r0, #0
    28d8:	f040 8118 	bne.w	2b0c <nffs_write_to_file+0x390>
                return rc;
            }
        }

        if (cache_block->ncb_file_offset < file_offset) {
    28dc:	990f      	ldr	r1, [sp, #60]	; 0x3c
    28de:	9b03      	ldr	r3, [sp, #12]
    28e0:	69ca      	ldr	r2, [r1, #28]
    28e2:	429a      	cmp	r2, r3
            chunk_off = file_offset - cache_block->ncb_file_offset;
    28e4:	bf38      	it	cc
    28e6:	1a9c      	subcc	r4, r3, r2
        } else {
            chunk_off = 0;
        }

        chunk_sz = cache_block->ncb_block.nb_data_len - chunk_off;
    28e8:	8b0b      	ldrh	r3, [r1, #24]
                return rc;
            }
        }

        if (cache_block->ncb_file_offset < file_offset) {
            chunk_off = file_offset - cache_block->ncb_file_offset;
    28ea:	bf34      	ite	cc
    28ec:	b2a4      	uxthcc	r4, r4
        } else {
            chunk_off = 0;
    28ee:	2400      	movcs	r4, #0
        }

        chunk_sz = cache_block->ncb_block.nb_data_len - chunk_off;
    28f0:	1b1e      	subs	r6, r3, r4
        block_end = cache_block->ncb_file_offset +
    28f2:	4413      	add	r3, r2
                    cache_block->ncb_block.nb_data_len;
        if (block_end != dst_off) {
    28f4:	454b      	cmp	r3, r9
            chunk_sz += (int)(dst_off - block_end);
    28f6:	bf18      	it	ne
    28f8:	ebc3 0309 	rsbne	r3, r3, r9
            chunk_off = file_offset - cache_block->ncb_file_offset;
        } else {
            chunk_off = 0;
        }

        chunk_sz = cache_block->ncb_block.nb_data_len - chunk_off;
    28fc:	b2b6      	uxth	r6, r6
        block_end = cache_block->ncb_file_offset +
                    cache_block->ncb_block.nb_data_len;
        if (block_end != dst_off) {
            chunk_sz += (int)(dst_off - block_end);
    28fe:	bf18      	it	ne
    2900:	18f6      	addne	r6, r6, r3

        /* Remember the current garbage collection count.  If the count
         * increases during the write, then the block cache has been
         * invalidated and we need to reset our pointers.
         */
        gc_count = nffs_gc_count;
    2902:	4b5c      	ldr	r3, [pc, #368]	; (2a74 <nffs_write_to_file+0x2f8>)
    2904:	681b      	ldr	r3, [r3, #0]
    2906:	930a      	str	r3, [sp, #40]	; 0x28
    2908:	9b03      	ldr	r3, [sp, #12]
    290a:	eba2 0203 	sub.w	r2, r2, r3

        data_offset = cache_block->ncb_file_offset + chunk_off - file_offset;
    290e:	eb02 0304 	add.w	r3, r2, r4
    2912:	9306      	str	r3, [sp, #24]
        rc = nffs_write_over_block(cache_block->ncb_block.nb_hash_entry,
    2914:	688b      	ldr	r3, [r1, #8]
    2916:	9305      	str	r3, [sp, #20]
    uint16_t block_off;
    uint8_t src_area_idx;
    uint8_t dst_area_idx;
    int rc;

    rc = nffs_block_from_hash_entry(&block, entry);
    2918:	a817      	add	r0, sp, #92	; 0x5c
    291a:	4619      	mov	r1, r3

        chunk_sz = cache_block->ncb_block.nb_data_len - chunk_off;
        block_end = cache_block->ncb_file_offset +
                    cache_block->ncb_block.nb_data_len;
        if (block_end != dst_off) {
            chunk_sz += (int)(dst_off - block_end);
    291c:	bf18      	it	ne
    291e:	b2b6      	uxthne	r6, r6
    uint16_t block_off;
    uint8_t src_area_idx;
    uint8_t dst_area_idx;
    int rc;

    rc = nffs_block_from_hash_entry(&block, entry);
    2920:	f000 fa58 	bl	2dd4 <nffs_block_from_hash_entry>
    if (rc != 0) {
    2924:	4682      	mov	sl, r0
    2926:	2800      	cmp	r0, #0
    2928:	f040 80f0 	bne.w	2b0c <nffs_write_to_file+0x390>
        return rc;
    }

    assert(left_copy_len <= block.nb_data_len);
    292c:	f8bd 506c 	ldrh.w	r5, [sp, #108]	; 0x6c
    2930:	42ac      	cmp	r4, r5
    2932:	d905      	bls.n	2940 <nffs_write_to_file+0x1c4>
    2934:	484e      	ldr	r0, [pc, #312]	; (2a70 <nffs_write_to_file+0x2f4>)
    2936:	2170      	movs	r1, #112	; 0x70
    2938:	4652      	mov	r2, sl
    293a:	4613      	mov	r3, r2
    293c:	f002 f986 	bl	4c4c <__assert_func>

    /* Determine how much old data at the end of the block needs to be
     * retained.  If the new data doesn't extend to the end of the block, the
     * the rest of the block retains its old contents.
     */
    if (left_copy_len + new_data_len > block.nb_data_len) {
    2940:	19a3      	adds	r3, r4, r6
    2942:	42ab      	cmp	r3, r5
         * invalidated and we need to reset our pointers.
         */
        gc_count = nffs_gc_count;

        data_offset = cache_block->ncb_file_offset + chunk_off - file_offset;
        rc = nffs_write_over_block(cache_block->ncb_block.nb_hash_entry,
    2944:	9a06      	ldr	r2, [sp, #24]
    2946:	9b04      	ldr	r3, [sp, #16]
    2948:	4413      	add	r3, r2
    294a:	9307      	str	r3, [sp, #28]
        right_copy_len = 0;
    } else {
        right_copy_len = block.nb_data_len - left_copy_len - new_data_len;
    }

    block.nb_seq++;
    294c:	9b18      	ldr	r3, [sp, #96]	; 0x60
     * the rest of the block retains its old contents.
     */
    if (left_copy_len + new_data_len > block.nb_data_len) {
        right_copy_len = 0;
    } else {
        right_copy_len = block.nb_data_len - left_copy_len - new_data_len;
    294e:	bfdc      	itt	le
    2950:	1b2d      	suble	r5, r5, r4
    2952:	1bad      	suble	r5, r5, r6
    }

    block.nb_seq++;
    2954:	f103 0301 	add.w	r3, r3, #1
    /* Determine how much old data at the end of the block needs to be
     * retained.  If the new data doesn't extend to the end of the block, the
     * the rest of the block retains its old contents.
     */
    if (left_copy_len + new_data_len > block.nb_data_len) {
        right_copy_len = 0;
    2958:	bfcc      	ite	gt
    295a:	4605      	movgt	r5, r0
    } else {
        right_copy_len = block.nb_data_len - left_copy_len - new_data_len;
    295c:	b2ad      	uxthle	r5, r5
    }

    block.nb_seq++;
    295e:	9318      	str	r3, [sp, #96]	; 0x60
    block.nb_data_len = left_copy_len + new_data_len + right_copy_len;
    2960:	1933      	adds	r3, r6, r4
    2962:	442b      	add	r3, r5
    nffs_block_to_disk(&block, &disk_block);
    2964:	a817      	add	r0, sp, #92	; 0x5c
    2966:	a912      	add	r1, sp, #72	; 0x48
    } else {
        right_copy_len = block.nb_data_len - left_copy_len - new_data_len;
    }

    block.nb_seq++;
    block.nb_data_len = left_copy_len + new_data_len + right_copy_len;
    2968:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    nffs_block_to_disk(&block, &disk_block);
    296c:	f000 f9c4 	bl	2cf8 <nffs_block_to_disk>

    nffs_flash_loc_expand(entry->nhe_flash_loc,
    2970:	9b05      	ldr	r3, [sp, #20]
    2972:	f10d 0132 	add.w	r1, sp, #50	; 0x32
    2976:	6898      	ldr	r0, [r3, #8]
    2978:	aa10      	add	r2, sp, #64	; 0x40
    297a:	f7fe fa15 	bl	da8 <nffs_flash_loc_expand>
                          &src_area_idx, &src_area_offset);

    rc = nffs_write_fill_crc16_overwrite(&disk_block,
    297e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    2980:	f89d a032 	ldrb.w	sl, [sp, #50]	; 0x32
    2984:	9309      	str	r3, [sp, #36]	; 0x24
    uint16_t crc16;
    int rc;

    block_off = 0;

    crc16 = nffs_crc_disk_block_hdr(disk_block);
    2986:	a812      	add	r0, sp, #72	; 0x48
    2988:	f000 fab4 	bl	2ef4 <nffs_crc_disk_block_hdr>
    298c:	f8ad 0044 	strh.w	r0, [sp, #68]	; 0x44
    block_off += sizeof *disk_block;

    /* Copy data from the start of the old block, in case the new data starts
     * at a non-zero offset.
     */
    if (left_copy_len > 0) {
    2990:	b174      	cbz	r4, 29b0 <nffs_write_to_file+0x234>
        rc = nffs_crc_flash(crc16, src_area_idx, src_area_offset + block_off,
    2992:	ab11      	add	r3, sp, #68	; 0x44
    2994:	9300      	str	r3, [sp, #0]
    2996:	9b09      	ldr	r3, [sp, #36]	; 0x24
    2998:	4651      	mov	r1, sl
    299a:	f103 0214 	add.w	r2, r3, #20
    299e:	4623      	mov	r3, r4
    29a0:	f000 fa84 	bl	2eac <nffs_crc_flash>
                            left_copy_len, &crc16);
        if (rc != 0) {
    29a4:	bba0      	cbnz	r0, 2a10 <nffs_write_to_file+0x294>
            return rc;
        }
        block_off += left_copy_len;
    29a6:	f104 0c14 	add.w	ip, r4, #20
    29aa:	fa1f fc8c 	uxth.w	ip, ip
    29ae:	e001      	b.n	29b4 <nffs_write_to_file+0x238>
    int rc;

    block_off = 0;

    crc16 = nffs_crc_disk_block_hdr(disk_block);
    block_off += sizeof *disk_block;
    29b0:	f04f 0c14 	mov.w	ip, #20
    }

    /* Write the new data into the data block.  This may extend the block's
     * length beyond its old value.
     */
    crc16 = crc16_ccitt(crc16, new_data, new_data_len);
    29b4:	f8bd 0044 	ldrh.w	r0, [sp, #68]	; 0x44
    29b8:	9907      	ldr	r1, [sp, #28]
    29ba:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
    29be:	4632      	mov	r2, r6
    29c0:	f002 fd60 	bl	5484 <crc16_ccitt>
    block_off += new_data_len;
    29c4:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    }

    /* Write the new data into the data block.  This may extend the block's
     * length beyond its old value.
     */
    crc16 = crc16_ccitt(crc16, new_data, new_data_len);
    29c8:	f8ad 0044 	strh.w	r0, [sp, #68]	; 0x44
    block_off += new_data_len;
    29cc:	44b4      	add	ip, r6
    29ce:	fa1f fc8c 	uxth.w	ip, ip

    /* Copy data from the end of the old block, in case the new data doesn't
     * extend to the end of the block.
     */
    if (right_copy_len > 0) {
    29d2:	b185      	cbz	r5, 29f6 <nffs_write_to_file+0x27a>
        rc = nffs_crc_flash(crc16, src_area_idx, src_area_offset + block_off,
    29d4:	ab11      	add	r3, sp, #68	; 0x44
    29d6:	9300      	str	r3, [sp, #0]
    29d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    29da:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
    29de:	4463      	add	r3, ip
    29e0:	461a      	mov	r2, r3
    29e2:	4651      	mov	r1, sl
    29e4:	462b      	mov	r3, r5
    29e6:	f000 fa61 	bl	2eac <nffs_crc_flash>
                            right_copy_len, &crc16);
        if (rc != 0) {
    29ea:	b988      	cbnz	r0, 2a10 <nffs_write_to_file+0x294>
            return rc;
        }
        block_off += right_copy_len;
    29ec:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    29f0:	44ac      	add	ip, r5
    29f2:	fa1f fc8c 	uxth.w	ip, ip
    }

    assert(block_off == sizeof *disk_block + disk_block->ndb_data_len);
    29f6:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    29fa:	3314      	adds	r3, #20
    29fc:	459c      	cmp	ip, r3
    29fe:	d002      	beq.n	2a06 <nffs_write_to_file+0x28a>
    2a00:	481b      	ldr	r0, [pc, #108]	; (2a70 <nffs_write_to_file+0x2f4>)
    2a02:	2146      	movs	r1, #70	; 0x46
    2a04:	e05c      	b.n	2ac0 <nffs_write_to_file+0x344>

    disk_block->ndb_crc16 = crc16;
    2a06:	f8bd 3044 	ldrh.w	r3, [sp, #68]	; 0x44
    2a0a:	f8ad 305a 	strh.w	r3, [sp, #90]	; 0x5a
    2a0e:	e002      	b.n	2a16 <nffs_write_to_file+0x29a>
     * extend to the end of the block.
     */
    if (right_copy_len > 0) {
        rc = nffs_crc_flash(crc16, src_area_idx, src_area_offset + block_off,
                            right_copy_len, &crc16);
        if (rc != 0) {
    2a10:	4682      	mov	sl, r0

    rc = nffs_write_fill_crc16_overwrite(&disk_block,
                                         src_area_idx, src_area_offset,
                                         left_copy_len, right_copy_len,
                                         new_data, new_data_len);
    if (rc != 0) {
    2a12:	2800      	cmp	r0, #0
    2a14:	d17a      	bne.n	2b0c <nffs_write_to_file+0x390>
        return rc;
    }

    rc = nffs_misc_reserve_space(sizeof disk_block + disk_block.ndb_data_len,
    2a16:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
    2a1a:	3014      	adds	r0, #20
    2a1c:	b280      	uxth	r0, r0
    2a1e:	f10d 0133 	add.w	r1, sp, #51	; 0x33
    2a22:	aa11      	add	r2, sp, #68	; 0x44
    2a24:	f7ff f83e 	bl	1aa4 <nffs_misc_reserve_space>
                                 &dst_area_idx, &dst_area_offset);
    if (rc != 0) {
    2a28:	4682      	mov	sl, r0
    2a2a:	2800      	cmp	r0, #0
    2a2c:	d16e      	bne.n	2b0c <nffs_write_to_file+0x390>
    }

    block_off = 0;

    /* Write the block header. */
    rc = nffs_flash_write(dst_area_idx, dst_area_offset + block_off,
    2a2e:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    2a32:	9911      	ldr	r1, [sp, #68]	; 0x44
    2a34:	aa12      	add	r2, sp, #72	; 0x48
    2a36:	2314      	movs	r3, #20
    2a38:	f7fe f956 	bl	ce8 <nffs_flash_write>
                          &disk_block, sizeof disk_block);
    if (rc != 0) {
    2a3c:	4682      	mov	sl, r0
    2a3e:	2800      	cmp	r0, #0
    2a40:	d164      	bne.n	2b0c <nffs_write_to_file+0x390>
    block_off += sizeof disk_block;

    /* Copy data from the start of the old block, in case the new data starts
     * at a non-zero offset.
     */
    if (left_copy_len > 0) {
    2a42:	b1cc      	cbz	r4, 2a78 <nffs_write_to_file+0x2fc>
        rc = nffs_flash_copy(src_area_idx, src_area_offset + block_off,
    2a44:	9910      	ldr	r1, [sp, #64]	; 0x40
    2a46:	9b11      	ldr	r3, [sp, #68]	; 0x44
    2a48:	f89d 0032 	ldrb.w	r0, [sp, #50]	; 0x32
    2a4c:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
    2a50:	9400      	str	r4, [sp, #0]
    2a52:	3114      	adds	r1, #20
    2a54:	3314      	adds	r3, #20
    2a56:	f7fe f971 	bl	d3c <nffs_flash_copy>
                             dst_area_idx, dst_area_offset + block_off,
                             left_copy_len);
        if (rc != 0) {
    2a5a:	4682      	mov	sl, r0
    2a5c:	2800      	cmp	r0, #0
    2a5e:	d155      	bne.n	2b0c <nffs_write_to_file+0x390>
            return rc;
        }
        block_off += left_copy_len;
    2a60:	3414      	adds	r4, #20
    2a62:	b2a4      	uxth	r4, r4
    2a64:	e009      	b.n	2a7a <nffs_write_to_file+0x2fe>
    2a66:	bf00      	nop
    2a68:	20000ca0 	.word	0x20000ca0
    2a6c:	20000b60 	.word	0x20000b60
    2a70:	00006306 	.word	0x00006306
    2a74:	20000cac 	.word	0x20000cac
    rc = nffs_flash_write(dst_area_idx, dst_area_offset + block_off,
                          &disk_block, sizeof disk_block);
    if (rc != 0) {
        return rc;
    }
    block_off += sizeof disk_block;
    2a78:	2414      	movs	r4, #20
    }

    /* Write the new data into the data block.  This may extend the block's
     * length beyond its old value.
     */
    rc = nffs_flash_write(dst_area_idx, dst_area_offset + block_off,
    2a7a:	9911      	ldr	r1, [sp, #68]	; 0x44
    2a7c:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    2a80:	9a07      	ldr	r2, [sp, #28]
    2a82:	4421      	add	r1, r4
    2a84:	4633      	mov	r3, r6
    2a86:	f7fe f92f 	bl	ce8 <nffs_flash_write>
                          new_data, new_data_len);
    if (rc != 0) {
    2a8a:	4682      	mov	sl, r0
    2a8c:	2800      	cmp	r0, #0
    2a8e:	d13d      	bne.n	2b0c <nffs_write_to_file+0x390>
        return rc;
    }
    block_off += new_data_len;
    2a90:	4434      	add	r4, r6
    2a92:	b2a4      	uxth	r4, r4

    /* Copy data from the end of the old block, in case the new data doesn't
     * extend to the end of the block.
     */
    if (right_copy_len > 0) {
    2a94:	b16d      	cbz	r5, 2ab2 <nffs_write_to_file+0x336>
        rc = nffs_flash_copy(src_area_idx, src_area_offset + block_off,
    2a96:	9910      	ldr	r1, [sp, #64]	; 0x40
    2a98:	9b11      	ldr	r3, [sp, #68]	; 0x44
    2a9a:	f89d 0032 	ldrb.w	r0, [sp, #50]	; 0x32
    2a9e:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
    2aa2:	9500      	str	r5, [sp, #0]
    2aa4:	4421      	add	r1, r4
    2aa6:	4423      	add	r3, r4
    2aa8:	f7fe f948 	bl	d3c <nffs_flash_copy>
                             dst_area_idx, dst_area_offset + block_off,
                             right_copy_len);
        if (rc != 0) {
    2aac:	b9d8      	cbnz	r0, 2ae6 <nffs_write_to_file+0x36a>
            return rc;
        }
        block_off += right_copy_len;
    2aae:	442c      	add	r4, r5
    2ab0:	b2a4      	uxth	r4, r4
    }

    assert(block_off == sizeof disk_block + block.nb_data_len);
    2ab2:	f8bd 306c 	ldrh.w	r3, [sp, #108]	; 0x6c
    2ab6:	3314      	adds	r3, #20
    2ab8:	429c      	cmp	r4, r3
    2aba:	d003      	beq.n	2ac4 <nffs_write_to_file+0x348>
    2abc:	4815      	ldr	r0, [pc, #84]	; (2b14 <nffs_write_to_file+0x398>)
    2abe:	21bf      	movs	r1, #191	; 0xbf
    2ac0:	2200      	movs	r2, #0
    2ac2:	e73a      	b.n	293a <nffs_write_to_file+0x1be>

    entry->nhe_flash_loc = nffs_flash_loc(dst_area_idx, dst_area_offset);
    2ac4:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    2ac8:	9911      	ldr	r1, [sp, #68]	; 0x44
    2aca:	f7fe f95d 	bl	d88 <nffs_flash_loc>
    2ace:	9b05      	ldr	r3, [sp, #20]
            return rc;
        }

        dst_off -= chunk_sz;

        if (gc_count != nffs_gc_count) {
    2ad0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        block_off += right_copy_len;
    }

    assert(block_off == sizeof disk_block + block.nb_data_len);

    entry->nhe_flash_loc = nffs_flash_loc(dst_area_idx, dst_area_offset);
    2ad2:	6098      	str	r0, [r3, #8]
            return rc;
        }

        dst_off -= chunk_sz;

        if (gc_count != nffs_gc_count) {
    2ad4:	4b10      	ldr	r3, [pc, #64]	; (2b18 <nffs_write_to_file+0x39c>)
    2ad6:	681b      	ldr	r3, [r3, #0]
    2ad8:	429a      	cmp	r2, r3
                                   chunk_off, data + data_offset, chunk_sz);
        if (rc != 0) {
            return rc;
        }

        dst_off -= chunk_sz;
    2ada:	ebc6 0909 	rsb	r9, r6, r9

        if (gc_count != nffs_gc_count) {
    2ade:	d004      	beq.n	2aea <nffs_write_to_file+0x36e>
            /* Garbage collection occurred; the current cached block pointer is
             * invalid, so reset it.  The cached inode is still valid.
             */
            cache_block = NULL;
    2ae0:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
    2ae4:	e006      	b.n	2af4 <nffs_write_to_file+0x378>
     */
    if (right_copy_len > 0) {
        rc = nffs_flash_copy(src_area_idx, src_area_offset + block_off,
                             dst_area_idx, dst_area_offset + block_off,
                             right_copy_len);
        if (rc != 0) {
    2ae6:	4682      	mov	sl, r0
    2ae8:	e010      	b.n	2b0c <nffs_write_to_file+0x390>
            /* Garbage collection occurred; the current cached block pointer is
             * invalid, so reset it.  The cached inode is still valid.
             */
            cache_block = NULL;
        } else {
            cache_block = TAILQ_PREV(cache_block, nffs_cache_block_list,
    2aea:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    2aec:	685b      	ldr	r3, [r3, #4]
    2aee:	685b      	ldr	r3, [r3, #4]
    2af0:	681b      	ldr	r3, [r3, #0]
    2af2:	930f      	str	r3, [sp, #60]	; 0x3c
                                     ncb_link);
        }
    } while (data_offset > 0);
    2af4:	9b06      	ldr	r3, [sp, #24]
    2af6:	2b00      	cmp	r3, #0
    2af8:	f47f aee4 	bne.w	28c4 <nffs_write_to_file+0x148>

    cache_inode->nci_file_size += append_len;
    2afc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    2afe:	9908      	ldr	r1, [sp, #32]
    2b00:	6a13      	ldr	r3, [r2, #32]
    2b02:	440b      	add	r3, r1
    2b04:	6213      	str	r3, [r2, #32]
    2b06:	e6ae      	b.n	2866 <nffs_write_to_file+0xea>
    const uint8_t *data_ptr;
    uint16_t chunk_size;
    int rc;

    if (!(file->nf_access_flags & FS_ACCESS_WRITE)) {
        return FS_EACCESS;
    2b08:	200c      	movs	r0, #12
    2b0a:	e000      	b.n	2b0e <nffs_write_to_file+0x392>
    2b0c:	4650      	mov	r0, sl
        data_ptr += chunk_size;
        file->nf_offset += chunk_size;
    }

    return 0;
}
    2b0e:	b01d      	add	sp, #116	; 0x74
    2b10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2b14:	00006306 	.word	0x00006306
    2b18:	20000cac 	.word	0x20000cac

00002b1c <nffs_area_magic_is_set>:
int
nffs_area_magic_is_set(const struct nffs_disk_area *disk_area)
{
    return disk_area->nda_magic[0] == NFFS_AREA_MAGIC0 &&
           disk_area->nda_magic[1] == NFFS_AREA_MAGIC1 &&
           disk_area->nda_magic[2] == NFFS_AREA_MAGIC2 &&
    2b1c:	6802      	ldr	r2, [r0, #0]
    2b1e:	4b09      	ldr	r3, [pc, #36]	; (2b44 <nffs_area_magic_is_set+0x28>)
    2b20:	429a      	cmp	r2, r3
    2b22:	d10d      	bne.n	2b40 <nffs_area_magic_is_set+0x24>
}

int
nffs_area_magic_is_set(const struct nffs_disk_area *disk_area)
{
    return disk_area->nda_magic[0] == NFFS_AREA_MAGIC0 &&
    2b24:	6842      	ldr	r2, [r0, #4]
    2b26:	4b08      	ldr	r3, [pc, #32]	; (2b48 <nffs_area_magic_is_set+0x2c>)
    2b28:	429a      	cmp	r2, r3
    2b2a:	d109      	bne.n	2b40 <nffs_area_magic_is_set+0x24>
           disk_area->nda_magic[1] == NFFS_AREA_MAGIC1 &&
    2b2c:	6882      	ldr	r2, [r0, #8]
    2b2e:	4b07      	ldr	r3, [pc, #28]	; (2b4c <nffs_area_magic_is_set+0x30>)
    2b30:	429a      	cmp	r2, r3
    2b32:	d105      	bne.n	2b40 <nffs_area_magic_is_set+0x24>
           disk_area->nda_magic[2] == NFFS_AREA_MAGIC2 &&
    2b34:	68c3      	ldr	r3, [r0, #12]
    2b36:	4806      	ldr	r0, [pc, #24]	; (2b50 <nffs_area_magic_is_set+0x34>)
    2b38:	1a1b      	subs	r3, r3, r0
    2b3a:	4258      	negs	r0, r3
    2b3c:	4158      	adcs	r0, r3
    2b3e:	4770      	bx	lr
    2b40:	2000      	movs	r0, #0
           disk_area->nda_magic[3] == NFFS_AREA_MAGIC3;
}
    2b42:	4770      	bx	lr
    2b44:	b98a31e2 	.word	0xb98a31e2
    2b48:	7fb0428c 	.word	0x7fb0428c
    2b4c:	ace08253 	.word	0xace08253
    2b50:	b185fc8e 	.word	0xb185fc8e

00002b54 <nffs_area_is_scratch>:

int
nffs_area_is_scratch(const struct nffs_disk_area *disk_area)
{
    2b54:	b510      	push	{r4, lr}
    2b56:	4604      	mov	r4, r0
    return nffs_area_magic_is_set(disk_area) &&
    2b58:	f7ff ffe0 	bl	2b1c <nffs_area_magic_is_set>
    2b5c:	b120      	cbz	r0, 2b68 <nffs_area_is_scratch+0x14>
    2b5e:	7de0      	ldrb	r0, [r4, #23]
    2b60:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
    2b64:	4258      	negs	r0, r3
    2b66:	4158      	adcs	r0, r3
           disk_area->nda_id == NFFS_AREA_ID_NONE;
}
    2b68:	bd10      	pop	{r4, pc}

00002b6a <nffs_area_is_current_version>:

int
nffs_area_is_current_version(const struct nffs_disk_area *disk_area)
{
    return disk_area->nda_ver == NFFS_AREA_VER;
    2b6a:	7d00      	ldrb	r0, [r0, #20]
}
    2b6c:	1e43      	subs	r3, r0, #1
    2b6e:	4258      	negs	r0, r3
    2b70:	4158      	adcs	r0, r3
    2b72:	4770      	bx	lr

00002b74 <nffs_area_to_disk>:

void
nffs_area_to_disk(const struct nffs_area *area,
                  struct nffs_disk_area *out_disk_area)
{
    2b74:	b538      	push	{r3, r4, r5, lr}
    memset(out_disk_area, 0, sizeof *out_disk_area);
    2b76:	2218      	movs	r2, #24
}

void
nffs_area_to_disk(const struct nffs_area *area,
                  struct nffs_disk_area *out_disk_area)
{
    2b78:	460c      	mov	r4, r1
    2b7a:	4605      	mov	r5, r0
    memset(out_disk_area, 0, sizeof *out_disk_area);
    2b7c:	4608      	mov	r0, r1
    2b7e:	2100      	movs	r1, #0
    2b80:	f000 fef0 	bl	3964 <memset>
nffs_area_set_magic(struct nffs_disk_area *disk_area)
{
    disk_area->nda_magic[0] = NFFS_AREA_MAGIC0;
    disk_area->nda_magic[1] = NFFS_AREA_MAGIC1;
    disk_area->nda_magic[2] = NFFS_AREA_MAGIC2;
    disk_area->nda_magic[3] = NFFS_AREA_MAGIC3;
    2b84:	4b07      	ldr	r3, [pc, #28]	; (2ba4 <nffs_area_to_disk+0x30>)
    2b86:	4808      	ldr	r0, [pc, #32]	; (2ba8 <nffs_area_to_disk+0x34>)
    2b88:	4908      	ldr	r1, [pc, #32]	; (2bac <nffs_area_to_disk+0x38>)
    2b8a:	4a09      	ldr	r2, [pc, #36]	; (2bb0 <nffs_area_to_disk+0x3c>)
    2b8c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
nffs_area_to_disk(const struct nffs_area *area,
                  struct nffs_disk_area *out_disk_area)
{
    memset(out_disk_area, 0, sizeof *out_disk_area);
    nffs_area_set_magic(out_disk_area);
    out_disk_area->nda_length = area->na_length;
    2b90:	686b      	ldr	r3, [r5, #4]
    2b92:	6123      	str	r3, [r4, #16]
    out_disk_area->nda_ver = NFFS_AREA_VER;
    2b94:	2301      	movs	r3, #1
    2b96:	7523      	strb	r3, [r4, #20]
    out_disk_area->nda_gc_seq = area->na_gc_seq;
    2b98:	7bab      	ldrb	r3, [r5, #14]
    2b9a:	7563      	strb	r3, [r4, #21]
    out_disk_area->nda_id = area->na_id;
    2b9c:	89ab      	ldrh	r3, [r5, #12]
    2b9e:	75e3      	strb	r3, [r4, #23]
    2ba0:	bd38      	pop	{r3, r4, r5, pc}
    2ba2:	bf00      	nop
    2ba4:	b185fc8e 	.word	0xb185fc8e
    2ba8:	b98a31e2 	.word	0xb98a31e2
    2bac:	7fb0428c 	.word	0x7fb0428c
    2bb0:	ace08253 	.word	0xace08253

00002bb4 <nffs_area_free_space>:
}

uint32_t
nffs_area_free_space(const struct nffs_area *area)
{
    return area->na_length - area->na_cur;
    2bb4:	6842      	ldr	r2, [r0, #4]
    2bb6:	6880      	ldr	r0, [r0, #8]
}
    2bb8:	1a10      	subs	r0, r2, r0
    2bba:	4770      	bx	lr

00002bbc <nffs_area_find_corrupt_scratch>:
 * @return                      0 if a corrupt scratch area was identified;
 *                              FS_ENOENT if one was not found.
 */
int
nffs_area_find_corrupt_scratch(uint16_t *out_good_idx, uint16_t *out_bad_idx)
{
    2bbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    const struct nffs_area *iarea;
    const struct nffs_area *jarea;
    int i;
    int j;

    for (i = 0; i < nffs_num_areas; i++) {
    2bc0:	4b16      	ldr	r3, [pc, #88]	; (2c1c <nffs_area_find_corrupt_scratch+0x60>)
    2bc2:	781e      	ldrb	r6, [r3, #0]
        iarea = nffs_areas + i;
    2bc4:	4b16      	ldr	r3, [pc, #88]	; (2c20 <nffs_area_find_corrupt_scratch+0x64>)
    2bc6:	681b      	ldr	r3, [r3, #0]
    const struct nffs_area *iarea;
    const struct nffs_area *jarea;
    int i;
    int j;

    for (i = 0; i < nffs_num_areas; i++) {
    2bc8:	2200      	movs	r2, #0
    2bca:	3310      	adds	r3, #16
    2bcc:	42b2      	cmp	r2, r6
    2bce:	da21      	bge.n	2c14 <nffs_area_find_corrupt_scratch+0x58>
        iarea = nffs_areas + i;
        for (j = i + 1; j < nffs_num_areas; j++) {
    2bd0:	1c57      	adds	r7, r2, #1
    2bd2:	f1a3 0c10 	sub.w	ip, r3, #16
    2bd6:	461d      	mov	r5, r3
    2bd8:	463c      	mov	r4, r7
    2bda:	42b4      	cmp	r4, r6
    2bdc:	da17      	bge.n	2c0e <nffs_area_find_corrupt_scratch+0x52>
            jarea = nffs_areas + j;
    2bde:	46ae      	mov	lr, r5

            if (jarea->na_id == iarea->na_id) {
    2be0:	f833 8c04 	ldrh.w	r8, [r3, #-4]
    2be4:	f8be 900c 	ldrh.w	r9, [lr, #12]
    2be8:	45c1      	cmp	r9, r8
    2bea:	f105 0510 	add.w	r5, r5, #16
    2bee:	d10c      	bne.n	2c0a <nffs_area_find_corrupt_scratch+0x4e>
                /* Found a duplicate.  The shorter of the two areas should be
                 * used as scratch.
                 */
                if (iarea->na_cur < jarea->na_cur) {
    2bf0:	f8dc 5008 	ldr.w	r5, [ip, #8]
    2bf4:	f8de 3008 	ldr.w	r3, [lr, #8]
    2bf8:	429d      	cmp	r5, r3
                    *out_good_idx = j;
    2bfa:	bf35      	itete	cc
    2bfc:	8004      	strhcc	r4, [r0, #0]
                    *out_bad_idx = i;
                } else {
                    *out_good_idx = i;
    2bfe:	8002      	strhcs	r2, [r0, #0]
                /* Found a duplicate.  The shorter of the two areas should be
                 * used as scratch.
                 */
                if (iarea->na_cur < jarea->na_cur) {
                    *out_good_idx = j;
                    *out_bad_idx = i;
    2c00:	800a      	strhcc	r2, [r1, #0]
                } else {
                    *out_good_idx = i;
                    *out_bad_idx = j;
    2c02:	800c      	strhcs	r4, [r1, #0]
                }

                return 0;
    2c04:	2000      	movs	r0, #0
    2c06:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    int i;
    int j;

    for (i = 0; i < nffs_num_areas; i++) {
        iarea = nffs_areas + i;
        for (j = i + 1; j < nffs_num_areas; j++) {
    2c0a:	3401      	adds	r4, #1
    2c0c:	e7e5      	b.n	2bda <nffs_area_find_corrupt_scratch+0x1e>
    2c0e:	3310      	adds	r3, #16
    const struct nffs_area *iarea;
    const struct nffs_area *jarea;
    int i;
    int j;

    for (i = 0; i < nffs_num_areas; i++) {
    2c10:	463a      	mov	r2, r7
    2c12:	e7db      	b.n	2bcc <nffs_area_find_corrupt_scratch+0x10>
                return 0;
            }
        }
    }

    return FS_ENOENT;
    2c14:	2006      	movs	r0, #6
}
    2c16:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2c1a:	bf00      	nop
    2c1c:	20000b24 	.word	0x20000b24
    2c20:	20000b40 	.word	0x20000b40

00002c24 <nffs_block_entry_alloc>:
#include "nffs/nffs.h"
#include "nffs_priv.h"

struct nffs_hash_entry *
nffs_block_entry_alloc(void)
{
    2c24:	b510      	push	{r4, lr}
    struct nffs_hash_entry *entry;

    entry = os_memblock_get(&nffs_block_entry_pool);
    2c26:	4805      	ldr	r0, [pc, #20]	; (2c3c <nffs_block_entry_alloc+0x18>)
    2c28:	f002 f8b6 	bl	4d98 <os_memblock_get>
    if (entry != NULL) {
    2c2c:	4604      	mov	r4, r0
    2c2e:	b118      	cbz	r0, 2c38 <nffs_block_entry_alloc+0x14>
        memset(entry, 0, sizeof *entry);
    2c30:	2100      	movs	r1, #0
    2c32:	220c      	movs	r2, #12
    2c34:	f000 fe96 	bl	3964 <memset>
    }

    return entry;
}
    2c38:	4620      	mov	r0, r4
    2c3a:	bd10      	pop	{r4, pc}
    2c3c:	20000b44 	.word	0x20000b44

00002c40 <nffs_block_entry_free>:

void
nffs_block_entry_free(struct nffs_hash_entry *block_entry)
{
    2c40:	b510      	push	{r4, lr}
    2c42:	4604      	mov	r4, r0
    assert(nffs_hash_id_is_block(block_entry->nhe_id));
    2c44:	6840      	ldr	r0, [r0, #4]
    2c46:	f7fe f93d 	bl	ec4 <nffs_hash_id_is_block>
    2c4a:	4602      	mov	r2, r0
    2c4c:	b920      	cbnz	r0, 2c58 <nffs_block_entry_free+0x18>
    2c4e:	4805      	ldr	r0, [pc, #20]	; (2c64 <nffs_block_entry_free+0x24>)
    2c50:	212b      	movs	r1, #43	; 0x2b
    2c52:	4613      	mov	r3, r2
    2c54:	f001 fffa 	bl	4c4c <__assert_func>
    os_memblock_put(&nffs_block_entry_pool, block_entry);
    2c58:	4621      	mov	r1, r4
    2c5a:	4803      	ldr	r0, [pc, #12]	; (2c68 <nffs_block_entry_free+0x28>)
}
    2c5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void
nffs_block_entry_free(struct nffs_hash_entry *block_entry)
{
    assert(nffs_hash_id_is_block(block_entry->nhe_id));
    os_memblock_put(&nffs_block_entry_pool, block_entry);
    2c60:	f002 b8ae 	b.w	4dc0 <os_memblock_put>
    2c64:	00006313 	.word	0x00006313
    2c68:	20000b44 	.word	0x20000b44

00002c6c <nffs_block_entry_reserve>:
 *                                  FS_ENOMEM on memory exhaustion;
 *                                  other nonzero on garbage collection error.
 */
int
nffs_block_entry_reserve(struct nffs_hash_entry **out_block_entry)
{
    2c6c:	b513      	push	{r0, r1, r4, lr}
    2c6e:	4604      	mov	r4, r0
    int rc;

    do {
        *out_block_entry = nffs_block_entry_alloc();
    2c70:	f7ff ffd8 	bl	2c24 <nffs_block_entry_alloc>
    } while (nffs_misc_gc_if_oom(*out_block_entry, &rc));
    2c74:	a901      	add	r1, sp, #4
nffs_block_entry_reserve(struct nffs_hash_entry **out_block_entry)
{
    int rc;

    do {
        *out_block_entry = nffs_block_entry_alloc();
    2c76:	6020      	str	r0, [r4, #0]
    } while (nffs_misc_gc_if_oom(*out_block_entry, &rc));
    2c78:	f7fe fef4 	bl	1a64 <nffs_misc_gc_if_oom>
    2c7c:	2800      	cmp	r0, #0
    2c7e:	d1f7      	bne.n	2c70 <nffs_block_entry_reserve+0x4>

    return rc;
}
    2c80:	9801      	ldr	r0, [sp, #4]
    2c82:	b002      	add	sp, #8
    2c84:	bd10      	pop	{r4, pc}

00002c86 <nffs_block_read_disk>:
 *                                  not contain a block.
 */
int
nffs_block_read_disk(uint8_t area_idx, uint32_t area_offset,
                     struct nffs_disk_block *out_disk_block)
{
    2c86:	b510      	push	{r4, lr}
    int rc;

    rc = nffs_flash_read(area_idx, area_offset, out_disk_block,
    2c88:	2314      	movs	r3, #20
 *                                  not contain a block.
 */
int
nffs_block_read_disk(uint8_t area_idx, uint32_t area_offset,
                     struct nffs_disk_block *out_disk_block)
{
    2c8a:	4614      	mov	r4, r2
    int rc;

    rc = nffs_flash_read(area_idx, area_offset, out_disk_block,
    2c8c:	f7fe f806 	bl	c9c <nffs_flash_read>
                         sizeof *out_disk_block);
    if (rc != 0) {
    2c90:	b930      	cbnz	r0, 2ca0 <nffs_block_read_disk+0x1a>
        return rc;
    }
    if (!nffs_hash_id_is_block(out_disk_block->ndb_id)) {
    2c92:	6820      	ldr	r0, [r4, #0]
    2c94:	f7fe f916 	bl	ec4 <nffs_hash_id_is_block>
    2c98:	2800      	cmp	r0, #0
        return FS_EUNEXP;
    }

    return 0;
    2c9a:	bf0c      	ite	eq
    2c9c:	2009      	moveq	r0, #9
    2c9e:	2000      	movne	r0, #0
}
    2ca0:	bd10      	pop	{r4, pc}

00002ca2 <nffs_block_write_disk>:
 */
int
nffs_block_write_disk(const struct nffs_disk_block *disk_block,
                      const void *data,
                      uint8_t *out_area_idx, uint32_t *out_area_offset)
{
    2ca2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2ca4:	4604      	mov	r4, r0
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    rc = nffs_misc_reserve_space(sizeof *disk_block + disk_block->ndb_data_len,
    2ca6:	8a00      	ldrh	r0, [r0, #16]
    2ca8:	3014      	adds	r0, #20
 */
int
nffs_block_write_disk(const struct nffs_disk_block *disk_block,
                      const void *data,
                      uint8_t *out_area_idx, uint32_t *out_area_offset)
{
    2caa:	460f      	mov	r7, r1
    2cac:	4615      	mov	r5, r2
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    rc = nffs_misc_reserve_space(sizeof *disk_block + disk_block->ndb_data_len,
    2cae:	b280      	uxth	r0, r0
    2cb0:	f10d 0103 	add.w	r1, sp, #3
    2cb4:	aa01      	add	r2, sp, #4
 */
int
nffs_block_write_disk(const struct nffs_disk_block *disk_block,
                      const void *data,
                      uint8_t *out_area_idx, uint32_t *out_area_offset)
{
    2cb6:	461e      	mov	r6, r3
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    rc = nffs_misc_reserve_space(sizeof *disk_block + disk_block->ndb_data_len,
    2cb8:	f7fe fef4 	bl	1aa4 <nffs_misc_reserve_space>
                                &area_idx, &area_offset);
    if (rc != 0) {
    2cbc:	b9c8      	cbnz	r0, 2cf2 <nffs_block_write_disk+0x50>
        return rc;
    }

    rc = nffs_flash_write(area_idx, area_offset, disk_block,
    2cbe:	f89d 0003 	ldrb.w	r0, [sp, #3]
    2cc2:	9901      	ldr	r1, [sp, #4]
    2cc4:	4622      	mov	r2, r4
    2cc6:	2314      	movs	r3, #20
    2cc8:	f7fe f80e 	bl	ce8 <nffs_flash_write>
                         sizeof *disk_block);
    if (rc != 0) {
    2ccc:	b988      	cbnz	r0, 2cf2 <nffs_block_write_disk+0x50>
        return rc;
    }

    if (disk_block->ndb_data_len > 0) {
    2cce:	8a23      	ldrh	r3, [r4, #16]
    2cd0:	b933      	cbnz	r3, 2ce0 <nffs_block_write_disk+0x3e>
        if (rc != 0) {
            return rc;
        }
    }

    *out_area_idx = area_idx;
    2cd2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2cd6:	702b      	strb	r3, [r5, #0]
    *out_area_offset = area_offset;
    2cd8:	9b01      	ldr	r3, [sp, #4]
    2cda:	6033      	str	r3, [r6, #0]

    ASSERT_IF_TEST(nffs_crc_disk_block_validate(disk_block, area_idx,
                                               area_offset) == 0);

    return 0;
    2cdc:	2000      	movs	r0, #0
    2cde:	e008      	b.n	2cf2 <nffs_block_write_disk+0x50>
    if (rc != 0) {
        return rc;
    }

    if (disk_block->ndb_data_len > 0) {
        rc = nffs_flash_write(area_idx, area_offset + sizeof *disk_block,
    2ce0:	9901      	ldr	r1, [sp, #4]
    2ce2:	f89d 0003 	ldrb.w	r0, [sp, #3]
    2ce6:	3114      	adds	r1, #20
    2ce8:	463a      	mov	r2, r7
    2cea:	f7fd fffd 	bl	ce8 <nffs_flash_write>
                             data, disk_block->ndb_data_len);
        if (rc != 0) {
    2cee:	2800      	cmp	r0, #0
    2cf0:	d0ef      	beq.n	2cd2 <nffs_block_write_disk+0x30>

    ASSERT_IF_TEST(nffs_crc_disk_block_validate(disk_block, area_idx,
                                               area_offset) == 0);

    return 0;
}
    2cf2:	b003      	add	sp, #12
    2cf4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00002cf8 <nffs_block_to_disk>:
 */
void
nffs_block_to_disk(const struct nffs_block *block,
                   struct nffs_disk_block *out_disk_block)
{
    assert(block->nb_inode_entry != NULL);
    2cf8:	6882      	ldr	r2, [r0, #8]
 * @param out_disk_block        The disk block to write to.
 */
void
nffs_block_to_disk(const struct nffs_block *block,
                   struct nffs_disk_block *out_disk_block)
{
    2cfa:	b508      	push	{r3, lr}
    assert(block->nb_inode_entry != NULL);
    2cfc:	b922      	cbnz	r2, 2d08 <nffs_block_to_disk+0x10>
    2cfe:	480b      	ldr	r0, [pc, #44]	; (2d2c <nffs_block_to_disk+0x34>)
    2d00:	21d7      	movs	r1, #215	; 0xd7
    2d02:	4613      	mov	r3, r2
    2d04:	f001 ffa2 	bl	4c4c <__assert_func>

    out_disk_block->ndb_id = block->nb_hash_entry->nhe_id;
    2d08:	6803      	ldr	r3, [r0, #0]
    2d0a:	685b      	ldr	r3, [r3, #4]
    2d0c:	600b      	str	r3, [r1, #0]
    out_disk_block->ndb_seq = block->nb_seq;
    2d0e:	6843      	ldr	r3, [r0, #4]
    2d10:	818b      	strh	r3, [r1, #12]
    out_disk_block->ndb_inode_id =
    2d12:	6853      	ldr	r3, [r2, #4]
    2d14:	604b      	str	r3, [r1, #4]
        block->nb_inode_entry->nie_hash_entry.nhe_id;
    if (block->nb_prev == NULL) {
    2d16:	68c3      	ldr	r3, [r0, #12]
    2d18:	b913      	cbnz	r3, 2d20 <nffs_block_to_disk+0x28>
        out_disk_block->ndb_prev_id = NFFS_ID_NONE;
    2d1a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2d1e:	e000      	b.n	2d22 <nffs_block_to_disk+0x2a>
    } else {
        out_disk_block->ndb_prev_id = block->nb_prev->nhe_id;
    2d20:	685b      	ldr	r3, [r3, #4]
    2d22:	608b      	str	r3, [r1, #8]
    }
    out_disk_block->ndb_data_len = block->nb_data_len;
    2d24:	8a03      	ldrh	r3, [r0, #16]
    2d26:	820b      	strh	r3, [r1, #16]
    2d28:	bd08      	pop	{r3, pc}
    2d2a:	bf00      	nop
    2d2c:	00006313 	.word	0x00006313

00002d30 <nffs_block_from_hash_entry_no_ptrs>:
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_block_from_hash_entry_no_ptrs(struct nffs_block *out_block,
                                   struct nffs_hash_entry *block_entry)
{
    2d30:	b530      	push	{r4, r5, lr}
    2d32:	4604      	mov	r4, r0
    2d34:	b089      	sub	sp, #36	; 0x24
    struct nffs_disk_block disk_block;
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    assert(nffs_hash_id_is_block(block_entry->nhe_id));
    2d36:	6848      	ldr	r0, [r1, #4]
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_block_from_hash_entry_no_ptrs(struct nffs_block *out_block,
                                   struct nffs_hash_entry *block_entry)
{
    2d38:	460d      	mov	r5, r1
    struct nffs_disk_block disk_block;
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    assert(nffs_hash_id_is_block(block_entry->nhe_id));
    2d3a:	f7fe f8c3 	bl	ec4 <nffs_hash_id_is_block>
    2d3e:	4602      	mov	r2, r0
    2d40:	b928      	cbnz	r0, 2d4e <nffs_block_from_hash_entry_no_ptrs+0x1e>
    2d42:	4812      	ldr	r0, [pc, #72]	; (2d8c <nffs_block_from_hash_entry_no_ptrs+0x5c>)
    2d44:	f44f 71a9 	mov.w	r1, #338	; 0x152
    2d48:	4613      	mov	r3, r2
    2d4a:	f001 ff7f 	bl	4c4c <__assert_func>

    if (nffs_hash_entry_is_dummy(block_entry)) {
    2d4e:	4628      	mov	r0, r5
    2d50:	f7fe f8f8 	bl	f44 <nffs_hash_entry_is_dummy>
    2d54:	b110      	cbz	r0, 2d5c <nffs_block_from_hash_entry_no_ptrs+0x2c>
        /*
         * We can't read this from disk so we'll be missing filling in anything
         * not already in inode_entry (e.g., prev_id).
         */
        out_block->nb_hash_entry = block_entry;
    2d56:	6025      	str	r5, [r4, #0]
        return FS_ENOENT; /* let caller know it's a partial inode_entry */
    2d58:	2006      	movs	r0, #6
    2d5a:	e015      	b.n	2d88 <nffs_block_from_hash_entry_no_ptrs+0x58>
    }

    nffs_flash_loc_expand(block_entry->nhe_flash_loc, &area_idx, &area_offset);
    2d5c:	68a8      	ldr	r0, [r5, #8]
    2d5e:	f10d 0107 	add.w	r1, sp, #7
    2d62:	aa02      	add	r2, sp, #8
    2d64:	f7fe f820 	bl	da8 <nffs_flash_loc_expand>
    rc = nffs_block_read_disk(area_idx, area_offset, &disk_block);
    2d68:	f89d 0007 	ldrb.w	r0, [sp, #7]
    2d6c:	9902      	ldr	r1, [sp, #8]
    2d6e:	aa03      	add	r2, sp, #12
    2d70:	f7ff ff89 	bl	2c86 <nffs_block_read_disk>
    if (rc != 0) {
    2d74:	b940      	cbnz	r0, 2d88 <nffs_block_from_hash_entry_no_ptrs+0x58>
    2d76:	f8bd 301c 	ldrh.w	r3, [sp, #28]

static void
nffs_block_from_disk_no_ptrs(struct nffs_block *out_block,
                             const struct nffs_disk_block *disk_block)
{
    out_block->nb_seq = disk_block->ndb_seq;
    2d7a:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    rc = nffs_block_read_disk(area_idx, area_offset, &disk_block);
    if (rc != 0) {
        return rc;
    }

    out_block->nb_hash_entry = block_entry;
    2d7e:	6025      	str	r5, [r4, #0]

static void
nffs_block_from_disk_no_ptrs(struct nffs_block *out_block,
                             const struct nffs_disk_block *disk_block)
{
    out_block->nb_seq = disk_block->ndb_seq;
    2d80:	6062      	str	r2, [r4, #4]
    out_block->nb_inode_entry = NULL;
    2d82:	60a0      	str	r0, [r4, #8]
    out_block->nb_prev = NULL;
    2d84:	60e0      	str	r0, [r4, #12]
    out_block->nb_data_len = disk_block->ndb_data_len;
    2d86:	8223      	strh	r3, [r4, #16]

    out_block->nb_hash_entry = block_entry;
    nffs_block_from_disk_no_ptrs(out_block, &disk_block);

    return 0;
}
    2d88:	b009      	add	sp, #36	; 0x24
    2d8a:	bd30      	pop	{r4, r5, pc}
    2d8c:	00006313 	.word	0x00006313

00002d90 <nffs_block_read_data>:
}

int
nffs_block_read_data(const struct nffs_block *block, uint16_t offset,
                     uint16_t length, void *dst)
{
    2d90:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2d92:	461e      	mov	r6, r3
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    nffs_flash_loc_expand(block->nb_hash_entry->nhe_flash_loc,
    2d94:	6803      	ldr	r3, [r0, #0]
}

int
nffs_block_read_data(const struct nffs_block *block, uint16_t offset,
                     uint16_t length, void *dst)
{
    2d96:	460c      	mov	r4, r1
    2d98:	4615      	mov	r5, r2
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    nffs_flash_loc_expand(block->nb_hash_entry->nhe_flash_loc,
    2d9a:	6898      	ldr	r0, [r3, #8]
    2d9c:	f10d 0103 	add.w	r1, sp, #3
    2da0:	aa01      	add	r2, sp, #4
    2da2:	f7fe f801 	bl	da8 <nffs_flash_loc_expand>
                         &area_idx, &area_offset);
    area_offset += sizeof (struct nffs_disk_block);
    2da6:	9901      	ldr	r1, [sp, #4]
    area_offset += offset;

    rc = nffs_flash_read(area_idx, area_offset, dst, length);
    2da8:	f89d 0003 	ldrb.w	r0, [sp, #3]
    uint8_t area_idx;
    int rc;

    nffs_flash_loc_expand(block->nb_hash_entry->nhe_flash_loc,
                         &area_idx, &area_offset);
    area_offset += sizeof (struct nffs_disk_block);
    2dac:	3114      	adds	r1, #20
    area_offset += offset;
    2dae:	4421      	add	r1, r4

    rc = nffs_flash_read(area_idx, area_offset, dst, length);
    2db0:	4632      	mov	r2, r6
    2db2:	462b      	mov	r3, r5
    int rc;

    nffs_flash_loc_expand(block->nb_hash_entry->nhe_flash_loc,
                         &area_idx, &area_offset);
    area_offset += sizeof (struct nffs_disk_block);
    area_offset += offset;
    2db4:	9101      	str	r1, [sp, #4]

    rc = nffs_flash_read(area_idx, area_offset, dst, length);
    2db6:	f7fd ff71 	bl	c9c <nffs_flash_read>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    2dba:	b002      	add	sp, #8
    2dbc:	bd70      	pop	{r4, r5, r6, pc}

00002dbe <nffs_block_is_dummy>:

int
nffs_block_is_dummy(struct nffs_hash_entry *entry)
{
    2dbe:	b510      	push	{r4, lr}
    return (entry->nhe_flash_loc == NFFS_FLASH_LOC_NONE);
    2dc0:	2100      	movs	r1, #0
    2dc2:	6884      	ldr	r4, [r0, #8]
    2dc4:	20ff      	movs	r0, #255	; 0xff
    2dc6:	f7fd ffdf 	bl	d88 <nffs_flash_loc>
}
    2dca:	1a23      	subs	r3, r4, r0
    2dcc:	4258      	negs	r0, r3
    2dce:	4158      	adcs	r0, r3
    2dd0:	bd10      	pop	{r4, pc}
	...

00002dd4 <nffs_block_from_hash_entry>:
 *                                  not contain a block.
 */
int
nffs_block_from_hash_entry(struct nffs_block *out_block,
                           struct nffs_hash_entry *block_entry)
{
    2dd4:	b530      	push	{r4, r5, lr}
    2dd6:	4605      	mov	r5, r0
    2dd8:	b089      	sub	sp, #36	; 0x24
    struct nffs_disk_block disk_block;
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    assert(nffs_hash_id_is_block(block_entry->nhe_id));
    2dda:	6848      	ldr	r0, [r1, #4]
 *                                  not contain a block.
 */
int
nffs_block_from_hash_entry(struct nffs_block *out_block,
                           struct nffs_hash_entry *block_entry)
{
    2ddc:	460c      	mov	r4, r1
    struct nffs_disk_block disk_block;
    uint32_t area_offset;
    uint8_t area_idx;
    int rc;

    assert(nffs_hash_id_is_block(block_entry->nhe_id));
    2dde:	f7fe f871 	bl	ec4 <nffs_hash_id_is_block>
    2de2:	4602      	mov	r2, r0
    2de4:	b928      	cbnz	r0, 2df2 <nffs_block_from_hash_entry+0x1e>
    2de6:	481d      	ldr	r0, [pc, #116]	; (2e5c <nffs_block_from_hash_entry+0x88>)
    2de8:	f44f 71c4 	mov.w	r1, #392	; 0x188
    2dec:	4613      	mov	r3, r2
    2dee:	f001 ff2d 	bl	4c4c <__assert_func>

    if (nffs_block_is_dummy(block_entry)) {
    2df2:	4620      	mov	r0, r4
    2df4:	f7ff ffe3 	bl	2dbe <nffs_block_is_dummy>
    2df8:	b120      	cbz	r0, 2e04 <nffs_block_from_hash_entry+0x30>
        out_block->nb_hash_entry = block_entry;
        out_block->nb_inode_entry = NULL;
    2dfa:	2000      	movs	r0, #0
    int rc;

    assert(nffs_hash_id_is_block(block_entry->nhe_id));

    if (nffs_block_is_dummy(block_entry)) {
        out_block->nb_hash_entry = block_entry;
    2dfc:	602c      	str	r4, [r5, #0]
        out_block->nb_inode_entry = NULL;
    2dfe:	60a8      	str	r0, [r5, #8]
        out_block->nb_prev = NULL;
    2e00:	60e8      	str	r0, [r5, #12]
         * (see nffs_restore_inode()). Return success (because there's 
         * too many places that ned to check for this,
         * but it's the responsibility fo the upstream code to check
         * whether this is still a dummy entry.  XXX
         */
        return 0;
    2e02:	e028      	b.n	2e56 <nffs_block_from_hash_entry+0x82>
        /*return FS_ENOENT;*/
    }
    nffs_flash_loc_expand(block_entry->nhe_flash_loc, &area_idx, &area_offset);
    2e04:	68a0      	ldr	r0, [r4, #8]
    2e06:	f10d 0107 	add.w	r1, sp, #7
    2e0a:	aa02      	add	r2, sp, #8
    2e0c:	f7fd ffcc 	bl	da8 <nffs_flash_loc_expand>
    rc = nffs_block_read_disk(area_idx, area_offset, &disk_block);
    2e10:	f89d 0007 	ldrb.w	r0, [sp, #7]
    2e14:	9902      	ldr	r1, [sp, #8]
    2e16:	aa03      	add	r2, sp, #12
    2e18:	f7ff ff35 	bl	2c86 <nffs_block_read_disk>
    if (rc != 0) {
    2e1c:	b9d8      	cbnz	r0, 2e56 <nffs_block_from_hash_entry+0x82>
    2e1e:	f8bd 301c 	ldrh.w	r3, [sp, #28]

static void
nffs_block_from_disk_no_ptrs(struct nffs_block *out_block,
                             const struct nffs_disk_block *disk_block)
{
    out_block->nb_seq = disk_block->ndb_seq;
    2e22:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    rc = nffs_block_read_disk(area_idx, area_offset, &disk_block);
    if (rc != 0) {
        return rc;
    }

    out_block->nb_hash_entry = block_entry;
    2e26:	602c      	str	r4, [r5, #0]
static void
nffs_block_from_disk_no_ptrs(struct nffs_block *out_block,
                             const struct nffs_disk_block *disk_block)
{
    out_block->nb_seq = disk_block->ndb_seq;
    out_block->nb_inode_entry = NULL;
    2e28:	60a8      	str	r0, [r5, #8]
    out_block->nb_prev = NULL;
    2e2a:	60e8      	str	r0, [r5, #12]
    out_block->nb_data_len = disk_block->ndb_data_len;
    2e2c:	822b      	strh	r3, [r5, #16]

static void
nffs_block_from_disk_no_ptrs(struct nffs_block *out_block,
                             const struct nffs_disk_block *disk_block)
{
    out_block->nb_seq = disk_block->ndb_seq;
    2e2e:	606a      	str	r2, [r5, #4]

    rc = 0;

    nffs_block_from_disk_no_ptrs(out_block, disk_block);

    out_block->nb_inode_entry = nffs_hash_find_inode(disk_block->ndb_inode_id);
    2e30:	9804      	ldr	r0, [sp, #16]
    2e32:	f7fe f861 	bl	ef8 <nffs_hash_find_inode>
    if (out_block->nb_inode_entry == NULL) {
    2e36:	fab0 f480 	clz	r4, r0

    rc = 0;

    nffs_block_from_disk_no_ptrs(out_block, disk_block);

    out_block->nb_inode_entry = nffs_hash_find_inode(disk_block->ndb_inode_id);
    2e3a:	60a8      	str	r0, [r5, #8]
    if (out_block->nb_inode_entry == NULL) {
        rc = FS_ECORRUPT;
    }

    if (disk_block->ndb_prev_id != NFFS_ID_NONE) {
    2e3c:	9805      	ldr	r0, [sp, #20]
    2e3e:	1c43      	adds	r3, r0, #1
    rc = 0;

    nffs_block_from_disk_no_ptrs(out_block, disk_block);

    out_block->nb_inode_entry = nffs_hash_find_inode(disk_block->ndb_inode_id);
    if (out_block->nb_inode_entry == NULL) {
    2e40:	ea4f 1454 	mov.w	r4, r4, lsr #5
        rc = FS_ECORRUPT;
    }

    if (disk_block->ndb_prev_id != NFFS_ID_NONE) {
    2e44:	d101      	bne.n	2e4a <nffs_block_from_hash_entry+0x76>
         * (see nffs_restore_inode()). Return success (because there's 
         * too many places that ned to check for this,
         * but it's the responsibility fo the upstream code to check
         * whether this is still a dummy entry.  XXX
         */
        return 0;
    2e46:	4620      	mov	r0, r4
    2e48:	e005      	b.n	2e56 <nffs_block_from_hash_entry+0x82>
    if (out_block->nb_inode_entry == NULL) {
        rc = FS_ECORRUPT;
    }

    if (disk_block->ndb_prev_id != NFFS_ID_NONE) {
        out_block->nb_prev = nffs_hash_find_block(disk_block->ndb_prev_id);
    2e4a:	f7fe f867 	bl	f1c <nffs_hash_find_block>
    2e4e:	60e8      	str	r0, [r5, #12]
        if (out_block->nb_prev == NULL) {
    2e50:	2800      	cmp	r0, #0
    2e52:	d1f8      	bne.n	2e46 <nffs_block_from_hash_entry+0x72>
    2e54:	2001      	movs	r0, #1
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    2e56:	b009      	add	sp, #36	; 0x24
    2e58:	bd30      	pop	{r4, r5, pc}
    2e5a:	bf00      	nop
    2e5c:	00006313 	.word	0x00006313

00002e60 <nffs_block_delete_from_ram>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
nffs_block_delete_from_ram(struct nffs_hash_entry *block_entry)
{
    2e60:	b530      	push	{r4, r5, lr}
    2e62:	b087      	sub	sp, #28
    2e64:	4605      	mov	r5, r0
    struct nffs_inode_entry *inode_entry;
    struct nffs_block block;
    int rc;

    if (nffs_hash_entry_is_dummy(block_entry)) {
    2e66:	f7fe f86d 	bl	f44 <nffs_hash_entry_is_dummy>
    2e6a:	b138      	cbz	r0, 2e7c <nffs_block_delete_from_ram+0x1c>
        /*
         * it's very limited to what we can do here as the block doesn't have
         * any way to get to the inode via hash entry. Just delete the
         * block and return FS_ECORRUPT
         */
        nffs_hash_remove(block_entry);
    2e6c:	4628      	mov	r0, r5
    2e6e:	f7fe f8b5 	bl	fdc <nffs_hash_remove>
        nffs_block_entry_free(block_entry);
    2e72:	4628      	mov	r0, r5
    2e74:	f7ff fee4 	bl	2c40 <nffs_block_entry_free>
        return FS_ECORRUPT;
    2e78:	2001      	movs	r0, #1
    2e7a:	e014      	b.n	2ea6 <nffs_block_delete_from_ram+0x46>
    }

    rc = nffs_block_from_hash_entry(&block, block_entry);
    2e7c:	a801      	add	r0, sp, #4
    2e7e:	4629      	mov	r1, r5
    2e80:	f7ff ffa8 	bl	2dd4 <nffs_block_from_hash_entry>
    if (rc == 0 || rc == FS_ECORRUPT) {
    2e84:	2801      	cmp	r0, #1
        nffs_hash_remove(block_entry);
        nffs_block_entry_free(block_entry);
        return FS_ECORRUPT;
    }

    rc = nffs_block_from_hash_entry(&block, block_entry);
    2e86:	4604      	mov	r4, r0
    if (rc == 0 || rc == FS_ECORRUPT) {
    2e88:	d80c      	bhi.n	2ea4 <nffs_block_delete_from_ram+0x44>
        /* If file system corruption was detected, the resulting block is still
         * valid and can be removed from RAM.
         */
        inode_entry = block.nb_inode_entry;
    2e8a:	9b03      	ldr	r3, [sp, #12]
        if (inode_entry != NULL &&
    2e8c:	b123      	cbz	r3, 2e98 <nffs_block_delete_from_ram+0x38>
    2e8e:	691a      	ldr	r2, [r3, #16]
    2e90:	42aa      	cmp	r2, r5
            inode_entry->nie_last_block_entry == block_entry) {

            inode_entry->nie_last_block_entry = block.nb_prev;
    2e92:	bf04      	itt	eq
    2e94:	9a04      	ldreq	r2, [sp, #16]
    2e96:	611a      	streq	r2, [r3, #16]
        }

        nffs_hash_remove(block_entry);
    2e98:	4628      	mov	r0, r5
    2e9a:	f7fe f89f 	bl	fdc <nffs_hash_remove>
        nffs_block_entry_free(block_entry);
    2e9e:	4628      	mov	r0, r5
    2ea0:	f7ff fece 	bl	2c40 <nffs_block_entry_free>
    2ea4:	4620      	mov	r0, r4
    }

    return rc;
}
    2ea6:	b007      	add	sp, #28
    2ea8:	bd30      	pop	{r4, r5, pc}
	...

00002eac <nffs_crc_flash>:
#include "nffs_priv.h"

int
nffs_crc_flash(uint16_t initial_crc, uint8_t area_idx, uint32_t area_offset,
               uint32_t len, uint16_t *out_crc)
{
    2eac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2eb0:	4606      	mov	r6, r0
    2eb2:	4688      	mov	r8, r1
    2eb4:	4617      	mov	r7, r2
    2eb6:	461c      	mov	r4, r3
    int rc;

    crc = initial_crc;

    /* Copy data in chunks small enough to fit in the flash buffer. */
    while (len > 0) {
    2eb8:	b1ac      	cbz	r4, 2ee6 <nffs_crc_flash+0x3a>
    2eba:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
    2ebe:	4625      	mov	r5, r4
    2ec0:	bf28      	it	cs
    2ec2:	f44f 7580 	movcs.w	r5, #256	; 0x100
            chunk_len = sizeof nffs_flash_buf;
        } else {
            chunk_len = len;
        }

        rc = nffs_flash_read(area_idx, area_offset, nffs_flash_buf, chunk_len);
    2ec6:	4640      	mov	r0, r8
    2ec8:	4639      	mov	r1, r7
    2eca:	4a09      	ldr	r2, [pc, #36]	; (2ef0 <nffs_crc_flash+0x44>)
    2ecc:	462b      	mov	r3, r5
    2ece:	f7fd fee5 	bl	c9c <nffs_flash_read>
        if (rc != 0) {
    2ed2:	b958      	cbnz	r0, 2eec <nffs_crc_flash+0x40>
            return rc;
        }

        crc = crc16_ccitt(crc, nffs_flash_buf, chunk_len);
    2ed4:	4630      	mov	r0, r6
    2ed6:	4906      	ldr	r1, [pc, #24]	; (2ef0 <nffs_crc_flash+0x44>)
    2ed8:	462a      	mov	r2, r5
    2eda:	f002 fad3 	bl	5484 <crc16_ccitt>

        area_offset += chunk_len;
    2ede:	442f      	add	r7, r5
        rc = nffs_flash_read(area_idx, area_offset, nffs_flash_buf, chunk_len);
        if (rc != 0) {
            return rc;
        }

        crc = crc16_ccitt(crc, nffs_flash_buf, chunk_len);
    2ee0:	4606      	mov	r6, r0

        area_offset += chunk_len;
        len -= chunk_len;
    2ee2:	1b64      	subs	r4, r4, r5
    2ee4:	e7e8      	b.n	2eb8 <nffs_crc_flash+0xc>
    }

    *out_crc = crc;
    2ee6:	9b06      	ldr	r3, [sp, #24]
    return 0;
    2ee8:	4620      	mov	r0, r4

        area_offset += chunk_len;
        len -= chunk_len;
    }

    *out_crc = crc;
    2eea:	801e      	strh	r6, [r3, #0]
    return 0;
}
    2eec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2ef0:	20000b9c 	.word	0x20000b9c

00002ef4 <nffs_crc_disk_block_hdr>:

uint16_t
nffs_crc_disk_block_hdr(const struct nffs_disk_block *disk_block)
{
    2ef4:	4601      	mov	r1, r0
    uint16_t crc;

    crc = crc16_ccitt(0, disk_block, NFFS_DISK_BLOCK_OFFSET_CRC);
    2ef6:	2212      	movs	r2, #18
    2ef8:	2000      	movs	r0, #0
    2efa:	f002 bac3 	b.w	5484 <crc16_ccitt>

00002efe <nffs_crc_disk_block_validate>:
}

int
nffs_crc_disk_block_validate(const struct nffs_disk_block *disk_block,
                             uint8_t area_idx, uint32_t area_offset)
{
    2efe:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f00:	b085      	sub	sp, #20
    2f02:	4605      	mov	r5, r0
    2f04:	460f      	mov	r7, r1
    2f06:	4616      	mov	r6, r2
                    uint16_t *out_crc)
{
    uint16_t crc;
    int rc;

    crc = nffs_crc_disk_block_hdr(disk_block);
    2f08:	f7ff fff4 	bl	2ef4 <nffs_crc_disk_block_hdr>
    2f0c:	ac04      	add	r4, sp, #16

    rc = nffs_crc_flash(crc, area_idx, area_offset + sizeof *disk_block,
    2f0e:	8a2b      	ldrh	r3, [r5, #16]
                    uint16_t *out_crc)
{
    uint16_t crc;
    int rc;

    crc = nffs_crc_disk_block_hdr(disk_block);
    2f10:	f824 0d02 	strh.w	r0, [r4, #-2]!

    rc = nffs_crc_flash(crc, area_idx, area_offset + sizeof *disk_block,
    2f14:	4639      	mov	r1, r7
    2f16:	9400      	str	r4, [sp, #0]
    2f18:	f106 0214 	add.w	r2, r6, #20
    2f1c:	f7ff ffc6 	bl	2eac <nffs_crc_flash>
                        disk_block->ndb_data_len, &crc);
    if (rc != 0) {
    2f20:	b928      	cbnz	r0, 2f2e <nffs_crc_disk_block_validate+0x30>
        return rc;
    }

    *out_crc = crc;
    2f22:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    rc = nffs_crc_disk_block(disk_block, area_idx, area_offset, &crc);
    if (rc != 0) {
        return rc;
    }

    if (crc != disk_block->ndb_crc16) {
    2f26:	8a6b      	ldrh	r3, [r5, #18]
    2f28:	1a18      	subs	r0, r3, r0
    2f2a:	bf18      	it	ne
    2f2c:	2001      	movne	r0, #1
        return FS_ECORRUPT;
    }

    return 0;
}
    2f2e:	b005      	add	sp, #20
    2f30:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002f32 <nffs_crc_disk_block_fill>:

void
nffs_crc_disk_block_fill(struct nffs_disk_block *disk_block, const void *data)
{
    2f32:	b538      	push	{r3, r4, r5, lr}
    2f34:	4604      	mov	r4, r0
    2f36:	460d      	mov	r5, r1
    uint16_t crc16;

    crc16 = nffs_crc_disk_block_hdr(disk_block);
    2f38:	f7ff ffdc 	bl	2ef4 <nffs_crc_disk_block_hdr>
    crc16 = crc16_ccitt(crc16, data, disk_block->ndb_data_len);
    2f3c:	4629      	mov	r1, r5
    2f3e:	8a22      	ldrh	r2, [r4, #16]
    2f40:	f002 faa0 	bl	5484 <crc16_ccitt>

    disk_block->ndb_crc16 = crc16;
    2f44:	8260      	strh	r0, [r4, #18]
    2f46:	bd38      	pop	{r3, r4, r5, pc}

00002f48 <nffs_crc_disk_inode_validate>:
}

int
nffs_crc_disk_inode_validate(const struct nffs_disk_inode *disk_inode,
                             uint8_t area_idx, uint32_t area_offset)
{
    2f48:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2f4a:	4604      	mov	r4, r0
    2f4c:	460e      	mov	r6, r1
    2f4e:	4615      	mov	r5, r2
static uint16_t
nffs_crc_disk_inode_hdr(const struct nffs_disk_inode *disk_inode)
{
    uint16_t crc;

    crc = crc16_ccitt(0, disk_inode, NFFS_DISK_INODE_OFFSET_CRC);
    2f50:	4621      	mov	r1, r4
    2f52:	2212      	movs	r2, #18
    2f54:	2000      	movs	r0, #0
    2f56:	f002 fa95 	bl	5484 <crc16_ccitt>
                    uint16_t *out_crc)
{
    uint16_t crc;
    int rc;

    crc = nffs_crc_disk_inode_hdr(disk_inode);
    2f5a:	aa04      	add	r2, sp, #16

    rc = nffs_crc_flash(crc, area_idx, area_offset + sizeof *disk_inode,
    2f5c:	7c63      	ldrb	r3, [r4, #17]
                    uint16_t *out_crc)
{
    uint16_t crc;
    int rc;

    crc = nffs_crc_disk_inode_hdr(disk_inode);
    2f5e:	f822 0d02 	strh.w	r0, [r2, #-2]!

    rc = nffs_crc_flash(crc, area_idx, area_offset + sizeof *disk_inode,
    2f62:	4631      	mov	r1, r6
    2f64:	9200      	str	r2, [sp, #0]
    2f66:	f105 0214 	add.w	r2, r5, #20
    2f6a:	f7ff ff9f 	bl	2eac <nffs_crc_flash>
                        disk_inode->ndi_filename_len, &crc);
    if (rc != 0) {
    2f6e:	b928      	cbnz	r0, 2f7c <nffs_crc_disk_inode_validate+0x34>
        return rc;
    }

    *out_crc = crc;
    2f70:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    rc = nffs_crc_disk_inode(disk_inode, area_idx, area_offset, &crc);
    if (rc != 0) {
        return rc;
    }

    if (crc != disk_inode->ndi_crc16) {
    2f74:	8a63      	ldrh	r3, [r4, #18]
    2f76:	1a18      	subs	r0, r3, r0
    2f78:	bf18      	it	ne
    2f7a:	2001      	movne	r0, #1
        return FS_ECORRUPT;
    }

    return 0;
}
    2f7c:	b004      	add	sp, #16
    2f7e:	bd70      	pop	{r4, r5, r6, pc}

00002f80 <nffs_crc_disk_inode_fill>:

void
nffs_crc_disk_inode_fill(struct nffs_disk_inode *disk_inode,
                         const char *filename)
{
    2f80:	b538      	push	{r3, r4, r5, lr}
    2f82:	4604      	mov	r4, r0
    2f84:	460d      	mov	r5, r1
static uint16_t
nffs_crc_disk_inode_hdr(const struct nffs_disk_inode *disk_inode)
{
    uint16_t crc;

    crc = crc16_ccitt(0, disk_inode, NFFS_DISK_INODE_OFFSET_CRC);
    2f86:	2212      	movs	r2, #18
    2f88:	4621      	mov	r1, r4
    2f8a:	2000      	movs	r0, #0
    2f8c:	f002 fa7a 	bl	5484 <crc16_ccitt>
                         const char *filename)
{
    uint16_t crc16;

    crc16 = nffs_crc_disk_inode_hdr(disk_inode);
    crc16 = crc16_ccitt(crc16, filename, disk_inode->ndi_filename_len);
    2f90:	4629      	mov	r1, r5
    2f92:	7c62      	ldrb	r2, [r4, #17]
    2f94:	f002 fa76 	bl	5484 <crc16_ccitt>

    disk_inode->ndi_crc16 = crc16;
    2f98:	8260      	strh	r0, [r4, #18]
    2f9a:	bd38      	pop	{r3, r4, r5, pc}

00002f9c <nffs_gc_copy_object.isra.0>:
 * to determine if garbage collection occurred.
 */
unsigned int nffs_gc_count;

static int
nffs_gc_copy_object(struct nffs_hash_entry *entry, uint16_t object_size,
    2f9c:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f9e:	b085      	sub	sp, #20
    2fa0:	460d      	mov	r5, r1
    2fa2:	4614      	mov	r4, r2
    uint32_t from_area_offset;
    uint32_t to_area_offset;
    uint8_t from_area_idx;
    int rc;

    nffs_flash_loc_expand(entry->nhe_flash_loc,
    2fa4:	f10d 010b 	add.w	r1, sp, #11
    2fa8:	aa03      	add	r2, sp, #12
 * to determine if garbage collection occurred.
 */
unsigned int nffs_gc_count;

static int
nffs_gc_copy_object(struct nffs_hash_entry *entry, uint16_t object_size,
    2faa:	4606      	mov	r6, r0
    uint32_t from_area_offset;
    uint32_t to_area_offset;
    uint8_t from_area_idx;
    int rc;

    nffs_flash_loc_expand(entry->nhe_flash_loc,
    2fac:	6800      	ldr	r0, [r0, #0]
    2fae:	f7fd fefb 	bl	da8 <nffs_flash_loc_expand>
                          &from_area_idx, &from_area_offset);
    to_area_offset = nffs_areas[to_area_idx].na_cur;
    2fb2:	4b0b      	ldr	r3, [pc, #44]	; (2fe0 <nffs_gc_copy_object.isra.0+0x44>)

    rc = nffs_flash_copy(from_area_idx, from_area_offset, to_area_idx,
    2fb4:	f89d 000b 	ldrb.w	r0, [sp, #11]
    uint8_t from_area_idx;
    int rc;

    nffs_flash_loc_expand(entry->nhe_flash_loc,
                          &from_area_idx, &from_area_offset);
    to_area_offset = nffs_areas[to_area_idx].na_cur;
    2fb8:	681b      	ldr	r3, [r3, #0]

    rc = nffs_flash_copy(from_area_idx, from_area_offset, to_area_idx,
    2fba:	9903      	ldr	r1, [sp, #12]
    uint8_t from_area_idx;
    int rc;

    nffs_flash_loc_expand(entry->nhe_flash_loc,
                          &from_area_idx, &from_area_offset);
    to_area_offset = nffs_areas[to_area_idx].na_cur;
    2fbc:	eb03 1304 	add.w	r3, r3, r4, lsl #4

    rc = nffs_flash_copy(from_area_idx, from_area_offset, to_area_idx,
    2fc0:	4622      	mov	r2, r4
    uint8_t from_area_idx;
    int rc;

    nffs_flash_loc_expand(entry->nhe_flash_loc,
                          &from_area_idx, &from_area_offset);
    to_area_offset = nffs_areas[to_area_idx].na_cur;
    2fc2:	689f      	ldr	r7, [r3, #8]

    rc = nffs_flash_copy(from_area_idx, from_area_offset, to_area_idx,
    2fc4:	9500      	str	r5, [sp, #0]
    2fc6:	463b      	mov	r3, r7
    2fc8:	f7fd feb8 	bl	d3c <nffs_flash_copy>
                         to_area_offset, object_size);
    if (rc != 0) {
    2fcc:	4605      	mov	r5, r0
    2fce:	b920      	cbnz	r0, 2fda <nffs_gc_copy_object.isra.0+0x3e>
        return rc;
    }

    entry->nhe_flash_loc = nffs_flash_loc(to_area_idx, to_area_offset);
    2fd0:	4620      	mov	r0, r4
    2fd2:	4639      	mov	r1, r7
    2fd4:	f7fd fed8 	bl	d88 <nffs_flash_loc>
    2fd8:	6030      	str	r0, [r6, #0]

    return 0;
}
    2fda:	4628      	mov	r0, r5
    2fdc:	b005      	add	sp, #20
    2fde:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2fe0:	20000b40 	.word	0x20000b40

00002fe4 <nffs_gc_block_chain_copy>:
}

static int
nffs_gc_block_chain_copy(struct nffs_hash_entry *last_entry, uint32_t data_len,
                         uint8_t to_area_idx)
{
    2fe4:	b5f0      	push	{r4, r5, r6, r7, lr}
    2fe6:	4604      	mov	r4, r0
    2fe8:	b087      	sub	sp, #28
    2fea:	460e      	mov	r6, r1
    2fec:	4617      	mov	r7, r2
    struct nffs_block block;
    uint32_t data_bytes_copied;
    uint16_t copy_len;
    int rc;

    data_bytes_copied = 0;
    2fee:	2500      	movs	r5, #0
    entry = last_entry;

    while (data_bytes_copied < data_len) {
    2ff0:	42b5      	cmp	r5, r6
    2ff2:	d21a      	bcs.n	302a <nffs_gc_block_chain_copy+0x46>
        assert(entry != NULL);
    2ff4:	b92c      	cbnz	r4, 3002 <nffs_gc_block_chain_copy+0x1e>
    2ff6:	480e      	ldr	r0, [pc, #56]	; (3030 <nffs_gc_block_chain_copy+0x4c>)
    2ff8:	2184      	movs	r1, #132	; 0x84
    2ffa:	4622      	mov	r2, r4
    2ffc:	4623      	mov	r3, r4
    2ffe:	f001 fe25 	bl	4c4c <__assert_func>

        rc = nffs_block_from_hash_entry(&block, entry);
    3002:	a801      	add	r0, sp, #4
    3004:	4621      	mov	r1, r4
    3006:	f7ff fee5 	bl	2dd4 <nffs_block_from_hash_entry>
        if (rc != 0) {
    300a:	b978      	cbnz	r0, 302c <nffs_gc_block_chain_copy+0x48>
            return rc;
        }

        copy_len = sizeof (struct nffs_disk_block) + block.nb_data_len;
    300c:	f8bd 1014 	ldrh.w	r1, [sp, #20]
    3010:	3114      	adds	r1, #20
        rc = nffs_gc_copy_object(entry, copy_len, to_area_idx);
    3012:	f104 0008 	add.w	r0, r4, #8
    3016:	b289      	uxth	r1, r1
    3018:	463a      	mov	r2, r7
    301a:	f7ff ffbf 	bl	2f9c <nffs_gc_copy_object.isra.0>
        if (rc != 0) {
    301e:	b928      	cbnz	r0, 302c <nffs_gc_block_chain_copy+0x48>
            return rc;
        }
        data_bytes_copied += block.nb_data_len;
    3020:	f8bd 3014 	ldrh.w	r3, [sp, #20]

        entry = block.nb_prev;
    3024:	9c04      	ldr	r4, [sp, #16]
        copy_len = sizeof (struct nffs_disk_block) + block.nb_data_len;
        rc = nffs_gc_copy_object(entry, copy_len, to_area_idx);
        if (rc != 0) {
            return rc;
        }
        data_bytes_copied += block.nb_data_len;
    3026:	441d      	add	r5, r3
    3028:	e7e2      	b.n	2ff0 <nffs_gc_block_chain_copy+0xc>

        entry = block.nb_prev;
    }

    return 0;
    302a:	2000      	movs	r0, #0
}
    302c:	b007      	add	sp, #28
    302e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3030:	00006320 	.word	0x00006320

00003034 <nffs_gc_block_chain>:
 */
static int
nffs_gc_block_chain(struct nffs_hash_entry *last_entry, int multiple_blocks,
                    uint32_t data_len, uint8_t to_area_idx,
                    struct nffs_hash_entry **inout_next)
{
    3034:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3038:	b095      	sub	sp, #84	; 0x54
    303a:	4681      	mov	r9, r0
    303c:	4616      	mov	r6, r2
    303e:	461d      	mov	r5, r3
    3040:	f8dd b078 	ldr.w	fp, [sp, #120]	; 0x78
    int rc;

    if (!multiple_blocks) {
    3044:	2900      	cmp	r1, #0
    3046:	f000 809d 	beq.w	3184 <nffs_gc_block_chain+0x150>
    uint32_t data_offset;
    uint8_t *data;
    uint8_t from_area_idx;
    int rc;

    memset(&last_block, 0, sizeof last_block);
    304a:	2100      	movs	r1, #0
    304c:	2214      	movs	r2, #20
    304e:	a80a      	add	r0, sp, #40	; 0x28
    3050:	f000 fc88 	bl	3964 <memset>

    data = malloc(data_len);
    3054:	4630      	mov	r0, r6
    3056:	f001 fe45 	bl	4ce4 <os_malloc>
    if (data == NULL) {
    305a:	4680      	mov	r8, r0
    305c:	2800      	cmp	r0, #0
    305e:	f000 808a 	beq.w	3176 <nffs_gc_block_chain+0x142>
        rc = FS_ENOMEM;
        goto done;
    }

    memset(&last_block, 0, sizeof(last_block));
    3062:	a80a      	add	r0, sp, #40	; 0x28
    3064:	2100      	movs	r1, #0
    3066:	2214      	movs	r2, #20
    3068:	f000 fc7c 	bl	3964 <memset>

    to_area = nffs_areas + to_area_idx;
    306c:	4b4a      	ldr	r3, [pc, #296]	; (3198 <nffs_gc_block_chain+0x164>)
    306e:	681b      	ldr	r3, [r3, #0]
    3070:	9301      	str	r3, [sp, #4]

    entry = last_entry;
    data_offset = data_len;
    3072:	4637      	mov	r7, r6
        goto done;
    }

    memset(&last_block, 0, sizeof(last_block));

    to_area = nffs_areas + to_area_idx;
    3074:	46ca      	mov	sl, r9

    entry = last_entry;
    data_offset = data_len;
    while (data_offset > 0) {
    3076:	2f00      	cmp	r7, #0
    3078:	d03b      	beq.n	30f2 <nffs_gc_block_chain+0xbe>
        rc = nffs_block_from_hash_entry(&block, entry);
    307a:	a80f      	add	r0, sp, #60	; 0x3c
    307c:	4651      	mov	r1, sl
    307e:	f7ff fea9 	bl	2dd4 <nffs_block_from_hash_entry>
        if (rc != 0) {
    3082:	4604      	mov	r4, r0
    3084:	2800      	cmp	r0, #0
    3086:	d177      	bne.n	3178 <nffs_gc_block_chain+0x144>
            goto done;
        }
        data_offset -= block.nb_data_len;
    3088:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
    308c:	1aff      	subs	r7, r7, r3

        nffs_flash_loc_expand(block.nb_hash_entry->nhe_flash_loc,
    308e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3090:	f10d 010f 	add.w	r1, sp, #15
    3094:	6898      	ldr	r0, [r3, #8]
    3096:	aa04      	add	r2, sp, #16
    3098:	f7fd fe86 	bl	da8 <nffs_flash_loc_expand>
                              &from_area_idx, &from_area_offset);
        from_area_offset += sizeof disk_block;
    309c:	9904      	ldr	r1, [sp, #16]
        rc = nffs_flash_read(from_area_idx, from_area_offset,
    309e:	f89d 000f 	ldrb.w	r0, [sp, #15]
    30a2:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
        }
        data_offset -= block.nb_data_len;

        nffs_flash_loc_expand(block.nb_hash_entry->nhe_flash_loc,
                              &from_area_idx, &from_area_offset);
        from_area_offset += sizeof disk_block;
    30a6:	3114      	adds	r1, #20
        rc = nffs_flash_read(from_area_idx, from_area_offset,
    30a8:	eb08 0207 	add.w	r2, r8, r7
        }
        data_offset -= block.nb_data_len;

        nffs_flash_loc_expand(block.nb_hash_entry->nhe_flash_loc,
                              &from_area_idx, &from_area_offset);
        from_area_offset += sizeof disk_block;
    30ac:	9104      	str	r1, [sp, #16]
        rc = nffs_flash_read(from_area_idx, from_area_offset,
    30ae:	f7fd fdf5 	bl	c9c <nffs_flash_read>
                             data + data_offset, block.nb_data_len);
        if (rc != 0) {
    30b2:	4604      	mov	r4, r0
    30b4:	2800      	cmp	r0, #0
    30b6:	d15f      	bne.n	3178 <nffs_gc_block_chain+0x144>
            goto done;
        }

        if (entry != last_entry) {
    30b8:	45ca      	cmp	sl, r9
    30ba:	d00e      	beq.n	30da <nffs_gc_block_chain+0xa6>
            if (inout_next != NULL && *inout_next == entry) {
    30bc:	f1bb 0f00 	cmp.w	fp, #0
    30c0:	d007      	beq.n	30d2 <nffs_gc_block_chain+0x9e>
    30c2:	f8db 3000 	ldr.w	r3, [fp]
    30c6:	4553      	cmp	r3, sl
                *inout_next = SLIST_NEXT(entry, nhe_next);
    30c8:	bf04      	itt	eq
    30ca:	f8da 3000 	ldreq.w	r3, [sl]
    30ce:	f8cb 3000 	streq.w	r3, [fp]
            }
            nffs_block_delete_from_ram(entry);
    30d2:	4650      	mov	r0, sl
    30d4:	f7ff fec4 	bl	2e60 <nffs_block_delete_from_ram>
    30d8:	e008      	b.n	30ec <nffs_gc_block_chain+0xb8>
        } else {
            last_block = block;
    30da:	ac0f      	add	r4, sp, #60	; 0x3c
    30dc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    30de:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
    30e2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    30e6:	6823      	ldr	r3, [r4, #0]
    30e8:	f8ce 3000 	str.w	r3, [lr]
        }
        entry = block.nb_prev;
    30ec:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
    30f0:	e7c1      	b.n	3076 <nffs_gc_block_chain+0x42>
    }

    /* we had better have found the last block */
    assert(last_block.nb_hash_entry);
    30f2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    30f4:	b92c      	cbnz	r4, 3102 <nffs_gc_block_chain+0xce>
    30f6:	4829      	ldr	r0, [pc, #164]	; (319c <nffs_gc_block_chain+0x168>)
    30f8:	21e7      	movs	r1, #231	; 0xe7
    30fa:	463a      	mov	r2, r7
    30fc:	463b      	mov	r3, r7
    30fe:	f001 fda5 	bl	4c4c <__assert_func>
    /* The resulting block should inherit its ID from its last constituent
     * block (this is the ID referenced by the parent inode and subsequent data
     * block).  The previous ID gets inherited from the first constituent
     * block.
     */
    memset(&disk_block, 0, sizeof disk_block);
    3102:	a805      	add	r0, sp, #20
    3104:	4639      	mov	r1, r7
    3106:	2214      	movs	r2, #20
    3108:	f000 fc2c 	bl	3964 <memset>
    disk_block.ndb_id = last_block.nb_hash_entry->nhe_id;
    310c:	6863      	ldr	r3, [r4, #4]
    310e:	9305      	str	r3, [sp, #20]
    disk_block.ndb_seq = last_block.nb_seq + 1;
    3110:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3112:	3301      	adds	r3, #1
    3114:	f8ad 3020 	strh.w	r3, [sp, #32]
    disk_block.ndb_inode_id = last_block.nb_inode_entry->nie_hash_entry.nhe_id;
    3118:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    311a:	685b      	ldr	r3, [r3, #4]
    311c:	9306      	str	r3, [sp, #24]
    if (entry == NULL) {
    311e:	f1ba 0f00 	cmp.w	sl, #0
    3122:	d102      	bne.n	312a <nffs_gc_block_chain+0xf6>
        disk_block.ndb_prev_id = NFFS_ID_NONE;
    3124:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3128:	e001      	b.n	312e <nffs_gc_block_chain+0xfa>
    } else {
        disk_block.ndb_prev_id = entry->nhe_id;
    312a:	f8da 3004 	ldr.w	r3, [sl, #4]
    312e:	9307      	str	r3, [sp, #28]
    }
    disk_block.ndb_data_len = data_len;
    nffs_crc_disk_block_fill(&disk_block, data);
    3130:	a805      	add	r0, sp, #20
    3132:	4641      	mov	r1, r8
    if (entry == NULL) {
        disk_block.ndb_prev_id = NFFS_ID_NONE;
    } else {
        disk_block.ndb_prev_id = entry->nhe_id;
    }
    disk_block.ndb_data_len = data_len;
    3134:	f8ad 6024 	strh.w	r6, [sp, #36]	; 0x24
    nffs_crc_disk_block_fill(&disk_block, data);
    3138:	f7ff fefb 	bl	2f32 <nffs_crc_disk_block_fill>

    to_area_offset = to_area->na_cur;
    313c:	9b01      	ldr	r3, [sp, #4]
    313e:	eb03 1a05 	add.w	sl, r3, r5, lsl #4
    rc = nffs_flash_write(to_area_idx, to_area_offset,
    3142:	4628      	mov	r0, r5
        disk_block.ndb_prev_id = entry->nhe_id;
    }
    disk_block.ndb_data_len = data_len;
    nffs_crc_disk_block_fill(&disk_block, data);

    to_area_offset = to_area->na_cur;
    3144:	f8da 7008 	ldr.w	r7, [sl, #8]
    rc = nffs_flash_write(to_area_idx, to_area_offset,
    3148:	aa05      	add	r2, sp, #20
    314a:	4639      	mov	r1, r7
    314c:	2314      	movs	r3, #20
    314e:	f7fd fdcb 	bl	ce8 <nffs_flash_write>
                          &disk_block, sizeof disk_block);
    if (rc != 0) {
    3152:	4604      	mov	r4, r0
    3154:	b980      	cbnz	r0, 3178 <nffs_gc_block_chain+0x144>
        goto done;
    }

    rc = nffs_flash_write(to_area_idx, to_area_offset + sizeof disk_block,
    3156:	4628      	mov	r0, r5
    3158:	f107 0114 	add.w	r1, r7, #20
    315c:	4642      	mov	r2, r8
    315e:	4633      	mov	r3, r6
    3160:	f7fd fdc2 	bl	ce8 <nffs_flash_write>
                          data, data_len);
    if (rc != 0) {
    3164:	4604      	mov	r4, r0
    3166:	b938      	cbnz	r0, 3178 <nffs_gc_block_chain+0x144>
        goto done;
    }

    last_entry->nhe_flash_loc = nffs_flash_loc(to_area_idx, to_area_offset);
    3168:	4628      	mov	r0, r5
    316a:	4639      	mov	r1, r7
    316c:	f7fd fe0c 	bl	d88 <nffs_flash_loc>
    3170:	f8c9 0008 	str.w	r0, [r9, #8]
    3174:	e000      	b.n	3178 <nffs_gc_block_chain+0x144>

    memset(&last_block, 0, sizeof last_block);

    data = malloc(data_len);
    if (data == NULL) {
        rc = FS_ENOMEM;
    3176:	2405      	movs	r4, #5

    ASSERT_IF_TEST(nffs_crc_disk_block_validate(&disk_block, to_area_idx,
                                                to_area_offset) == 0);

done:
    free(data);
    3178:	4640      	mov	r0, r8
    317a:	f001 fdbf 	bl	4cfc <os_free>
         */
        rc = nffs_gc_block_chain_copy(last_entry, data_len, to_area_idx);
    } else {
        rc = nffs_gc_block_chain_collate(last_entry, data_len, to_area_idx,
                                         inout_next);
        if (rc == FS_ENOMEM) {
    317e:	2c05      	cmp	r4, #5
    3180:	d105      	bne.n	318e <nffs_gc_block_chain+0x15a>
            /* Insufficient heap for collation; just copy each block one by
             * one.
             */
            rc = nffs_gc_block_chain_copy(last_entry, data_len, to_area_idx);
    3182:	4648      	mov	r0, r9
    3184:	4631      	mov	r1, r6
    3186:	462a      	mov	r2, r5
    3188:	f7ff ff2c 	bl	2fe4 <nffs_gc_block_chain_copy>
    318c:	4604      	mov	r4, r0
        }
    }

    return rc;
}
    318e:	4620      	mov	r0, r4
    3190:	b015      	add	sp, #84	; 0x54
    3192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3196:	bf00      	nop
    3198:	20000b40 	.word	0x20000b40
    319c:	00006320 	.word	0x00006320

000031a0 <nffs_gc>:
 *
 * @return                  0 on success; nonzero on error.
 */
int
nffs_gc(uint8_t *out_area_idx)
{
    31a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t best_area_idx;
    int8_t diff;
    int i;

    best_area_idx = 0;
    for (i = 1; i < nffs_num_areas; i++) {
    31a4:	4b7d      	ldr	r3, [pc, #500]	; (339c <nffs_gc+0x1fc>)
        if (i == nffs_scratch_area_idx) {
    31a6:	4f7e      	ldr	r7, [pc, #504]	; (33a0 <nffs_gc+0x200>)
    uint8_t best_area_idx;
    int8_t diff;
    int i;

    best_area_idx = 0;
    for (i = 1; i < nffs_num_areas; i++) {
    31a8:	781e      	ldrb	r6, [r3, #0]
        if (i == nffs_scratch_area_idx) {
            continue;
        }

        area = nffs_areas + i;
    31aa:	4b7e      	ldr	r3, [pc, #504]	; (33a4 <nffs_gc+0x204>)
    int8_t diff;
    int i;

    best_area_idx = 0;
    for (i = 1; i < nffs_num_areas; i++) {
        if (i == nffs_scratch_area_idx) {
    31ac:	f897 9000 	ldrb.w	r9, [r7]
            continue;
        }

        area = nffs_areas + i;
    31b0:	f8d3 8000 	ldr.w	r8, [r3]
 *
 * @return                  0 on success; nonzero on error.
 */
int
nffs_gc(uint8_t *out_area_idx)
{
    31b4:	b091      	sub	sp, #68	; 0x44
    31b6:	4642      	mov	r2, r8
    31b8:	9004      	str	r0, [sp, #16]
    uint8_t best_area_idx;
    int8_t diff;
    int i;

    best_area_idx = 0;
    for (i = 1; i < nffs_num_areas; i++) {
    31ba:	2301      	movs	r3, #1
    const struct nffs_area *area;
    uint8_t best_area_idx;
    int8_t diff;
    int i;

    best_area_idx = 0;
    31bc:	2400      	movs	r4, #0
    31be:	9702      	str	r7, [sp, #8]
    for (i = 1; i < nffs_num_areas; i++) {
    31c0:	42b3      	cmp	r3, r6
    31c2:	da12      	bge.n	31ea <nffs_gc+0x4a>
        if (i == nffs_scratch_area_idx) {
    31c4:	454b      	cmp	r3, r9
    31c6:	d00d      	beq.n	31e4 <nffs_gc+0x44>
            continue;
        }

        area = nffs_areas + i;
        if (area->na_length > nffs_areas[best_area_idx].na_length) {
    31c8:	eb08 1504 	add.w	r5, r8, r4, lsl #4
    31cc:	6950      	ldr	r0, [r2, #20]
    31ce:	6869      	ldr	r1, [r5, #4]
    31d0:	4288      	cmp	r0, r1
    31d2:	d806      	bhi.n	31e2 <nffs_gc+0x42>
            best_area_idx = i;
        } else if (best_area_idx == nffs_scratch_area_idx) {
    31d4:	454c      	cmp	r4, r9
    31d6:	d004      	beq.n	31e2 <nffs_gc+0x42>
            best_area_idx = i;
        } else {
            diff = nffs_areas[i].na_gc_seq -
    31d8:	7f91      	ldrb	r1, [r2, #30]
    31da:	7ba8      	ldrb	r0, [r5, #14]
    31dc:	1a09      	subs	r1, r1, r0
                   nffs_areas[best_area_idx].na_gc_seq;
            if (diff < 0) {
    31de:	0609      	lsls	r1, r1, #24
    31e0:	d500      	bpl.n	31e4 <nffs_gc+0x44>
                best_area_idx = i;
    31e2:	b2dc      	uxtb	r4, r3
    uint8_t best_area_idx;
    int8_t diff;
    int i;

    best_area_idx = 0;
    for (i = 1; i < nffs_num_areas; i++) {
    31e4:	3301      	adds	r3, #1
    31e6:	3210      	adds	r2, #16
    31e8:	e7ea      	b.n	31c0 <nffs_gc+0x20>
                best_area_idx = i;
            }
        }
    }

    assert(best_area_idx != nffs_scratch_area_idx);
    31ea:	454c      	cmp	r4, r9
    31ec:	d103      	bne.n	31f6 <nffs_gc+0x56>
    31ee:	486e      	ldr	r0, [pc, #440]	; (33a8 <nffs_gc+0x208>)
    31f0:	2171      	movs	r1, #113	; 0x71
    31f2:	2200      	movs	r2, #0
    31f4:	e03d      	b.n	3272 <nffs_gc+0xd2>
    uint8_t area_idx;
    int rc;
    int i;

    from_area_idx = nffs_gc_select_area();
    from_area = nffs_areas + from_area_idx;
    31f6:	eb08 1a04 	add.w	sl, r8, r4, lsl #4
    to_area = nffs_areas + nffs_scratch_area_idx;

    rc = nffs_format_from_scratch_area(nffs_scratch_area_idx,
    31fa:	4648      	mov	r0, r9
    31fc:	f89a 100c 	ldrb.w	r1, [sl, #12]
    3200:	f7fd fe02 	bl	e08 <nffs_format_from_scratch_area>
                                       from_area->na_id);
    if (rc != 0) {
    3204:	2800      	cmp	r0, #0
    3206:	f040 80c5 	bne.w	3394 <nffs_gc+0x1f4>
    320a:	4683      	mov	fp, r0
        return rc;
    }

    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        entry = SLIST_FIRST(nffs_hash + i);
    320c:	4b67      	ldr	r3, [pc, #412]	; (33ac <nffs_gc+0x20c>)
    320e:	681b      	ldr	r3, [r3, #0]
    3210:	f853 500b 	ldr.w	r5, [r3, fp]
        while (entry != NULL) {
    3214:	e008      	b.n	3228 <nffs_gc+0x88>
    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));

    data_len = 0;
    last_entry = NULL;
    multiple_blocks = 0;
    entry = inode_entry->nie_last_block_entry;
    3216:	692f      	ldr	r7, [r5, #16]

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));

    data_len = 0;
    last_entry = NULL;
    multiple_blocks = 0;
    3218:	2500      	movs	r5, #0
    int multiple_blocks;
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));

    data_len = 0;
    321a:	462b      	mov	r3, r5
    last_entry = NULL;
    321c:	462e      	mov	r6, r5
    multiple_blocks = 0;
    entry = inode_entry->nie_last_block_entry;
    while (entry != NULL) {
    321e:	2f00      	cmp	r7, #0
    3220:	d13e      	bne.n	32a0 <nffs_gc+0x100>
        }

        entry = block.nb_prev;
    }

    if (last_entry != NULL) {
    3222:	2e00      	cmp	r6, #0
    3224:	d17e      	bne.n	3324 <nffs_gc+0x184>
                        return rc;
                    }
                }
            }

            entry = next;
    3226:	9d08      	ldr	r5, [sp, #32]
        return rc;
    }

    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        entry = SLIST_FIRST(nffs_hash + i);
        while (entry != NULL) {
    3228:	2d00      	cmp	r5, #0
    322a:	f000 8087 	beq.w	333c <nffs_gc+0x19c>
            next = SLIST_NEXT(entry, nhe_next);
    322e:	682b      	ldr	r3, [r5, #0]

            if (nffs_hash_id_is_inode(entry->nhe_id)) {
    3230:	6868      	ldr	r0, [r5, #4]
    }

    for (i = 0; i < NFFS_HASH_SIZE; i++) {
        entry = SLIST_FIRST(nffs_hash + i);
        while (entry != NULL) {
            next = SLIST_NEXT(entry, nhe_next);
    3232:	9308      	str	r3, [sp, #32]

            if (nffs_hash_id_is_inode(entry->nhe_id)) {
    3234:	f7fd fe42 	bl	ebc <nffs_hash_id_is_inode>
    3238:	2800      	cmp	r0, #0
    323a:	d0f4      	beq.n	3226 <nffs_gc+0x86>
                /* The inode gets copied if it is in the source area. */
                nffs_flash_loc_expand(entry->nhe_flash_loc,
    323c:	68a8      	ldr	r0, [r5, #8]
    323e:	f10d 011e 	add.w	r1, sp, #30
    3242:	aa09      	add	r2, sp, #36	; 0x24
    3244:	f7fd fdb0 	bl	da8 <nffs_flash_loc_expand>
                                      &area_idx, &area_offset);
                inode_entry = (struct nffs_inode_entry *)entry;
                if (area_idx == from_area_idx) {
    3248:	f89d 301e 	ldrb.w	r3, [sp, #30]
    324c:	42a3      	cmp	r3, r4
    324e:	d013      	beq.n	3278 <nffs_gc+0xd8>
                }

                /* If the inode is a file, all constituent data blocks that are
                 * resident in the source area get copied.
                 */
                if (nffs_hash_id_is_file(entry->nhe_id)) {
    3250:	6868      	ldr	r0, [r5, #4]
    3252:	f7fd fe2b 	bl	eac <nffs_hash_id_is_file>
    3256:	2800      	cmp	r0, #0
    3258:	d0e5      	beq.n	3226 <nffs_gc+0x86>
                    rc = nffs_gc_inode_blocks(inode_entry, from_area_idx,
    325a:	9b02      	ldr	r3, [sp, #8]
    uint32_t data_len;
    uint8_t area_idx;
    int multiple_blocks;
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));
    325c:	6868      	ldr	r0, [r5, #4]

                /* If the inode is a file, all constituent data blocks that are
                 * resident in the source area get copied.
                 */
                if (nffs_hash_id_is_file(entry->nhe_id)) {
                    rc = nffs_gc_inode_blocks(inode_entry, from_area_idx,
    325e:	781b      	ldrb	r3, [r3, #0]
    3260:	9303      	str	r3, [sp, #12]
    uint32_t data_len;
    uint8_t area_idx;
    int multiple_blocks;
    int rc;

    assert(nffs_hash_id_is_file(inode_entry->nie_hash_entry.nhe_id));
    3262:	f7fd fe23 	bl	eac <nffs_hash_id_is_file>
    3266:	4602      	mov	r2, r0
    3268:	2800      	cmp	r0, #0
    326a:	d1d4      	bne.n	3216 <nffs_gc+0x76>
    326c:	484e      	ldr	r0, [pc, #312]	; (33a8 <nffs_gc+0x208>)
    326e:	f240 1151 	movw	r1, #337	; 0x151
    3272:	4613      	mov	r3, r2
    3274:	f001 fcea 	bl	4c4c <__assert_func>
                /* The inode gets copied if it is in the source area. */
                nffs_flash_loc_expand(entry->nhe_flash_loc,
                                      &area_idx, &area_offset);
                inode_entry = (struct nffs_inode_entry *)entry;
                if (area_idx == from_area_idx) {
                    rc = nffs_gc_copy_inode(inode_entry,
    3278:	9b02      	ldr	r3, [sp, #8]
{
    struct nffs_inode inode;
    uint16_t copy_len;
    int rc;

    rc = nffs_inode_from_entry(&inode, inode_entry);
    327a:	a80b      	add	r0, sp, #44	; 0x2c
    327c:	4629      	mov	r1, r5
                /* The inode gets copied if it is in the source area. */
                nffs_flash_loc_expand(entry->nhe_flash_loc,
                                      &area_idx, &area_offset);
                inode_entry = (struct nffs_inode_entry *)entry;
                if (area_idx == from_area_idx) {
                    rc = nffs_gc_copy_inode(inode_entry,
    327e:	781e      	ldrb	r6, [r3, #0]
{
    struct nffs_inode inode;
    uint16_t copy_len;
    int rc;

    rc = nffs_inode_from_entry(&inode, inode_entry);
    3280:	f7fe f9fa 	bl	1678 <nffs_inode_from_entry>
    if (rc != 0) {
    3284:	2800      	cmp	r0, #0
    3286:	f040 8085 	bne.w	3394 <nffs_gc+0x1f4>
        return rc;
    }
    copy_len = sizeof (struct nffs_disk_inode) + inode.ni_filename_len;
    328a:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38

    rc = nffs_gc_copy_object(&inode_entry->nie_hash_entry, copy_len,
    328e:	f105 0008 	add.w	r0, r5, #8
    3292:	3114      	adds	r1, #20
    3294:	4632      	mov	r2, r6
    3296:	f7ff fe81 	bl	2f9c <nffs_gc_copy_object.isra.0>
                                      &area_idx, &area_offset);
                inode_entry = (struct nffs_inode_entry *)entry;
                if (area_idx == from_area_idx) {
                    rc = nffs_gc_copy_inode(inode_entry,
                                            nffs_scratch_area_idx);
                    if (rc != 0) {
    329a:	2800      	cmp	r0, #0
    329c:	d0d8      	beq.n	3250 <nffs_gc+0xb0>
    329e:	e079      	b.n	3394 <nffs_gc+0x1f4>
    data_len = 0;
    last_entry = NULL;
    multiple_blocks = 0;
    entry = inode_entry->nie_last_block_entry;
    while (entry != NULL) {
        rc = nffs_block_from_hash_entry(&block, entry);
    32a0:	a80b      	add	r0, sp, #44	; 0x2c
    32a2:	4639      	mov	r1, r7
    32a4:	9305      	str	r3, [sp, #20]
    32a6:	f7ff fd95 	bl	2dd4 <nffs_block_from_hash_entry>
        if (rc != 0) {
    32aa:	2800      	cmp	r0, #0
    32ac:	d172      	bne.n	3394 <nffs_gc+0x1f4>
            return rc;
        }

        nffs_flash_loc_expand(entry->nhe_flash_loc, &area_idx, &area_offset);
    32ae:	aa0a      	add	r2, sp, #40	; 0x28
    32b0:	68b8      	ldr	r0, [r7, #8]
    32b2:	f10d 011f 	add.w	r1, sp, #31
    32b6:	f7fd fd77 	bl	da8 <nffs_flash_loc_expand>
        if (area_idx == from_area_idx) {
    32ba:	f89d 201f 	ldrb.w	r2, [sp, #31]
    32be:	9b05      	ldr	r3, [sp, #20]
    32c0:	42a2      	cmp	r2, r4
    32c2:	d11c      	bne.n	32fe <nffs_gc+0x15e>
            if (last_entry == NULL) {
                last_entry = entry;
            }

            prospective_data_len = data_len + block.nb_data_len;
            if (prospective_data_len <= nffs_block_max_data_sz) {
    32c4:	493a      	ldr	r1, [pc, #232]	; (33b0 <nffs_gc+0x210>)
        if (area_idx == from_area_idx) {
            if (last_entry == NULL) {
                last_entry = entry;
            }

            prospective_data_len = data_len + block.nb_data_len;
    32c6:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
            if (prospective_data_len <= nffs_block_max_data_sz) {
    32ca:	8809      	ldrh	r1, [r1, #0]
        if (area_idx == from_area_idx) {
            if (last_entry == NULL) {
                last_entry = entry;
            }

            prospective_data_len = data_len + block.nb_data_len;
    32cc:	441a      	add	r2, r3
            return rc;
        }

        nffs_flash_loc_expand(entry->nhe_flash_loc, &area_idx, &area_offset);
        if (area_idx == from_area_idx) {
            if (last_entry == NULL) {
    32ce:	2e00      	cmp	r6, #0
    32d0:	bf08      	it	eq
    32d2:	463e      	moveq	r6, r7
                last_entry = entry;
            }

            prospective_data_len = data_len + block.nb_data_len;
            if (prospective_data_len <= nffs_block_max_data_sz) {
    32d4:	428a      	cmp	r2, r1
    32d6:	d803      	bhi.n	32e0 <nffs_gc+0x140>
                data_len = prospective_data_len;
                if (last_entry != entry) {
                    multiple_blocks = 1;
    32d8:	42be      	cmp	r6, r7
    32da:	bf18      	it	ne
    32dc:	2501      	movne	r5, #1
    32de:	e01e      	b.n	331e <nffs_gc+0x17e>
                }
            } else {
                rc = nffs_gc_block_chain(last_entry, multiple_blocks, data_len,
    32e0:	aa08      	add	r2, sp, #32
    32e2:	9200      	str	r2, [sp, #0]
    32e4:	4630      	mov	r0, r6
    32e6:	461a      	mov	r2, r3
    32e8:	4629      	mov	r1, r5
    32ea:	9b03      	ldr	r3, [sp, #12]
    32ec:	f7ff fea2 	bl	3034 <nffs_gc_block_chain>
                                         to_area_idx, inout_next);
                if (rc != 0) {
    32f0:	2800      	cmp	r0, #0
    32f2:	d14f      	bne.n	3394 <nffs_gc+0x1f4>
                    return rc;
                }
                last_entry = entry;
                data_len = block.nb_data_len;
    32f4:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
    32f8:	463e      	mov	r6, r7
                multiple_blocks = 0;
    32fa:	4605      	mov	r5, r0
    32fc:	e00f      	b.n	331e <nffs_gc+0x17e>
            }
        } else {
            if (last_entry != NULL) {
    32fe:	b16e      	cbz	r6, 331c <nffs_gc+0x17c>
                rc = nffs_gc_block_chain(last_entry, multiple_blocks, data_len,
    3300:	aa08      	add	r2, sp, #32
    3302:	9200      	str	r2, [sp, #0]
    3304:	4630      	mov	r0, r6
    3306:	461a      	mov	r2, r3
    3308:	4629      	mov	r1, r5
    330a:	9b03      	ldr	r3, [sp, #12]
    330c:	f7ff fe92 	bl	3034 <nffs_gc_block_chain>
                                         to_area_idx, inout_next);
                if (rc != 0) {
    3310:	2800      	cmp	r0, #0
    3312:	d13f      	bne.n	3394 <nffs_gc+0x1f4>
                    return rc;
                }

                last_entry = NULL;
                data_len = 0;
                multiple_blocks = 0;
    3314:	4605      	mov	r5, r0
                if (rc != 0) {
                    return rc;
                }

                last_entry = NULL;
                data_len = 0;
    3316:	4602      	mov	r2, r0
                                         to_area_idx, inout_next);
                if (rc != 0) {
                    return rc;
                }

                last_entry = NULL;
    3318:	4606      	mov	r6, r0
    331a:	e000      	b.n	331e <nffs_gc+0x17e>
                last_entry = entry;
                data_len = block.nb_data_len;
                multiple_blocks = 0;
            }
        } else {
            if (last_entry != NULL) {
    331c:	461a      	mov	r2, r3
                data_len = 0;
                multiple_blocks = 0;
            }
        }

        entry = block.nb_prev;
    331e:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    3320:	4613      	mov	r3, r2
    3322:	e77c      	b.n	321e <nffs_gc+0x7e>
    }

    if (last_entry != NULL) {
        rc = nffs_gc_block_chain(last_entry, multiple_blocks, data_len,
    3324:	aa08      	add	r2, sp, #32
    3326:	9200      	str	r2, [sp, #0]
    3328:	4630      	mov	r0, r6
    332a:	461a      	mov	r2, r3
    332c:	4629      	mov	r1, r5
    332e:	9b03      	ldr	r3, [sp, #12]
    3330:	f7ff fe80 	bl	3034 <nffs_gc_block_chain>
                 * resident in the source area get copied.
                 */
                if (nffs_hash_id_is_file(entry->nhe_id)) {
                    rc = nffs_gc_inode_blocks(inode_entry, from_area_idx,
                                              nffs_scratch_area_idx, &next);
                    if (rc != 0) {
    3334:	2800      	cmp	r0, #0
    3336:	f43f af76 	beq.w	3226 <nffs_gc+0x86>
    333a:	e02b      	b.n	3394 <nffs_gc+0x1f4>
    333c:	f10b 0b04 	add.w	fp, fp, #4
                                       from_area->na_id);
    if (rc != 0) {
        return rc;
    }

    for (i = 0; i < NFFS_HASH_SIZE; i++) {
    3340:	f5bb 6f80 	cmp.w	fp, #1024	; 0x400
    3344:	f47f af62 	bne.w	320c <nffs_gc+0x6c>
    }

    /* The amount of written data should never increase as a result of a gc
     * cycle.
     */
    assert(to_area->na_cur <= from_area->na_cur);
    3348:	eb08 1809 	add.w	r8, r8, r9, lsl #4
    334c:	f8da 3008 	ldr.w	r3, [sl, #8]
    3350:	f8d8 2008 	ldr.w	r2, [r8, #8]
    3354:	429a      	cmp	r2, r3
    3356:	d904      	bls.n	3362 <nffs_gc+0x1c2>
    3358:	4813      	ldr	r0, [pc, #76]	; (33a8 <nffs_gc+0x208>)
    335a:	f44f 71fe 	mov.w	r1, #508	; 0x1fc
    335e:	462a      	mov	r2, r5
    3360:	e787      	b.n	3272 <nffs_gc+0xd2>

    /* Turn the source area into the new scratch area. */
    from_area->na_gc_seq++;
    3362:	f89a 300e 	ldrb.w	r3, [sl, #14]
    3366:	3301      	adds	r3, #1
    3368:	f88a 300e 	strb.w	r3, [sl, #14]
    rc = nffs_format_area(from_area_idx, 1);
    336c:	4620      	mov	r0, r4
    336e:	2101      	movs	r1, #1
    3370:	f7fd fd20 	bl	db4 <nffs_format_area>
    if (rc != 0) {
    3374:	b970      	cbnz	r0, 3394 <nffs_gc+0x1f4>
        return rc;
    }

    if (out_area_idx != NULL) {
    3376:	9b04      	ldr	r3, [sp, #16]
    3378:	b11b      	cbz	r3, 3382 <nffs_gc+0x1e2>
        *out_area_idx = nffs_scratch_area_idx;
    337a:	9b02      	ldr	r3, [sp, #8]
    337c:	9a04      	ldr	r2, [sp, #16]
    337e:	781b      	ldrb	r3, [r3, #0]
    3380:	7013      	strb	r3, [r2, #0]
    }

    nffs_scratch_area_idx = from_area_idx;
    3382:	9b02      	ldr	r3, [sp, #8]
    3384:	701c      	strb	r4, [r3, #0]
    /* Garbage collection renders the cache invalid:
     *     o All cached blocks are now invalid; drop them.
     *     o Flash locations of inodes may have changed; the cached inodes need
     *       updated to reflect this.
     */
    rc = nffs_cache_inode_refresh();
    3386:	f7fd fa15 	bl	7b4 <nffs_cache_inode_refresh>
    if (rc != 0) {
    338a:	b918      	cbnz	r0, 3394 <nffs_gc+0x1f4>
    }

    /* Increment the garbage collection counter so that client code knows to
     * reset its pointers to cached objects.
     */
    nffs_gc_count++;
    338c:	4a09      	ldr	r2, [pc, #36]	; (33b4 <nffs_gc+0x214>)
    338e:	6813      	ldr	r3, [r2, #0]
    3390:	3301      	adds	r3, #1
    3392:	6013      	str	r3, [r2, #0]

    return 0;
}
    3394:	b011      	add	sp, #68	; 0x44
    3396:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    339a:	bf00      	nop
    339c:	20000b24 	.word	0x20000b24
    33a0:	20000aa4 	.word	0x20000aa4
    33a4:	20000b40 	.word	0x20000b40
    33a8:	00006320 	.word	0x00006320
    33ac:	20000ca4 	.word	0x20000ca4
    33b0:	20000b60 	.word	0x20000b60
    33b4:	20000cac 	.word	0x20000cac

000033b8 <nffs_gc_until>:
 *                                  freed.
 *                              nonzero on other failure.
 */
int
nffs_gc_until(uint32_t space, uint8_t *out_area_idx)
{
    33b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    33ba:	4607      	mov	r7, r0
    33bc:	460e      	mov	r6, r1
    int rc;
    int i;

    for (i = 0; i < nffs_num_areas; i++) {
    33be:	2500      	movs	r5, #0
    33c0:	4b0b      	ldr	r3, [pc, #44]	; (33f0 <nffs_gc_until+0x38>)
    33c2:	781b      	ldrb	r3, [r3, #0]
    33c4:	429d      	cmp	r5, r3
    33c6:	da0f      	bge.n	33e8 <nffs_gc_until+0x30>
        rc = nffs_gc(out_area_idx);
    33c8:	4630      	mov	r0, r6
    33ca:	f7ff fee9 	bl	31a0 <nffs_gc>
        if (rc != 0) {
    33ce:	4604      	mov	r4, r0
    33d0:	b960      	cbnz	r0, 33ec <nffs_gc_until+0x34>
            return rc;
        }

        if (nffs_area_free_space(nffs_areas + *out_area_idx) >= space) {
    33d2:	4b08      	ldr	r3, [pc, #32]	; (33f4 <nffs_gc_until+0x3c>)
    33d4:	7830      	ldrb	r0, [r6, #0]
    33d6:	681b      	ldr	r3, [r3, #0]
    33d8:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    33dc:	f7ff fbea 	bl	2bb4 <nffs_area_free_space>
    33e0:	42b8      	cmp	r0, r7
    33e2:	d203      	bcs.n	33ec <nffs_gc_until+0x34>
nffs_gc_until(uint32_t space, uint8_t *out_area_idx)
{
    int rc;
    int i;

    for (i = 0; i < nffs_num_areas; i++) {
    33e4:	3501      	adds	r5, #1
    33e6:	e7eb      	b.n	33c0 <nffs_gc_until+0x8>
        if (nffs_area_free_space(nffs_areas + *out_area_idx) >= space) {
            return 0;
        }
    }

    return FS_EFULL;
    33e8:	2008      	movs	r0, #8
    33ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (rc != 0) {
            return rc;
        }

        if (nffs_area_free_space(nffs_areas + *out_area_idx) >= space) {
            return 0;
    33ec:	4620      	mov	r0, r4
        }
    }

    return FS_EFULL;
}
    33ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    33f0:	20000b24 	.word	0x20000b24
    33f4:	20000b40 	.word	0x20000b40

000033f8 <Reset_Handler>:
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
    33f8:	4906      	ldr	r1, [pc, #24]	; (3414 <Reset_Handler+0x1c>)
    ldr    r2, =__data_start__
    33fa:	4a07      	ldr	r2, [pc, #28]	; (3418 <Reset_Handler+0x20>)
    ldr    r3, =__data_end__
    33fc:	4b07      	ldr	r3, [pc, #28]	; (341c <Reset_Handler+0x24>)

    subs    r3, r2
    33fe:	1a9b      	subs	r3, r3, r2
    ble     .LC0
    3400:	dd03      	ble.n	340a <Reset_Handler+0x12>

.LC1:
    subs    r3, 4
    3402:	3b04      	subs	r3, #4
    ldr    r0, [r1,r3]
    3404:	58c8      	ldr	r0, [r1, r3]
    str    r0, [r2,r3]
    3406:	50d0      	str	r0, [r2, r3]
    bgt    .LC1
    3408:	dcfb      	bgt.n	3402 <Reset_Handler+0xa>
.LC0:

    LDR     R0, =SystemInit
    340a:	4805      	ldr	r0, [pc, #20]	; (3420 <Reset_Handler+0x28>)
    BLX     R0
    340c:	4780      	blx	r0
    LDR     R0, =_start
    340e:	4805      	ldr	r0, [pc, #20]	; (3424 <Reset_Handler+0x2c>)
    BX      R0
    3410:	4700      	bx	r0
    3412:	0000      	.short	0x0000
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
    3414:	00006784 	.word	0x00006784
    ldr    r2, =__data_start__
    3418:	200000d8 	.word	0x200000d8
    ldr    r3, =__data_end__
    341c:	200005cc 	.word	0x200005cc
    ldr    r0, [r1,r3]
    str    r0, [r2,r3]
    bgt    .LC1
.LC0:

    LDR     R0, =SystemInit
    3420:	0000343d 	.word	0x0000343d
    BLX     R0
    LDR     R0, =_start
    3424:	000000d9 	.word	0x000000d9

00003428 <NMI_Handler>:
/* Dummy Exception Handlers (infinite loops which can be modified) */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    B       .
    3428:	e7fe      	b.n	3428 <NMI_Handler>

0000342a <HardFault_Handler>:


    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    B       .
    342a:	e7fe      	b.n	342a <HardFault_Handler>

0000342c <MemoryManagement_Handler>:


    .weak   MemoryManagement_Handler
    .type   MemoryManagement_Handler, %function
MemoryManagement_Handler:
    B       .
    342c:	e7fe      	b.n	342c <MemoryManagement_Handler>

0000342e <BusFault_Handler>:


    .weak   BusFault_Handler
    .type   BusFault_Handler, %function
BusFault_Handler:
    B       .
    342e:	e7fe      	b.n	342e <BusFault_Handler>

00003430 <UsageFault_Handler>:


    .weak   UsageFault_Handler
    .type   UsageFault_Handler, %function
UsageFault_Handler:
    B       .
    3430:	e7fe      	b.n	3430 <UsageFault_Handler>


    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    B       .
    3432:	e7fe      	b.n	3432 <UsageFault_Handler+0x2>


    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    B       .
    3434:	e7fe      	b.n	3434 <UsageFault_Handler+0x4>


    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    B       .
    3436:	e7fe      	b.n	3436 <UsageFault_Handler+0x6>

00003438 <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    B       .
    3438:	e7fe      	b.n	3438 <Default_Handler>
    343a:	bf00      	nop

0000343c <SystemInit>:
    NVIC_Relocate();
}

static bool ftpan_32(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
    343c:	4b27      	ldr	r3, [pc, #156]	; (34dc <SystemInit+0xa0>)
    343e:	781b      	ldrb	r3, [r3, #0]
    3440:	2b06      	cmp	r3, #6
    3442:	d10e      	bne.n	3462 <SystemInit+0x26>
    3444:	4b26      	ldr	r3, [pc, #152]	; (34e0 <SystemInit+0xa4>)
    3446:	681b      	ldr	r3, [r3, #0]
    3448:	0719      	lsls	r1, r3, #28
    344a:	d10a      	bne.n	3462 <SystemInit+0x26>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
    344c:	4b25      	ldr	r3, [pc, #148]	; (34e4 <SystemInit+0xa8>)
    344e:	681b      	ldr	r3, [r3, #0]
    3450:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3454:	2b30      	cmp	r3, #48	; 0x30
    3456:	d104      	bne.n	3462 <SystemInit+0x26>
    3458:	4b23      	ldr	r3, [pc, #140]	; (34e8 <SystemInit+0xac>)
    345a:	681b      	ldr	r3, [r3, #0]
    345c:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    3460:	d02a      	beq.n	34b8 <SystemInit+0x7c>
    return false;
}

static bool ftpan_37(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
    3462:	4b1e      	ldr	r3, [pc, #120]	; (34dc <SystemInit+0xa0>)
    3464:	781b      	ldrb	r3, [r3, #0]
    3466:	2b06      	cmp	r3, #6
    3468:	d10e      	bne.n	3488 <SystemInit+0x4c>
    346a:	4b1d      	ldr	r3, [pc, #116]	; (34e0 <SystemInit+0xa4>)
    346c:	681b      	ldr	r3, [r3, #0]
    346e:	071a      	lsls	r2, r3, #28
    3470:	d10a      	bne.n	3488 <SystemInit+0x4c>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
    3472:	4b1c      	ldr	r3, [pc, #112]	; (34e4 <SystemInit+0xa8>)
    3474:	681b      	ldr	r3, [r3, #0]
    3476:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    347a:	2b30      	cmp	r3, #48	; 0x30
    347c:	d104      	bne.n	3488 <SystemInit+0x4c>
    347e:	4b1a      	ldr	r3, [pc, #104]	; (34e8 <SystemInit+0xac>)
    3480:	681b      	ldr	r3, [r3, #0]
    3482:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    3486:	d01d      	beq.n	34c4 <SystemInit+0x88>
    return false;
}

static bool ftpan_36(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
    3488:	4b14      	ldr	r3, [pc, #80]	; (34dc <SystemInit+0xa0>)
    348a:	781b      	ldrb	r3, [r3, #0]
    348c:	2b06      	cmp	r3, #6
    348e:	d10e      	bne.n	34ae <SystemInit+0x72>
    3490:	4b13      	ldr	r3, [pc, #76]	; (34e0 <SystemInit+0xa4>)
    3492:	681b      	ldr	r3, [r3, #0]
    3494:	071b      	lsls	r3, r3, #28
    3496:	d10a      	bne.n	34ae <SystemInit+0x72>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
    3498:	4b12      	ldr	r3, [pc, #72]	; (34e4 <SystemInit+0xa8>)
    349a:	681b      	ldr	r3, [r3, #0]
    349c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    34a0:	2b30      	cmp	r3, #48	; 0x30
    34a2:	d104      	bne.n	34ae <SystemInit+0x72>
    34a4:	4b10      	ldr	r3, [pc, #64]	; (34e8 <SystemInit+0xac>)
    34a6:	681b      	ldr	r3, [r3, #0]
    34a8:	f013 03f0 	ands.w	r3, r3, #240	; 0xf0
    34ac:	d00e      	beq.n	34cc <SystemInit+0x90>
    uint32_t SystemCoreClock __attribute__((used)) = __SYSTEM_CLOCK_64M;
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    34ae:	4b0f      	ldr	r3, [pc, #60]	; (34ec <SystemInit+0xb0>)
    34b0:	4a0f      	ldr	r2, [pc, #60]	; (34f0 <SystemInit+0xb4>)
    34b2:	601a      	str	r2, [r3, #0]
        NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Parallel << CLOCK_TRACECONFIG_TRACEMUX_Pos;
    #endif

    SystemCoreClockUpdate();

    NVIC_Relocate();
    34b4:	f000 bdd4 	b.w	4060 <NVIC_Relocate>
void SystemInit(void)
{
    /* Workaround for FTPAN-32 "DIF: Debug session automatically enables TracePort pins" found at Product Anomaly document 
       for your device located at https://www.nordicsemi.com/ */
    if (ftpan_32()){        
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
    34b8:	4a0e      	ldr	r2, [pc, #56]	; (34f4 <SystemInit+0xb8>)
    34ba:	68d3      	ldr	r3, [r2, #12]
    34bc:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    34c0:	60d3      	str	r3, [r2, #12]
    34c2:	e7ce      	b.n	3462 <SystemInit+0x26>
    }
    
    /* Workaround for FTPAN-37 "AMLI: EasyDMA is slow with Radio, ECB, AAR and CCM." found at Product Anomaly document 
       for your device located at https://www.nordicsemi.com/  */
    if (ftpan_37()){        
        *(volatile uint32_t *)0x400005A0 = 0x3;
    34c4:	4b0c      	ldr	r3, [pc, #48]	; (34f8 <SystemInit+0xbc>)
    34c6:	2203      	movs	r2, #3
    34c8:	601a      	str	r2, [r3, #0]
    34ca:	e7dd      	b.n	3488 <SystemInit+0x4c>
    }
    
    /* Workaround for FTPAN-36 "CLOCK: Some registers are not reset when expected." found at Product Anomaly document 
       for your device located at https://www.nordicsemi.com/  */
    if (ftpan_36()){        
        NRF_CLOCK->EVENTS_DONE = 0;
    34cc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    34d0:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
    34d4:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
    34d8:	e7e9      	b.n	34ae <SystemInit+0x72>
    34da:	bf00      	nop
    34dc:	f0000fe0 	.word	0xf0000fe0
    34e0:	f0000fe4 	.word	0xf0000fe4
    34e4:	f0000fe8 	.word	0xf0000fe8
    34e8:	f0000fec 	.word	0xf0000fec
    34ec:	200000f4 	.word	0x200000f4
    34f0:	03d09000 	.word	0x03d09000
    34f4:	e000edf0 	.word	0xe000edf0
    34f8:	400005a0 	.word	0x400005a0

000034fc <flash_area_init>:
static int flash_map_entries;

void
flash_area_init(const struct flash_area *map, int map_entries)
{
    flash_map = map;
    34fc:	4b02      	ldr	r3, [pc, #8]	; (3508 <flash_area_init+0xc>)
    34fe:	6018      	str	r0, [r3, #0]
    flash_map_entries = map_entries;
    3500:	4b02      	ldr	r3, [pc, #8]	; (350c <flash_area_init+0x10>)
    3502:	6019      	str	r1, [r3, #0]
    3504:	4770      	bx	lr
    3506:	bf00      	nop
    3508:	20000600 	.word	0x20000600
    350c:	20000604 	.word	0x20000604

00003510 <flash_area_to_sectors>:
    int i;
    const struct hal_flash *hf;
    const struct flash_area *fa;
    uint32_t start, size;

    if (!flash_map || idx >= flash_map_entries) {
    3510:	4b1c      	ldr	r3, [pc, #112]	; (3584 <flash_area_to_sectors+0x74>)
    /* nothing to do for now */
}

int
flash_area_to_sectors(int idx, int *cnt, struct flash_area *ret)
{
    3512:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    3516:	4615      	mov	r5, r2
    int i;
    const struct hal_flash *hf;
    const struct flash_area *fa;
    uint32_t start, size;

    if (!flash_map || idx >= flash_map_entries) {
    3518:	681a      	ldr	r2, [r3, #0]
    /* nothing to do for now */
}

int
flash_area_to_sectors(int idx, int *cnt, struct flash_area *ret)
{
    351a:	460f      	mov	r7, r1
    int i;
    const struct hal_flash *hf;
    const struct flash_area *fa;
    uint32_t start, size;

    if (!flash_map || idx >= flash_map_entries) {
    351c:	b36a      	cbz	r2, 357a <flash_area_to_sectors+0x6a>
    351e:	4b1a      	ldr	r3, [pc, #104]	; (3588 <flash_area_to_sectors+0x78>)
    3520:	681b      	ldr	r3, [r3, #0]
    3522:	4298      	cmp	r0, r3
    3524:	da29      	bge.n	357a <flash_area_to_sectors+0x6a>
        return -1;
    }
    *cnt = 0;
    fa = &flash_map[idx];
    3526:	230c      	movs	r3, #12
    3528:	4358      	muls	r0, r3
    uint32_t start, size;

    if (!flash_map || idx >= flash_map_entries) {
        return -1;
    }
    *cnt = 0;
    352a:	2400      	movs	r4, #0
    352c:	600c      	str	r4, [r1, #0]
    fa = &flash_map[idx];
    352e:	1816      	adds	r6, r2, r0

    hf = bsp_flash_dev(fa->fa_flash_id);
    3530:	5c10      	ldrb	r0, [r2, r0]
    3532:	f002 fb05 	bl	5b40 <bsp_flash_dev>
    3536:	4680      	mov	r8, r0
    for (i = 0; i < hf->hf_sector_cnt; i++) {
    3538:	f8d8 300c 	ldr.w	r3, [r8, #12]
    353c:	429c      	cmp	r4, r3
    353e:	da1a      	bge.n	3576 <flash_area_to_sectors+0x66>
        hf->hf_itf->hff_sector_info(i, &start, &size);
    3540:	f8d8 3000 	ldr.w	r3, [r8]
    3544:	4669      	mov	r1, sp
    3546:	68db      	ldr	r3, [r3, #12]
    3548:	4620      	mov	r0, r4
    354a:	aa01      	add	r2, sp, #4
    354c:	4798      	blx	r3
        if (start >= fa->fa_off && start < fa->fa_off + fa->fa_size) {
    354e:	9b00      	ldr	r3, [sp, #0]
    3550:	6871      	ldr	r1, [r6, #4]
    3552:	428b      	cmp	r3, r1
    3554:	d30d      	bcc.n	3572 <flash_area_to_sectors+0x62>
    3556:	68b2      	ldr	r2, [r6, #8]
    3558:	440a      	add	r2, r1
    355a:	4293      	cmp	r3, r2
    355c:	d209      	bcs.n	3572 <flash_area_to_sectors+0x62>
            if (ret) {
    355e:	b12d      	cbz	r5, 356c <flash_area_to_sectors+0x5c>
                ret->fa_flash_id = fa->fa_flash_id;
    3560:	7832      	ldrb	r2, [r6, #0]
                ret->fa_off = start;
    3562:	606b      	str	r3, [r5, #4]
                ret->fa_size = size;
    3564:	9b01      	ldr	r3, [sp, #4]
    hf = bsp_flash_dev(fa->fa_flash_id);
    for (i = 0; i < hf->hf_sector_cnt; i++) {
        hf->hf_itf->hff_sector_info(i, &start, &size);
        if (start >= fa->fa_off && start < fa->fa_off + fa->fa_size) {
            if (ret) {
                ret->fa_flash_id = fa->fa_flash_id;
    3566:	702a      	strb	r2, [r5, #0]
                ret->fa_off = start;
                ret->fa_size = size;
    3568:	60ab      	str	r3, [r5, #8]
                ret++;
    356a:	350c      	adds	r5, #12
            }
            *cnt = *cnt + 1;
    356c:	683b      	ldr	r3, [r7, #0]
    356e:	3301      	adds	r3, #1
    3570:	603b      	str	r3, [r7, #0]
    }
    *cnt = 0;
    fa = &flash_map[idx];

    hf = bsp_flash_dev(fa->fa_flash_id);
    for (i = 0; i < hf->hf_sector_cnt; i++) {
    3572:	3401      	adds	r4, #1
    3574:	e7e0      	b.n	3538 <flash_area_to_sectors+0x28>
                ret++;
            }
            *cnt = *cnt + 1;
        }
    }
    return 0;
    3576:	2000      	movs	r0, #0
    3578:	e001      	b.n	357e <flash_area_to_sectors+0x6e>
    const struct hal_flash *hf;
    const struct flash_area *fa;
    uint32_t start, size;

    if (!flash_map || idx >= flash_map_entries) {
        return -1;
    357a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
            }
            *cnt = *cnt + 1;
        }
    }
    return 0;
}
    357e:	b002      	add	sp, #8
    3580:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3584:	20000600 	.word	0x20000600
    3588:	20000604 	.word	0x20000604

0000358c <flash_area_to_nffs_desc>:
 * If sector count within region exceeds that, collect multiple sectors
 * to a region.
 */
int
flash_area_to_nffs_desc(int idx, int *cnt, struct nffs_area_desc *nad)
{
    358c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int max_cnt, move_on;
    int first_idx, last_idx;
    uint32_t start, size;
    uint32_t min_size;

    if (!flash_map || idx >= flash_map_entries) {
    3590:	4b42      	ldr	r3, [pc, #264]	; (369c <flash_area_to_nffs_desc+0x110>)
 * If sector count within region exceeds that, collect multiple sectors
 * to a region.
 */
int
flash_area_to_nffs_desc(int idx, int *cnt, struct nffs_area_desc *nad)
{
    3592:	4617      	mov	r7, r2
    int max_cnt, move_on;
    int first_idx, last_idx;
    uint32_t start, size;
    uint32_t min_size;

    if (!flash_map || idx >= flash_map_entries) {
    3594:	681a      	ldr	r2, [r3, #0]
 * If sector count within region exceeds that, collect multiple sectors
 * to a region.
 */
int
flash_area_to_nffs_desc(int idx, int *cnt, struct nffs_area_desc *nad)
{
    3596:	b085      	sub	sp, #20
    3598:	460c      	mov	r4, r1
    int max_cnt, move_on;
    int first_idx, last_idx;
    uint32_t start, size;
    uint32_t min_size;

    if (!flash_map || idx >= flash_map_entries) {
    359a:	2a00      	cmp	r2, #0
    359c:	d079      	beq.n	3692 <flash_area_to_nffs_desc+0x106>
    359e:	4b40      	ldr	r3, [pc, #256]	; (36a0 <flash_area_to_nffs_desc+0x114>)
    35a0:	681b      	ldr	r3, [r3, #0]
    35a2:	4298      	cmp	r0, r3
    35a4:	da75      	bge.n	3692 <flash_area_to_nffs_desc+0x106>
    }
    first_idx = last_idx = -1;
    max_cnt = *cnt;
    *cnt = 0;

    fa = &flash_map[idx];
    35a6:	230c      	movs	r3, #12
    35a8:	4358      	muls	r0, r3
    if (!flash_map || idx >= flash_map_entries) {
        return -1;
    }
    first_idx = last_idx = -1;
    max_cnt = *cnt;
    *cnt = 0;
    35aa:	2500      	movs	r5, #0

    if (!flash_map || idx >= flash_map_entries) {
        return -1;
    }
    first_idx = last_idx = -1;
    max_cnt = *cnt;
    35ac:	f8d1 b000 	ldr.w	fp, [r1]
    *cnt = 0;
    35b0:	600d      	str	r5, [r1, #0]

    fa = &flash_map[idx];
    35b2:	eb02 0800 	add.w	r8, r2, r0

    hf = bsp_flash_dev(fa->fa_flash_id);
    35b6:	5c10      	ldrb	r0, [r2, r0]
    35b8:	f002 fac2 	bl	5b40 <bsp_flash_dev>
    uint32_t min_size;

    if (!flash_map || idx >= flash_map_entries) {
        return -1;
    }
    first_idx = last_idx = -1;
    35bc:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
    max_cnt = *cnt;
    *cnt = 0;

    fa = &flash_map[idx];

    hf = bsp_flash_dev(fa->fa_flash_id);
    35c0:	4682      	mov	sl, r0
    uint32_t min_size;

    if (!flash_map || idx >= flash_map_entries) {
        return -1;
    }
    first_idx = last_idx = -1;
    35c2:	464e      	mov	r6, r9
    *cnt = 0;

    fa = &flash_map[idx];

    hf = bsp_flash_dev(fa->fa_flash_id);
    for (i = 0; i < hf->hf_sector_cnt; i++) {
    35c4:	f8da 300c 	ldr.w	r3, [sl, #12]
    35c8:	429d      	cmp	r5, r3
    35ca:	da1a      	bge.n	3602 <flash_area_to_nffs_desc+0x76>
        hf->hf_itf->hff_sector_info(i, &start, &size);
    35cc:	f8da 3000 	ldr.w	r3, [sl]
    35d0:	a902      	add	r1, sp, #8
    35d2:	aa03      	add	r2, sp, #12
    35d4:	68db      	ldr	r3, [r3, #12]
    35d6:	4628      	mov	r0, r5
    35d8:	4798      	blx	r3
        if (start >= fa->fa_off && start < fa->fa_off + fa->fa_size) {
    35da:	9a02      	ldr	r2, [sp, #8]
    35dc:	f8d8 1004 	ldr.w	r1, [r8, #4]
    35e0:	428a      	cmp	r2, r1
    35e2:	d30c      	bcc.n	35fe <flash_area_to_nffs_desc+0x72>
    35e4:	f8d8 3008 	ldr.w	r3, [r8, #8]
    35e8:	440b      	add	r3, r1
    35ea:	429a      	cmp	r2, r3
    35ec:	d207      	bcs.n	35fe <flash_area_to_nffs_desc+0x72>
            if (first_idx == -1) {
                first_idx = i;
            }
            last_idx = i;
            *cnt = *cnt + 1;
    35ee:	6823      	ldr	r3, [r4, #0]
    35f0:	3301      	adds	r3, #1

    hf = bsp_flash_dev(fa->fa_flash_id);
    for (i = 0; i < hf->hf_sector_cnt; i++) {
        hf->hf_itf->hff_sector_info(i, &start, &size);
        if (start >= fa->fa_off && start < fa->fa_off + fa->fa_size) {
            if (first_idx == -1) {
    35f2:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
    35f6:	bf08      	it	eq
    35f8:	462e      	moveq	r6, r5
                first_idx = i;
            }
            last_idx = i;
            *cnt = *cnt + 1;
    35fa:	6023      	str	r3, [r4, #0]
    35fc:	46a9      	mov	r9, r5
    *cnt = 0;

    fa = &flash_map[idx];

    hf = bsp_flash_dev(fa->fa_flash_id);
    for (i = 0; i < hf->hf_sector_cnt; i++) {
    35fe:	3501      	adds	r5, #1
    3600:	e7e0      	b.n	35c4 <flash_area_to_nffs_desc+0x38>
            }
            last_idx = i;
            *cnt = *cnt + 1;
        }
    }
    if (*cnt > max_cnt) {
    3602:	6823      	ldr	r3, [r4, #0]
    3604:	455b      	cmp	r3, fp
    3606:	f04f 0300 	mov.w	r3, #0
        min_size = fa->fa_size / max_cnt;
    360a:	bfc8      	it	gt
    360c:	f8d8 2008 	ldrgt.w	r2, [r8, #8]
    } else {
        min_size = 0;
    }
    *cnt = 0;
    3610:	6023      	str	r3, [r4, #0]
        }
    }
    if (*cnt > max_cnt) {
        min_size = fa->fa_size / max_cnt;
    } else {
        min_size = 0;
    3612:	bfd8      	it	le
    3614:	469b      	movle	fp, r3
    }
    *cnt = 0;

    move_on = 1;
    3616:	f04f 0c01 	mov.w	ip, #1
    for (i = first_idx, j = 0; i < last_idx + 1; i++) {
    361a:	f04f 0500 	mov.w	r5, #0
            last_idx = i;
            *cnt = *cnt + 1;
        }
    }
    if (*cnt > max_cnt) {
        min_size = fa->fa_size / max_cnt;
    361e:	bfc8      	it	gt
    3620:	fbb2 fbfb 	udivgt	fp, r2, fp
        min_size = 0;
    }
    *cnt = 0;

    move_on = 1;
    for (i = first_idx, j = 0; i < last_idx + 1; i++) {
    3624:	45b1      	cmp	r9, r6
    3626:	db2d      	blt.n	3684 <flash_area_to_nffs_desc+0xf8>
        hf->hf_itf->hff_sector_info(i, &start, &size);
    3628:	f8da 3000 	ldr.w	r3, [sl]
    362c:	f8cd c004 	str.w	ip, [sp, #4]
    3630:	68db      	ldr	r3, [r3, #12]
    3632:	aa03      	add	r2, sp, #12
    3634:	4630      	mov	r0, r6
    3636:	a902      	add	r1, sp, #8
    3638:	4798      	blx	r3
        if (move_on) {
    363a:	f8dd c004 	ldr.w	ip, [sp, #4]
    363e:	9a03      	ldr	r2, [sp, #12]
    3640:	230c      	movs	r3, #12
    3642:	f1bc 0f00 	cmp.w	ip, #0
    3646:	d00b      	beq.n	3660 <flash_area_to_nffs_desc+0xd4>
            nad[j].nad_flash_id = fa->fa_flash_id;
    3648:	436b      	muls	r3, r5
    364a:	18f8      	adds	r0, r7, r3
    364c:	f898 1000 	ldrb.w	r1, [r8]
    3650:	7201      	strb	r1, [r0, #8]
            nad[j].nad_offset = start;
    3652:	9902      	ldr	r1, [sp, #8]
    3654:	50f9      	str	r1, [r7, r3]
            nad[j].nad_length = size;
            *cnt = *cnt + 1;
    3656:	6823      	ldr	r3, [r4, #0]
    for (i = first_idx, j = 0; i < last_idx + 1; i++) {
        hf->hf_itf->hff_sector_info(i, &start, &size);
        if (move_on) {
            nad[j].nad_flash_id = fa->fa_flash_id;
            nad[j].nad_offset = start;
            nad[j].nad_length = size;
    3658:	6042      	str	r2, [r0, #4]
            *cnt = *cnt + 1;
    365a:	3301      	adds	r3, #1
    365c:	6023      	str	r3, [r4, #0]
    365e:	e004      	b.n	366a <flash_area_to_nffs_desc+0xde>
            move_on = 0;
        } else {
            nad[j].nad_length += size;
    3660:	fb03 7305 	mla	r3, r3, r5, r7
    3664:	6859      	ldr	r1, [r3, #4]
    3666:	440a      	add	r2, r1
    3668:	605a      	str	r2, [r3, #4]
        }
        if (nad[j].nad_length >= min_size) {
    366a:	230c      	movs	r3, #12
    366c:	fb03 7305 	mla	r3, r3, r5, r7
        min_size = 0;
    }
    *cnt = 0;

    move_on = 1;
    for (i = first_idx, j = 0; i < last_idx + 1; i++) {
    3670:	3601      	adds	r6, #1
            *cnt = *cnt + 1;
            move_on = 0;
        } else {
            nad[j].nad_length += size;
        }
        if (nad[j].nad_length >= min_size) {
    3672:	685b      	ldr	r3, [r3, #4]
    3674:	455b      	cmp	r3, fp
            j++;
    3676:	bf26      	itte	cs
    3678:	3501      	addcs	r5, #1
            move_on = 1;
    367a:	f04f 0c01 	movcs.w	ip, #1
    367e:	f04f 0c00 	movcc.w	ip, #0
    3682:	e7cf      	b.n	3624 <flash_area_to_nffs_desc+0x98>
        }
    }
    nad[*cnt].nad_length = 0;
    3684:	6823      	ldr	r3, [r4, #0]
    3686:	220c      	movs	r2, #12
    3688:	fb02 7703 	mla	r7, r2, r3, r7
    368c:	2000      	movs	r0, #0
    368e:	6078      	str	r0, [r7, #4]
    return 0;
    3690:	e001      	b.n	3696 <flash_area_to_nffs_desc+0x10a>
    int first_idx, last_idx;
    uint32_t start, size;
    uint32_t min_size;

    if (!flash_map || idx >= flash_map_entries) {
        return -1;
    3692:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
            move_on = 1;
        }
    }
    nad[*cnt].nad_length = 0;
    return 0;
}
    3696:	b005      	add	sp, #20
    3698:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    369c:	20000600 	.word	0x20000600
    36a0:	20000604 	.word	0x20000604

000036a4 <hal_flash_check_addr>:
}

static int
hal_flash_check_addr(const struct hal_flash *hf, uint32_t addr)
{
    if (addr < hf->hf_base_addr || addr > hf->hf_base_addr + hf->hf_size) {
    36a4:	6842      	ldr	r2, [r0, #4]
    36a6:	4291      	cmp	r1, r2
    36a8:	d307      	bcc.n	36ba <hal_flash_check_addr+0x16>
    36aa:	6883      	ldr	r3, [r0, #8]
    36ac:	18d0      	adds	r0, r2, r3
    36ae:	4281      	cmp	r1, r0
    36b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    36b4:	bf98      	it	ls
    36b6:	2000      	movls	r0, #0
    36b8:	4770      	bx	lr
        return -1;
    36ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }
    return 0;
}
    36be:	4770      	bx	lr

000036c0 <hal_flash_init>:
#include "hal/hal_flash.h"
#include "hal/hal_flash_int.h"

int
hal_flash_init(void)
{
    36c0:	b538      	push	{r3, r4, r5, lr}
    36c2:	2400      	movs	r4, #0
    const struct hal_flash *hf;
    uint8_t i;
    int rc = 0;
    36c4:	4625      	mov	r5, r4

    for (i = 0; ; i++) {
        hf = bsp_flash_dev(i);
    36c6:	b2e0      	uxtb	r0, r4
    36c8:	f002 fa3a 	bl	5b40 <bsp_flash_dev>
        if (!hf) {
    36cc:	b140      	cbz	r0, 36e0 <hal_flash_init+0x20>
            break;
        }
        if (hf->hf_itf->hff_init()) {
    36ce:	6803      	ldr	r3, [r0, #0]
    36d0:	691b      	ldr	r3, [r3, #16]
    36d2:	4798      	blx	r3
            rc = -1;
    36d4:	2800      	cmp	r0, #0
    36d6:	bf18      	it	ne
    36d8:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
    36dc:	3401      	adds	r4, #1
        }
    }
    36de:	e7f2      	b.n	36c6 <hal_flash_init+0x6>
    return rc;
}
    36e0:	4628      	mov	r0, r5
    36e2:	bd38      	pop	{r3, r4, r5, pc}

000036e4 <hal_flash_read>:
    return 0;
}

int
hal_flash_read(uint8_t id, uint32_t address, void *dst, uint32_t num_bytes)
{
    36e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    36e8:	460c      	mov	r4, r1
    36ea:	4617      	mov	r7, r2
    36ec:	461d      	mov	r5, r3
    const struct hal_flash *hf;

    hf = bsp_flash_dev(id);
    36ee:	f002 fa27 	bl	5b40 <bsp_flash_dev>
    if (!hf) {
    36f2:	4606      	mov	r6, r0
    36f4:	b180      	cbz	r0, 3718 <hal_flash_read+0x34>
        return -1;
    }
    if (hal_flash_check_addr(hf, address) ||
    36f6:	4621      	mov	r1, r4
    36f8:	f7ff ffd4 	bl	36a4 <hal_flash_check_addr>
    36fc:	b960      	cbnz	r0, 3718 <hal_flash_read+0x34>
      hal_flash_check_addr(hf, address + num_bytes)) {
    36fe:	4630      	mov	r0, r6
    3700:	1961      	adds	r1, r4, r5
    3702:	f7ff ffcf 	bl	36a4 <hal_flash_check_addr>

    hf = bsp_flash_dev(id);
    if (!hf) {
        return -1;
    }
    if (hal_flash_check_addr(hf, address) ||
    3706:	b938      	cbnz	r0, 3718 <hal_flash_read+0x34>
      hal_flash_check_addr(hf, address + num_bytes)) {
        return -1;
    }
    return hf->hf_itf->hff_read(address, dst, num_bytes);
    3708:	6833      	ldr	r3, [r6, #0]
    370a:	4620      	mov	r0, r4
    370c:	4639      	mov	r1, r7
    370e:	462a      	mov	r2, r5
    3710:	681b      	ldr	r3, [r3, #0]
}
    3712:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }
    if (hal_flash_check_addr(hf, address) ||
      hal_flash_check_addr(hf, address + num_bytes)) {
        return -1;
    }
    return hf->hf_itf->hff_read(address, dst, num_bytes);
    3716:	4718      	bx	r3
}
    3718:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    371c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003720 <hal_flash_write>:

int
hal_flash_write(uint8_t id, uint32_t address, const void *src,
  uint32_t num_bytes)
{
    3720:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3724:	460c      	mov	r4, r1
    3726:	4617      	mov	r7, r2
    3728:	461d      	mov	r5, r3
    const struct hal_flash *hf;

    hf = bsp_flash_dev(id);
    372a:	f002 fa09 	bl	5b40 <bsp_flash_dev>
    if (!hf) {
    372e:	4606      	mov	r6, r0
    3730:	b180      	cbz	r0, 3754 <hal_flash_write+0x34>
        return -1;
    }
    if (hal_flash_check_addr(hf, address) ||
    3732:	4621      	mov	r1, r4
    3734:	f7ff ffb6 	bl	36a4 <hal_flash_check_addr>
    3738:	b960      	cbnz	r0, 3754 <hal_flash_write+0x34>
      hal_flash_check_addr(hf, address + num_bytes)) {
    373a:	4630      	mov	r0, r6
    373c:	1961      	adds	r1, r4, r5
    373e:	f7ff ffb1 	bl	36a4 <hal_flash_check_addr>

    hf = bsp_flash_dev(id);
    if (!hf) {
        return -1;
    }
    if (hal_flash_check_addr(hf, address) ||
    3742:	b938      	cbnz	r0, 3754 <hal_flash_write+0x34>
      hal_flash_check_addr(hf, address + num_bytes)) {
        return -1;
    }
    return hf->hf_itf->hff_write(address, src, num_bytes);
    3744:	6833      	ldr	r3, [r6, #0]
    3746:	4620      	mov	r0, r4
    3748:	4639      	mov	r1, r7
    374a:	462a      	mov	r2, r5
    374c:	685b      	ldr	r3, [r3, #4]
}
    374e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }
    if (hal_flash_check_addr(hf, address) ||
      hal_flash_check_addr(hf, address + num_bytes)) {
        return -1;
    }
    return hf->hf_itf->hff_write(address, src, num_bytes);
    3752:	4718      	bx	r3
}
    3754:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    3758:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000375c <hal_flash_erase>:
    return hf->hf_itf->hff_erase_sector(sector_address);
}

int
hal_flash_erase(uint8_t id, uint32_t address, uint32_t num_bytes)
{
    375c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    3760:	4688      	mov	r8, r1
    3762:	4614      	mov	r4, r2
    uint32_t end;
    uint32_t end_area;
    int i;
    int rc;

    hf = bsp_flash_dev(id);
    3764:	f002 f9ec 	bl	5b40 <bsp_flash_dev>
    if (!hf) {
    3768:	4607      	mov	r7, r0
    376a:	b910      	cbnz	r0, 3772 <hal_flash_erase+0x16>
        return -1;
    376c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    3770:	e02d      	b.n	37ce <hal_flash_erase+0x72>
    }
    if (hal_flash_check_addr(hf, address) ||
    3772:	4641      	mov	r1, r8
    3774:	f7ff ff96 	bl	36a4 <hal_flash_check_addr>
    3778:	2800      	cmp	r0, #0
    377a:	d1f7      	bne.n	376c <hal_flash_erase+0x10>
      hal_flash_check_addr(hf, address + num_bytes)) {
    377c:	4444      	add	r4, r8
    377e:	4638      	mov	r0, r7
    3780:	4621      	mov	r1, r4
    3782:	f7ff ff8f 	bl	36a4 <hal_flash_check_addr>

    hf = bsp_flash_dev(id);
    if (!hf) {
        return -1;
    }
    if (hal_flash_check_addr(hf, address) ||
    3786:	4605      	mov	r5, r0
    3788:	2800      	cmp	r0, #0
    378a:	d1ef      	bne.n	376c <hal_flash_erase+0x10>
      hal_flash_check_addr(hf, address + num_bytes)) {
        return -1;
    }

    end = address + num_bytes;
    if (end <= address) {
    378c:	4544      	cmp	r4, r8
    378e:	d9ed      	bls.n	376c <hal_flash_erase+0x10>
    3790:	4606      	mov	r6, r0
         * Check for wrap-around.
         */
        return -1;
    }

    for (i = 0; i < hf->hf_sector_cnt; i++) {
    3792:	68fb      	ldr	r3, [r7, #12]
    3794:	429e      	cmp	r6, r3
    3796:	da1a      	bge.n	37ce <hal_flash_erase+0x72>
        rc = hf->hf_itf->hff_sector_info(i, &start, &size);
    3798:	683b      	ldr	r3, [r7, #0]
    379a:	4630      	mov	r0, r6
    379c:	68db      	ldr	r3, [r3, #12]
    379e:	4669      	mov	r1, sp
    37a0:	aa01      	add	r2, sp, #4
    37a2:	4798      	blx	r3
        assert(rc == 0);
    37a4:	b128      	cbz	r0, 37b2 <hal_flash_erase+0x56>
    37a6:	2200      	movs	r2, #0
    37a8:	480b      	ldr	r0, [pc, #44]	; (37d8 <hal_flash_erase+0x7c>)
    37aa:	219c      	movs	r1, #156	; 0x9c
    37ac:	4613      	mov	r3, r2
    37ae:	f001 fa4d 	bl	4c4c <__assert_func>
        end_area = start + size;
    37b2:	e89d 0009 	ldmia.w	sp, {r0, r3}
    37b6:	4403      	add	r3, r0
        if (address < end_area && end > start) {
    37b8:	4598      	cmp	r8, r3
    37ba:	d206      	bcs.n	37ca <hal_flash_erase+0x6e>
    37bc:	4284      	cmp	r4, r0
    37be:	d904      	bls.n	37ca <hal_flash_erase+0x6e>
            /*
             * If some region of eraseable area falls inside sector,
             * erase the sector.
             */
            if (hf->hf_itf->hff_erase_sector(start)) {
    37c0:	683b      	ldr	r3, [r7, #0]
    37c2:	689b      	ldr	r3, [r3, #8]
    37c4:	4798      	blx	r3
    37c6:	2800      	cmp	r0, #0
    37c8:	d1d0      	bne.n	376c <hal_flash_erase+0x10>
         * Check for wrap-around.
         */
        return -1;
    }

    for (i = 0; i < hf->hf_sector_cnt; i++) {
    37ca:	3601      	adds	r6, #1
    37cc:	e7e1      	b.n	3792 <hal_flash_erase+0x36>
                return -1;
            }
        }
    }
    return 0;
}
    37ce:	4628      	mov	r0, r5
    37d0:	b002      	add	sp, #8
    37d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    37d6:	bf00      	nop
    37d8:	0000632a 	.word	0x0000632a

000037dc <system_start>:

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
    37dc:	6803      	ldr	r3, [r0, #0]
    37de:	f383 8808 	msr	MSP, r3
    base0entry = *(uint32_t *)(img_start + 4);
    jump_addr = base0entry;
    fn = (jump_fn *)jump_addr;

    /* Jump to image. */
    fn();
    37e2:	6843      	ldr	r3, [r0, #4]
    37e4:	4718      	bx	r3

000037e6 <exit>:
}

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
__extern_inline void exit(int err)
{
    37e6:	b508      	push	{r3, lr}
	__extern void _exit(int s);

	_exit(err);
    37e8:	f002 f9b5 	bl	5b56 <_exit>

000037ec <malloc_lock_nop>:
	},
	&__malloc_head,
	&__malloc_head
};

static bool malloc_lock_nop() {return true;}
    37ec:	2001      	movs	r0, #1
    37ee:	4770      	bx	lr

000037f0 <malloc_unlock_nop>:
static void malloc_unlock_nop() {}
    37f0:	4770      	bx	lr
	...

000037f4 <__free_block>:

static struct free_arena_header *__free_block(struct free_arena_header *ah)
{
	struct free_arena_header *pah, *nah;

	pah = ah->a.prev;
    37f4:	68c3      	ldr	r3, [r0, #12]
	nah = ah->a.next;
    37f6:	6882      	ldr	r2, [r0, #8]
	if (pah->a.type == ARENA_TYPE_FREE &&
    37f8:	6819      	ldr	r1, [r3, #0]
    37fa:	2901      	cmp	r1, #1

	return (void *)(&fp->a + 1);
}

static struct free_arena_header *__free_block(struct free_arena_header *ah)
{
    37fc:	b510      	push	{r4, lr}
	struct free_arena_header *pah, *nah;

	pah = ah->a.prev;
	nah = ah->a.next;
	if (pah->a.type == ARENA_TYPE_FREE &&
    37fe:	d109      	bne.n	3814 <__free_block+0x20>
	    (char *)pah + pah->a.size == (char *)ah) {
    3800:	6859      	ldr	r1, [r3, #4]
    3802:	185c      	adds	r4, r3, r1
{
	struct free_arena_header *pah, *nah;

	pah = ah->a.prev;
	nah = ah->a.next;
	if (pah->a.type == ARENA_TYPE_FREE &&
    3804:	4284      	cmp	r4, r0
    3806:	d105      	bne.n	3814 <__free_block+0x20>
	    (char *)pah + pah->a.size == (char *)ah) {
		/* Coalesce into the previous block */
		pah->a.size += ah->a.size;
    3808:	6860      	ldr	r0, [r4, #4]
		pah->a.next = nah;
    380a:	609a      	str	r2, [r3, #8]
	pah = ah->a.prev;
	nah = ah->a.next;
	if (pah->a.type == ARENA_TYPE_FREE &&
	    (char *)pah + pah->a.size == (char *)ah) {
		/* Coalesce into the previous block */
		pah->a.size += ah->a.size;
    380c:	4401      	add	r1, r0
    380e:	6059      	str	r1, [r3, #4]
		pah->a.next = nah;
		nah->a.prev = pah;
    3810:	60d3      	str	r3, [r2, #12]
		mark_block_dead(ah);

		ah = pah;
		pah = ah->a.prev;
    3812:	e009      	b.n	3828 <__free_block+0x34>
	} else {
		/* Need to add this block to the free chain */
		ah->a.type = ARENA_TYPE_FREE;
    3814:	2301      	movs	r3, #1
    3816:	6003      	str	r3, [r0, #0]

		ah->next_free = __malloc_head.next_free;
    3818:	4b0d      	ldr	r3, [pc, #52]	; (3850 <__free_block+0x5c>)
		ah->prev_free = &__malloc_head;
    381a:	6143      	str	r3, [r0, #20]
		pah = ah->a.prev;
	} else {
		/* Need to add this block to the free chain */
		ah->a.type = ARENA_TYPE_FREE;

		ah->next_free = __malloc_head.next_free;
    381c:	6919      	ldr	r1, [r3, #16]
    381e:	6101      	str	r1, [r0, #16]
		ah->prev_free = &__malloc_head;
		__malloc_head.next_free = ah;
    3820:	6118      	str	r0, [r3, #16]
		ah->next_free->prev_free = ah;
    3822:	6903      	ldr	r3, [r0, #16]
    3824:	6158      	str	r0, [r3, #20]
    3826:	4603      	mov	r3, r0
	}

	/* In either of the previous cases, we might be able to merge
	   with the subsequent block... */
	if (nah->a.type == ARENA_TYPE_FREE &&
    3828:	6811      	ldr	r1, [r2, #0]
    382a:	2901      	cmp	r1, #1
    382c:	d10e      	bne.n	384c <__free_block+0x58>
	    (char *)ah + ah->a.size == (char *)nah) {
    382e:	6859      	ldr	r1, [r3, #4]
    3830:	1858      	adds	r0, r3, r1
		ah->next_free->prev_free = ah;
	}

	/* In either of the previous cases, we might be able to merge
	   with the subsequent block... */
	if (nah->a.type == ARENA_TYPE_FREE &&
    3832:	4290      	cmp	r0, r2
    3834:	d10a      	bne.n	384c <__free_block+0x58>
	    (char *)ah + ah->a.size == (char *)nah) {
		ah->a.size += nah->a.size;
    3836:	6850      	ldr	r0, [r2, #4]
    3838:	4401      	add	r1, r0
    383a:	6059      	str	r1, [r3, #4]

static inline void remove_from_free_chain(struct free_arena_header *ah)
{
	struct free_arena_header *ap, *an;

	ap = ah->prev_free;
    383c:	6950      	ldr	r0, [r2, #20]
	an = ah->next_free;
    383e:	6911      	ldr	r1, [r2, #16]
	ap->next_free = an;
    3840:	6101      	str	r1, [r0, #16]
	an->prev_free = ap;
    3842:	6148      	str	r0, [r1, #20]
{
	struct free_arena_header *ap, *an;

	mark_block_dead(ah);

	ap = ah->a.prev;
    3844:	68d1      	ldr	r1, [r2, #12]
	an = ah->a.next;
    3846:	6892      	ldr	r2, [r2, #8]
	ap->a.next = an;
    3848:	608a      	str	r2, [r1, #8]
	an->a.prev = ap;
    384a:	60d1      	str	r1, [r2, #12]
		remove_from_chains(nah);
	}

	/* Return the block that contains the called block */
	return ah;
}
    384c:	4618      	mov	r0, r3
    384e:	bd10      	pop	{r4, pc}
    3850:	200000f8 	.word	0x200000f8

00003854 <add_malloc_block>:
void add_malloc_block(void *buf, size_t size)
{
	struct free_arena_header *fp = buf;
	struct free_arena_header *pah;

	if (size < sizeof(struct free_arena_header))
    3854:	2917      	cmp	r1, #23
	return result;
}

/* Call this to give malloc some memory to allocate from */
void add_malloc_block(void *buf, size_t size)
{
    3856:	b510      	push	{r4, lr}
    3858:	4604      	mov	r4, r0
	struct free_arena_header *fp = buf;
	struct free_arena_header *pah;

	if (size < sizeof(struct free_arena_header))
    385a:	d91b      	bls.n	3894 <add_malloc_block+0x40>
		return; // Too small.

	/* Insert the block into the management chains.  We need to set
	   up the size and the main block list pointer, the rest of
	   the work is logically identical to free(). */
	fp->a.type = ARENA_TYPE_FREE;
    385c:	2301      	movs	r3, #1
    385e:	6003      	str	r3, [r0, #0]
	fp->a.size = size;

        if (!malloc_lock())
    3860:	4b0d      	ldr	r3, [pc, #52]	; (3898 <add_malloc_block+0x44>)

	/* Insert the block into the management chains.  We need to set
	   up the size and the main block list pointer, the rest of
	   the work is logically identical to free(). */
	fp->a.type = ARENA_TYPE_FREE;
	fp->a.size = size;
    3862:	6041      	str	r1, [r0, #4]

        if (!malloc_lock())
    3864:	681b      	ldr	r3, [r3, #0]
    3866:	4798      	blx	r3
    3868:	b1a0      	cbz	r0, 3894 <add_malloc_block+0x40>

	/* We need to insert this into the main block list in the proper
	   place -- this list is required to be sorted.  Since we most likely
	   get memory assignments in ascending order, search backwards for
	   the proper place. */
	for (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;
    386a:	4b0c      	ldr	r3, [pc, #48]	; (389c <add_malloc_block+0x48>)
	     pah = pah->a.prev) {
    386c:	68db      	ldr	r3, [r3, #12]

	/* We need to insert this into the main block list in the proper
	   place -- this list is required to be sorted.  Since we most likely
	   get memory assignments in ascending order, search backwards for
	   the proper place. */
	for (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;
    386e:	681a      	ldr	r2, [r3, #0]
    3870:	2a02      	cmp	r2, #2
    3872:	d001      	beq.n	3878 <add_malloc_block+0x24>
	     pah = pah->a.prev) {
		if (pah < fp)
    3874:	42a3      	cmp	r3, r4
    3876:	d2f9      	bcs.n	386c <add_malloc_block+0x18>
			break;
	}

	/* Now pah points to the node that should be the predecessor of
	   the new node */
	fp->a.next = pah->a.next;
    3878:	689a      	ldr	r2, [r3, #8]
    387a:	60a2      	str	r2, [r4, #8]
	fp->a.prev = pah;
    387c:	60e3      	str	r3, [r4, #12]
	pah->a.next = fp;
    387e:	609c      	str	r4, [r3, #8]
	fp->a.next->a.prev = fp;
    3880:	68a3      	ldr	r3, [r4, #8]

	/* Insert into the free chain and coalesce with adjacent blocks */
	fp = __free_block(fp);
    3882:	4620      	mov	r0, r4
	/* Now pah points to the node that should be the predecessor of
	   the new node */
	fp->a.next = pah->a.next;
	fp->a.prev = pah;
	pah->a.next = fp;
	fp->a.next->a.prev = fp;
    3884:	60dc      	str	r4, [r3, #12]

	/* Insert into the free chain and coalesce with adjacent blocks */
	fp = __free_block(fp);
    3886:	f7ff ffb5 	bl	37f4 <__free_block>

        malloc_unlock();
    388a:	4b05      	ldr	r3, [pc, #20]	; (38a0 <add_malloc_block+0x4c>)
}
    388c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	fp->a.next->a.prev = fp;

	/* Insert into the free chain and coalesce with adjacent blocks */
	fp = __free_block(fp);

        malloc_unlock();
    3890:	681b      	ldr	r3, [r3, #0]
    3892:	4718      	bx	r3
    3894:	bd10      	pop	{r4, pc}
    3896:	bf00      	nop
    3898:	20000114 	.word	0x20000114
    389c:	200000f8 	.word	0x200000f8
    38a0:	20000110 	.word	0x20000110

000038a4 <malloc>:
	/* Return the block that contains the called block */
	return ah;
}

void *malloc(size_t size)
{
    38a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct free_arena_header *fp;
        void *more_mem;
        extern void *_sbrk(int incr);

	if (size == 0)
    38a6:	b908      	cbnz	r0, 38ac <malloc+0x8>
		return NULL;
    38a8:	2000      	movs	r0, #0
    38aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;

        if (!malloc_lock())
    38ac:	4b1f      	ldr	r3, [pc, #124]	; (392c <malloc+0x88>)

	if (size == 0)
		return NULL;

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
    38ae:	301f      	adds	r0, #31

        if (!malloc_lock())
    38b0:	681b      	ldr	r3, [r3, #0]

	if (size == 0)
		return NULL;

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
    38b2:	f020 040f 	bic.w	r4, r0, #15

        if (!malloc_lock())
    38b6:	4798      	blx	r3
    38b8:	2800      	cmp	r0, #0
    38ba:	d0f5      	beq.n	38a8 <malloc+0x4>
                return NULL;

        void *result = NULL;
retry_alloc:
	for (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;
    38bc:	4b1c      	ldr	r3, [pc, #112]	; (3930 <malloc+0x8c>)
    38be:	6918      	ldr	r0, [r3, #16]
    38c0:	6803      	ldr	r3, [r0, #0]
    38c2:	2b02      	cmp	r3, #2
    38c4:	d029      	beq.n	391a <malloc+0x76>
	     fp = fp->next_free) {
		if (fp->a.size >= size) {
    38c6:	6842      	ldr	r2, [r0, #4]
    38c8:	42a2      	cmp	r2, r4
    38ca:	d31e      	bcc.n	390a <malloc+0x66>

	fsize = fp->a.size;

	/* We need the 2* to account for the larger requirements of a
	   free block */
	if (fsize >= size + 2 * sizeof(struct arena_header)) {
    38cc:	f104 0320 	add.w	r3, r4, #32
    38d0:	429a      	cmp	r2, r3
    38d2:	6901      	ldr	r1, [r0, #16]
    38d4:	6945      	ldr	r5, [r0, #20]
    38d6:	d311      	bcc.n	38fc <malloc+0x58>
		/* Bigger block than required -- split block */
		nfp = (struct free_arena_header *)((char *)fp + size);
    38d8:	1903      	adds	r3, r0, r4
		na = fp->a.next;
    38da:	6886      	ldr	r6, [r0, #8]

		nfp->a.type = ARENA_TYPE_FREE;
		nfp->a.size = fsize - size;
    38dc:	1b12      	subs	r2, r2, r4
	if (fsize >= size + 2 * sizeof(struct arena_header)) {
		/* Bigger block than required -- split block */
		nfp = (struct free_arena_header *)((char *)fp + size);
		na = fp->a.next;

		nfp->a.type = ARENA_TYPE_FREE;
    38de:	2701      	movs	r7, #1
    38e0:	5107      	str	r7, [r0, r4]
		nfp->a.size = fsize - size;
    38e2:	605a      	str	r2, [r3, #4]
		fp->a.type = ARENA_TYPE_USED;
    38e4:	2200      	movs	r2, #0
		fp->a.size = size;
    38e6:	e880 0014 	stmia.w	r0, {r2, r4}

		/* Insert into all-block chain */
		nfp->a.prev = fp;
    38ea:	60d8      	str	r0, [r3, #12]
		nfp->a.next = na;
    38ec:	609e      	str	r6, [r3, #8]
		na->a.prev = nfp;
    38ee:	60f3      	str	r3, [r6, #12]
		fp->a.next = nfp;
    38f0:	6083      	str	r3, [r0, #8]

		/* Replace current block on free chain */
		nfp->next_free = fpn = fp->next_free;
    38f2:	6119      	str	r1, [r3, #16]
		nfp->prev_free = fpp = fp->prev_free;
    38f4:	615d      	str	r5, [r3, #20]
		fpn->prev_free = nfp;
    38f6:	614b      	str	r3, [r1, #20]
		fpp->next_free = nfp;
    38f8:	612b      	str	r3, [r5, #16]
    38fa:	e003      	b.n	3904 <malloc+0x60>
	} else {
		fp->a.type = ARENA_TYPE_USED; /* Allocate the whole block */
    38fc:	2300      	movs	r3, #0
    38fe:	6003      	str	r3, [r0, #0]
{
	struct free_arena_header *ap, *an;

	ap = ah->prev_free;
	an = ah->next_free;
	ap->next_free = an;
    3900:	6129      	str	r1, [r5, #16]
	an->prev_free = ap;
    3902:	614d      	str	r5, [r1, #20]
	} else {
		fp->a.type = ARENA_TYPE_USED; /* Allocate the whole block */
		remove_from_free_chain(fp);
	}

	return (void *)(&fp->a + 1);
    3904:	f100 0410 	add.w	r4, r0, #16
    3908:	e002      	b.n	3910 <malloc+0x6c>
                return NULL;

        void *result = NULL;
retry_alloc:
	for (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;
	     fp = fp->next_free) {
    390a:	6900      	ldr	r0, [r0, #16]
    390c:	e7d8      	b.n	38c0 <malloc+0x1c>
    390e:	2400      	movs	r4, #0
            if (more_mem != (void *)-1) {
                add_malloc_block(more_mem, size);
                goto retry_alloc;
            }
        }
        malloc_unlock();
    3910:	4b08      	ldr	r3, [pc, #32]	; (3934 <malloc+0x90>)
    3912:	681b      	ldr	r3, [r3, #0]
    3914:	4798      	blx	r3
	return result;
    3916:	4620      	mov	r0, r4
    3918:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			result = __malloc_from_block(fp, size);
                        break;
		}
	}
        if (result == NULL) {
            more_mem = _sbrk(size);
    391a:	4620      	mov	r0, r4
    391c:	f002 f92e 	bl	5b7c <_sbrk>
            if (more_mem != (void *)-1) {
    3920:	1c43      	adds	r3, r0, #1
    3922:	d0f4      	beq.n	390e <malloc+0x6a>
                add_malloc_block(more_mem, size);
    3924:	4621      	mov	r1, r4
    3926:	f7ff ff95 	bl	3854 <add_malloc_block>
                goto retry_alloc;
    392a:	e7c7      	b.n	38bc <malloc+0x18>
    392c:	20000114 	.word	0x20000114
    3930:	200000f8 	.word	0x200000f8
    3934:	20000110 	.word	0x20000110

00003938 <free>:

        malloc_unlock();
}

void free(void *ptr)
{
    3938:	b510      	push	{r4, lr}
	struct free_arena_header *ah;

	if (!ptr)
    393a:	4604      	mov	r4, r0
    393c:	b160      	cbz	r0, 3958 <free+0x20>

#ifdef DEBUG_MALLOC
	assert(ah->a.type == ARENA_TYPE_USED);
#endif

        if (!malloc_lock())
    393e:	4b07      	ldr	r3, [pc, #28]	; (395c <free+0x24>)
    3940:	681b      	ldr	r3, [r3, #0]
    3942:	4798      	blx	r3
    3944:	b140      	cbz	r0, 3958 <free+0x20>
            return;

	/* Merge into adjacent free blocks */
	ah = __free_block(ah);
    3946:	f1a4 0010 	sub.w	r0, r4, #16
    394a:	f7ff ff53 	bl	37f4 <__free_block>
        malloc_unlock();
    394e:	4b04      	ldr	r3, [pc, #16]	; (3960 <free+0x28>)
}
    3950:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        if (!malloc_lock())
            return;

	/* Merge into adjacent free blocks */
	ah = __free_block(ah);
        malloc_unlock();
    3954:	681b      	ldr	r3, [r3, #0]
    3956:	4718      	bx	r3
    3958:	bd10      	pop	{r4, pc}
    395a:	bf00      	nop
    395c:	20000114 	.word	0x20000114
    3960:	20000110 	.word	0x20000110

00003964 <memset>:

#include <string.h>
#include <stdint.h>

void *memset(void *dst, int c, size_t n)
{
    3964:	4402      	add	r2, r0
	char *q = dst;
    3966:	4603      	mov	r3, r0
	asm volatile ("cld ; rep ; stosq ; movl %3,%%ecx ; rep ; stosb"
		      :"+c" (nq), "+D" (q)
		      : "a" ((unsigned char)c * 0x0101010101010101U),
			"r" ((uint32_t) n & 7));
#else
	while (n--) {
    3968:	4293      	cmp	r3, r2
    396a:	d002      	beq.n	3972 <memset+0xe>
		*q++ = c;
    396c:	f803 1b01 	strb.w	r1, [r3], #1
    3970:	e7fa      	b.n	3968 <memset+0x4>
	}
#endif

	return dst;
}
    3972:	4770      	bx	lr

00003974 <strchr>:
 */

#include <string.h>

char *strchr(const char *s, int c)
{
    3974:	b510      	push	{r4, lr}
    3976:	4602      	mov	r2, r0
	while (*s != (char)c) {
    3978:	f810 3b01 	ldrb.w	r3, [r0], #1
    397c:	b2cc      	uxtb	r4, r1
    397e:	42a3      	cmp	r3, r4
    3980:	d003      	beq.n	398a <strchr+0x16>
		if (!*s)
    3982:	2b00      	cmp	r3, #0
    3984:	d1f7      	bne.n	3976 <strchr+0x2>
			return NULL;
    3986:	4618      	mov	r0, r3
		s++;
	}

	return (char *)s;
}
    3988:	bd10      	pop	{r4, pc}
    398a:	4610      	mov	r0, r2
    398c:	bd10      	pop	{r4, pc}

0000398e <strcpy>:
 */

#include <string.h>

char *strcpy(char *dst, const char *src)
{
    398e:	1e42      	subs	r2, r0, #1
	char *q = dst;
	const char *p = src;
	char ch;

	do {
		*q++ = ch = *p++;
    3990:	f811 3b01 	ldrb.w	r3, [r1], #1
    3994:	f802 3f01 	strb.w	r3, [r2, #1]!
	} while (ch);
    3998:	2b00      	cmp	r3, #0
    399a:	d1f9      	bne.n	3990 <strcpy+0x2>

	return dst;
}
    399c:	4770      	bx	lr

0000399e <strlen>:
 */

#include <string.h>

size_t strlen(const char *s)
{
    399e:	4603      	mov	r3, r0
    39a0:	461a      	mov	r2, r3
    39a2:	3301      	adds	r3, #1
	const char *ss = s;
	while (*ss)
    39a4:	7811      	ldrb	r1, [r2, #0]
    39a6:	2900      	cmp	r1, #0
    39a8:	d1fa      	bne.n	39a0 <strlen+0x2>
		ss++;
	return ss - s;
}
    39aa:	1a10      	subs	r0, r2, r0
    39ac:	4770      	bx	lr

000039ae <strncmp>:
 */

#include <string.h>

int strncmp(const char *s1, const char *s2, size_t n)
{
    39ae:	b510      	push	{r4, lr}
    39b0:	4402      	add	r2, r0
	const unsigned char *c1 = (const unsigned char *)s1;
	const unsigned char *c2 = (const unsigned char *)s2;
	unsigned char ch;
	int d = 0;

	while (n--) {
    39b2:	4290      	cmp	r0, r2
    39b4:	d008      	beq.n	39c8 <strncmp+0x1a>
		d = (int)(ch = *c1++) - (int)*c2++;
    39b6:	f810 4b01 	ldrb.w	r4, [r0], #1
    39ba:	f811 3b01 	ldrb.w	r3, [r1], #1
		if (d || !ch)
    39be:	1ae3      	subs	r3, r4, r3
    39c0:	d103      	bne.n	39ca <strncmp+0x1c>
    39c2:	2c00      	cmp	r4, #0
    39c4:	d1f5      	bne.n	39b2 <strncmp+0x4>
    39c6:	e000      	b.n	39ca <strncmp+0x1c>
    39c8:	2300      	movs	r3, #0
			break;
	}

	return d;
}
    39ca:	4618      	mov	r0, r3
    39cc:	bd10      	pop	{r4, pc}
	...

000039d0 <boot_conf_set>:
boot_conf_set(int argc, char **argv, char *val)
{
    int rc;
    int len;

    if (argc == 1) {
    39d0:	2801      	cmp	r0, #1
    .ch_export = NULL,
};

static int
boot_conf_set(int argc, char **argv, char *val)
{
    39d2:	b537      	push	{r0, r1, r2, r4, r5, lr}
    39d4:	4614      	mov	r4, r2
    int rc;
    int len;

    if (argc == 1) {
    39d6:	d120      	bne.n	3a1a <boot_conf_set+0x4a>
        if (!strcmp(argv[0], "main")) {
    39d8:	680d      	ldr	r5, [r1, #0]
    39da:	4911      	ldr	r1, [pc, #68]	; (3a20 <boot_conf_set+0x50>)
    39dc:	4628      	mov	r0, r5
    39de:	f002 fab0 	bl	5f42 <strcmp>
    39e2:	b938      	cbnz	r0, 39f4 <boot_conf_set+0x24>
            len = sizeof(boot_main);
    39e4:	2308      	movs	r3, #8
    39e6:	9301      	str	r3, [sp, #4]
            if (val) {
    39e8:	b114      	cbz	r4, 39f0 <boot_conf_set+0x20>
                rc = conf_bytes_from_str(val, &boot_main, &len);
    39ea:	4620      	mov	r0, r4
    39ec:	490d      	ldr	r1, [pc, #52]	; (3a24 <boot_conf_set+0x54>)
    39ee:	e00b      	b.n	3a08 <boot_conf_set+0x38>
            } else {
                memset(&boot_main, 0, len);
    39f0:	4b0c      	ldr	r3, [pc, #48]	; (3a24 <boot_conf_set+0x54>)
    39f2:	e00e      	b.n	3a12 <boot_conf_set+0x42>
                rc = 0;
            }
        } else if (!strcmp(argv[0], "test")) {
    39f4:	4628      	mov	r0, r5
    39f6:	490c      	ldr	r1, [pc, #48]	; (3a28 <boot_conf_set+0x58>)
    39f8:	f002 faa3 	bl	5f42 <strcmp>
    39fc:	b968      	cbnz	r0, 3a1a <boot_conf_set+0x4a>
            len = sizeof(boot_test);
    39fe:	2308      	movs	r3, #8
    3a00:	9301      	str	r3, [sp, #4]
            if (val) {
    3a02:	b12c      	cbz	r4, 3a10 <boot_conf_set+0x40>
                rc = conf_bytes_from_str(val, &boot_test, &len);
    3a04:	4909      	ldr	r1, [pc, #36]	; (3a2c <boot_conf_set+0x5c>)
    3a06:	4620      	mov	r0, r4
    3a08:	aa01      	add	r2, sp, #4
    3a0a:	f001 fd95 	bl	5538 <conf_bytes_from_str>
    3a0e:	e005      	b.n	3a1c <boot_conf_set+0x4c>
            } else {
                memset(&boot_test, 0, len);
    3a10:	4b06      	ldr	r3, [pc, #24]	; (3a2c <boot_conf_set+0x5c>)
    3a12:	601c      	str	r4, [r3, #0]
    3a14:	605c      	str	r4, [r3, #4]
    3a16:	4620      	mov	r0, r4
    3a18:	e000      	b.n	3a1c <boot_conf_set+0x4c>
#endif
        } else {
            rc = OS_ENOENT;
        }
    } else {
        rc = OS_ENOENT;
    3a1a:	200a      	movs	r0, #10
    }
    return rc;
}
    3a1c:	b003      	add	sp, #12
    3a1e:	bd30      	pop	{r4, r5, pc}
    3a20:	00006345 	.word	0x00006345
    3a24:	20000608 	.word	0x20000608
    3a28:	0000633b 	.word	0x0000633b
    3a2c:	20000610 	.word	0x20000610

00003a30 <boot_vect_read_test>:

static int
boot_vect_read_one(struct image_version *dst, struct image_version *src)
{
    if (src->iv_major == 0 && src->iv_minor == 0 &&
    3a30:	4b06      	ldr	r3, [pc, #24]	; (3a4c <boot_vect_read_test+0x1c>)
    3a32:	6819      	ldr	r1, [r3, #0]
 *
 * @return                  0 on success; nonzero on failure.
 */
int
boot_vect_read_test(struct image_version *out_ver)
{
    3a34:	4602      	mov	r2, r0
}

static int
boot_vect_read_one(struct image_version *dst, struct image_version *src)
{
    if (src->iv_major == 0 && src->iv_minor == 0 &&
    3a36:	b909      	cbnz	r1, 3a3c <boot_vect_read_test+0xc>
      src->iv_revision == 0 && src->iv_build_num == 0) {
    3a38:	685b      	ldr	r3, [r3, #4]
    3a3a:	b12b      	cbz	r3, 3a48 <boot_vect_read_test+0x18>
        return BOOT_EBADVECT;
    }
    memcpy(dst, src, sizeof(*dst));
    3a3c:	4b03      	ldr	r3, [pc, #12]	; (3a4c <boot_vect_read_test+0x1c>)
    3a3e:	cb03      	ldmia	r3!, {r0, r1}
    3a40:	6010      	str	r0, [r2, #0]
    3a42:	6051      	str	r1, [r2, #4]
    return 0;
    3a44:	2000      	movs	r0, #0
    3a46:	4770      	bx	lr
static int
boot_vect_read_one(struct image_version *dst, struct image_version *src)
{
    if (src->iv_major == 0 && src->iv_minor == 0 &&
      src->iv_revision == 0 && src->iv_build_num == 0) {
        return BOOT_EBADVECT;
    3a48:	2004      	movs	r0, #4
 */
int
boot_vect_read_test(struct image_version *out_ver)
{
    return boot_vect_read_one(out_ver, &boot_test);
}
    3a4a:	4770      	bx	lr
    3a4c:	20000610 	.word	0x20000610

00003a50 <boot_vect_read_main>:
}

static int
boot_vect_read_one(struct image_version *dst, struct image_version *src)
{
    if (src->iv_major == 0 && src->iv_minor == 0 &&
    3a50:	4b06      	ldr	r3, [pc, #24]	; (3a6c <boot_vect_read_main+0x1c>)
    3a52:	6819      	ldr	r1, [r3, #0]
 *
 * @return                  0 on success; nonzero on failure.
 */
int
boot_vect_read_main(struct image_version *out_ver)
{
    3a54:	4602      	mov	r2, r0
}

static int
boot_vect_read_one(struct image_version *dst, struct image_version *src)
{
    if (src->iv_major == 0 && src->iv_minor == 0 &&
    3a56:	b909      	cbnz	r1, 3a5c <boot_vect_read_main+0xc>
      src->iv_revision == 0 && src->iv_build_num == 0) {
    3a58:	685b      	ldr	r3, [r3, #4]
    3a5a:	b12b      	cbz	r3, 3a68 <boot_vect_read_main+0x18>
        return BOOT_EBADVECT;
    }
    memcpy(dst, src, sizeof(*dst));
    3a5c:	4b03      	ldr	r3, [pc, #12]	; (3a6c <boot_vect_read_main+0x1c>)
    3a5e:	cb03      	ldmia	r3!, {r0, r1}
    3a60:	6010      	str	r0, [r2, #0]
    3a62:	6051      	str	r1, [r2, #4]
    return 0;
    3a64:	2000      	movs	r0, #0
    3a66:	4770      	bx	lr
static int
boot_vect_read_one(struct image_version *dst, struct image_version *src)
{
    if (src->iv_major == 0 && src->iv_minor == 0 &&
      src->iv_revision == 0 && src->iv_build_num == 0) {
        return BOOT_EBADVECT;
    3a68:	2004      	movs	r0, #4
 */
int
boot_vect_read_main(struct image_version *out_ver)
{
    return boot_vect_read_one(out_ver, &boot_main);
}
    3a6a:	4770      	bx	lr
    3a6c:	20000608 	.word	0x20000608

00003a70 <boot_vect_write_test>:
 *
 * @return                  0 on success; nonzero on failure.
 */
int
boot_vect_write_test(struct image_version *ver)
{
    3a70:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (!ver) {
    3a72:	4601      	mov	r1, r0
    3a74:	4b0d      	ldr	r3, [pc, #52]	; (3aac <boot_vect_write_test+0x3c>)
    3a76:	b918      	cbnz	r0, 3a80 <boot_vect_write_test+0x10>
        memset(&boot_test, 0, sizeof(boot_test));
    3a78:	6018      	str	r0, [r3, #0]
    3a7a:	6058      	str	r0, [r3, #4]
        if (!conf_str_from_bytes(ver, sizeof(*ver), str, sizeof(str))) {
            return -1;
        }
        to_store = str;
    }
    return conf_save_one(name, to_store);
    3a7c:	480c      	ldr	r0, [pc, #48]	; (3ab0 <boot_vect_write_test+0x40>)
    3a7e:	e00c      	b.n	3a9a <boot_vect_write_test+0x2a>
{
    if (!ver) {
        memset(&boot_test, 0, sizeof(boot_test));
        return boot_vect_write_one("boot/test", NULL);
    } else {
        memcpy(&boot_test, ver, sizeof(boot_test));
    3a80:	6800      	ldr	r0, [r0, #0]
    3a82:	6849      	ldr	r1, [r1, #4]
    3a84:	461a      	mov	r2, r3
    3a86:	c203      	stmia	r2!, {r0, r1}
    char *to_store;

    if (!ver) {
        to_store = NULL;
    } else {
        if (!conf_str_from_bytes(ver, sizeof(*ver), str, sizeof(str))) {
    3a88:	4618      	mov	r0, r3
    3a8a:	2108      	movs	r1, #8
    3a8c:	466a      	mov	r2, sp
    3a8e:	230e      	movs	r3, #14
    3a90:	f001 fd66 	bl	5560 <conf_str_from_bytes>
    3a94:	b120      	cbz	r0, 3aa0 <boot_vect_write_test+0x30>
            return -1;
        }
        to_store = str;
    }
    return conf_save_one(name, to_store);
    3a96:	4806      	ldr	r0, [pc, #24]	; (3ab0 <boot_vect_write_test+0x40>)
    3a98:	4669      	mov	r1, sp
    3a9a:	f001 ff95 	bl	59c8 <conf_save_one>
    3a9e:	e001      	b.n	3aa4 <boot_vect_write_test+0x34>

    if (!ver) {
        to_store = NULL;
    } else {
        if (!conf_str_from_bytes(ver, sizeof(*ver), str, sizeof(str))) {
            return -1;
    3aa0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        return boot_vect_write_one("boot/test", NULL);
    } else {
        memcpy(&boot_test, ver, sizeof(boot_test));
        return boot_vect_write_one("boot/test", &boot_test);
    }
}
    3aa4:	b005      	add	sp, #20
    3aa6:	f85d fb04 	ldr.w	pc, [sp], #4
    3aaa:	bf00      	nop
    3aac:	20000610 	.word	0x20000610
    3ab0:	00006336 	.word	0x00006336

00003ab4 <boot_vect_write_main>:
 *
 * @return                  0 on success; nonzero on failure.
 */
int
boot_vect_write_main(struct image_version *ver)
{
    3ab4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (!ver) {
    3ab6:	4601      	mov	r1, r0
    3ab8:	4b0d      	ldr	r3, [pc, #52]	; (3af0 <boot_vect_write_main+0x3c>)
    3aba:	b918      	cbnz	r0, 3ac4 <boot_vect_write_main+0x10>
        memset(&boot_main, 0, sizeof(boot_main));
    3abc:	6018      	str	r0, [r3, #0]
    3abe:	6058      	str	r0, [r3, #4]
        if (!conf_str_from_bytes(ver, sizeof(*ver), str, sizeof(str))) {
            return -1;
        }
        to_store = str;
    }
    return conf_save_one(name, to_store);
    3ac0:	480c      	ldr	r0, [pc, #48]	; (3af4 <boot_vect_write_main+0x40>)
    3ac2:	e00c      	b.n	3ade <boot_vect_write_main+0x2a>
{
    if (!ver) {
        memset(&boot_main, 0, sizeof(boot_main));
        return boot_vect_write_one("boot/main", NULL);
    } else {
        memcpy(&boot_main, ver, sizeof(boot_main));
    3ac4:	6800      	ldr	r0, [r0, #0]
    3ac6:	6849      	ldr	r1, [r1, #4]
    3ac8:	461a      	mov	r2, r3
    3aca:	c203      	stmia	r2!, {r0, r1}
    char *to_store;

    if (!ver) {
        to_store = NULL;
    } else {
        if (!conf_str_from_bytes(ver, sizeof(*ver), str, sizeof(str))) {
    3acc:	4618      	mov	r0, r3
    3ace:	2108      	movs	r1, #8
    3ad0:	466a      	mov	r2, sp
    3ad2:	230e      	movs	r3, #14
    3ad4:	f001 fd44 	bl	5560 <conf_str_from_bytes>
    3ad8:	b120      	cbz	r0, 3ae4 <boot_vect_write_main+0x30>
            return -1;
        }
        to_store = str;
    }
    return conf_save_one(name, to_store);
    3ada:	4806      	ldr	r0, [pc, #24]	; (3af4 <boot_vect_write_main+0x40>)
    3adc:	4669      	mov	r1, sp
    3ade:	f001 ff73 	bl	59c8 <conf_save_one>
    3ae2:	e001      	b.n	3ae8 <boot_vect_write_main+0x34>

    if (!ver) {
        to_store = NULL;
    } else {
        if (!conf_str_from_bytes(ver, sizeof(*ver), str, sizeof(str))) {
            return -1;
    3ae4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        return boot_vect_write_one("boot/main", NULL);
    } else {
        memcpy(&boot_main, ver, sizeof(boot_main));
        return boot_vect_write_one("boot/main", &boot_main);
    }
}
    3ae8:	b005      	add	sp, #20
    3aea:	f85d fb04 	ldr.w	pc, [sp], #4
    3aee:	bf00      	nop
    3af0:	20000608 	.word	0x20000608
    3af4:	00006340 	.word	0x00006340

00003af8 <boot_read_image_headers>:
 */
void
boot_read_image_headers(struct image_header *out_headers,
                        const struct boot_image_location *addresses,
                        int num_addresses)
{
    3af8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3afa:	460e      	mov	r6, r1
    3afc:	4617      	mov	r7, r2
    3afe:	4605      	mov	r5, r0
    struct image_header *hdr;
    int rc;
    int i;

    for (i = 0; i < num_addresses; i++) {
    3b00:	2400      	movs	r4, #0
    3b02:	42bc      	cmp	r4, r7
    3b04:	da15      	bge.n	3b32 <boot_read_image_headers+0x3a>
    3b06:	eb06 03c4 	add.w	r3, r6, r4, lsl #3
boot_read_image_header(struct image_header *out_hdr,
                       const struct boot_image_location *loc)
{
    int rc;

    rc = hal_flash_read(loc->bil_flash_id, loc->bil_address, out_hdr,
    3b0a:	f816 0034 	ldrb.w	r0, [r6, r4, lsl #3]
    3b0e:	6859      	ldr	r1, [r3, #4]
    3b10:	462a      	mov	r2, r5
    3b12:	2320      	movs	r3, #32
    3b14:	f7ff fde6 	bl	36e4 <hal_flash_read>
                        sizeof *out_hdr);
    if (rc != 0) {
    3b18:	b918      	cbnz	r0, 3b22 <boot_read_image_headers+0x2a>
        return BOOT_EFLASH;
    }

    if (out_hdr->ih_magic != IMAGE_MAGIC) {
    3b1a:	682a      	ldr	r2, [r5, #0]
    3b1c:	4b05      	ldr	r3, [pc, #20]	; (3b34 <boot_read_image_headers+0x3c>)
    3b1e:	429a      	cmp	r2, r3
    3b20:	d004      	beq.n	3b2c <boot_read_image_headers+0x34>

    for (i = 0; i < num_addresses; i++) {
        hdr = out_headers + i;
        rc = boot_read_image_header(hdr, &addresses[i]);
        if (rc != 0 || hdr->ih_magic != IMAGE_MAGIC) {
            memset(hdr, 0xff, sizeof *hdr);
    3b22:	4628      	mov	r0, r5
    3b24:	21ff      	movs	r1, #255	; 0xff
    3b26:	2220      	movs	r2, #32
    3b28:	f7ff ff1c 	bl	3964 <memset>
{
    struct image_header *hdr;
    int rc;
    int i;

    for (i = 0; i < num_addresses; i++) {
    3b2c:	3401      	adds	r4, #1
    3b2e:	3520      	adds	r5, #32
    3b30:	e7e7      	b.n	3b02 <boot_read_image_headers+0xa>
        rc = boot_read_image_header(hdr, &addresses[i]);
        if (rc != 0 || hdr->ih_magic != IMAGE_MAGIC) {
            memset(hdr, 0xff, sizeof *hdr);
        }
    }
}
    3b32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3b34:	96f3b83c 	.word	0x96f3b83c

00003b38 <bootutil_cfg_register>:

void
bootutil_cfg_register(void)
{
    conf_register(&boot_conf_handler);
    3b38:	4801      	ldr	r0, [pc, #4]	; (3b40 <bootutil_cfg_register+0x8>)
    3b3a:	f001 bcc1 	b.w	54c0 <conf_register>
    3b3e:	bf00      	nop
    3b40:	20000118 	.word	0x20000118

00003b44 <boot_read_status>:
 * status is not present in the file system, the implication is that there is
 * no copy operation in progress.
 */
int
boot_read_status(struct boot_status *bs)
{
    3b44:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    3b46:	4604      	mov	r4, r0
    int rc;
    uint32_t bytes_read;

    conf_load();
    3b48:	f001 ff28 	bl	599c <conf_load>

    rc = fsutil_read_file(BOOT_PATH_STATUS, 0, sizeof(*bs),
    3b4c:	ab03      	add	r3, sp, #12
    3b4e:	9300      	str	r3, [sp, #0]
    3b50:	4809      	ldr	r0, [pc, #36]	; (3b78 <boot_read_status+0x34>)
    3b52:	2100      	movs	r1, #0
    3b54:	2208      	movs	r2, #8
    3b56:	4623      	mov	r3, r4
    3b58:	f001 ffc6 	bl	5ae8 <fsutil_read_file>
      bs, &bytes_read);
    if (rc || bytes_read != sizeof(*bs)) {
    3b5c:	b910      	cbnz	r0, 3b64 <boot_read_status+0x20>
    3b5e:	9b03      	ldr	r3, [sp, #12]
    3b60:	2b08      	cmp	r3, #8
    3b62:	d006      	beq.n	3b72 <boot_read_status+0x2e>
        memset(bs, 0, sizeof(*bs));
    3b64:	4620      	mov	r0, r4
    3b66:	2100      	movs	r1, #0
    3b68:	2208      	movs	r2, #8
    3b6a:	f7ff fefb 	bl	3964 <memset>
        return 0;
    3b6e:	2000      	movs	r0, #0
    3b70:	e000      	b.n	3b74 <boot_read_status+0x30>
    }
    return 1;
    3b72:	2001      	movs	r0, #1
}
    3b74:	b004      	add	sp, #16
    3b76:	bd10      	pop	{r4, pc}
    3b78:	0000634a 	.word	0x0000634a

00003b7c <boot_write_status>:

int
boot_write_status(struct boot_status *bs)
{
    3b7c:	b508      	push	{r3, lr}
    3b7e:	4601      	mov	r1, r0
    int rc;

    /*
     * XXX point of failure.
     */
    rc = fsutil_write_file(BOOT_PATH_STATUS, bs, sizeof(*bs));
    3b80:	2208      	movs	r2, #8
    3b82:	4804      	ldr	r0, [pc, #16]	; (3b94 <boot_write_status+0x18>)
    3b84:	f001 ffc6 	bl	5b14 <fsutil_write_file>
    if (rc) {
        rc = BOOT_EFILE;
    }
    return rc;
}
    3b88:	2800      	cmp	r0, #0
    3b8a:	bf14      	ite	ne
    3b8c:	2002      	movne	r0, #2
    3b8e:	2000      	moveq	r0, #0
    3b90:	bd08      	pop	{r3, pc}
    3b92:	bf00      	nop
    3b94:	0000634a 	.word	0x0000634a

00003b98 <boot_clear_status>:

void
boot_clear_status(void)
{
    fs_unlink(BOOT_PATH_STATUS);
    3b98:	4801      	ldr	r0, [pc, #4]	; (3ba0 <boot_clear_status+0x8>)
    3b9a:	f001 bf8f 	b.w	5abc <fs_unlink>
    3b9e:	bf00      	nop
    3ba0:	0000634a 	.word	0x0000634a

00003ba4 <boot_find_image_slot>:
 * @return                      The image slot containing the specified image
 *                              on success; -1 on failure.
 */
static int
boot_find_image_slot(const struct image_version *ver)
{
    3ba4:	b510      	push	{r4, lr}
    3ba6:	4604      	mov	r4, r0
    int i;

    for (i = 0; i < 2; i++) {
        if (memcmp(&boot_img_hdrs[i].ih_ver, ver, sizeof *ver) == 0) {
    3ba8:	4621      	mov	r1, r4
    3baa:	4808      	ldr	r0, [pc, #32]	; (3bcc <boot_find_image_slot+0x28>)
    3bac:	2208      	movs	r2, #8
    3bae:	f002 f983 	bl	5eb8 <memcmp>
    3bb2:	b148      	cbz	r0, 3bc8 <boot_find_image_slot+0x24>
    3bb4:	4806      	ldr	r0, [pc, #24]	; (3bd0 <boot_find_image_slot+0x2c>)
    3bb6:	4621      	mov	r1, r4
    3bb8:	2208      	movs	r2, #8
    3bba:	f002 f97d 	bl	5eb8 <memcmp>
    3bbe:	b908      	cbnz	r0, 3bc4 <boot_find_image_slot+0x20>
static int
boot_find_image_slot(const struct image_version *ver)
{
    int i;

    for (i = 0; i < 2; i++) {
    3bc0:	2001      	movs	r0, #1
    3bc2:	bd10      	pop	{r4, pc}
        if (memcmp(&boot_img_hdrs[i].ih_ver, ver, sizeof *ver) == 0) {
            return i;
        }
    }

    return -1;
    3bc4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    3bc8:	bd10      	pop	{r4, pc}
    3bca:	bf00      	nop
    3bcc:	20000cc4 	.word	0x20000cc4
    3bd0:	20000ce4 	.word	0x20000ce4

00003bd4 <boot_image_check>:
/*
 * Validate image hash/signature in a slot.
 */
static int
boot_image_check(struct image_header *hdr, struct boot_image_location *loc)
{
    3bd4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    static void *tmpbuf;

    if (!tmpbuf) {
    3bd6:	4c0f      	ldr	r4, [pc, #60]	; (3c14 <boot_image_check+0x40>)
    3bd8:	6823      	ldr	r3, [r4, #0]
/*
 * Validate image hash/signature in a slot.
 */
static int
boot_image_check(struct image_header *hdr, struct boot_image_location *loc)
{
    3bda:	4606      	mov	r6, r0
    3bdc:	460d      	mov	r5, r1
    3bde:	4627      	mov	r7, r4
    static void *tmpbuf;

    if (!tmpbuf) {
    3be0:	b16b      	cbz	r3, 3bfe <boot_image_check+0x2a>
        tmpbuf = malloc(BOOT_TMPBUF_SZ);
        if (!tmpbuf) {
            return BOOT_ENOMEM;
        }
    }
    if (bootutil_img_validate(hdr, loc->bil_flash_id, loc->bil_address,
    3be2:	f44f 7380 	mov.w	r3, #256	; 0x100
    3be6:	9300      	str	r3, [sp, #0]
    3be8:	7829      	ldrb	r1, [r5, #0]
    3bea:	686a      	ldr	r2, [r5, #4]
    3bec:	683b      	ldr	r3, [r7, #0]
    3bee:	4630      	mov	r0, r6
    3bf0:	f000 f9c4 	bl	3f7c <bootutil_img_validate>
        tmpbuf, BOOT_TMPBUF_SZ)) {
        return BOOT_EBADIMAGE;
    3bf4:	2800      	cmp	r0, #0
    3bf6:	bf14      	ite	ne
    3bf8:	2003      	movne	r0, #3
    3bfa:	2000      	moveq	r0, #0
    3bfc:	e007      	b.n	3c0e <boot_image_check+0x3a>
boot_image_check(struct image_header *hdr, struct boot_image_location *loc)
{
    static void *tmpbuf;

    if (!tmpbuf) {
        tmpbuf = malloc(BOOT_TMPBUF_SZ);
    3bfe:	f44f 7080 	mov.w	r0, #256	; 0x100
    3c02:	f001 f86f 	bl	4ce4 <os_malloc>
    3c06:	6020      	str	r0, [r4, #0]
        if (!tmpbuf) {
    3c08:	2800      	cmp	r0, #0
    3c0a:	d1ea      	bne.n	3be2 <boot_image_check+0xe>
            return BOOT_ENOMEM;
    3c0c:	2006      	movs	r0, #6
    if (bootutil_img_validate(hdr, loc->bil_flash_id, loc->bil_address,
        tmpbuf, BOOT_TMPBUF_SZ)) {
        return BOOT_EBADIMAGE;
    }
    return 0;
}
    3c0e:	b003      	add	sp, #12
    3c10:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c12:	bf00      	nop
    3c14:	20000618 	.word	0x20000618

00003c18 <boot_erase_area>:
}


static int
boot_erase_area(int area_idx, uint32_t sz)
{
    3c18:	b508      	push	{r3, lr}
    const struct flash_area *area_desc;
    int rc;

    area_desc = boot_req->br_area_descs + area_idx;
    3c1a:	4b07      	ldr	r3, [pc, #28]	; (3c38 <boot_erase_area+0x20>)
}


static int
boot_erase_area(int area_idx, uint32_t sz)
{
    3c1c:	460a      	mov	r2, r1
    const struct flash_area *area_desc;
    int rc;

    area_desc = boot_req->br_area_descs + area_idx;
    3c1e:	6819      	ldr	r1, [r3, #0]
    3c20:	230c      	movs	r3, #12
    3c22:	4358      	muls	r0, r3
    3c24:	680b      	ldr	r3, [r1, #0]
    3c26:	1819      	adds	r1, r3, r0
    rc = hal_flash_erase(area_desc->fa_flash_id, area_desc->fa_off, sz);
    3c28:	5c18      	ldrb	r0, [r3, r0]
    3c2a:	6849      	ldr	r1, [r1, #4]
    3c2c:	f7ff fd96 	bl	375c <hal_flash_erase>
    if (rc != 0) {
        return BOOT_EFLASH;
    }
    return 0;
}
    3c30:	3000      	adds	r0, #0
    3c32:	bf18      	it	ne
    3c34:	2001      	movne	r0, #1
    3c36:	bd08      	pop	{r3, pc}
    3c38:	20000628 	.word	0x20000628

00003c3c <boot_copy_area>:
    int chunk_sz;
    int rc;

    static uint8_t buf[1024];

    from_area_desc = boot_req->br_area_descs + from_area_idx;
    3c3c:	4b19      	ldr	r3, [pc, #100]	; (3ca4 <boot_copy_area+0x68>)
    3c3e:	681b      	ldr	r3, [r3, #0]
    3c40:	681b      	ldr	r3, [r3, #0]
 *
 * @return                      0 on success; nonzero on failure.
 */
static int
boot_copy_area(int from_area_idx, int to_area_idx, uint32_t sz)
{
    3c42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int chunk_sz;
    int rc;

    static uint8_t buf[1024];

    from_area_desc = boot_req->br_area_descs + from_area_idx;
    3c46:	250c      	movs	r5, #12
    3c48:	fb05 3700 	mla	r7, r5, r0, r3
    to_area_desc = boot_req->br_area_descs + to_area_idx;
    3c4c:	fb05 3501 	mla	r5, r5, r1, r3
 *
 * @return                      0 on success; nonzero on failure.
 */
static int
boot_copy_area(int from_area_idx, int to_area_idx, uint32_t sz)
{
    3c50:	4690      	mov	r8, r2
    static uint8_t buf[1024];

    from_area_desc = boot_req->br_area_descs + from_area_idx;
    to_area_desc = boot_req->br_area_descs + to_area_idx;

    assert(to_area_desc->fa_size >= from_area_desc->fa_size);
    3c52:	68bb      	ldr	r3, [r7, #8]
    3c54:	68aa      	ldr	r2, [r5, #8]
    3c56:	429a      	cmp	r2, r3
    3c58:	d205      	bcs.n	3c66 <boot_copy_area+0x2a>
    3c5a:	2200      	movs	r2, #0
    3c5c:	4812      	ldr	r0, [pc, #72]	; (3ca8 <boot_copy_area+0x6c>)
    3c5e:	21dc      	movs	r1, #220	; 0xdc
    3c60:	4613      	mov	r3, r2
    3c62:	f000 fff3 	bl	4c4c <__assert_func>
    3c66:	2400      	movs	r4, #0

    off = 0;
    while (off < sz) {
    3c68:	4544      	cmp	r4, r8
    3c6a:	d218      	bcs.n	3c9e <boot_copy_area+0x62>
        if (sz - off > sizeof buf) {
    3c6c:	ebc4 0608 	rsb	r6, r4, r8
            chunk_sz = sizeof buf;
        } else {
            chunk_sz = sz - off;
    3c70:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
        }

        from_addr = from_area_desc->fa_off + off;
    3c74:	6879      	ldr	r1, [r7, #4]
        rc = hal_flash_read(from_area_desc->fa_flash_id, from_addr, buf,
    3c76:	7838      	ldrb	r0, [r7, #0]
    3c78:	4a0c      	ldr	r2, [pc, #48]	; (3cac <boot_copy_area+0x70>)
    off = 0;
    while (off < sz) {
        if (sz - off > sizeof buf) {
            chunk_sz = sizeof buf;
        } else {
            chunk_sz = sz - off;
    3c7a:	bf28      	it	cs
    3c7c:	f44f 6680 	movcs.w	r6, #1024	; 0x400
        }

        from_addr = from_area_desc->fa_off + off;
        rc = hal_flash_read(from_area_desc->fa_flash_id, from_addr, buf,
    3c80:	4421      	add	r1, r4
    3c82:	4633      	mov	r3, r6
    3c84:	f7ff fd2e 	bl	36e4 <hal_flash_read>
                            chunk_sz);
        if (rc != 0) {
    3c88:	b950      	cbnz	r0, 3ca0 <boot_copy_area+0x64>
            return rc;
        }

        to_addr = to_area_desc->fa_off + off;
    3c8a:	6869      	ldr	r1, [r5, #4]
        rc = hal_flash_write(to_area_desc->fa_flash_id, to_addr, buf,
    3c8c:	7828      	ldrb	r0, [r5, #0]
    3c8e:	4a07      	ldr	r2, [pc, #28]	; (3cac <boot_copy_area+0x70>)
    3c90:	4421      	add	r1, r4
    3c92:	4633      	mov	r3, r6
    3c94:	f7ff fd44 	bl	3720 <hal_flash_write>
                             chunk_sz);
        if (rc != 0) {
    3c98:	b910      	cbnz	r0, 3ca0 <boot_copy_area+0x64>
            return rc;
        }

        off += chunk_sz;
    3c9a:	4434      	add	r4, r6
    3c9c:	e7e4      	b.n	3c68 <boot_copy_area+0x2c>
    }

    return 0;
    3c9e:	2000      	movs	r0, #0
}
    3ca0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3ca4:	20000628 	.word	0x20000628
    3ca8:	00006358 	.word	0x00006358
    3cac:	2000062c 	.word	0x2000062c

00003cb0 <boot_copy_image>:
 *
 * @return                      0 on success; nonzero on failure.
 */
static int
boot_copy_image(void)
{
    3cb0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    int cnt;
    int rc;
    int state_idx;

    state_idx = BOOT_PERSIST_IDX(boot_state.state);
    3cb4:	4f54      	ldr	r7, [pc, #336]	; (3e08 <boot_copy_image+0x158>)
    3cb6:	687b      	ldr	r3, [r7, #4]
    for (off = 0, i = 0; off < boot_state.length; off += sz, i += cnt) {
    3cb8:	2400      	movs	r4, #0
    int i;
    int cnt;
    int rc;
    int state_idx;

    state_idx = BOOT_PERSIST_IDX(boot_state.state);
    3cba:	0a1b      	lsrs	r3, r3, #8
    3cbc:	9301      	str	r3, [sp, #4]
    for (off = 0, i = 0; off < boot_state.length; off += sz, i += cnt) {
    3cbe:	46a2      	mov	sl, r4
    3cc0:	683b      	ldr	r3, [r7, #0]
    3cc2:	459a      	cmp	sl, r3
    3cc4:	f080 809b 	bcs.w	3dfe <boot_copy_image+0x14e>
        sz = boot_copy_sz(i, boot_req->br_slot_areas[1], &cnt);
    3cc8:	f8df b144 	ldr.w	fp, [pc, #324]	; 3e10 <boot_copy_image+0x160>
{
    int i;
    uint32_t sz;
    static uint32_t scratch_sz = 0;

    if (!scratch_sz) {
    3ccc:	f8df c144 	ldr.w	ip, [pc, #324]	; 3e14 <boot_copy_image+0x164>
    int rc;
    int state_idx;

    state_idx = BOOT_PERSIST_IDX(boot_state.state);
    for (off = 0, i = 0; off < boot_state.length; off += sz, i += cnt) {
        sz = boot_copy_sz(i, boot_req->br_slot_areas[1], &cnt);
    3cd0:	f8db 3000 	ldr.w	r3, [fp]
{
    int i;
    uint32_t sz;
    static uint32_t scratch_sz = 0;

    if (!scratch_sz) {
    3cd4:	f8dc 5000 	ldr.w	r5, [ip]
    int rc;
    int state_idx;

    state_idx = BOOT_PERSIST_IDX(boot_state.state);
    for (off = 0, i = 0; off < boot_state.length; off += sz, i += cnt) {
        sz = boot_copy_sz(i, boot_req->br_slot_areas[1], &cnt);
    3cd8:	f8d3 e004 	ldr.w	lr, [r3, #4]
    3cdc:	f89e 6001 	ldrb.w	r6, [lr, #1]
{
    int i;
    uint32_t sz;
    static uint32_t scratch_sz = 0;

    if (!scratch_sz) {
    3ce0:	b12d      	cbz	r5, 3cee <boot_copy_image+0x3e>
        }
    }
    sz = 0;
    *cnt = 0;
    for (i = idx; i < max_idx; i++) {
        if (sz + boot_req->br_area_descs[i].fa_size > scratch_sz) {
    3ce2:	f04f 0900 	mov.w	r9, #0
    3ce6:	f8dc 0000 	ldr.w	r0, [ip]
    3cea:	464d      	mov	r5, r9
    3cec:	e01d      	b.n	3d2a <boot_copy_image+0x7a>
    int i;
    uint32_t sz;
    static uint32_t scratch_sz = 0;

    if (!scratch_sz) {
        for (i = boot_req->br_scratch_area_idx;
    3cee:	7a5a      	ldrb	r2, [r3, #9]
             i < boot_req->br_num_image_areas;
    3cf0:	f893 8008 	ldrb.w	r8, [r3, #8]
    3cf4:	eb02 0142 	add.w	r1, r2, r2, lsl #1
    3cf8:	0089      	lsls	r1, r1, #2
    int i;
    uint32_t sz;
    static uint32_t scratch_sz = 0;

    if (!scratch_sz) {
        for (i = boot_req->br_scratch_area_idx;
    3cfa:	4542      	cmp	r2, r8
    3cfc:	da06      	bge.n	3d0c <boot_copy_image+0x5c>
             i < boot_req->br_num_image_areas;
             i++) {
            scratch_sz += boot_req->br_area_descs[i].fa_size;
    3cfe:	6818      	ldr	r0, [r3, #0]
    3d00:	4408      	add	r0, r1
    static uint32_t scratch_sz = 0;

    if (!scratch_sz) {
        for (i = boot_req->br_scratch_area_idx;
             i < boot_req->br_num_image_areas;
             i++) {
    3d02:	3201      	adds	r2, #1
            scratch_sz += boot_req->br_area_descs[i].fa_size;
    3d04:	6880      	ldr	r0, [r0, #8]
    3d06:	310c      	adds	r1, #12
    3d08:	4405      	add	r5, r0
    3d0a:	e7f6      	b.n	3cfa <boot_copy_image+0x4a>
    3d0c:	f8cc 5000 	str.w	r5, [ip]
    3d10:	e7e7      	b.n	3ce2 <boot_copy_image+0x32>
        }
    }
    sz = 0;
    *cnt = 0;
    for (i = idx; i < max_idx; i++) {
        if (sz + boot_req->br_area_descs[i].fa_size > scratch_sz) {
    3d12:	681a      	ldr	r2, [r3, #0]
    3d14:	f04f 0c0c 	mov.w	ip, #12
    3d18:	fb0c 2201 	mla	r2, ip, r1, r2
    3d1c:	6892      	ldr	r2, [r2, #8]
    3d1e:	442a      	add	r2, r5
    3d20:	4282      	cmp	r2, r0
    3d22:	d806      	bhi.n	3d32 <boot_copy_image+0x82>
            break;
        }
        sz += boot_req->br_area_descs[i].fa_size;
        *cnt = *cnt + 1;
    3d24:	f109 0901 	add.w	r9, r9, #1
    3d28:	4615      	mov	r5, r2
    3d2a:	eb09 0104 	add.w	r1, r9, r4
            scratch_sz += boot_req->br_area_descs[i].fa_size;
        }
    }
    sz = 0;
    *cnt = 0;
    for (i = idx; i < max_idx; i++) {
    3d2e:	42b1      	cmp	r1, r6
    3d30:	dbef      	blt.n	3d12 <boot_copy_image+0x62>
    int state_idx;

    state_idx = BOOT_PERSIST_IDX(boot_state.state);
    for (off = 0, i = 0; off < boot_state.length; off += sz, i += cnt) {
        sz = boot_copy_sz(i, boot_req->br_slot_areas[1], &cnt);
        if (i >= state_idx) {
    3d32:	9a01      	ldr	r2, [sp, #4]
    3d34:	4294      	cmp	r4, r2
    3d36:	db5b      	blt.n	3df0 <boot_copy_image+0x140>
    int area_idx_1;
    int area_idx_2;
    int rc;
    int state;

    area_idx_1 = boot_req->br_slot_areas[0] + idx;
    3d38:	f89e 8000 	ldrb.w	r8, [lr]
    area_idx_2 = boot_req->br_slot_areas[1] + idx;
    3d3c:	4426      	add	r6, r4
    int area_idx_1;
    int area_idx_2;
    int rc;
    int state;

    area_idx_1 = boot_req->br_slot_areas[0] + idx;
    3d3e:	44a0      	add	r8, r4
    area_idx_2 = boot_req->br_slot_areas[1] + idx;
    assert(area_idx_1 != area_idx_2);
    3d40:	45b0      	cmp	r8, r6
    3d42:	d103      	bne.n	3d4c <boot_copy_image+0x9c>
    3d44:	4831      	ldr	r0, [pc, #196]	; (3e0c <boot_copy_image+0x15c>)
    3d46:	f44f 7187 	mov.w	r1, #270	; 0x10e
    3d4a:	e005      	b.n	3d58 <boot_copy_image+0xa8>
    assert(area_idx_1 != boot_req->br_scratch_area_idx);
    3d4c:	7a58      	ldrb	r0, [r3, #9]
    3d4e:	4580      	cmp	r8, r0
    3d50:	d106      	bne.n	3d60 <boot_copy_image+0xb0>
    3d52:	482e      	ldr	r0, [pc, #184]	; (3e0c <boot_copy_image+0x15c>)
    3d54:	f240 110f 	movw	r1, #271	; 0x10f
    3d58:	2200      	movs	r2, #0
    3d5a:	4613      	mov	r3, r2
    3d5c:	f000 ff76 	bl	4c4c <__assert_func>
    assert(area_idx_2 != boot_req->br_scratch_area_idx);
    3d60:	4286      	cmp	r6, r0
    3d62:	d103      	bne.n	3d6c <boot_copy_image+0xbc>
    3d64:	4829      	ldr	r0, [pc, #164]	; (3e0c <boot_copy_image+0x15c>)
    3d66:	f44f 7188 	mov.w	r1, #272	; 0x110
    3d6a:	e7f5      	b.n	3d58 <boot_copy_image+0xa8>

    state = BOOT_PERSIST_ST(boot_state.state);
    3d6c:	793b      	ldrb	r3, [r7, #4]
    if (state == 0) {
    3d6e:	b9ab      	cbnz	r3, 3d9c <boot_copy_image+0xec>
        rc = boot_erase_area(boot_req->br_scratch_area_idx, sz);
    3d70:	4629      	mov	r1, r5
    3d72:	f7ff ff51 	bl	3c18 <boot_erase_area>
        if (rc != 0) {
    3d76:	2800      	cmp	r0, #0
    3d78:	d13d      	bne.n	3df6 <boot_copy_image+0x146>
            return rc;
        }

        rc = boot_copy_area(area_idx_2, boot_req->br_scratch_area_idx, sz);
    3d7a:	f8db 3000 	ldr.w	r3, [fp]
    3d7e:	4630      	mov	r0, r6
    3d80:	7a59      	ldrb	r1, [r3, #9]
    3d82:	462a      	mov	r2, r5
    3d84:	f7ff ff5a 	bl	3c3c <boot_copy_area>
        if (rc != 0) {
    3d88:	bba8      	cbnz	r0, 3df6 <boot_copy_image+0x146>
            return rc;
        }

        boot_state.state = BOOT_PERSIST(idx, 1);
    3d8a:	4a1f      	ldr	r2, [pc, #124]	; (3e08 <boot_copy_image+0x158>)
    3d8c:	0223      	lsls	r3, r4, #8
    3d8e:	f043 0301 	orr.w	r3, r3, #1
        (void)boot_write_status(&boot_state);
    3d92:	4610      	mov	r0, r2
        rc = boot_copy_area(area_idx_2, boot_req->br_scratch_area_idx, sz);
        if (rc != 0) {
            return rc;
        }

        boot_state.state = BOOT_PERSIST(idx, 1);
    3d94:	6053      	str	r3, [r2, #4]
        (void)boot_write_status(&boot_state);
    3d96:	f7ff fef1 	bl	3b7c <boot_write_status>
    3d9a:	e001      	b.n	3da0 <boot_copy_image+0xf0>
        state = 1;
    }
    if (state == 1) {
    3d9c:	2b01      	cmp	r3, #1
    3d9e:	d112      	bne.n	3dc6 <boot_copy_image+0x116>
        rc = boot_erase_area(area_idx_2, sz);
    3da0:	4630      	mov	r0, r6
    3da2:	4629      	mov	r1, r5
    3da4:	f7ff ff38 	bl	3c18 <boot_erase_area>
        if (rc != 0) {
    3da8:	bb28      	cbnz	r0, 3df6 <boot_copy_image+0x146>
            return rc;
        }

        rc = boot_copy_area(area_idx_1, area_idx_2, sz);
    3daa:	4640      	mov	r0, r8
    3dac:	4631      	mov	r1, r6
    3dae:	462a      	mov	r2, r5
    3db0:	f7ff ff44 	bl	3c3c <boot_copy_area>
        if (rc != 0) {
    3db4:	b9f8      	cbnz	r0, 3df6 <boot_copy_image+0x146>
            return rc;
        }

        boot_state.state = BOOT_PERSIST(idx, 2);
    3db6:	0223      	lsls	r3, r4, #8
    3db8:	f043 0302 	orr.w	r3, r3, #2
        (void)boot_write_status(&boot_state);
    3dbc:	4812      	ldr	r0, [pc, #72]	; (3e08 <boot_copy_image+0x158>)
        rc = boot_copy_area(area_idx_1, area_idx_2, sz);
        if (rc != 0) {
            return rc;
        }

        boot_state.state = BOOT_PERSIST(idx, 2);
    3dbe:	607b      	str	r3, [r7, #4]
        (void)boot_write_status(&boot_state);
    3dc0:	f7ff fedc 	bl	3b7c <boot_write_status>
    3dc4:	e001      	b.n	3dca <boot_copy_image+0x11a>
        state = 2;
    }
    if (state == 2) {
    3dc6:	2b02      	cmp	r3, #2
    3dc8:	d112      	bne.n	3df0 <boot_copy_image+0x140>
        rc = boot_erase_area(area_idx_1, sz);
    3dca:	4640      	mov	r0, r8
    3dcc:	4629      	mov	r1, r5
    3dce:	f7ff ff23 	bl	3c18 <boot_erase_area>
        if (rc != 0) {
    3dd2:	b980      	cbnz	r0, 3df6 <boot_copy_image+0x146>
            return rc;
        }

        rc = boot_copy_area(boot_req->br_scratch_area_idx, area_idx_1, sz);
    3dd4:	f8db 3000 	ldr.w	r3, [fp]
    3dd8:	4641      	mov	r1, r8
    3dda:	7a58      	ldrb	r0, [r3, #9]
    3ddc:	462a      	mov	r2, r5
    3dde:	f7ff ff2d 	bl	3c3c <boot_copy_area>
        if (rc != 0) {
    3de2:	b940      	cbnz	r0, 3df6 <boot_copy_image+0x146>
            return rc;
        }

        boot_state.state = BOOT_PERSIST(idx + 1, 0);
    3de4:	1c63      	adds	r3, r4, #1
    3de6:	021b      	lsls	r3, r3, #8
        (void)boot_write_status(&boot_state);
    3de8:	4807      	ldr	r0, [pc, #28]	; (3e08 <boot_copy_image+0x158>)
        rc = boot_copy_area(boot_req->br_scratch_area_idx, area_idx_1, sz);
        if (rc != 0) {
            return rc;
        }

        boot_state.state = BOOT_PERSIST(idx + 1, 0);
    3dea:	607b      	str	r3, [r7, #4]
        (void)boot_write_status(&boot_state);
    3dec:	f7ff fec6 	bl	3b7c <boot_write_status>
    int cnt;
    int rc;
    int state_idx;

    state_idx = BOOT_PERSIST_IDX(boot_state.state);
    for (off = 0, i = 0; off < boot_state.length; off += sz, i += cnt) {
    3df0:	44aa      	add	sl, r5
    3df2:	444c      	add	r4, r9
    3df4:	e764      	b.n	3cc0 <boot_copy_image+0x10>
        sz = boot_copy_sz(i, boot_req->br_slot_areas[1], &cnt);
        if (i >= state_idx) {
            rc = boot_swap_areas(i, sz);
            assert(rc == 0);
    3df6:	4805      	ldr	r0, [pc, #20]	; (3e0c <boot_copy_image+0x15c>)
    3df8:	f240 115b 	movw	r1, #347	; 0x15b
    3dfc:	e7ac      	b.n	3d58 <boot_copy_image+0xa8>
        }
    }

    return 0;
}
    3dfe:	2000      	movs	r0, #0
    3e00:	b003      	add	sp, #12
    3e02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3e06:	bf00      	nop
    3e08:	20000620 	.word	0x20000620
    3e0c:	00006358 	.word	0x00006358
    3e10:	20000628 	.word	0x20000628
    3e14:	2000061c 	.word	0x2000061c

00003e18 <boot_go>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
boot_go(const struct boot_req *req, struct boot_rsp *rsp)
{
    3e18:	b5f0      	push	{r4, r5, r6, r7, lr}
    int i;

    /* Set the global boot request object.  The remainder of the boot process
     * will reference the global.
     */
    boot_req = req;
    3e1a:	4c52      	ldr	r4, [pc, #328]	; (3f64 <boot_go+0x14c>)
 *
 * @return                      0 on success; nonzero on failure.
 */
int
boot_go(const struct boot_req *req, struct boot_rsp *rsp)
{
    3e1c:	b087      	sub	sp, #28
    int i;

    /* Set the global boot request object.  The remainder of the boot process
     * will reference the global.
     */
    boot_req = req;
    3e1e:	6020      	str	r0, [r4, #0]

    /* Read the boot status to determine if an image copy operation was
     * interrupted (i.e., the system was reset before the boot loader could
     * finish its task last time).
     */
    if (boot_read_status(&boot_state)) {
    3e20:	4851      	ldr	r0, [pc, #324]	; (3f68 <boot_go+0x150>)
 *
 * @return                      0 on success; nonzero on failure.
 */
int
boot_go(const struct boot_req *req, struct boot_rsp *rsp)
{
    3e22:	460e      	mov	r6, r1

    /* Read the boot status to determine if an image copy operation was
     * interrupted (i.e., the system was reset before the boot loader could
     * finish its task last time).
     */
    if (boot_read_status(&boot_state)) {
    3e24:	f7ff fe8e 	bl	3b44 <boot_read_status>
    3e28:	bb20      	cbnz	r0, 3e74 <boot_go+0x5c>
    const struct flash_area *area_desc;
    uint8_t area_idx;

    assert(slot_num >= 0 && slot_num < BOOT_NUM_SLOTS);

    area_idx = boot_req->br_slot_areas[slot_num];
    3e2a:	6822      	ldr	r2, [r4, #0]
        boot_slot_addr(i, &image_addrs[i].bil_flash_id,
                       &image_addrs[i].bil_address);
    }

    /* Attempt to read an image header from each slot. */
    boot_read_image_headers(boot_img_hdrs, image_addrs, BOOT_NUM_SLOTS);
    3e2c:	4d4f      	ldr	r5, [pc, #316]	; (3f6c <boot_go+0x154>)
    const struct flash_area *area_desc;
    uint8_t area_idx;

    assert(slot_num >= 0 && slot_num < BOOT_NUM_SLOTS);

    area_idx = boot_req->br_slot_areas[slot_num];
    3e2e:	6851      	ldr	r1, [r2, #4]
    area_desc = boot_req->br_area_descs + area_idx;
    3e30:	6810      	ldr	r0, [r2, #0]
    3e32:	780b      	ldrb	r3, [r1, #0]
    3e34:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    3e38:	009b      	lsls	r3, r3, #2
    3e3a:	18c4      	adds	r4, r0, r3
    *flash_id = area_desc->fa_flash_id;
    3e3c:	5cc3      	ldrb	r3, [r0, r3]
    3e3e:	f88d 3008 	strb.w	r3, [sp, #8]
    *address = area_desc->fa_off;
    3e42:	6863      	ldr	r3, [r4, #4]
    3e44:	9303      	str	r3, [sp, #12]
    uint8_t area_idx;

    assert(slot_num >= 0 && slot_num < BOOT_NUM_SLOTS);

    area_idx = boot_req->br_slot_areas[slot_num];
    area_desc = boot_req->br_area_descs + area_idx;
    3e46:	784b      	ldrb	r3, [r1, #1]
    3e48:	6812      	ldr	r2, [r2, #0]
    3e4a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    3e4e:	009b      	lsls	r3, r3, #2
    3e50:	18d1      	adds	r1, r2, r3
    *flash_id = area_desc->fa_flash_id;
    3e52:	5cd3      	ldrb	r3, [r2, r3]
    3e54:	f88d 3010 	strb.w	r3, [sp, #16]
    *address = area_desc->fa_off;
    3e58:	684b      	ldr	r3, [r1, #4]
    3e5a:	9305      	str	r3, [sp, #20]
        boot_slot_addr(i, &image_addrs[i].bil_flash_id,
                       &image_addrs[i].bil_address);
    }

    /* Attempt to read an image header from each slot. */
    boot_read_image_headers(boot_img_hdrs, image_addrs, BOOT_NUM_SLOTS);
    3e5c:	2202      	movs	r2, #2
    3e5e:	4628      	mov	r0, r5
    3e60:	a902      	add	r1, sp, #8
    3e62:	f7ff fe49 	bl	3af8 <boot_read_image_headers>
boot_build_status(void)
{
    uint32_t len1;
    uint32_t len2;

    if (boot_img_hdrs[0].ih_magic == IMAGE_MAGIC) {
    3e66:	4b42      	ldr	r3, [pc, #264]	; (3f70 <boot_go+0x158>)
    3e68:	682a      	ldr	r2, [r5, #0]
    3e6a:	429a      	cmp	r2, r3
    3e6c:	461a      	mov	r2, r3
    3e6e:	d006      	beq.n	3e7e <boot_go+0x66>
        len1 = boot_img_hdrs[0].ih_hdr_size + boot_img_hdrs[0].ih_img_size +
          boot_img_hdrs[0].ih_tlv_size;
    } else {
        len1 = 0;
    3e70:	2300      	movs	r3, #0
    3e72:	e009      	b.n	3e88 <boot_go+0x70>
     * finish its task last time).
     */
    if (boot_read_status(&boot_state)) {
        /* We are resuming an interrupted image copy. */
        /* XXX if copy has not actually started yet, validate image */
        rc = boot_copy_image();
    3e74:	f7ff ff1c 	bl	3cb0 <boot_copy_image>
        if (rc != 0) {
    3e78:	2800      	cmp	r0, #0
    3e7a:	d0d6      	beq.n	3e2a <boot_go+0x12>
    3e7c:	e06f      	b.n	3f5e <boot_go+0x146>
{
    uint32_t len1;
    uint32_t len2;

    if (boot_img_hdrs[0].ih_magic == IMAGE_MAGIC) {
        len1 = boot_img_hdrs[0].ih_hdr_size + boot_img_hdrs[0].ih_img_size +
    3e7e:	88ab      	ldrh	r3, [r5, #4]
    3e80:	8929      	ldrh	r1, [r5, #8]
    3e82:	4419      	add	r1, r3
    3e84:	68eb      	ldr	r3, [r5, #12]
    3e86:	440b      	add	r3, r1
          boot_img_hdrs[0].ih_tlv_size;
    } else {
        len1 = 0;
    }

    if (boot_img_hdrs[1].ih_magic == IMAGE_MAGIC) {
    3e88:	6a29      	ldr	r1, [r5, #32]
    3e8a:	4c38      	ldr	r4, [pc, #224]	; (3f6c <boot_go+0x154>)
    3e8c:	4291      	cmp	r1, r2
    3e8e:	4936      	ldr	r1, [pc, #216]	; (3f68 <boot_go+0x150>)
    3e90:	d106      	bne.n	3ea0 <boot_go+0x88>
        len2 = boot_img_hdrs[1].ih_hdr_size + boot_img_hdrs[1].ih_img_size +
    3e92:	88a2      	ldrh	r2, [r4, #4]
    3e94:	8d20      	ldrh	r0, [r4, #40]	; 0x28
    3e96:	4410      	add	r0, r2
    3e98:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    3e9a:	4402      	add	r2, r0
          boot_img_hdrs[0].ih_tlv_size;
    } else {
        len2 = 0;
    }
    boot_state.length = len1;
    if (len1 < len2) {
    3e9c:	4293      	cmp	r3, r2
    3e9e:	d301      	bcc.n	3ea4 <boot_go+0x8c>
        len2 = boot_img_hdrs[1].ih_hdr_size + boot_img_hdrs[1].ih_img_size +
          boot_img_hdrs[0].ih_tlv_size;
    } else {
        len2 = 0;
    }
    boot_state.length = len1;
    3ea0:	600b      	str	r3, [r1, #0]
    3ea2:	e000      	b.n	3ea6 <boot_go+0x8e>
    if (len1 < len2) {
        boot_state.length = len2;
    3ea4:	600a      	str	r2, [r1, #0]
    }
    boot_state.state = 0;
    3ea6:	2300      	movs	r3, #0
{
    struct image_version ver;
    int slot;
    int rc;

    rc = boot_vect_read_test(&ver);
    3ea8:	4668      	mov	r0, sp
    }
    boot_state.length = len1;
    if (len1 < len2) {
        boot_state.length = len2;
    }
    boot_state.state = 0;
    3eaa:	604b      	str	r3, [r1, #4]
{
    struct image_version ver;
    int slot;
    int rc;

    rc = boot_vect_read_test(&ver);
    3eac:	f7ff fdc0 	bl	3a30 <boot_vect_read_test>
    if (rc == 0) {
    3eb0:	4607      	mov	r7, r0
    3eb2:	b940      	cbnz	r0, 3ec6 <boot_go+0xae>
        slot = boot_find_image_slot(&ver);
    3eb4:	4668      	mov	r0, sp
    3eb6:	f7ff fe75 	bl	3ba4 <boot_find_image_slot>
        if (slot == -1) {
    3eba:	1c42      	adds	r2, r0, #1
    int slot;
    int rc;

    rc = boot_vect_read_test(&ver);
    if (rc == 0) {
        slot = boot_find_image_slot(&ver);
    3ebc:	4604      	mov	r4, r0
        if (slot == -1) {
    3ebe:	d11c      	bne.n	3efa <boot_go+0xe2>
            boot_vect_write_test(NULL);
    3ec0:	4638      	mov	r0, r7
    3ec2:	f7ff fdd5 	bl	3a70 <boot_vect_write_test>
        } else {
            return slot;
        }
    }

    rc = boot_vect_read_main(&ver);
    3ec6:	4668      	mov	r0, sp
    3ec8:	f7ff fdc2 	bl	3a50 <boot_vect_read_main>
    if (rc == 0) {
    3ecc:	4607      	mov	r7, r0
    3ece:	b940      	cbnz	r0, 3ee2 <boot_go+0xca>
        slot = boot_find_image_slot(&ver);
    3ed0:	4668      	mov	r0, sp
    3ed2:	f7ff fe67 	bl	3ba4 <boot_find_image_slot>
        if (slot == -1) {
    3ed6:	1c43      	adds	r3, r0, #1
        }
    }

    rc = boot_vect_read_main(&ver);
    if (rc == 0) {
        slot = boot_find_image_slot(&ver);
    3ed8:	4604      	mov	r4, r0
        if (slot == -1) {
    3eda:	d10e      	bne.n	3efa <boot_go+0xe2>
            boot_vect_write_main(NULL);
    3edc:	4638      	mov	r0, r7
    3ede:	f7ff fde9 	bl	3ab4 <boot_vect_write_main>
    slot = boot_select_image_slot();
    if (slot == -1) {
        /* Either there is no image vector, or none of the requested images are
         * present.  Just try booting from the first image slot.
         */
        if (boot_img_hdrs[0].ih_magic != IMAGE_MAGIC_NONE) {
    3ee2:	682b      	ldr	r3, [r5, #0]
    3ee4:	3301      	adds	r3, #1
    3ee6:	d105      	bne.n	3ef4 <boot_go+0xdc>
            slot = 0;
        } else if (boot_img_hdrs[1].ih_magic != IMAGE_MAGIC_NONE) {
    3ee8:	4b20      	ldr	r3, [pc, #128]	; (3f6c <boot_go+0x154>)
    3eea:	6a1b      	ldr	r3, [r3, #32]
    3eec:	3301      	adds	r3, #1
    3eee:	d103      	bne.n	3ef8 <boot_go+0xe0>
            slot = 1;
        } else {
            /* No images present. */
            return BOOT_EBADIMAGE;
    3ef0:	2003      	movs	r0, #3
    3ef2:	e034      	b.n	3f5e <boot_go+0x146>
    if (slot == -1) {
        /* Either there is no image vector, or none of the requested images are
         * present.  Just try booting from the first image slot.
         */
        if (boot_img_hdrs[0].ih_magic != IMAGE_MAGIC_NONE) {
            slot = 0;
    3ef4:	2400      	movs	r4, #0
    3ef6:	e000      	b.n	3efa <boot_go+0xe2>
        } else if (boot_img_hdrs[1].ih_magic != IMAGE_MAGIC_NONE) {
            slot = 1;
    3ef8:	2401      	movs	r4, #1
    }

    /*
     * If the selected image fails integrity check, try the other one.
     */
    if (boot_image_check(&boot_img_hdrs[slot], &image_addrs[slot])) {
    3efa:	ab02      	add	r3, sp, #8
    3efc:	eb05 1044 	add.w	r0, r5, r4, lsl #5
    3f00:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
    3f04:	f7ff fe66 	bl	3bd4 <boot_image_check>
    3f08:	b158      	cbz	r0, 3f22 <boot_go+0x10a>
        slot ^= 1;
        if (boot_image_check(&boot_img_hdrs[slot], &image_addrs[slot])) {
    3f0a:	4818      	ldr	r0, [pc, #96]	; (3f6c <boot_go+0x154>)

    /*
     * If the selected image fails integrity check, try the other one.
     */
    if (boot_image_check(&boot_img_hdrs[slot], &image_addrs[slot])) {
        slot ^= 1;
    3f0c:	f084 0401 	eor.w	r4, r4, #1
        if (boot_image_check(&boot_img_hdrs[slot], &image_addrs[slot])) {
    3f10:	ab02      	add	r3, sp, #8
    3f12:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    3f16:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
    3f1a:	f7ff fe5b 	bl	3bd4 <boot_image_check>
    3f1e:	2800      	cmp	r0, #0
    3f20:	d1e6      	bne.n	3ef0 <boot_go+0xd8>
            return BOOT_EBADIMAGE;
        }
    }
    switch (slot) {
    3f22:	b114      	cbz	r4, 3f2a <boot_go+0x112>
    3f24:	2c01      	cmp	r4, #1
    3f26:	d002      	beq.n	3f2e <boot_go+0x116>
    3f28:	e007      	b.n	3f3a <boot_go+0x122>
    case 0:
        rsp->br_hdr = &boot_img_hdrs[0];
    3f2a:	6035      	str	r5, [r6, #0]
        break;
    3f2c:	e00c      	b.n	3f48 <boot_go+0x130>

    case 1:
        /* The user wants to run the image in the secondary slot.  The contents
         * of this slot need to moved to the primary slot.
         */
        rc = boot_copy_image();
    3f2e:	f7ff febf 	bl	3cb0 <boot_copy_image>
        if (rc != 0) {
    3f32:	b9a0      	cbnz	r0, 3f5e <boot_go+0x146>
             * solution here.
             */
            return rc;
        }

        rsp->br_hdr = &boot_img_hdrs[1];
    3f34:	4b0f      	ldr	r3, [pc, #60]	; (3f74 <boot_go+0x15c>)
    3f36:	6033      	str	r3, [r6, #0]
        break;
    3f38:	e006      	b.n	3f48 <boot_go+0x130>

    default:
        assert(0);
    3f3a:	2200      	movs	r2, #0
    3f3c:	480e      	ldr	r0, [pc, #56]	; (3f78 <boot_go+0x160>)
    3f3e:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
    3f42:	4613      	mov	r3, r2
    3f44:	f000 fe82 	bl	4c4c <__assert_func>
        break;
    }

    /* Always boot from the primary slot. */
    rsp->br_flash_id = image_addrs[0].bil_flash_id;
    3f48:	f89d 3008 	ldrb.w	r3, [sp, #8]
    3f4c:	7133      	strb	r3, [r6, #4]
    rsp->br_image_addr = image_addrs[0].bil_address;
    3f4e:	9b03      	ldr	r3, [sp, #12]
    3f50:	60b3      	str	r3, [r6, #8]

    /* After successful boot, there should not be a status file. */
    boot_clear_status();
    3f52:	f7ff fe21 	bl	3b98 <boot_clear_status>

    /* If an image is being tested, it should only be booted into once. */
    boot_vect_write_test(NULL);
    3f56:	2000      	movs	r0, #0
    3f58:	f7ff fd8a 	bl	3a70 <boot_vect_write_test>

    return 0;
    3f5c:	2000      	movs	r0, #0
}
    3f5e:	b007      	add	sp, #28
    3f60:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3f62:	bf00      	nop
    3f64:	20000628 	.word	0x20000628
    3f68:	20000620 	.word	0x20000620
    3f6c:	20000cb0 	.word	0x20000cb0
    3f70:	96f3b83c 	.word	0x96f3b83c
    3f74:	20000cd0 	.word	0x20000cd0
    3f78:	00006358 	.word	0x00006358

00003f7c <bootutil_img_validate>:
 * Return non-zero if image could not be validated/does not validate.
 */
int
bootutil_img_validate(struct image_header *hdr, uint8_t flash_id, uint32_t addr,
  uint8_t *tmp_buf, uint32_t tmp_buf_sz)
{
    3f7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f80:	469b      	mov	fp, r3
#ifdef IMAGE_SIGNATURES_EC
    if ((hdr->ih_flags & IMAGE_F_ECDSA224_SHA256) == 0) {
        return -1;
    }
#endif
    if ((hdr->ih_flags & IMAGE_F_SHA256) == 0) {
    3f82:	6903      	ldr	r3, [r0, #16]
 * Return non-zero if image could not be validated/does not validate.
 */
int
bootutil_img_validate(struct image_header *hdr, uint8_t flash_id, uint32_t addr,
  uint8_t *tmp_buf, uint32_t tmp_buf_sz)
{
    3f84:	4692      	mov	sl, r2
#ifdef IMAGE_SIGNATURES_EC
    if ((hdr->ih_flags & IMAGE_F_ECDSA224_SHA256) == 0) {
        return -1;
    }
#endif
    if ((hdr->ih_flags & IMAGE_F_SHA256) == 0) {
    3f86:	079a      	lsls	r2, r3, #30
 * Return non-zero if image could not be validated/does not validate.
 */
int
bootutil_img_validate(struct image_header *hdr, uint8_t flash_id, uint32_t addr,
  uint8_t *tmp_buf, uint32_t tmp_buf_sz)
{
    3f88:	b0cb      	sub	sp, #300	; 0x12c
    3f8a:	4605      	mov	r5, r0
    3f8c:	4689      	mov	r9, r1
#ifdef IMAGE_SIGNATURES_EC
    if ((hdr->ih_flags & IMAGE_F_ECDSA224_SHA256) == 0) {
        return -1;
    }
#endif
    if ((hdr->ih_flags & IMAGE_F_SHA256) == 0) {
    3f8e:	d402      	bmi.n	3f96 <bootutil_img_validate+0x1a>
        return -1;
    3f90:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    3f94:	e060      	b.n	4058 <bootutil_img_validate+0xdc>
    uint32_t blk_sz;
    uint32_t size;
    uint32_t off;
    int rc;

    mbedtls_sha256_init(&sha256_ctx);
    3f96:	a80a      	add	r0, sp, #40	; 0x28
    3f98:	f000 f882 	bl	40a0 <mbedtls_sha256_init>
    mbedtls_sha256_starts(&sha256_ctx, 0);
    3f9c:	a80a      	add	r0, sp, #40	; 0x28
    3f9e:	2100      	movs	r1, #0
    3fa0:	f000 f882 	bl	40a8 <mbedtls_sha256_starts>

    /*
     * Hash is computed over image header and image itself. No TLV is
     * included ATM.
     */
    size = hdr->ih_img_size + hdr->ih_hdr_size;
    3fa4:	f8b5 8008 	ldrh.w	r8, [r5, #8]
    3fa8:	68eb      	ldr	r3, [r5, #12]
    for (off = 0; off < size; off += blk_sz) {
    3faa:	2600      	movs	r6, #0

    /*
     * Hash is computed over image header and image itself. No TLV is
     * included ATM.
     */
    size = hdr->ih_img_size + hdr->ih_hdr_size;
    3fac:	4498      	add	r8, r3
    for (off = 0; off < size; off += blk_sz) {
    3fae:	4546      	cmp	r6, r8
    3fb0:	d215      	bcs.n	3fde <bootutil_img_validate+0x62>
    3fb2:	9b54      	ldr	r3, [sp, #336]	; 0x150
        blk_sz = size - off;
    3fb4:	ebc6 0708 	rsb	r7, r6, r8
    3fb8:	429f      	cmp	r7, r3
    3fba:	bf28      	it	cs
    3fbc:	461f      	movcs	r7, r3
        if (blk_sz > tmp_buf_sz) {
            blk_sz = tmp_buf_sz;
        }
        rc = hal_flash_read(flash_id, addr + off, tmp_buf, blk_sz);
    3fbe:	4648      	mov	r0, r9
    3fc0:	eb06 010a 	add.w	r1, r6, sl
    3fc4:	465a      	mov	r2, fp
    3fc6:	463b      	mov	r3, r7
    3fc8:	f7ff fb8c 	bl	36e4 <hal_flash_read>
        if (rc) {
    3fcc:	2800      	cmp	r0, #0
    3fce:	d142      	bne.n	4056 <bootutil_img_validate+0xda>
            return rc;
        }
        mbedtls_sha256_update(&sha256_ctx, tmp_buf, blk_sz);
    3fd0:	a80a      	add	r0, sp, #40	; 0x28
    3fd2:	4659      	mov	r1, fp
    3fd4:	463a      	mov	r2, r7
    3fd6:	f000 fc5d 	bl	4894 <mbedtls_sha256_update>
    /*
     * Hash is computed over image header and image itself. No TLV is
     * included ATM.
     */
    size = hdr->ih_img_size + hdr->ih_hdr_size;
    for (off = 0; off < size; off += blk_sz) {
    3fda:	443e      	add	r6, r7
    3fdc:	e7e7      	b.n	3fae <bootutil_img_validate+0x32>
        if (rc) {
            return rc;
        }
        mbedtls_sha256_update(&sha256_ctx, tmp_buf, blk_sz);
    }
    mbedtls_sha256_finish(&sha256_ctx, hash_result);
    3fde:	a80a      	add	r0, sp, #40	; 0x28
    3fe0:	a902      	add	r1, sp, #8
    3fe2:	f000 fc5b 	bl	489c <mbedtls_sha256_finish>
    }

    /*
     * After image there's TLVs.
     */
    off = hdr->ih_img_size + hdr->ih_hdr_size;
    3fe6:	892e      	ldrh	r6, [r5, #8]
    3fe8:	68eb      	ldr	r3, [r5, #12]
    size = off + hdr->ih_tlv_size;
    3fea:	f8b5 8004 	ldrh.w	r8, [r5, #4]
        }
        mbedtls_sha256_update(&sha256_ctx, tmp_buf, blk_sz);
    }
    mbedtls_sha256_finish(&sha256_ctx, hash_result);

    return 0;
    3fee:	2400      	movs	r4, #0
    }

    /*
     * After image there's TLVs.
     */
    off = hdr->ih_img_size + hdr->ih_hdr_size;
    3ff0:	441e      	add	r6, r3
    size = off + hdr->ih_tlv_size;
    3ff2:	44b0      	add	r8, r6
bootutil_img_validate(struct image_header *hdr, uint8_t flash_id, uint32_t addr,
  uint8_t *tmp_buf, uint32_t tmp_buf_sz)
{
    uint32_t off;
    uint32_t size;
    uint32_t sha_off = 0;
    3ff4:	4627      	mov	r7, r4
     * After image there's TLVs.
     */
    off = hdr->ih_img_size + hdr->ih_hdr_size;
    size = off + hdr->ih_tlv_size;

    for (; off < size; off += sizeof(tlv) + tlv.it_len) {
    3ff6:	4546      	cmp	r6, r8
    3ff8:	d217      	bcs.n	402a <bootutil_img_validate+0xae>
        rc = hal_flash_read(flash_id, addr + off, &tlv, sizeof(tlv));
    3ffa:	eb06 0b0a 	add.w	fp, r6, sl
    3ffe:	4648      	mov	r0, r9
    4000:	4659      	mov	r1, fp
    4002:	aa01      	add	r2, sp, #4
    4004:	2304      	movs	r3, #4
    4006:	f7ff fb6d 	bl	36e4 <hal_flash_read>
        if (rc) {
    400a:	bb20      	cbnz	r0, 4056 <bootutil_img_validate+0xda>
            return rc;
        }
        if (tlv.it_type == IMAGE_TLV_SHA256) {
    400c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    4010:	2b01      	cmp	r3, #1
    4012:	d105      	bne.n	4020 <bootutil_img_validate+0xa4>
            if (tlv.it_len != sizeof(hash)) {
    4014:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    4018:	2b20      	cmp	r3, #32
    401a:	d1b9      	bne.n	3f90 <bootutil_img_validate+0x14>
                return -1;
            }
            sha_off = addr + off + sizeof(tlv);
    401c:	f10b 0704 	add.w	r7, fp, #4
     * After image there's TLVs.
     */
    off = hdr->ih_img_size + hdr->ih_hdr_size;
    size = off + hdr->ih_tlv_size;

    for (; off < size; off += sizeof(tlv) + tlv.it_len) {
    4020:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    4024:	3304      	adds	r3, #4
    4026:	441e      	add	r6, r3
    4028:	e7e5      	b.n	3ff6 <bootutil_img_validate+0x7a>
            sig_off = addr + off + sizeof(tlv);
            sig_len = tlv.it_len;
        }
#endif
    }
    if (hdr->ih_flags & IMAGE_F_SHA256) {
    402a:	692b      	ldr	r3, [r5, #16]
    402c:	079b      	lsls	r3, r3, #30
    402e:	d513      	bpl.n	4058 <bootutil_img_validate+0xdc>
        if (!sha_off) {
    4030:	2f00      	cmp	r7, #0
    4032:	d0ad      	beq.n	3f90 <bootutil_img_validate+0x14>
            /*
             * Header said there should be hash TLV, no TLV found.
             */
            return -1;
        }
        rc = hal_flash_read(flash_id, sha_off, buf, sizeof(hash));
    4034:	4648      	mov	r0, r9
    4036:	4639      	mov	r1, r7
    4038:	aa0a      	add	r2, sp, #40	; 0x28
    403a:	2320      	movs	r3, #32
    403c:	f7ff fb52 	bl	36e4 <hal_flash_read>
        if (rc) {
    4040:	b948      	cbnz	r0, 4056 <bootutil_img_validate+0xda>
            return rc;
        }
        if (memcmp(hash, buf, sizeof(hash))) {
    4042:	a802      	add	r0, sp, #8
    4044:	a90a      	add	r1, sp, #40	; 0x28
    4046:	2220      	movs	r2, #32
    4048:	f001 ff36 	bl	5eb8 <memcmp>
    404c:	3000      	adds	r0, #0
    404e:	bf18      	it	ne
    4050:	2001      	movne	r0, #1
    4052:	4244      	negs	r4, r0
    4054:	e000      	b.n	4058 <bootutil_img_validate+0xdc>
    4056:	4604      	mov	r4, r0
    if (rc) {
        return -1;
    }
#endif
    return 0;
}
    4058:	4620      	mov	r0, r4
    405a:	b04b      	add	sp, #300	; 0x12c
    405c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004060 <NVIC_Relocate>:
     * designated in the linker script.
     */
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
    4060:	4a07      	ldr	r2, [pc, #28]	; (4080 <NVIC_Relocate+0x20>)
    4062:	4b08      	ldr	r3, [pc, #32]	; (4084 <NVIC_Relocate+0x24>)
    4064:	4293      	cmp	r3, r2
    4066:	4611      	mov	r1, r2
    4068:	d102      	bne.n	4070 <NVIC_Relocate+0x10>
    }

    /* Set VTOR except for M0 */
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
#else
    SCB->VTOR = (uint32_t)&__vector_tbl_reloc__;
    406a:	4a07      	ldr	r2, [pc, #28]	; (4088 <NVIC_Relocate+0x28>)
    406c:	6093      	str	r3, [r2, #8]
    406e:	4770      	bx	lr
    4070:	2200      	movs	r2, #0
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
            new_location[i] = current_location[i];
    4072:	5888      	ldr	r0, [r1, r2]
    4074:	5098      	str	r0, [r3, r2]
    4076:	3204      	adds	r2, #4
     */
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
    4078:	2ad8      	cmp	r2, #216	; 0xd8
    407a:	d1fa      	bne.n	4072 <NVIC_Relocate+0x12>
    407c:	e7f5      	b.n	406a <NVIC_Relocate+0xa>
    407e:	bf00      	nop
    4080:	00000000 	.word	0x00000000
    4084:	20000000 	.word	0x20000000
    4088:	e000ed00 	.word	0xe000ed00

0000408c <NVIC_SetVector>:
{
    uint32_t *vectors;
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
    vectors = (uint32_t *)&__vector_tbl_reloc__;
#else
    vectors = (uint32_t *)SCB->VTOR;
    408c:	4b03      	ldr	r3, [pc, #12]	; (409c <NVIC_SetVector+0x10>)
#endif
    vectors[IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    408e:	3010      	adds	r0, #16
{
    uint32_t *vectors;
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
    vectors = (uint32_t *)&__vector_tbl_reloc__;
#else
    vectors = (uint32_t *)SCB->VTOR;
    4090:	689b      	ldr	r3, [r3, #8]
#endif
    vectors[IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    4092:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    4096:	f3bf 8f5f 	dmb	sy
    409a:	4770      	bx	lr
    409c:	e000ed00 	.word	0xe000ed00

000040a0 <mbedtls_sha256_init>:
} while( 0 )
#endif

void mbedtls_sha256_init( mbedtls_sha256_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_sha256_context ) );
    40a0:	2100      	movs	r1, #0
    40a2:	226c      	movs	r2, #108	; 0x6c
    40a4:	f7ff bc5e 	b.w	3964 <memset>

000040a8 <mbedtls_sha256_starts>:
/*
 * SHA-256 context setup
 */
void mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 )
{
    ctx->total[0] = 0;
    40a8:	2300      	movs	r3, #0
    40aa:	6003      	str	r3, [r0, #0]
    ctx->total[1] = 0;
    40ac:	6043      	str	r3, [r0, #4]

    if( is224 == 0 )
    40ae:	b9a1      	cbnz	r1, 40da <mbedtls_sha256_starts+0x32>
    {
        /* SHA-256 */
        ctx->state[0] = 0x6A09E667;
    40b0:	4b18      	ldr	r3, [pc, #96]	; (4114 <mbedtls_sha256_starts+0x6c>)
    40b2:	6083      	str	r3, [r0, #8]
        ctx->state[1] = 0xBB67AE85;
    40b4:	4b18      	ldr	r3, [pc, #96]	; (4118 <mbedtls_sha256_starts+0x70>)
    40b6:	60c3      	str	r3, [r0, #12]
        ctx->state[2] = 0x3C6EF372;
    40b8:	4b18      	ldr	r3, [pc, #96]	; (411c <mbedtls_sha256_starts+0x74>)
    40ba:	6103      	str	r3, [r0, #16]
        ctx->state[3] = 0xA54FF53A;
    40bc:	4b18      	ldr	r3, [pc, #96]	; (4120 <mbedtls_sha256_starts+0x78>)
    40be:	6143      	str	r3, [r0, #20]
        ctx->state[4] = 0x510E527F;
    40c0:	4b18      	ldr	r3, [pc, #96]	; (4124 <mbedtls_sha256_starts+0x7c>)
    40c2:	6183      	str	r3, [r0, #24]
        ctx->state[5] = 0x9B05688C;
    40c4:	4b18      	ldr	r3, [pc, #96]	; (4128 <mbedtls_sha256_starts+0x80>)
    40c6:	61c3      	str	r3, [r0, #28]
        ctx->state[6] = 0x1F83D9AB;
    40c8:	4b18      	ldr	r3, [pc, #96]	; (412c <mbedtls_sha256_starts+0x84>)
    40ca:	6203      	str	r3, [r0, #32]
        ctx->state[7] = 0x5BE0CD19;
    40cc:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
    40d0:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
    40d4:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
    40d8:	e018      	b.n	410c <mbedtls_sha256_starts+0x64>
    }
    else
    {
        /* SHA-224 */
        ctx->state[0] = 0xC1059ED8;
    40da:	4b15      	ldr	r3, [pc, #84]	; (4130 <mbedtls_sha256_starts+0x88>)
    40dc:	6083      	str	r3, [r0, #8]
        ctx->state[1] = 0x367CD507;
    40de:	4b15      	ldr	r3, [pc, #84]	; (4134 <mbedtls_sha256_starts+0x8c>)
    40e0:	60c3      	str	r3, [r0, #12]
        ctx->state[2] = 0x3070DD17;
    40e2:	f103 4379 	add.w	r3, r3, #4177526784	; 0xf9000000
    40e6:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
    40ea:	f503 6301 	add.w	r3, r3, #2064	; 0x810
    40ee:	6103      	str	r3, [r0, #16]
        ctx->state[3] = 0xF70E5939;
    40f0:	4b11      	ldr	r3, [pc, #68]	; (4138 <mbedtls_sha256_starts+0x90>)
    40f2:	6143      	str	r3, [r0, #20]
        ctx->state[4] = 0xFFC00B31;
    40f4:	4b11      	ldr	r3, [pc, #68]	; (413c <mbedtls_sha256_starts+0x94>)
    40f6:	6183      	str	r3, [r0, #24]
        ctx->state[5] = 0x68581511;
    40f8:	f103 43d1 	add.w	r3, r3, #1753219072	; 0x68800000
    40fc:	f503 13c0 	add.w	r3, r3, #1572864	; 0x180000
    4100:	f503 631e 	add.w	r3, r3, #2528	; 0x9e0
    4104:	61c3      	str	r3, [r0, #28]
        ctx->state[6] = 0x64F98FA7;
    4106:	4b0e      	ldr	r3, [pc, #56]	; (4140 <mbedtls_sha256_starts+0x98>)
    4108:	6203      	str	r3, [r0, #32]
        ctx->state[7] = 0xBEFA4FA4;
    410a:	4b0e      	ldr	r3, [pc, #56]	; (4144 <mbedtls_sha256_starts+0x9c>)
    410c:	6243      	str	r3, [r0, #36]	; 0x24
    }

    ctx->is224 = is224;
    410e:	6681      	str	r1, [r0, #104]	; 0x68
    4110:	4770      	bx	lr
    4112:	bf00      	nop
    4114:	6a09e667 	.word	0x6a09e667
    4118:	bb67ae85 	.word	0xbb67ae85
    411c:	3c6ef372 	.word	0x3c6ef372
    4120:	a54ff53a 	.word	0xa54ff53a
    4124:	510e527f 	.word	0x510e527f
    4128:	9b05688c 	.word	0x9b05688c
    412c:	1f83d9ab 	.word	0x1f83d9ab
    4130:	c1059ed8 	.word	0xc1059ed8
    4134:	367cd507 	.word	0x367cd507
    4138:	f70e5939 	.word	0xf70e5939
    413c:	ffc00b31 	.word	0xffc00b31
    4140:	64f98fa7 	.word	0x64f98fa7
    4144:	befa4fa4 	.word	0xbefa4fa4

00004148 <mbedtls_sha256_process>:
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

void mbedtls_sha256_process( mbedtls_sha256_context *ctx, const unsigned char data[64] )
{
    4148:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    414c:	b0cf      	sub	sp, #316	; 0x13c
    414e:	1d03      	adds	r3, r0, #4
    4150:	9305      	str	r3, [sp, #20]
    4152:	461a      	mov	r2, r3
    uint32_t temp1, temp2, W[64];
    uint32_t A[8];
    unsigned int i;

    for( i = 0; i < 8; i++ )
    4154:	2300      	movs	r3, #0
        A[i] = ctx->state[i];
    4156:	ac06      	add	r4, sp, #24
    4158:	f852 0f04 	ldr.w	r0, [r2, #4]!
    415c:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
{
    uint32_t temp1, temp2, W[64];
    uint32_t A[8];
    unsigned int i;

    for( i = 0; i < 8; i++ )
    4160:	3301      	adds	r3, #1
    4162:	2b08      	cmp	r3, #8
    4164:	d1f7      	bne.n	4156 <mbedtls_sha256_process+0xe>
    4166:	4608      	mov	r0, r1
    4168:	2200      	movs	r2, #0
        temp1 = A[7]; A[7] = A[6]; A[6] = A[5]; A[5] = A[4]; A[4] = A[3];
        A[3] = A[2]; A[2] = A[1]; A[1] = A[0]; A[0] = temp1;
    }
#else /* MBEDTLS_SHA256_SMALLER */
    for( i = 0; i < 16; i++ )
        GET_UINT32_BE( W[i], data, 4 * i );
    416a:	f811 4022 	ldrb.w	r4, [r1, r2, lsl #2]
    416e:	78c3      	ldrb	r3, [r0, #3]
    4170:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
    4174:	7844      	ldrb	r4, [r0, #1]
    4176:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
    417a:	7884      	ldrb	r4, [r0, #2]
    417c:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    4180:	ac0e      	add	r4, sp, #56	; 0x38
    4182:	3004      	adds	r0, #4
    4184:	f844 3022 	str.w	r3, [r4, r2, lsl #2]

        temp1 = A[7]; A[7] = A[6]; A[6] = A[5]; A[5] = A[4]; A[4] = A[3];
        A[3] = A[2]; A[2] = A[1]; A[1] = A[0]; A[0] = temp1;
    }
#else /* MBEDTLS_SHA256_SMALLER */
    for( i = 0; i < 16; i++ )
    4188:	3201      	adds	r2, #1
    418a:	2a10      	cmp	r2, #16
    418c:	d1ed      	bne.n	416a <mbedtls_sha256_process+0x22>
    418e:	a807      	add	r0, sp, #28
    4190:	e890 0203 	ldmia.w	r0, {r0, r1, r9}
    4194:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    4198:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    419a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    419c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    419e:	9c06      	ldr	r4, [sp, #24]
    41a0:	f8df e27c 	ldr.w	lr, [pc, #636]	; 4420 <mbedtls_sha256_process+0x2d8>
    41a4:	f10d 0c3c 	add.w	ip, sp, #60	; 0x3c
    41a8:	f85c 7c04 	ldr.w	r7, [ip, #-4]
    41ac:	f85e 6c04 	ldr.w	r6, [lr, #-4]
        GET_UINT32_BE( W[i], data, 4 * i );

    for( i = 0; i < 16; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i+0], K[i+0] );
    41b0:	ea4f 1ab5 	mov.w	sl, r5, ror #6
    41b4:	ea8a 2af5 	eor.w	sl, sl, r5, ror #11
    41b8:	ea8a 6a75 	eor.w	sl, sl, r5, ror #25
    41bc:	443e      	add	r6, r7
    41be:	4456      	add	r6, sl
    41c0:	ea83 0a02 	eor.w	sl, r3, r2
    41c4:	ea0a 0a05 	and.w	sl, sl, r5
    41c8:	ea8a 0a03 	eor.w	sl, sl, r3
    41cc:	4456      	add	r6, sl
    41ce:	4446      	add	r6, r8
    41d0:	ea40 0804 	orr.w	r8, r0, r4
    41d4:	ea00 0704 	and.w	r7, r0, r4
    41d8:	ea08 0801 	and.w	r8, r8, r1
    41dc:	ea48 0807 	orr.w	r8, r8, r7
    41e0:	ea4f 07b4 	mov.w	r7, r4, ror #2
    41e4:	ea87 3774 	eor.w	r7, r7, r4, ror #13
    41e8:	ea87 57b4 	eor.w	r7, r7, r4, ror #22
    41ec:	44b8      	add	r8, r7
    41ee:	44b0      	add	r8, r6
    41f0:	44b1      	add	r9, r6
    41f2:	f8de 7000 	ldr.w	r7, [lr]
    41f6:	f8dc 6000 	ldr.w	r6, [ip]
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
    41fa:	ea82 0a05 	eor.w	sl, r2, r5
    41fe:	4437      	add	r7, r6
    4200:	ea09 0a0a 	and.w	sl, r9, sl
    4204:	ea8a 0a02 	eor.w	sl, sl, r2
    4208:	443b      	add	r3, r7
    420a:	eb03 070a 	add.w	r7, r3, sl
    420e:	ea4f 13b9 	mov.w	r3, r9, ror #6
    4212:	ea83 23f9 	eor.w	r3, r3, r9, ror #11
    4216:	ea83 6379 	eor.w	r3, r3, r9, ror #25
    421a:	18fe      	adds	r6, r7, r3
    421c:	ea48 0304 	orr.w	r3, r8, r4
    4220:	eb06 0a01 	add.w	sl, r6, r1
    4224:	4003      	ands	r3, r0
    4226:	ea08 0104 	and.w	r1, r8, r4
    422a:	430b      	orrs	r3, r1
    422c:	ea4f 01b8 	mov.w	r1, r8, ror #2
    4230:	ea81 3178 	eor.w	r1, r1, r8, ror #13
    4234:	ea81 51b8 	eor.w	r1, r1, r8, ror #22
    4238:	440b      	add	r3, r1
    423a:	4433      	add	r3, r6
    423c:	f8dc 1004 	ldr.w	r1, [ip, #4]
    4240:	f8de 6004 	ldr.w	r6, [lr, #4]
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
    4244:	ea89 0705 	eor.w	r7, r9, r5
    4248:	440e      	add	r6, r1
    424a:	ea0a 0707 	and.w	r7, sl, r7
    424e:	406f      	eors	r7, r5
    4250:	4432      	add	r2, r6
    4252:	19d6      	adds	r6, r2, r7
    4254:	ea4f 12ba 	mov.w	r2, sl, ror #6
    4258:	ea82 22fa 	eor.w	r2, r2, sl, ror #11
    425c:	ea82 627a 	eor.w	r2, r2, sl, ror #25
    4260:	18b1      	adds	r1, r6, r2
    4262:	ea43 0208 	orr.w	r2, r3, r8
    4266:	180f      	adds	r7, r1, r0
    4268:	4022      	ands	r2, r4
    426a:	ea03 0008 	and.w	r0, r3, r8
    426e:	4302      	orrs	r2, r0
    4270:	ea4f 00b3 	mov.w	r0, r3, ror #2
    4274:	ea80 3073 	eor.w	r0, r0, r3, ror #13
    4278:	ea80 50b3 	eor.w	r0, r0, r3, ror #22
    427c:	4402      	add	r2, r0
    427e:	440a      	add	r2, r1
    4280:	f8de 0008 	ldr.w	r0, [lr, #8]
    4284:	f8dc 1008 	ldr.w	r1, [ip, #8]
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
    4288:	ea8a 0609 	eor.w	r6, sl, r9
    428c:	4401      	add	r1, r0
    428e:	403e      	ands	r6, r7
    4290:	ea86 0609 	eor.w	r6, r6, r9
    4294:	440d      	add	r5, r1
    4296:	4435      	add	r5, r6
    4298:	ea4f 16b7 	mov.w	r6, r7, ror #6
    429c:	ea86 26f7 	eor.w	r6, r6, r7, ror #11
    42a0:	ea86 6677 	eor.w	r6, r6, r7, ror #25
    42a4:	19a9      	adds	r1, r5, r6
    42a6:	ea42 0503 	orr.w	r5, r2, r3
    42aa:	ea05 0508 	and.w	r5, r5, r8
    42ae:	ea02 0603 	and.w	r6, r2, r3
    42b2:	432e      	orrs	r6, r5
    42b4:	ea4f 05b2 	mov.w	r5, r2, ror #2
    42b8:	ea85 3572 	eor.w	r5, r5, r2, ror #13
    42bc:	ea85 50b2 	eor.w	r0, r5, r2, ror #22
    42c0:	1835      	adds	r5, r6, r0
    42c2:	186e      	adds	r6, r5, r1
    42c4:	eb01 0b04 	add.w	fp, r1, r4
    42c8:	f8dc 000c 	ldr.w	r0, [ip, #12]
    42cc:	f8de 100c 	ldr.w	r1, [lr, #12]
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], W[i+4], K[i+4] );
    42d0:	ea87 040a 	eor.w	r4, r7, sl
    42d4:	4408      	add	r0, r1
    42d6:	ea0b 0404 	and.w	r4, fp, r4
    42da:	ea84 040a 	eor.w	r4, r4, sl
    42de:	4481      	add	r9, r0
    42e0:	eb09 0004 	add.w	r0, r9, r4
    42e4:	ea4f 19bb 	mov.w	r9, fp, ror #6
    42e8:	ea89 29fb 	eor.w	r9, r9, fp, ror #11
    42ec:	ea89 697b 	eor.w	r9, r9, fp, ror #25
    42f0:	eb00 0109 	add.w	r1, r0, r9
    42f4:	ea46 0902 	orr.w	r9, r6, r2
    42f8:	ea06 0002 	and.w	r0, r6, r2
    42fc:	ea09 0903 	and.w	r9, r9, r3
    4300:	ea49 0900 	orr.w	r9, r9, r0
    4304:	ea4f 00b6 	mov.w	r0, r6, ror #2
    4308:	ea80 3076 	eor.w	r0, r0, r6, ror #13
    430c:	ea80 50b6 	eor.w	r0, r0, r6, ror #22
    4310:	4481      	add	r9, r0
    4312:	4489      	add	r9, r1
    4314:	4488      	add	r8, r1
    4316:	f8dc 0010 	ldr.w	r0, [ip, #16]
    431a:	f8de 1010 	ldr.w	r1, [lr, #16]
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
    431e:	ea8b 0407 	eor.w	r4, fp, r7
    4322:	4408      	add	r0, r1
    4324:	ea08 0404 	and.w	r4, r8, r4
    4328:	ea4f 11b8 	mov.w	r1, r8, ror #6
    432c:	407c      	eors	r4, r7
    432e:	4482      	add	sl, r0
    4330:	ea81 21f8 	eor.w	r1, r1, r8, ror #11
    4334:	eb0a 0004 	add.w	r0, sl, r4
    4338:	ea81 6178 	eor.w	r1, r1, r8, ror #25
    433c:	eb00 0a01 	add.w	sl, r0, r1
    4340:	ea49 0106 	orr.w	r1, r9, r6
    4344:	ea09 0006 	and.w	r0, r9, r6
    4348:	4011      	ands	r1, r2
    434a:	4301      	orrs	r1, r0
    434c:	ea4f 00b9 	mov.w	r0, r9, ror #2
    4350:	ea80 3079 	eor.w	r0, r0, r9, ror #13
    4354:	ea80 50b9 	eor.w	r0, r0, r9, ror #22
    4358:	4401      	add	r1, r0
    435a:	f8dc 4014 	ldr.w	r4, [ip, #20]
    435e:	f8de 0014 	ldr.w	r0, [lr, #20]
    4362:	4453      	add	r3, sl
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
    4364:	ea88 050b 	eor.w	r5, r8, fp
    4368:	4404      	add	r4, r0
    436a:	401d      	ands	r5, r3
    436c:	ea4f 10b3 	mov.w	r0, r3, ror #6
    4370:	ea85 050b 	eor.w	r5, r5, fp
    4374:	4427      	add	r7, r4
    4376:	ea80 20f3 	eor.w	r0, r0, r3, ror #11
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i+0], K[i+0] );
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], W[i+4], K[i+4] );
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
    437a:	4451      	add	r1, sl
    437c:	197c      	adds	r4, r7, r5
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
    437e:	ea80 6073 	eor.w	r0, r0, r3, ror #25
    4382:	1827      	adds	r7, r4, r0
    4384:	ea41 0009 	orr.w	r0, r1, r9
    4388:	4030      	ands	r0, r6
    438a:	ea01 0409 	and.w	r4, r1, r9
    438e:	4320      	orrs	r0, r4
    4390:	ea4f 04b1 	mov.w	r4, r1, ror #2
    4394:	ea84 3471 	eor.w	r4, r4, r1, ror #13
    4398:	ea84 54b1 	eor.w	r4, r4, r1, ror #22
    439c:	4420      	add	r0, r4
    439e:	f8dc 5018 	ldr.w	r5, [ip, #24]
    43a2:	f8de 4018 	ldr.w	r4, [lr, #24]
    43a6:	4438      	add	r0, r7
    43a8:	443a      	add	r2, r7
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    43aa:	ea83 0708 	eor.w	r7, r3, r8
    43ae:	4425      	add	r5, r4
    43b0:	4017      	ands	r7, r2
    43b2:	ea4f 14b2 	mov.w	r4, r2, ror #6
    43b6:	44ab      	add	fp, r5
    43b8:	ea87 0708 	eor.w	r7, r7, r8
    43bc:	ea84 24f2 	eor.w	r4, r4, r2, ror #11
    43c0:	eb0b 0507 	add.w	r5, fp, r7
    43c4:	ea84 6472 	eor.w	r4, r4, r2, ror #25
    43c8:	eb05 0b04 	add.w	fp, r5, r4
    43cc:	ea40 0401 	orr.w	r4, r0, r1
    43d0:	eb0b 0506 	add.w	r5, fp, r6
    43d4:	ea04 0409 	and.w	r4, r4, r9
    43d8:	ea00 0601 	and.w	r6, r0, r1
    43dc:	4334      	orrs	r4, r6
    43de:	ea4f 06b0 	mov.w	r6, r0, ror #2
    43e2:	ea86 3670 	eor.w	r6, r6, r0, ror #13
    43e6:	ea86 56b0 	eor.w	r6, r6, r0, ror #22
    43ea:	4434      	add	r4, r6
    }
#else /* MBEDTLS_SHA256_SMALLER */
    for( i = 0; i < 16; i++ )
        GET_UINT32_BE( W[i], data, 4 * i );

    for( i = 0; i < 16; i += 8 )
    43ec:	4e0b      	ldr	r6, [pc, #44]	; (441c <mbedtls_sha256_process+0x2d4>)
    43ee:	f10e 0e20 	add.w	lr, lr, #32
    43f2:	45b6      	cmp	lr, r6
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], W[i+4], K[i+4] );
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    43f4:	445c      	add	r4, fp
    43f6:	f10c 0c20 	add.w	ip, ip, #32
    }
#else /* MBEDTLS_SHA256_SMALLER */
    for( i = 0; i < 16; i++ )
        GET_UINT32_BE( W[i], data, 4 * i );

    for( i = 0; i < 16; i += 8 )
    43fa:	f47f aed5 	bne.w	41a8 <mbedtls_sha256_process+0x60>
    43fe:	2700      	movs	r7, #0
    4400:	f1a6 0b44 	sub.w	fp, r6, #68	; 0x44
    4404:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    4408:	950a      	str	r5, [sp, #40]	; 0x28
    440a:	920b      	str	r2, [sp, #44]	; 0x2c
    440c:	930c      	str	r3, [sp, #48]	; 0x30
    440e:	9406      	str	r4, [sp, #24]
    4410:	9007      	str	r0, [sp, #28]
    4412:	9108      	str	r1, [sp, #32]
    4414:	9001      	str	r0, [sp, #4]
    4416:	ae0e      	add	r6, sp, #56	; 0x38
    4418:	9704      	str	r7, [sp, #16]
    441a:	e003      	b.n	4424 <mbedtls_sha256_process+0x2dc>
    441c:	000063e8 	.word	0x000063e8
    4420:	000063a8 	.word	0x000063a8
    4424:	f10d 0c38 	add.w	ip, sp, #56	; 0x38
    4428:	9f04      	ldr	r7, [sp, #16]
    442a:	6a70      	ldr	r0, [r6, #36]	; 0x24
    442c:	f85c 7027 	ldr.w	r7, [ip, r7, lsl #2]
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    }

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
    4430:	f8d6 e004 	ldr.w	lr, [r6, #4]
    4434:	4407      	add	r7, r0
    4436:	6bb0      	ldr	r0, [r6, #56]	; 0x38
    4438:	ea4f 4c70 	mov.w	ip, r0, ror #17
    443c:	ea8c 4cf0 	eor.w	ip, ip, r0, ror #19
    4440:	ea8c 2c90 	eor.w	ip, ip, r0, lsr #10
    4444:	4467      	add	r7, ip
    4446:	ea4f 1cfe 	mov.w	ip, lr, ror #7
    444a:	ea8c 4cbe 	eor.w	ip, ip, lr, ror #18
    444e:	ea8c 0cde 	eor.w	ip, ip, lr, lsr #3
    4452:	eb07 000c 	add.w	r0, r7, ip
    4456:	ea4f 1cb5 	mov.w	ip, r5, ror #6
    445a:	ea8c 2cf5 	eor.w	ip, ip, r5, ror #11
    445e:	ea8c 6a75 	eor.w	sl, ip, r5, ror #25
    4462:	ea83 0c02 	eor.w	ip, r3, r2
    4466:	ea0c 0c05 	and.w	ip, ip, r5
    446a:	ea8c 0703 	eor.w	r7, ip, r3
    446e:	eb0a 0c07 	add.w	ip, sl, r7
    4472:	f8db 7040 	ldr.w	r7, [fp, #64]	; 0x40
    4476:	9003      	str	r0, [sp, #12]
    4478:	4467      	add	r7, ip
    447a:	4407      	add	r7, r0
    447c:	6430      	str	r0, [r6, #64]	; 0x40
    447e:	9801      	ldr	r0, [sp, #4]
    4480:	ea40 0c04 	orr.w	ip, r0, r4
    4484:	44b8      	add	r8, r7
    4486:	ea0c 0701 	and.w	r7, ip, r1
    448a:	ea00 0c04 	and.w	ip, r0, r4
    448e:	6ab0      	ldr	r0, [r6, #40]	; 0x28
    4490:	ea47 0c0c 	orr.w	ip, r7, ip
    4494:	ea4f 07b4 	mov.w	r7, r4, ror #2
    4498:	4486      	add	lr, r0
    449a:	ea87 3774 	eor.w	r7, r7, r4, ror #13
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
    449e:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    }

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
    44a0:	ea87 57b4 	eor.w	r7, r7, r4, ror #22
    44a4:	4467      	add	r7, ip
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
    44a6:	ea4f 4c70 	mov.w	ip, r0, ror #17
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    }

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
    44aa:	eb09 0a08 	add.w	sl, r9, r8
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
    44ae:	ea8c 4cf0 	eor.w	ip, ip, r0, ror #19
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    }

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
    44b2:	44b8      	add	r8, r7
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
    44b4:	68b7      	ldr	r7, [r6, #8]
    44b6:	ea8c 2c90 	eor.w	ip, ip, r0, lsr #10
    44ba:	44f4      	add	ip, lr
    44bc:	ea4f 1ef7 	mov.w	lr, r7, ror #7
    44c0:	ea8e 4eb7 	eor.w	lr, lr, r7, ror #18
    44c4:	f8db 0044 	ldr.w	r0, [fp, #68]	; 0x44
    44c8:	ea8e 0ed7 	eor.w	lr, lr, r7, lsr #3
    44cc:	44e6      	add	lr, ip
    44ce:	ea82 0c05 	eor.w	ip, r2, r5
    44d2:	4403      	add	r3, r0
    44d4:	ea0a 0c0c 	and.w	ip, sl, ip
    44d8:	4473      	add	r3, lr
    44da:	ea8c 0c02 	eor.w	ip, ip, r2
    44de:	eb03 090c 	add.w	r9, r3, ip
    44e2:	ea4f 13ba 	mov.w	r3, sl, ror #6
    44e6:	ea83 23fa 	eor.w	r3, r3, sl, ror #11
    44ea:	ea83 637a 	eor.w	r3, r3, sl, ror #25
    44ee:	eb09 0c03 	add.w	ip, r9, r3
    44f2:	eb0c 0301 	add.w	r3, ip, r1
    44f6:	9302      	str	r3, [sp, #8]
    44f8:	9b01      	ldr	r3, [sp, #4]
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
    44fa:	9803      	ldr	r0, [sp, #12]
    }

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
    44fc:	f8c6 e044 	str.w	lr, [r6, #68]	; 0x44
    4500:	ea48 0104 	orr.w	r1, r8, r4
    4504:	400b      	ands	r3, r1
    4506:	ea08 0104 	and.w	r1, r8, r4
    450a:	4319      	orrs	r1, r3
    450c:	ea4f 03b8 	mov.w	r3, r8, ror #2
    4510:	ea83 3378 	eor.w	r3, r3, r8, ror #13
    4514:	ea83 53b8 	eor.w	r3, r3, r8, ror #22
    4518:	440b      	add	r3, r1
    451a:	6af1      	ldr	r1, [r6, #44]	; 0x2c
    451c:	4439      	add	r1, r7
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
    451e:	ea4f 4770 	mov.w	r7, r0, ror #17
    }

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
    4522:	4463      	add	r3, ip
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
    4524:	ea87 47f0 	eor.w	r7, r7, r0, ror #19
    4528:	f8d6 c00c 	ldr.w	ip, [r6, #12]
    452c:	ea87 2990 	eor.w	r9, r7, r0, lsr #10
    4530:	eb01 0709 	add.w	r7, r1, r9
    4534:	f8db 0048 	ldr.w	r0, [fp, #72]	; 0x48
    4538:	ea4f 11fc 	mov.w	r1, ip, ror #7
    453c:	ea81 41bc 	eor.w	r1, r1, ip, ror #18
    4540:	ea81 01dc 	eor.w	r1, r1, ip, lsr #3
    4544:	4402      	add	r2, r0
    4546:	9802      	ldr	r0, [sp, #8]
    4548:	4439      	add	r1, r7
    454a:	ea8a 0705 	eor.w	r7, sl, r5
    454e:	4007      	ands	r7, r0
    4550:	440a      	add	r2, r1
    4552:	406f      	eors	r7, r5
    4554:	eb02 0907 	add.w	r9, r2, r7
    4558:	ea4f 12b0 	mov.w	r2, r0, ror #6
    455c:	ea82 22f0 	eor.w	r2, r2, r0, ror #11
    4560:	ea82 6270 	eor.w	r2, r2, r0, ror #25
    4564:	eb09 0702 	add.w	r7, r9, r2
    4568:	9a01      	ldr	r2, [sp, #4]
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
    456a:	f8d6 9010 	ldr.w	r9, [r6, #16]

    for( i = 16; i < 64; i += 8 )
    {
        P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
    456e:	64b1      	str	r1, [r6, #72]	; 0x48
    4570:	ea43 0008 	orr.w	r0, r3, r8
    4574:	443a      	add	r2, r7
    4576:	9201      	str	r2, [sp, #4]
    4578:	ea00 0204 	and.w	r2, r0, r4
    457c:	ea03 0008 	and.w	r0, r3, r8
    4580:	4310      	orrs	r0, r2
    4582:	ea4f 02b3 	mov.w	r2, r3, ror #2
    4586:	ea82 3273 	eor.w	r2, r2, r3, ror #13
    458a:	ea82 52b3 	eor.w	r2, r2, r3, ror #22
    458e:	4402      	add	r2, r0
    4590:	443a      	add	r2, r7
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
    4592:	ea4f 477e 	mov.w	r7, lr, ror #17
    4596:	6b30      	ldr	r0, [r6, #48]	; 0x30
    4598:	ea87 47fe 	eor.w	r7, r7, lr, ror #19
    459c:	ea87 2e9e 	eor.w	lr, r7, lr, lsr #10
    45a0:	ea4f 17f9 	mov.w	r7, r9, ror #7
    45a4:	4460      	add	r0, ip
    45a6:	ea87 47b9 	eor.w	r7, r7, r9, ror #18
    45aa:	ea87 07d9 	eor.w	r7, r7, r9, lsr #3
    45ae:	4470      	add	r0, lr
    45b0:	4438      	add	r0, r7
    45b2:	f8db 704c 	ldr.w	r7, [fp, #76]	; 0x4c
    45b6:	64f0      	str	r0, [r6, #76]	; 0x4c
    45b8:	443d      	add	r5, r7
    45ba:	9f02      	ldr	r7, [sp, #8]
    45bc:	ea87 0e0a 	eor.w	lr, r7, sl
    45c0:	9f01      	ldr	r7, [sp, #4]
    45c2:	ea07 0e0e 	and.w	lr, r7, lr
    45c6:	4405      	add	r5, r0
    45c8:	ea8e 0e0a 	eor.w	lr, lr, sl
    45cc:	44ae      	add	lr, r5
    45ce:	ea4f 15b7 	mov.w	r5, r7, ror #6
    45d2:	ea85 25f7 	eor.w	r5, r5, r7, ror #11
    45d6:	ea85 6577 	eor.w	r5, r5, r7, ror #25
    45da:	eb0e 0705 	add.w	r7, lr, r5
    45de:	ea42 0503 	orr.w	r5, r2, r3
    45e2:	eb07 0c04 	add.w	ip, r7, r4
    45e6:	ea05 0508 	and.w	r5, r5, r8
    45ea:	ea02 0403 	and.w	r4, r2, r3
    45ee:	4325      	orrs	r5, r4
    45f0:	ea4f 04b2 	mov.w	r4, r2, ror #2
    45f4:	ea84 3472 	eor.w	r4, r4, r2, ror #13
    45f8:	ea84 54b2 	eor.w	r4, r4, r2, ror #22
    45fc:	4425      	add	r5, r4
    45fe:	443d      	add	r5, r7
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i+4), K[i+4] );
    4600:	ea4f 4e71 	mov.w	lr, r1, ror #17
    4604:	6b77      	ldr	r7, [r6, #52]	; 0x34
    4606:	6974      	ldr	r4, [r6, #20]
    4608:	ea8e 4ef1 	eor.w	lr, lr, r1, ror #19
    460c:	44b9      	add	r9, r7
    460e:	ea8e 2791 	eor.w	r7, lr, r1, lsr #10
    4612:	44b9      	add	r9, r7
    4614:	ea4f 17f4 	mov.w	r7, r4, ror #7
    4618:	ea87 47b4 	eor.w	r7, r7, r4, ror #18
    461c:	ea87 01d4 	eor.w	r1, r7, r4, lsr #3
    4620:	eb09 0701 	add.w	r7, r9, r1
    4624:	f8db 1050 	ldr.w	r1, [fp, #80]	; 0x50
    4628:	4439      	add	r1, r7
    462a:	eb01 090a 	add.w	r9, r1, sl
    462e:	9901      	ldr	r1, [sp, #4]
    4630:	6537      	str	r7, [r6, #80]	; 0x50
    4632:	468e      	mov	lr, r1
    4634:	9902      	ldr	r1, [sp, #8]
    4636:	ea8e 0a01 	eor.w	sl, lr, r1
    463a:	ea0c 0a0a 	and.w	sl, ip, sl
    463e:	ea8a 0e01 	eor.w	lr, sl, r1
    4642:	eb09 0a0e 	add.w	sl, r9, lr
    4646:	ea4f 19bc 	mov.w	r9, ip, ror #6
    464a:	ea89 29fc 	eor.w	r9, r9, ip, ror #11
    464e:	ea89 697c 	eor.w	r9, r9, ip, ror #25
    4652:	eb0a 0109 	add.w	r1, sl, r9
    4656:	ea45 0902 	orr.w	r9, r5, r2
    465a:	ea05 0e02 	and.w	lr, r5, r2
    465e:	ea09 0903 	and.w	r9, r9, r3
    4662:	ea49 090e 	orr.w	r9, r9, lr
    4666:	ea4f 0eb5 	mov.w	lr, r5, ror #2
    466a:	ea8e 3e75 	eor.w	lr, lr, r5, ror #13
    466e:	ea8e 5eb5 	eor.w	lr, lr, r5, ror #22
    4672:	44f1      	add	r9, lr
    4674:	4489      	add	r9, r1
    4676:	4488      	add	r8, r1
    4678:	6bb1      	ldr	r1, [r6, #56]	; 0x38
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], R(i+5), K[i+5] );
    467a:	f8d6 a018 	ldr.w	sl, [r6, #24]
    467e:	440c      	add	r4, r1
    4680:	ea4f 4170 	mov.w	r1, r0, ror #17
    4684:	ea81 41f0 	eor.w	r1, r1, r0, ror #19
    4688:	ea4f 1efa 	mov.w	lr, sl, ror #7
    468c:	ea81 2090 	eor.w	r0, r1, r0, lsr #10
    4690:	ea8e 4eba 	eor.w	lr, lr, sl, ror #18
    4694:	ea8e 0eda 	eor.w	lr, lr, sl, lsr #3
    4698:	4404      	add	r4, r0
    469a:	f8db 0054 	ldr.w	r0, [fp, #84]	; 0x54
    469e:	9902      	ldr	r1, [sp, #8]
    46a0:	4474      	add	r4, lr
    46a2:	4420      	add	r0, r4
    46a4:	1841      	adds	r1, r0, r1
    46a6:	9801      	ldr	r0, [sp, #4]
    46a8:	6574      	str	r4, [r6, #84]	; 0x54
    46aa:	ea8c 0e00 	eor.w	lr, ip, r0
    46ae:	ea08 0e0e 	and.w	lr, r8, lr
    46b2:	ea8e 0e00 	eor.w	lr, lr, r0
    46b6:	448e      	add	lr, r1
    46b8:	ea4f 11b8 	mov.w	r1, r8, ror #6
    46bc:	ea81 21f8 	eor.w	r1, r1, r8, ror #11
    46c0:	ea81 6178 	eor.w	r1, r1, r8, ror #25
    46c4:	eb0e 0001 	add.w	r0, lr, r1
    46c8:	ea49 0e05 	orr.w	lr, r9, r5
    46cc:	ea0e 0102 	and.w	r1, lr, r2
    46d0:	ea09 0e05 	and.w	lr, r9, r5
    46d4:	ea41 0e0e 	orr.w	lr, r1, lr
    46d8:	ea4f 01b9 	mov.w	r1, r9, ror #2
    46dc:	ea81 3179 	eor.w	r1, r1, r9, ror #13
    46e0:	ea81 51b9 	eor.w	r1, r1, r9, ror #22
    46e4:	4471      	add	r1, lr
    46e6:	4401      	add	r1, r0
    46e8:	4403      	add	r3, r0
    46ea:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
    46ec:	f8d6 e01c 	ldr.w	lr, [r6, #28]
    46f0:	4482      	add	sl, r0
    46f2:	ea4f 4077 	mov.w	r0, r7, ror #17
    46f6:	ea80 40f7 	eor.w	r0, r0, r7, ror #19
    46fa:	ea80 2797 	eor.w	r7, r0, r7, lsr #10
    46fe:	44ba      	add	sl, r7
    4700:	ea4f 17fe 	mov.w	r7, lr, ror #7
    4704:	ea87 47be 	eor.w	r7, r7, lr, ror #18
    4708:	ea87 00de 	eor.w	r0, r7, lr, lsr #3
    470c:	eb0a 0700 	add.w	r7, sl, r0
    4710:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    4714:	65b7      	str	r7, [r6, #88]	; 0x58
    4716:	eb00 0a07 	add.w	sl, r0, r7
    471a:	9801      	ldr	r0, [sp, #4]
    471c:	4450      	add	r0, sl
    471e:	ea88 0a0c 	eor.w	sl, r8, ip
    4722:	ea03 0a0a 	and.w	sl, r3, sl
    4726:	ea4f 17b3 	mov.w	r7, r3, ror #6
    472a:	ea8a 0a0c 	eor.w	sl, sl, ip
    472e:	ea87 27f3 	eor.w	r7, r7, r3, ror #11
    4732:	4450      	add	r0, sl
    4734:	ea87 6773 	eor.w	r7, r7, r3, ror #25
    4738:	ea41 0a09 	orr.w	sl, r1, r9
    473c:	4407      	add	r7, r0
    473e:	ea0a 0005 	and.w	r0, sl, r5
    4742:	ea01 0a09 	and.w	sl, r1, r9
    4746:	ea40 0a0a 	orr.w	sl, r0, sl
    474a:	ea4f 00b1 	mov.w	r0, r1, ror #2
    474e:	ea80 3071 	eor.w	r0, r0, r1, ror #13
    4752:	ea80 50b1 	eor.w	r0, r0, r1, ror #22
    4756:	4450      	add	r0, sl
    4758:	443a      	add	r2, r7
    475a:	4438      	add	r0, r7
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    475c:	ea4f 4a74 	mov.w	sl, r4, ror #17
    4760:	6a37      	ldr	r7, [r6, #32]
        P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i+4), K[i+4] );
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], R(i+5), K[i+5] );
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
    4762:	9001      	str	r0, [sp, #4]
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    4764:	ea8a 4af4 	eor.w	sl, sl, r4, ror #19
    4768:	9803      	ldr	r0, [sp, #12]
    476a:	ea8a 2494 	eor.w	r4, sl, r4, lsr #10
    476e:	ea4f 1af7 	mov.w	sl, r7, ror #7
    4772:	4486      	add	lr, r0
    4774:	ea8a 4ab7 	eor.w	sl, sl, r7, ror #18
    4778:	44a6      	add	lr, r4
    477a:	ea8a 07d7 	eor.w	r7, sl, r7, lsr #3
    477e:	f8db 405c 	ldr.w	r4, [fp, #92]	; 0x5c
    4782:	9801      	ldr	r0, [sp, #4]
    4784:	4477      	add	r7, lr
    4786:	443c      	add	r4, r7
    4788:	ea83 0e08 	eor.w	lr, r3, r8
    478c:	4464      	add	r4, ip
    478e:	ea02 0e0e 	and.w	lr, r2, lr
    4792:	ea4f 1cb2 	mov.w	ip, r2, ror #6
    4796:	ea8e 0e08 	eor.w	lr, lr, r8
    479a:	ea8c 2cf2 	eor.w	ip, ip, r2, ror #11
    479e:	4474      	add	r4, lr
    47a0:	ea8c 6c72 	eor.w	ip, ip, r2, ror #25
    47a4:	44a4      	add	ip, r4
    47a6:	ea40 0401 	orr.w	r4, r0, r1
    47aa:	65f7      	str	r7, [r6, #92]	; 0x5c
    47ac:	ea04 0409 	and.w	r4, r4, r9
    47b0:	ea00 0701 	and.w	r7, r0, r1
    47b4:	433c      	orrs	r4, r7
    47b6:	ea4f 07b0 	mov.w	r7, r0, ror #2
    47ba:	ea87 3770 	eor.w	r7, r7, r0, ror #13
    47be:	ea87 57b0 	eor.w	r7, r7, r0, ror #22
    47c2:	9804      	ldr	r0, [sp, #16]
    47c4:	3008      	adds	r0, #8
    47c6:	443c      	add	r4, r7
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    }

    for( i = 16; i < 64; i += 8 )
    47c8:	2830      	cmp	r0, #48	; 0x30
        P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
        P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
        P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i+4), K[i+4] );
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], R(i+5), K[i+5] );
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    47ca:	4465      	add	r5, ip
    47cc:	4464      	add	r4, ip
    47ce:	9004      	str	r0, [sp, #16]
    47d0:	f10b 0b20 	add.w	fp, fp, #32
    47d4:	f106 0620 	add.w	r6, r6, #32
        P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    }

    for( i = 16; i < 64; i += 8 )
    47d8:	f47f ae24 	bne.w	4424 <mbedtls_sha256_process+0x2dc>
    47dc:	930c      	str	r3, [sp, #48]	; 0x30
    47de:	9b01      	ldr	r3, [sp, #4]
    47e0:	9307      	str	r3, [sp, #28]
    47e2:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    47e6:	950a      	str	r5, [sp, #40]	; 0x28
    47e8:	920b      	str	r2, [sp, #44]	; 0x2c
    47ea:	9406      	str	r4, [sp, #24]
    47ec:	9108      	str	r1, [sp, #32]
    47ee:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    47f2:	2300      	movs	r3, #0
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    }
#endif /* MBEDTLS_SHA256_SMALLER */

    for( i = 0; i < 8; i++ )
        ctx->state[i] += A[i];
    47f4:	9a05      	ldr	r2, [sp, #20]
    47f6:	f852 1f04 	ldr.w	r1, [r2, #4]!
    47fa:	9205      	str	r2, [sp, #20]
    47fc:	aa06      	add	r2, sp, #24
    47fe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    }
#endif /* MBEDTLS_SHA256_SMALLER */

    for( i = 0; i < 8; i++ )
    4802:	3301      	adds	r3, #1
        ctx->state[i] += A[i];
    4804:	440a      	add	r2, r1
    4806:	9905      	ldr	r1, [sp, #20]
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    }
#endif /* MBEDTLS_SHA256_SMALLER */

    for( i = 0; i < 8; i++ )
    4808:	2b08      	cmp	r3, #8
        ctx->state[i] += A[i];
    480a:	600a      	str	r2, [r1, #0]
        P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
        P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    }
#endif /* MBEDTLS_SHA256_SMALLER */

    for( i = 0; i < 8; i++ )
    480c:	d1f2      	bne.n	47f4 <mbedtls_sha256_process+0x6ac>
        ctx->state[i] += A[i];
}
    480e:	b04f      	add	sp, #316	; 0x13c
    4810:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004814 <mbedtls_sha256_update.part.0>:
    uint32_t left;

    if( ilen == 0 )
        return;

    left = ctx->total[0] & 0x3F;
    4814:	6803      	ldr	r3, [r0, #0]
#endif /* !MBEDTLS_SHA256_PROCESS_ALT */

/*
 * SHA-256 process buffer
 */
void mbedtls_sha256_update( mbedtls_sha256_context *ctx, const unsigned char *input,
    4816:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t left;

    if( ilen == 0 )
        return;

    left = ctx->total[0] & 0x3F;
    481a:	f003 053f 	and.w	r5, r3, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
    481e:	4413      	add	r3, r2
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
    4820:	4293      	cmp	r3, r2
        return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
    4822:	6003      	str	r3, [r0, #0]
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
        ctx->total[1]++;
    4824:	bf3c      	itt	cc
    4826:	6843      	ldrcc	r3, [r0, #4]
    4828:	3301      	addcc	r3, #1
#endif /* !MBEDTLS_SHA256_PROCESS_ALT */

/*
 * SHA-256 process buffer
 */
void mbedtls_sha256_update( mbedtls_sha256_context *ctx, const unsigned char *input,
    482a:	4606      	mov	r6, r0
    482c:	460f      	mov	r7, r1
    482e:	4614      	mov	r4, r2

    ctx->total[0] += (uint32_t) ilen;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
        ctx->total[1]++;
    4830:	bf38      	it	cc
    4832:	6043      	strcc	r3, [r0, #4]

    if( left && ilen >= fill )
    4834:	b195      	cbz	r5, 485c <mbedtls_sha256_update.part.0+0x48>

    if( ilen == 0 )
        return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    4836:	f1c5 0840 	rsb	r8, r5, #64	; 0x40
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
        ctx->total[1]++;

    if( left && ilen >= fill )
    483a:	4542      	cmp	r2, r8
    483c:	d30e      	bcc.n	485c <mbedtls_sha256_update.part.0+0x48>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
    483e:	f105 0028 	add.w	r0, r5, #40	; 0x28
    4842:	4642      	mov	r2, r8
    4844:	4430      	add	r0, r6
    4846:	f001 fb45 	bl	5ed4 <memcpy>
        mbedtls_sha256_process( ctx, ctx->buffer );
    484a:	4630      	mov	r0, r6
    484c:	f106 0128 	add.w	r1, r6, #40	; 0x28
    4850:	f7ff fc7a 	bl	4148 <mbedtls_sha256_process>
        input += fill;
    4854:	4447      	add	r7, r8
        ilen  -= fill;
    4856:	ebc8 0404 	rsb	r4, r8, r4
        left = 0;
    485a:	2500      	movs	r5, #0
    485c:	46a0      	mov	r8, r4
    485e:	ebc8 0104 	rsb	r1, r8, r4
    }

    while( ilen >= 64 )
    4862:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
    4866:	4439      	add	r1, r7
    4868:	d905      	bls.n	4876 <mbedtls_sha256_update.part.0+0x62>
    {
        mbedtls_sha256_process( ctx, input );
    486a:	4630      	mov	r0, r6
    486c:	f7ff fc6c 	bl	4148 <mbedtls_sha256_process>
        input += 64;
        ilen  -= 64;
    4870:	f1a8 0840 	sub.w	r8, r8, #64	; 0x40
    4874:	e7f3      	b.n	485e <mbedtls_sha256_update.part.0+0x4a>
    4876:	f024 013f 	bic.w	r1, r4, #63	; 0x3f
    }

    if( ilen > 0 )
    487a:	f014 023f 	ands.w	r2, r4, #63	; 0x3f
    487e:	4439      	add	r1, r7
    4880:	d006      	beq.n	4890 <mbedtls_sha256_update.part.0+0x7c>
        memcpy( (void *) (ctx->buffer + left), input, ilen );
    4882:	f105 0028 	add.w	r0, r5, #40	; 0x28
    4886:	4430      	add	r0, r6
}
    4888:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        input += 64;
        ilen  -= 64;
    }

    if( ilen > 0 )
        memcpy( (void *) (ctx->buffer + left), input, ilen );
    488c:	f001 bb22 	b.w	5ed4 <memcpy>
    4890:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004894 <mbedtls_sha256_update>:
                    size_t ilen )
{
    size_t fill;
    uint32_t left;

    if( ilen == 0 )
    4894:	b10a      	cbz	r2, 489a <mbedtls_sha256_update+0x6>
    4896:	f7ff bfbd 	b.w	4814 <mbedtls_sha256_update.part.0>
    489a:	4770      	bx	lr

0000489c <mbedtls_sha256_finish>:

/*
 * SHA-256 final digest
 */
void mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] )
{
    489c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
    489e:	6802      	ldr	r2, [r0, #0]

/*
 * SHA-256 final digest
 */
void mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] )
{
    48a0:	460d      	mov	r5, r1
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    48a2:	6841      	ldr	r1, [r0, #4]
{
    uint32_t last, padn;
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
    48a4:	0f53      	lsrs	r3, r2, #29
    48a6:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3

/*
 * SHA-256 final digest
 */
void mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] )
{
    48aa:	4604      	mov	r4, r0

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_BE( high, msglen, 0 );
    48ac:	0e18      	lsrs	r0, r3, #24
    uint32_t high, low;
    unsigned char msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );
    48ae:	00d1      	lsls	r1, r2, #3

    PUT_UINT32_BE( high, msglen, 0 );
    48b0:	f88d 0000 	strb.w	r0, [sp]
    48b4:	0c18      	lsrs	r0, r3, #16
    PUT_UINT32_BE( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
    48b6:	f002 023f 	and.w	r2, r2, #63	; 0x3f

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_BE( high, msglen, 0 );
    48ba:	f88d 0001 	strb.w	r0, [sp, #1]
    48be:	f88d 3003 	strb.w	r3, [sp, #3]
    48c2:	0a18      	lsrs	r0, r3, #8
    PUT_UINT32_BE( low,  msglen, 4 );
    48c4:	0e0b      	lsrs	r3, r1, #24

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    48c6:	2a37      	cmp	r2, #55	; 0x37
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_BE( high, msglen, 0 );
    PUT_UINT32_BE( low,  msglen, 4 );
    48c8:	f88d 3004 	strb.w	r3, [sp, #4]
    48cc:	ea4f 4311 	mov.w	r3, r1, lsr #16

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    48d0:	bf94      	ite	ls
    48d2:	f1c2 0238 	rsbls	r2, r2, #56	; 0x38
    48d6:	f1c2 0278 	rsbhi	r2, r2, #120	; 0x78

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_BE( high, msglen, 0 );
    48da:	f88d 0002 	strb.w	r0, [sp, #2]
    PUT_UINT32_BE( low,  msglen, 4 );
    48de:	f88d 3005 	strb.w	r3, [sp, #5]
    48e2:	f88d 1007 	strb.w	r1, [sp, #7]
    48e6:	0a0b      	lsrs	r3, r1, #8

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    mbedtls_sha256_update( ctx, sha256_padding, padn );
    48e8:	4620      	mov	r0, r4
    48ea:	492c      	ldr	r1, [pc, #176]	; (499c <mbedtls_sha256_finish+0x100>)
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32_BE( high, msglen, 0 );
    PUT_UINT32_BE( low,  msglen, 4 );
    48ec:	f88d 3006 	strb.w	r3, [sp, #6]

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    mbedtls_sha256_update( ctx, sha256_padding, padn );
    48f0:	f7ff ffd0 	bl	4894 <mbedtls_sha256_update>
    48f4:	4620      	mov	r0, r4
    48f6:	4669      	mov	r1, sp
    48f8:	2208      	movs	r2, #8
    48fa:	f7ff ff8b 	bl	4814 <mbedtls_sha256_update.part.0>
    mbedtls_sha256_update( ctx, msglen, 8 );

    PUT_UINT32_BE( ctx->state[0], output,  0 );
    48fe:	7ae3      	ldrb	r3, [r4, #11]
    4900:	702b      	strb	r3, [r5, #0]
    4902:	8963      	ldrh	r3, [r4, #10]
    4904:	706b      	strb	r3, [r5, #1]
    4906:	68a3      	ldr	r3, [r4, #8]
    4908:	0a1b      	lsrs	r3, r3, #8
    490a:	70ab      	strb	r3, [r5, #2]
    490c:	68a3      	ldr	r3, [r4, #8]
    490e:	70eb      	strb	r3, [r5, #3]
    PUT_UINT32_BE( ctx->state[1], output,  4 );
    4910:	7be3      	ldrb	r3, [r4, #15]
    4912:	712b      	strb	r3, [r5, #4]
    4914:	89e3      	ldrh	r3, [r4, #14]
    4916:	716b      	strb	r3, [r5, #5]
    4918:	68e3      	ldr	r3, [r4, #12]
    491a:	0a1b      	lsrs	r3, r3, #8
    491c:	71ab      	strb	r3, [r5, #6]
    491e:	68e3      	ldr	r3, [r4, #12]
    4920:	71eb      	strb	r3, [r5, #7]
    PUT_UINT32_BE( ctx->state[2], output,  8 );
    4922:	7ce3      	ldrb	r3, [r4, #19]
    4924:	722b      	strb	r3, [r5, #8]
    4926:	8a63      	ldrh	r3, [r4, #18]
    4928:	726b      	strb	r3, [r5, #9]
    492a:	6923      	ldr	r3, [r4, #16]
    492c:	0a1b      	lsrs	r3, r3, #8
    492e:	72ab      	strb	r3, [r5, #10]
    4930:	6923      	ldr	r3, [r4, #16]
    4932:	72eb      	strb	r3, [r5, #11]
    PUT_UINT32_BE( ctx->state[3], output, 12 );
    4934:	7de3      	ldrb	r3, [r4, #23]
    4936:	732b      	strb	r3, [r5, #12]
    4938:	8ae3      	ldrh	r3, [r4, #22]
    493a:	736b      	strb	r3, [r5, #13]
    493c:	6963      	ldr	r3, [r4, #20]
    493e:	0a1b      	lsrs	r3, r3, #8
    4940:	73ab      	strb	r3, [r5, #14]
    4942:	6963      	ldr	r3, [r4, #20]
    4944:	73eb      	strb	r3, [r5, #15]
    PUT_UINT32_BE( ctx->state[4], output, 16 );
    4946:	7ee3      	ldrb	r3, [r4, #27]
    4948:	742b      	strb	r3, [r5, #16]
    494a:	8b63      	ldrh	r3, [r4, #26]
    494c:	746b      	strb	r3, [r5, #17]
    494e:	69a3      	ldr	r3, [r4, #24]
    4950:	0a1b      	lsrs	r3, r3, #8
    4952:	74ab      	strb	r3, [r5, #18]
    4954:	69a3      	ldr	r3, [r4, #24]
    4956:	74eb      	strb	r3, [r5, #19]
    PUT_UINT32_BE( ctx->state[5], output, 20 );
    4958:	7fe3      	ldrb	r3, [r4, #31]
    495a:	752b      	strb	r3, [r5, #20]
    495c:	8be3      	ldrh	r3, [r4, #30]
    495e:	756b      	strb	r3, [r5, #21]
    4960:	69e3      	ldr	r3, [r4, #28]
    4962:	0a1b      	lsrs	r3, r3, #8
    4964:	75ab      	strb	r3, [r5, #22]
    4966:	69e3      	ldr	r3, [r4, #28]
    4968:	75eb      	strb	r3, [r5, #23]
    PUT_UINT32_BE( ctx->state[6], output, 24 );
    496a:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    496e:	762b      	strb	r3, [r5, #24]
    4970:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    4972:	766b      	strb	r3, [r5, #25]
    4974:	6a23      	ldr	r3, [r4, #32]
    4976:	0a1b      	lsrs	r3, r3, #8
    4978:	76ab      	strb	r3, [r5, #26]
    497a:	6a23      	ldr	r3, [r4, #32]
    497c:	76eb      	strb	r3, [r5, #27]

    if( ctx->is224 == 0 )
    497e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    4980:	b94b      	cbnz	r3, 4996 <mbedtls_sha256_finish+0xfa>
        PUT_UINT32_BE( ctx->state[7], output, 28 );
    4982:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
    4986:	772b      	strb	r3, [r5, #28]
    4988:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
    498a:	776b      	strb	r3, [r5, #29]
    498c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    498e:	0a1b      	lsrs	r3, r3, #8
    4990:	77ab      	strb	r3, [r5, #30]
    4992:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4994:	77eb      	strb	r3, [r5, #31]
}
    4996:	b003      	add	sp, #12
    4998:	bd30      	pop	{r4, r5, pc}
    499a:	bf00      	nop
    499c:	00006361 	.word	0x00006361

000049a0 <os_idle_task>:
 *
 * @param arg unused
 */
void
os_idle_task(void *arg)
{
    49a0:	b570      	push	{r4, r5, r6, lr}
    os_sr_t sr;
    os_time_t now;
    os_time_t iticks, sticks, cticks;

    while (1) {
        ++g_os_idle_ctr;
    49a2:	4a11      	ldr	r2, [pc, #68]	; (49e8 <os_idle_task+0x48>)
    49a4:	6813      	ldr	r3, [r2, #0]
    49a6:	3301      	adds	r3, #1
    49a8:	6013      	str	r3, [r2, #0]
        OS_ENTER_CRITICAL(sr);
    49aa:	f000 f861 	bl	4a70 <os_arch_save_sr>
    49ae:	4605      	mov	r5, r0
        now = os_time_get();
    49b0:	f000 fc92 	bl	52d8 <os_time_get>
    49b4:	4606      	mov	r6, r0
        sticks = os_sched_wakeup_ticks(now);
    49b6:	f000 fbdd 	bl	5174 <os_sched_wakeup_ticks>
    49ba:	4604      	mov	r4, r0
        cticks = os_callout_wakeup_ticks(now);
    49bc:	4630      	mov	r0, r6
    49be:	f000 f901 	bl	4bc4 <os_callout_wakeup_ticks>
        iticks = min(sticks, cticks);
    49c2:	42a0      	cmp	r0, r4
    49c4:	bf28      	it	cs
    49c6:	4620      	movcs	r0, r4
        if (iticks < MIN_IDLE_TICKS) {
    49c8:	280b      	cmp	r0, #11
    49ca:	d905      	bls.n	49d8 <os_idle_task+0x38>
    49cc:	f5b0 3f96 	cmp.w	r0, #76800	; 0x12c00
    49d0:	bf28      	it	cs
    49d2:	f44f 3096 	movcs.w	r0, #76800	; 0x12c00
    49d6:	e000      	b.n	49da <os_idle_task+0x3a>
            iticks = 0;
    49d8:	2000      	movs	r0, #0
            /* NOTHING */
        }
        /* Tell the architecture specific support to put the processor to sleep
         * for 'n' ticks.
         */
        os_tick_idle(iticks);
    49da:	f001 fa29 	bl	5e30 <os_tick_idle>
        OS_EXIT_CRITICAL(sr);
    49de:	4628      	mov	r0, r5
    49e0:	f000 f84c 	bl	4a7c <os_arch_restore_sr>
    }
    49e4:	e7dd      	b.n	49a2 <os_idle_task+0x2>
    49e6:	bf00      	nop
    49e8:	20000d40 	.word	0x20000d40

000049ec <os_init_idle_task>:
}


void
os_init_idle_task(void)
{
    49ec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    os_task_init(&g_idle_task, "idle", os_idle_task, NULL,
    49ee:	22ff      	movs	r2, #255	; 0xff
    49f0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    49f4:	e88d 000c 	stmia.w	sp, {r2, r3}
    49f8:	4b06      	ldr	r3, [pc, #24]	; (4a14 <os_init_idle_task+0x28>)
    49fa:	9302      	str	r3, [sp, #8]
    49fc:	2340      	movs	r3, #64	; 0x40
    49fe:	9303      	str	r3, [sp, #12]
    4a00:	4905      	ldr	r1, [pc, #20]	; (4a18 <os_init_idle_task+0x2c>)
    4a02:	4a06      	ldr	r2, [pc, #24]	; (4a1c <os_init_idle_task+0x30>)
    4a04:	4806      	ldr	r0, [pc, #24]	; (4a20 <os_init_idle_task+0x34>)
    4a06:	2300      	movs	r3, #0
    4a08:	f000 fbea 	bl	51e0 <os_task_init>
            OS_IDLE_PRIO, OS_WAIT_FOREVER, g_idle_task_stack,
            OS_STACK_ALIGN(OS_IDLE_STACK_SIZE));
}
    4a0c:	b005      	add	sp, #20
    4a0e:	f85d fb04 	ldr.w	pc, [sp], #4
    4a12:	bf00      	nop
    4a14:	20000d44 	.word	0x20000d44
    4a18:	000064a4 	.word	0x000064a4
    4a1c:	000049a1 	.word	0x000049a1
    4a20:	20000cf0 	.word	0x20000cf0

00004a24 <os_init>:
void
os_init(void)
{
    os_error_t err;

    TAILQ_INIT(&g_callout_list);
    4a24:	4b08      	ldr	r3, [pc, #32]	; (4a48 <os_init+0x24>)
 * Initialize the operating system, calls into the architecture specific
 * support to initialize the operating system.
 */
void
os_init(void)
{
    4a26:	b510      	push	{r4, lr}
    os_error_t err;

    TAILQ_INIT(&g_callout_list);
    4a28:	2400      	movs	r4, #0
    4a2a:	601c      	str	r4, [r3, #0]
    4a2c:	605b      	str	r3, [r3, #4]
    STAILQ_INIT(&g_os_task_list);
    4a2e:	4b07      	ldr	r3, [pc, #28]	; (4a4c <os_init+0x28>)
    4a30:	601c      	str	r4, [r3, #0]
    4a32:	605b      	str	r3, [r3, #4]

    err = os_arch_os_init();
    4a34:	f000 f852 	bl	4adc <os_arch_os_init>
    assert(err == OS_OK);
    4a38:	b128      	cbz	r0, 4a46 <os_init+0x22>
    4a3a:	4805      	ldr	r0, [pc, #20]	; (4a50 <os_init+0x2c>)
    4a3c:	2171      	movs	r1, #113	; 0x71
    4a3e:	4622      	mov	r2, r4
    4a40:	4623      	mov	r3, r4
    4a42:	f000 f903 	bl	4c4c <__assert_func>
    4a46:	bd10      	pop	{r4, pc}
    4a48:	20000e48 	.word	0x20000e48
    4a4c:	20000e58 	.word	0x20000e58
    4a50:	000064a9 	.word	0x000064a9

00004a54 <timer_handler>:
uint32_t os_flags = OS_RUN_PRIV;

void
timer_handler(void)
{
    os_time_advance(1);
    4a54:	2001      	movs	r0, #1
    4a56:	f000 bc45 	b.w	52e4 <os_time_advance>
	...

00004a5c <os_arch_ctx_sw>:
}

void
os_arch_ctx_sw(struct os_task *t)
{
    4a5c:	b508      	push	{r3, lr}
    os_sched_ctx_sw_hook(t);
    4a5e:	f000 fac1 	bl	4fe4 <os_sched_ctx_sw_hook>

    /* Set PendSV interrupt pending bit to force context switch */
    SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
    4a62:	4b02      	ldr	r3, [pc, #8]	; (4a6c <os_arch_ctx_sw+0x10>)
    4a64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    4a68:	605a      	str	r2, [r3, #4]
    4a6a:	bd08      	pop	{r3, pc}
    4a6c:	e000ed00 	.word	0xe000ed00

00004a70 <os_arch_save_sr>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    4a70:	f3ef 8010 	mrs	r0, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    4a74:	b672      	cpsid	i
    uint32_t isr_ctx;

    isr_ctx = __get_PRIMASK();
    __disable_irq();
    return (isr_ctx & 1);
}
    4a76:	f000 0001 	and.w	r0, r0, #1
    4a7a:	4770      	bx	lr

00004a7c <os_arch_restore_sr>:

void
os_arch_restore_sr(os_sr_t isr_ctx)
{
    if (!isr_ctx) {
    4a7c:	b900      	cbnz	r0, 4a80 <os_arch_restore_sr+0x4>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    4a7e:	b662      	cpsie	i
    4a80:	4770      	bx	lr

00004a82 <os_arch_in_critical>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    4a82:	f3ef 8010 	mrs	r0, PRIMASK
{
    uint32_t isr_ctx;

    isr_ctx = __get_PRIMASK();
    return (isr_ctx & 1);
}
    4a86:	f000 0001 	and.w	r0, r0, #1
    4a8a:	4770      	bx	lr

00004a8c <os_arch_task_stack_init>:

os_stack_t *
os_arch_task_stack_init(struct os_task *t, os_stack_t *stack_top, int size)
{
    4a8c:	b570      	push	{r4, r5, r6, lr}
    4a8e:	f1a1 0320 	sub.w	r3, r1, #32
    4a92:	4606      	mov	r6, r0
    4a94:	460c      	mov	r4, r1
    int i;
    os_stack_t *s;
    struct stack_frame *sf;

    /* Get stack frame pointer */
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));
    4a96:	f1a1 0540 	sub.w	r5, r1, #64	; 0x40
    4a9a:	f1a1 020c 	sub.w	r2, r1, #12

    /* Zero out R1-R3, R12, LR */
    for (i = 9; i < 14; ++i) {
        s[i] = 0;
    4a9e:	2100      	movs	r1, #0
    4aa0:	f843 1f04 	str.w	r1, [r3, #4]!

    /* Get stack frame pointer */
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));

    /* Zero out R1-R3, R12, LR */
    for (i = 9; i < 14; ++i) {
    4aa4:	4293      	cmp	r3, r2
    4aa6:	d1fa      	bne.n	4a9e <os_arch_task_stack_init+0x12>
        s[i] = 0;
    }

    /* Set registers R4 - R11 on stack. */
    os_arch_init_task_stack(s);
    4aa8:	4628      	mov	r0, r5
    4aaa:	f000 fc5e 	bl	536a <os_arch_init_task_stack>

    /* Set remaining portions of stack frame */
    sf = (struct stack_frame *) s;
    sf->xpsr = INITIAL_xPSR;
    4aae:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    4ab2:	f844 3c04 	str.w	r3, [r4, #-4]
    sf->pc = (uint32_t)t->t_func;
    4ab6:	6973      	ldr	r3, [r6, #20]
    4ab8:	f844 3c08 	str.w	r3, [r4, #-8]
    sf->r0 = (uint32_t)t->t_arg;
    4abc:	69b3      	ldr	r3, [r6, #24]
    4abe:	f844 3c20 	str.w	r3, [r4, #-32]

    return (s);
}
    4ac2:	4628      	mov	r0, r5
    4ac4:	bd70      	pop	{r4, r5, r6, pc}
	...

00004ac8 <os_arch_init>:
os_arch_init(void)
{
    /*
     * Trap on divide-by-zero.
     */
    SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    4ac8:	4a03      	ldr	r2, [pc, #12]	; (4ad8 <os_arch_init+0x10>)
    4aca:	6953      	ldr	r3, [r2, #20]
    4acc:	f043 0310 	orr.w	r3, r3, #16
    4ad0:	6153      	str	r3, [r2, #20]
    os_init_idle_task();
    4ad2:	f7ff bf8b 	b.w	49ec <os_init_idle_task>
    4ad6:	bf00      	nop
    4ad8:	e000ed00 	.word	0xe000ed00

00004adc <os_arch_os_init>:
    SVC_Call(os_arch_init);
}

os_error_t
os_arch_os_init(void)
{
    4adc:	b538      	push	{r3, r4, r5, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    4ade:	f3ef 8305 	mrs	r3, IPSR
    os_error_t err;
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
    4ae2:	2b00      	cmp	r3, #0
    4ae4:	d141      	bne.n	4b6a <os_arch_os_init+0x8e>
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
            NVIC->IP[i] = 0xff;
    4ae6:	f103 4260 	add.w	r2, r3, #3758096384	; 0xe0000000
    4aea:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    4aee:	3301      	adds	r3, #1
            NVIC->IP[i] = 0xff;
    4af0:	21ff      	movs	r1, #255	; 0xff
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    4af2:	2bf0      	cmp	r3, #240	; 0xf0
            NVIC->IP[i] = 0xff;
    4af4:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    4af8:	d1f5      	bne.n	4ae6 <os_arch_os_init+0xa>
        /*
         * Install default interrupt handler, which'll print out system
         * state at the time of the interrupt, and few other regs which
         * should help in trying to figure out what went wrong.
         */
        NVIC_SetVector(NonMaskableInt_IRQn, (uint32_t)os_default_irq_asm);
    4afa:	f06f 000d 	mvn.w	r0, #13
    4afe:	491c      	ldr	r1, [pc, #112]	; (4b70 <os_arch_os_init+0x94>)
    4b00:	f7ff fac4 	bl	408c <NVIC_SetVector>
        NVIC_SetVector(-13, (uint32_t)os_default_irq_asm);
    4b04:	f06f 000c 	mvn.w	r0, #12
    4b08:	4919      	ldr	r1, [pc, #100]	; (4b70 <os_arch_os_init+0x94>)
    4b0a:	f7ff fabf 	bl	408c <NVIC_SetVector>
        NVIC_SetVector(MemoryManagement_IRQn, (uint32_t)os_default_irq_asm);
    4b0e:	f06f 000b 	mvn.w	r0, #11
    4b12:	4917      	ldr	r1, [pc, #92]	; (4b70 <os_arch_os_init+0x94>)
    4b14:	f7ff faba 	bl	408c <NVIC_SetVector>
        NVIC_SetVector(BusFault_IRQn, (uint32_t)os_default_irq_asm);
    4b18:	f06f 000a 	mvn.w	r0, #10
    4b1c:	4914      	ldr	r1, [pc, #80]	; (4b70 <os_arch_os_init+0x94>)
    4b1e:	f7ff fab5 	bl	408c <NVIC_SetVector>
        NVIC_SetVector(UsageFault_IRQn, (uint32_t)os_default_irq_asm);
    4b22:	f06f 0009 	mvn.w	r0, #9
    4b26:	4912      	ldr	r1, [pc, #72]	; (4b70 <os_arch_os_init+0x94>)
    4b28:	f7ff fab0 	bl	408c <NVIC_SetVector>
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    4b2c:	2400      	movs	r4, #0
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
    4b2e:	b260      	sxtb	r0, r4
    4b30:	490f      	ldr	r1, [pc, #60]	; (4b70 <os_arch_os_init+0x94>)
        NVIC_SetVector(NonMaskableInt_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(-13, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(MemoryManagement_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(BusFault_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(UsageFault_IRQn, (uint32_t)os_default_irq_asm);
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    4b32:	3401      	adds	r4, #1
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
    4b34:	f7ff faaa 	bl	408c <NVIC_SetVector>
        NVIC_SetVector(NonMaskableInt_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(-13, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(MemoryManagement_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(BusFault_IRQn, (uint32_t)os_default_irq_asm);
        NVIC_SetVector(UsageFault_IRQn, (uint32_t)os_default_irq_asm);
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    4b38:	2c26      	cmp	r4, #38	; 0x26
    4b3a:	d1f8      	bne.n	4b2e <os_arch_os_init+0x52>
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
    4b3c:	4c0d      	ldr	r4, [pc, #52]	; (4b74 <os_arch_os_init+0x98>)
    4b3e:	25e0      	movs	r5, #224	; 0xe0
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
        }

        /* Call bsp related OS initializations */
        bsp_init();
    4b40:	f001 f80c 	bl	5b5c <bsp_init>
    4b44:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
    4b48:	2520      	movs	r5, #32
    4b4a:	77e5      	strb	r5, [r4, #31]
        /*
         * Set the os environment. This will set stack pointers and, based
         * on the contents of os_flags, will determine if the tasks run in
         * priviliged or un-privileged mode.
         */
        os_set_env();
    4b4c:	f000 fc02 	bl	5354 <os_set_env>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    4b50:	f3ef 8414 	mrs	r4, CONTROL

        /* Check if privileged or not */
        if ((__get_CONTROL() & 1) == 0) {
    4b54:	f014 0401 	ands.w	r4, r4, #1
    4b58:	d102      	bne.n	4b60 <os_arch_os_init+0x84>
            os_arch_init();
    4b5a:	f7ff ffb5 	bl	4ac8 <os_arch_init>
    4b5e:	e002      	b.n	4b66 <os_arch_os_init+0x8a>
__attribute__((always_inline))
static inline void
svc_os_arch_init(void)
{
    SVC_Arg0();
    SVC_Call(os_arch_init);
    4b60:	f8df c014 	ldr.w	ip, [pc, #20]	; 4b78 <os_arch_os_init+0x9c>
    4b64:	df00      	svc	0
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    if (__get_IPSR() == 0) {
        err = OS_OK;
    4b66:	2000      	movs	r0, #0
    4b68:	bd38      	pop	{r3, r4, r5, pc}
{
    os_error_t err;
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    4b6a:	2007      	movs	r0, #7
            svc_os_arch_init();
        }
    }

    return err;
}
    4b6c:	bd38      	pop	{r3, r4, r5, pc}
    4b6e:	bf00      	nop
    4b70:	000053ed 	.word	0x000053ed
    4b74:	e000ed00 	.word	0xe000ed00
    4b78:	00004ac9 	.word	0x00004ac9

00004b7c <os_callout_tick>:
 * to run, it posts an event for each callout that's ready to run,
 * to the event queue provided to os_callout_func_init().
 */
void
os_callout_tick(void)
{
    4b7c:	b538      	push	{r3, r4, r5, lr}
    os_sr_t sr;
    struct os_callout *c;
    uint32_t now;

    now = os_time_get();
    4b7e:	f000 fbab 	bl	52d8 <os_time_get>
    4b82:	4605      	mov	r5, r0

    while (1) {
        OS_ENTER_CRITICAL(sr);
    4b84:	f7ff ff74 	bl	4a70 <os_arch_save_sr>
        c = TAILQ_FIRST(&g_callout_list);
    4b88:	4a0d      	ldr	r2, [pc, #52]	; (4bc0 <os_callout_tick+0x44>)
    4b8a:	6814      	ldr	r4, [r2, #0]
        if (c) {
    4b8c:	b17c      	cbz	r4, 4bae <os_callout_tick+0x32>
            if (OS_TIME_TICK_GEQ(now, c->c_ticks)) {
    4b8e:	6923      	ldr	r3, [r4, #16]
    4b90:	1aeb      	subs	r3, r5, r3
    4b92:	2b00      	cmp	r3, #0
    4b94:	db0a      	blt.n	4bac <os_callout_tick+0x30>
                TAILQ_REMOVE(&g_callout_list, c, c_next);
    4b96:	6963      	ldr	r3, [r4, #20]
    4b98:	69a1      	ldr	r1, [r4, #24]
    4b9a:	b10b      	cbz	r3, 4ba0 <os_callout_tick+0x24>
    4b9c:	6199      	str	r1, [r3, #24]
    4b9e:	e000      	b.n	4ba2 <os_callout_tick+0x26>
    4ba0:	6051      	str	r1, [r2, #4]
    4ba2:	69a2      	ldr	r2, [r4, #24]
    4ba4:	6013      	str	r3, [r2, #0]
                c->c_next.tqe_prev = NULL;
    4ba6:	2300      	movs	r3, #0
    4ba8:	61a3      	str	r3, [r4, #24]
    4baa:	e000      	b.n	4bae <os_callout_tick+0x32>
    4bac:	2400      	movs	r4, #0
            } else {
                c = NULL;
            }
        }
        OS_EXIT_CRITICAL(sr);
    4bae:	f7ff ff65 	bl	4a7c <os_arch_restore_sr>

        if (c) {
    4bb2:	b124      	cbz	r4, 4bbe <os_callout_tick+0x42>
            os_eventq_put(c->c_evq, &c->c_ev);
    4bb4:	68e0      	ldr	r0, [r4, #12]
    4bb6:	4621      	mov	r1, r4
    4bb8:	f000 f81e 	bl	4bf8 <os_eventq_put>
        } else {
            break;
        }
    }
    4bbc:	e7e2      	b.n	4b84 <os_callout_tick+0x8>
    4bbe:	bd38      	pop	{r3, r4, r5, pc}
    4bc0:	20000e48 	.word	0x20000e48

00004bc4 <os_callout_wakeup_ticks>:
 *
 * @return Number of ticks to first pending callout
 */
os_time_t
os_callout_wakeup_ticks(os_time_t now)
{
    4bc4:	b510      	push	{r4, lr}
    4bc6:	4604      	mov	r4, r0
    os_time_t rt;
    struct os_callout *c;

    OS_ASSERT_CRITICAL();
    4bc8:	f7ff ff5b 	bl	4a82 <os_arch_in_critical>
    4bcc:	4602      	mov	r2, r0
    4bce:	b920      	cbnz	r0, 4bda <os_callout_wakeup_ticks+0x16>
    4bd0:	4807      	ldr	r0, [pc, #28]	; (4bf0 <os_callout_wakeup_ticks+0x2c>)
    4bd2:	21ba      	movs	r1, #186	; 0xba
    4bd4:	4613      	mov	r3, r2
    4bd6:	f000 f839 	bl	4c4c <__assert_func>

    c = TAILQ_FIRST(&g_callout_list);
    4bda:	4b06      	ldr	r3, [pc, #24]	; (4bf4 <os_callout_wakeup_ticks+0x30>)
    4bdc:	681b      	ldr	r3, [r3, #0]
    if (c != NULL) {
    4bde:	b123      	cbz	r3, 4bea <os_callout_wakeup_ticks+0x26>
        if (OS_TIME_TICK_GEQ(c->c_ticks, now)) {
    4be0:	6918      	ldr	r0, [r3, #16]
    4be2:	1b00      	subs	r0, r0, r4
            rt = c->c_ticks - now;
        } else {
            rt = 0;     /* callout time is in the past */
    4be4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    4be8:	bd10      	pop	{r4, pc}
        }
    } else {
        rt = OS_TIMEOUT_NEVER;
    4bea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }

    return (rt);
}
    4bee:	bd10      	pop	{r4, pc}
    4bf0:	000064ae 	.word	0x000064ae
    4bf4:	20000e48 	.word	0x20000e48

00004bf8 <os_eventq_put>:
 * @param evq The event queue to put an event on 
 * @param ev The event to put on the queue
 */
void
os_eventq_put(struct os_eventq *evq, struct os_event *ev)
{
    4bf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4bfa:	460d      	mov	r5, r1
    4bfc:	4606      	mov	r6, r0
    int resched;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    4bfe:	f7ff ff37 	bl	4a70 <os_arch_save_sr>

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
    4c02:	782b      	ldrb	r3, [r5, #0]
os_eventq_put(struct os_eventq *evq, struct os_event *ev)
{
    int resched;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    4c04:	4607      	mov	r7, r0

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
    4c06:	b11b      	cbz	r3, 4c10 <os_eventq_put+0x18>
    OS_EXIT_CRITICAL(sr);

    if (resched) {
        os_sched(NULL);
    }
}
    4c08:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

    OS_ENTER_CRITICAL(sr);

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
        OS_EXIT_CRITICAL(sr);
    4c0c:	f7ff bf36 	b.w	4a7c <os_arch_restore_sr>
        return;
    }

    /* Queue the event */
    ev->ev_queued = 1;
    4c10:	2401      	movs	r4, #1
    4c12:	702c      	strb	r4, [r5, #0]
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);
    4c14:	68b2      	ldr	r2, [r6, #8]
    4c16:	60ab      	str	r3, [r5, #8]
    4c18:	6015      	str	r5, [r2, #0]

    resched = 0;
    if (evq->evq_task) {
    4c1a:	6830      	ldr	r0, [r6, #0]
        return;
    }

    /* Queue the event */
    ev->ev_queued = 1;
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);
    4c1c:	3508      	adds	r5, #8
    4c1e:	60b5      	str	r5, [r6, #8]

    resched = 0;
    if (evq->evq_task) {
    4c20:	b148      	cbz	r0, 4c36 <os_eventq_put+0x3e>
        /* If task waiting on event, wake it up.
         * Check if task is sleeping, because another event 
         * queue may have woken this task up beforehand.
         */
        if (evq->evq_task->t_state == OS_TASK_SLEEP) {
    4c22:	7b82      	ldrb	r2, [r0, #14]
    4c24:	2a02      	cmp	r2, #2
    4c26:	d102      	bne.n	4c2e <os_eventq_put+0x36>
            os_sched_wakeup(evq->evq_task);
    4c28:	f000 fa4c 	bl	50c4 <os_sched_wakeup>
    4c2c:	e000      	b.n	4c30 <os_eventq_put+0x38>

    /* Queue the event */
    ev->ev_queued = 1;
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);

    resched = 0;
    4c2e:	461c      	mov	r4, r3
            resched = 1;
        }
        /* Either way, NULL out the task, because the task will
         * be awake upon exit of this function.
         */
        evq->evq_task = NULL;
    4c30:	2300      	movs	r3, #0
    4c32:	6033      	str	r3, [r6, #0]
    4c34:	e000      	b.n	4c38 <os_eventq_put+0x40>

    /* Queue the event */
    ev->ev_queued = 1;
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);

    resched = 0;
    4c36:	4604      	mov	r4, r0
         * be awake upon exit of this function.
         */
        evq->evq_task = NULL;
    }

    OS_EXIT_CRITICAL(sr);
    4c38:	4638      	mov	r0, r7
    4c3a:	f7ff ff1f 	bl	4a7c <os_arch_restore_sr>

    if (resched) {
    4c3e:	b124      	cbz	r4, 4c4a <os_eventq_put+0x52>
        os_sched(NULL);
    4c40:	2000      	movs	r0, #0
    }
}
    4c42:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }

    OS_EXIT_CRITICAL(sr);

    if (resched) {
        os_sched(NULL);
    4c46:	f000 b9eb 	b.w	5020 <os_sched>
    4c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00004c4c <__assert_func>:
}
#endif

void
__assert_func(const char *file, int line, const char *func, const char *e)
{
    4c4c:	b508      	push	{r3, lr}
    int sr;

    OS_ENTER_CRITICAL(sr);
    4c4e:	f7ff ff0f 	bl	4a70 <os_arch_save_sr>
    (void)sr;
    console_blocking_mode();
    console_printf("Assert %s; failed in %s:%d\n", e ? e : "", file, line);
    if (system_debugger_connected()) {
    4c52:	f001 f929 	bl	5ea8 <system_debugger_connected>
    4c56:	b100      	cbz	r0, 4c5a <__assert_func+0xe>
       /*
        * If debugger is attached, breakpoint before the trap.
        */
       asm("bkpt");
    4c58:	be00      	bkpt	0x0000
    }
    SCB->ICSR = SCB_ICSR_NMIPENDSET_Msk;
    4c5a:	4b04      	ldr	r3, [pc, #16]	; (4c6c <__assert_func+0x20>)
    4c5c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    4c60:	605a      	str	r2, [r3, #4]
    asm("isb");
    4c62:	f3bf 8f6f 	isb	sy
    system_reset();
    4c66:	f001 f907 	bl	5e78 <system_reset>
    4c6a:	bf00      	nop
    4c6c:	e000ed00 	.word	0xe000ed00

00004c70 <os_default_irq>:
}

void
os_default_irq(struct trap_frame *tf)
{
    4c70:	b508      	push	{r3, lr}
    struct coredump_regs regs;
#endif

    console_blocking_mode();
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    4c72:	4b04      	ldr	r3, [pc, #16]	; (4c84 <os_default_irq+0x14>)
    4c74:	685a      	ldr	r2, [r3, #4]
      tf->r4, tf->r5, tf->r6, tf->r7);
    console_printf(" r8:0x%08lx  r9:0x%08lx r10:0x%08lx r11:0x%08lx\n",
      tf->r8, tf->r9, tf->r10, tf->r11);
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
      tf->ef->r12, tf->ef->lr, tf->ef->pc, tf->ef->psr);
    console_printf("ICSR:0x%08lx HFSR:0x%08lx CFSR:0x%08lx\n",
    4c76:	685a      	ldr	r2, [r3, #4]
    4c78:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4c7a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
      SCB->ICSR, SCB->HFSR, SCB->CFSR);
    console_printf("BFAR:0x%08lx MMFAR:0x%08lx\n", SCB->BFAR, SCB->MMFAR);
    4c7c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    4c7e:	6b5b      	ldr	r3, [r3, #52]	; 0x34

#ifdef COREDUMP_PRESENT
    trap_to_coredump(tf, &regs);
    coredump_dump(&regs, sizeof(regs));
#endif
    system_reset();
    4c80:	f001 f8fa 	bl	5e78 <system_reset>
    4c84:	e000ed00 	.word	0xe000ed00

00004c88 <os_malloc_lock>:

static struct os_mutex os_malloc_mutex;

static void
os_malloc_lock(void)
{
    4c88:	b508      	push	{r3, lr}
    int rc;

    if (g_os_started) {
    4c8a:	4b08      	ldr	r3, [pc, #32]	; (4cac <os_malloc_lock+0x24>)
    4c8c:	681b      	ldr	r3, [r3, #0]
    4c8e:	b15b      	cbz	r3, 4ca8 <os_malloc_lock+0x20>
        rc = os_mutex_pend(&os_malloc_mutex, 0xffffffff);
    4c90:	4807      	ldr	r0, [pc, #28]	; (4cb0 <os_malloc_lock+0x28>)
    4c92:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4c96:	f000 f90f 	bl	4eb8 <os_mutex_pend>
        assert(rc == 0);
    4c9a:	b128      	cbz	r0, 4ca8 <os_malloc_lock+0x20>
    4c9c:	2200      	movs	r2, #0
    4c9e:	4805      	ldr	r0, [pc, #20]	; (4cb4 <os_malloc_lock+0x2c>)
    4ca0:	2122      	movs	r1, #34	; 0x22
    4ca2:	4613      	mov	r3, r2
    4ca4:	f7ff ffd2 	bl	4c4c <__assert_func>
    4ca8:	bd08      	pop	{r3, pc}
    4caa:	bf00      	nop
    4cac:	20000e44 	.word	0x20000e44
    4cb0:	20000a30 	.word	0x20000a30
    4cb4:	000064bb 	.word	0x000064bb

00004cb8 <os_malloc_unlock>:
    }
}

static void
os_malloc_unlock(void)
{
    4cb8:	b508      	push	{r3, lr}
    int rc;

    if (g_os_started) {
    4cba:	4b07      	ldr	r3, [pc, #28]	; (4cd8 <os_malloc_unlock+0x20>)
    4cbc:	681b      	ldr	r3, [r3, #0]
    4cbe:	b14b      	cbz	r3, 4cd4 <os_malloc_unlock+0x1c>
        rc = os_mutex_release(&os_malloc_mutex);
    4cc0:	4806      	ldr	r0, [pc, #24]	; (4cdc <os_malloc_unlock+0x24>)
    4cc2:	f000 f8b1 	bl	4e28 <os_mutex_release>
        assert(rc == 0);
    4cc6:	b128      	cbz	r0, 4cd4 <os_malloc_unlock+0x1c>
    4cc8:	2200      	movs	r2, #0
    4cca:	4805      	ldr	r0, [pc, #20]	; (4ce0 <os_malloc_unlock+0x28>)
    4ccc:	212d      	movs	r1, #45	; 0x2d
    4cce:	4613      	mov	r3, r2
    4cd0:	f7ff ffbc 	bl	4c4c <__assert_func>
    4cd4:	bd08      	pop	{r3, pc}
    4cd6:	bf00      	nop
    4cd8:	20000e44 	.word	0x20000e44
    4cdc:	20000a30 	.word	0x20000a30
    4ce0:	000064bb 	.word	0x000064bb

00004ce4 <os_malloc>:
 *
 * @return A pointer to the memory region allocated.
 */
void *
os_malloc(size_t size)
{
    4ce4:	b510      	push	{r4, lr}
    4ce6:	4604      	mov	r4, r0
    void *ptr;

    os_malloc_lock();
    4ce8:	f7ff ffce 	bl	4c88 <os_malloc_lock>
    ptr = malloc(size);
    4cec:	4620      	mov	r0, r4
    4cee:	f7fe fdd9 	bl	38a4 <malloc>
    4cf2:	4604      	mov	r4, r0
    os_malloc_unlock();
    4cf4:	f7ff ffe0 	bl	4cb8 <os_malloc_unlock>

    return ptr;
}
    4cf8:	4620      	mov	r0, r4
    4cfa:	bd10      	pop	{r4, pc}

00004cfc <os_free>:
 *
 * @param mem The memory to free.
 */
void
os_free(void *mem)
{
    4cfc:	b510      	push	{r4, lr}
    4cfe:	4604      	mov	r4, r0
    os_malloc_lock();
    4d00:	f7ff ffc2 	bl	4c88 <os_malloc_lock>
    free(mem);
    4d04:	4620      	mov	r0, r4
    4d06:	f7fe fe17 	bl	3938 <free>
    os_malloc_unlock();
}
    4d0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void
os_free(void *mem)
{
    os_malloc_lock();
    free(mem);
    os_malloc_unlock();
    4d0e:	f7ff bfd3 	b.w	4cb8 <os_malloc_unlock>

00004d12 <os_realloc>:
 *
 * @return A pointer to memory of size, or NULL on failure to allocate
 */
void *
os_realloc(void *ptr, size_t size)
{
    4d12:	b538      	push	{r3, r4, r5, lr}
    4d14:	4605      	mov	r5, r0
    4d16:	460c      	mov	r4, r1
    void *new_ptr;

    os_malloc_lock();
    4d18:	f7ff ffb6 	bl	4c88 <os_malloc_lock>
    new_ptr = realloc(ptr, size);
    4d1c:	4621      	mov	r1, r4
    4d1e:	4628      	mov	r0, r5
    4d20:	f001 f8e3 	bl	5eea <realloc>
    4d24:	4604      	mov	r4, r0
    os_malloc_unlock();
    4d26:	f7ff ffc7 	bl	4cb8 <os_malloc_unlock>

    return new_ptr;
}
    4d2a:	4620      	mov	r0, r4
    4d2c:	bd38      	pop	{r3, r4, r5, pc}
	...

00004d30 <os_mempool_init>:
 * @return os_error_t 
 */
os_error_t
os_mempool_init(struct os_mempool *mp, int blocks, int block_size, void *membuf,
                char *name)
{
    4d30:	b570      	push	{r4, r5, r6, lr}
    int true_block_size;
    uint8_t *block_addr;
    struct os_memblock *block_ptr;

    /* Check for valid parameters */
    if ((!mp) || (!membuf) || (blocks <= 0) || (block_size <= 0)) {
    4d32:	b350      	cbz	r0, 4d8a <os_mempool_init+0x5a>
    4d34:	b34b      	cbz	r3, 4d8a <os_mempool_init+0x5a>
    4d36:	2900      	cmp	r1, #0
    4d38:	dd27      	ble.n	4d8a <os_mempool_init+0x5a>
    4d3a:	2a00      	cmp	r2, #0
    4d3c:	dd25      	ble.n	4d8a <os_mempool_init+0x5a>
        return OS_INVALID_PARM;
    }

    /* Blocks need to be sized properly and memory buffer should be aligned */
    if (((uint32_t)membuf & (OS_ALIGNMENT - 1)) != 0) {
    4d3e:	079c      	lsls	r4, r3, #30
    4d40:	d125      	bne.n	4d8e <os_mempool_init+0x5e>
        return OS_MEM_NOT_ALIGNED;
    }
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(block_size);
    4d42:	f012 0403 	ands.w	r4, r2, #3
    4d46:	bf1a      	itte	ne
    4d48:	f1c4 0404 	rsbne	r4, r4, #4
    4d4c:	18a4      	addne	r4, r4, r2
    4d4e:	4614      	moveq	r4, r2

    /* Initialize the memory pool structure */
    mp->mp_block_size = block_size;
    4d50:	6002      	str	r2, [r0, #0]
    mp->mp_num_free = blocks;
    mp->mp_num_blocks = blocks;
    mp->mp_membuf_addr = (uint32_t)membuf;
    mp->name = name;
    4d52:	9a04      	ldr	r2, [sp, #16]
    4d54:	6182      	str	r2, [r0, #24]
    }
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(block_size);

    /* Initialize the memory pool structure */
    mp->mp_block_size = block_size;
    mp->mp_num_free = blocks;
    4d56:	6081      	str	r1, [r0, #8]
    mp->mp_num_blocks = blocks;
    4d58:	6041      	str	r1, [r0, #4]
    mp->mp_membuf_addr = (uint32_t)membuf;
    4d5a:	60c3      	str	r3, [r0, #12]
    mp->name = name;
    SLIST_FIRST(mp) = membuf;
    4d5c:	6143      	str	r3, [r0, #20]

    /* Chain the memory blocks to the free list */
    block_addr = (uint8_t *)membuf;
    block_ptr = (struct os_memblock *)block_addr;
    while (blocks > 1) {
    4d5e:	461d      	mov	r5, r3
    4d60:	460a      	mov	r2, r1
    4d62:	2a01      	cmp	r2, #1
    4d64:	d004      	beq.n	4d70 <os_mempool_init+0x40>
    4d66:	192e      	adds	r6, r5, r4
        block_addr += true_block_size;
        SLIST_NEXT(block_ptr, mb_next) = (struct os_memblock *)block_addr;
    4d68:	602e      	str	r6, [r5, #0]
        block_ptr = (struct os_memblock *)block_addr;
        --blocks;
    4d6a:	3a01      	subs	r2, #1

    /* Chain the memory blocks to the free list */
    block_addr = (uint8_t *)membuf;
    block_ptr = (struct os_memblock *)block_addr;
    while (blocks > 1) {
        block_addr += true_block_size;
    4d6c:	4635      	mov	r5, r6
    4d6e:	e7f8      	b.n	4d62 <os_mempool_init+0x32>
    4d70:	3901      	subs	r1, #1
    4d72:	4361      	muls	r1, r4
        block_ptr = (struct os_memblock *)block_addr;
        --blocks;
    }

    /* Last one in the list should be NULL */
    SLIST_NEXT(block_ptr, mb_next) = NULL;
    4d74:	2200      	movs	r2, #0
    4d76:	505a      	str	r2, [r3, r1]

    STAILQ_INSERT_TAIL(&g_os_mempool_list, mp, mp_list);
    4d78:	4906      	ldr	r1, [pc, #24]	; (4d94 <os_mempool_init+0x64>)
    4d7a:	6102      	str	r2, [r0, #16]
    4d7c:	684b      	ldr	r3, [r1, #4]
    4d7e:	6018      	str	r0, [r3, #0]
    4d80:	f100 0310 	add.w	r3, r0, #16
    4d84:	604b      	str	r3, [r1, #4]

    return OS_OK;
    4d86:	4610      	mov	r0, r2
    4d88:	bd70      	pop	{r4, r5, r6, pc}
    uint8_t *block_addr;
    struct os_memblock *block_ptr;

    /* Check for valid parameters */
    if ((!mp) || (!membuf) || (blocks <= 0) || (block_size <= 0)) {
        return OS_INVALID_PARM;
    4d8a:	2003      	movs	r0, #3
    4d8c:	bd70      	pop	{r4, r5, r6, pc}
    }

    /* Blocks need to be sized properly and memory buffer should be aligned */
    if (((uint32_t)membuf & (OS_ALIGNMENT - 1)) != 0) {
        return OS_MEM_NOT_ALIGNED;
    4d8e:	2004      	movs	r0, #4
    SLIST_NEXT(block_ptr, mb_next) = NULL;

    STAILQ_INSERT_TAIL(&g_os_mempool_list, mp, mp_list);

    return OS_OK;
}
    4d90:	bd70      	pop	{r4, r5, r6, pc}
    4d92:	bf00      	nop
    4d94:	20000130 	.word	0x20000130

00004d98 <os_memblock_get>:
 * 
 * @return void* Pointer to block if available; NULL otherwise
 */
void *
os_memblock_get(struct os_mempool *mp)
{
    4d98:	b538      	push	{r3, r4, r5, lr}
    os_sr_t sr;
    struct os_memblock *block;

    /* Check to make sure they passed in a memory pool (or something) */
    block = NULL;
    if (mp) {
    4d9a:	4604      	mov	r4, r0
    4d9c:	b168      	cbz	r0, 4dba <os_memblock_get+0x22>
        OS_ENTER_CRITICAL(sr);
    4d9e:	f7ff fe67 	bl	4a70 <os_arch_save_sr>
        /* Check for any free */
        if (mp->mp_num_free) {
    4da2:	68a3      	ldr	r3, [r4, #8]
    4da4:	b12b      	cbz	r3, 4db2 <os_memblock_get+0x1a>
            /* Get a free block */
            block = SLIST_FIRST(mp);
    4da6:	6965      	ldr	r5, [r4, #20]

            /* Set new free list head */
            SLIST_FIRST(mp) = SLIST_NEXT(block, mb_next);

            /* Decrement number free by 1 */
            mp->mp_num_free--;
    4da8:	3b01      	subs	r3, #1
        if (mp->mp_num_free) {
            /* Get a free block */
            block = SLIST_FIRST(mp);

            /* Set new free list head */
            SLIST_FIRST(mp) = SLIST_NEXT(block, mb_next);
    4daa:	682a      	ldr	r2, [r5, #0]
    4dac:	6162      	str	r2, [r4, #20]

            /* Decrement number free by 1 */
            mp->mp_num_free--;
    4dae:	60a3      	str	r3, [r4, #8]
    4db0:	e000      	b.n	4db4 <os_memblock_get+0x1c>
{
    os_sr_t sr;
    struct os_memblock *block;

    /* Check to make sure they passed in a memory pool (or something) */
    block = NULL;
    4db2:	461d      	mov	r5, r3
            SLIST_FIRST(mp) = SLIST_NEXT(block, mb_next);

            /* Decrement number free by 1 */
            mp->mp_num_free--;
        }
        OS_EXIT_CRITICAL(sr);
    4db4:	f7ff fe62 	bl	4a7c <os_arch_restore_sr>
    4db8:	e000      	b.n	4dbc <os_memblock_get+0x24>
{
    os_sr_t sr;
    struct os_memblock *block;

    /* Check to make sure they passed in a memory pool (or something) */
    block = NULL;
    4dba:	4605      	mov	r5, r0
        }
        OS_EXIT_CRITICAL(sr);
    }

    return (void *)block;
}
    4dbc:	4628      	mov	r0, r5
    4dbe:	bd38      	pop	{r3, r4, r5, pc}

00004dc0 <os_memblock_put>:
 * 
 * @return os_error_t 
 */
os_error_t
os_memblock_put(struct os_mempool *mp, void *block_addr)
{
    4dc0:	b570      	push	{r4, r5, r6, lr}
    4dc2:	460e      	mov	r6, r1
    uint32_t true_block_size;
    uint32_t baddr32;
    struct os_memblock *block;

    /* Make sure parameters are valid */
    if ((mp == NULL) || (block_addr == NULL)) {
    4dc4:	4605      	mov	r5, r0
    4dc6:	b310      	cbz	r0, 4e0e <os_memblock_put+0x4e>
    4dc8:	b309      	cbz	r1, 4e0e <os_memblock_put+0x4e>
        return OS_INVALID_PARM;
    }

    /* Check that the block we are freeing is a valid block! */
    baddr32 = (uint32_t)block_addr;
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(mp->mp_block_size);
    4dca:	6804      	ldr	r4, [r0, #0]
    end = mp->mp_membuf_addr + (mp->mp_num_blocks * true_block_size);
    4dcc:	68c0      	ldr	r0, [r0, #12]
    4dce:	686b      	ldr	r3, [r5, #4]
        return OS_INVALID_PARM;
    }

    /* Check that the block we are freeing is a valid block! */
    baddr32 = (uint32_t)block_addr;
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(mp->mp_block_size);
    4dd0:	f014 0203 	ands.w	r2, r4, #3
    4dd4:	bf16      	itet	ne
    4dd6:	f1c2 0204 	rsbne	r2, r2, #4
    4dda:	4622      	moveq	r2, r4
    4ddc:	1912      	addne	r2, r2, r4
    end = mp->mp_membuf_addr + (mp->mp_num_blocks * true_block_size);
    if ((baddr32 < mp->mp_membuf_addr) || (baddr32 >= end)) {
    4dde:	4281      	cmp	r1, r0
    4de0:	d315      	bcc.n	4e0e <os_memblock_put+0x4e>
    }

    /* Check that the block we are freeing is a valid block! */
    baddr32 = (uint32_t)block_addr;
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(mp->mp_block_size);
    end = mp->mp_membuf_addr + (mp->mp_num_blocks * true_block_size);
    4de2:	fb03 0302 	mla	r3, r3, r2, r0
    if ((baddr32 < mp->mp_membuf_addr) || (baddr32 >= end)) {
    4de6:	4299      	cmp	r1, r3
    4de8:	d211      	bcs.n	4e0e <os_memblock_put+0x4e>
        return OS_INVALID_PARM;
    }

    /* All freed blocks should be on true block size boundaries! */
    if (((baddr32 - mp->mp_membuf_addr) % true_block_size) != 0) {
    4dea:	1a08      	subs	r0, r1, r0
    4dec:	fbb0 f3f2 	udiv	r3, r0, r2
    4df0:	fb02 0413 	mls	r4, r2, r3, r0
    4df4:	b95c      	cbnz	r4, 4e0e <os_memblock_put+0x4e>
     * XXX: we should do boundary checks here! The block had better be within 
     * the pool. If it fails, do we return an error or assert()? Add this when 
     * we add the memory debug. 
     */ 
    block = (struct os_memblock *)block_addr;
    OS_ENTER_CRITICAL(sr);
    4df6:	f7ff fe3b 	bl	4a70 <os_arch_save_sr>
    
    /* Chain current free list pointer to this block; make this block head */
    SLIST_NEXT(block, mb_next) = SLIST_FIRST(mp);
    4dfa:	696b      	ldr	r3, [r5, #20]
    4dfc:	6033      	str	r3, [r6, #0]
    SLIST_FIRST(mp) = block;

    /* XXX: Should we check that the number free <= number blocks? */
    /* Increment number free */
    mp->mp_num_free++;
    4dfe:	68ab      	ldr	r3, [r5, #8]
    block = (struct os_memblock *)block_addr;
    OS_ENTER_CRITICAL(sr);
    
    /* Chain current free list pointer to this block; make this block head */
    SLIST_NEXT(block, mb_next) = SLIST_FIRST(mp);
    SLIST_FIRST(mp) = block;
    4e00:	616e      	str	r6, [r5, #20]

    /* XXX: Should we check that the number free <= number blocks? */
    /* Increment number free */
    mp->mp_num_free++;
    4e02:	3301      	adds	r3, #1
    4e04:	60ab      	str	r3, [r5, #8]

    OS_EXIT_CRITICAL(sr);
    4e06:	f7ff fe39 	bl	4a7c <os_arch_restore_sr>

    return OS_OK;
    4e0a:	4620      	mov	r0, r4
    4e0c:	bd70      	pop	{r4, r5, r6, pc}
    uint32_t baddr32;
    struct os_memblock *block;

    /* Make sure parameters are valid */
    if ((mp == NULL) || (block_addr == NULL)) {
        return OS_INVALID_PARM;
    4e0e:	2003      	movs	r0, #3
    mp->mp_num_free++;

    OS_EXIT_CRITICAL(sr);

    return OS_OK;
}
    4e10:	bd70      	pop	{r4, r5, r6, pc}

00004e12 <os_mutex_init>:
 *      OS_OK               no error.
 */
os_error_t
os_mutex_init(struct os_mutex *mu)
{
    if (!mu) {
    4e12:	b130      	cbz	r0, 4e22 <os_mutex_init+0x10>
        return OS_INVALID_PARM;
    }

    /* Initialize to 0 */
    mu->mu_prio = 0;
    4e14:	2300      	movs	r3, #0
    4e16:	7143      	strb	r3, [r0, #5]
    mu->mu_level = 0;
    4e18:	80c3      	strh	r3, [r0, #6]
    mu->mu_owner = NULL;
    4e1a:	6083      	str	r3, [r0, #8]
    SLIST_FIRST(&mu->mu_head) = NULL;
    4e1c:	6003      	str	r3, [r0, #0]

    return OS_OK;
    4e1e:	4618      	mov	r0, r3
    4e20:	4770      	bx	lr
 */
os_error_t
os_mutex_init(struct os_mutex *mu)
{
    if (!mu) {
        return OS_INVALID_PARM;
    4e22:	2003      	movs	r0, #3
    mu->mu_level = 0;
    mu->mu_owner = NULL;
    SLIST_FIRST(&mu->mu_head) = NULL;

    return OS_OK;
}
    4e24:	4770      	bx	lr
	...

00004e28 <os_mutex_release>:
 *      OS_BAD_MUTEX    Mutex was not granted to current task (not owner).
 *      OS_OK           No error
 */
os_error_t
os_mutex_release(struct os_mutex *mu)
{
    4e28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_sr_t sr;
    struct os_task *current;
    struct os_task *rdy;

    /* Check if OS is started */
    if (!g_os_started) {
    4e2a:	4b21      	ldr	r3, [pc, #132]	; (4eb0 <os_mutex_release+0x88>)
    4e2c:	681b      	ldr	r3, [r3, #0]
 *      OS_BAD_MUTEX    Mutex was not granted to current task (not owner).
 *      OS_OK           No error
 */
os_error_t
os_mutex_release(struct os_mutex *mu)
{
    4e2e:	4604      	mov	r4, r0
    os_sr_t sr;
    struct os_task *current;
    struct os_task *rdy;

    /* Check if OS is started */
    if (!g_os_started) {
    4e30:	2b00      	cmp	r3, #0
    4e32:	d036      	beq.n	4ea2 <os_mutex_release+0x7a>
        return (OS_NOT_STARTED);
    }

    /* Check for valid mutex */
    if (!mu) {
    4e34:	2800      	cmp	r0, #0
    4e36:	d036      	beq.n	4ea6 <os_mutex_release+0x7e>
        return OS_INVALID_PARM;
    }

    /* We better own this mutex! */
    current = os_sched_get_current_task();
    4e38:	f000 f8ec 	bl	5014 <os_sched_get_current_task>
    if ((mu->mu_level == 0) || (mu->mu_owner != current)) {
    4e3c:	88e3      	ldrh	r3, [r4, #6]
    4e3e:	2b00      	cmp	r3, #0
    4e40:	d033      	beq.n	4eaa <os_mutex_release+0x82>
    4e42:	68a5      	ldr	r5, [r4, #8]
    4e44:	4285      	cmp	r5, r0
    4e46:	d130      	bne.n	4eaa <os_mutex_release+0x82>
        return (OS_BAD_MUTEX);
    }

    /* Decrement nesting level by 1. If not zero, nested (so dont release!) */
    --mu->mu_level;
    4e48:	3b01      	subs	r3, #1
    4e4a:	b29b      	uxth	r3, r3
    4e4c:	80e3      	strh	r3, [r4, #6]
    if (mu->mu_level != 0) {
    4e4e:	bb33      	cbnz	r3, 4e9e <os_mutex_release+0x76>
        return (OS_OK);
    }

    OS_ENTER_CRITICAL(sr);
    4e50:	f7ff fe0e 	bl	4a70 <os_arch_save_sr>

    /* Restore owner task's priority; resort list if different  */
    if (current->t_prio != mu->mu_prio) {
    4e54:	7963      	ldrb	r3, [r4, #5]
    4e56:	7b6a      	ldrb	r2, [r5, #13]
    4e58:	429a      	cmp	r2, r3
    --mu->mu_level;
    if (mu->mu_level != 0) {
        return (OS_OK);
    }

    OS_ENTER_CRITICAL(sr);
    4e5a:	4607      	mov	r7, r0

    /* Restore owner task's priority; resort list if different  */
    if (current->t_prio != mu->mu_prio) {
    4e5c:	d003      	beq.n	4e66 <os_mutex_release+0x3e>
        current->t_prio = mu->mu_prio;
    4e5e:	736b      	strb	r3, [r5, #13]
        os_sched_resort(current);
    4e60:	4628      	mov	r0, r5
    4e62:	f000 f9ab 	bl	51bc <os_sched_resort>
    }

    /* Check if tasks are waiting for the mutex */
    rdy = SLIST_FIRST(&mu->mu_head);
    4e66:	6826      	ldr	r6, [r4, #0]
    if (rdy) {
    4e68:	b16e      	cbz	r6, 4e86 <os_mutex_release+0x5e>
        /* There is one waiting. Wake it up */
        assert(rdy->t_obj);
    4e6a:	69f2      	ldr	r2, [r6, #28]
    4e6c:	b922      	cbnz	r2, 4e78 <os_mutex_release+0x50>
    4e6e:	4811      	ldr	r0, [pc, #68]	; (4eb4 <os_mutex_release+0x8c>)
    4e70:	2168      	movs	r1, #104	; 0x68
    4e72:	4613      	mov	r3, r2
    4e74:	f7ff feea 	bl	4c4c <__assert_func>
        os_sched_wakeup(rdy);
    4e78:	4630      	mov	r0, r6
    4e7a:	f000 f923 	bl	50c4 <os_sched_wakeup>

        /* Set mutex internals */
        mu->mu_level = 1;
    4e7e:	2301      	movs	r3, #1
    4e80:	80e3      	strh	r3, [r4, #6]
        mu->mu_prio = rdy->t_prio;
    4e82:	7b73      	ldrb	r3, [r6, #13]
    4e84:	7163      	strb	r3, [r4, #5]
    }

    /* Set new owner of mutex (or NULL if not owned) */
    mu->mu_owner = rdy;
    4e86:	60a6      	str	r6, [r4, #8]

    /* Do we need to re-schedule? */
    resched = 0;
    rdy = os_sched_next_task();
    4e88:	f000 f992 	bl	51b0 <os_sched_next_task>
    4e8c:	4604      	mov	r4, r0
    if (rdy != current) {
        resched = 1;
    }
    OS_EXIT_CRITICAL(sr);
    4e8e:	4638      	mov	r0, r7
    4e90:	f7ff fdf4 	bl	4a7c <os_arch_restore_sr>

    /* Re-schedule if needed */
    if (resched) {
    4e94:	42ac      	cmp	r4, r5
    4e96:	d002      	beq.n	4e9e <os_mutex_release+0x76>
        os_sched(rdy);
    4e98:	4620      	mov	r0, r4
    4e9a:	f000 f8c1 	bl	5020 <os_sched>
    }

    return OS_OK;
    4e9e:	2000      	movs	r0, #0
    4ea0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    struct os_task *current;
    struct os_task *rdy;

    /* Check if OS is started */
    if (!g_os_started) {
        return (OS_NOT_STARTED);
    4ea2:	2009      	movs	r0, #9
    4ea4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Check for valid mutex */
    if (!mu) {
        return OS_INVALID_PARM;
    4ea6:	2003      	movs	r0, #3
    4ea8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* We better own this mutex! */
    current = os_sched_get_current_task();
    if ((mu->mu_level == 0) || (mu->mu_owner != current)) {
        return (OS_BAD_MUTEX);
    4eaa:	2005      	movs	r0, #5
    if (resched) {
        os_sched(rdy);
    }

    return OS_OK;
}
    4eac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4eae:	bf00      	nop
    4eb0:	20000e44 	.word	0x20000e44
    4eb4:	000064c5 	.word	0x000064c5

00004eb8 <os_mutex_pend>:
    struct os_task *current;
    struct os_task *entry;
    struct os_task *last;

    /* OS must be started when calling this function */
    if (!g_os_started) {
    4eb8:	4b36      	ldr	r3, [pc, #216]	; (4f94 <os_mutex_pend+0xdc>)
    4eba:	681b      	ldr	r3, [r3, #0]
 *      OS_TIMEOUT          Mutex was owned by another task and timeout=0
 *      OS_OK               no error.
 */ 
os_error_t
os_mutex_pend(struct os_mutex *mu, uint32_t timeout)
{
    4ebc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4ec0:	4606      	mov	r6, r0
    4ec2:	4688      	mov	r8, r1
    struct os_task *current;
    struct os_task *entry;
    struct os_task *last;

    /* OS must be started when calling this function */
    if (!g_os_started) {
    4ec4:	2b00      	cmp	r3, #0
    4ec6:	d05e      	beq.n	4f86 <os_mutex_pend+0xce>
        return (OS_NOT_STARTED);
    }

    /* Check for valid mutex */
    if (!mu) {
    4ec8:	2800      	cmp	r0, #0
    4eca:	d05f      	beq.n	4f8c <os_mutex_pend+0xd4>
        return OS_INVALID_PARM;
    }

    OS_ENTER_CRITICAL(sr);
    4ecc:	f7ff fdd0 	bl	4a70 <os_arch_save_sr>
    4ed0:	4607      	mov	r7, r0

    /* Is this owned? */
    current = os_sched_get_current_task();
    4ed2:	f000 f89f 	bl	5014 <os_sched_get_current_task>
    if (mu->mu_level == 0) {
    4ed6:	88f5      	ldrh	r5, [r6, #6]
    }

    OS_ENTER_CRITICAL(sr);

    /* Is this owned? */
    current = os_sched_get_current_task();
    4ed8:	4604      	mov	r4, r0
    if (mu->mu_level == 0) {
    4eda:	b92d      	cbnz	r5, 4ee8 <os_mutex_pend+0x30>
        mu->mu_owner = current;
    4edc:	60b0      	str	r0, [r6, #8]
        mu->mu_prio  = current->t_prio;
    4ede:	7b43      	ldrb	r3, [r0, #13]
    4ee0:	7173      	strb	r3, [r6, #5]
        mu->mu_level = 1;
    4ee2:	2301      	movs	r3, #1
    4ee4:	80f3      	strh	r3, [r6, #6]
    4ee6:	e004      	b.n	4ef2 <os_mutex_pend+0x3a>
        OS_EXIT_CRITICAL(sr);
        return OS_OK;
    }

    /* Are we owner? */
    if (mu->mu_owner == current) {
    4ee8:	68b3      	ldr	r3, [r6, #8]
    4eea:	4283      	cmp	r3, r0
    4eec:	d107      	bne.n	4efe <os_mutex_pend+0x46>
        ++mu->mu_level;
    4eee:	1c68      	adds	r0, r5, #1
    4ef0:	80f0      	strh	r0, [r6, #6]
        OS_EXIT_CRITICAL(sr);
    4ef2:	4638      	mov	r0, r7
    4ef4:	f7ff fdc2 	bl	4a7c <os_arch_restore_sr>
        return OS_OK;
    4ef8:	2000      	movs	r0, #0
    4efa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /* Mutex is not owned by us. If timeout is 0, return immediately */
    if (timeout == 0) {
    4efe:	f1b8 0f00 	cmp.w	r8, #0
    4f02:	d105      	bne.n	4f10 <os_mutex_pend+0x58>
        OS_EXIT_CRITICAL(sr);
    4f04:	4638      	mov	r0, r7
    4f06:	f7ff fdb9 	bl	4a7c <os_arch_restore_sr>
        return OS_TIMEOUT;
    4f0a:	2006      	movs	r0, #6
    4f0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /* Change priority of owner if needed */
    if (mu->mu_owner->t_prio > current->t_prio) {
    4f10:	7b42      	ldrb	r2, [r0, #13]
    4f12:	7b59      	ldrb	r1, [r3, #13]
    4f14:	4291      	cmp	r1, r2
    4f16:	d903      	bls.n	4f20 <os_mutex_pend+0x68>
        mu->mu_owner->t_prio = current->t_prio;
    4f18:	735a      	strb	r2, [r3, #13]
        os_sched_resort(mu->mu_owner);
    4f1a:	68b0      	ldr	r0, [r6, #8]
    4f1c:	f000 f94e 	bl	51bc <os_sched_resort>
    }

    /* Link current task to tasks waiting for mutex */
    last = NULL;
    if (!SLIST_EMPTY(&mu->mu_head)) {
    4f20:	6832      	ldr	r2, [r6, #0]
    4f22:	b182      	cbz	r2, 4f46 <os_mutex_pend+0x8e>
        /* Insert in priority order */
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
            if (current->t_prio < entry->t_prio) { 
    4f24:	7b65      	ldrb	r5, [r4, #13]
    4f26:	4613      	mov	r3, r2
    4f28:	2100      	movs	r1, #0
    4f2a:	7b58      	ldrb	r0, [r3, #13]
    4f2c:	42a8      	cmp	r0, r5
    4f2e:	d804      	bhi.n	4f3a <os_mutex_pend+0x82>

    /* Link current task to tasks waiting for mutex */
    last = NULL;
    if (!SLIST_EMPTY(&mu->mu_head)) {
        /* Insert in priority order */
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
    4f30:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
    4f32:	4619      	mov	r1, r3
    4f34:	b118      	cbz	r0, 4f3e <os_mutex_pend+0x86>
    4f36:	4603      	mov	r3, r0
    4f38:	e7f7      	b.n	4f2a <os_mutex_pend+0x72>
            }
            last = entry;
        }
    }

    if (last) {
    4f3a:	460b      	mov	r3, r1
    4f3c:	b119      	cbz	r1, 4f46 <os_mutex_pend+0x8e>
        SLIST_INSERT_AFTER(last, current, t_obj_list);
    4f3e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    4f40:	64e2      	str	r2, [r4, #76]	; 0x4c
    4f42:	64dc      	str	r4, [r3, #76]	; 0x4c
    4f44:	e001      	b.n	4f4a <os_mutex_pend+0x92>
    } else {
        SLIST_INSERT_HEAD(&mu->mu_head, current, t_obj_list);
    4f46:	64e2      	str	r2, [r4, #76]	; 0x4c
    4f48:	6034      	str	r4, [r6, #0]
    }

    /* Set mutex pointer in task */
    current->t_obj = mu;
    current->t_flags |= OS_TASK_FLAG_MUTEX_WAIT;
    4f4a:	7be3      	ldrb	r3, [r4, #15]
    } else {
        SLIST_INSERT_HEAD(&mu->mu_head, current, t_obj_list);
    }

    /* Set mutex pointer in task */
    current->t_obj = mu;
    4f4c:	61e6      	str	r6, [r4, #28]
    current->t_flags |= OS_TASK_FLAG_MUTEX_WAIT;
    4f4e:	f043 0304 	orr.w	r3, r3, #4
    4f52:	73e3      	strb	r3, [r4, #15]
    os_sched_sleep(current, timeout);
    4f54:	4641      	mov	r1, r8
    4f56:	4620      	mov	r0, r4
    4f58:	f000 f87a 	bl	5050 <os_sched_sleep>
    OS_EXIT_CRITICAL(sr);
    4f5c:	4638      	mov	r0, r7
    4f5e:	f7ff fd8d 	bl	4a7c <os_arch_restore_sr>

    os_sched(NULL);
    4f62:	2000      	movs	r0, #0
    4f64:	f000 f85c 	bl	5020 <os_sched>

    OS_ENTER_CRITICAL(sr);
    4f68:	f7ff fd82 	bl	4a70 <os_arch_save_sr>
    current->t_flags &= ~OS_TASK_FLAG_MUTEX_WAIT;
    4f6c:	7be3      	ldrb	r3, [r4, #15]
    4f6e:	f023 0304 	bic.w	r3, r3, #4
    4f72:	73e3      	strb	r3, [r4, #15]
    OS_EXIT_CRITICAL(sr);
    4f74:	f7ff fd82 	bl	4a7c <os_arch_restore_sr>

    /* If we are owner we did not time out. */
    if (mu->mu_owner == current) {
    4f78:	68b0      	ldr	r0, [r6, #8]
        rc = OS_OK; 
    } else {
        rc = OS_TIMEOUT;
    4f7a:	42a0      	cmp	r0, r4
    4f7c:	bf14      	ite	ne
    4f7e:	2006      	movne	r0, #6
    4f80:	2000      	moveq	r0, #0
    4f82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    struct os_task *entry;
    struct os_task *last;

    /* OS must be started when calling this function */
    if (!g_os_started) {
        return (OS_NOT_STARTED);
    4f86:	2009      	movs	r0, #9
    4f88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /* Check for valid mutex */
    if (!mu) {
        return OS_INVALID_PARM;
    4f8c:	2003      	movs	r0, #3
    } else {
        rc = OS_TIMEOUT;
    }

    return rc;
}
    4f8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4f92:	bf00      	nop
    4f94:	20000e44 	.word	0x20000e44

00004f98 <os_sched_insert>:
 * @return int  OS_OK: task was inserted into run list 
 *              OS_EINVAL: Task was not in ready state. 
 */
os_error_t
os_sched_insert(struct os_task *t) 
{
    4f98:	b538      	push	{r3, r4, r5, lr}
    struct os_task *entry; 
    os_sr_t sr; 
    os_error_t rc;

    if (t->t_state != OS_TASK_READY) {
    4f9a:	7b83      	ldrb	r3, [r0, #14]
    4f9c:	2b01      	cmp	r3, #1
 * @return int  OS_OK: task was inserted into run list 
 *              OS_EINVAL: Task was not in ready state. 
 */
os_error_t
os_sched_insert(struct os_task *t) 
{
    4f9e:	4604      	mov	r4, r0
    struct os_task *entry; 
    os_sr_t sr; 
    os_error_t rc;

    if (t->t_state != OS_TASK_READY) {
    4fa0:	d10a      	bne.n	4fb8 <os_sched_insert+0x20>
        rc = OS_EINVAL;
        goto err;
    }

    entry = NULL;
    OS_ENTER_CRITICAL(sr); 
    4fa2:	f7ff fd65 	bl	4a70 <os_arch_save_sr>
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    4fa6:	4a0e      	ldr	r2, [pc, #56]	; (4fe0 <os_sched_insert+0x48>)
    4fa8:	6813      	ldr	r3, [r2, #0]
    4faa:	b193      	cbz	r3, 4fd2 <os_sched_insert+0x3a>
        if (t->t_prio < entry->t_prio) { 
    4fac:	7b65      	ldrb	r5, [r4, #13]
    4fae:	7b59      	ldrb	r1, [r3, #13]
    4fb0:	428d      	cmp	r5, r1
    4fb2:	d303      	bcc.n	4fbc <os_sched_insert+0x24>
        goto err;
    }

    entry = NULL;
    OS_ENTER_CRITICAL(sr); 
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    4fb4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4fb6:	e7f8      	b.n	4faa <os_sched_insert+0x12>
    }
    OS_EXIT_CRITICAL(sr);

    return (0);
err:
    return (rc);
    4fb8:	2002      	movs	r0, #2
    4fba:	bd38      	pop	{r3, r4, r5, pc}
        if (t->t_prio < entry->t_prio) { 
            break;
        }
    }
    if (entry) {
        TAILQ_INSERT_BEFORE(entry, (struct os_task *) t, t_os_list);
    4fbc:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    4fbe:	64a2      	str	r2, [r4, #72]	; 0x48
    4fc0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    4fc2:	6463      	str	r3, [r4, #68]	; 0x44
    4fc4:	6014      	str	r4, [r2, #0]
    4fc6:	3444      	adds	r4, #68	; 0x44
    4fc8:	649c      	str	r4, [r3, #72]	; 0x48
    } else {
        TAILQ_INSERT_TAIL(&g_os_run_list, (struct os_task *) t, t_os_list);
    }
    OS_EXIT_CRITICAL(sr);
    4fca:	f7ff fd57 	bl	4a7c <os_arch_restore_sr>
    4fce:	2000      	movs	r0, #0
    4fd0:	bd38      	pop	{r3, r4, r5, pc}
        }
    }
    if (entry) {
        TAILQ_INSERT_BEFORE(entry, (struct os_task *) t, t_os_list);
    } else {
        TAILQ_INSERT_TAIL(&g_os_run_list, (struct os_task *) t, t_os_list);
    4fd2:	6463      	str	r3, [r4, #68]	; 0x44
    4fd4:	6853      	ldr	r3, [r2, #4]
    4fd6:	64a3      	str	r3, [r4, #72]	; 0x48
    4fd8:	601c      	str	r4, [r3, #0]
    4fda:	3444      	adds	r4, #68	; 0x44
    4fdc:	6054      	str	r4, [r2, #4]
    4fde:	e7f4      	b.n	4fca <os_sched_insert+0x32>
    4fe0:	20000138 	.word	0x20000138

00004fe4 <os_sched_ctx_sw_hook>:
}

void
os_sched_ctx_sw_hook(struct os_task *next_t)
{
    if (g_current_task == next_t) {
    4fe4:	4b08      	ldr	r3, [pc, #32]	; (5008 <os_sched_ctx_sw_hook+0x24>)
    4fe6:	681a      	ldr	r2, [r3, #0]
    4fe8:	4282      	cmp	r2, r0
    return (rc);
}

void
os_sched_ctx_sw_hook(struct os_task *next_t)
{
    4fea:	b510      	push	{r4, lr}
    if (g_current_task == next_t) {
    4fec:	d00b      	beq.n	5006 <os_sched_ctx_sw_hook+0x22>
        return;
    }

    next_t->t_ctx_sw_cnt++;
    4fee:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    4ff0:	4906      	ldr	r1, [pc, #24]	; (500c <os_sched_ctx_sw_hook+0x28>)
{
    if (g_current_task == next_t) {
        return;
    }

    next_t->t_ctx_sw_cnt++;
    4ff2:	3301      	adds	r3, #1
    4ff4:	63c3      	str	r3, [r0, #60]	; 0x3c
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    4ff6:	4b06      	ldr	r3, [pc, #24]	; (5010 <os_sched_ctx_sw_hook+0x2c>)
    4ff8:	680c      	ldr	r4, [r1, #0]
    4ffa:	6818      	ldr	r0, [r3, #0]
    4ffc:	6b93      	ldr	r3, [r2, #56]	; 0x38
    g_os_last_ctx_sw_time = g_os_time;
    4ffe:	6008      	str	r0, [r1, #0]
    5000:	4403      	add	r3, r0
    if (g_current_task == next_t) {
        return;
    }

    next_t->t_ctx_sw_cnt++;
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    5002:	1b1b      	subs	r3, r3, r4
    5004:	6393      	str	r3, [r2, #56]	; 0x38
    5006:	bd10      	pop	{r4, pc}
    5008:	20000e50 	.word	0x20000e50
    500c:	20000e54 	.word	0x20000e54
    5010:	20000e64 	.word	0x20000e64

00005014 <os_sched_get_current_task>:
 */
struct os_task * 
os_sched_get_current_task(void)
{
    return (g_current_task);
}
    5014:	4b01      	ldr	r3, [pc, #4]	; (501c <os_sched_get_current_task+0x8>)
    5016:	6818      	ldr	r0, [r3, #0]
    5018:	4770      	bx	lr
    501a:	bf00      	nop
    501c:	20000e50 	.word	0x20000e50

00005020 <os_sched>:
 * 
 * @param next_t Task to run
 */
void
os_sched(struct os_task *next_t)
{
    5020:	b538      	push	{r3, r4, r5, lr}
    5022:	4604      	mov	r4, r0
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    5024:	f7ff fd24 	bl	4a70 <os_arch_save_sr>
    5028:	4605      	mov	r5, r0

    if (!next_t) {
    502a:	b90c      	cbnz	r4, 5030 <os_sched+0x10>
 * @return struct os_task* 
 */
struct os_task *  
os_sched_next_task(void) 
{
    return (TAILQ_FIRST(&g_os_run_list));
    502c:	4b06      	ldr	r3, [pc, #24]	; (5048 <os_sched+0x28>)
    502e:	681c      	ldr	r4, [r3, #0]

    if (!next_t) {
        next_t = os_sched_next_task();
    }

    if (next_t != g_current_task) {
    5030:	4b06      	ldr	r3, [pc, #24]	; (504c <os_sched+0x2c>)
    5032:	681b      	ldr	r3, [r3, #0]
    5034:	429c      	cmp	r4, r3
    5036:	d002      	beq.n	503e <os_sched+0x1e>
        os_arch_ctx_sw(next_t);
    5038:	4620      	mov	r0, r4
    503a:	f7ff fd0f 	bl	4a5c <os_arch_ctx_sw>
    }

    OS_EXIT_CRITICAL(sr);
    503e:	4628      	mov	r0, r5
}
    5040:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    if (next_t != g_current_task) {
        os_arch_ctx_sw(next_t);
    }

    OS_EXIT_CRITICAL(sr);
    5044:	f7ff bd1a 	b.w	4a7c <os_arch_restore_sr>
    5048:	20000138 	.word	0x20000138
    504c:	20000e50 	.word	0x20000e50

00005050 <os_sched_sleep>:
 * NOTE: must be called with interrupts disabled! This function does not call 
 * the scheduler 
 */
int 
os_sched_sleep(struct os_task *t, os_time_t nticks) 
{
    5050:	b538      	push	{r3, r4, r5, lr}
    struct os_task *entry;

    entry = NULL; 

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    5052:	6c43      	ldr	r3, [r0, #68]	; 0x44
    5054:	6c82      	ldr	r2, [r0, #72]	; 0x48
 * NOTE: must be called with interrupts disabled! This function does not call 
 * the scheduler 
 */
int 
os_sched_sleep(struct os_task *t, os_time_t nticks) 
{
    5056:	4604      	mov	r4, r0
    5058:	460d      	mov	r5, r1
    struct os_task *entry;

    entry = NULL; 

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    505a:	b10b      	cbz	r3, 5060 <os_sched_sleep+0x10>
    505c:	649a      	str	r2, [r3, #72]	; 0x48
    505e:	e001      	b.n	5064 <os_sched_sleep+0x14>
    5060:	4916      	ldr	r1, [pc, #88]	; (50bc <os_sched_sleep+0x6c>)
    5062:	604a      	str	r2, [r1, #4]
    5064:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    5066:	6013      	str	r3, [r2, #0]
    t->t_state = OS_TASK_SLEEP;
    5068:	2302      	movs	r3, #2
    506a:	73a3      	strb	r3, [r4, #14]
    t->t_next_wakeup = os_time_get() + nticks;
    506c:	f000 f934 	bl	52d8 <os_time_get>
    5070:	4428      	add	r0, r5
    if (nticks == OS_TIMEOUT_NEVER) {
    5072:	3501      	adds	r5, #1

    entry = NULL; 

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    t->t_state = OS_TASK_SLEEP;
    t->t_next_wakeup = os_time_get() + nticks;
    5074:	6360      	str	r0, [r4, #52]	; 0x34
    5076:	4a12      	ldr	r2, [pc, #72]	; (50c0 <os_sched_sleep+0x70>)
    if (nticks == OS_TIMEOUT_NEVER) {
    5078:	d105      	bne.n	5086 <os_sched_sleep+0x36>
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
    507a:	7be3      	ldrb	r3, [r4, #15]
    507c:	f043 0301 	orr.w	r3, r3, #1
    5080:	73e3      	strb	r3, [r4, #15]
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    5082:	2300      	movs	r3, #0
    5084:	e00a      	b.n	509c <os_sched_sleep+0x4c>
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    5086:	6813      	ldr	r3, [r2, #0]
    5088:	b143      	cbz	r3, 509c <os_sched_sleep+0x4c>
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    508a:	7bd9      	ldrb	r1, [r3, #15]
    508c:	07c9      	lsls	r1, r1, #31
    508e:	d40c      	bmi.n	50aa <os_sched_sleep+0x5a>
                    OS_TIME_TICK_GT(entry->t_next_wakeup, t->t_next_wakeup)) {
    5090:	6b59      	ldr	r1, [r3, #52]	; 0x34
    5092:	1a09      	subs	r1, r1, r0
    if (nticks == OS_TIMEOUT_NEVER) {
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    5094:	2900      	cmp	r1, #0
    5096:	dc08      	bgt.n	50aa <os_sched_sleep+0x5a>
    t->t_next_wakeup = os_time_get() + nticks;
    if (nticks == OS_TIMEOUT_NEVER) {
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    5098:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    509a:	e7f5      	b.n	5088 <os_sched_sleep+0x38>
            }
        }
        if (entry) {
            TAILQ_INSERT_BEFORE(entry, t, t_os_list); 
        } else {
            TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
    509c:	6463      	str	r3, [r4, #68]	; 0x44
    509e:	6853      	ldr	r3, [r2, #4]
    50a0:	64a3      	str	r3, [r4, #72]	; 0x48
    50a2:	601c      	str	r4, [r3, #0]
    50a4:	3444      	adds	r4, #68	; 0x44
    50a6:	6054      	str	r4, [r2, #4]
    50a8:	e006      	b.n	50b8 <os_sched_sleep+0x68>
                    OS_TIME_TICK_GT(entry->t_next_wakeup, t->t_next_wakeup)) {
                break;
            }
        }
        if (entry) {
            TAILQ_INSERT_BEFORE(entry, t, t_os_list); 
    50aa:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    50ac:	64a2      	str	r2, [r4, #72]	; 0x48
    50ae:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    50b0:	6463      	str	r3, [r4, #68]	; 0x44
    50b2:	6014      	str	r4, [r2, #0]
    50b4:	3444      	adds	r4, #68	; 0x44
    50b6:	649c      	str	r4, [r3, #72]	; 0x48
            TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list); 
        }
    }

    return (0);
}
    50b8:	2000      	movs	r0, #0
    50ba:	bd38      	pop	{r3, r4, r5, pc}
    50bc:	20000138 	.word	0x20000138
    50c0:	20000140 	.word	0x20000140

000050c4 <os_sched_wakeup>:
 *  
 * NOTE: This function must be called with interrupts disabled. 
 */
int 
os_sched_wakeup(struct os_task *t) 
{
    50c4:	b508      	push	{r3, lr}
    struct os_task_obj *os_obj;

    assert(t->t_state == OS_TASK_SLEEP);
    50c6:	7b83      	ldrb	r3, [r0, #14]
    50c8:	2b02      	cmp	r3, #2
    50ca:	d003      	beq.n	50d4 <os_sched_wakeup+0x10>
    50cc:	4818      	ldr	r0, [pc, #96]	; (5130 <os_sched_wakeup+0x6c>)
    50ce:	21ce      	movs	r1, #206	; 0xce
    50d0:	2200      	movs	r2, #0
    50d2:	e005      	b.n	50e0 <os_sched_wakeup+0x1c>

    /* Remove self from object list if waiting on one */
    if (t->t_obj) {
    50d4:	69c3      	ldr	r3, [r0, #28]
    50d6:	b1ab      	cbz	r3, 5104 <os_sched_wakeup+0x40>
        os_obj = (struct os_task_obj *)t->t_obj;
        assert(!SLIST_EMPTY(&os_obj->obj_head));
    50d8:	681a      	ldr	r2, [r3, #0]
    50da:	b922      	cbnz	r2, 50e6 <os_sched_wakeup+0x22>
    50dc:	4814      	ldr	r0, [pc, #80]	; (5130 <os_sched_wakeup+0x6c>)
    50de:	21d3      	movs	r1, #211	; 0xd3
    50e0:	4613      	mov	r3, r2
    50e2:	f7ff fdb3 	bl	4c4c <__assert_func>
        SLIST_REMOVE(&os_obj->obj_head, t, os_task, t_obj_list);
    50e6:	4282      	cmp	r2, r0
    50e8:	d102      	bne.n	50f0 <os_sched_wakeup+0x2c>
    50ea:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
    50ec:	601a      	str	r2, [r3, #0]
    50ee:	e006      	b.n	50fe <os_sched_wakeup+0x3a>
    50f0:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    50f2:	4283      	cmp	r3, r0
    50f4:	d001      	beq.n	50fa <os_sched_wakeup+0x36>
    50f6:	461a      	mov	r2, r3
    50f8:	e7fa      	b.n	50f0 <os_sched_wakeup+0x2c>
    50fa:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    50fc:	64d3      	str	r3, [r2, #76]	; 0x4c
        SLIST_NEXT(t, t_obj_list) = NULL;
    50fe:	2300      	movs	r3, #0
    5100:	64c3      	str	r3, [r0, #76]	; 0x4c
        t->t_obj = NULL; 
    5102:	61c3      	str	r3, [r0, #28]
    }

    /* Remove task from sleep list */
    t->t_state = OS_TASK_READY;
    5104:	2301      	movs	r3, #1
    5106:	7383      	strb	r3, [r0, #14]
    t->t_next_wakeup = 0;
    5108:	2300      	movs	r3, #0
    510a:	6343      	str	r3, [r0, #52]	; 0x34
    t->t_flags &= ~OS_TASK_FLAG_NO_TIMEOUT;
    510c:	7bc3      	ldrb	r3, [r0, #15]
    510e:	6c82      	ldr	r2, [r0, #72]	; 0x48
    5110:	f023 0301 	bic.w	r3, r3, #1
    5114:	73c3      	strb	r3, [r0, #15]
    TAILQ_REMOVE(&g_os_sleep_list, t, t_os_list);
    5116:	6c43      	ldr	r3, [r0, #68]	; 0x44
    5118:	b10b      	cbz	r3, 511e <os_sched_wakeup+0x5a>
    511a:	649a      	str	r2, [r3, #72]	; 0x48
    511c:	e001      	b.n	5122 <os_sched_wakeup+0x5e>
    511e:	4905      	ldr	r1, [pc, #20]	; (5134 <os_sched_wakeup+0x70>)
    5120:	604a      	str	r2, [r1, #4]
    5122:	6c82      	ldr	r2, [r0, #72]	; 0x48
    5124:	6013      	str	r3, [r2, #0]
    os_sched_insert(t);
    5126:	f7ff ff37 	bl	4f98 <os_sched_insert>

    return (0);
}
    512a:	2000      	movs	r0, #0
    512c:	bd08      	pop	{r3, pc}
    512e:	bf00      	nop
    5130:	000064d0 	.word	0x000064d0
    5134:	20000140 	.word	0x20000140

00005138 <os_sched_os_timer_exp>:
 * removed from the sleep list and added to the run list. 
 * 
 */
void
os_sched_os_timer_exp(void)
{
    5138:	b570      	push	{r4, r5, r6, lr}
    struct os_task *t;
    struct os_task *next;
    os_time_t now; 
    os_sr_t sr;

    now = os_time_get();
    513a:	f000 f8cd 	bl	52d8 <os_time_get>
    513e:	4605      	mov	r5, r0

    OS_ENTER_CRITICAL(sr);
    5140:	f7ff fc96 	bl	4a70 <os_arch_save_sr>

    /*
     * Wakeup any tasks that have their sleep timer expired
     */
    t = TAILQ_FIRST(&g_os_sleep_list);
    5144:	4b0a      	ldr	r3, [pc, #40]	; (5170 <os_sched_os_timer_exp+0x38>)
    os_time_t now; 
    os_sr_t sr;

    now = os_time_get();

    OS_ENTER_CRITICAL(sr);
    5146:	4604      	mov	r4, r0

    /*
     * Wakeup any tasks that have their sleep timer expired
     */
    t = TAILQ_FIRST(&g_os_sleep_list);
    5148:	6818      	ldr	r0, [r3, #0]
    while (t) {
    514a:	b158      	cbz	r0, 5164 <os_sched_os_timer_exp+0x2c>
        /* If task waiting forever, do not check next wakeup time */
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
    514c:	7bc3      	ldrb	r3, [r0, #15]
    514e:	07db      	lsls	r3, r3, #31
    5150:	d408      	bmi.n	5164 <os_sched_os_timer_exp+0x2c>
            break;
        }
        next = TAILQ_NEXT(t, t_os_list);
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
    5152:	6b43      	ldr	r3, [r0, #52]	; 0x34
    while (t) {
        /* If task waiting forever, do not check next wakeup time */
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
            break;
        }
        next = TAILQ_NEXT(t, t_os_list);
    5154:	6c46      	ldr	r6, [r0, #68]	; 0x44
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
    5156:	1aeb      	subs	r3, r5, r3
    5158:	2b00      	cmp	r3, #0
    515a:	db03      	blt.n	5164 <os_sched_os_timer_exp+0x2c>
            os_sched_wakeup(t);
    515c:	f7ff ffb2 	bl	50c4 <os_sched_wakeup>
        } else {
            break;
        }
        t = next;
    5160:	4630      	mov	r0, r6
    5162:	e7f2      	b.n	514a <os_sched_os_timer_exp+0x12>
    }

    OS_EXIT_CRITICAL(sr); 
    5164:	4620      	mov	r0, r4
}
    5166:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            break;
        }
        t = next;
    }

    OS_EXIT_CRITICAL(sr); 
    516a:	f7ff bc87 	b.w	4a7c <os_arch_restore_sr>
    516e:	bf00      	nop
    5170:	20000140 	.word	0x20000140

00005174 <os_sched_wakeup_ticks>:
 * Return the number of ticks until the first sleep timer expires.If there are
 * no such tasks then return OS_TIMEOUT_NEVER instead.
 */
os_time_t
os_sched_wakeup_ticks(os_time_t now)
{
    5174:	b510      	push	{r4, lr}
    5176:	4604      	mov	r4, r0
    os_time_t rt;
    struct os_task *t;

    OS_ASSERT_CRITICAL();
    5178:	f7ff fc83 	bl	4a82 <os_arch_in_critical>
    517c:	4602      	mov	r2, r0
    517e:	b928      	cbnz	r0, 518c <os_sched_wakeup_ticks+0x18>
    5180:	4809      	ldr	r0, [pc, #36]	; (51a8 <os_sched_wakeup_ticks+0x34>)
    5182:	f240 1117 	movw	r1, #279	; 0x117
    5186:	4613      	mov	r3, r2
    5188:	f7ff fd60 	bl	4c4c <__assert_func>

    t = TAILQ_FIRST(&g_os_sleep_list);
    518c:	4b07      	ldr	r3, [pc, #28]	; (51ac <os_sched_wakeup_ticks+0x38>)
    518e:	681b      	ldr	r3, [r3, #0]
    if (t == NULL || (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT)) {
    5190:	b13b      	cbz	r3, 51a2 <os_sched_wakeup_ticks+0x2e>
    5192:	7bda      	ldrb	r2, [r3, #15]
    5194:	07d2      	lsls	r2, r2, #31
    5196:	d404      	bmi.n	51a2 <os_sched_wakeup_ticks+0x2e>
        rt = OS_TIMEOUT_NEVER;
    } else if (OS_TIME_TICK_GEQ(t->t_next_wakeup, now)) {
    5198:	6b58      	ldr	r0, [r3, #52]	; 0x34
    519a:	1b00      	subs	r0, r0, r4
        rt = t->t_next_wakeup - now;   
    } else {
        rt = 0;     /* wakeup time was in the past */
    519c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    51a0:	bd10      	pop	{r4, pc}

    OS_ASSERT_CRITICAL();

    t = TAILQ_FIRST(&g_os_sleep_list);
    if (t == NULL || (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT)) {
        rt = OS_TIMEOUT_NEVER;
    51a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        rt = t->t_next_wakeup - now;   
    } else {
        rt = 0;     /* wakeup time was in the past */
    }
    return (rt);
}
    51a6:	bd10      	pop	{r4, pc}
    51a8:	000064d0 	.word	0x000064d0
    51ac:	20000140 	.word	0x20000140

000051b0 <os_sched_next_task>:
 */
struct os_task *  
os_sched_next_task(void) 
{
    return (TAILQ_FIRST(&g_os_run_list));
}
    51b0:	4b01      	ldr	r3, [pc, #4]	; (51b8 <os_sched_next_task+0x8>)
    51b2:	6818      	ldr	r0, [r3, #0]
    51b4:	4770      	bx	lr
    51b6:	bf00      	nop
    51b8:	20000138 	.word	0x20000138

000051bc <os_sched_resort>:
 * are not disabled here. 
 */
void 
os_sched_resort(struct os_task *t) 
{
    if (t->t_state == OS_TASK_READY) {
    51bc:	7b83      	ldrb	r3, [r0, #14]
    51be:	2b01      	cmp	r3, #1
    51c0:	d10a      	bne.n	51d8 <os_sched_resort+0x1c>
        TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    51c2:	6c43      	ldr	r3, [r0, #68]	; 0x44
    51c4:	6c82      	ldr	r2, [r0, #72]	; 0x48
    51c6:	b10b      	cbz	r3, 51cc <os_sched_resort+0x10>
    51c8:	649a      	str	r2, [r3, #72]	; 0x48
    51ca:	e001      	b.n	51d0 <os_sched_resort+0x14>
    51cc:	4903      	ldr	r1, [pc, #12]	; (51dc <os_sched_resort+0x20>)
    51ce:	604a      	str	r2, [r1, #4]
    51d0:	6c82      	ldr	r2, [r0, #72]	; 0x48
    51d2:	6013      	str	r3, [r2, #0]
        os_sched_insert(t);
    51d4:	f7ff bee0 	b.w	4f98 <os_sched_insert>
    51d8:	4770      	bx	lr
    51da:	bf00      	nop
    51dc:	20000138 	.word	0x20000138

000051e0 <os_task_init>:
 */
int
os_task_init(struct os_task *t, char *name, os_task_func_t func, void *arg,
        uint8_t prio, os_time_t sanity_itvl, os_stack_t *stack_bottom,
        uint16_t stack_size)
{
    51e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    51e4:	4604      	mov	r4, r0
    51e6:	461f      	mov	r7, r3
    51e8:	4689      	mov	r9, r1
    51ea:	4692      	mov	sl, r2
    struct os_sanity_check *sc;
    int rc;

    memset(t, 0, sizeof(*t));
    51ec:	2100      	movs	r1, #0
    51ee:	2250      	movs	r2, #80	; 0x50
 */
int
os_task_init(struct os_task *t, char *name, os_task_func_t func, void *arg,
        uint8_t prio, os_time_t sanity_itvl, os_stack_t *stack_bottom,
        uint16_t stack_size)
{
    51f0:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    51f4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    51f6:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
    struct os_sanity_check *sc;
    int rc;

    memset(t, 0, sizeof(*t));
    51fa:	f7fe fbb3 	bl	3964 <memset>

    t->t_func = func;
    t->t_arg = arg;
    51fe:	61a7      	str	r7, [r4, #24]
    struct os_sanity_check *sc;
    int rc;

    memset(t, 0, sizeof(*t));

    t->t_func = func;
    5200:	f8c4 a014 	str.w	sl, [r4, #20]
os_task_next_id(void)
{
    uint8_t rc;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    5204:	f7ff fc34 	bl	4a70 <os_arch_save_sr>
    rc = g_task_id;
    5208:	4b1f      	ldr	r3, [pc, #124]	; (5288 <os_task_init+0xa8>)
    520a:	781f      	ldrb	r7, [r3, #0]
    g_task_id++;
    520c:	1c7a      	adds	r2, r7, #1
    520e:	701a      	strb	r2, [r3, #0]
    OS_EXIT_CRITICAL(sr);
    5210:	f7ff fc34 	bl	4a7c <os_arch_restore_sr>

    t->t_func = func;
    t->t_arg = arg;

    t->t_taskid = os_task_next_id();
    t->t_prio = prio;
    5214:	f89d 3020 	ldrb.w	r3, [sp, #32]
    5218:	7363      	strb	r3, [r4, #13]

    t->t_state = OS_TASK_READY;
    521a:	2301      	movs	r3, #1
    memset(t, 0, sizeof(*t));

    t->t_func = func;
    t->t_arg = arg;

    t->t_taskid = os_task_next_id();
    521c:	7327      	strb	r7, [r4, #12]
    t->t_prio = prio;

    t->t_state = OS_TASK_READY;
    521e:	73a3      	strb	r3, [r4, #14]
    t->t_name = name;
    t->t_next_wakeup = 0;

    rc = os_sanity_check_init(&t->t_sanity_check);
    5220:	f104 0720 	add.w	r7, r4, #32
    t->t_taskid = os_task_next_id();
    t->t_prio = prio;

    t->t_state = OS_TASK_READY;
    t->t_name = name;
    t->t_next_wakeup = 0;
    5224:	2300      	movs	r3, #0

    t->t_taskid = os_task_next_id();
    t->t_prio = prio;

    t->t_state = OS_TASK_READY;
    t->t_name = name;
    5226:	f8c4 9010 	str.w	r9, [r4, #16]
    t->t_next_wakeup = 0;
    522a:	6363      	str	r3, [r4, #52]	; 0x34

    rc = os_sanity_check_init(&t->t_sanity_check);
    522c:	4638      	mov	r0, r7
    522e:	f000 f911 	bl	5454 <os_sanity_check_init>
    if (rc != OS_OK) {
    5232:	bb38      	cbnz	r0, 5284 <os_task_init+0xa4>
        goto err;
    }

    if (sanity_itvl != OS_WAIT_FOREVER) {
    5234:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    5238:	d101      	bne.n	523e <os_task_init+0x5e>
static void
_clear_stack(os_stack_t *stack_bottom, int size)
{
    int i;

    for (i = 0; i < size; i++) {
    523a:	2300      	movs	r3, #0
    523c:	e006      	b.n	524c <os_task_init+0x6c>
        goto err;
    }

    if (sanity_itvl != OS_WAIT_FOREVER) {
        sc = (struct os_sanity_check *) &t->t_sanity_check;
        sc->sc_checkin_itvl = sanity_itvl;
    523e:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24

        rc = os_sanity_check_register(sc);
    5242:	4638      	mov	r0, r7
    5244:	f000 f90e 	bl	5464 <os_sanity_check_register>
        if (rc != OS_OK) {
    5248:	b9e0      	cbnz	r0, 5284 <os_task_init+0xa4>
    524a:	e7f6      	b.n	523a <os_task_init+0x5a>
static void
_clear_stack(os_stack_t *stack_bottom, int size)
{
    int i;

    for (i = 0; i < size; i++) {
    524c:	42b3      	cmp	r3, r6
    524e:	da04      	bge.n	525a <os_task_init+0x7a>
        stack_bottom[i] = OS_STACK_PATTERN;
    5250:	4a0e      	ldr	r2, [pc, #56]	; (528c <os_task_init+0xac>)
    5252:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
static void
_clear_stack(os_stack_t *stack_bottom, int size)
{
    int i;

    for (i = 0; i < size; i++) {
    5256:	3301      	adds	r3, #1
    5258:	e7f8      	b.n	524c <os_task_init+0x6c>
            goto err;
        }
    }

    _clear_stack(stack_bottom, stack_size);
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
    525a:	eb05 0586 	add.w	r5, r5, r6, lsl #2
    525e:	4632      	mov	r2, r6
    5260:	4620      	mov	r0, r4
    5262:	4629      	mov	r1, r5
    5264:	f7ff fc12 	bl	4a8c <os_arch_task_stack_init>
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    t->t_stacksize = stack_size;

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    5268:	2300      	movs	r3, #0
    526a:	6423      	str	r3, [r4, #64]	; 0x40
    526c:	4b08      	ldr	r3, [pc, #32]	; (5290 <os_task_init+0xb0>)

    _clear_stack(stack_bottom, stack_size);
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    t->t_stacksize = stack_size;
    526e:	8126      	strh	r6, [r4, #8]

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    5270:	685a      	ldr	r2, [r3, #4]
    }

    _clear_stack(stack_bottom, stack_size);
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    5272:	e884 0021 	stmia.w	r4, {r0, r5}
    t->t_stacksize = stack_size;

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    5276:	6014      	str	r4, [r2, #0]

    /* insert this task into the scheduler list */
    rc = os_sched_insert(t);
    5278:	4620      	mov	r0, r4
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    t->t_stacksize = stack_size;

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    527a:	f104 0240 	add.w	r2, r4, #64	; 0x40
    527e:	605a      	str	r2, [r3, #4]

    /* insert this task into the scheduler list */
    rc = os_sched_insert(t);
    5280:	f7ff fe8a 	bl	4f98 <os_sched_insert>


    return (0);
err:
    return (rc);
}
    5284:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5288:	20000e60 	.word	0x20000e60
    528c:	deadbeef 	.word	0xdeadbeef
    5290:	20000e58 	.word	0x20000e58

00005294 <os_deltatime>:
} basetod;

static void
os_deltatime(os_time_t delta, const struct os_timeval *base,
    struct os_timeval *result)
{
    5294:	b530      	push	{r4, r5, lr}
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    os_timeradd(base, &tvdelta, result);
    5296:	e9d1 4500 	ldrd	r4, r5, [r1]
os_deltatime(os_time_t delta, const struct os_timeval *base,
    struct os_timeval *result)
{
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    529a:	09c3      	lsrs	r3, r0, #7
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    os_timeradd(base, &tvdelta, result);
    529c:	6889      	ldr	r1, [r1, #8]
    529e:	18e4      	adds	r4, r4, r3
    struct os_timeval *result)
{
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    52a0:	f000 037f 	and.w	r3, r0, #127	; 0x7f
    os_timeradd(base, &tvdelta, result);
    52a4:	f641 6084 	movw	r0, #7812	; 0x1e84
    52a8:	fb00 1003 	mla	r0, r0, r3, r1
    52ac:	4b09      	ldr	r3, [pc, #36]	; (52d4 <os_deltatime+0x40>)
    52ae:	6090      	str	r0, [r2, #8]
    52b0:	f145 0500 	adc.w	r5, r5, #0
    52b4:	4298      	cmp	r0, r3
    52b6:	e9c2 4500 	strd	r4, r5, [r2]
    52ba:	dd09      	ble.n	52d0 <os_deltatime+0x3c>
    52bc:	3401      	adds	r4, #1
    52be:	f145 0500 	adc.w	r5, r5, #0
    52c2:	f5a0 2074 	sub.w	r0, r0, #999424	; 0xf4000
    52c6:	e9c2 4500 	strd	r4, r5, [r2]
    52ca:	f5a0 7010 	sub.w	r0, r0, #576	; 0x240
    52ce:	6090      	str	r0, [r2, #8]
    52d0:	bd30      	pop	{r4, r5, pc}
    52d2:	bf00      	nop
    52d4:	000f423f 	.word	0x000f423f

000052d8 <os_time_get>:
 */
os_time_t
os_time_get(void)
{
    return (g_os_time);
}
    52d8:	4b01      	ldr	r3, [pc, #4]	; (52e0 <os_time_get+0x8>)
    52da:	6818      	ldr	r0, [r3, #0]
    52dc:	4770      	bx	lr
    52de:	bf00      	nop
    52e0:	20000e64 	.word	0x20000e64

000052e4 <os_time_advance>:
 *
 * @param ticks The number of ticks to move time forward.
 */
void
os_time_advance(int ticks)
{
    52e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    assert(ticks >= 0);
    52e6:	1e04      	subs	r4, r0, #0
    52e8:	da05      	bge.n	52f6 <os_time_advance+0x12>
    52ea:	2200      	movs	r2, #0
    52ec:	4816      	ldr	r0, [pc, #88]	; (5348 <os_time_advance+0x64>)
    52ee:	2161      	movs	r1, #97	; 0x61
    52f0:	4613      	mov	r3, r2
    52f2:	f7ff fcab 	bl	4c4c <__assert_func>

    if (ticks > 0) {
    52f6:	d026      	beq.n	5346 <os_time_advance+0x62>
    os_time_t delta, prev_os_time;

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    prev_os_time = g_os_time;
    52f8:	4e14      	ldr	r6, [pc, #80]	; (534c <os_time_advance+0x68>)
    os_sr_t sr;
    os_time_t delta, prev_os_time;

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    52fa:	f7ff fbb9 	bl	4a70 <os_arch_save_sr>
    prev_os_time = g_os_time;
    52fe:	6833      	ldr	r3, [r6, #0]
    os_sr_t sr;
    os_time_t delta, prev_os_time;

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    5300:	4607      	mov	r7, r0
    prev_os_time = g_os_time;
    g_os_time += ticks;
    5302:	18e0      	adds	r0, r4, r3

    /*
     * Update 'basetod' when 'g_os_time' crosses the 0x00000000 and
     * 0x80000000 thresholds.
     */
    if ((prev_os_time ^ g_os_time) >> 31) {
    5304:	ea90 0f03 	teq	r0, r3

    assert(ticks >= 0);

    OS_ENTER_CRITICAL(sr);
    prev_os_time = g_os_time;
    g_os_time += ticks;
    5308:	6030      	str	r0, [r6, #0]

    /*
     * Update 'basetod' when 'g_os_time' crosses the 0x00000000 and
     * 0x80000000 thresholds.
     */
    if ((prev_os_time ^ g_os_time) >> 31) {
    530a:	d510      	bpl.n	532e <os_time_advance+0x4a>
        delta = g_os_time - basetod.ostime;
    530c:	4d10      	ldr	r5, [pc, #64]	; (5350 <os_time_advance+0x6c>)
    530e:	4629      	mov	r1, r5
    5310:	f851 4b08 	ldr.w	r4, [r1], #8
    5314:	1b04      	subs	r4, r0, r4
        os_deltatime(delta, &basetod.uptime, &basetod.uptime);
    5316:	460a      	mov	r2, r1
    5318:	4620      	mov	r0, r4
    531a:	f7ff ffbb 	bl	5294 <os_deltatime>
        os_deltatime(delta, &basetod.utctime, &basetod.utctime);
    531e:	f105 0118 	add.w	r1, r5, #24
    5322:	4620      	mov	r0, r4
    5324:	460a      	mov	r2, r1
    5326:	f7ff ffb5 	bl	5294 <os_deltatime>
        basetod.ostime = g_os_time;
    532a:	6833      	ldr	r3, [r6, #0]
    532c:	602b      	str	r3, [r5, #0]
    }
    OS_EXIT_CRITICAL(sr);
    532e:	4638      	mov	r0, r7
    5330:	f7ff fba4 	bl	4a7c <os_arch_restore_sr>
{
    assert(ticks >= 0);

    if (ticks > 0) {
        os_time_tick(ticks);
        os_callout_tick();
    5334:	f7ff fc22 	bl	4b7c <os_callout_tick>
        os_sched_os_timer_exp();
    5338:	f7ff fefe 	bl	5138 <os_sched_os_timer_exp>
        os_sched(NULL);
    533c:	2000      	movs	r0, #0
    }
}
    533e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

    if (ticks > 0) {
        os_time_tick(ticks);
        os_callout_tick();
        os_sched_os_timer_exp();
        os_sched(NULL);
    5342:	f7ff be6d 	b.w	5020 <os_sched>
    5346:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5348:	000064db 	.word	0x000064db
    534c:	20000e64 	.word	0x20000e64
    5350:	20000a40 	.word	0x20000a40

00005354 <os_set_env>:
        .global os_set_env
os_set_env:
        .fnstart
        .cantunwind

        MOV     R0,SP           /* Copy MSP to PSP */
    5354:	4668      	mov	r0, sp
        MSR     PSP,R0
    5356:	f380 8809 	msr	PSP, r0
        LDR     R0,=os_flags
    535a:	482c      	ldr	r0, [pc, #176]	; (540c <os_default_irq_asm+0x20>)
        LDRB    R0,[R0]
    535c:	7800      	ldrb	r0, [r0, #0]
        ADDS    R0, R0, #2
    535e:	3002      	adds	r0, #2
        MSR     CONTROL,R0
    5360:	f380 8814 	msr	CONTROL, r0
        ISB
    5364:	f3bf 8f6f 	isb	sy
        BX      LR
    5368:	4770      	bx	lr

0000536a <os_arch_init_task_stack>:
        .type   os_arch_init_task_stack, %function
        .global os_arch_init_task_stack
os_arch_init_task_stack:
        .fnstart

        STMIA   R0,{R4-R11}
    536a:	e880 0ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
        BX      LR
    536e:	4770      	bx	lr

00005370 <SVC_Handler>:
        .global SVC_Handler
SVC_Handler:
        .fnstart
        .cantunwind

        MRS     R0,PSP                  /* Read PSP */
    5370:	f3ef 8009 	mrs	r0, PSP
        LDR     R1,[R0,#24]             /* Read Saved PC from Stack */
    5374:	6981      	ldr	r1, [r0, #24]
        LDRB    R1,[R1,#-2]             /* Load SVC Number */
    5376:	f811 1c02 	ldrb.w	r1, [r1, #-2]
        CBNZ    R1,SVC_User
    537a:	b951      	cbnz	r1, 5392 <SVC_User>

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
    537c:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    5380:	b510      	push	{r4, lr}
        BLX     R12                     /* Call SVC Function */
    5382:	47e0      	blx	ip
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    5384:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

        MRS     R12,PSP                 /* Read PSP */
    5388:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R2}             /* Store return values */
    538c:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
        BX      LR                      /* Return from interrupt */
    5390:	4770      	bx	lr

00005392 <SVC_User>:

        /*------------------- User SVC ------------------------------*/
SVC_User:
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    5392:	b510      	push	{r4, lr}
        LDR     R2,=SVC_Count
    5394:	4a1e      	ldr	r2, [pc, #120]	; (5410 <os_default_irq_asm+0x24>)
        LDR     R2,[R2]
    5396:	6812      	ldr	r2, [r2, #0]
        CMP     R1,R2
    5398:	4291      	cmp	r1, r2
        BHI     SVC_Done                /* Overflow */
    539a:	d809      	bhi.n	53b0 <SVC_Done>

        LDR     R4,=SVC_Table-4
    539c:	4c1d      	ldr	r4, [pc, #116]	; (5414 <os_default_irq_asm+0x28>)
        LDR     R4,[R4,R1,LSL #2]       /* Load SVC Function Address */
    539e:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
    53a2:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        BLX     R4                      /* Call SVC Function */
    53a6:	47a0      	blx	r4

        MRS     R12,PSP
    53a8:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R3}             /* Function return values */
    53ac:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

000053b0 <SVC_Done>:
SVC_Done:
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    53b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR                      /* Return from interrupt */
    53b4:	4770      	bx	lr

000053b6 <PendSV_Handler>:
        .global PendSV_Handler
PendSV_Handler:
        .fnstart
        .cantunwind

        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
    53b6:	4b18      	ldr	r3, [pc, #96]	; (5418 <os_default_irq_asm+0x2c>)
        LDR     R2,[R3]                 /* Store in R2 */
    53b8:	681a      	ldr	r2, [r3, #0]
        LDR     R3,=g_current_task      /* Get current task */
    53ba:	4b18      	ldr	r3, [pc, #96]	; (541c <os_default_irq_asm+0x30>)
        LDR     R1,[R3]                 /* Current task in R1 */
    53bc:	6819      	ldr	r1, [r3, #0]
        CMP     R1,R2
    53be:	4291      	cmp	r1, r2
        IT      EQ
    53c0:	bf08      	it	eq
        BXEQ    LR                      /* RETI, no task switch */
    53c2:	4770      	bxeq	lr

        MRS     R12,PSP                 /* Read PSP */
    53c4:	f3ef 8c09 	mrs	ip, PSP
        STMDB   R12!,{R4-R11}           /* Save Old context */
    53c8:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
        STR     R12,[R1,#0]             /* Update stack pointer in current task */
    53cc:	f8c1 c000 	str.w	ip, [r1]
        STR     R2,[R3]                 /* g_current_task = highest ready */
    53d0:	601a      	str	r2, [r3, #0]

        LDR     R12,[R2,#0]             /* get stack pointer of task we will start */
    53d2:	f8d2 c000 	ldr.w	ip, [r2]
        LDMIA   R12!,{R4-R11}           /* Restore New Context */
    53d6:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
        MSR     PSP,R12                 /* Write PSP */
    53da:	f38c 8809 	msr	PSP, ip
        BX      LR                      /* Return to Thread Mode */
    53de:	4770      	bx	lr

000053e0 <SysTick_Handler>:
        .global SysTick_Handler
SysTick_Handler:
        .fnstart
        .cantunwind

        PUSH    {R4,LR}                 /* Save EXC_RETURN */
    53e0:	b510      	push	{r4, lr}
        BL      timer_handler
    53e2:	f7ff fb37 	bl	4a54 <timer_handler>
        POP     {R4,LR}                 /* Restore EXC_RETURN */
    53e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR
    53ea:	4770      	bx	lr

000053ec <os_default_irq_asm>:

        /*
         * LR = 0xfffffff9 if we were using MSP as SP
         * LR = 0xfffffffd if we were using PSP as SP
         */
        TST     LR,#4
    53ec:	f01e 0f04 	tst.w	lr, #4
        ITE     EQ
    53f0:	bf0c      	ite	eq
        MRSEQ   R3,MSP
    53f2:	f3ef 8308 	mrseq	r3, MSP
        MRSNE   R3,PSP
    53f6:	f3ef 8309 	mrsne	r3, PSP
        PUSH    {R3-R11,LR}
    53fa:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        MOV     R0, SP
    53fe:	4668      	mov	r0, sp
        BL      os_default_irq
    5400:	f7ff fc36 	bl	4c70 <os_default_irq>
        POP     {R3-R11,LR}                 /* Restore EXC_RETURN */
    5404:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        BX      LR
    5408:	4770      	bx	lr
    540a:	0000      	.short	0x0000
        .fnstart
        .cantunwind

        MOV     R0,SP           /* Copy MSP to PSP */
        MSR     PSP,R0
        LDR     R0,=os_flags
    540c:	20000a2c 	.word	0x20000a2c
        BX      LR                      /* Return from interrupt */

        /*------------------- User SVC ------------------------------*/
SVC_User:
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
        LDR     R2,=SVC_Count
    5410:	00000000 	.word	0x00000000
        LDR     R2,[R2]
        CMP     R1,R2
        BHI     SVC_Done                /* Overflow */

        LDR     R4,=SVC_Table-4
    5414:	fffffffc 	.word	0xfffffffc
        .global PendSV_Handler
PendSV_Handler:
        .fnstart
        .cantunwind

        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
    5418:	20000138 	.word	0x20000138
        LDR     R2,[R3]                 /* Store in R2 */
        LDR     R3,=g_current_task      /* Get current task */
    541c:	20000e50 	.word	0x20000e50

00005420 <os_sanity_check_list_lock>:
 *
 * @return 0 on success, error code on failure. 
 */
static int
os_sanity_check_list_lock(void)
{
    5420:	b508      	push	{r3, lr}
    int rc; 

    if (!g_os_started) {
    5422:	4b04      	ldr	r3, [pc, #16]	; (5434 <os_sanity_check_list_lock+0x14>)
    5424:	6818      	ldr	r0, [r3, #0]
    5426:	b120      	cbz	r0, 5432 <os_sanity_check_list_lock+0x12>
        return (0);
    }

    rc = os_mutex_pend(&g_os_sanity_check_mu, OS_WAIT_FOREVER);
    5428:	4803      	ldr	r0, [pc, #12]	; (5438 <os_sanity_check_list_lock+0x18>)
    542a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    542e:	f7ff fd43 	bl	4eb8 <os_mutex_pend>
    }

    return (0);
err:
    return (rc);
}
    5432:	bd08      	pop	{r3, pc}
    5434:	20000e44 	.word	0x20000e44
    5438:	20000e6c 	.word	0x20000e6c

0000543c <os_sanity_check_list_unlock>:
 *
 * @return 0 on success, error code on failure
 */
static int 
os_sanity_check_list_unlock(void)
{
    543c:	b508      	push	{r3, lr}
    int rc; 

    if (!g_os_started) {
    543e:	4b03      	ldr	r3, [pc, #12]	; (544c <os_sanity_check_list_unlock+0x10>)
    5440:	6818      	ldr	r0, [r3, #0]
    5442:	b110      	cbz	r0, 544a <os_sanity_check_list_unlock+0xe>
        return (0);
    }

    rc = os_mutex_release(&g_os_sanity_check_mu);
    5444:	4802      	ldr	r0, [pc, #8]	; (5450 <os_sanity_check_list_unlock+0x14>)
    5446:	f7ff fcef 	bl	4e28 <os_mutex_release>
    }

    return (0);
err:
    return (rc);
}
    544a:	bd08      	pop	{r3, pc}
    544c:	20000e44 	.word	0x20000e44
    5450:	20000e6c 	.word	0x20000e6c

00005454 <os_sanity_check_init>:
 *
 * @return 0 on success, error code on failure.
 */
int 
os_sanity_check_init(struct os_sanity_check *sc)
{
    5454:	b508      	push	{r3, lr}
    memset(sc, 0, sizeof(*sc)); 
    5456:	2100      	movs	r1, #0
    5458:	2214      	movs	r2, #20
    545a:	f7fe fa83 	bl	3964 <memset>

    return (0);
}
    545e:	2000      	movs	r0, #0
    5460:	bd08      	pop	{r3, pc}
	...

00005464 <os_sanity_check_register>:
 *
 * @return 0 on success, error code on failure
 */
int 
os_sanity_check_register(struct os_sanity_check *sc)
{
    5464:	b510      	push	{r4, lr}
    5466:	4604      	mov	r4, r0
    int rc;

    rc = os_sanity_check_list_lock();
    5468:	f7ff ffda 	bl	5420 <os_sanity_check_list_lock>
    if (rc != OS_OK) {
    546c:	b938      	cbnz	r0, 547e <os_sanity_check_register+0x1a>
        goto err;
    }

    SLIST_INSERT_HEAD(&g_os_sanity_check_list, sc, sc_next);
    546e:	4b04      	ldr	r3, [pc, #16]	; (5480 <os_sanity_check_register+0x1c>)
    5470:	681a      	ldr	r2, [r3, #0]
    5472:	6122      	str	r2, [r4, #16]
    5474:	601c      	str	r4, [r3, #0]
    }

    return (0);
err:
    return (rc);
}
    5476:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        goto err;
    }

    SLIST_INSERT_HEAD(&g_os_sanity_check_list, sc, sc_next);

    rc = os_sanity_check_list_unlock();
    547a:	f7ff bfdf 	b.w	543c <os_sanity_check_list_unlock>
    }

    return (0);
err:
    return (rc);
}
    547e:	bd10      	pop	{r4, pc}
    5480:	20000a70 	.word	0x20000a70

00005484 <crc16_ccitt>:
    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};
  
uint16_t
crc16_ccitt(uint16_t initial_crc, const void *buf, int len)
{
    5484:	b530      	push	{r4, r5, lr}
    const uint8_t *ptr;
    uint16_t crc;
    int counter;

    crc = initial_crc;
    ptr = buf;
    5486:	460b      	mov	r3, r1
    5488:	1a5c      	subs	r4, r3, r1

    for (counter = 0; counter < len; counter++) {
    548a:	4294      	cmp	r4, r2
    548c:	da0a      	bge.n	54a4 <crc16_ccitt+0x20>
        crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *ptr++)&0x00FF];
    548e:	f813 4b01 	ldrb.w	r4, [r3], #1
    5492:	4d05      	ldr	r5, [pc, #20]	; (54a8 <crc16_ccitt+0x24>)
    5494:	ea84 2410 	eor.w	r4, r4, r0, lsr #8
    5498:	f835 4014 	ldrh.w	r4, [r5, r4, lsl #1]
    549c:	ea84 2000 	eor.w	r0, r4, r0, lsl #8
    54a0:	b280      	uxth	r0, r0
    54a2:	e7f1      	b.n	5488 <crc16_ccitt+0x4>
    }

    return crc;
}
    54a4:	bd30      	pop	{r4, r5, pc}
    54a6:	bf00      	nop
    54a8:	000064e6 	.word	0x000064e6

000054ac <conf_init>:
conf_init(void)
{
    int rc;

    rc = 0;
    if (conf_cmd_inited) {
    54ac:	4b03      	ldr	r3, [pc, #12]	; (54bc <conf_init+0x10>)
    54ae:	781a      	ldrb	r2, [r3, #0]
    54b0:	b90a      	cbnz	r2, 54b6 <conf_init+0xa>
#endif
#ifdef NEWTMGR_PRESENT
    rc = conf_nmgr_register();
#endif
    if (!rc) {
        conf_cmd_inited = 1;
    54b2:	2201      	movs	r2, #1
    54b4:	701a      	strb	r2, [r3, #0]
    }

done:
    return rc;
}
    54b6:	2000      	movs	r0, #0
    54b8:	4770      	bx	lr
    54ba:	bf00      	nop
    54bc:	20000a74 	.word	0x20000a74

000054c0 <conf_register>:

int
conf_register(struct conf_handler *handler)
{
    SLIST_INSERT_HEAD(&conf_handlers, handler, ch_list);
    54c0:	4b02      	ldr	r3, [pc, #8]	; (54cc <conf_register+0xc>)
    54c2:	681a      	ldr	r2, [r3, #0]
    54c4:	6002      	str	r2, [r0, #0]
    54c6:	6018      	str	r0, [r3, #0]
    return 0;
}
    54c8:	2000      	movs	r0, #0
    54ca:	4770      	bx	lr
    54cc:	20000a78 	.word	0x20000a78

000054d0 <conf_handler_lookup>:
/*
 * Find conf_handler based on name.
 */
struct conf_handler *
conf_handler_lookup(char *name)
{
    54d0:	b538      	push	{r3, r4, r5, lr}
    struct conf_handler *ch;

    SLIST_FOREACH(ch, &conf_handlers, ch_list) {
    54d2:	4b06      	ldr	r3, [pc, #24]	; (54ec <conf_handler_lookup+0x1c>)
    54d4:	681c      	ldr	r4, [r3, #0]
/*
 * Find conf_handler based on name.
 */
struct conf_handler *
conf_handler_lookup(char *name)
{
    54d6:	4605      	mov	r5, r0
    struct conf_handler *ch;

    SLIST_FOREACH(ch, &conf_handlers, ch_list) {
    54d8:	b134      	cbz	r4, 54e8 <conf_handler_lookup+0x18>
        if (!strcmp(name, ch->ch_name)) {
    54da:	4628      	mov	r0, r5
    54dc:	6861      	ldr	r1, [r4, #4]
    54de:	f000 fd30 	bl	5f42 <strcmp>
    54e2:	b108      	cbz	r0, 54e8 <conf_handler_lookup+0x18>
struct conf_handler *
conf_handler_lookup(char *name)
{
    struct conf_handler *ch;

    SLIST_FOREACH(ch, &conf_handlers, ch_list) {
    54e4:	6824      	ldr	r4, [r4, #0]
    54e6:	e7f7      	b.n	54d8 <conf_handler_lookup+0x8>
        if (!strcmp(name, ch->ch_name)) {
            return ch;
        }
    }
    return NULL;
}
    54e8:	4620      	mov	r0, r4
    54ea:	bd38      	pop	{r3, r4, r5, pc}
    54ec:	20000a78 	.word	0x20000a78

000054f0 <conf_parse_name>:
/*
 * Separate string into argv array.
 */
int
conf_parse_name(char *name, int *name_argc, char *name_argv[])
{
    54f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    54f2:	460d      	mov	r5, r1
    54f4:	4616      	mov	r6, r2
    char *tok;
    char *tok_ptr;
    char *sep = CONF_NAME_SEPARATOR;
    int i;

    tok = strtok_r(name, sep, &tok_ptr);
    54f6:	4909      	ldr	r1, [pc, #36]	; (551c <conf_parse_name+0x2c>)
    54f8:	aa01      	add	r2, sp, #4
    54fa:	f000 fd2c 	bl	5f56 <strtok_r>

    i = 0;
    while (tok) {
    54fe:	2400      	movs	r4, #0
    5500:	b140      	cbz	r0, 5514 <conf_parse_name+0x24>
        name_argv[i++] = tok;
    5502:	f846 0024 	str.w	r0, [r6, r4, lsl #2]
        tok = strtok_r(NULL, sep, &tok_ptr);
    5506:	4905      	ldr	r1, [pc, #20]	; (551c <conf_parse_name+0x2c>)
    5508:	2000      	movs	r0, #0
    550a:	aa01      	add	r2, sp, #4
    550c:	f000 fd23 	bl	5f56 <strtok_r>
    5510:	3401      	adds	r4, #1
    5512:	e7f5      	b.n	5500 <conf_parse_name+0x10>
    }
    *name_argc = i;
    5514:	602c      	str	r4, [r5, #0]

    return 0;
}
    5516:	b002      	add	sp, #8
    5518:	bd70      	pop	{r4, r5, r6, pc}
    551a:	bf00      	nop
    551c:	00006304 	.word	0x00006304

00005520 <conf_parse_and_lookup>:

static struct conf_handler *
conf_parse_and_lookup(char *name, int *name_argc, char *name_argv[])
{
    5520:	b510      	push	{r4, lr}
    5522:	4614      	mov	r4, r2
    int rc;

    rc = conf_parse_name(name, name_argc, name_argv);
    5524:	f7ff ffe4 	bl	54f0 <conf_parse_name>
    if (rc) {
    5528:	b920      	cbnz	r0, 5534 <conf_parse_and_lookup+0x14>
        return NULL;
    }
    return conf_handler_lookup(name_argv[0]);
    552a:	6820      	ldr	r0, [r4, #0]
}
    552c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

    rc = conf_parse_name(name, name_argc, name_argv);
    if (rc) {
        return NULL;
    }
    return conf_handler_lookup(name_argv[0]);
    5530:	f7ff bfce 	b.w	54d0 <conf_handler_lookup>
}
    5534:	2000      	movs	r0, #0
    5536:	bd10      	pop	{r4, pc}

00005538 <conf_bytes_from_str>:
    return OS_INVALID_PARM;
}

int
conf_bytes_from_str(char *val_str, void *vp, int *len)
{
    5538:	b570      	push	{r4, r5, r6, lr}
    553a:	4614      	mov	r4, r2
    553c:	4606      	mov	r6, r0
    553e:	460d      	mov	r5, r1
    int tmp;

    if (base64_decode_len(val_str) > *len) {
    5540:	f000 fde2 	bl	6108 <base64_decode_len>
    5544:	6823      	ldr	r3, [r4, #0]
    5546:	4298      	cmp	r0, r3
    5548:	dd01      	ble.n	554e <conf_bytes_from_str+0x16>
        return OS_INVALID_PARM;
    554a:	2003      	movs	r0, #3
    554c:	bd70      	pop	{r4, r5, r6, pc}
    }
    tmp = base64_decode(val_str, vp);
    554e:	4630      	mov	r0, r6
    5550:	4629      	mov	r1, r5
    5552:	f000 fd83 	bl	605c <base64_decode>
    if (tmp < 0) {
    5556:	2800      	cmp	r0, #0
    5558:	dbf7      	blt.n	554a <conf_bytes_from_str+0x12>
        return OS_INVALID_PARM;
    }
    *len = tmp;
    555a:	6020      	str	r0, [r4, #0]
    return 0;
    555c:	2000      	movs	r0, #0
}
    555e:	bd70      	pop	{r4, r5, r6, pc}

00005560 <conf_str_from_bytes>:
    }
}

char *
conf_str_from_bytes(void *vp, int vp_len, char *buf, int buf_len)
{
    5560:	b570      	push	{r4, r5, r6, lr}
    if (BASE64_ENCODE_SIZE(vp_len) > buf_len) {
    5562:	2603      	movs	r6, #3
    5564:	008c      	lsls	r4, r1, #2
    5566:	fb94 f4f6 	sdiv	r4, r4, r6
    556a:	4434      	add	r4, r6
    556c:	429c      	cmp	r4, r3
    }
}

char *
conf_str_from_bytes(void *vp, int vp_len, char *buf, int buf_len)
{
    556e:	4615      	mov	r5, r2
    if (BASE64_ENCODE_SIZE(vp_len) > buf_len) {
    5570:	da04      	bge.n	557c <conf_str_from_bytes+0x1c>
        return NULL;
    }
    base64_encode(vp, vp_len, buf, 1);
    5572:	2301      	movs	r3, #1
    5574:	f000 fd24 	bl	5fc0 <base64_encode>
    return buf;
    5578:	4628      	mov	r0, r5
    557a:	bd70      	pop	{r4, r5, r6, pc}

char *
conf_str_from_bytes(void *vp, int vp_len, char *buf, int buf_len)
{
    if (BASE64_ENCODE_SIZE(vp_len) > buf_len) {
        return NULL;
    557c:	2000      	movs	r0, #0
    }
    base64_encode(vp, vp_len, buf, 1);
    return buf;
}
    557e:	bd70      	pop	{r4, r5, r6, pc}

00005580 <conf_set_value>:

int
conf_set_value(char *name, char *val_str)
{
    5580:	b510      	push	{r4, lr}
    5582:	b08a      	sub	sp, #40	; 0x28
    5584:	460c      	mov	r4, r1
    int name_argc;
    char *name_argv[CONF_MAX_DIR_DEPTH];
    struct conf_handler *ch;

    ch = conf_parse_and_lookup(name, &name_argc, name_argv);
    5586:	aa02      	add	r2, sp, #8
    5588:	a901      	add	r1, sp, #4
    558a:	f7ff ffc9 	bl	5520 <conf_parse_and_lookup>
    if (!ch) {
    558e:	b130      	cbz	r0, 559e <conf_set_value+0x1e>
        return OS_INVALID_PARM;
    }

    return ch->ch_set(name_argc - 1, &name_argv[1], val_str);
    5590:	68c3      	ldr	r3, [r0, #12]
    5592:	9801      	ldr	r0, [sp, #4]
    5594:	a903      	add	r1, sp, #12
    5596:	4622      	mov	r2, r4
    5598:	3801      	subs	r0, #1
    559a:	4798      	blx	r3
    559c:	e000      	b.n	55a0 <conf_set_value+0x20>
    char *name_argv[CONF_MAX_DIR_DEPTH];
    struct conf_handler *ch;

    ch = conf_parse_and_lookup(name, &name_argc, name_argv);
    if (!ch) {
        return OS_INVALID_PARM;
    559e:	2003      	movs	r0, #3
    }

    return ch->ch_set(name_argc - 1, &name_argv[1], val_str);
}
    55a0:	b00a      	add	sp, #40	; 0x28
    55a2:	bd10      	pop	{r4, pc}

000055a4 <conf_commit>:
    return ch->ch_get(name_argc - 1, &name_argv[1], buf, buf_len);
}

int
conf_commit(char *name)
{
    55a4:	b530      	push	{r4, r5, lr}
    char *name_argv[CONF_MAX_DIR_DEPTH];
    struct conf_handler *ch;
    int rc;
    int rc2;

    if (name) {
    55a6:	4604      	mov	r4, r0
    return ch->ch_get(name_argc - 1, &name_argv[1], buf, buf_len);
}

int
conf_commit(char *name)
{
    55a8:	b08b      	sub	sp, #44	; 0x2c
    char *name_argv[CONF_MAX_DIR_DEPTH];
    struct conf_handler *ch;
    int rc;
    int rc2;

    if (name) {
    55aa:	b140      	cbz	r0, 55be <conf_commit+0x1a>
        ch = conf_parse_and_lookup(name, &name_argc, name_argv);
    55ac:	a901      	add	r1, sp, #4
    55ae:	aa02      	add	r2, sp, #8
    55b0:	f7ff ffb6 	bl	5520 <conf_parse_and_lookup>
        if (!ch) {
    55b4:	b180      	cbz	r0, 55d8 <conf_commit+0x34>
            return OS_INVALID_PARM;
        }
        if (ch->ch_commit) {
    55b6:	6900      	ldr	r0, [r0, #16]
    55b8:	b178      	cbz	r0, 55da <conf_commit+0x36>
            return ch->ch_commit();
    55ba:	4780      	blx	r0
    55bc:	e00d      	b.n	55da <conf_commit+0x36>
        } else {
            return 0;
        }
    } else {
        rc = 0;
        SLIST_FOREACH(ch, &conf_handlers, ch_list) {
    55be:	4b08      	ldr	r3, [pc, #32]	; (55e0 <conf_commit+0x3c>)
    55c0:	681d      	ldr	r5, [r3, #0]
    55c2:	b13d      	cbz	r5, 55d4 <conf_commit+0x30>
            if (ch->ch_commit) {
    55c4:	692b      	ldr	r3, [r5, #16]
    55c6:	b11b      	cbz	r3, 55d0 <conf_commit+0x2c>
                rc2 = ch->ch_commit();
    55c8:	4798      	blx	r3
                if (!rc) {
                    rc = rc2;
    55ca:	2c00      	cmp	r4, #0
    55cc:	bf08      	it	eq
    55ce:	4604      	moveq	r4, r0
        } else {
            return 0;
        }
    } else {
        rc = 0;
        SLIST_FOREACH(ch, &conf_handlers, ch_list) {
    55d0:	682d      	ldr	r5, [r5, #0]
    55d2:	e7f6      	b.n	55c2 <conf_commit+0x1e>
    55d4:	4620      	mov	r0, r4
    55d6:	e000      	b.n	55da <conf_commit+0x36>
    int rc2;

    if (name) {
        ch = conf_parse_and_lookup(name, &name_argc, name_argv);
        if (!ch) {
            return OS_INVALID_PARM;
    55d8:	2003      	movs	r0, #3
                }
            }
        }
        return rc;
    }
}
    55da:	b00b      	add	sp, #44	; 0x2c
    55dc:	bd30      	pop	{r4, r5, pc}
    55de:	bf00      	nop
    55e0:	20000a78 	.word	0x20000a78

000055e4 <conf_file_src>:
 * Register a file to be a source of configuration.
 */
int
conf_file_src(struct conf_file *cf)
{
    if (!cf->cf_name) {
    55e4:	6882      	ldr	r2, [r0, #8]
/*
 * Register a file to be a source of configuration.
 */
int
conf_file_src(struct conf_file *cf)
{
    55e6:	b508      	push	{r3, lr}
    if (!cf->cf_name) {
    55e8:	b12a      	cbz	r2, 55f6 <conf_file_src+0x12>
        return OS_INVALID_PARM;
    }
    cf->cf_store.cs_itf = &conf_file_itf;
    55ea:	4a04      	ldr	r2, [pc, #16]	; (55fc <conf_file_src+0x18>)
    55ec:	6042      	str	r2, [r0, #4]
    conf_src_register(&cf->cf_store);
    55ee:	f000 f9bb 	bl	5968 <conf_src_register>

    return OS_OK;
    55f2:	2000      	movs	r0, #0
    55f4:	bd08      	pop	{r3, pc}
 */
int
conf_file_src(struct conf_file *cf)
{
    if (!cf->cf_name) {
        return OS_INVALID_PARM;
    55f6:	2003      	movs	r0, #3
    }
    cf->cf_store.cs_itf = &conf_file_itf;
    conf_src_register(&cf->cf_store);

    return OS_OK;
}
    55f8:	bd08      	pop	{r3, pc}
    55fa:	bf00      	nop
    55fc:	20000148 	.word	0x20000148

00005600 <conf_file_dst>:

int
conf_file_dst(struct conf_file *cf)
{
    if (!cf->cf_name) {
    5600:	6882      	ldr	r2, [r0, #8]
    return OS_OK;
}

int
conf_file_dst(struct conf_file *cf)
{
    5602:	b508      	push	{r3, lr}
    if (!cf->cf_name) {
    5604:	b12a      	cbz	r2, 5612 <conf_file_dst+0x12>
        return OS_INVALID_PARM;
    }
    cf->cf_store.cs_itf = &conf_file_itf;
    5606:	4a04      	ldr	r2, [pc, #16]	; (5618 <conf_file_dst+0x18>)
    5608:	6042      	str	r2, [r0, #4]
    conf_dst_register(&cf->cf_store);
    560a:	f000 f9c1 	bl	5990 <conf_dst_register>

    return OS_OK;
    560e:	2000      	movs	r0, #0
    5610:	bd08      	pop	{r3, pc}

int
conf_file_dst(struct conf_file *cf)
{
    if (!cf->cf_name) {
        return OS_INVALID_PARM;
    5612:	2003      	movs	r0, #3
    }
    cf->cf_store.cs_itf = &conf_file_itf;
    conf_dst_register(&cf->cf_store);

    return OS_OK;
}
    5614:	bd08      	pop	{r3, pc}
    5616:	bf00      	nop
    5618:	20000148 	.word	0x20000148

0000561c <conf_getnext_line>:

int
conf_getnext_line(struct fs_file *file, char *buf, int blen, uint32_t *loc)
{
    561c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    561e:	460c      	mov	r4, r1
    int rc;
    char *end;
    uint32_t len;

    rc = fs_seek(file, *loc);
    5620:	6819      	ldr	r1, [r3, #0]
    return OS_OK;
}

int
conf_getnext_line(struct fs_file *file, char *buf, int blen, uint32_t *loc)
{
    5622:	4607      	mov	r7, r0
    5624:	4616      	mov	r6, r2
    5626:	461d      	mov	r5, r3
    int rc;
    char *end;
    uint32_t len;

    rc = fs_seek(file, *loc);
    5628:	f000 fa42 	bl	5ab0 <fs_seek>
    if (rc < 0) {
    562c:	2800      	cmp	r0, #0
    562e:	da04      	bge.n	563a <conf_getnext_line+0x1e>
        *loc = 0;
    5630:	2300      	movs	r3, #0
    5632:	602b      	str	r3, [r5, #0]
        return -1;
    5634:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5638:	e023      	b.n	5682 <conf_getnext_line+0x66>
    }
    rc = fs_read(file, blen, buf, &len);
    563a:	4638      	mov	r0, r7
    563c:	4631      	mov	r1, r6
    563e:	4622      	mov	r2, r4
    5640:	ab01      	add	r3, sp, #4
    5642:	f000 fa25 	bl	5a90 <fs_read>
    if (rc < 0 || len == 0) {
    5646:	2800      	cmp	r0, #0
    5648:	dbf2      	blt.n	5630 <conf_getnext_line+0x14>
    564a:	9b01      	ldr	r3, [sp, #4]
    564c:	2b00      	cmp	r3, #0
    564e:	d0ef      	beq.n	5630 <conf_getnext_line+0x14>
        *loc = 0;
        return -1;
    }
    if (len == blen) {
    5650:	42b3      	cmp	r3, r6
        len--;
    5652:	bf04      	itt	eq
    5654:	f103 33ff 	addeq.w	r3, r3, #4294967295	; 0xffffffff
    5658:	9301      	streq	r3, [sp, #4]
    }
    buf[len] = '\0';
    565a:	9b01      	ldr	r3, [sp, #4]
    565c:	2600      	movs	r6, #0

    end = strchr(buf, '\n');
    565e:	210a      	movs	r1, #10
        return -1;
    }
    if (len == blen) {
        len--;
    }
    buf[len] = '\0';
    5660:	54e6      	strb	r6, [r4, r3]

    end = strchr(buf, '\n');
    5662:	4620      	mov	r0, r4
    5664:	f7fe f986 	bl	3974 <strchr>
    if (end) {
    5668:	4601      	mov	r1, r0
    566a:	b108      	cbz	r0, 5670 <conf_getnext_line+0x54>
        *end = '\0';
    566c:	7006      	strb	r6, [r0, #0]
    566e:	e003      	b.n	5678 <conf_getnext_line+0x5c>
    } else {
        end = strchr(buf, '\0');
    5670:	4620      	mov	r0, r4
    5672:	f7fe f97f 	bl	3974 <strchr>
    5676:	4601      	mov	r1, r0
    5678:	682b      	ldr	r3, [r5, #0]
    }
    blen = end - buf;
    567a:	1b08      	subs	r0, r1, r4
    567c:	3301      	adds	r3, #1
    *loc += (blen + 1);
    567e:	4403      	add	r3, r0
    5680:	602b      	str	r3, [r5, #0]
    return blen;
}
    5682:	b003      	add	sp, #12
    5684:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005686 <conf_file_load>:
 * Called to load configuration items. cb must be called for every configuration
 * item found.
 */
static int
conf_file_load(struct conf_store *cs, load_cb cb, void *cb_arg)
{
    5686:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    568a:	b0dc      	sub	sp, #368	; 0x170
    568c:	4606      	mov	r6, r0
    568e:	460f      	mov	r7, r1
    5690:	4690      	mov	r8, r2
    char *name_str;
    char *val_str;
    int rc;
    int lines;

    rc = fs_open(cf->cf_name, FS_ACCESS_READ, &file);
    5692:	6880      	ldr	r0, [r0, #8]
    5694:	2101      	movs	r1, #1
    5696:	466a      	mov	r2, sp
    5698:	f000 f9ee 	bl	5a78 <fs_open>
    if (rc != FS_EOK) {
    569c:	b9f8      	cbnz	r0, 56de <conf_file_load+0x58>
        return OS_EINVAL;
    }

    loc = 0;
    569e:	9001      	str	r0, [sp, #4]
    lines = 0;
    56a0:	4604      	mov	r4, r0
    while (1) {
        rc = conf_getnext_line(file, tmpbuf, sizeof(tmpbuf), &loc);
    56a2:	9800      	ldr	r0, [sp, #0]
    56a4:	a904      	add	r1, sp, #16
    56a6:	f44f 72b0 	mov.w	r2, #352	; 0x160
    56aa:	ab01      	add	r3, sp, #4
    56ac:	f7ff ffb6 	bl	561c <conf_getnext_line>
        if (loc == 0) {
    56b0:	9d01      	ldr	r5, [sp, #4]
    56b2:	b175      	cbz	r5, 56d2 <conf_file_load+0x4c>
            break;
        }
        if (rc < 0) {
    56b4:	2800      	cmp	r0, #0
    56b6:	dbf4      	blt.n	56a2 <conf_file_load+0x1c>
            continue;
        }
        rc = conf_line_parse(tmpbuf, &name_str, &val_str);
    56b8:	a804      	add	r0, sp, #16
    56ba:	a902      	add	r1, sp, #8
    56bc:	aa03      	add	r2, sp, #12
    56be:	f000 f8cd 	bl	585c <conf_line_parse>
        if (rc != 0) {
    56c2:	2800      	cmp	r0, #0
    56c4:	d1ed      	bne.n	56a2 <conf_file_load+0x1c>
            continue;
        }
        lines++;
        cb(name_str, val_str, cb_arg);
    56c6:	9802      	ldr	r0, [sp, #8]
    56c8:	9903      	ldr	r1, [sp, #12]
    56ca:	4642      	mov	r2, r8
        }
        rc = conf_line_parse(tmpbuf, &name_str, &val_str);
        if (rc != 0) {
            continue;
        }
        lines++;
    56cc:	3401      	adds	r4, #1
        cb(name_str, val_str, cb_arg);
    56ce:	47b8      	blx	r7
    56d0:	e7e7      	b.n	56a2 <conf_file_load+0x1c>
    }
    fs_close(file);
    56d2:	9800      	ldr	r0, [sp, #0]
    56d4:	f000 f9d6 	bl	5a84 <fs_close>
    cf->cf_lines = lines;
    56d8:	6134      	str	r4, [r6, #16]
    return OS_OK;
    56da:	4628      	mov	r0, r5
    56dc:	e000      	b.n	56e0 <conf_file_load+0x5a>
    int rc;
    int lines;

    rc = fs_open(cf->cf_name, FS_ACCESS_READ, &file);
    if (rc != FS_EOK) {
        return OS_EINVAL;
    56de:	2002      	movs	r0, #2
        cb(name_str, val_str, cb_arg);
    }
    fs_close(file);
    cf->cf_lines = lines;
    return OS_OK;
}
    56e0:	b05c      	add	sp, #368	; 0x170
    56e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

000056e8 <conf_file_compress>:
/*
 * Try to compress configuration file by keeping unique names only.
 */
void
conf_file_compress(struct conf_file *cf)
{
    56e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    56ec:	f5ad 7d40 	sub.w	sp, sp, #768	; 0x300
    56f0:	4606      	mov	r6, r0
    char *name2, *val2;
    int copy;
    int len, len2;
    int lines;

    if (fs_open(cf->cf_name, FS_ACCESS_READ, &rf) != FS_EOK) {
    56f2:	2101      	movs	r1, #1
    56f4:	6880      	ldr	r0, [r0, #8]
    56f6:	466a      	mov	r2, sp
    56f8:	f000 f9be 	bl	5a78 <fs_open>
    56fc:	4605      	mov	r5, r0
    56fe:	2800      	cmp	r0, #0
    5700:	d16e      	bne.n	57e0 <conf_file_compress+0xf8>
        return;
    }
    conf_tmpfile(tmp_file, cf->cf_name, ".cmp");
    5702:	f8d6 8008 	ldr.w	r8, [r6, #8]
conf_tmpfile(char *dst, const char *src, char *pfx)
{
    int len;
    int pfx_len;

    len = strlen(src);
    5706:	4640      	mov	r0, r8
    5708:	f7fe f949 	bl	399e <strlen>
    570c:	281b      	cmp	r0, #27
    570e:	bfa8      	it	ge
    5710:	201b      	movge	r0, #27
    5712:	4604      	mov	r4, r0
    pfx_len = strlen(pfx);
    if (len + pfx_len >= CONF_FILE_NAME_MAX) {
        len = CONF_FILE_NAME_MAX - pfx_len - 1;
    }
    memcpy(dst, src, len);
    5714:	af08      	add	r7, sp, #32
    5716:	4641      	mov	r1, r8
    5718:	4622      	mov	r2, r4
    571a:	4638      	mov	r0, r7
    571c:	f000 fbda 	bl	5ed4 <memcpy>
    memcpy(dst + len, pfx, pfx_len);
    5720:	4b31      	ldr	r3, [pc, #196]	; (57e8 <conf_file_compress+0x100>)
    5722:	681b      	ldr	r3, [r3, #0]
    5724:	513b      	str	r3, [r7, r4]
    dst[len + pfx_len] = '\0';
    5726:	ab09      	add	r3, sp, #36	; 0x24

    if (fs_open(cf->cf_name, FS_ACCESS_READ, &rf) != FS_EOK) {
        return;
    }
    conf_tmpfile(tmp_file, cf->cf_name, ".cmp");
    if (fs_open(tmp_file, FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE, &wf)) {
    5728:	4638      	mov	r0, r7
    if (len + pfx_len >= CONF_FILE_NAME_MAX) {
        len = CONF_FILE_NAME_MAX - pfx_len - 1;
    }
    memcpy(dst, src, len);
    memcpy(dst + len, pfx, pfx_len);
    dst[len + pfx_len] = '\0';
    572a:	551d      	strb	r5, [r3, r4]

    if (fs_open(cf->cf_name, FS_ACCESS_READ, &rf) != FS_EOK) {
        return;
    }
    conf_tmpfile(tmp_file, cf->cf_name, ".cmp");
    if (fs_open(tmp_file, FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE, &wf)) {
    572c:	210a      	movs	r1, #10
    572e:	aa01      	add	r2, sp, #4
    5730:	f000 f9a2 	bl	5a78 <fs_open>
    5734:	b118      	cbz	r0, 573e <conf_file_compress+0x56>
        fs_close(rf);
    5736:	9800      	ldr	r0, [sp, #0]
    5738:	f000 f9a4 	bl	5a84 <fs_close>
        return;
    573c:	e050      	b.n	57e0 <conf_file_compress+0xf8>
    }

    loc1 = 0;
    573e:	9002      	str	r0, [sp, #8]
    lines = 0;
    5740:	4604      	mov	r4, r0
    while (1) {
        len = conf_getnext_line(rf, buf1, sizeof(buf1), &loc1);
    5742:	ab02      	add	r3, sp, #8
    5744:	9800      	ldr	r0, [sp, #0]
    5746:	a910      	add	r1, sp, #64	; 0x40
    5748:	f44f 72b0 	mov.w	r2, #352	; 0x160
    574c:	f7ff ff66 	bl	561c <conf_getnext_line>
        if (loc1 == 0 || len < 0) {
    5750:	9b02      	ldr	r3, [sp, #8]
    5752:	b313      	cbz	r3, 579a <conf_file_compress+0xb2>
    5754:	2800      	cmp	r0, #0
    5756:	db20      	blt.n	579a <conf_file_compress+0xb2>
            break;
        }
        rc = conf_line_parse(buf1, &name1, &val1);
    5758:	a810      	add	r0, sp, #64	; 0x40
    575a:	a904      	add	r1, sp, #16
    575c:	aa05      	add	r2, sp, #20
    575e:	f000 f87d 	bl	585c <conf_line_parse>
        if (rc) {
    5762:	2800      	cmp	r0, #0
    5764:	d1ed      	bne.n	5742 <conf_file_compress+0x5a>
            continue;
        }
        loc2 = loc1;
    5766:	9b02      	ldr	r3, [sp, #8]
    5768:	9303      	str	r3, [sp, #12]
        copy = 1;
        while ((len2 = conf_getnext_line(rf, buf2, sizeof(buf2), &loc2)) > 0) {
    576a:	ad68      	add	r5, sp, #416	; 0x1a0
    576c:	9800      	ldr	r0, [sp, #0]
    576e:	4629      	mov	r1, r5
    5770:	f44f 72b0 	mov.w	r2, #352	; 0x160
    5774:	ab03      	add	r3, sp, #12
    5776:	f7ff ff51 	bl	561c <conf_getnext_line>
    577a:	2800      	cmp	r0, #0
    577c:	dd1c      	ble.n	57b8 <conf_file_compress+0xd0>
            rc = conf_line_parse(buf2, &name2, &val2);
    577e:	4628      	mov	r0, r5
    5780:	a906      	add	r1, sp, #24
    5782:	aa07      	add	r2, sp, #28
    5784:	f000 f86a 	bl	585c <conf_line_parse>
            if (rc) {
    5788:	2800      	cmp	r0, #0
    578a:	d1ee      	bne.n	576a <conf_file_compress+0x82>
                continue;
            }
            if (!strcmp(name1, name2)) {
    578c:	9804      	ldr	r0, [sp, #16]
    578e:	9906      	ldr	r1, [sp, #24]
    5790:	f000 fbd7 	bl	5f42 <strcmp>
    5794:	2800      	cmp	r0, #0
    5796:	d1e8      	bne.n	576a <conf_file_compress+0x82>
    5798:	e7d3      	b.n	5742 <conf_file_compress+0x5a>
        }
        buf2[len++] = '\n';
        fs_write(wf, buf2, len);
	lines++;
    }
    fs_close(wf);
    579a:	9801      	ldr	r0, [sp, #4]
    579c:	f000 f972 	bl	5a84 <fs_close>
    fs_close(rf);
    57a0:	9800      	ldr	r0, [sp, #0]
    57a2:	f000 f96f 	bl	5a84 <fs_close>
    fs_unlink(cf->cf_name);
    57a6:	68b0      	ldr	r0, [r6, #8]
    57a8:	f000 f988 	bl	5abc <fs_unlink>
    fs_rename(tmp_file, cf->cf_name);
    57ac:	4638      	mov	r0, r7
    57ae:	68b1      	ldr	r1, [r6, #8]
    57b0:	f000 f98a 	bl	5ac8 <fs_rename>
    cf->cf_lines = lines;
    57b4:	6134      	str	r4, [r6, #16]
    57b6:	e013      	b.n	57e0 <conf_file_compress+0xf8>
        }

        /*
         * Can't find one. Must copy.
         */
        len = conf_line_make(buf2, sizeof(buf2), name1, val1);
    57b8:	9a04      	ldr	r2, [sp, #16]
    57ba:	9b05      	ldr	r3, [sp, #20]
    57bc:	4628      	mov	r0, r5
    57be:	f44f 71b0 	mov.w	r1, #352	; 0x160
    57c2:	f000 f888 	bl	58d6 <conf_line_make>
        if (len < 0 || len + 2 > sizeof(buf2)) {
    57c6:	f5b0 7faf 	cmp.w	r0, #350	; 0x15e
        }

        /*
         * Can't find one. Must copy.
         */
        len = conf_line_make(buf2, sizeof(buf2), name1, val1);
    57ca:	4602      	mov	r2, r0
        if (len < 0 || len + 2 > sizeof(buf2)) {
    57cc:	d8b9      	bhi.n	5742 <conf_file_compress+0x5a>
            continue;
        }
        buf2[len++] = '\n';
    57ce:	230a      	movs	r3, #10
    57d0:	54ab      	strb	r3, [r5, r2]
        fs_write(wf, buf2, len);
    57d2:	9801      	ldr	r0, [sp, #4]
    57d4:	4629      	mov	r1, r5
    57d6:	3201      	adds	r2, #1
    57d8:	f000 f964 	bl	5aa4 <fs_write>
	lines++;
    57dc:	3401      	adds	r4, #1
    57de:	e7b0      	b.n	5742 <conf_file_compress+0x5a>
    cf->cf_lines = lines;
    /*
     * XXX at conf_file_load(), look for .cmp if actual file does not
     * exist.
     */
}
    57e0:	f50d 7d40 	add.w	sp, sp, #768	; 0x300
    57e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    57e8:	000066ea 	.word	0x000066ea

000057ec <conf_file_save>:
/*
 * Called to save configuration.
 */
static int
conf_file_save(struct conf_store *cs, const char *name, const char *value)
{
    57ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    57ee:	4604      	mov	r4, r0
    57f0:	b0db      	sub	sp, #364	; 0x16c
    57f2:	4617      	mov	r7, r2
    struct fs_file *file;
    char buf[CONF_MAX_NAME_LEN + CONF_MAX_VAL_LEN + 32];
    int len;
    int rc;

    if (!name) {
    57f4:	460d      	mov	r5, r1
    57f6:	b909      	cbnz	r1, 57fc <conf_file_save+0x10>
        return OS_INVALID_PARM;
    57f8:	2003      	movs	r0, #3
    57fa:	e02d      	b.n	5858 <conf_file_save+0x6c>
    }

    if (cf->cf_maxlines && (cf->cf_lines + 1 >= cf->cf_maxlines)) {
    57fc:	68c2      	ldr	r2, [r0, #12]
    57fe:	b12a      	cbz	r2, 580c <conf_file_save+0x20>
    5800:	6901      	ldr	r1, [r0, #16]
    5802:	3101      	adds	r1, #1
    5804:	4291      	cmp	r1, r2
    5806:	db01      	blt.n	580c <conf_file_save+0x20>
        /*
         * Compress before config file size exceeds the max number of lines.
         */
        conf_file_compress(cf);
    5808:	f7ff ff6e 	bl	56e8 <conf_file_compress>
    }
    len = conf_line_make(buf, sizeof(buf), name, value);
    580c:	ae02      	add	r6, sp, #8
    580e:	462a      	mov	r2, r5
    5810:	4630      	mov	r0, r6
    5812:	f44f 71b0 	mov.w	r1, #352	; 0x160
    5816:	463b      	mov	r3, r7
    5818:	f000 f85d 	bl	58d6 <conf_line_make>
    if (len < 0 || len + 2 > sizeof(buf)) {
    581c:	f5b0 7faf 	cmp.w	r0, #350	; 0x15e
        /*
         * Compress before config file size exceeds the max number of lines.
         */
        conf_file_compress(cf);
    }
    len = conf_line_make(buf, sizeof(buf), name, value);
    5820:	4605      	mov	r5, r0
    if (len < 0 || len + 2 > sizeof(buf)) {
    5822:	d8e9      	bhi.n	57f8 <conf_file_save+0xc>
        return OS_INVALID_PARM;
    }
    buf[len++] = '\n';
    5824:	230a      	movs	r3, #10
    5826:	5433      	strb	r3, [r6, r0]

    /*
     * Open the file to add this one value.
     */
    if (fs_open(cf->cf_name, FS_ACCESS_WRITE | FS_ACCESS_APPEND, &file)) {
    5828:	2106      	movs	r1, #6
    582a:	68a0      	ldr	r0, [r4, #8]
    582c:	aa01      	add	r2, sp, #4
    582e:	f000 f923 	bl	5a78 <fs_open>
    5832:	b980      	cbnz	r0, 5856 <conf_file_save+0x6a>
        return OS_EINVAL;
    }
    if (fs_write(file, buf, len)) {
    5834:	9801      	ldr	r0, [sp, #4]
    5836:	4631      	mov	r1, r6
    5838:	1c6a      	adds	r2, r5, #1
    583a:	f000 f933 	bl	5aa4 <fs_write>
    583e:	b920      	cbnz	r0, 584a <conf_file_save+0x5e>
        rc = OS_EINVAL;
    } else {
        rc = 0;
        cf->cf_lines++;
    5840:	6923      	ldr	r3, [r4, #16]
    5842:	3301      	adds	r3, #1
    5844:	6123      	str	r3, [r4, #16]
        return OS_EINVAL;
    }
    if (fs_write(file, buf, len)) {
        rc = OS_EINVAL;
    } else {
        rc = 0;
    5846:	4604      	mov	r4, r0
    5848:	e000      	b.n	584c <conf_file_save+0x60>
     */
    if (fs_open(cf->cf_name, FS_ACCESS_WRITE | FS_ACCESS_APPEND, &file)) {
        return OS_EINVAL;
    }
    if (fs_write(file, buf, len)) {
        rc = OS_EINVAL;
    584a:	2402      	movs	r4, #2
    } else {
        rc = 0;
        cf->cf_lines++;
    }
    fs_close(file);
    584c:	9801      	ldr	r0, [sp, #4]
    584e:	f000 f919 	bl	5a84 <fs_close>
    return rc;
    5852:	4620      	mov	r0, r4
    5854:	e000      	b.n	5858 <conf_file_save+0x6c>

    /*
     * Open the file to add this one value.
     */
    if (fs_open(cf->cf_name, FS_ACCESS_WRITE | FS_ACCESS_APPEND, &file)) {
        return OS_EINVAL;
    5856:	2002      	movs	r0, #2
        rc = 0;
        cf->cf_lines++;
    }
    fs_close(file);
    return rc;
}
    5858:	b05b      	add	sp, #364	; 0x16c
    585a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000585c <conf_line_parse>:
#include "config/config.h"
#include "config_priv.h"

int
conf_line_parse(char *buf, char **namep, char **valp)
{
    585c:	b570      	push	{r4, r5, r6, lr}
        FIND_NAME_END,
        FIND_VAL,
        FIND_VAL_END
    } state = FIND_NAME;

    *valp = NULL;
    585e:	2400      	movs	r4, #0
    5860:	6014      	str	r4, [r2, #0]
    5862:	4605      	mov	r5, r0
    for (cp = buf; *cp != '\0'; cp++) {
    5864:	f810 3b01 	ldrb.w	r3, [r0], #1
    5868:	b373      	cbz	r3, 58c8 <conf_line_parse+0x6c>
        switch (state) {
    586a:	2c03      	cmp	r4, #3
    586c:	d8f9      	bhi.n	5862 <conf_line_parse+0x6>
    586e:	e8df f004 	tbb	[pc, r4]
    5872:	0d02      	.short	0x0d02
    5874:	1f14      	.short	0x1f14
	return __c < 0x20;
}

__extern_inline int isspace(int __c)
{
	return __c == ' ' || __c == '\n' || __c == '\t' || __c == '\r';
    5876:	2b20      	cmp	r3, #32
    5878:	d0f3      	beq.n	5862 <conf_line_parse+0x6>
    587a:	f1a3 0609 	sub.w	r6, r3, #9
    587e:	2e01      	cmp	r6, #1
    5880:	d9ef      	bls.n	5862 <conf_line_parse+0x6>
    5882:	2b0d      	cmp	r3, #13
    5884:	d0ed      	beq.n	5862 <conf_line_parse+0x6>
        case FIND_NAME:
            if (!isspace((unsigned char)*cp)) {
                *namep = cp;
    5886:	600d      	str	r5, [r1, #0]
                state = FIND_NAME_END;
    5888:	2401      	movs	r4, #1
    588a:	e7ea      	b.n	5862 <conf_line_parse+0x6>
            }
            break;
        case FIND_NAME_END:
            if (*cp == '=') {
    588c:	2b3d      	cmp	r3, #61	; 0x3d
    588e:	d10f      	bne.n	58b0 <conf_line_parse+0x54>
                *cp = '\0';
    5890:	2300      	movs	r3, #0
    5892:	f800 3c01 	strb.w	r3, [r0, #-1]
                state = FIND_VAL;
    5896:	2402      	movs	r4, #2
    5898:	e7e3      	b.n	5862 <conf_line_parse+0x6>
    589a:	2b20      	cmp	r3, #32
    589c:	d0e1      	beq.n	5862 <conf_line_parse+0x6>
    589e:	f1a3 0609 	sub.w	r6, r3, #9
    58a2:	2e01      	cmp	r6, #1
    58a4:	d9dd      	bls.n	5862 <conf_line_parse+0x6>
    58a6:	2b0d      	cmp	r3, #13
    58a8:	d0db      	beq.n	5862 <conf_line_parse+0x6>
                *cp = '\0';
            }
            break;
        case FIND_VAL:
            if (!isspace((unsigned char)*cp)) {
                *valp = cp;
    58aa:	6015      	str	r5, [r2, #0]
                state = FIND_VAL_END;
    58ac:	2403      	movs	r4, #3
    58ae:	e7d8      	b.n	5862 <conf_line_parse+0x6>
    58b0:	2b20      	cmp	r3, #32
    58b2:	d005      	beq.n	58c0 <conf_line_parse+0x64>
    58b4:	f1a3 0509 	sub.w	r5, r3, #9
    58b8:	2d01      	cmp	r5, #1
    58ba:	d901      	bls.n	58c0 <conf_line_parse+0x64>
    58bc:	2b0d      	cmp	r3, #13
    58be:	d1d0      	bne.n	5862 <conf_line_parse+0x6>
            }
            break;
        case FIND_VAL_END:
            if (isspace((unsigned char)*cp)) {
                *cp = '\0';
    58c0:	2300      	movs	r3, #0
    58c2:	f800 3c01 	strb.w	r3, [r0, #-1]
    58c6:	e7cc      	b.n	5862 <conf_line_parse+0x6>
            }
            break;
        }
    }
    if (state == FIND_VAL_END || state == FIND_VAL) {
    58c8:	1ea0      	subs	r0, r4, #2
    58ca:	2801      	cmp	r0, #1
    58cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    58d0:	bf98      	it	ls
    58d2:	2000      	movls	r0, #0
        return 0;
    } else {
        return -1;
    }
}
    58d4:	bd70      	pop	{r4, r5, r6, pc}

000058d6 <conf_line_make>:

int
conf_line_make(char *dst, int dlen, const char *name, const char *value)
{
    58d6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    58da:	4605      	mov	r5, r0
    int nlen;
    int vlen;
    int off;

    nlen = strlen(name);
    58dc:	4610      	mov	r0, r2
    }
}

int
conf_line_make(char *dst, int dlen, const char *name, const char *value)
{
    58de:	4689      	mov	r9, r1
    58e0:	4690      	mov	r8, r2
    58e2:	461e      	mov	r6, r3
    int nlen;
    int vlen;
    int off;

    nlen = strlen(name);
    58e4:	f7fe f85b 	bl	399e <strlen>
    58e8:	4607      	mov	r7, r0
    if (value) {
    58ea:	b126      	cbz	r6, 58f6 <conf_line_make+0x20>
        vlen = strlen(value);
    58ec:	4630      	mov	r0, r6
    58ee:	f7fe f856 	bl	399e <strlen>
    58f2:	4604      	mov	r4, r0
    58f4:	e000      	b.n	58f8 <conf_line_make+0x22>
    } else {
        vlen = 0;
    58f6:	4634      	mov	r4, r6
    }
    if (nlen + vlen + 2 > dlen) {
    58f8:	193b      	adds	r3, r7, r4
    58fa:	3301      	adds	r3, #1
    58fc:	454b      	cmp	r3, r9
    58fe:	da14      	bge.n	592a <conf_line_make+0x54>
        return -1;
    }
    memcpy(dst, name, nlen);
    5900:	4641      	mov	r1, r8
    5902:	463a      	mov	r2, r7
    5904:	4628      	mov	r0, r5
    5906:	f000 fae5 	bl	5ed4 <memcpy>
    off = nlen;
    dst[off++] = '=';
    590a:	f107 0801 	add.w	r8, r7, #1
    590e:	233d      	movs	r3, #61	; 0x3d
    5910:	55eb      	strb	r3, [r5, r7]

    memcpy(dst + off, value, vlen);
    5912:	eb05 0008 	add.w	r0, r5, r8
    5916:	4631      	mov	r1, r6
    5918:	4622      	mov	r2, r4
    591a:	f000 fadb 	bl	5ed4 <memcpy>
    off += vlen;
    591e:	eb08 0004 	add.w	r0, r8, r4
    dst[off] = '\0';
    5922:	2300      	movs	r3, #0
    5924:	542b      	strb	r3, [r5, r0]

    return off;
    5926:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        vlen = strlen(value);
    } else {
        vlen = 0;
    }
    if (nlen + vlen + 2 > dlen) {
        return -1;
    592a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    memcpy(dst + off, value, vlen);
    off += vlen;
    dst[off] = '\0';

    return off;
}
    592e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00005932 <conf_load_cb>:
}

static void
conf_load_cb(char *name, char *val, void *cb_arg)
{
    conf_set_value(name, val);
    5932:	f7ff be25 	b.w	5580 <conf_set_value>

00005936 <conf_dup_check_cb>:
    return conf_commit(NULL);
}

static void
conf_dup_check_cb(char *name, char *val, void *cb_arg)
{
    5936:	b538      	push	{r3, r4, r5, lr}
    5938:	460d      	mov	r5, r1
    struct conf_dup_check_arg *cdca = (struct conf_dup_check_arg *)cb_arg;

    if (strcmp(name, cdca->name)) {
    593a:	6811      	ldr	r1, [r2, #0]
    return conf_commit(NULL);
}

static void
conf_dup_check_cb(char *name, char *val, void *cb_arg)
{
    593c:	4614      	mov	r4, r2
    struct conf_dup_check_arg *cdca = (struct conf_dup_check_arg *)cb_arg;

    if (strcmp(name, cdca->name)) {
    593e:	f000 fb00 	bl	5f42 <strcmp>
    5942:	b980      	cbnz	r0, 5966 <conf_dup_check_cb+0x30>
    5944:	6861      	ldr	r1, [r4, #4]
        return;
    }
    if (!val) {
    5946:	b925      	cbnz	r5, 5952 <conf_dup_check_cb+0x1c>
        if (!cdca->val || cdca->val[0] == '\0') {
    5948:	b109      	cbz	r1, 594e <conf_dup_check_cb+0x18>
    594a:	780b      	ldrb	r3, [r1, #0]
    594c:	b913      	cbnz	r3, 5954 <conf_dup_check_cb+0x1e>
            cdca->is_dup = 1;
    594e:	2301      	movs	r3, #1
    5950:	e001      	b.n	5956 <conf_dup_check_cb+0x20>
        } else {
            cdca->is_dup = 0;
        }
    } else {
        if (cdca->val && !strcmp(val, cdca->val)) {
    5952:	b911      	cbnz	r1, 595a <conf_dup_check_cb+0x24>
    }
    if (!val) {
        if (!cdca->val || cdca->val[0] == '\0') {
            cdca->is_dup = 1;
        } else {
            cdca->is_dup = 0;
    5954:	2300      	movs	r3, #0
    5956:	60a3      	str	r3, [r4, #8]
    5958:	bd38      	pop	{r3, r4, r5, pc}
        }
    } else {
        if (cdca->val && !strcmp(val, cdca->val)) {
    595a:	4628      	mov	r0, r5
    595c:	f000 faf1 	bl	5f42 <strcmp>
    5960:	2800      	cmp	r0, #0
    5962:	d1f7      	bne.n	5954 <conf_dup_check_cb+0x1e>
    5964:	e7f3      	b.n	594e <conf_dup_check_cb+0x18>
    5966:	bd38      	pop	{r3, r4, r5, pc}

00005968 <conf_src_register>:
conf_src_register(struct conf_store *cs)
{
    struct conf_store *prev, *cur;

    prev = NULL;
    SLIST_FOREACH(cur, &conf_load_srcs, cs_next) {
    5968:	4a08      	ldr	r2, [pc, #32]	; (598c <conf_src_register+0x24>)
struct conf_store_head conf_load_srcs = SLIST_HEAD_INITIALIZER(&conf_load_srcs);
struct conf_store *conf_save_dst;

void
conf_src_register(struct conf_store *cs)
{
    596a:	b510      	push	{r4, lr}
    struct conf_store *prev, *cur;

    prev = NULL;
    SLIST_FOREACH(cur, &conf_load_srcs, cs_next) {
    596c:	6814      	ldr	r4, [r2, #0]
void
conf_src_register(struct conf_store *cs)
{
    struct conf_store *prev, *cur;

    prev = NULL;
    596e:	2300      	movs	r3, #0
    SLIST_FOREACH(cur, &conf_load_srcs, cs_next) {
    5970:	4621      	mov	r1, r4
    5972:	b111      	cbz	r1, 597a <conf_src_register+0x12>
    5974:	460b      	mov	r3, r1
    5976:	6809      	ldr	r1, [r1, #0]
    5978:	e7fb      	b.n	5972 <conf_src_register+0xa>
        prev = cur;
    }
    if (!prev) {
    597a:	b913      	cbnz	r3, 5982 <conf_src_register+0x1a>
        SLIST_INSERT_HEAD(&conf_load_srcs, cs, cs_next);
    597c:	6004      	str	r4, [r0, #0]
    597e:	6010      	str	r0, [r2, #0]
    5980:	bd10      	pop	{r4, pc}
    } else {
        SLIST_INSERT_AFTER(prev, cs, cs_next);
    5982:	681a      	ldr	r2, [r3, #0]
    5984:	6002      	str	r2, [r0, #0]
    5986:	6018      	str	r0, [r3, #0]
    5988:	bd10      	pop	{r4, pc}
    598a:	bf00      	nop
    598c:	20000a7c 	.word	0x20000a7c

00005990 <conf_dst_register>:
}

void
conf_dst_register(struct conf_store *cs)
{
    conf_save_dst = cs;
    5990:	4b01      	ldr	r3, [pc, #4]	; (5998 <conf_dst_register+0x8>)
    5992:	6018      	str	r0, [r3, #0]
    5994:	4770      	bx	lr
    5996:	bf00      	nop
    5998:	20000fc8 	.word	0x20000fc8

0000599c <conf_load>:
     *    load config
     *    apply config
     *    commit all
     */

    SLIST_FOREACH(cs, &conf_load_srcs, cs_next) {
    599c:	4b08      	ldr	r3, [pc, #32]	; (59c0 <conf_load+0x24>)
    conf_set_value(name, val);
}

int
conf_load(void)
{
    599e:	b510      	push	{r4, lr}
     *    load config
     *    apply config
     *    commit all
     */

    SLIST_FOREACH(cs, &conf_load_srcs, cs_next) {
    59a0:	681c      	ldr	r4, [r3, #0]
    59a2:	b13c      	cbz	r4, 59b4 <conf_load+0x18>
        cs->cs_itf->csi_load(cs, conf_load_cb, NULL);
    59a4:	6863      	ldr	r3, [r4, #4]
    59a6:	4907      	ldr	r1, [pc, #28]	; (59c4 <conf_load+0x28>)
    59a8:	681b      	ldr	r3, [r3, #0]
    59aa:	4620      	mov	r0, r4
    59ac:	2200      	movs	r2, #0
    59ae:	4798      	blx	r3
     *    load config
     *    apply config
     *    commit all
     */

    SLIST_FOREACH(cs, &conf_load_srcs, cs_next) {
    59b0:	6824      	ldr	r4, [r4, #0]
    59b2:	e7f6      	b.n	59a2 <conf_load+0x6>
        cs->cs_itf->csi_load(cs, conf_load_cb, NULL);
    }
    return conf_commit(NULL);
    59b4:	4620      	mov	r0, r4
}
    59b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     */

    SLIST_FOREACH(cs, &conf_load_srcs, cs_next) {
        cs->cs_itf->csi_load(cs, conf_load_cb, NULL);
    }
    return conf_commit(NULL);
    59ba:	f7ff bdf3 	b.w	55a4 <conf_commit>
    59be:	bf00      	nop
    59c0:	20000a7c 	.word	0x20000a7c
    59c4:	00005933 	.word	0x00005933

000059c8 <conf_save_one>:
/*
 * Append a single value to persisted config. Don't store duplicate value.
 */
int
conf_save_one(const char *name, char *value)
{
    59c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct conf_store *cs;
    struct conf_dup_check_arg cdca;

    cs = conf_save_dst;
    59ca:	4b0f      	ldr	r3, [pc, #60]	; (5a08 <conf_save_one+0x40>)
    59cc:	681d      	ldr	r5, [r3, #0]
/*
 * Append a single value to persisted config. Don't store duplicate value.
 */
int
conf_save_one(const char *name, char *value)
{
    59ce:	b085      	sub	sp, #20
    59d0:	4607      	mov	r7, r0
    59d2:	460e      	mov	r6, r1
    struct conf_store *cs;
    struct conf_dup_check_arg cdca;

    cs = conf_save_dst;
    if (!cs) {
    59d4:	b19d      	cbz	r5, 59fe <conf_save_one+0x36>
     * Check if we're writing the same value again.
     */
    cdca.name = name;
    cdca.val = value;
    cdca.is_dup = 0;
    cs->cs_itf->csi_load(cs, conf_dup_check_cb, &cdca);
    59d6:	686b      	ldr	r3, [r5, #4]
    }

    /*
     * Check if we're writing the same value again.
     */
    cdca.name = name;
    59d8:	9001      	str	r0, [sp, #4]
    cdca.val = value;
    cdca.is_dup = 0;
    59da:	2400      	movs	r4, #0

    /*
     * Check if we're writing the same value again.
     */
    cdca.name = name;
    cdca.val = value;
    59dc:	9102      	str	r1, [sp, #8]
    cdca.is_dup = 0;
    cs->cs_itf->csi_load(cs, conf_dup_check_cb, &cdca);
    59de:	681b      	ldr	r3, [r3, #0]
    /*
     * Check if we're writing the same value again.
     */
    cdca.name = name;
    cdca.val = value;
    cdca.is_dup = 0;
    59e0:	9403      	str	r4, [sp, #12]
    cs->cs_itf->csi_load(cs, conf_dup_check_cb, &cdca);
    59e2:	4628      	mov	r0, r5
    59e4:	4909      	ldr	r1, [pc, #36]	; (5a0c <conf_save_one+0x44>)
    59e6:	aa01      	add	r2, sp, #4
    59e8:	4798      	blx	r3
    if (cdca.is_dup == 1) {
    59ea:	9b03      	ldr	r3, [sp, #12]
    59ec:	2b01      	cmp	r3, #1
    59ee:	d008      	beq.n	5a02 <conf_save_one+0x3a>
        return 0;
    }
    return cs->cs_itf->csi_save(cs, name, value);
    59f0:	686b      	ldr	r3, [r5, #4]
    59f2:	4628      	mov	r0, r5
    59f4:	689b      	ldr	r3, [r3, #8]
    59f6:	4639      	mov	r1, r7
    59f8:	4632      	mov	r2, r6
    59fa:	4798      	blx	r3
    59fc:	e002      	b.n	5a04 <conf_save_one+0x3c>
    struct conf_store *cs;
    struct conf_dup_check_arg cdca;

    cs = conf_save_dst;
    if (!cs) {
        return OS_ENOENT;
    59fe:	200a      	movs	r0, #10
    5a00:	e000      	b.n	5a04 <conf_save_one+0x3c>
    cdca.name = name;
    cdca.val = value;
    cdca.is_dup = 0;
    cs->cs_itf->csi_load(cs, conf_dup_check_cb, &cdca);
    if (cdca.is_dup == 1) {
        return 0;
    5a02:	4620      	mov	r0, r4
    }
    return cs->cs_itf->csi_save(cs, name, value);
}
    5a04:	b005      	add	sp, #20
    5a06:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5a08:	20000fc8 	.word	0x20000fc8
    5a0c:	00005937 	.word	0x00005937

00005a10 <log_init>:
{
#ifdef NEWTMGR_PRESENT
    int rc;
#endif

    if (log_inited) {
    5a10:	4b03      	ldr	r3, [pc, #12]	; (5a20 <log_init+0x10>)
    5a12:	781a      	ldrb	r2, [r3, #0]
    5a14:	b90a      	cbnz	r2, 5a1a <log_init+0xa>
        return (0);
    }
    log_inited = 1;
    5a16:	2201      	movs	r2, #1
    5a18:	701a      	strb	r2, [r3, #0]
        return (rc);
    }
#endif /* NEWTMGR_PRESENT */

    return (0);
}
    5a1a:	2000      	movs	r0, #0
    5a1c:	4770      	bx	lr
    5a1e:	bf00      	nop
    5a20:	20000a80 	.word	0x20000a80

00005a24 <log_register>:
log_register(char *name, struct log *log, struct log_handler *lh)
{
    log->l_name = name;
    log->l_log = lh;

    STAILQ_INSERT_TAIL(&g_log_list, log, l_next);
    5a24:	4b04      	ldr	r3, [pc, #16]	; (5a38 <log_register+0x14>)

int
log_register(char *name, struct log *log, struct log_handler *lh)
{
    log->l_name = name;
    log->l_log = lh;
    5a26:	e881 0005 	stmia.w	r1, {r0, r2}

    STAILQ_INSERT_TAIL(&g_log_list, log, l_next);
    5a2a:	685a      	ldr	r2, [r3, #4]
    5a2c:	2000      	movs	r0, #0
    5a2e:	6088      	str	r0, [r1, #8]
    5a30:	6011      	str	r1, [r2, #0]
    5a32:	3108      	adds	r1, #8
    5a34:	6059      	str	r1, [r3, #4]

    return (0);
}
    5a36:	4770      	bx	lr
    5a38:	20000158 	.word	0x20000158

00005a3c <log_console_append>:
    }

    console_write((char *) buf + LOG_ENTRY_HDR_SIZE, len - LOG_ENTRY_HDR_SIZE);

    return (0);
}
    5a3c:	2000      	movs	r0, #0
    5a3e:	4770      	bx	lr

00005a40 <log_console_read>:
log_console_read(struct log *log, void *dptr, void *buf, uint16_t offset,
        uint16_t len)
{
    /* You don't read console, console read you */
    return (OS_EINVAL);
}
    5a40:	2002      	movs	r0, #2
    5a42:	4770      	bx	lr

00005a44 <log_console_walk>:
static int
log_console_walk(struct log *log, log_walk_func_t walk_func, void *arg)
{
    /* You don't walk console, console walk you. */
    return (OS_EINVAL);
}
    5a44:	2002      	movs	r0, #2
    5a46:	4770      	bx	lr

00005a48 <log_console_flush>:
static int
log_console_flush(struct log *log)
{
    /* You don't flush console, console flush you. */
    return (OS_EINVAL);
}
    5a48:	2002      	movs	r0, #2
    5a4a:	4770      	bx	lr

00005a4c <log_console_handler_init>:

int
log_console_handler_init(struct log_handler *handler)
{
    5a4c:	4603      	mov	r3, r0
    handler->log_type = LOG_TYPE_STREAM;
    handler->log_read = log_console_read;
    5a4e:	4a06      	ldr	r2, [pc, #24]	; (5a68 <log_console_handler_init+0x1c>)
    5a50:	605a      	str	r2, [r3, #4]
    handler->log_append = log_console_append;
    5a52:	4a06      	ldr	r2, [pc, #24]	; (5a6c <log_console_handler_init+0x20>)
    5a54:	609a      	str	r2, [r3, #8]
    handler->log_walk = log_console_walk;
    5a56:	4a06      	ldr	r2, [pc, #24]	; (5a70 <log_console_handler_init+0x24>)
    5a58:	60da      	str	r2, [r3, #12]
}

int
log_console_handler_init(struct log_handler *handler)
{
    handler->log_type = LOG_TYPE_STREAM;
    5a5a:	2000      	movs	r0, #0
    handler->log_read = log_console_read;
    handler->log_append = log_console_append;
    handler->log_walk = log_console_walk;
    handler->log_flush = log_console_flush;
    5a5c:	4a05      	ldr	r2, [pc, #20]	; (5a74 <log_console_handler_init+0x28>)
}

int
log_console_handler_init(struct log_handler *handler)
{
    handler->log_type = LOG_TYPE_STREAM;
    5a5e:	6018      	str	r0, [r3, #0]
    handler->log_read = log_console_read;
    handler->log_append = log_console_append;
    handler->log_walk = log_console_walk;
    handler->log_flush = log_console_flush;
    5a60:	611a      	str	r2, [r3, #16]
    handler->log_arg = NULL;
    5a62:	6198      	str	r0, [r3, #24]
    handler->log_rtr_erase = NULL;
    5a64:	6158      	str	r0, [r3, #20]

    return (0);
}
    5a66:	4770      	bx	lr
    5a68:	00005a41 	.word	0x00005a41
    5a6c:	00005a3d 	.word	0x00005a3d
    5a70:	00005a45 	.word	0x00005a45
    5a74:	00005a49 	.word	0x00005a49

00005a78 <fs_open>:
#include "fs_priv.h"

int
fs_open(const char *filename, uint8_t access_flags, struct fs_file **out_file)
{
    return fs_root_ops->f_open(filename, access_flags, out_file);
    5a78:	4b01      	ldr	r3, [pc, #4]	; (5a80 <fs_open+0x8>)
    5a7a:	681b      	ldr	r3, [r3, #0]
    5a7c:	681b      	ldr	r3, [r3, #0]
    5a7e:	4718      	bx	r3
    5a80:	20000a84 	.word	0x20000a84

00005a84 <fs_close>:
}

int
fs_close(struct fs_file *file)
{
    return fs_root_ops->f_close(file);
    5a84:	4b01      	ldr	r3, [pc, #4]	; (5a8c <fs_close+0x8>)
    5a86:	681b      	ldr	r3, [r3, #0]
    5a88:	685b      	ldr	r3, [r3, #4]
    5a8a:	4718      	bx	r3
    5a8c:	20000a84 	.word	0x20000a84

00005a90 <fs_read>:
}

int
fs_read(struct fs_file *file, uint32_t len, void *out_data, uint32_t *out_len)
{
    5a90:	b510      	push	{r4, lr}
    return fs_root_ops->f_read(file, len, out_data, out_len);
    5a92:	4c03      	ldr	r4, [pc, #12]	; (5aa0 <fs_read+0x10>)
    5a94:	6824      	ldr	r4, [r4, #0]
    5a96:	68a4      	ldr	r4, [r4, #8]
    5a98:	46a4      	mov	ip, r4
}
    5a9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

int
fs_read(struct fs_file *file, uint32_t len, void *out_data, uint32_t *out_len)
{
    return fs_root_ops->f_read(file, len, out_data, out_len);
    5a9e:	4760      	bx	ip
    5aa0:	20000a84 	.word	0x20000a84

00005aa4 <fs_write>:
}

int
fs_write(struct fs_file *file, const void *data, int len)
{
    return fs_root_ops->f_write(file, data, len);
    5aa4:	4b01      	ldr	r3, [pc, #4]	; (5aac <fs_write+0x8>)
    5aa6:	681b      	ldr	r3, [r3, #0]
    5aa8:	68db      	ldr	r3, [r3, #12]
    5aaa:	4718      	bx	r3
    5aac:	20000a84 	.word	0x20000a84

00005ab0 <fs_seek>:
}

int
fs_seek(struct fs_file *file, uint32_t offset)
{
    return fs_root_ops->f_seek(file, offset);
    5ab0:	4b01      	ldr	r3, [pc, #4]	; (5ab8 <fs_seek+0x8>)
    5ab2:	681b      	ldr	r3, [r3, #0]
    5ab4:	691b      	ldr	r3, [r3, #16]
    5ab6:	4718      	bx	r3
    5ab8:	20000a84 	.word	0x20000a84

00005abc <fs_unlink>:
}

int
fs_unlink(const char *filename)
{
    return fs_root_ops->f_unlink(filename);
    5abc:	4b01      	ldr	r3, [pc, #4]	; (5ac4 <fs_unlink+0x8>)
    5abe:	681b      	ldr	r3, [r3, #0]
    5ac0:	69db      	ldr	r3, [r3, #28]
    5ac2:	4718      	bx	r3
    5ac4:	20000a84 	.word	0x20000a84

00005ac8 <fs_rename>:
#include "fs_priv.h"

int
fs_rename(const char *from, const char *to)
{
    return fs_root_ops->f_rename(from, to);
    5ac8:	4b01      	ldr	r3, [pc, #4]	; (5ad0 <fs_rename+0x8>)
    5aca:	681b      	ldr	r3, [r3, #0]
    5acc:	6a1b      	ldr	r3, [r3, #32]
    5ace:	4718      	bx	r3
    5ad0:	20000a84 	.word	0x20000a84

00005ad4 <fs_register>:
const struct fs_ops *fs_root_ops = NULL;

int
fs_register(const struct fs_ops *fops)
{
    if (fs_root_ops) {
    5ad4:	4a03      	ldr	r2, [pc, #12]	; (5ae4 <fs_register+0x10>)
    5ad6:	6813      	ldr	r3, [r2, #0]
    5ad8:	b913      	cbnz	r3, 5ae0 <fs_register+0xc>
        return FS_EEXIST;
    }
    fs_root_ops = fops;
    5ada:	6010      	str	r0, [r2, #0]

#ifdef SHELL_PRESENT
    fs_cli_init();
#endif

    return FS_EOK;
    5adc:	4618      	mov	r0, r3
    5ade:	4770      	bx	lr

int
fs_register(const struct fs_ops *fops)
{
    if (fs_root_ops) {
        return FS_EEXIST;
    5ae0:	200b      	movs	r0, #11
#ifdef SHELL_PRESENT
    fs_cli_init();
#endif

    return FS_EOK;
}
    5ae2:	4770      	bx	lr
    5ae4:	20000a84 	.word	0x20000a84

00005ae8 <fsutil_read_file>:
#include "fs/fs.h"

int
fsutil_read_file(const char *path, uint32_t offset, uint32_t len, void *dst,
                 uint32_t *out_len)
{
    5ae8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5aea:	4616      	mov	r6, r2
    struct fs_file *file;
    int rc;

    rc = fs_open(path, FS_ACCESS_READ, &file);
    5aec:	2101      	movs	r1, #1
    5aee:	aa01      	add	r2, sp, #4
#include "fs/fs.h"

int
fsutil_read_file(const char *path, uint32_t offset, uint32_t len, void *dst,
                 uint32_t *out_len)
{
    5af0:	461d      	mov	r5, r3
    struct fs_file *file;
    int rc;

    rc = fs_open(path, FS_ACCESS_READ, &file);
    5af2:	f7ff ffc1 	bl	5a78 <fs_open>
    if (rc != 0) {
    5af6:	4604      	mov	r4, r0
    5af8:	b930      	cbnz	r0, 5b08 <fsutil_read_file+0x20>
        goto done;
    }

    rc = fs_read(file, len, dst, out_len);
    5afa:	9801      	ldr	r0, [sp, #4]
    5afc:	9b06      	ldr	r3, [sp, #24]
    5afe:	4631      	mov	r1, r6
    5b00:	462a      	mov	r2, r5
    5b02:	f7ff ffc5 	bl	5a90 <fs_read>
    5b06:	4604      	mov	r4, r0
    }

    rc = 0;

done:
    fs_close(file);
    5b08:	9801      	ldr	r0, [sp, #4]
    5b0a:	f7ff ffbb 	bl	5a84 <fs_close>
    return rc;
}
    5b0e:	4620      	mov	r0, r4
    5b10:	b002      	add	sp, #8
    5b12:	bd70      	pop	{r4, r5, r6, pc}

00005b14 <fsutil_write_file>:

int
fsutil_write_file(const char *path, const void *data, uint32_t len)
{
    5b14:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5b16:	460e      	mov	r6, r1
    5b18:	4615      	mov	r5, r2
    struct fs_file *file;
    int rc;

    rc = fs_open(path, FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE, &file);
    5b1a:	210a      	movs	r1, #10
    5b1c:	aa01      	add	r2, sp, #4
    5b1e:	f7ff ffab 	bl	5a78 <fs_open>
    if (rc != 0) {
    5b22:	4604      	mov	r4, r0
    5b24:	b928      	cbnz	r0, 5b32 <fsutil_write_file+0x1e>
        goto done;
    }

    rc = fs_write(file, data, len);
    5b26:	9801      	ldr	r0, [sp, #4]
    5b28:	4631      	mov	r1, r6
    5b2a:	462a      	mov	r2, r5
    5b2c:	f7ff ffba 	bl	5aa4 <fs_write>
    5b30:	4604      	mov	r4, r0
    }

    rc = 0;

done:
    fs_close(file);
    5b32:	9801      	ldr	r0, [sp, #4]
    5b34:	f7ff ffa6 	bl	5a84 <fs_close>
    return rc;
}
    5b38:	4620      	mov	r0, r4
    5b3a:	b002      	add	sp, #8
    5b3c:	bd70      	pop	{r4, r5, r6, pc}
	...

00005b40 <bsp_flash_dev>:
bsp_flash_dev(uint8_t id)
{
    /*
     * Internal flash mapped to id 0.
     */
    if (id != 0) {
    5b40:	2800      	cmp	r0, #0
        return NULL;
    }
    return &nrf52k_flash_dev;
}
    5b42:	4802      	ldr	r0, [pc, #8]	; (5b4c <bsp_flash_dev+0xc>)
    5b44:	bf18      	it	ne
    5b46:	2000      	movne	r0, #0
    5b48:	4770      	bx	lr
    5b4a:	bf00      	nop
    5b4c:	000066f0 	.word	0x000066f0

00005b50 <_close>:

int
_close(int fd)
{
    return -1;
}
    5b50:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5b54:	4770      	bx	lr

00005b56 <_exit>:
}


void
_exit(int s)
{
    5b56:	b508      	push	{r3, lr}
    system_reset();
    5b58:	f000 f98e 	bl	5e78 <system_reset>

00005b5c <bsp_init>:
    return FLASH_AREA_IMAGE_0;
}

void
bsp_init(void)
{
    5b5c:	b508      	push	{r3, lr}
    /*
     * XXX this reference is here to keep this function in.
     */
    _sbrk(0);
    5b5e:	2000      	movs	r0, #0
    5b60:	f000 f80c 	bl	5b7c <_sbrk>
    _close(0);
    5b64:	2000      	movs	r0, #0
    5b66:	f7ff fff3 	bl	5b50 <_close>

    flash_area_init(bsp_flash_areas,
    5b6a:	4803      	ldr	r0, [pc, #12]	; (5b78 <bsp_init+0x1c>)
    5b6c:	2105      	movs	r1, #5
      sizeof(bsp_flash_areas) / sizeof(bsp_flash_areas[0]));
}
    5b6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     * XXX this reference is here to keep this function in.
     */
    _sbrk(0);
    _close(0);

    flash_area_init(bsp_flash_areas,
    5b72:	f7fd bcc3 	b.w	34fc <flash_area_init>
    5b76:	bf00      	nop
    5b78:	20000160 	.word	0x20000160

00005b7c <_sbrk>:

static char *brk = &__HeapBase;

void *
_sbrk(int incr)
{
    5b7c:	4a0d      	ldr	r2, [pc, #52]	; (5bb4 <_sbrk+0x38>)
    5b7e:	b508      	push	{r3, lr}
    void *prev_brk;

    if (incr < 0) {
    5b80:	1e03      	subs	r3, r0, #0
        /* Returning memory to the heap. */
        incr = -incr;
        if (brk - incr < &__HeapBase) {
    5b82:	6810      	ldr	r0, [r2, #0]
void *
_sbrk(int incr)
{
    void *prev_brk;

    if (incr < 0) {
    5b84:	da07      	bge.n	5b96 <_sbrk+0x1a>
        /* Returning memory to the heap. */
        incr = -incr;
        if (brk - incr < &__HeapBase) {
    5b86:	490c      	ldr	r1, [pc, #48]	; (5bb8 <_sbrk+0x3c>)
    5b88:	4403      	add	r3, r0
    5b8a:	428b      	cmp	r3, r1
    5b8c:	d208      	bcs.n	5ba0 <_sbrk+0x24>
            prev_brk = (void *)-1;
            errno = EINVAL;
    5b8e:	f000 fad1 	bl	6134 <__errno>
    5b92:	2316      	movs	r3, #22
    5b94:	e009      	b.n	5baa <_sbrk+0x2e>
            prev_brk = brk;
            brk -= incr;
        }
    } else {
        /* Allocating memory from the heap. */
        if (&__HeapLimit - brk >= incr) {
    5b96:	4909      	ldr	r1, [pc, #36]	; (5bbc <_sbrk+0x40>)
    5b98:	1a09      	subs	r1, r1, r0
    5b9a:	4299      	cmp	r1, r3
    5b9c:	db02      	blt.n	5ba4 <_sbrk+0x28>
            prev_brk = brk;
            brk += incr;
    5b9e:	4403      	add	r3, r0
    5ba0:	6013      	str	r3, [r2, #0]
    5ba2:	bd08      	pop	{r3, pc}
        } else {
            prev_brk = (void *)-1;
            errno = ENOMEM;
    5ba4:	f000 fac6 	bl	6134 <__errno>
    5ba8:	230c      	movs	r3, #12
    5baa:	6003      	str	r3, [r0, #0]
        /* Allocating memory from the heap. */
        if (&__HeapLimit - brk >= incr) {
            prev_brk = brk;
            brk += incr;
        } else {
            prev_brk = (void *)-1;
    5bac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
            errno = ENOMEM;
        }
    }

    return prev_brk;
}
    5bb0:	bd08      	pop	{r3, pc}
    5bb2:	bf00      	nop
    5bb4:	2000019c 	.word	0x2000019c
    5bb8:	20000fd8 	.word	0x20000fd8
    5bbc:	2000fe50 	.word	0x2000fe50

00005bc0 <nrf52k_flash_wait_ready>:

#define NRF52K_FLASH_READY() (NRF_NVMC->READY == NVMC_READY_READY_Ready)

static int
nrf52k_flash_wait_ready(void)
{
    5bc0:	4b06      	ldr	r3, [pc, #24]	; (5bdc <nrf52k_flash_wait_ready+0x1c>)
    int i;

    for (i = 0; i < 100000; i++) {
        if (NRF_NVMC->READY == NVMC_READY_READY_Ready) {
    5bc2:	4a07      	ldr	r2, [pc, #28]	; (5be0 <nrf52k_flash_wait_ready+0x20>)
    5bc4:	f8d2 2400 	ldr.w	r2, [r2, #1024]	; 0x400
    5bc8:	2a01      	cmp	r2, #1
    5bca:	d004      	beq.n	5bd6 <nrf52k_flash_wait_ready+0x16>
static int
nrf52k_flash_wait_ready(void)
{
    int i;

    for (i = 0; i < 100000; i++) {
    5bcc:	3b01      	subs	r3, #1
    5bce:	d1f8      	bne.n	5bc2 <nrf52k_flash_wait_ready+0x2>
        if (NRF_NVMC->READY == NVMC_READY_READY_Ready) {
            return 0;
        }
    }
    return -1;
    5bd0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5bd4:	4770      	bx	lr
{
    int i;

    for (i = 0; i < 100000; i++) {
        if (NRF_NVMC->READY == NVMC_READY_READY_Ready) {
            return 0;
    5bd6:	2000      	movs	r0, #0
        }
    }
    return -1;
}
    5bd8:	4770      	bx	lr
    5bda:	bf00      	nop
    5bdc:	000186a0 	.word	0x000186a0
    5be0:	4001e000 	.word	0x4001e000

00005be4 <nrf52k_flash_erase_sector>:
    return rc;
}

static int
nrf52k_flash_erase_sector(uint32_t sector_address)
{
    5be4:	b570      	push	{r4, r5, r6, lr}
    5be6:	4606      	mov	r6, r0
    int sr;
    int rc = -1;

    if (nrf52k_flash_wait_ready()) {
    5be8:	f7ff ffea 	bl	5bc0 <nrf52k_flash_wait_ready>
    5bec:	bb00      	cbnz	r0, 5c30 <nrf52k_flash_erase_sector+0x4c>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    5bee:	f3ef 8510 	mrs	r5, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    5bf2:	b672      	cpsid	i
        return -1;
    }
    __HAL_DISABLE_INTERRUPTS(sr);
    NRF_NVMC->CONFIG |= NVMC_CONFIG_WEN_Een; /* Enable erase OP */
    5bf4:	4c10      	ldr	r4, [pc, #64]	; (5c38 <nrf52k_flash_erase_sector+0x54>)
    5bf6:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
    5bfa:	f043 0302 	orr.w	r3, r3, #2
    5bfe:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    if (nrf52k_flash_wait_ready()) {
    5c02:	f7ff ffdd 	bl	5bc0 <nrf52k_flash_wait_ready>
    5c06:	b940      	cbnz	r0, 5c1a <nrf52k_flash_erase_sector+0x36>
        goto out;
    }

    NRF_NVMC->ERASEPAGE = sector_address;
    5c08:	f8c4 6508 	str.w	r6, [r4, #1288]	; 0x508
    if (nrf52k_flash_wait_ready()) {
    5c0c:	f7ff ffd8 	bl	5bc0 <nrf52k_flash_wait_ready>
    5c10:	3000      	adds	r0, #0
    5c12:	bf18      	it	ne
    5c14:	2001      	movne	r0, #1
    5c16:	4240      	negs	r0, r0
    5c18:	e001      	b.n	5c1e <nrf52k_flash_erase_sector+0x3a>

static int
nrf52k_flash_erase_sector(uint32_t sector_address)
{
    int sr;
    int rc = -1;
    5c1a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    if (nrf52k_flash_wait_ready()) {
        goto out;
    }
    rc = 0;
out:
    NRF_NVMC->CONFIG &= ~NVMC_CONFIG_WEN_Een; /* Disable erase OP */
    5c1e:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
    5c22:	f023 0302 	bic.w	r3, r3, #2
    5c26:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    __HAL_ENABLE_INTERRUPTS(sr);
    5c2a:	b91d      	cbnz	r5, 5c34 <nrf52k_flash_erase_sector+0x50>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    5c2c:	b662      	cpsie	i
    5c2e:	bd70      	pop	{r4, r5, r6, pc}
{
    int sr;
    int rc = -1;

    if (nrf52k_flash_wait_ready()) {
        return -1;
    5c30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    rc = 0;
out:
    NRF_NVMC->CONFIG &= ~NVMC_CONFIG_WEN_Een; /* Disable erase OP */
    __HAL_ENABLE_INTERRUPTS(sr);
    return rc;
}
    5c34:	bd70      	pop	{r4, r5, r6, pc}
    5c36:	bf00      	nop
    5c38:	4001e000 	.word	0x4001e000

00005c3c <nrf52k_flash_init>:

static int
nrf52k_flash_init(void)
{
    return 0;
}
    5c3c:	2000      	movs	r0, #0
    5c3e:	4770      	bx	lr

00005c40 <nrf52k_flash_write>:
/*
 * Flash write is done by writing 4 bytes at a time at a word boundary.
 */
static int
nrf52k_flash_write(uint32_t address, const void *src, uint32_t num_bytes)
{
    5c40:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    5c44:	4604      	mov	r4, r0
    5c46:	460e      	mov	r6, r1
    5c48:	4615      	mov	r5, r2
    int rc = -1;
    uint32_t val;
    int cnt;
    uint32_t tmp;

    if (nrf52k_flash_wait_ready()) {
    5c4a:	f7ff ffb9 	bl	5bc0 <nrf52k_flash_wait_ready>
    5c4e:	2800      	cmp	r0, #0
    5c50:	d153      	bne.n	5cfa <nrf52k_flash_write+0xba>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    5c52:	f3ef 8810 	mrs	r8, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    5c56:	b672      	cpsid	i
        return -1;
    }
    __HAL_DISABLE_INTERRUPTS(sr);
    NRF_NVMC->CONFIG |= NVMC_CONFIG_WEN_Wen; /* Enable erase OP */
    5c58:	4a2a      	ldr	r2, [pc, #168]	; (5d04 <nrf52k_flash_write+0xc4>)
    5c5a:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    tmp = address & 0x3;
    if (tmp) {
    5c5e:	f014 0a03 	ands.w	sl, r4, #3

    if (nrf52k_flash_wait_ready()) {
        return -1;
    }
    __HAL_DISABLE_INTERRUPTS(sr);
    NRF_NVMC->CONFIG |= NVMC_CONFIG_WEN_Wen; /* Enable erase OP */
    5c62:	f043 0301 	orr.w	r3, r3, #1
    5c66:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    tmp = address & 0x3;
    if (tmp) {
    5c6a:	d026      	beq.n	5cba <nrf52k_flash_write+0x7a>
        if (nrf52k_flash_wait_ready()) {
    5c6c:	f7ff ffa8 	bl	5bc0 <nrf52k_flash_wait_ready>
    5c70:	b110      	cbz	r0, 5c78 <nrf52k_flash_write+0x38>
 */
static int
nrf52k_flash_write(uint32_t address, const void *src, uint32_t num_bytes)
{
    int sr;
    int rc = -1;
    5c72:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5c76:	e034      	b.n	5ce2 <nrf52k_flash_write+0xa2>
        }
        /*
         * Starts at a non-word boundary. Read 4 bytes which were there
         * before, update with new data, and write back.
         */
        val = *(uint32_t *)(address & ~0x3);
    5c78:	f024 0903 	bic.w	r9, r4, #3
    5c7c:	a802      	add	r0, sp, #8
        cnt = 4 - tmp;
    5c7e:	f1ca 0704 	rsb	r7, sl, #4
        }
        /*
         * Starts at a non-word boundary. Read 4 bytes which were there
         * before, update with new data, and write back.
         */
        val = *(uint32_t *)(address & ~0x3);
    5c82:	f8d9 3000 	ldr.w	r3, [r9]
    5c86:	f840 3d04 	str.w	r3, [r0, #-4]!
        cnt = 4 - tmp;
    5c8a:	42af      	cmp	r7, r5
    5c8c:	bf28      	it	cs
    5c8e:	462f      	movcs	r7, r5
        if (cnt > num_bytes) {
            cnt = num_bytes;
        }
        memcpy((uint8_t *)&val + tmp, src, cnt);
    5c90:	4631      	mov	r1, r6
    5c92:	4450      	add	r0, sl
    5c94:	463a      	mov	r2, r7
    5c96:	f000 f91d 	bl	5ed4 <memcpy>
        *(uint32_t *)(address & ~0x3) = val;
    5c9a:	9b01      	ldr	r3, [sp, #4]
    5c9c:	f8c9 3000 	str.w	r3, [r9]
        address += cnt;
    5ca0:	443c      	add	r4, r7
        num_bytes -= cnt;
    5ca2:	1bed      	subs	r5, r5, r7
        src += cnt;
    5ca4:	443e      	add	r6, r7
    5ca6:	e008      	b.n	5cba <nrf52k_flash_write+0x7a>

    while (num_bytes >= sizeof(uint32_t)) {
        /*
         * Write data 4 bytes at a time.
         */
        if (nrf52k_flash_wait_ready()) {
    5ca8:	f7ff ff8a 	bl	5bc0 <nrf52k_flash_wait_ready>
    5cac:	2800      	cmp	r0, #0
    5cae:	d1e0      	bne.n	5c72 <nrf52k_flash_write+0x32>
            goto out;
        }
        *(uint32_t *)address = *(uint32_t *)src;
    5cb0:	f856 3b04 	ldr.w	r3, [r6], #4
    5cb4:	f844 3b04 	str.w	r3, [r4], #4
        address += sizeof(uint32_t);
        src += sizeof(uint32_t);
        num_bytes -= sizeof(uint32_t);
    5cb8:	3d04      	subs	r5, #4
        address += cnt;
        num_bytes -= cnt;
        src += cnt;
    }

    while (num_bytes >= sizeof(uint32_t)) {
    5cba:	2d03      	cmp	r5, #3
    5cbc:	d8f4      	bhi.n	5ca8 <nrf52k_flash_write+0x68>
        *(uint32_t *)address = *(uint32_t *)src;
        address += sizeof(uint32_t);
        src += sizeof(uint32_t);
        num_bytes -= sizeof(uint32_t);
    }
    if (num_bytes) {
    5cbe:	b16d      	cbz	r5, 5cdc <nrf52k_flash_write+0x9c>
        /*
         * Deal with the trailing bytes.
         */
        val = *(uint32_t *)address;
    5cc0:	a802      	add	r0, sp, #8
    5cc2:	6823      	ldr	r3, [r4, #0]
    5cc4:	f840 3d04 	str.w	r3, [r0, #-4]!
        memcpy(&val, src, num_bytes);
    5cc8:	4631      	mov	r1, r6
    5cca:	462a      	mov	r2, r5
    5ccc:	f000 f902 	bl	5ed4 <memcpy>
        if (nrf52k_flash_wait_ready()) {
    5cd0:	f7ff ff76 	bl	5bc0 <nrf52k_flash_wait_ready>
    5cd4:	2800      	cmp	r0, #0
    5cd6:	d1cc      	bne.n	5c72 <nrf52k_flash_write+0x32>
            goto out;
        }
        *(uint32_t *)address = val;
    5cd8:	9b01      	ldr	r3, [sp, #4]
    5cda:	6023      	str	r3, [r4, #0]
    }
    rc = 0;
    if (nrf52k_flash_wait_ready()) {
    5cdc:	f7ff ff70 	bl	5bc0 <nrf52k_flash_wait_ready>
        if (nrf52k_flash_wait_ready()) {
            goto out;
        }
        *(uint32_t *)address = val;
    }
    rc = 0;
    5ce0:	2000      	movs	r0, #0
    if (nrf52k_flash_wait_ready()) {
        goto out;
    }
out:
    NRF_NVMC->CONFIG &= ~NVMC_CONFIG_WEN_Wen;
    5ce2:	4a08      	ldr	r2, [pc, #32]	; (5d04 <nrf52k_flash_write+0xc4>)
    5ce4:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    5ce8:	f023 0301 	bic.w	r3, r3, #1
    5cec:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    __HAL_ENABLE_INTERRUPTS(sr);
    5cf0:	f1b8 0f00 	cmp.w	r8, #0
    5cf4:	d103      	bne.n	5cfe <nrf52k_flash_write+0xbe>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    5cf6:	b662      	cpsie	i
    5cf8:	e001      	b.n	5cfe <nrf52k_flash_write+0xbe>
    uint32_t val;
    int cnt;
    uint32_t tmp;

    if (nrf52k_flash_wait_ready()) {
        return -1;
    5cfa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }
out:
    NRF_NVMC->CONFIG &= ~NVMC_CONFIG_WEN_Wen;
    __HAL_ENABLE_INTERRUPTS(sr);
    return rc;
}
    5cfe:	b002      	add	sp, #8
    5d00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5d04:	4001e000 	.word	0x4001e000

00005d08 <nrf52k_flash_read>:
    return -1;
}

static int
nrf52k_flash_read(uint32_t address, void *dst, uint32_t num_bytes)
{
    5d08:	b508      	push	{r3, lr}
    5d0a:	4603      	mov	r3, r0
    memcpy(dst, (void *)address, num_bytes);
    5d0c:	4608      	mov	r0, r1
    5d0e:	4619      	mov	r1, r3
    5d10:	f000 f8e0 	bl	5ed4 <memcpy>
    return 0;
}
    5d14:	2000      	movs	r0, #0
    5d16:	bd08      	pop	{r3, pc}

00005d18 <nrf52k_flash_sector_info>:
}

static int
nrf52k_flash_sector_info(int idx, uint32_t *address, uint32_t *sz)
{
    assert(idx < nrf52k_flash_dev.hf_sector_cnt);
    5d18:	287f      	cmp	r0, #127	; 0x7f
    return rc;
}

static int
nrf52k_flash_sector_info(int idx, uint32_t *address, uint32_t *sz)
{
    5d1a:	b508      	push	{r3, lr}
    assert(idx < nrf52k_flash_dev.hf_sector_cnt);
    5d1c:	dd05      	ble.n	5d2a <nrf52k_flash_sector_info+0x12>
    5d1e:	2200      	movs	r2, #0
    5d20:	4805      	ldr	r0, [pc, #20]	; (5d38 <nrf52k_flash_sector_info+0x20>)
    5d22:	21af      	movs	r1, #175	; 0xaf
    5d24:	4613      	mov	r3, r2
    5d26:	f7fe ff91 	bl	4c4c <__assert_func>
    *address = idx * NRF52K_FLASH_SECTOR_SZ;
    5d2a:	0300      	lsls	r0, r0, #12
    *sz = NRF52K_FLASH_SECTOR_SZ;
    5d2c:	f44f 5380 	mov.w	r3, #4096	; 0x1000

static int
nrf52k_flash_sector_info(int idx, uint32_t *address, uint32_t *sz)
{
    assert(idx < nrf52k_flash_dev.hf_sector_cnt);
    *address = idx * NRF52K_FLASH_SECTOR_SZ;
    5d30:	6008      	str	r0, [r1, #0]
    *sz = NRF52K_FLASH_SECTOR_SZ;
    5d32:	6013      	str	r3, [r2, #0]
    return 0;
}
    5d34:	2000      	movs	r0, #0
    5d36:	bd08      	pop	{r3, pc}
    5d38:	0000632a 	.word	0x0000632a

00005d3c <nrf52_os_tick_counter.part.0>:
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
    5d3c:	2200      	movs	r2, #0
        return (result & 0x007fffff);
    }
}

static inline uint32_t
nrf52_os_tick_counter(void)
    5d3e:	b508      	push	{r3, lr}
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
    5d40:	4802      	ldr	r0, [pc, #8]	; (5d4c <nrf52_os_tick_counter.part.0+0x10>)
    5d42:	2155      	movs	r1, #85	; 0x55
    5d44:	4613      	mov	r3, r2
    5d46:	f7fe ff81 	bl	4c4c <__assert_func>
    5d4a:	bf00      	nop
    5d4c:	00006718 	.word	0x00006718

00005d50 <sub24>:
static inline int
sub24(uint32_t x, uint32_t y)
{
    int result;

    assert(x <= 0xffffff);
    5d50:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 * sub24(0x7fffff, 0) = 8388607
 * sub24(0x800000, 0) = -8388608
 */
static inline int
sub24(uint32_t x, uint32_t y)
{
    5d54:	b508      	push	{r3, lr}
    int result;

    assert(x <= 0xffffff);
    5d56:	d302      	bcc.n	5d5e <sub24+0xe>
    5d58:	480a      	ldr	r0, [pc, #40]	; (5d84 <sub24+0x34>)
    5d5a:	2143      	movs	r1, #67	; 0x43
    5d5c:	e004      	b.n	5d68 <sub24+0x18>
    assert(y <= 0xffffff);
    5d5e:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
    5d62:	d305      	bcc.n	5d70 <sub24+0x20>
    5d64:	4807      	ldr	r0, [pc, #28]	; (5d84 <sub24+0x34>)
    5d66:	2144      	movs	r1, #68	; 0x44
    5d68:	2200      	movs	r2, #0
    5d6a:	4613      	mov	r3, r2
    5d6c:	f7fe ff6e 	bl	4c4c <__assert_func>

    result = x - y;
    5d70:	1a40      	subs	r0, r0, r1
    if (result & 0x800000) {
    5d72:	0203      	lsls	r3, r0, #8
        return (result | 0xff800000);
    5d74:	bf46      	itte	mi
    5d76:	ea6f 2040 	mvnmi.w	r0, r0, lsl #9
    5d7a:	ea6f 2050 	mvnmi.w	r0, r0, lsr #9
    } else {
        return (result & 0x007fffff);
    5d7e:	f3c0 0016 	ubfxpl	r0, r0, #0, #23
    }
}
    5d82:	bd08      	pop	{r3, pc}
    5d84:	00006718 	.word	0x00006718

00005d88 <nrf52_os_tick_set_ocmp>:
#endif
}

static inline void
nrf52_os_tick_set_ocmp(uint32_t ocmp)
{
    5d88:	b538      	push	{r3, r4, r5, lr}
    5d8a:	4604      	mov	r4, r0
    uint32_t counter;

    OS_ASSERT_CRITICAL();
    5d8c:	f7fe fe79 	bl	4a82 <os_arch_in_critical>
    5d90:	4602      	mov	r2, r0
    5d92:	b970      	cbnz	r0, 5db2 <nrf52_os_tick_set_ocmp+0x2a>
    5d94:	480d      	ldr	r0, [pc, #52]	; (5dcc <nrf52_os_tick_set_ocmp+0x44>)
    5d96:	2167      	movs	r1, #103	; 0x67
    5d98:	4613      	mov	r3, r2
    5d9a:	f7fe ff57 	bl	4c4c <__assert_func>
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();

#if defined(BSP_HAS_32768_XTAL)
    return OS_TICK_TIMER->COUNTER;
    5d9e:	f8d5 1504 	ldr.w	r1, [r5, #1284]	; 0x504
         *   may not trigger a compare event.
         *
         * - If Counter is 'N' writing (N + 2) to CC register is guaranteed
         *   to trigger a compare event at 'N + 2'.
         */
        delta = sub24(ocmp, counter);
    5da2:	4620      	mov	r0, r4
    5da4:	f7ff ffd4 	bl	5d50 <sub24>
        if (delta > 2) {
    5da8:	2802      	cmp	r0, #2
    5daa:	dc0d      	bgt.n	5dc8 <nrf52_os_tick_set_ocmp+0x40>
        counter = nrf52_os_tick_counter();
        if (TIMER_LT(counter, ocmp)) {
            break;
        }
#endif
        ocmp += g_hal_os_tick.ticks_per_ostick;
    5dac:	4b08      	ldr	r3, [pc, #32]	; (5dd0 <nrf52_os_tick_set_ocmp+0x48>)
    5dae:	681b      	ldr	r3, [r3, #0]
    5db0:	441c      	add	r4, r3
    while (1) {
#if defined(BSP_HAS_32768_XTAL)
        int delta;

        ocmp &= 0xffffff;
        OS_TICK_TIMER->CC[OS_TICK_CMPREG] = ocmp;
    5db2:	4d08      	ldr	r5, [pc, #32]	; (5dd4 <nrf52_os_tick_set_ocmp+0x4c>)
    OS_ASSERT_CRITICAL();
    while (1) {
#if defined(BSP_HAS_32768_XTAL)
        int delta;

        ocmp &= 0xffffff;
    5db4:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        OS_TICK_TIMER->CC[OS_TICK_CMPREG] = ocmp;
    5db8:	f8c5 454c 	str.w	r4, [r5, #1356]	; 0x54c
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
    5dbc:	f7fe fe61 	bl	4a82 <os_arch_in_critical>
    5dc0:	2800      	cmp	r0, #0
    5dc2:	d1ec      	bne.n	5d9e <nrf52_os_tick_set_ocmp+0x16>
    5dc4:	f7ff ffba 	bl	5d3c <nrf52_os_tick_counter.part.0>
    5dc8:	bd38      	pop	{r3, r4, r5, pc}
    5dca:	bf00      	nop
    5dcc:	00006718 	.word	0x00006718
    5dd0:	20000fcc 	.word	0x20000fcc
    5dd4:	40011000 	.word	0x40011000

00005dd8 <nrf52_timer_handler>:
    }
}

static void
nrf52_timer_handler(void)
{
    5dd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int ticks;
    os_sr_t sr;
    uint32_t counter;

    OS_ENTER_CRITICAL(sr);
    5dda:	f7fe fe49 	bl	4a70 <os_arch_save_sr>
    5dde:	4607      	mov	r7, r0
{
    /*
     * Make sure we are not interrupted between invoking the capture task
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();
    5de0:	f7fe fe4f 	bl	4a82 <os_arch_in_critical>
    5de4:	b908      	cbnz	r0, 5dea <nrf52_timer_handler+0x12>
    5de6:	f7ff ffa9 	bl	5d3c <nrf52_os_tick_counter.part.0>
    /* Calculate elapsed ticks and advance OS time. */
#if defined(BSP_HAS_32768_XTAL)
    int delta;

    counter = nrf52_os_tick_counter();
    delta = sub24(counter, g_hal_os_tick.lastocmp);
    5dea:	4d0f      	ldr	r5, [pc, #60]	; (5e28 <nrf52_timer_handler+0x50>)
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();

#if defined(BSP_HAS_32768_XTAL)
    return OS_TICK_TIMER->COUNTER;
    5dec:	4e0f      	ldr	r6, [pc, #60]	; (5e2c <nrf52_timer_handler+0x54>)
    /* Calculate elapsed ticks and advance OS time. */
#if defined(BSP_HAS_32768_XTAL)
    int delta;

    counter = nrf52_os_tick_counter();
    delta = sub24(counter, g_hal_os_tick.lastocmp);
    5dee:	68a9      	ldr	r1, [r5, #8]
     * and reading the value.
     */
    OS_ASSERT_CRITICAL();

#if defined(BSP_HAS_32768_XTAL)
    return OS_TICK_TIMER->COUNTER;
    5df0:	f8d6 0504 	ldr.w	r0, [r6, #1284]	; 0x504
    /* Calculate elapsed ticks and advance OS time. */
#if defined(BSP_HAS_32768_XTAL)
    int delta;

    counter = nrf52_os_tick_counter();
    delta = sub24(counter, g_hal_os_tick.lastocmp);
    5df4:	f7ff ffac 	bl	5d50 <sub24>
    ticks = delta / g_hal_os_tick.ticks_per_ostick;
    5df8:	682c      	ldr	r4, [r5, #0]
    5dfa:	fb90 f4f4 	sdiv	r4, r0, r4
    os_time_advance(ticks);
    5dfe:	4620      	mov	r0, r4
    5e00:	f7ff fa70 	bl	52e4 <os_time_advance>

    /* Clear timer interrupt */
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;
    5e04:	2300      	movs	r3, #0
    5e06:	f8c6 314c 	str.w	r3, [r6, #332]	; 0x14c

    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
        (ticks * g_hal_os_tick.ticks_per_ostick)) & 0xffffff;
    5e0a:	6828      	ldr	r0, [r5, #0]

    /* Clear timer interrupt */
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;

    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
    5e0c:	68ab      	ldr	r3, [r5, #8]
    5e0e:	fb00 3404 	mla	r4, r0, r4, r3
        (ticks * g_hal_os_tick.ticks_per_ostick)) & 0xffffff;
    5e12:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp += ticks * g_hal_os_tick.ticks_per_ostick;
#endif

    /* Update the output compare to interrupt at the next tick */
    nrf52_os_tick_set_ocmp(g_hal_os_tick.lastocmp + g_hal_os_tick.ticks_per_ostick);
    5e16:	4420      	add	r0, r4

    /* Clear timer interrupt */
    OS_TICK_TIMER->EVENTS_COMPARE[OS_TICK_CMPREG] = 0;

    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp = (g_hal_os_tick.lastocmp +
    5e18:	60ac      	str	r4, [r5, #8]
    /* Update the time associated with the most recent tick */
    g_hal_os_tick.lastocmp += ticks * g_hal_os_tick.ticks_per_ostick;
#endif

    /* Update the output compare to interrupt at the next tick */
    nrf52_os_tick_set_ocmp(g_hal_os_tick.lastocmp + g_hal_os_tick.ticks_per_ostick);
    5e1a:	f7ff ffb5 	bl	5d88 <nrf52_os_tick_set_ocmp>

    OS_EXIT_CRITICAL(sr);
    5e1e:	4638      	mov	r0, r7
}
    5e20:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#endif

    /* Update the output compare to interrupt at the next tick */
    nrf52_os_tick_set_ocmp(g_hal_os_tick.lastocmp + g_hal_os_tick.ticks_per_ostick);

    OS_EXIT_CRITICAL(sr);
    5e24:	f7fe be2a 	b.w	4a7c <os_arch_restore_sr>
    5e28:	20000fcc 	.word	0x20000fcc
    5e2c:	40011000 	.word	0x40011000

00005e30 <os_tick_idle>:
}

void
os_tick_idle(os_time_t ticks)
{
    5e30:	b510      	push	{r4, lr}
    5e32:	4604      	mov	r4, r0
    uint32_t ocmp;

    OS_ASSERT_CRITICAL();
    5e34:	f7fe fe25 	bl	4a82 <os_arch_in_critical>
    5e38:	4602      	mov	r2, r0
    5e3a:	b920      	cbnz	r0, 5e46 <os_tick_idle+0x16>
    5e3c:	480c      	ldr	r0, [pc, #48]	; (5e70 <os_tick_idle+0x40>)
    5e3e:	21b6      	movs	r1, #182	; 0xb6
    5e40:	4613      	mov	r3, r2
    5e42:	f7fe ff03 	bl	4c4c <__assert_func>

    if (ticks > 0) {
    5e46:	b154      	cbz	r4, 5e5e <os_tick_idle+0x2e>
        /*
         * Enter tickless regime during long idle durations.
         */
        if (ticks > g_hal_os_tick.max_idle_ticks) {
    5e48:	4b0a      	ldr	r3, [pc, #40]	; (5e74 <os_tick_idle+0x44>)
    5e4a:	685a      	ldr	r2, [r3, #4]
            ticks = g_hal_os_tick.max_idle_ticks;
        }
        ocmp = g_hal_os_tick.lastocmp + (ticks*g_hal_os_tick.ticks_per_ostick);
    5e4c:	6818      	ldr	r0, [r3, #0]
    5e4e:	689b      	ldr	r3, [r3, #8]
    5e50:	4294      	cmp	r4, r2
    5e52:	bf28      	it	cs
    5e54:	4614      	movcs	r4, r2
        nrf52_os_tick_set_ocmp(ocmp);
    5e56:	fb00 3004 	mla	r0, r0, r4, r3
    5e5a:	f7ff ff95 	bl	5d88 <nrf52_os_tick_set_ocmp>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
    5e5e:	f3bf 8f4f 	dsb	sy
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
    5e62:	bf30      	wfi
    }

    __DSB();
    __WFI();

    if (ticks > 0) {
    5e64:	b11c      	cbz	r4, 5e6e <os_tick_idle+0x3e>
         * Update OS time before anything else when coming out of
         * the tickless regime.
         */
        nrf52_timer_handler();
    }
}
    5e66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (ticks > 0) {
        /*
         * Update OS time before anything else when coming out of
         * the tickless regime.
         */
        nrf52_timer_handler();
    5e6a:	f7ff bfb5 	b.w	5dd8 <nrf52_timer_handler>
    5e6e:	bd10      	pop	{r4, pc}
    5e70:	00006718 	.word	0x00006718
    5e74:	20000fcc 	.word	0x20000fcc

00005e78 <system_reset>:
}

int
system_debugger_connected(void)
{
    return CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk;
    5e78:	4b08      	ldr	r3, [pc, #32]	; (5e9c <system_reset+0x24>)
    5e7a:	681b      	ldr	r3, [r3, #0]

void
system_reset(void)
{
    while (1) {
        if (system_debugger_connected()) {
    5e7c:	07db      	lsls	r3, r3, #31
    5e7e:	d500      	bpl.n	5e82 <system_reset+0xa>
            /*
             * If debugger is attached, breakpoint here.
             */
            asm("bkpt");
    5e80:	be00      	bkpt	0x0000
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
    5e82:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5e86:	4906      	ldr	r1, [pc, #24]	; (5ea0 <system_reset+0x28>)
    5e88:	4b06      	ldr	r3, [pc, #24]	; (5ea4 <system_reset+0x2c>)
    5e8a:	68ca      	ldr	r2, [r1, #12]
    5e8c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    5e90:	4313      	orrs	r3, r2
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
    5e92:	60cb      	str	r3, [r1, #12]
    5e94:	f3bf 8f4f 	dsb	sy
    5e98:	e7fe      	b.n	5e98 <system_reset+0x20>
    5e9a:	bf00      	nop
    5e9c:	e000edf0 	.word	0xe000edf0
    5ea0:	e000ed00 	.word	0xe000ed00
    5ea4:	05fa0004 	.word	0x05fa0004

00005ea8 <system_debugger_connected>:
}

int
system_debugger_connected(void)
{
    return CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk;
    5ea8:	4b02      	ldr	r3, [pc, #8]	; (5eb4 <system_debugger_connected+0xc>)
    5eaa:	6818      	ldr	r0, [r3, #0]
}
    5eac:	f000 0001 	and.w	r0, r0, #1
    5eb0:	4770      	bx	lr
    5eb2:	bf00      	nop
    5eb4:	e000edf0 	.word	0xe000edf0

00005eb8 <memcmp>:
 */

#include <string.h>

int memcmp(const void *s1, const void *s2, size_t n)
{
    5eb8:	b510      	push	{r4, lr}
    5eba:	4402      	add	r2, r0
	const unsigned char *c1 = s1, *c2 = s2;
	int d = 0;

	while (n--) {
    5ebc:	4290      	cmp	r0, r2
    5ebe:	d006      	beq.n	5ece <memcmp+0x16>
		d = (int)*c1++ - (int)*c2++;
    5ec0:	f810 3b01 	ldrb.w	r3, [r0], #1
    5ec4:	f811 4b01 	ldrb.w	r4, [r1], #1
		if (d)
    5ec8:	1b1b      	subs	r3, r3, r4
    5eca:	d0f7      	beq.n	5ebc <memcmp+0x4>
    5ecc:	e000      	b.n	5ed0 <memcmp+0x18>
    5ece:	2300      	movs	r3, #0
			break;
	}

	return d;
}
    5ed0:	4618      	mov	r0, r3
    5ed2:	bd10      	pop	{r4, pc}

00005ed4 <memcpy>:

#include <string.h>
#include <stdint.h>

void *memcpy(void *dst, const void *src, size_t n)
{
    5ed4:	b510      	push	{r4, lr}
    5ed6:	1e43      	subs	r3, r0, #1
    5ed8:	440a      	add	r2, r1
	size_t nq = n >> 3;
	asm volatile ("cld ; rep ; movsq ; movl %3,%%ecx ; rep ; movsb":"+c"
		      (nq), "+S"(p), "+D"(q)
		      :"r"((uint32_t) (n & 7)));
#else
	while (n--) {
    5eda:	4291      	cmp	r1, r2
    5edc:	d004      	beq.n	5ee8 <memcpy+0x14>
		*q++ = *p++;
    5ede:	f811 4b01 	ldrb.w	r4, [r1], #1
    5ee2:	f803 4f01 	strb.w	r4, [r3, #1]!
    5ee6:	e7f8      	b.n	5eda <memcpy+0x6>
	}
#endif

	return dst;
}
    5ee8:	bd10      	pop	{r4, pc}

00005eea <realloc>:
#include "malloc.h"

/* FIXME: This is cheesy, it should be fixed later */

void *realloc(void *ptr, size_t size)
{
    5eea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5eec:	460c      	mov	r4, r1
	struct free_arena_header *ah;
	void *newptr;
	size_t oldsize;

	if (!ptr)
    5eee:	4605      	mov	r5, r0
    5ef0:	b920      	cbnz	r0, 5efc <realloc+0x12>
		return malloc(size);
    5ef2:	4608      	mov	r0, r1
                }
		free(ptr);

		return newptr;
	}
}
    5ef4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	struct free_arena_header *ah;
	void *newptr;
	size_t oldsize;

	if (!ptr)
		return malloc(size);
    5ef8:	f7fd bcd4 	b.w	38a4 <malloc>

	if (size == 0) {
    5efc:	b919      	cbnz	r1, 5f06 <realloc+0x1c>
		free(ptr);
    5efe:	f7fd fd1b 	bl	3938 <free>
		return NULL;
    5f02:	4620      	mov	r0, r4
    5f04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
    5f06:	f101 021f 	add.w	r2, r1, #31

	ah = (struct free_arena_header *)
	    ((struct arena_header *)ptr - 1);

	if (ah->a.size >= size && size >= (ah->a.size >> 2)) {
    5f0a:	f850 6c0c 	ldr.w	r6, [r0, #-12]
		free(ptr);
		return NULL;
	}

	/* Add the obligatory arena header, and round up */
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
    5f0e:	f022 040f 	bic.w	r4, r2, #15

	ah = (struct free_arena_header *)
	    ((struct arena_header *)ptr - 1);

	if (ah->a.size >= size && size >= (ah->a.size >> 2)) {
    5f12:	42a6      	cmp	r6, r4
    5f14:	d302      	bcc.n	5f1c <realloc+0x32>
    5f16:	ebb4 0f96 	cmp.w	r4, r6, lsr #2
    5f1a:	d211      	bcs.n	5f40 <realloc+0x56>
		   be checking the following block to see if we can do an
		   in-place adjustment... fix that later. */

		oldsize = ah->a.size - sizeof(struct arena_header);

		newptr = malloc(size);
    5f1c:	4620      	mov	r0, r4
    5f1e:	f7fd fcc1 	bl	38a4 <malloc>
                if(newptr) {
    5f22:	4607      	mov	r7, r0
    5f24:	b138      	cbz	r0, 5f36 <realloc+0x4c>
	} else {
		/* Make me a new block.  This is kind of bogus; we should
		   be checking the following block to see if we can do an
		   in-place adjustment... fix that later. */

		oldsize = ah->a.size - sizeof(struct arena_header);
    5f26:	f1a6 0210 	sub.w	r2, r6, #16

		newptr = malloc(size);
                if(newptr) {
                    memcpy(newptr, ptr, (size < oldsize) ? size : oldsize);
    5f2a:	42a2      	cmp	r2, r4
    5f2c:	4629      	mov	r1, r5
    5f2e:	bf28      	it	cs
    5f30:	4622      	movcs	r2, r4
    5f32:	f7ff ffcf 	bl	5ed4 <memcpy>
                }
		free(ptr);
    5f36:	4628      	mov	r0, r5
    5f38:	f7fd fcfe 	bl	3938 <free>
		   be checking the following block to see if we can do an
		   in-place adjustment... fix that later. */

		oldsize = ah->a.size - sizeof(struct arena_header);

		newptr = malloc(size);
    5f3c:	4638      	mov	r0, r7
                if(newptr) {
                    memcpy(newptr, ptr, (size < oldsize) ? size : oldsize);
                }
		free(ptr);

		return newptr;
    5f3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
}
    5f40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00005f42 <strcmp>:
	const unsigned char *c2 = (const unsigned char *)s2;
	unsigned char ch;
	int d = 0;

	while (1) {
		d = (int)(ch = *c1++) - (int)*c2++;
    5f42:	f810 2b01 	ldrb.w	r2, [r0], #1
    5f46:	f811 3b01 	ldrb.w	r3, [r1], #1
		if (d || !ch)
    5f4a:	1ad3      	subs	r3, r2, r3
    5f4c:	d101      	bne.n	5f52 <strcmp+0x10>
    5f4e:	2a00      	cmp	r2, #0
    5f50:	d1f7      	bne.n	5f42 <strcmp>
			break;
	}

	return d;
}
    5f52:	4618      	mov	r0, r3
    5f54:	4770      	bx	lr

00005f56 <strtok_r>:
#include <string.h>

char *strtok_r(char *s, const char *delim, char **holder)
{
    5f56:	b538      	push	{r3, r4, r5, lr}
    5f58:	460d      	mov	r5, r1
    5f5a:	4614      	mov	r4, r2
	if (s)
    5f5c:	b100      	cbz	r0, 5f60 <strtok_r+0xa>
		*holder = s;
    5f5e:	6010      	str	r0, [r2, #0]

	do {
		s = strsep(holder, delim);
    5f60:	4620      	mov	r0, r4
    5f62:	4629      	mov	r1, r5
    5f64:	f000 f805 	bl	5f72 <strsep>
	} while (s && !*s);
    5f68:	b110      	cbz	r0, 5f70 <strtok_r+0x1a>
    5f6a:	7803      	ldrb	r3, [r0, #0]
    5f6c:	2b00      	cmp	r3, #0
    5f6e:	d0f7      	beq.n	5f60 <strtok_r+0xa>

	return s;
}
    5f70:	bd38      	pop	{r3, r4, r5, pc}

00005f72 <strsep>:
 */

#include <string.h>

char *strsep(char **stringp, const char *delim)
{
    5f72:	b538      	push	{r3, r4, r5, lr}
	char *s = *stringp;
    5f74:	6804      	ldr	r4, [r0, #0]
 */

#include <string.h>

char *strsep(char **stringp, const char *delim)
{
    5f76:	4605      	mov	r5, r0
	char *s = *stringp;
	char *e;

	if (!s)
    5f78:	b13c      	cbz	r4, 5f8a <strsep+0x18>
		return NULL;

	e = strpbrk(s, delim);
    5f7a:	4620      	mov	r0, r4
    5f7c:	f000 f807 	bl	5f8e <strpbrk>
	if (e)
    5f80:	b110      	cbz	r0, 5f88 <strsep+0x16>
		*e++ = '\0';
    5f82:	2300      	movs	r3, #0
    5f84:	7003      	strb	r3, [r0, #0]
    5f86:	3001      	adds	r0, #1

	*stringp = e;
    5f88:	6028      	str	r0, [r5, #0]
	return s;
}
    5f8a:	4620      	mov	r0, r4
    5f8c:	bd38      	pop	{r3, r4, r5, pc}

00005f8e <strpbrk>:
*/

#include <string.h>

char *strpbrk(const char *s1, const char *s2)
{
    5f8e:	b570      	push	{r4, r5, r6, lr}
  const char *c = s2;
  if (!*s1)
    5f90:	7803      	ldrb	r3, [r0, #0]
    5f92:	b193      	cbz	r3, 5fba <strpbrk+0x2c>
    5f94:	460c      	mov	r4, r1
    5f96:	4603      	mov	r3, r0
    return (char *) NULL;

  while (*s1)
    5f98:	f810 5b01 	ldrb.w	r5, [r0], #1
    5f9c:	b13d      	cbz	r5, 5fae <strpbrk+0x20>
    5f9e:	460a      	mov	r2, r1
    5fa0:	4614      	mov	r4, r2
    {
      for (c = s2; *c; c++)
    5fa2:	f812 6b01 	ldrb.w	r6, [r2], #1
    5fa6:	2e00      	cmp	r6, #0
    5fa8:	d0f5      	beq.n	5f96 <strpbrk+0x8>
	{
	  if (*s1 == *c)
    5faa:	42b5      	cmp	r5, r6
    5fac:	d1f8      	bne.n	5fa0 <strpbrk+0x12>
      if (*c)
	break;
      s1++;
    }

  if (*c == '\0')
    5fae:	7822      	ldrb	r2, [r4, #0]
    s1 = NULL;
    5fb0:	2a00      	cmp	r2, #0
    5fb2:	bf14      	ite	ne
    5fb4:	4618      	movne	r0, r3
    5fb6:	2000      	moveq	r0, #0
    5fb8:	bd70      	pop	{r4, r5, r6, pc}

char *strpbrk(const char *s1, const char *s2)
{
  const char *c = s2;
  if (!*s1)
    return (char *) NULL;
    5fba:	4618      	mov	r0, r3

  if (*c == '\0')
    s1 = NULL;

  return (char *) s1;
}
    5fbc:	bd70      	pop	{r4, r5, r6, pc}
	...

00005fc0 <base64_encode>:
    return -1;
}

int 
base64_encode(const void *data, int size, char *s, uint8_t should_pad)
{
    5fc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int diff;

    p = s;

    q = (const unsigned char *) data;
    last = NULL;
    5fc2:	2400      	movs	r4, #0
    return -1;
}

int 
base64_encode(const void *data, int size, char *s, uint8_t should_pad)
{
    5fc4:	4616      	mov	r6, r2
    int c;
    const unsigned char *q;
    char *last;
    int diff;

    p = s;
    5fc6:	4615      	mov	r5, r2
    5fc8:	4607      	mov	r7, r0

    q = (const unsigned char *) data;
    last = NULL;
    i = 0;
    5fca:	4622      	mov	r2, r4
    while (i < size) {
    5fcc:	428a      	cmp	r2, r1
    5fce:	da32      	bge.n	6036 <base64_encode+0x76>
    5fd0:	f102 0e01 	add.w	lr, r2, #1
        c = q[i++];
    5fd4:	5c84      	ldrb	r4, [r0, r2]
        c *= 256;
        if (i < size)
    5fd6:	458e      	cmp	lr, r1
            c += q[i];
    5fd8:	bfb8      	it	lt
    5fda:	f897 e001 	ldrblt.w	lr, [r7, #1]
    q = (const unsigned char *) data;
    last = NULL;
    i = 0;
    while (i < size) {
        c = q[i++];
        c *= 256;
    5fde:	ea4f 2404 	mov.w	r4, r4, lsl #8
        if (i < size)
            c += q[i];
    5fe2:	bfb8      	it	lt
    5fe4:	4474      	addlt	r4, lr
    5fe6:	f102 0e02 	add.w	lr, r2, #2
        i++;
        c *= 256;
        if (i < size)
    5fea:	458e      	cmp	lr, r1
            c += q[i];
    5fec:	bfb8      	it	lt
    5fee:	f897 e002 	ldrblt.w	lr, [r7, #2]
        c = q[i++];
        c *= 256;
        if (i < size)
            c += q[i];
        i++;
        c *= 256;
    5ff2:	ea4f 2404 	mov.w	r4, r4, lsl #8
        if (i < size)
            c += q[i];
    5ff6:	bfb8      	it	lt
    5ff8:	4474      	addlt	r4, lr
        i++;
        p[0] = base64_chars[(c & 0x00fc0000) >> 18];
    5ffa:	f3c4 4c85 	ubfx	ip, r4, #18, #6
    5ffe:	f8df e058 	ldr.w	lr, [pc, #88]	; 6058 <base64_encode+0x98>
    6002:	f81e c00c 	ldrb.w	ip, [lr, ip]
    6006:	f885 c000 	strb.w	ip, [r5]
        p[1] = base64_chars[(c & 0x0003f000) >> 12];
    600a:	f3c4 3c05 	ubfx	ip, r4, #12, #6
            c += q[i];
        i++;
        c *= 256;
        if (i < size)
            c += q[i];
        i++;
    600e:	3203      	adds	r2, #3
        p[0] = base64_chars[(c & 0x00fc0000) >> 18];
        p[1] = base64_chars[(c & 0x0003f000) >> 12];
    6010:	f81e c00c 	ldrb.w	ip, [lr, ip]
    6014:	f885 c001 	strb.w	ip, [r5, #1]
        p[2] = base64_chars[(c & 0x00000fc0) >> 6];
    6018:	f3c4 1c85 	ubfx	ip, r4, #6, #6
        p[3] = base64_chars[(c & 0x0000003f) >> 0];
    601c:	f004 043f 	and.w	r4, r4, #63	; 0x3f
        if (i < size)
            c += q[i];
        i++;
        p[0] = base64_chars[(c & 0x00fc0000) >> 18];
        p[1] = base64_chars[(c & 0x0003f000) >> 12];
        p[2] = base64_chars[(c & 0x00000fc0) >> 6];
    6020:	f81e c00c 	ldrb.w	ip, [lr, ip]
        p[3] = base64_chars[(c & 0x0000003f) >> 0];
    6024:	f81e 4004 	ldrb.w	r4, [lr, r4]
    6028:	70ec      	strb	r4, [r5, #3]
        if (i < size)
            c += q[i];
        i++;
        p[0] = base64_chars[(c & 0x00fc0000) >> 18];
        p[1] = base64_chars[(c & 0x0003f000) >> 12];
        p[2] = base64_chars[(c & 0x00000fc0) >> 6];
    602a:	f885 c002 	strb.w	ip, [r5, #2]
        p[3] = base64_chars[(c & 0x0000003f) >> 0];
        last = p;
        p += 4;
    602e:	462c      	mov	r4, r5
    6030:	3703      	adds	r7, #3
    6032:	3504      	adds	r5, #4
    6034:	e7ca      	b.n	5fcc <base64_encode+0xc>
    }

    if (last) {
    6036:	b15c      	cbz	r4, 6050 <base64_encode+0x90>
        diff = i - size;
    6038:	1a52      	subs	r2, r2, r1
        if (diff > 0) {
    603a:	2a00      	cmp	r2, #0
    603c:	dd08      	ble.n	6050 <base64_encode+0x90>
    603e:	f1c2 0004 	rsb	r0, r2, #4
            if (should_pad) {
    6042:	b123      	cbz	r3, 604e <base64_encode+0x8e>
                memset(last + (4 - diff), '=', diff);
    6044:	4420      	add	r0, r4
    6046:	213d      	movs	r1, #61	; 0x3d
    6048:	f7fd fc8c 	bl	3964 <memset>
    604c:	e000      	b.n	6050 <base64_encode+0x90>
            } else {
                p = last + (4 - diff);
    604e:	1825      	adds	r5, r4, r0
            }
        }
    } 

    *p = 0;
    6050:	2300      	movs	r3, #0
    6052:	702b      	strb	r3, [r5, #0]

    return (p - s);
}
    6054:	1ba8      	subs	r0, r5, r6
    6056:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6058:	00006726 	.word	0x00006726

0000605c <base64_decode>:
    return (marker << 24) | val;
}

int 
base64_decode(const char *str, void *data)
{
    605c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6060:	460e      	mov	r6, r1
    6062:	1cc5      	adds	r5, r0, #3
    const char *p;
    unsigned char *q;

    q = data;
    6064:	460c      	mov	r4, r1
    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4) {
    6066:	f815 1c03 	ldrb.w	r1, [r5, #-3]
    606a:	1eef      	subs	r7, r5, #3
    606c:	b911      	cbnz	r1, 6074 <base64_decode+0x18>
        if (marker < 2)
            *q++ = (val >> 8) & 0xff;
        if (marker < 1)
            *q++ = val & 0xff;
    }
    return q - (unsigned char *) data;
    606e:	1ba0      	subs	r0, r4, r6
    6070:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
    const char *p;
    unsigned char *q;

    q = data;
    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4) {
    6074:	293d      	cmp	r1, #61	; 0x3d
    6076:	d13d      	bne.n	60f4 <base64_decode+0x98>
token_decode(const char *token)
{
    int i;
    unsigned int val = 0;
    int marker = 0;
    if (strlen(token) < 4)
    6078:	4638      	mov	r0, r7
    607a:	f7fd fc90 	bl	399e <strlen>
    607e:	2803      	cmp	r0, #3
    6080:	d923      	bls.n	60ca <base64_decode+0x6e>
    6082:	2000      	movs	r0, #0
    6084:	1f2f      	subs	r7, r5, #4
    6086:	4603      	mov	r3, r0
        return DECODE_ERROR;
    for (i = 0; i < 4; i++) {
        val *= 64;
        if (token[i] == '=')
    6088:	f817 cf01 	ldrb.w	ip, [r7, #1]!
    608c:	f1bc 0f3d 	cmp.w	ip, #61	; 0x3d
    unsigned int val = 0;
    int marker = 0;
    if (strlen(token) < 4)
        return DECODE_ERROR;
    for (i = 0; i < 4; i++) {
        val *= 64;
    6090:	ea4f 1383 	mov.w	r3, r3, lsl #6
        if (token[i] == '=')
    6094:	d101      	bne.n	609a <base64_decode+0x3e>
            marker++;
    6096:	3001      	adds	r0, #1
    6098:	e010      	b.n	60bc <base64_decode+0x60>
        else if (marker > 0)
    609a:	b9b0      	cbnz	r0, 60ca <base64_decode+0x6e>
    609c:	4919      	ldr	r1, [pc, #100]	; (6104 <base64_decode+0xa8>)
    609e:	4688      	mov	r8, r1
    60a0:	460a      	mov	r2, r1

static int 
pos(char c)
{
    const char *p;
    for (p = base64_chars; *p; p++)
    60a2:	f811 eb01 	ldrb.w	lr, [r1], #1
    60a6:	f1be 0f00 	cmp.w	lr, #0
    60aa:	d004      	beq.n	60b6 <base64_decode+0x5a>
        if (*p == c)
    60ac:	45e6      	cmp	lr, ip
    60ae:	d1f7      	bne.n	60a0 <base64_decode+0x44>
            return p - base64_chars;
    60b0:	ebc8 0202 	rsb	r2, r8, r2
    60b4:	e001      	b.n	60ba <base64_decode+0x5e>
    return -1;
    60b6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        if (token[i] == '=')
            marker++;
        else if (marker > 0)
            return DECODE_ERROR;
        else
            val += pos(token[i]);
    60ba:	4413      	add	r3, r2
    int i;
    unsigned int val = 0;
    int marker = 0;
    if (strlen(token) < 4)
        return DECODE_ERROR;
    for (i = 0; i < 4; i++) {
    60bc:	42af      	cmp	r7, r5
    60be:	d1e3      	bne.n	6088 <base64_decode+0x2c>
        else if (marker > 0)
            return DECODE_ERROR;
        else
            val += pos(token[i]);
    }
    if (marker > 2)
    60c0:	2802      	cmp	r0, #2
    60c2:	dc02      	bgt.n	60ca <base64_decode+0x6e>
        return DECODE_ERROR;
    return (marker << 24) | val;
    60c4:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
    60c8:	e001      	b.n	60ce <base64_decode+0x72>
{
    int i;
    unsigned int val = 0;
    int marker = 0;
    if (strlen(token) < 4)
        return DECODE_ERROR;
    60ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

    q = data;
    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4) {
        unsigned int val = token_decode(p);
        unsigned int marker = (val >> 24) & 0xff;
        if (val == DECODE_ERROR)
    60ce:	1c42      	adds	r2, r0, #1
    unsigned char *q;

    q = data;
    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4) {
        unsigned int val = token_decode(p);
        unsigned int marker = (val >> 24) & 0xff;
    60d0:	ea4f 6310 	mov.w	r3, r0, lsr #24
        if (val == DECODE_ERROR)
    60d4:	d014      	beq.n	6100 <base64_decode+0xa4>
            return -1;
        *q++ = (val >> 16) & 0xff;
    60d6:	0c02      	lsrs	r2, r0, #16
        if (marker < 2)
    60d8:	2b01      	cmp	r3, #1
    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4) {
        unsigned int val = token_decode(p);
        unsigned int marker = (val >> 24) & 0xff;
        if (val == DECODE_ERROR)
            return -1;
        *q++ = (val >> 16) & 0xff;
    60da:	7022      	strb	r2, [r4, #0]
        if (marker < 2)
    60dc:	d901      	bls.n	60e2 <base64_decode+0x86>
    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4) {
        unsigned int val = token_decode(p);
        unsigned int marker = (val >> 24) & 0xff;
        if (val == DECODE_ERROR)
            return -1;
        *q++ = (val >> 16) & 0xff;
    60de:	3401      	adds	r4, #1
    60e0:	e006      	b.n	60f0 <base64_decode+0x94>
        if (marker < 2)
            *q++ = (val >> 8) & 0xff;
    60e2:	0a02      	lsrs	r2, r0, #8
    60e4:	7062      	strb	r2, [r4, #1]
        if (marker < 1)
    60e6:	b10b      	cbz	r3, 60ec <base64_decode+0x90>
        unsigned int marker = (val >> 24) & 0xff;
        if (val == DECODE_ERROR)
            return -1;
        *q++ = (val >> 16) & 0xff;
        if (marker < 2)
            *q++ = (val >> 8) & 0xff;
    60e8:	3402      	adds	r4, #2
    60ea:	e001      	b.n	60f0 <base64_decode+0x94>
        if (marker < 1)
            *q++ = val & 0xff;
    60ec:	70a0      	strb	r0, [r4, #2]
    60ee:	3403      	adds	r4, #3
    60f0:	3504      	adds	r5, #4
    60f2:	e7b8      	b.n	6066 <base64_decode+0xa>
{
    const char *p;
    unsigned char *q;

    q = data;
    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4) {
    60f4:	4803      	ldr	r0, [pc, #12]	; (6104 <base64_decode+0xa8>)
    60f6:	f7fd fc3d 	bl	3974 <strchr>
    60fa:	2800      	cmp	r0, #0
    60fc:	d1bc      	bne.n	6078 <base64_decode+0x1c>
    60fe:	e7b6      	b.n	606e <base64_decode+0x12>
            *q++ = (val >> 8) & 0xff;
        if (marker < 1)
            *q++ = val & 0xff;
    }
    return q - (unsigned char *) data;
}
    6100:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6104:	00006726 	.word	0x00006726

00006108 <base64_decode_len>:


int
base64_decode_len(const char *str)
{
    6108:	b510      	push	{r4, lr}
    610a:	4604      	mov	r4, r0
    int len;

    len = strlen(str);
    610c:	f7fd fc47 	bl	399e <strlen>
    6110:	4420      	add	r0, r4
    while (len && str[len - 1] == '=') {
    6112:	42a0      	cmp	r0, r4
    6114:	eba0 0304 	sub.w	r3, r0, r4
    6118:	d004      	beq.n	6124 <base64_decode_len+0x1c>
    611a:	f810 2d01 	ldrb.w	r2, [r0, #-1]!
    611e:	2a3d      	cmp	r2, #61	; 0x3d
    6120:	d0f7      	beq.n	6112 <base64_decode_len+0xa>
    6122:	e000      	b.n	6126 <base64_decode_len+0x1e>
    6124:	2300      	movs	r3, #0
        len--;
    }
    return len * 3 / 4;
    6126:	eb03 0343 	add.w	r3, r3, r3, lsl #1
}
    612a:	2004      	movs	r0, #4
    612c:	fb93 f0f0 	sdiv	r0, r3, r0
    6130:	bd10      	pop	{r4, pc}
	...

00006134 <__errno>:
    6134:	4b01      	ldr	r3, [pc, #4]	; (613c <__errno+0x8>)
    6136:	6818      	ldr	r0, [r3, #0]
    6138:	4770      	bx	lr
    613a:	bf00      	nop
    613c:	200005c8 	.word	0x200005c8

00006140 <__libc_init_array>:
    6140:	b570      	push	{r4, r5, r6, lr}
    6142:	4e0f      	ldr	r6, [pc, #60]	; (6180 <__libc_init_array+0x40>)
    6144:	4d0f      	ldr	r5, [pc, #60]	; (6184 <__libc_init_array+0x44>)
    6146:	1b76      	subs	r6, r6, r5
    6148:	10b6      	asrs	r6, r6, #2
    614a:	bf18      	it	ne
    614c:	2400      	movne	r4, #0
    614e:	d005      	beq.n	615c <__libc_init_array+0x1c>
    6150:	3401      	adds	r4, #1
    6152:	f855 3b04 	ldr.w	r3, [r5], #4
    6156:	4798      	blx	r3
    6158:	42a6      	cmp	r6, r4
    615a:	d1f9      	bne.n	6150 <__libc_init_array+0x10>
    615c:	4e0a      	ldr	r6, [pc, #40]	; (6188 <__libc_init_array+0x48>)
    615e:	4d0b      	ldr	r5, [pc, #44]	; (618c <__libc_init_array+0x4c>)
    6160:	1b76      	subs	r6, r6, r5
    6162:	f000 f815 	bl	6190 <_init>
    6166:	10b6      	asrs	r6, r6, #2
    6168:	bf18      	it	ne
    616a:	2400      	movne	r4, #0
    616c:	d006      	beq.n	617c <__libc_init_array+0x3c>
    616e:	3401      	adds	r4, #1
    6170:	f855 3b04 	ldr.w	r3, [r5], #4
    6174:	4798      	blx	r3
    6176:	42a6      	cmp	r6, r4
    6178:	d1f9      	bne.n	616e <__libc_init_array+0x2e>
    617a:	bd70      	pop	{r4, r5, r6, pc}
    617c:	bd70      	pop	{r4, r5, r6, pc}
    617e:	bf00      	nop
    6180:	200005cc 	.word	0x200005cc
    6184:	200005cc 	.word	0x200005cc
    6188:	200005cc 	.word	0x200005cc
    618c:	200005cc 	.word	0x200005cc

00006190 <_init>:
    6190:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6192:	bf00      	nop
    6194:	bcf8      	pop	{r3, r4, r5, r6, r7}
    6196:	bc08      	pop	{r3}
    6198:	469e      	mov	lr, r3
    619a:	4770      	bx	lr

0000619c <_fini>:
    619c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    619e:	bf00      	nop
    61a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    61a2:	bc08      	pop	{r3}
    61a4:	469e      	mov	lr, r3
    61a6:	4770      	bx	lr
    61a8:	746f6f62 	.word	0x746f6f62
    61ac:	2f00632e 	.word	0x2f00632e
    61b0:	2f676663 	.word	0x2f676663
    61b4:	006e7572 	.word	0x006e7572
    61b8:	7366666e 	.word	0x7366666e
    61bc:	6e00632e 	.word	0x6e00632e
    61c0:	00736666 	.word	0x00736666

000061c4 <nffs_ops>:
    61c4:	00000439 0000041f 000003fb 000003d1     9...............
    61d4:	000003b5 000002c1 00000399 00000377     ............w...
    61e4:	00000351 0000032d 00000307 000002eb     Q...-...........
    61f4:	000002d3 000004a1 00000471 000061bf     ........q....a..
    6204:	7366666e 6361635f 632e6568 66666e00     nffs_cache.c.nff
    6214:	69665f73 632e656c 66666e00 6c665f73     s_file.c.nffs_fl
    6224:	2e687361 666e0063 665f7366 616d726f     ash.c.nffs_forma
    6234:	00632e74 7366666e 7361685f 00632e68     t.c.nffs_hash.c.
    6244:	7366666e 6f6e695f 632e6564 66666e00     nffs_inode.c.nff
    6254:	696d5f73 632e6373 6f6c2f00 662b7473     s_misc.c./lost+f
    6264:	646e756f 66666e00 69665f73 705f656c     ound.nffs_file_p
    6274:	006c6f6f 7366666e 6f6e695f 655f6564     ool.nffs_inode_e
    6284:	7972746e 6f6f705f 666e006c 625f7366     ntry_pool.nffs_b
    6294:	6b636f6c 746e655f 705f7972 006c6f6f     lock_entry_pool.
    62a4:	7366666e 6361635f 695f6568 65646f6e     nffs_cache_inode
    62b4:	6f6f705f 666e006c 635f7366 65686361     _pool.nffs_cache
    62c4:	6f6c625f 705f6b63 006c6f6f 7366666e     _block_pool.nffs
    62d4:	7269645f 6f6f705f 666e006c 705f7366     _dir_pool.nffs_p
    62e4:	2e687461 666e0063 725f7366 6f747365     ath.c.nffs_resto
    62f4:	632e6572 6f6c2f00 662b7473 646e756f     re.c./lost+found
    6304:	666e002f 775f7366 65746972 6e00632e     /.nffs_write.c.n
    6314:	5f736666 636f6c62 00632e6b 7366666e     ffs_block.c.nffs
    6324:	2e63675f 61680063 6c665f6c 2e687361     _gc.c.hal_flash.
    6334:	6f620063 742f746f 00747365 746f6f62     c.boot/test.boot
    6344:	69616d2f 632f006e 622f6766 62007473     /main./cfg/bst.b
    6354:	00746f6f 64616f6c 632e7265 00008000              oot.loader.c.

00006361 <sha256_padding>:
    6361:	00000080 00000000 00000000 00000000     ................
	...

000063a4 <K>:
    63a4:	428a2f98 71374491 b5c0fbcf e9b5dba5     ./.B.D7q........
    63b4:	3956c25b 59f111f1 923f82a4 ab1c5ed5     [.V9...Y..?..^..
    63c4:	d807aa98 12835b01 243185be 550c7dc3     .....[....1$.}.U
    63d4:	72be5d74 80deb1fe 9bdc06a7 c19bf174     t].r........t...
    63e4:	e49b69c1 efbe4786 0fc19dc6 240ca1cc     .i...G.........$
    63f4:	2de92c6f 4a7484aa 5cb0a9dc 76f988da     o,.-..tJ...\...v
    6404:	983e5152 a831c66d b00327c8 bf597fc7     RQ>.m.1..'....Y.
    6414:	c6e00bf3 d5a79147 06ca6351 14292967     ....G...Qc..g)).
    6424:	27b70a85 2e1b2138 4d2c6dfc 53380d13     ...'8!...m,M..8S
    6434:	650a7354 766a0abb 81c2c92e 92722c85     Ts.e..jv.....,r.
    6444:	a2bfe8a1 a81a664b c24b8b70 c76c51a3     ....Kf..p.K..Ql.
    6454:	d192e819 d6990624 f40e3585 106aa070     ....$....5..p.j.
    6464:	19a4c116 1e376c08 2748774c 34b0bcb5     .....l7.LwH'...4
    6474:	391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3     ...9J..NO..[.o.h
    6484:	748f82ee 78a5636f 84c87814 8cc70208     ...toc.x.x......
    6494:	90befffa a4506ceb bef9a3f7 c67178f2     .....lP......xq.
    64a4:	656c6469 2e736f00 736f0063 6c61635f     idle.os.c.os_cal
    64b4:	74756f6c 6f00632e 65685f73 632e7061     lout.c.os_heap.c
    64c4:	5f736f00 6574756d 00632e78 735f736f     .os_mutex.c.os_s
    64d4:	64656863 6f00632e 69745f73 632e656d     ched.c.os_time.c
	...

000064e6 <crc16tab>:
    64e6:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
    64f6:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
    6506:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
    6516:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
    6526:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
    6536:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
    6546:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
    6556:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
    6566:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
    6576:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
    6586:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
    6596:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
    65a6:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
    65b6:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
    65c6:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
    65d6:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
    65e6:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
    65f6:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
    6606:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
    6616:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
    6626:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
    6636:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
    6646:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
    6656:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
    6666:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
    6676:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
    6686:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
    6696:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
    66a6:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
    66b6:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
    66c6:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
    66d6:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....
    66e6:	00646c25 706d632e 67040000                       %ld..cmp..

000066f0 <nrf52k_flash_dev>:
    66f0:	00006704 00000000 00080000 00000080     .g..............
    6700:	00000001                                ....

00006704 <nrf52k_flash_funcs>:
    6704:	00005d09 00005c41 00005be5 00005d19     .]..A\...[...]..
    6714:	00005c3d 5f6c6168 745f736f 2e6b6369     =\..hal_os_tick.
    6724:	42410063                                         c.

00006726 <base64_chars>:
    6726:	44434241 48474645 4c4b4a49 504f4e4d     ABCDEFGHIJKLMNOP
    6736:	54535251 58575655 62615a59 66656463     QRSTUVWXYZabcdef
    6746:	6a696867 6e6d6c6b 7271706f 76757473     ghijklmnopqrstuv
    6756:	7a797877 33323130 37363534 2f2b3938     wxyz0123456789+/
    6766:	00430000 00000000                                ..C...

/Users/briangiori/dev/newt/blegpio/bin/nrf52_boot/apps/boot/boot.elf:     file format elf32-littlearm

Contents of section .text:
 0000 00000120 f9330000 29340000 2b340000  ... .3..)4..+4..
 0010 00000000 00000000 00000000 00000000  ................
 0020 00000000 00000000 00000000 71530000  ............qS..
 0030 00000000 00000000 b7530000 e1530000  .........S...S..
 0040 39340000 39340000 39340000 39340000  94..94..94..94..
 0050 39340000 39340000 39340000 39340000  94..94..94..94..
 0060 39340000 39340000 39340000 39340000  94..94..94..94..
 0070 39340000 39340000 39340000 39340000  94..94..94..94..
 0080 39340000 39340000 39340000 39340000  94..94..94..94..
 0090 39340000 39340000 39340000 39340000  94..94..94..94..
 00a0 39340000 39340000 39340000 39340000  94..94..94..94..
 00b0 39340000 39340000 00000000 00000000  94..94..........
 00c0 39340000 39340000 39340000 39340000  94..94..94..94..
 00d0 39340000 39340000 154b002b 08bf134b  94..94...K.+...K
 00e0 9d46a3f5 803a0021 8b460f46 1348144a  .F...:.!.F.F.H.J
 00f0 121a03f0 37fc0f4b 002b00d0 98470e4b  ....7..K.+...G.K
 0100 002b00d0 98470020 00210400 0d000d48  .+...G. .!.....H
 0110 002802d0 0c48aff3 008006f0 11f82000  .(...H........ .
 0120 290000f0 13f803f0 5efb00bf 00000800  ).......^.......
 0130 00000120 00000000 00000000 d0050020  ... ........... 
 0140 d80f0020 00000000 00000000 2de9f043  ... ........-..C
 0150 4ff00c08 adf68c4d 00214246 04a822ad  O......M.!BF..".
 0160 0df10409 03f0fefb 0495cdf8 149004f0  ................
 0170 59fc03f0 a5fa0646 10b13c48 932158e0  Y......F..<H.!X.
 0180 4ff48073 012002a9 2a460293 03f0c0f9  O..s. ..*F......
 0190 029c89f8 0060c4f5 8073002b 029305da  .....`...s.+....
 01a0 32489b21 32461346 04f050fd 022002a9  2H.!2F.F..P.. ..
 01b0 08fb0452 03f0acf9 074610b1 2b489d21  ...R.....F..+H.!
 01c0 f0e7029b 89f80140 1c44c4f5 8073002b  .......@.D...s.+
 01d0 029302da 2548a221 09e008fb 04520320  ....%H.!.....R. 
 01e0 02a903f0 95f90546 18b12048 a4213a46  .......F.. H.!:F
 01f0 d9e7029b 8df81940 1c448df8 184005f0  .......@.D...@..
 0200 55f90823 042003a9 07aa0393 03f0bef9  U..#. ..........
 0210 10b11648 522115e0 00f06cf9 10b907a8  ...HR!....l.....
 0220 00f05cf9 124805f0 ddf90546 18b10f48  ..\..H.....F...H
 0230 61210022 b7e70e48 05f0e2f9 044618b1  a!."...H.....F..
 0240 0a486321 2a46aee7 03f076fc 04a807a9  .Hc!*F....v.....
 0250 03f0e2fd 18b10548 c1212246 a3e7079b  .......H.!"F....
 0260 1889099b 184403f0 b9fa00bf a8610000  .....D.......a..
 0270 d8000020 08b50748 4ff0ff31 04f01cfe  ... ...HO..1....
 0280 38b10928 05d00022 03486d21 134604f0  8..(...".Hm!.F..
 0290 ddfc08bd d0050020 b8610000 08b50648  ....... .a.....H
 02a0 04f0c2fd 38b10928 05d00022 03487621  ....8..(...".Hv!
 02b0 134604f0 cbfc08bd d0050020 b8610000  .F......... .a..
 02c0 10b50446 fff7d6ff 6468fff7 e7ff2046  ...F....dh.... F
 02d0 10bd10b5 0446fff7 cdff2046 00f098fb  .....F.... F....
 02e0 0446fff7 dbff2046 10bd38b5 05460c46  .F.... F..8..F.F
 02f0 fff7c0ff 21462846 00f072fb 0446fff7  ....!F(F..r..F..
 0300 cdff2046 38bd38b5 05460c46 fff7b2ff  .. F8.8..F.F....
 0310 01f006fd 28b12146 284600f0 37fb0446  ....(.!F(F..7..F
 0320 00e00d24 fff7baff 204638bd 10b50446  ...$.... F8....F
 0330 fff7a0ff 01f0f4fc 28b12046 002101f0  ........(. F.!..
 0340 ebfd0446 00e00d24 fff7a8ff 204610bd  ...F...$.... F..
 0350 38b50546 0c46fff7 8dff01f0 e1fc28b1  8..F.F........(.
 0360 21462846 01f088fd 044600e0 0d24fff7  !F(F.....F...$..
 0370 95ff2046 38bd10b5 0446fff7 7bff01f0  .. F8....F..{...
 0380 cffc20b1 204601f0 66fd0446 00e00d24  .. . F..f..F...$
 0390 fff784ff 204610bd 38b50546 0c46fff7  .... F..8..F.F..
 03a0 69ff2146 286800f0 71ff0446 fff776ff  i.!F(h..q..F..v.
 03b0 204638bd 38b50546 0c46fff7 5bff2146   F8.8..F.F..[.!F
 03c0 284600f0 27fc0446 fff768ff 204638bd  (F..'..F..h. F8.
 03d0 70b50646 0d461446 fff74cff 01f0a0fc  p..F.F.F..L.....
 03e0 30b12246 30462946 02f0c8f9 044600e0  0."F0F)F.....F..
 03f0 0d24fff7 53ff2046 70bdf8b5 07460e46  .$..S. Fp....F.F
 0400 15461c46 fff736ff 23463146 2a463846  .F.F..6.#F1F*F8F
 0410 00f00ffc 0446fff7 41ff2046 f8bd10b5  .....F..A. F....
 0420 044638b1 fff726ff 204600f0 25fc0446  .F8...&. F..%..F
 0430 fff734ff 204610bd 73b50646 0c461546  ..4. F..s..F.F.F
 0440 fff718ff 01f06cfc 48b12246 01a83146  ......l.H."F..1F
 0450 00f070fb 044618b9 019b2b60 00e00d24  ..p..F....+`...$
 0460 fff71cff 0cb10023 2b602046 02b070bd  .......#+` F..p.
 0470 10b50446 fff7fefe 0cb12368 33b90022  ...F......#h3.."
 0480 064840f2 2e211346 04f0e0fb 5c68fff7  .H@..!.F....\h..
 0490 05ff2046 bde81040 00f002bd b8610000  .. F...@.....a..
 04a0 f8b50446 0f461646 1d46fff7 e3fe0cb1  ...F.F.F.F......
 04b0 206830b9 00220848 4ff40571 134604f0   h0..".HO..q.F..
 04c0 c5fb3946 32462b46 01f023f9 0446fff7  ..9F2F+F..#..F..
 04d0 e5fe2046 f8bd00bf b8610000 10b50446  .. F.....a.....F
 04e0 fff7c8fe 204602f0 7ff80446 fff7d6fe  .... F.....F....
 04f0 204610bd 70b500f0 27fa00f0 13fa3148   F..p...'.....1H
 0500 04f087fc 002858d1 2f4d304c 286804f0  .....(X./M0L(h..
 0510 f5fba068 0c267043 04f0e4fb 286008b9  ...h.&pC....(`..
 0520 052070bd 2a4d2868 04f0e8fb 23681820  . p.*M(h....#h. 
 0530 584304f0 d7fb2860 0028f1d0 254d2868  XC....(`.(..%M(h
 0540 04f0dcfb 60687043 04f0ccfb 28600028  ....`hpC....(`.(
 0550 e6d0214d 286804f0 d1fb2369 24205843  ..!M(h....#i$ XC
 0560 04f0c0fb 28600028 dad01c4d 286804f0  ....(`.(...M(h..
 0570 c5fb6069 400104f0 b5fb2860 0028cfd0  ..`i@.....(`.(..
 0580 174d2868 04f0bafb e068c000 04f0aafb  .M(h.....h......
 0590 28600028 c4d005f0 3bfa1248 05f056fa  (`.(....;..H..V.
 05a0 1149104a 114805f0 3dfa01f0 1dfb0446  .I.J.H..=......F
 05b0 28b90f48 05f08efa 01e00a20 70bd2046  (..H....... p. F
 05c0 70bd00bf d0050020 280b0020 840b0020  p...... (.. ... 
 05d0 300b0020 800b0020 a80a0020 2c0b0020  0.. ... ... ,.. 
 05e0 7c0b0020 dc050020 340b0020 bf610000  |.. ... 4.. .a..
 05f0 c4610000 10b50446 a16959b1 0b684a68  .a.....F.iY..hJh
 0600 0bb15a60 00e0e261 4a680348 136004f0  ..Z`...aJh.H.`..
 0610 d7fbf1e7 10bd00bf e80a0020 10b50446  ........... ...F
 0620 38b1fff7 e7ff2146 0248bde8 104004f0  8.....!F.H...@..
 0630 c7bb10bd 880a0020 10b50848 04f0acfb  ....... ...H....
 0640 044640b1 24220021 03f08cf9 23460022  .F@.$".!....#F."
 0650 43f8182f e3612046 10bd00bf 880a0020  C../.a F....... 
 0660 10b50548 04f098fb 044618b1 00212022  ...H.....F...! "
 0670 03f078f9 204610bd e80a0020 08b5fff7  ..x. F..... ....
 0680 efff0246 b8b90d4b 5b685b68 1a686ab1  ...F...K[h[h.hj.
 0690 93694bb1 1046fff7 adfffff7 e1ff0246  .iK..F.........F
 06a0 48b90748 3f2103e0 5368eee7 0448e621  H..H?!..Sh...H.!
 06b0 134604f0 cbfa1046 08bd00bf ec000020  .F.....F....... 
 06c0 04620000 83690bb9 0b6007e0 db690b60  .b...i...`...i.`
 06d0 c3695b68 1968088b cb690344 13607047  .i[h.h...i.D.`pG
 06e0 094a1368 4bb19968 814204d1 19685868  .J.hK..h.B...hXh
 06f0 21b14860 03e01b68 f4e77047 50605a68  !.H`...h..pGP`Zh
 0700 18461160 fff78abf ec000020 f8b5274d  .F.`....... ..'M
 0710 2c680746 0e4624b1 a368b342 42d02468  ,h.F.F$..h.BB.$h
 0720 f9e7fff7 89ff0446 d8b96b68 5b681868  .......F..kh[h.h
 0730 10b91f48 802110e0 03684268 0bb15a60  ...H.!...hBh..Z`
 0740 01e01a49 4a604268 1360fff7 67fffff7  ...IJ`Bh.`..g...
 0750 73ff0446 28b91648 88212246 234604f0  s..F(..H.!"F#F..
 0760 75fa0021 24222046 03f0fcf8 314604f1  u..!$" F....1F..
 0770 080000f0 81ff0646 70b9a068 04f12001  .......Fp..h.. .
 0780 00f062fd 064638b9 2b682360 03b9074b  ..b..F8.+h#`...K
 0790 5c602c60 656005e0 2046fff7 3fff0023  \`,`e`.. F..?..#
 07a0 3b6001e0 3c600026 3046f8bd ec000020  ;`..<`.&0F..... 
 07b0 04620000 074b10b5 1c682046 4cb1fff7  .b...K...h FL...
 07c0 19ff04f1 0800a168 00f056ff 08b92468  .......h..V...$h
 07d0 f3e710bd ec000020 32b10023 0b60c369  ....... 2..#.`.i
 07e0 4b601960 c1617047 83690b60 0bb15960  K`.`.apG.i.`..Y`
 07f0 00e0c161 40f8181f 48607047 2de9f043  ...a@...H`pG-..C
 0800 036a89b0 06468846 1746002b 00f08280  .j...F.F.F.+....
 0810 01a902aa fff756ff 029d7db1 019b9845  ......V...}....E
 0820 04d2b369 d3f81490 dd690be0 a84505d2  ...i.....i...E..
 0830 f3695b68 1c68d4f8 089004e0 b368356a  .i[h.h.......h5j
 0840 d3f81090 0024019b 9d4219d8 34b10022  .....$...B..4.."
 0850 334840f2 a9111346 04f0f8f9 fff70eff  3H@....F........
 0860 49460446 083002f0 b5fa0246 002854d1  IF.F.0.....F.(T.
 0870 238bed1a e5613046 2146fff7 adff00e0  #....a0F!F......
 0880 1cb1e569 d4f81490 0ae003a8 494602f0  ...i........IF..
 0890 a1fa0028 41d1bdf8 1c30ddf8 1890ed1a  ...(A....0......
 08a0 454531d8 a04654bb fff7e8fe 0df10c0c  EE1..FT.........
 08b0 804600f1 080ebce8 0f00aee8 0f00dcf8  .F..............
 08c0 0030cef8 0030b369 c8f81c50 7bb1f369  .0...0.i...P{..i
 08d0 5a681268 926852b1 4a4508d1 c8f80040  Zh.h.hR.JE.....@
 08e0 c8f80430 c3f80080 c6f81c80 07e03046  ...0..........0F
 08f0 fff780fe 30464146 0022fff7 6dff5fb1  ....0FAF."..m._.
 0900 c7f80080 002008e0 002c9cd0 63685b68  ..... ...,..ch[h
 0910 1c6898e7 062000e0 384609b0 bde8f083  .h... ..8F......
 0920 04620000 08b5074a 106850b1 03684168  .b.....J.hP..hAh
 0930 0bb15960 00e05160 42681360 fff76efe  ..Y`..Q`Bh.`..n.
 0940 f1e708bd ec000020 0f4b1a68 0ab96422  ....... .K.h..d"
 0950 1a605a68 12b90c4a 64215160 9a6812b9  .`Zh...Jd!Q`.h..
 0960 094a0421 91601a69 12b9074a 04211161  .J.!.`.i...J.!.a
 0970 5a6912b9 044a4021 5161db68 13b9024b  Zi...J@!Qa.h...K
 0980 0422da60 704700bf 840b0020 f7b50f46  .".`pG..... ...F
 0990 01a901f0 55fa0446 c8b9019b 586800f0  ....U..F....Xh..
 09a0 7ffab0b1 0d4804f0 f7f90646 98b12146  .....H.....F..!F
 09b0 08223546 02f0d6ff 019845f8 040b00f0  ."5F......E.....
 09c0 79fc2846 21460422 02f0ccff 3e602046  y.(F!F."....>` F
 09d0 02e00420 00e00520 03b0f0bd ac0a0020  ... ... ....... 
 09e0 70b50446 40680e46 10b92368 1d6903e0  p..F@h.F..#h.i..
 09f0 c56800f0 6ffc50b9 656015b9 35600620  .h..o.P.e`..5`. 
 0a00 70bd2846 043400f0 55fc3460 002070bd  p.(F.4..U.4`. p.
 0a10 10b50446 08b90020 10bd4068 20b92068  ...F... ..@h . h
 0a20 00f058fc 60b904e0 00f054fc 0028f6d0  ..X.`.....T..(..
 0a30 10bd0448 214604f0 c3f90028 ebd00a20  ...H!F.....(... 
 0a40 10bd00bf ac0a0020 2de9f041 88b00546  ....... -..A...F
 0a50 01a80e46 17469846 00f0c0fb 04460028  ...F.F.F.....F.(
 0a60 5ad107f1 14000df1 030102aa 01f01af8  Z...............
 0a70 04460028 50d103a8 ff211422 02f072ff  .F.(P....!."..r.
 0a80 b8f1000f 01d0284a 00e0284a 1368591c  ......(J..(J.hY.
 0a90 11600393 4ff0ff32 0023adf8 18300592  .`..O..2.#...0..
 0aa0 05b16a68 049203a8 31468df8 1c308df8  ..jh....1F...0..
 0ab0 1d7002f0 65fa03a8 31469df8 0320029b  .p..e...1F... ..
 0ac0 00f0a7fb 044638bb 019e039b 73600299  .....F8.....s`..
 0ad0 9df80300 00f058f9 0199b060 01230b75  ......X....`.#.u
 0ae0 0c612db1 284600f0 2dfe0446 a0b90be0  .a-.(F..-..F....
 0af0 039b2bb1 0e487b21 2a462b46 04f0a6f8  ..+..H{!*F+F....
 0b00 08462021 00f068ff 019800f0 33fa0e9b  .F !..h.....3...
 0b10 019a1a60 002003e0 019800f0 f3fa2046  ...`. ........ F
 0b20 08b0bde8 f08100bf 9c0c0020 a80c0020  ........... ... 
 0b30 11620000 2de9f041 80469007 8ab00f46  .b..-..A.F.....F
 0b40 16465ed0 12f00c03 03d09107 59d50c2b  .F^.........Y..+
 0b50 57d02f48 04f020f9 05460028 53d00c22  W./H.. ..F.(S.."
 0b60 002102f0 fffe05a8 394601f0 2bf905a8  .!......9F..+...
 0b70 04a903aa 01f02cf9 06280446 0dd1059b  ......,..(.F....
 0b80 022b38d1 b20736d5 03980028 33d09df8  .+8...6....(3...
 0b90 20200095 07990023 10e060bb 049b5868    .....#..`...Xh
 0ba0 00f07ef9 30bb3307 0dd53846 01f053f9  ..~.0.3...8F..S.
 0bb0 9df82020 03980799 00952346 fff744ff  ..  ......#F..D.
 0bc0 0446c0b9 01e0049b 2b6006f0 040303f0  .F......+`......
 0bd0 ff0233b1 2868291d 00f058fb 044650b9  ..3.(h)...X..FP.
 0be0 00e06a60 286800f0 65fb2e72 0020c8f8  ..j`(h..e..r. ..
 0bf0 005009e0 04240648 294604f0 e1f82046  .P...$.H)F.... F
 0c00 02e00420 00e00520 0ab0bde8 f08100bf  ... ... ........
 0c10 cc0a0020 37b50446 0d460068 01a900f0  ... 7..F.F.h....
 0c20 35fb20b9 019b9d42 94bf6560 032003b0  5. ....B..e`. ..
 0c30 30bdf0b5 85b00546 0f461646 1c4601f0  0......F.F.F.F..
 0c40 6ff890b1 2b7adb07 11d503ab 009395e8  o...+z..........
 0c50 03003a46 334600f0 8ffc58b9 6b68039a  ..:F3F....X.kh..
 0c60 13446b60 2cb12260 04e00d20 02e00c20  .Dk`,."`... ... 
 0c70 00e02046 05b0f0bd 10b50446 006800f0  .. F.......F.h..
 0c80 29fb38b9 04482146 04f09af8 00280cbf  ).8..H!F.....(..
 0c90 00200a20 10bd00bf cc0a0020 f8b50f4d  . . ....... ...M
 0ca0 2d788542 1c4605d8 00220d48 31211346  -x.B.F...".H1!.F
 0cb0 03f0ccff 0b4d2e68 00013518 0c446f68  .....M.h..5..Doh
 0cc0 bc4209d8 3458e87b 214402f0 0bfd0028  .B..4X.{!D.....(
 0cd0 14bf0220 0020f8bd 0320f8bd 240b0020  ... . ... ..$.. 
 0ce0 1d620000 400b0020 f8b5114c 24788442  .b..@.. ...L$x.B
 0cf0 1d4605d8 00220f48 57211346 03f0a6ff  .F...".HW!.F....
 0d00 0d4c2668 00013418 0d446768 bd420ad8  .L&h..4..Dgh.B..
 0d10 a768b942 07d33658 e07b3144 02f000fd  .h.B..6X.{1D....
 0d20 18b9a560 f8bd0320 f8bd0220 f8bd00bf  ...`... ... ....
 0d30 240b0020 1d620000 400b0020 2de9f843  $.. .b..@.. -..C
 0d40 089c8046 0e469146 1f46bcb1 b4f5807f  ...F.F.F.F......
 0d50 254628bf 4ff48075 40463146 094a2b46  %F(.O..u@F1F.J+F
 0d60 fff79cff 58b94846 3946064a 2b46fff7  ....X.HF9F.J+F..
 0d70 bbff20b9 2e442f44 641be6e7 2046bde8  .. ..D/Dd... F..
 0d80 f88300bf 9c0b0020 b1f1807f 08b505d3  ....... ........
 0d90 00220448 a3211346 03f058ff 41ea0060  .".H.!.F..X.A..`
 0da0 08bd00bf 1d620000 030e20f0 7f400b70  .....b.... ..@.p
 0db0 10607047 2de9f041 124f3b68 04011d19  .`pG-..A.O;h....
 0dc0 86b00646 8846e87b 19596a68 02f0c6fc  ...F.F.{.Yjh....
 0dd0 a0b9a860 69462846 01f0ccfe b8f1000f  ...`iF(F........
 0de0 05d03b68 1c44ff23 a3811723 00e01823  ..;h.D.#...#...#
 0df0 30460021 6a46fff7 77ff00e0 022006b0  0F.!jF..w.... ..
 0e00 bde8f081 400b0020 30b5154b 1b788342  ....@.. 0..K.x.B
 0e10 87b00446 0d4605d8 00221248 25211346  ...F.F...".H%!.F
 0e20 03f014ff 00216a46 1823fff7 37ffa8b9  .....!jF.#..7...
 0e30 0d4b1b68 03eb0413 68469d81 01f08afe  .K.h....hF......
 0e40 014618b9 2046fff7 b5ff07e0 06aa2046  .F.. F........ F
 0e50 02f8015d 17210123 fff746ff 07b030bd  ...].!.#..F...0.
 0e60 240b0020 2a620000 400b0020 0b4b70b5  $.. *b..@.. .Kp.
 0e70 1d68c4b2 002255f8 24100b46 63b15e68  .h..."U.$..Fc.^h
 0e80 864206d1 42b11868 10601960 45f82430  .B..B..h.`.`E.$0
 0e90 02e01a46 1b68f1e7 184670bd a40c0020  ...F.h...Fp.... 
 0ea0 b0f1805f 2cbf0020 01207047 00f17040  ..._,.. . pG..p@
 0eb0 b0f1e04f 2cbf0020 01207047 c043c00f  ...O,.. . pG.C..
 0ec0 70470000 034b00f1 00409842 8cbf0020  pG...K...@.B... 
 0ed0 01207047 feffff7f 064bc2b2 1b6853f8  . pG.....K...hS.
 0ee0 223023b1 5a688242 01d01b68 f9e71846  "0#.Zh.B...h...F
 0ef0 704700bf a40c0020 10b50446 fff7deff  pG..... ...F....
 0f00 024620b9 04487221 134603f0 9ffe2046  .F ..Hr!.F.... F
 0f10 bde81040 fff7aabf 38620000 08b5074b  ...@....8b.....K
 0f20 00f10042 9a4205d9 00220548 7d211346  ...B.B...".H}!.F
 0f30 03f08cfe bde80840 fff798bf feffff7f  .......@........
 0f40 38620000 10b50021 8468ff20 fff71cff  8b.....!.h. ....
 0f50 231a5842 584110bd 10b5fff7 bdff38b1  #.XBXA........8.
 0f60 84680021 ff20fff7 0fff231a 58425841  .h.!. ....#.XBXA
 0f70 10bd0000 38b54468 05462046 fff7acff  ....8.Dh.F F....
 0f80 18b11448 9a210022 12e0134b e2b21b68  ...H.!."...K...h
 0f90 53f82210 29602046 43f82250 fff78eff  S.".)` FC."P....
 0fa0 70b12046 fff7a8ff 024620b9 0948a221  p. F.....F ..H.!
 0fb0 134603f0 4bfe4021 bde83840 00f00cbd  .F..K.@!..8@....
 0fc0 2046fff7 89ff0246 10b90248 a521efe7   F.....F...H.!..
 0fd0 38bd00bf 38620000 a40c0020 70b54668  8...8b..... p.Fh
 0fe0 04463046 fff76aff 05463046 8db1fff7  .F0F..j..F0F....
 0ff0 83ff0546 18b91c48 b2212a46 06e04021  ...F...H.!*F..@!
 1000 00f0f5fc 024658b9 1748b321 134603f0  .....FX..H.!.F..
 1010 1dfefff7 61ff0246 10b91348 b521f5e7  ....a..F...H.!..
 1020 124b6068 1a68c1b2 52f82130 a34203d1  .K`h.h..R.!0.B..
 1030 236842f8 213006e0 1a68a242 01d01346  #hB.!0...h.B...F
 1040 fae72268 1a60fff7 39ff20b1 1db12846  .."h.`..9. ...(F
 1050 402100f0 c6fc6068 fff73eff 18b10248  @!....`h..>....H
 1060 c0210022 d2e770bd 38620000 a40c0020  .!."..p.8b..... 
 1070 10b50a4c 206802f0 5ffc4ff4 806002f0  ...L h.._.O..`..
 1080 11fc2060 40b10023 22680020 d0500433  .. `@..#"h. .P.3
 1090 b3f5806f f8d110bd 052010bd a40c0020  ...o..... ..... 
 10a0 73b51646 1d46ca18 037b9a42 0c4606dd  s..F.F...{.B.F..
 10b0 00220c48 40f2c621 134603f0 c7fd0368  .".H@..!.F.....h
 10c0 0df10301 986801aa fff76efe 01999df8  .....h....n.....
 10d0 03001431 21443246 2b460191 fff7defd  ...1!D2F+F......
 10e0 02b070bd 44620000 10b50548 03f054fe  ..p.Db.....H..T.
 10f0 044618b1 00211822 02f034fc 204610bd  .F...!."..4. F..
 1100 080b0020 10b50446 78b14068 fff7d6fe  ... ...Fx.@h....
 1110 024620b9 05483821 134603f0 97fd2146  .F ..H8!.F....!F
 1120 0348bde8 104003f0 4bbe10bd 44620000  .H...@..K...Db..
 1130 080b0020 70b50e46 044620b9 254840f2  ... p..F.F .%H@.
 1140 5d112246 04e0027d 2ab92248 4ff4af71  ]."F...}*."HO..q
 1150 134603f0 7bfd013a d2b20275 002a33d1  .F..{..:...u.*3.
 1160 4068fff7 a3fe0546 30b36068 fff79efe  @h.....F0.`h....
 1170 c0b1637d 606863f0 7f036375 fff796fe  ..c}`hc...cu....
 1180 024630b9 134840f2 0511e1e7 01f068fe  .F0..H@.......h.
 1190 18b92069 0028f9d1 04e00128 16d1aeb1  .. i.(.....(....
 11a0 00232361 2046fff7 9bfa2046 fff716ff  .##a F.... F....
 11b0 2046fff7 a7ff07e0 2046fff7 0fff064b   F...... F.....K
 11c0 1a682260 1c6002e0 002500e0 05462846  .h"`.`...%...F(F
 11d0 70bd00bf 44620000 f8050020 13b50446  p...Db..... ...F
 11e0 fff782ff 01a92060 00f03cfc 0028f7d1  ...... `..<..(..
 11f0 019802b0 10bd10b5 14231446 fff74efd  .........#.F..N.
 1200 30b92068 fff75afe 00280cbf 09200020  0. h..Z..(... . 
 1210 10bd2de9 f0410646 0f461546 1c461046  ..-..A.F.F.F.F.F
 1220 19463246 1423fff7 5ffd50b9 737c3bb1  .F2F.#.._.P.s|;.
 1230 284604f1 14013a46 bde8f041 fff754bd  (F....:F...A..T.
 1240 1846bde8 f0810000 30b50546 87b04068  .F......0..F..@h
 1250 0c46fff7 2bfe0246 20b90b48 91211346  .F..+..F ..H.!.F
 1260 03f0f4fc 00232360 296951b1 01a801f0  .....##`)iQ.....
 1270 b1fd38b9 2268bdf8 14300499 13442360  ..8."h...0...D#`
 1280 f3e70846 07b030bd 44620000 13b50346  ...F..0.Db.....F
 1290 0c4601a8 1946fff7 39fa10b9 019b1b6a  .F...F..9......j
 12a0 236002b0 10bd8368 0bb15868 70474ff0  #`.....h..XhpGO.
 12b0 ff307047 08b50246 28b90548 4ff4b971  .0pG...F(..HO..q
 12c0 134603f0 c3fc037d 01330375 002008bd  .F.....}.3.u. ..
 12d0 44620000 0021fff7 2dbf0000 30b58268  Db...!..-...0..h
 12e0 89b00546 2ab91d48 4ff4e671 134603f0  ...F*..HO..q.F..
 12f0 adfc1420 0df10701 02aa00f0 d3fb58bb  ... ..........X.
 1300 2a686b68 51680391 01338021 6b608df8  *hkhQh...3.!k`..
 1310 1c101269 adf81830 4ff0ff33 049302b1  ...i...0O..3....
 1320 53680593 03a80023 0d498df8 1d3001f0  Sh.....#.I...0..
 1330 27fe029b 0a499df8 072003a8 fff769ff  '....I... ....i.
 1340 2b680446 5868fff7 b1fd20b1 2a68537d  +h.FXh.... .*hS}
 1350 63f07f03 53752046 09b030bd 44620000  c...Su F..0.Db..
 1360 05630000 38b50368 5b7d03f0 20030546  .c..8..h[}.. ..F
 1370 03f0ff02 1bb91648 40f23731 05e08468  .......H@.71...h
 1380 34b91348 40f23931 22461346 03f05efc  4..H@.91"F.F..^.
 1390 6068fff7 85fd0246 18b90d48 40f23a31  `h.....F...H@.:1
 13a0 f3e72369 2a689342 02d1db68 236106e0  ..#i*h.B...h#a..
 13b0 d9689142 01d00b46 fae7d268 da602b68  .h.B...F...h.`+h
 13c0 0022da60 5a7d22f0 20025a75 38bd00bf  .".`Z}". .Zu8...
 13d0 44620000 83682de9 f0410446 0f461646  Db...h-..A.F.F.F
 13e0 0bb1fff7 bfff2268 537d63f0 7f035375  ......"hS}c...Su
 13f0 23685868 fff754fd 80b32468 2046fff7  #hXh..T...$h F..
 1400 edfd1b4b 1a682260 1c601d46 2c68dff8  ...K.h"`.`.F,h..
 1410 608044b3 6068fff7 43fd0246 28b91548  `.D.`h..C..F(..H
 1420 40f2a111 134603f0 11fcd8f8 00302069  @....F.......0 i
 1430 1b68c8f8 003068b1 d0f80c80 26b13368  .h...0h.....&.3h
 1440 834208bf c6f80080 3946fff7 73fe68b9  .B......9F..s.h.
 1450 4046f0e7 2046fff7 55fed7e7 20683946  @F.. F..U... h9F
 1460 fff768fe 10b90020 bde8f081 bde8f081  ..h.... ........
 1470 f8050020 44620000 2de9f047 057b9542  ... Db..-..G.{.B
 1480 a8bf1546 032d2c46 a8bf0324 07469046  ...F.-,F...$.F.F
 1490 0d302246 1e468946 02f089fa 30603068  .0"F.F.F....0`0h
 14a0 c0b9ac42 19dac4eb 050abaf1 810f28bf  ...B..........(.
 14b0 4ff0800a 3846e1b2 0b4a5346 fff7f0fd  O...8F...JSF....
 14c0 78b909eb 04010848 524602f0 70fa5444  x......HRF..p.TD
 14d0 3060e4e7 0020bde8 f0873b7b c8eb0303  0`... ....;{....
 14e0 3360bde8 f08700bf 9c0b0020 2de9f047  3`......... -..G
 14f0 057b0b7b 9d4228bf 1d46032d 2c46a8bf  .{.{.B(..F.-,F..
 1500 03241646 80460f46 0d300d31 224602f0  .$.F.F.F.0.1"F..
 1510 4efa3060 306808bb ac4222da c4eb0509  N.0`0h...B".....
 1520 b9f1810f 28bf4ff0 80095ffa 84fa4046  ....(.O..._...@F
 1530 51460f4a 4b46fff7 b3fdb8b9 38465146  QF.JKF......8FQF
 1540 0c4a4b46 fff7acfd 80b90948 4a4600f1  .JKF.......HJF..
 1550 800102f0 2cfa4c44 3060dbe7 0020bde8  ....,.LD0`... ..
 1560 f08798f8 0c303a7b 9b1a3360 bde8f087  .....0:{..3`....
 1570 9c0b0020 1c0c0020 2de9f347 0a9d0746  ... ... -..G...F
 1580 0e469846 144622b9 0db90020 42e02a60  .F.F.F".... B.*`
 1590 fbe76846 3946fff7 b9f80028 3ad1009b  ..hF9F.....(:...
 15a0 01901a6a 34449442 28bf1446 a71ba246  ...j4D.B(..F...F
 15b0 b946b9f1 000f29d0 019b33b9 00980af1  .F....)...3.....
 15c0 ff3101aa fff71af9 20bb0198 c369028b  .1...... ....i..
 15d0 b3423cbf f11a89b2 134428bf 0021521a  .B<......D(..!R.
 15e0 a34292b2 82bfe31a d21892b2 c2eb0909  .B..............
 15f0 083008eb 0903c2eb 0a0a01f0 c9fb48b9  .0............H.
 1600 019b5b68 5b681b68 0193d2e7 002dbcd0  ..[h[h.h.....-..
 1610 2f604846 02b0bde8 f0870a46 0021fff7  /`HF.......F.!..
 1620 d9be0a46 0121fff7 d5be10b5 0446fff7  ...F.!.......F..
 1630 55fe0146 20b92046 bde81040 fff7edbf  U..F . F...@....
 1640 10bd0000 38b50021 85680446 ff20fff7  ....8..!.h.F. ..
 1650 9bfb8542 05d1637d 43f00103 63750120  ...B..c}C...cu. 
 1660 38bd044b 1b689c42 1abf607d 00f00100  8..K.h.B..`}....
 1670 002038bd 780b0020 70b50446 88b00846  . 8.x.. p..F...F
 1680 0e46fff7 dfff0546 38b12046 00211022  .F.....F8. F.!."
 1690 02f068f9 06252660 38e0b068 0df10701  ..h..%&`8..h....
 16a0 02aafff7 81fb9df8 07000299 03aafff7  ................
 16b0 a2fd50bb 0498bdf8 18306360 431c2660  ..P......0c`C.&`
 16c0 01d1a560 02e0fff7 17fca060 9df81d30  ...`.......`...0
 16d0 2373032b 0ed873b9 9df91c30 002b15da  #s.+..s....0.+..
 16e0 2268537d 63f07f03 5375737d 63f07f03  "hS}c...Sus}c...
 16f0 73750be0 03230299 9df80700 143104f1  su...#.......1..
 1700 0d02fff7 cbfa0028 e6d00546 284608b0  .......(...F(F..
 1710 70bd7fb5 03460e46 68461946 1546fff7  p....F.FhF.F.F..
 1720 abff68b9 9df80c40 a64298bf 06f1ff34  ..h....@.B.....4
 1730 68460021 2a462346 fff7b2fc 00b92855  hF.!*F#F......(U
 1740 04b070bd f0b50746 8bb04068 0c46fff7  ..p....F..@h.F..
 1750 a7fb0246 18b91e48 4ff44371 06e0637d  ...F...HO.Cq..c}
 1760 9b0606d5 1a4840f2 0d310022 134603f0  .....H@..1.".F..
 1770 6dfa02a8 2146fff7 7fff30bb 3d690646  m...!F....0.=i.F
 1780 9db1a542 03d11248 40f21631 ede706a8  ...B...H@..1....
 1790 2946fff7 71ffc0b9 02a806a9 01aafff7  )F..q...........
 17a0 a5fe90b9 019b002b 04da36b9 3b69e360  .......+..6.;i.`
 17b0 3c6105e0 2e46ed68 e2e7f368 e360f460  <a...F.h...h.`.`
 17c0 637d43f0 20036375 00200bb0 f0bd00bf  c}C. .cu. ......
 17d0 44620000 70b50546 8cb04068 0c461646  Db..p..F..@h.F.F
 17e0 fff75efb 60b12146 41b1a942 06d007a8  ..^.`.!FA..B....
 17f0 fff742ff 002867d1 0999f5e7 a94260d0  ..B..(g......B`.
 1800 03a82946 fff738ff 00285dd1 059ba342  ..)F..8..(]....B
 1810 0dd013b1 03a8fff7 a5fd0cb9 059406e0  ................
 1820 20460399 fff78eff 0028f7d0 4ce026b1   F.......(..L.&.
 1830 304602f0 b4f80446 12e0a868 9df81840  0F.....F...h...@
 1840 0df10701 02aafff7 affa0299 9df80700  ................
 1850 1e4a1431 2346fff7 21fa0028 34d11b4e  .J.1#F..!..(4..N
 1860 04f11400 80b20df1 070102aa 00f01af9  ................
 1870 50bb6b68 0793049b 03a80133 adf82830  P.kh.......3..(0
 1880 fff711fd 2b690890 8df82d40 13b15b68  ....+i....-@..[h
 1890 5a1c01d1 4ff0ff33 07a83146 099301f0  Z...O..3..1F....
 18a0 6ffb07a8 31469df8 0720029b fff7b1fc  o...1F... ......
 18b0 044640b9 9df80700 0299fff7 65faa860  .F@.........e..`
 18c0 01e00420 00e02046 0cb070bd 9c0b0020  ... .. F..p.... 
 18d0 70b50546 8cb003a8 2946fff7 cdfe0628  p..F....)F.....(
 18e0 044609d1 2846fff7 adfe0246 00285cd1  .F..(F.....F.(\.
 18f0 2f4840f2 8b210ce0 002856d1 ff202146  /H@..!...(V.. !F
 1900 ae68fff7 41fa8642 06d12948 4ff42471  .h..A..B..)HO.$q
 1910 22461346 03f09af9 a8689df8 18600df1  "F.F.....h...`..
 1920 070102aa fff740fa 02999df8 0700214a  ......@.......!J
 1930 14313346 fff7b2f9 002837d1 06f11400  .13F.....(7.....
 1940 0df10701 02aa00f0 adf80446 68bb6b68  ...........Fh.kh
 1950 0793049b 03a80133 adf82830 fff7a3fc  .......3..(0....
 1960 2b698df8 2c408df8 2d600890 5868fff7  +i..,@..-`..Xh..
 1970 a9fa0246 18b90e48 40f2aa21 c9e72b69  ...F...H@..!..+i
 1980 0c495b68 099307a8 01f0fafa 07a80949  .I[h...........I
 1990 9df80720 029bfff7 3cfc0446 28b99df8  ... ....<..F(...
 19a0 07000299 fff7f0f9 a8602046 0cb070bd  .........` F..p.
 19b0 44620000 9c0b0020 08b50246 28b90548  Db..... ...F(..H
 19c0 40f2eb41 134603f0 41f9407d 00f08000  @..A.F..A.@}....
 19d0 08bd00bf 44620000 437d1943 41750846  ....Db..C}.CAu.F
 19e0 7047437d 23ea0101 41750846 7047407d  pGC}#...Au.FpG@}
 19f0 08407047 1fb50a4b 196861b1 4b6853b9  .@pG...K.ha.KhS.
 1a00 6846fff7 39fe08b1 062805d1 02980030  hF..9....(.....0
 1a10 18bf0120 00e00120 05b05df8 04fb00bf  ... ... ..].....
 1a20 780b0020 10b50c4b 1b78ff2b 12d00b4a  x.. ...K.x.+...J
 1a30 126802eb 03135868 094b1978 00238b42  .h....Xh.K.x.#.B
 1a40 06da02eb 03146468 844203d8 0133f6e7  ......dh.B...3..
 1a50 002010bd 012010bd a40a0020 400b0020  . ... ..... @.. 
 1a60 240b0020 38b50d46 0c4c18b1 00202070  $.. 8..F.L...  p
 1a70 086038bd 0a4a2178 1278013a 914202db  .`8..J!x.x.:.B..
 1a80 05222a60 38bd01f0 8bfb2378 28600133  ."*`8.....#x(`.3
 1a90 2370b0fa 80f04009 38bd00bf fc050020  #p....@.8...... 
 1aa0 240b0020 2de9f341 1d4b1e4c 93f800e0  $.. -..A.K.L....
 1ab0 1d4bd4f8 008093f8 00c00546 0e461746  .K.........F.F.F
 1ac0 00237345 0fda6345 0bd0d9b2 08eb0111  .#sE..cE........
 1ad0 88684a68 121aaa42 03d33860 33700020  .hJh...B..8`3p. 
 1ae0 1be00133 ede72846 0df10701 01f064fc  ...3..(F......d.
 1af0 024658b9 9df80710 236803eb 01139868  .FX.....#h.....h
 1b00 5b681b1a ab4203d3 38603170 104604e0  [h...B..8`1p.F..
 1b10 0648ed21 134603f0 99f802b0 bde8f081  .H.!.F..........
 1b20 240b0020 400b0020 a40a0020 51620000  $.. @.. ... Qb..
 1b30 38b5094d 04462868 1cb903f0 dff82c60  8..M.F(h......,`
 1b40 04e02101 03f0e5f8 286018b1 034b1c70  ..!.....(`...K.p
 1b50 002038bd 052038bd 400b0020 240b0020  . 8.. 8.@.. $.. 
 1b60 30b5144b 1978144b 00221c68 4ff0ff33  0..K.x.K.".hO..3
 1b70 8a4207da 04eb0215 01326d68 ab4228bf  .B.......2mh.B(.
 1b80 2b46f5e7 a3f12c02 82420fd3 183b5b08  +F....,..B...;[.
 1b90 143bb3f5 006f094a 28bf4ff4 00631380  .;...o.J(.O..c..
 1ba0 13888342 04d2054b 188001e0 012030bd  ...B...K..... 0.
 1bb0 002030bd 240b0020 400b0020 600b0020  . 0.$.. @.. `.. 
 1bc0 08b50748 074900f0 a7f938b1 0b2805d1  ...H.I....8..(..
 1bd0 03480449 bde80840 00f032b9 08bd00bf  .H.I...@..2.....
 1be0 5d620000 c80a0020 37b5fef7 9bfe314b  ]b..... 7.....1K
 1bf0 0093314c 314b3248 a1681b68 0c2203f0  ..1L1K2H.h.h."..
 1c00 97f808b1 0a2053e0 2e4b0093 2e4b2f48  ..... S..K...K/H
 1c10 21681b68 182203f0 8bf80028 f2d12c4b  !h.h.".....(..,K
 1c20 00932c4b 2c486168 1b680c22 03f080f8  ..,K,Hah.h."....
 1c30 0028e7d1 294b0093 294b2a48 21691b68  .(..)K..)K*H!i.h
 1c40 242203f0 75f80028 dcd1274b 0093274b  $"..u..(..'K..'K
 1c50 27486169 1b682022 03f06af8 0028d1d1  'Hai.h "..j..(..
 1c60 244b0093 244b2548 e1681b68 082203f0  $K..$K%H.h.h."..
 1c70 5ff80028 c6d1fff7 fbf90446 b8b9204d  _..(.......F.. M
 1c80 286803f0 3bf81f4b 2c601c70 1e4b1c60  (h..;..K,`.p.K.`
 1c90 1e4b1c60 1e4bff22 1a701e4b 4ff08052  .K.`.K.".p.KO..R
 1ca0 1a601d4b 1c601d4b 4ff00042 1a602046  .`.K.`.KO..B.` F
 1cb0 03b030bd 69620000 840b0020 280b0020  ..0.ib..... (.. 
 1cc0 cc0a0020 78620000 300b0020 080b0020  ... xb..0.. ... 
 1cd0 8e620000 800b0020 440b0020 a4620000  .b..... D.. .b..
 1ce0 a80a0020 880a0020 ba620000 2c0b0020  ... ... .b..,.. 
 1cf0 e80a0020 d0620000 7c0b0020 ac0a0020  ... .b..|.. ... 
 1d00 400b0020 240b0020 780b0020 c80a0020  @.. $.. x.. ... 
 1d10 a40a0020 a80c0020 9c0c0020 a00c0020  ... ... ... ... 
 1d20 024b1868 003018bf 01207047 780b0020  .K.h.0... pGx.. 
 1d30 f0b50446 87b00d46 16461f46 8cb102a8  ...F...F.F.F....
 1d40 2146fff7 99fc80b9 02a82946 324601ab  !F........)F2F..
 1d50 fff792fb 48b90198 002801d1 3c6004e0  ....H....(..<`..
 1d60 01dd0620 01e0e468 e8e707b0 f0bd2de9  ... ...h......-.
 1d70 f041d0f8 0080b8f1 020f0446 02d10420  .A.........F... 
 1d80 bde8f081 47680569 7e193046 2f2101f0  ....Gh.i~.0F/!..
 1d90 f1fd40b9 b8f1000f f1d00223 23603046  ..@........##`0F
 1da0 01f0fdfd 03e00123 c01b2360 401bb0f5  .......#..#`@...
 1db0 807fe4dc e0600130 28442061 a6600020  .....`.0(D a.`. 
 1dc0 bde8f081 00230360 41600361 70470000  .....#.`A`.apG..
 1dd0 0023f7b5 05460f46 0b601646 02b11360  .#...F.F.`.F...`
 1de0 01932846 019cfff7 c2ff28bb 2b68012b  ..(F......(.+h.+
 1df0 02d0022b 10d0f4e7 ea681cb9 dab90f4b  ...+.....h.....K
 1e00 1b68ede7 002aecd0 2069a968 01abfff7  .h...*.. i.h....
 1e10 8fff0028 e5d009e0 6cb1ea68 0ab90194  ...(....l..h....
 1e20 04e02069 a96801ab fff782ff 019b3b60  .. i.h........;`
 1e30 16b13460 00e00620 03b0f0bd 780b0020  ..4`... ....x.. 
 1e40 7fb50022 029001a8 01920592 fff7c0ff  ..."............
 1e50 07b05df8 04fb7fb5 01a9fff7 f1ff38b9  ..]...........8.
 1e60 02a80199 fff708fc 10b902a8 fff7ddfb  ................
 1e70 07b05df8 04fb0000 10b58eb0 00230c46  ..]..........#.F
 1e80 0a9001a9 09a803aa 09930d93 fff7a0ff  ................
 1e90 00283dd1 09900d90 02a909a8 04aa0a94  .(=.............
 1ea0 fff796ff 10b10628 26d031e0 019b5868  .......(&.1...Xh
 1eb0 fef7f6ff 029b0446 5868fef7 f1ff8442  .......FXh.....B
 1ec0 01d00420 24e005a8 0299fff7 d5fb0446  ... $..........F
 1ed0 f0b90198 fff770fd 20b10e48 40f21911  ......p. ..H@...
 1ee0 22460ee0 05a8fff7 a0fb88b9 01980499  "F..............
 1ef0 0b9afff7 6ffc0be0 049a2ab9 05484ff4  ....o.....*..HO.
 1f00 92711346 02f0a2fe 099b022b d9d1ede7  .q.F.......+....
 1f10 0eb010bd de620000 30b58bb0 03ad0023  .....b..0......#
 1f20 0c460690 294605a8 04aa0593 0993fff7  .F..)F..........
 1f30 4fff98b1 062814d1 059b022b 11d1049b  O....(.....+....
 1f40 7bb11846 9df82020 00950799 0123fef7  {..F..  .....#..
 1f50 7bfd30b9 24b1039b 236002e0 0b2000e0  {.0.$...#`... ..
 1f60 20460bb0 30bd70b5 05460e46 fff7bcf8   F..0.p..F.F....
 1f70 044690b1 45600021 ff20fef7 05ff0025  .F..E`.!. .....%
 1f80 a0600121 25752561 2046fff7 25fd2046  .`.!%u%a F..%. F
 1f90 fef7f0ff 34602846 70bd0520 70bd0000  ....4`(Fp.. p...
 1fa0 2de9f047 ad4b1e68 90b00746 06eb0016  -..G.K.h...F....
 1fb0 1823b360 d6f80880 fcb22046 41460baa  .#.`...... FAF..
 1fc0 1423fef7 6bfef8b9 0b98fef7 77ff08b1  .#..k.......w...
 1fd0 012304e0 0b98fef7 75ff58b1 02230893  .#......u.X..#..
 1fe0 ddf820a0 8df82440 baf1010f cdf82880  .. ...$@......(.
 1ff0 05d113e0 0b9b0133 40f08b81 f7e1baf1  .......3@.......
 2000 020f00f0 e18071e1 032800f0 85810728  ......q..(.....(
 2010 00f08281 012840f0 ea817ae1 9df82490  .....(@...z...$.
 2020 00230ba8 49464246 029300f0 8dff0546  .#..IFBF.......F
 2030 002840f0 59810b98 fef75eff 04460028  .(@.Y.....^..F.(
 2040 00f08780 9df93c30 002b02da 8021fff7  ......<0.+...!..
 2050 c3fc6268 0b9b9a42 03d08148 4ff4d371  ..bh...B...HO..q
 2060 55e12046 fff7eefa a0b92046 1021fff7  U. F...... F.!..
 2070 befc78b9 03a82146 fff7fefa 002840f0  ..x...!F.....(@.
 2080 ad81bdf8 3830049a 9a4203d3 40f08d80  ....80...B..@...
 2090 0b20a3e1 2046fff7 d5fa18bb 03a82146  . .. F........!F
 20a0 fff7eafa 002840f0 99812046 1021fff7  .....(@... F.!..
 20b0 9efc18b1 20461021 fff793fc 059b13b1  .... F.!........
 20c0 03a8fff7 4ff96368 002b3ad0 9df93c30  ....O.ch.+:...<0
 20d0 002b02db 0c9b0133 33d12046 8021fff7  .+.....33. F.!..
 20e0 7bfc2ee0 20460221 fff781fc 70b16068  {... F.!....p.`h
 20f0 fef7d6fe 024628b9 59484ff4 0f711346  .....F(.YHO..q.F
 2100 02f0a4fd 20460221 fff76bfc 20460821  .... F.!..k. F.!
 2110 fff76dfc 60b16068 fef7c8fe 024618b9  ..m.`.`h.....F..
 2120 4f4840f2 4621eae7 20460821 fff759fc  OH@.F!.. F.!..Y.
 2130 20460121 fff75bfc 18b12046 0121fff7   F.!..[... F.!..
 2140 50fc4146 4846fef7 1ffe4ff0 0008a060  P.AFHF....O....`
 2150 11e0fef7 c9ff0446 002800f0 c7800b9b  .......F.(......
 2160 43604146 4846fef7 0ffe2561 a0602046  C`AFHF....%a.` F
 2170 fef700ff d0460123 23759df9 3c30002b  .....F.##u..<0.+
 2180 03da2046 8021fff7 27fc0d9b 013340f0  .. F.!..'....3@.
 2190 c5800c98 431c40f0 01816368 2bb9314b  ....C.@...ch+.1K
 21a0 20462021 1c60fff7 17fc6068 fef77efe   F !.`....`h..~.
 21b0 636808b1 2c4a00e0 2c4a1168 8b42c0f0  ch..,J..,J.h.B..
 21c0 95800133 136091e0 9df82490 0ba84946  ...3.`....$...IF
 21d0 424600f0 94fe0546 002840f0 85800b98  BF.....F.(@.....
 21e0 fef79cfe 04460028 42d003a8 214600f0  .....F.(B...!F..
 21f0 9ffd10b1 062840f0 f1802046 00f0dffd  .....(@... F....
 2200 a0b16268 0b9b9a42 03d01548 4ff45071  ..bh...B...HO.Pq
 2210 7de04146 4846fef7 b7fda060 0c98fef7  }.AFHF.....`....
 2220 6bfe0290 10b10421 fff7dbfb 03980b9b  k......!........
 2230 42689a42 03d00a48 40f2fa21 67e000f0  Bh.B...H@..!g...
 2240 befd0546 18b10648 40f2fd21 5fe0bdf8  ...F...H@..!_...
 2250 3830049a 9a4249d2 c2e000bf 400b0020  80...BI.....@.. 
 2260 ea620000 780b0020 a80c0020 9c0c0020  .b..x.. ... ... 
 2270 00f0d8fc 04460028 38d00b9b 43604146  .....F.(8...C`AF
 2280 4846fef7 81fda060 2046fef7 73fe594a  HF.....` F..s.YJ
 2290 0b9b1168 8b4224bf 01331360 4ff00108  ...h.B$..3.`O...
 22a0 554bbdf8 3c201988 0c989142 38bf1a80  UK..< .....B8...
 22b0 fef722fe 029060b9 0c9802a9 fff753fe  .."...`.......S.
 22c0 054658b9 02980821 fff786fb 029b1c61  .FX....!.......a
 22d0 0ce08021 fff78bfb 40b10625 b8f1000f  ...!....@..%....
 22e0 02d02046 00f0acfc 012d12d0 089b012b  .. F.....-.....+
 22f0 04d0022b 08d1bdf8 3c3001e0 9df83d30  ...+....<0....=0
 2300 b2681433 134454e6 3c4840f2 04410022  .h.3.DT.<H@..A."
 2310 f5e6b368 01334ce6 002068e0 6068fef7  ...h.3L.. h.`h..
 2320 c5fd0028 3ff435af 0d98fef7 f7fd0546  ...(?.5........F
 2330 029080b1 42680d9b 9a427ff4 2aaf2061  ....Bh...B..*. a
 2340 04212046 fff753fb 00283ff4 22af2b48  .! F..S..(?.".+H
 2350 40f29121 dbe702a8 00f088fc ddf80890  @..!............
 2360 b9f1000f 32d00d9b c9f80430 2946ff20  ....2......0)F. 
 2370 fef70afd 029bc9f8 08000421 23612046  ...........!#a F
 2380 fff72afb 0298fef7 f5fd1a4a 029b1168  ..*........J...h
 2390 5b688b42 24bf0133 1360fae6 fef7acfd  [h.B$..3.`......
 23a0 019040b1 01982146 fff7ccf9 00283ff4  ..@...!F.....(?.
 23b0 f4ae0546 0be001a9 0c98fff7 d4fd0221  ...F...........!
 23c0 05460198 fff708fb 0db9ebe7 0525b8f1  .F...........%..
 23d0 000f89d0 2046fef7 95fe85e7 054683e7  .... F.......F..
 23e0 41464846 fef7d0fc a846a060 58e710b0  AFHF.....F.`X...
 23f0 bde8f087 a00c0020 fe050020 ea620000  ....... ... .b..
 2400 f0b50024 9fb0754b 1b681e59 1d19002e  ...$..uK.h.Y....
 2410 00f0db80 33687068 0293fef7 4ffd0028  ....3hph....O..(
 2420 00f0bf80 7068fef7 3bfd0028 43d03046  ....ph..;..(C.0F
 2430 fff708f9 00283ed0 3369002b 3bd06849  .....(>.3i.+;.hI
 2440 16a801f0 a4fa16a8 01f0a9fa 16ab03eb  ................
 2450 000e7768 00200246 01463b0f 02d10729  ..wh. .F.F;....)
 2460 03d103e0 092b03d8 00e030b1 303300e0  .....+....0.03..
 2470 57330ef8 02300120 01320131 08294fea  W3...0. .2.1.)O.
 2480 0717ead1 00230ef8 023016a8 11a9fff7  .....#...0......
 2490 43fd48b1 0b280bd1 06e01199 0022fff7  C.H..(......."..
 24a0 99f90028 40f09780 30690028 f5d102e0  ...(@...0i.(....
 24b0 002840f0 90803046 0421fff7 98fa10b1  .(@...0F.!......
 24c0 01273775 5de03046 0821fff7 90fa18b1  .'7u].0F.!......
 24d0 01233375 022754e0 3046fff7 b3f80746  .#3u.'T.0F.....F
 24e0 50b13046 fef7e6fe 327d002a 43d13d48  P.0F....2}.*C.=H
 24f0 cc211346 02f0aafb 73682bb9 30468021  .!.F....sh+.0F.!
 2500 fff775fa 60b910e0 08a83146 fff7b4f8  ..u.`.....1F....
 2510 08b10628 34d10a9b 002befd1 042730e0  ...(4....+...'0.
 2520 08a83146 fff7a8f8 48bb7068 fef7befc  ..1F....H.ph....
 2530 08b90746 25e03769 384607b3 fef702fd  ...F%.7i8F......
 2540 b8b9b868 0df10701 03aafef7 2dfc9df8  ...h........-...
 2550 07000399 11aa00f0 96fb30b9 16a83946  ..........0...9F
 2560 00f038fc 08b9199f e6e70128 05d00628  ..8........(...(
 2570 05d10727 05e00327 03e00627 01e00027  ...'...'...'...'
 2580 48bb04a8 3146fff7 77f808b1 062822d1  H...1F..w....(".
 2590 cfb104a8 02a9fff7 44f8e0b9 2b680293  ........D...+h..
 25a0 11e07068 fef78efc 68b17068 fef7d4fc  ..ph....h.ph....
 25b0 30b90ca8 314600f0 0dfc20b1 062802d0  0...1F.... ..(..
 25c0 304600f0 4dfc029e 21e70434 b4f5806f  0F..M...!..4...o
 25d0 7ff419af 30461fb0 f0bd00bf a40c0020  ....0F......... 
 25e0 f9620000 ea620000 2de9f041 8ab00446  .b...b..-..A...F
 25f0 fff7fafa 002840f0 b2805a4f 5a4b3880  .....(@...ZOZK8.
 2600 1c60251d 04f54168 2b68e3b1 454576d0  .`%...Ah+h..EEv.
 2610 287955f8 041c04aa 182301f0 63f80028  (yU......#..c..(
 2620 6fd104a8 00f07afa 58b104a8 00f09dfa  o.....z.X.......
 2630 38b19df8 2730ff2b 68d14c4b 1b78ff2b  8...'0.+h.LK.x.+
 2640 64d00c35 e0e7494b 1a78ff2a 1e4642d1  d..5..IK.x.*.FB.
 2650 02a80df1 0a0100f0 b1fa0446 b8bb0546  ...........F...F
 2660 434b1b68 5c59ecb1 03aaa068 d4f80080  CK.h\Y.....h....
 2670 0df10701 fef798fb 9df80720 bdf80a30  ........... ...0
 2680 9a420dd1 6068fef7 1dfc28b1 204600f0  .B..`h....(. F..
 2690 e7fb0446 20b11ae0 20461021 fff79cf9  ...F ... F.!....
 26a0 4446e0e7 0435b5f5 806fd9d1 bdf80800  DF...5...o......
 26b0 fff776fc 044650b9 9df80a00 0121fef7  ..v..FP......!..
 26c0 79fb0446 18b9bdf8 0a303370 03e0062c  y..F.....03p...,
 26d0 08bf0124 16e0fff7 a5f90446 90b9fff7  ...$.......F....
 26e0 89f90446 70b9fff7 6bfa0446 50b9fff7  ...Fp...k..FP...
 26f0 87fe3888 fff734fa 044618b9 04e00424  ..8...4..F.....$
 2700 00e00224 fff770fa 204628e0 194b1e78  ...$..p. F(..K.x
 2710 701cc0b2 fff70cfa 04460028 f2d1164b  p........F.(...K
 2720 55f8040c 19683201 8b188850 2a685a60  U....h2....P*hZ`
 2730 2a79da73 9df82520 9a739df8 27209a81  *y.s..% .s..' ..
 2740 9df82720 ff2a04d1 17229a60 074b1e70  ..' .*...".`.K.p
 2750 77e71822 9a603046 fff722fc 71e70ab0  w..".`0F..".q...
 2760 bde8f081 fe050020 040b0020 a40a0020  ....... ... ... 
 2770 a40c0020 240b0020 400b0020 2de9f04f  ... $.. @.. -..O
 2780 037a9db0 93469a07 80460491 40f1bc81  .z...F...F..@...
 2790 bbf1000f 01d10020 b9e10da8 d8f80010  ....... ........
 27a0 fdf7b4ff 002840f0 b28198f8 08305b07  .....(@......0[.
 27b0 63d50d9b 1b6ac8f8 04305ee0 0ea8fdf7  c....j...0^.....
 27c0 a5ff8246 002840f0 a1810e9c 039a236a  ...F.(@.......#j
 27d0 9a426cd1 11a800f0 49fa119b 002b61d0  .Bl.....I....+a.
 27e0 a14aa568 13681793 591c6b68 adf868a0  .J.h.h..Y.kh..h.
 27f0 18932b69 1160002b 52d14ff0 ff3317a8  ..+i.`.+R.O..3..
 2800 04991993 adf86c70 00f093fb 17a80499  ......lp........
 2810 10aa12ab 00f045fa 06460028 45d1ddf8  ......E..F.(E...
 2820 4490179b c9f80430 12999df8 4000fef7  D......0....@...
 2830 abfac9f8 08001198 fef79cfb 119b2b61  ..............+a
 2840 ff203146 d5f80890 fef79efa 814502d0  . 1F.........E..
 2850 2846fff7 3df8216a 39442162 20460139  (F..=.!j9D!b F.9
 2860 0022fdf7 cbff049b 3b440493 d8f80430  ."......;D.....0
 2870 c7eb0b0b 1f44c8f8 0470bbf1 000f8add  .....D...p......
 2880 7a4b1b88 98e80600 9b45d4bf 1ffa8bf7  zK.......E......
 2890 1f469f42 039291d9 75484ff4 95710fe1  .F.B....uHO..q..
 28a0 5b68ace7 4ff0050a 30e18246 2ee1039a  [h..O...0..F....
 28b0 0f9007eb 02099945 86bfc3eb 09030893  .......E........
 28c0 cdf820a0 0f9b4bb9 0e9809f1 ff310faa  .. ...K......1..
 28d0 fdf794ff 82460028 40f01881 0f99039b  .....F.(@.......
 28e0 ca699a42 38bf9c1a 0b8b34bf a4b20024  .i.B8.....4....$
 28f0 1e1b1344 4b4518bf c3eb0903 b6b218bf  ...DKE..........
 2900 f6185c4b 1b680a93 039ba2eb 030202eb  ..\K.h..........
 2910 04030693 8b680593 17a81946 18bfb6b2  .....h.....F....
 2920 00f058fa 82460028 40f0f080 bdf86c50  ..X..F.(@.....lP
 2930 ac4205d9 4e487021 52461346 02f086f9  .B..NHp!RF.F....
 2940 a319ab42 069a049b 13440793 189bdcbf  ...B.....D......
 2950 2d1bad1b 03f10103 ccbf0546 adb21893  -..........F....
 2960 33192b44 17a812a9 adf86c30 00f0c4f9  3.+D......l0....
 2970 059b0df1 32019868 10aafef7 15fa109b  ....2..h........
 2980 9df832a0 099312a8 00f0b4fa adf84400  ..2...........D.
 2990 74b111ab 0093099b 514603f1 14022346  t.......QF....#F
 29a0 00f084fa a0bb04f1 140c1ffa 8cfc01e0  ................
 29b0 4ff0140c bdf84400 0799cdf8 2cc03246  O.....D.....,.2F
 29c0 02f060fd ddf82cc0 adf84400 b4441ffa  ..`...,...D..D..
 29d0 8cfc85b1 11ab0093 099bcdf8 24c06344  ............$.cD
 29e0 1a465146 2b4600f0 61fa88b9 ddf824c0  .FQF+F..a.....$.
 29f0 ac441ffa 8cfcbdf8 58301433 9c4502d0  .D......X0.3.E..
 2a00 1b484621 5ce0bdf8 4430adf8 5a3002e0  .HF!\...D0..Z0..
 2a10 82460028 7ad1bdf8 58001430 80b20df1  .F.(z...X..0....
 2a20 330111aa fff73ef8 82460028 6ed19df8  3.....>..F.(n...
 2a30 33001199 12aa1423 fef756f9 82460028  3......#..V..F.(
 2a40 64d1ccb1 1099119b 9df83200 9df83320  d.........2...3 
 2a50 00941431 1433fef7 71f98246 002855d1  ...1.3..q..F.(U.
 2a60 1434a4b2 09e000bf a00c0020 600b0020  .4......... `.. 
 2a70 06630000 ac0c0020 14241199 9df83300  .c..... .$....3.
 2a80 079a2144 3346fef7 2ff98246 00283dd1  ..!D3F../..F.(=.
 2a90 3444a4b2 6db11099 119b9df8 32009df8  4D..m.......2...
 2aa0 33200095 21442344 fef748f9 d8b92c44  3 ..!D#D..H...,D
 2ab0 a4b2bdf8 6c301433 9c4203d0 1548bf21  ....l0.3.B...H.!
 2ac0 00223ae7 9df83300 1199fef7 5df9059b  .":...3.....]...
 2ad0 0a9a9860 104b1b68 9a42c6eb 090904d0  ...`.K.h.B......
 2ae0 cdf83ca0 06e08246 10e00f9b 5b685b68  ..<....F....[h[h
 2af0 1b680f93 069b002b 7ff4e4ae 0e9a0899  .h.....+........
 2b00 136a0b44 1362aee6 0c2000e0 50461db0  .j.D.b... ..PF..
 2b10 bde8f08f 06630000 ac0c0020 0268094b  .....c..... .h.K
 2b20 9a420dd1 4268084b 9a4209d1 8268074b  .B..Bh.K.B...h.K
 2b30 9a4205d1 c3680648 1b1a5842 58417047  .B...h.H..XBXApG
 2b40 00207047 e2318ab9 8c42b07f 5382e0ac  . pG.1...B..S...
 2b50 8efc85b1 10b50446 fff7e0ff 20b1e07d  .......F.... ..}
 2b60 a0f1ff03 58425841 10bd007d 431e5842  ....XBXA...}C.XB
 2b70 58417047 38b51822 0c460546 08460021  XApG8..".F.F.F.!
 2b80 00f0f0fe 074b0848 0849094a 84e80f00  .....K.H.I.J....
 2b90 6b682361 01232375 ab7b6375 ab89e375  kh#a.##u.{cu...u
 2ba0 38bd00bf 8efc85b1 e2318ab9 8c42b07f  8........1...B..
 2bb0 5382e0ac 42688068 101a7047 2de9f043  S...Bh.h..pG-..C
 2bc0 164b1e78 164b1b68 00221033 b24221da  .K.x.K.h.".3.B!.
 2bd0 571ca3f1 100c1d46 3c46b442 17daae46  W......F<F.B...F
 2be0 33f8048c bef80c90 c14505f1 10050cd1  3........E......
 2bf0 dcf80850 def80830 9d4235bf 04800280  ...P...0.B5.....
 2c00 0a800c80 0020bde8 f0830134 e5e71033  ..... .....4...3
 2c10 3a46dbe7 0620bde8 f08300bf 240b0020  :F... ......$.. 
 2c20 400b0020 10b50548 02f0b6f8 044618b1  @.. ...H.....F..
 2c30 00210c22 00f096fe 204610bd 440b0020  .!.".... F..D.. 
 2c40 10b50446 4068fef7 3df90246 20b90548  ...F@h..=..F ..H
 2c50 2b211346 01f0faff 21460348 bde81040  +!.F....!F.H...@
 2c60 02f0aeb8 13630000 440b0020 13b50446  .....c..D.. ...F
 2c70 fff7d8ff 01a92060 fef7f4fe 0028f7d1  ...... `.....(..
 2c80 019802b0 10bd10b5 14231446 fef706f8  .........#.F....
 2c90 30b92068 fef716f9 00280cbf 09200020  0. h.....(... . 
 2ca0 10bdf7b5 0446008a 14300f46 154680b2  .....F...0.F.F..
 2cb0 0df10301 01aa1e46 fef7f4fe c8b99df8  .......F........
 2cc0 03000199 22461423 fef70ef8 88b9238a  ...."F.#......#.
 2cd0 33b99df8 03302b70 019b3360 002008e0  3....0+p..3`. ..
 2ce0 01999df8 03001431 3a46fdf7 fdff0028  .......1:F.....(
 2cf0 efd003b0 f0bd0000 826808b5 22b90b48  .........h.."..H
 2d00 d7211346 01f0a2ff 03685b68 0b604368  .!.F.....h[h.`Ch
 2d10 8b815368 4b60c368 13b94ff0 ff3300e0  ..ShK`.h..O..3..
 2d20 5b688b60 038a0b82 08bd00bf 13630000  [h.`.........c..
 2d30 30b50446 89b04868 0d46fef7 c3f80246  0..F..Hh.F.....F
 2d40 28b91248 4ff4a971 134601f0 7fff2846  (..HO..q.F....(F
 2d50 fef7f8f8 10b12560 062015e0 a8680df1  ......%`. ...h..
 2d60 070102aa fef720f8 9df80700 029903aa  ...... .........
 2d70 fff789ff 40b9bdf8 1c30bdf8 18202560  ....@....0... %`
 2d80 6260a060 e0602382 09b030bd 13630000  b`.`.`#...0..c..
 2d90 73b51e46 03680c46 15469868 0df10301  s..F.h.F.F.h....
 2da0 01aafef7 01f80199 9df80300 14312144  .............1!D
 2db0 32462b46 0191fdf7 71ff02b0 70bd10b5  2F+F....q...p...
 2dc0 00218468 ff20fdf7 dfff231a 58425841  .!.h. ....#.XBXA
 2dd0 10bd0000 30b50546 89b04868 0c46fef7  ....0..F..Hh.F..
 2de0 71f80246 28b91d48 4ff4c471 134601f0  q..F(..HO..q.F..
 2df0 2dff2046 fff7e3ff 20b10020 2c60a860  -. F.... .. ,`.`
 2e00 e86028e0 a0680df1 070102aa fdf7ccff  .`(..h..........
 2e10 9df80700 029903aa fff735ff d8b9bdf8  ..........5.....
 2e20 1c30bdf8 18202c60 a860e860 2b826a60  .0... ,`.`.`+.j`
 2e30 0498fef7 61f8b0fa 80f4a860 0598431c  ....a......`..C.
 2e40 4fea5414 01d12046 05e0fef7 67f8e860  O.T... F....g..`
 2e50 0028f8d1 012009b0 30bd00bf 13630000  .(... ..0....c..
 2e60 30b587b0 0546fef7 6df838b1 2846fef7  0....F..m.8.(F..
 2e70 b5f82846 fff7e4fe 012014e0 01a82946  ..(F..... ....)F
 2e80 fff7a8ff 01280446 0cd8039b 23b11a69  .....(.F....#..i
 2e90 aa4204bf 049a1a61 2846fef7 9ff82846  .B.....a(F....(F
 2ea0 fff7cefe 204607b0 30bd0000 2de9f041  .... F..0...-..A
 2eb0 06468846 17461c46 acb1b4f5 807f2546  .F.F.F.F......%F
 2ec0 28bf4ff4 80754046 3946094a 2b46fdf7  (.O..u@F9F.J+F..
 2ed0 e5fe58b9 30460649 2a4602f0 d3fa2f44  ..X.0F.I*F..../D
 2ee0 0646641b e8e7069b 20461e80 bde8f081  .Fd..... F......
 2ef0 9c0b0020 01461222 002002f0 c3baf0b5  ... .F.". ......
 2f00 85b00546 0f461646 fff7f4ff 04ac2b8a  ...F.F.F......+.
 2f10 24f8020d 39460094 06f11402 fff7c6ff  $...9F..........
 2f20 28b9bdf8 0e006b8a 181a18bf 012005b0  (.....k...... ..
 2f30 f0bd38b5 04460d46 fff7dcff 2946228a  ..8..F.F....)F".
 2f40 02f0a0fa 608238bd 7fb50446 0e461546  ....`.8....F.F.F
 2f50 21461222 002002f0 95fa04aa 637c22f8  !F.". ......c|".
 2f60 020d3146 009205f1 1402fff7 9fff28b9  ..1F..........(.
 2f70 bdf80e00 638a181a 18bf0120 04b070bd  ....c...... ..p.
 2f80 38b50446 0d461222 21460020 02f07afa  8..F.F."!F. ..z.
 2f90 2946627c 02f076fa 608238bd f0b585b0  )Fb|..v.`.8.....
 2fa0 0d461446 0df10b01 03aa0646 0068fdf7  .F.F.......F.h..
 2fb0 fbfe0b4b 9df80b00 1b680399 03eb0413  ...K.....h......
 2fc0 22469f68 00953b46 fdf7b8fe 054620b9  "F.h..;F.....F .
 2fd0 20463946 fdf7d8fe 30602846 05b0f0bd   F9F....0`(F....
 2fe0 400b0020 f0b50446 87b00e46 17460025  @.. ...F...F.F.%
 2ff0 b5421ad2 2cb90e48 84212246 234601f0  .B..,..H.!"F#F..
 3000 25fe01a8 2146fff7 e5fe78b9 bdf81410  %...!F....x.....
 3010 143104f1 080089b2 3a46fff7 bfff28b9  .1......:F....(.
 3020 bdf81430 049c1d44 e2e70020 07b0f0bd  ...0...D... ....
 3030 20630000 2de9f04f 95b08146 16461d46   c..-..O...F.F.F
 3040 ddf878b0 002900f0 9d800021 14220aa8  ..x..).....!."..
 3050 00f088fc 304601f0 45fe8046 002800f0  ....0F..E..F.(..
 3060 8a800aa8 00211422 00f07cfc 4a4b1b68  .....!."..|.JK.h
 3070 01933746 ca46002f 3bd00fa8 5146fff7  ..7F.F./;...QF..
 3080 a9fe0446 002877d1 bdf84c30 ff1a0f9b  ...F.(w...L0....
 3090 0df10f01 986804aa fdf786fe 04999df8  .....h..........
 30a0 0f00bdf8 4c301431 08eb0702 0491fdf7  ....L0.1........
 30b0 f5fd0446 00285fd1 ca450ed0 bbf1000f  ...F.(_..E......
 30c0 07d0dbf8 00305345 04bfdaf8 0030cbf8  .....0SE.....0..
 30d0 00305046 fff7c4fe 08e00fac 0fcc0df1  .0PF............
 30e0 280eaee8 0f002368 cef80030 ddf848a0  (.....#h...0..H.
 30f0 c1e70a9c 2cb92948 e7213a46 3b4601f0  ....,.)H.!:F;F..
 3100 a5fd05a8 39461422 00f02cfc 63680593  ....9F."..,.ch..
 3110 0b9b0133 adf82030 0c9b5b68 0693baf1  ...3.. 0..[h....
 3120 000f02d1 4ff0ff33 01e0daf8 04300793  ....O..3.....0..
 3130 05a84146 adf82460 fff7fbfe 019b03eb  ..AF..$`........
 3140 051a2846 daf80870 05aa3946 1423fdf7  ..(F...p..9F.#..
 3150 cbfd0446 80b92846 07f11401 42463346  ...F..(F....BF3F
 3160 fdf7c2fd 044638b9 28463946 fdf70cfe  .....F8.(F9F....
 3170 c9f80800 00e00524 404601f0 bffd052c  .......$@F.....,
 3180 05d14846 31462a46 fff72cff 04462046  ..HF1F*F..,..F F
 3190 15b0bde8 f08f00bf 400b0020 20630000  ........@..  c..
 31a0 2de9f04f 7d4b7e4f 1e787e4b 97f80090  -..O}K~O.x~K....
 31b0 d3f80080 91b04246 04900123 00240297  ......BF...#.$..
 31c0 b34212da 4b450dd0 08eb0415 50696968  .B..KE......Piih
 31d0 884206d8 4c4504d0 917fa87b 091a0906  .B..LE.....{....
 31e0 00d5dcb2 01331032 eae74c45 03d16e48  .....3.2..LE..nH
 31f0 71210022 3de008eb 041a4846 9af80c10  q!."=.....HF....
 3200 fdf702fe 002840f0 c5808346 674b1b68  .....(@....FgK.h
 3210 53f80b50 08e02f69 00252b46 2e46002f  S..P../i.%+F.F./
 3220 3ed1002e 7ed1089d 002d00f0 87802b68  >...~....-....+h
 3230 68680893 fdf742fe 0028f4d0 a8680df1  hh....B..(...h..
 3240 1e0109aa fdf7b0fd 9df81e30 a34213d0  ...........0.B..
 3250 6868fdf7 2bfe0028 e5d0029b 68681b78  hh..+..(....hh.x
 3260 0393fdf7 23fe0246 0028d4d1 4e4840f2  ....#..F.(..NH@.
 3270 51111346 01f0eafc 029b0ba8 29461e78  Q..F........)F.x
 3280 fef7faf9 002840f0 85809df8 381005f1  .....(@.....8...
 3290 08001431 3246fff7 81fe0028 d8d079e0  ...12F.....(..y.
 32a0 0ba83946 0593fff7 95fd0028 72d10aaa  ..9F.......(r...
 32b0 b8680df1 1f01fdf7 77fd9df8 1f20059b  .h......w.... ..
 32c0 a2421cd1 3a49bdf8 3c200988 1a44002e  .B..:I..< ...D..
 32d0 08bf3e46 8a4203d8 be4218bf 01251ee0  ..>F.B...B...%..
 32e0 08aa0092 30461a46 2946039b fff7a2fe  ....0F.F)F......
 32f0 00284fd1 bdf83c20 3e460546 0fe06eb1  .(O...< >F.F..n.
 3300 08aa0092 30461a46 2946039b fff792fe  ....0F.F)F......
 3310 00283fd1 05460246 064600e0 1a460e9f  .(?..F.F.F...F..
 3320 13467ce7 08aa0092 30461a46 2946039b  .F|.....0F.F)F..
 3330 fff780fe 00283ff4 76af2be0 0bf1040b  .....(?.v.+.....
 3340 bbf5806f 7ff462af 08eb0918 daf80830  ...o..b........0
 3350 d8f80820 9a4204d9 13484ff4 fe712a46  ... .B...HO..q*F
 3360 87e79af8 0e300133 8af80e30 20460121  .....0.3...0 F.!
 3370 fdf720fd 70b9049b 1bb1029b 049a1b78  .. .p..........x
 3380 1370029b 1c70fdf7 15fa18b9 094a1368  .p...p.......J.h
 3390 01331360 11b0bde8 f08f00bf 240b0020  .3.`........$.. 
 33a0 a40a0020 400b0020 20630000 a40c0020  ... @..  c..... 
 33b0 600b0020 ac0c0020 f8b50746 0e460025  `.. ... ...F.F.%
 33c0 0b4b1b78 9d420fda 3046fff7 e9fe0446  .K.x.B..0F.....F
 33d0 60b9084b 30781b68 03eb0010 fff7eafb  `..K0x.h........
 33e0 b84203d2 0135ebe7 0820f8bd 2046f8bd  .B...5... .. F..
 33f0 240b0020 400b0020 0649074a 074b9b1a  $.. @.. .I.J.K..
 3400 03dd043b c858d050 fbdc0548 80470548  ...;.X.P...H.G.H
 3410 00470000 84670000 d8000020 cc050020  .G...g..... ... 
 3420 3d340000 d9000000 fee7fee7 fee7fee7  =4..............
 3430 fee7fee7 fee7fee7 fee700bf 274b1b78  ............'K.x
 3440 062b0ed1 264b1b68 19070ad1 254b1b68  .+..&K.h....%K.h
 3450 03f0f003 302b04d1 234b1b68 13f0f00f  ....0+..#K.h....
 3460 2ad01e4b 1b78062b 0ed11d4b 1b681a07  *..K.x.+...K.h..
 3470 0ad11c4b 1b6803f0 f003302b 04d11a4b  ...K.h....0+...K
 3480 1b6813f0 f00f1dd0 144b1b78 062b0ed1  .h.......K.x.+..
 3490 134b1b68 1b070ad1 124b1b68 03f0f003  .K.h.....K.h....
 34a0 302b04d1 104b1b68 13f0f003 0ed00f4b  0+...K.h.......K
 34b0 0f4a1a60 00f0d4bd 0e4ad368 23f08073  .J.`.....J.h#..s
 34c0 d360cee7 0c4b0322 1a60dde7 4ff08042  .`...K.".`..O..B
 34d0 c2f80c31 c2f81031 e9e700bf e00f00f0  ...1...1........
 34e0 e40f00f0 e80f00f0 ec0f00f0 f4000020  ............... 
 34f0 0090d003 f0ed00e0 a0050040 024b1860  ...........@.K.`
 3500 024b1960 704700bf 00060020 04060020  .K.`pG..... ... 
 3510 1c4b2de9 f3411546 1a680f46 6ab31a4b  .K-..A.F.h.Fj..K
 3520 1b689842 29da0c23 58430024 0c601618  .h.B)..#XC.$.`..
 3530 105c02f0 05fb8046 d8f80c30 9c421ada  .\.....F...0.B..
 3540 d8f80030 6946db68 204601aa 9847009b  ...0iF.h F...G..
 3550 71688b42 0dd3b268 0a449342 09d22db1  qh.B...h.D.B..-.
 3560 32786b60 019b2a70 ab600c35 3b680133  2xk`..*p.`.5;h.3
 3570 3b600134 e0e70020 01e04ff0 ff3002b0  ;`.4... ..O..0..
 3580 bde8f081 00060020 04060020 2de9f04f  ....... ... -..O
 3590 424b1746 1a6885b0 0c46002a 79d0404b  BK.F.h...F.*y.@K
 35a0 1b689842 75da0c23 58430025 d1f800b0  .h.Bu..#XC.%....
 35b0 0d6002eb 0008105c 02f0c2fa 4ff0ff39  .`.....\....O..9
 35c0 82464e46 daf80c30 9d421ada daf80030  .FNF...0.B.....0
 35d0 02a903aa db682846 9847029a d8f80410  .....h(F.G......
 35e0 8a420cd3 d8f80830 0b449a42 07d22368  .B.....0.D.B..#h
 35f0 0133b6f1 ff3f08bf 2e462360 a9460135  .3...?...F#`.F.5
 3600 e0e72368 5b454ff0 0003c8bf d8f80820  ..#h[EO........ 
 3610 2360d8bf 9b464ff0 010c4ff0 0005c8bf  #`...FO...O.....
 3620 b2fbfbfb b1452ddb daf80030 cdf804c0  .....E-....0....
 3630 db6803aa 304602a9 9847ddf8 04c0039a  .h..0F...G......
 3640 0c23bcf1 000f0bd0 6b43f818 98f80010  .#......kC......
 3650 01720299 f9502368 42600133 236004e0  .r...P#hB`.3#`..
 3660 03fb0573 59680a44 5a600c23 03fb0573  ...sYh.DZ`.#...s
 3670 01365b68 5b4526bf 01354ff0 010c4ff0  .6[h[E&..5O...O.
 3680 000ccfe7 23680c22 02fb0377 00207860  ....#h."...w. x`
 3690 01e04ff0 ff3005b0 bde8f08f 00060020  ..O..0......... 
 36a0 04060020 42689142 07d38368 d0188142  ... Bh.B...h...B
 36b0 4ff0ff30 98bf0020 70474ff0 ff307047  O..0... pGO..0pG
 36c0 38b50024 2546e0b2 02f03afa 40b10368  8..$%F....:.@..h
 36d0 1b699847 002818bf 4ff0ff35 0134f2e7  .i.G.(..O..5.4..
 36e0 284638bd 2de9f041 0c461746 1d4602f0  (F8.-..A.F.F.F..
 36f0 27fa0646 80b12146 fff7d4ff 60b93046  '..F..!F....`.0F
 3700 6119fff7 cfff38b9 33682046 39462a46  a.....8.3h F9F*F
 3710 1b68bde8 f0411847 4ff0ff30 bde8f081  .h...A.GO..0....
 3720 2de9f041 0c461746 1d4602f0 09fa0646  -..A.F.F.F.....F
 3730 80b12146 fff7b6ff 60b93046 6119fff7  ..!F....`.0Fa...
 3740 b1ff38b9 33682046 39462a46 5b68bde8  ..8.3h F9F*F[h..
 3750 f0411847 4ff0ff30 bde8f081 2de9f341  .A.GO..0....-..A
 3760 88461446 02f0ecf9 074610b9 4ff0ff35  .F.F.....F..O..5
 3770 2de04146 fff796ff 0028f7d1 44443846  -.AF.....(..DD8F
 3780 2146fff7 8fff0546 0028efd1 4445edd9  !F.....F.(..DE..
 3790 0646fb68 9e421ada 3b683046 db686946  .F.h.B..;h0F.hiF
 37a0 01aa9847 28b10022 0b489c21 134601f0  ...G(..".H.!.F..
 37b0 4dfa9de8 09000344 984506d2 844204d9  M......D.E...B..
 37c0 3b689b68 98470028 d0d10136 e1e72846  ;h.h.G.(...6..(F
 37d0 02b0bde8 f08100bf 2a630000 036883f3  ........*c...h..
 37e0 08884368 184708b5 02f0b5f9 01207047  ..Ch.G....... pG
 37f0 70470000 c3688268 19680129 10b509d1  pG...h.h.h.)....
 3800 59685c18 844205d1 60689a60 01445960  Yh\..B..`h.`.DY`
 3810 d36009e0 01230360 0d4b4361 19690161  .`...#.`.KCa.i.a
 3820 18610369 58610346 11680129 0ed15968  .a.iXa.F.h.)..Yh
 3830 58189042 0ad15068 01445960 50691169  X..B..Ph.DY`Pi.i
 3840 01614861 d1689268 8a60d160 184610bd  .aHa.h.h.`.`.F..
 3850 f8000020 172910b5 04461bd9 01230360  ... .)...F...#.`
 3860 0d4b4160 1b689847 a0b10c4b db681a68  .KA`.h.G...K.h.h
 3870 022a01d0 a342f9d2 9a68a260 e3609c60  .*...B...h.`.`.`
 3880 a3682046 dc60fff7 b5ff054b bde81040  .h F.`.....K...@
 3890 1b681847 10bd00bf 14010020 f8000020  .h.G....... ... 
 38a0 10010020 f8b508b9 0020f8bd 1f4b1f30  ... ..... ...K.0
 38b0 1b6820f0 0f049847 0028f5d0 1c4b1869  .h ....G.(...K.i
 38c0 0368022b 29d04268 a2421ed3 04f12003  .h.+).Bh.B.... .
 38d0 9a420169 456911d3 03198668 121b0127  .B.iEi.....h...'
 38e0 07515a60 002280e8 1400d860 9e60f360  .QZ`.".....`.`.`
 38f0 83601961 5d614b61 2b6103e0 00230360  .`.a]aKa+a...#.`
 3900 29614d61 00f11004 02e00069 d8e70024  )aMa.......i...$
 3910 084b1b68 98472046 f8bd2046 02f02ef9  .K.h.G F.. F....
 3920 431cf4d0 2146fff7 95ffc7e7 14010020  C...!F......... 
 3930 f8000020 10010020 10b50446 60b1074b  ... ... ...F`..K
 3940 1b689847 40b1a4f1 1000fff7 53ff044b  .h.G@.......S..K
 3950 bde81040 1b681847 10bd00bf 14010020  ...@.h.G....... 
 3960 10010020 02440346 934202d0 03f8011b  ... .D.F.B......
 3970 fae77047 10b50246 10f8013b ccb2a342  ..pG...F...;...B
 3980 03d0002b f7d11846 10bd1046 10bd421e  ...+...F...F..B.
 3990 11f8013b 02f8013f 002bf9d1 70470346  ...;...?.+..pG.F
 39a0 1a460133 11780029 fad1101a 704710b5  .F.3.x.)....pG..
 39b0 02449042 08d010f8 014b11f8 013be31a  .D.B.....K...;..
 39c0 03d1002c f5d100e0 00231846 10bd0000  ...,.....#.F....
 39d0 012837b5 144620d1 0d681149 284602f0  .(7..F ..h.I(F..
 39e0 b0fa38b9 08230193 14b12046 0d490be0  ..8..#.... F.I..
 39f0 0c4b0ee0 28460c49 02f0a3fa 68b90823  .K..(F.I....h..#
 3a00 01932cb1 09492046 01aa01f0 95fd05e0  ..,..I F........
 3a10 064b1c60 5c602046 00e00a20 03b030bd  .K.`\` F... ..0.
 3a20 45630000 08060020 3b630000 10060020  Ec..... ;c..... 
 3a30 064b1968 024609b9 5b682bb1 034b03cb  .K.h.F..[h+..K..
 3a40 10605160 00207047 04207047 10060020  .`Q`. pG. pG... 
 3a50 064b1968 024609b9 5b682bb1 034b03cb  .K.h.F..[h+..K..
 3a60 10605160 00207047 04207047 08060020  .`Q`. pG. pG... 
 3a70 1fb50146 0d4b18b9 18605860 0c480ce0  ...F.K...`X`.H..
 3a80 00684968 1a4603c2 18460821 6a460e23  .hIh.F...F.!jF.#
 3a90 01f066fd 20b10648 694601f0 95ff01e0  ..f. ..HiF......
 3aa0 4ff0ff30 05b05df8 04fb00bf 10060020  O..0..]........ 
 3ab0 36630000 1fb50146 0d4b18b9 18605860  6c.....F.K...`X`
 3ac0 0c480ce0 00684968 1a4603c2 18460821  .H...hIh.F...F.!
 3ad0 6a460e23 01f044fd 20b10648 694601f0  jF.#..D. ..HiF..
 3ae0 73ff01e0 4ff0ff30 05b05df8 04fb00bf  s...O..0..].....
 3af0 08060020 40630000 f8b50e46 17460546  ... @c.....F.F.F
 3b00 0024bc42 15da06eb c40316f8 34005968  .$.B........4.Yh
 3b10 2a462023 fff7e6fd 18b92a68 054b9a42  *F #......*h.K.B
 3b20 04d02846 ff212022 fff71cff 01342035  ..(F.! ".....4 5
 3b30 e7e7f8bd 3cb8f396 014801f0 c1bc00bf  ....<....H......
 3b40 18010020 1fb50446 01f028ff 03ab0093  ... ...F..(.....
 3b50 09480021 08222346 01f0c6ff 10b9039b  .H.!."#F........
 3b60 082b06d0 20460021 0822fff7 fbfe0020  .+.. F.!."..... 
 3b70 00e00120 04b010bd 4a630000 08b50146  ... ....Jc.....F
 3b80 08220448 01f0c6ff 002814bf 02200020  .".H.....(... . 
 3b90 08bd00bf 4a630000 014801f0 8fbf00bf  ....Jc...H......
 3ba0 4a630000 10b50446 21460848 082202f0  Jc.....F!F.H."..
 3bb0 83f948b1 06482146 082202f0 7df908b9  ..H..H!F."..}...
 3bc0 012010bd 4ff0ff30 10bd00bf c40c0020  . ..O..0....... 
 3bd0 e40c0020 f7b50f4c 23680646 0d462746  ... ...L#h.F.F'F
 3be0 6bb14ff4 80730093 29786a68 3b683046  k.O..s..)xjh;h0F
 3bf0 00f0c4f9 002814bf 03200020 07e04ff4  .....(... . ..O.
 3c00 807001f0 6ff82060 0028ead1 062003b0  .p..o. `.(... ..
 3c10 f0bd00bf 18060020 08b5074b 0a461968  ....... ...K.F.h
 3c20 0c235843 0b681918 185c4968 fff796fd  .#XC.h...\Ih....
 3c30 003018bf 012008bd 28060020 194b1b68  .0... ..(.. .K.h
 3c40 1b682de9 f0410c25 05fb0037 05fb0135  .h-..A.%...7...5
 3c50 9046bb68 aa689a42 05d20022 1248dc21  .F.h.h.B...".H.!
 3c60 134600f0 f3ff0024 444518d2 c4eb0806  .F.....$DE......
 3c70 b6f5806f 79683878 0c4a28bf 4ff48066  ...oyh8x.J(.O..f
 3c80 21443346 fff72efd 50b96968 2878074a  !D3F....P.ih(x.J
 3c90 21443346 fff744fd 10b93444 e4e70020  !D3F..D...4D... 
 3ca0 bde8f081 28060020 58630000 2c060020  ....(.. Xc..,.. 
 3cb0 2de9f74f 544f7b68 00241b0a 0193a246  -..OTO{h.$.....F
 3cc0 3b689a45 80f09b80 dff844b1 dff844c1  ;h.E......D...D.
 3cd0 dbf80030 dcf80050 d3f804e0 9ef80160  ...0...P.......`
 3ce0 2db14ff0 0009dcf8 00004d46 1de05a7a  -.O.......MF..Zz
 3cf0 93f80880 02eb4201 89004245 06da1868  ......B...BE...h
 3d00 08440132 80680c31 0544f6e7 ccf80050  .D.2.h.1.D.....P
 3d10 e7e71a68 4ff00c0c 0cfb0122 92682a44  ...hO......".h*D
 3d20 824206d8 09f10109 154609eb 0401b142  .B.......F.....B
 3d30 efdb019a 94425bdb 9ef80080 2644a044  .....B[.....&D.D
 3d40 b04503d1 31484ff4 877105e0 587a8045  .E..1HO..q..Xz.E
 3d50 06d12e48 40f20f11 00221346 00f076ff  ...H@....".F..v.
 3d60 864203d1 29484ff4 8871f5e7 3b79abb9  .B..)HO..q..;y..
 3d70 2946fff7 51ff0028 3dd1dbf8 00303046  )F..Q..(=....00F
 3d80 597a2a46 fff75aff a8bb1f4a 230243f0  Yz*F..Z....J#.C.
 3d90 01031046 5360fff7 f1fe01e0 012b12d1  ...FS`.......+..
 3da0 30462946 fff738ff 28bb4046 31462a46  0F)F..8.(.@F1F*F
 3db0 fff744ff f8b92302 43f00203 12487b60  ..D...#.C....H{`
 3dc0 fff7dcfe 01e0022b 12d14046 2946fff7  .......+..@F)F..
 3dd0 23ff80b9 dbf80030 4146587a 2a46fff7  #......0AFXz*F..
 3de0 2dff40b9 631c1b02 07487b60 fff7c6fe  -.@.c....H{`....
 3df0 aa444c44 64e70548 40f25b11 ace70020  .DLDd..H@.[.... 
 3e00 03b0bde8 f08f00bf 20060020 58630000  ........ .. Xc..
 3e10 28060020 1c060020 f0b5524c 87b02060  (.. ... ..RL.. `
 3e20 51480e46 fff78efe 20bb2268 4f4d5168  QH.F.... ."hOMQh
 3e30 10680b78 03eb4303 9b00c418 c35c8df8  .h.x..C......\..
 3e40 08306368 03934b78 126803eb 43039b00  .0ch..Kx.h..C...
 3e50 d118d35c 8df81030 4b680593 02222846  ...\...0Kh..."(F
 3e60 02a9fff7 49fe424b 2a689a42 1a4606d0  ....I.BK*h.B.F..
 3e70 002309e0 fff71cff 0028d6d0 6fe0ab88  .#.......(..o...
 3e80 29891944 eb680b44 296a384c 91423649  )..D.h.D)j8L.B6I
 3e90 06d1a288 208d1044 e26a0244 934201d3  .... ..D.j.D.B..
 3ea0 0b6000e0 0a600023 68464b60 fff7c0fd  .`...`.#hFK`....
 3eb0 074640b9 6846fff7 75fe421c 04461cd1  .F@.hF..u.B..F..
 3ec0 3846fff7 d5fd6846 fff7c2fd 074640b9  8F....hF.....F@.
 3ed0 6846fff7 67fe431c 04460ed1 3846fff7  hF..g.C..F..8F..
 3ee0 e9fd2b68 013305d1 204b1b6a 013303d1  ..+h.3.. K.j.3..
 3ef0 032034e0 002400e0 012402ab 05eb4410  . 4..$...$....D.
 3f00 03ebc401 fff766fe 58b11848 84f00104  ......f.X..H....
 3f10 02ab00eb 441003eb c401fff7 5bfe0028  ....D.......[..(
 3f20 e6d114b1 012c02d0 07e03560 0ce0fff7  .....,....5`....
 3f30 bffea0b9 0f4b3360 06e00022 0e484ff4  .....K3`...".HO.
 3f40 f3711346 00f082fe 9df80830 3371039b  .q.F.......03q..
 3f50 b360fff7 21fe0020 fff78afd 002007b0  .`..!.. ..... ..
 3f60 f0bd00bf 28060020 20060020 b00c0020  ....(..  .. ... 
 3f70 3cb8f396 d00c0020 58630000 2de9f04f  <...... Xc..-..O
 3f80 9b460369 92469a07 cbb00546 894602d4  .F.i.F.....F.F..
 3f90 4ff0ff34 60e00aa8 00f082f8 0aa80021  O..4`..........!
 3fa0 00f082f8 b5f80880 eb680026 98444645  .........h.&.DFE
 3fb0 15d2549b c6eb0807 9f4228bf 1f464846  ..T......B(..FHF
 3fc0 06eb0a01 5a463b46 fff78cfb 002842d1  ....ZF;F.....(B.
 3fd0 0aa85946 3a4600f0 5dfc3e44 e7e70aa8  ..YF:F..].>D....
 3fe0 02a900f0 5bfc2e89 eb68b5f8 04800024  ....[....h.....$
 3ff0 1e44b044 27464645 17d206eb 0a0b4846  .D.D'FFE......HF
 4000 594601aa 0423fff7 6dfb20bb 9df80430  YF...#..m. ....0
 4010 012b05d1 bdf80630 202bb9d1 0bf10407  .+.....0 +......
 4020 bdf80630 04331e44 e5e72b69 9b0713d5  ...0.3.D..+i....
 4030 002fadd0 48463946 0aaa2023 fff752fb  ./..HF9F.. #..R.
 4040 48b902a8 0aa92022 01f036ff 003018bf  H..... "..6..0..
 4050 01204442 00e00446 20464bb0 bde8f08f  . DB...F FK.....
 4060 074a084b 93421146 02d1074a 93607047  .J.K.B.F...J.`pG
 4070 00228858 98500432 d82afad1 f5e700bf  .".X.P.2.*......
 4080 00000000 00000020 00ed00e0 034b1030  ....... .....K.0
 4090 9b6843f8 2010bff3 5f8f7047 00ed00e0  .hC. ..._.pG....
 40a0 00216c22 fff75ebc 00230360 4360a1b9  .!l"..^..#.`C`..
 40b0 184b8360 184bc360 184b0361 184b4361  .K.`.K.`.K.a.KCa
 40c0 184b8361 184bc361 184b0362 03f17453  .K.a.K.a.K.b..tS
 40d0 a3f52303 a3f69243 18e0154b 8360154b  ..#....C...K.`.K
 40e0 c36003f1 794303f5 740303f5 01630361  .`..yC..t....c.a
 40f0 114b4361 114b8361 03f1d143 03f5c013  .KCa.K.a...C....
 4100 03f51e63 c3610e4b 03620e4b 43628166  ...c.a.K.b.KCb.f
 4110 704700bf 67e6096a 85ae67bb 72f36e3c  pG..g..j..g.r.n<
 4120 3af54fa5 7f520e51 8c68059b abd9831f  :.O..R.Q.h......
 4130 d89e05c1 07d57c36 39590ef7 310bc0ff  ......|69Y..1...
 4140 a78ff964 a44ffabe 2de9f04f cfb0031d  ...d.O..-..O....
 4150 05931a46 002306ac 52f8040f 44f82300  ...F.#..R...D.#.
 4160 0133082b f7d10846 002211f8 2240c378  .3.+...F.".."@.x
 4170 43ea0463 447843ea 04438478 43ea0423  C..cDxC..C.xC..#
 4180 0eac0430 44f82230 0132102a edd107a8  ...0D."0.2.*....
 4190 90e80302 ddf83480 0a9d0b9a 0c9b069c  ......4.........
 41a0 dff87ce2 0df13c0c 5cf8047c 5ef8046c  ..|...<.\..|^..l
 41b0 4feab51a 8aeaf52a 8aea756a 3e445644  O......*..uj>DVD
 41c0 83ea020a 0aea050a 8aea030a 56444644  ............VDFD
 41d0 40ea0408 00ea0407 08ea0108 48ea0708  @...........H...
 41e0 4feab407 87ea7437 87eab457 b844b044  O.....t7...W.D.D
 41f0 b144def8 0070dcf8 006082ea 050a3744  .D...p...`....7D
 4200 09ea0a0a 8aea020a 3b4403eb 0a074fea  ........;D....O.
 4210 b91383ea f92383ea 7963fe18 48ea0403  .....#..yc..H...
 4220 06eb010a 034008ea 04010b43 4feab801  .....@.....CO...
 4230 81ea7831 81eab851 0b443344 dcf80410  ..x1...Q.D3D....
 4240 def80460 89ea0507 0e440aea 07076f40  ...`.....D....o@
 4250 3244d619 4feaba12 82eafa22 82ea7a62  2D..O......"..zb
 4260 b11843ea 08020f18 224003ea 08000243  ..C....."@.....C
 4270 4feab300 80ea7330 80eab350 02440a44  O.....s0...P.D.D
 4280 def80800 dcf80810 8aea0906 01443e40  .............D>@
 4290 86ea0906 0d443544 4feab716 86eaf726  .....D5DO......&
 42a0 86ea7766 a91942ea 030505ea 080502ea  ..wf..B.........
 42b0 03062e43 4feab205 85ea7235 85eab250  ...CO.....r5...P
 42c0 35186e18 01eb040b dcf80c00 def80c10  5.n.............
 42d0 87ea0a04 08440bea 040484ea 0a048144  .....D.........D
 42e0 09eb0400 4feabb19 89eafb29 89ea7b69  ....O......)..{i
 42f0 00eb0901 46ea0209 06ea0200 09ea0309  ....F...........
 4300 49ea0009 4feab600 80ea7630 80eab650  I...O.....v0...P
 4310 81448944 8844dcf8 1000def8 10108bea  .D.D.D..........
 4320 07040844 08ea0404 4feab811 7c408244  ...D....O...|@.D
 4330 81eaf821 0aeb0400 81ea7861 00eb010a  ...!......xa....
 4340 49ea0601 09ea0600 11400143 4feab900  I........@.CO...
 4350 80ea7930 80eab950 0144dcf8 1440def8  ..y0...P.D...@..
 4360 14005344 88ea0b05 04441d40 4feab310  ..SD.....D.@O...
 4370 85ea0b05 274480ea f3205144 7c1980ea  ....'D... QD|...
 4380 73602718 41ea0900 304001ea 09042043  s`'.A...0@.... C
 4390 4feab104 84ea7134 84eab154 2044dcf8  O.....q4...T D..
 43a0 1850def8 18403844 3a4483ea 08072544  .P...@8D:D....%D
 43b0 17404fea b214ab44 87ea0807 84eaf224  .@O....D.......$
 43c0 0beb0705 84ea7264 05eb040b 40ea0104  ......rd....@...
 43d0 0beb0605 04ea0904 00ea0106 34434fea  ............4CO.
 43e0 b00686ea 703686ea b0563444 0b4e0ef1  ....p6...V4D.N..
 43f0 200eb645 5c440cf1 200c7ff4 d5ae0027   ..E\D.. ......'
 4400 a6f1440b cdf83480 0a950b92 0c930694  ..D...4.........
 4410 07900891 01900eae 049703e0 e8630000  .............c..
 4420 a8630000 0df1380c 049f706a 5cf82770  .c....8...pj\.'p
 4430 d6f804e0 0744b06b 4fea704c 8ceaf04c  .....D.kO.pL...L
 4440 8cea902c 67444fea fe1c8cea be4c8cea  ...,gDO......L..
 4450 de0c07eb 0c004fea b51c8cea f52c8cea  ......O......,..
 4460 756a83ea 020c0cea 050c8cea 03070aeb  uj..............
 4470 070cdbf8 40700390 67440744 30640198  ....@p..gD.D0d..
 4480 40ea040c b8440cea 010700ea 040cb06a  @....D.........j
 4490 47ea0c0c 4feab407 864487ea 7437f06b  G...O....D..t7.k
 44a0 87eab457 67444fea 704c09eb 080a8cea  ...WgDO.pL......
 44b0 f04cb844 b7688cea 902cf444 4feaf71e  .L.D.h...,.DO...
 44c0 8eeab74e dbf84400 8eead70e e64482ea  ...N..D......D..
 44d0 050c0344 0aea0c0c 73448cea 020c03eb  ...D....sD......
 44e0 0c094fea ba1383ea fa2383ea 7a6309eb  ..O......#..zc..
 44f0 030c0ceb 01030293 019b0398 c6f844e0  ..............D.
 4500 48ea0401 0b4008ea 04011943 4feab803  H....@.....CO...
 4510 83ea7833 83eab853 0b44f16a 39444fea  ..x3...S.D.j9DO.
 4520 70476344 87eaf047 d6f80cc0 87ea9029  pGcD...G.......)
 4530 01eb0907 dbf84800 4feafc11 81eabc41  ......H.O......A
 4540 81eadc01 02440298 39448aea 05070740  .....D..9D.....@
 4550 0a446f40 02eb0709 4feab012 82eaf022  .Do@....O......"
 4560 82ea7062 09eb0207 019ad6f8 1090b164  ..pb...........d
 4570 43ea0800 3a440192 00ea0402 03ea0800  C...:D..........
 4580 10434fea b30282ea 733282ea b3520244  .CO.....s2...R.D
 4590 3a444fea 7e47306b 87eafe47 87ea9e2e  :DO.~G0k...G....
 45a0 4feaf917 604487ea b94787ea d9077044  O...`D...G....pD
 45b0 3844dbf8 4c70f064 3d44029f 87ea0a0e  8D..Lp.d=D......
 45c0 019f07ea 0e0e0544 8eea0a0e ae444fea  .......D.....DO.
 45d0 b71585ea f72585ea 77650eeb 050742ea  .....%..we....B.
 45e0 030507eb 040c05ea 080502ea 03042543  ..............%C
 45f0 4feab204 84ea7234 84eab254 25443d44  O.....r4...T%D=D
 4600 4fea714e 776b7469 8eeaf14e b9448eea  O.qNwkti...N.D..
 4610 9127b944 4feaf417 87eab447 87ead401  .'.DO......G....
 4620 09eb0107 dbf85010 394401eb 0a090199  ......P.9D......
 4630 37658e46 02998eea 010a0cea 0a0a8aea  7e.F............
 4640 010e09eb 0e0a4fea bc1989ea fc2989ea  ......O......)..
 4650 7c690aeb 090145ea 020905ea 020e09ea  |i....E.........
 4660 030949ea 0e094fea b50e8eea 753e8eea  ..I...O.....u>..
 4670 b55ef144 89448844 b16bd6f8 18a00c44  .^.D.D.D.k.....D
 4680 4fea7041 81eaf041 4feafa1e 81ea9020  O.pA...AO...... 
 4690 8eeaba4e 8eeada0e 0444dbf8 54000299  ...N.....D..T...
 46a0 74442044 41180198 74658cea 000e08ea  tD DA...te......
 46b0 0e0e8eea 000e8e44 4feab811 81eaf821  .......DO......!
 46c0 81ea7861 0eeb0100 49ea050e 0eea0201  ..xa....I.......
 46d0 09ea050e 41ea0e0e 4feab901 81ea7931  ....A...O.....y1
 46e0 81eab951 71440144 0344f06b d6f81ce0  ...QqD.D.D.k....
 46f0 82444fea 774080ea f74080ea 9727ba44  .DO.w@...@...'.D
 4700 4feafe17 87eabe47 87eade00 0aeb0007  O......G........
 4710 dbf85800 b76500eb 070a0198 504488ea  ..X..e......PD..
 4720 0c0a03ea 0a0a4fea b3178aea 0c0a87ea  ......O.........
 4730 f3275044 87ea7367 41ea090a 07440aea  .'PD..sgA....D..
 4740 050001ea 090a40ea 0a0a4fea b10080ea  ......@...O.....
 4750 713080ea b1505044 3a443844 4fea744a  q0...PPD:D8DO.tJ
 4760 376a0190 8aeaf44a 03988aea 94244fea  7j.....J.....$O.
 4770 f71a8644 8aeab74a a6448aea d707dbf8  ...D...J.D......
 4780 5c400198 77443c44 83ea080e 644402ea  \@..wD<D....dD..
 4790 0e0e4fea b21c8eea 080e8cea f22c7444  ..O..........,tD
 47a0 8cea726c a44440ea 0104f765 04ea0904  ..rl.D@....e....
 47b0 00ea0107 3c434fea b00787ea 703787ea  ....<CO.....p7..
 47c0 b0570498 08303c44 30286544 64440490  .W...0<D0(eDdD..
 47d0 0bf1200b 06f12006 7ff424ae 0c93019b  .. ... ...$.....
 47e0 0793cdf8 34800a95 0b920694 0891cdf8  ....4...........
 47f0 24900023 059a52f8 041f0592 06aa52f8  $..#..R.......R.
 4800 23200133 0a440599 082b0a60 f2d14fb0  # .3.D...+.`..O.
 4810 bde8f08f 03682de9 f04103f0 3f051344  .....h-..A..?..D
 4820 93420360 3cbf4368 01330646 0f461446  .B.`<.Ch.3.F.F.F
 4830 38bf4360 95b1c5f1 40084245 0ed305f1  8.C`....@.BE....
 4840 28004246 304401f0 45fb3046 06f12801  (.BF0D..E.0F..(.
 4850 fff77afc 4744c8eb 04040025 a046c8eb  ..z.GD.....%.F..
 4860 0401b8f1 3f0f3944 05d93046 fff76cfc  ....?.9D..0F..l.
 4870 a8f14008 f3e724f0 3f0114f0 3f023944  ..@...$.?...?.9D
 4880 06d005f1 28003044 bde8f041 01f022bb  ....(.0D...A..".
 4890 bde8f081 0ab1fff7 bdbf7047 37b50268  ..........pG7..h
 48a0 0d464168 530f43ea c1030446 180ed100  .FAhS.C....F....
 48b0 8df80000 180c02f0 3f028df8 01008df8  ........?.......
 48c0 0330180a 0b0e372a 8df80430 4fea1143  .0....7*...0O..C
 48d0 94bfc2f1 3802c2f1 78028df8 02008df8  ....8...x.......
 48e0 05308df8 07100b0a 20462c49 8df80630  .0...... F,I...0
 48f0 fff7d0ff 20466946 0822fff7 8bffe37a  .... FiF.".....z
 4900 2b706389 6b70a368 1b0aab70 a368eb70  +pc.kp.h...p.h.p
 4910 e37b2b71 e3896b71 e3681b0a ab71e368  .{+q..kq.h...q.h
 4920 eb71e37c 2b72638a 6b722369 1b0aab72  .q.|+rc.kr#i...r
 4930 2369eb72 e37d2b73 e38a6b73 63691b0a  #i.r.}+s..ksci..
 4940 ab736369 eb73e37e 2b74638b 6b74a369  .sci.s.~+tc.kt.i
 4950 1b0aab74 a369eb74 e37f2b75 e38b6b75  ...t.i.t..+u..ku
 4960 e3691b0a ab75e369 eb7594f8 23302b76  .i...u.i.u..#0+v
 4970 638c6b76 236a1b0a ab76236a eb76a36e  c.kv#j...v#j.v.n
 4980 4bb994f8 27302b77 e38c6b77 636a1b0a  K...'0+w..kwcj..
 4990 ab77636a eb7703b0 30bd00bf 61630000  .wcj.w..0...ac..
 49a0 70b5114a 13680133 136000f0 61f80546  p..J.h.3.`..a..F
 49b0 00f092fc 064600f0 ddfb0446 304600f0  .....F.....F0F..
 49c0 01f9a042 28bf2046 0b2805d9 b0f5963f  ...B(. F.(.....?
 49d0 28bf4ff4 963000e0 002001f0 29fa2846  (.O..0... ..).(F
 49e0 00f04cf8 dde700bf 400d0020 1fb5ff22  ..L.....@.. ..."
 49f0 4ff0ff33 8de80c00 064b0293 40230393  O..3.....K..@#..
 4a00 0549064a 06480023 00f0eafb 05b05df8  .I.J.H.#......].
 4a10 04fb00bf 440d0020 a4640000 a1490000  ....D.. .d...I..
 4a20 f00c0020 084b10b5 00241c60 5b60074b  ... .K...$.`[`.K
 4a30 1c605b60 00f052f8 28b10548 71212246  .`[`..R.(..Hq!"F
 4a40 234600f0 03f910bd 480e0020 580e0020  #F......H.. X.. 
 4a50 a9640000 012000f0 45bc0000 08b500f0  .d... ..E.......
 4a60 c1fa024b 4ff08052 5a6008bd 00ed00e0  ...KO..RZ`......
 4a70 eff31080 72b600f0 01007047 00b962b6  ....r.....pG..b.
 4a80 7047eff3 108000f0 01007047 70b5a1f1  pG........pGp...
 4a90 20030646 0c46a1f1 4005a1f1 0c020021   ..F.F..@......!
 4aa0 43f8041f 9342fad1 284600f0 5efc4ff0  C....B..(F..^.O.
 4ab0 807344f8 043c7369 44f8083c b36944f8  .sD..<siD..<.iD.
 4ac0 203c2846 70bd0000 034a5369 43f01003   <(Fp....JSiC...
 4ad0 5361fff7 8bbf00bf 00ed00e0 38b5eff3  Sa..........8...
 4ae0 0583002b 41d103f1 604202f5 61420133  ...+A...`B..aB.3
 4af0 ff21f02b 82f80013 f5d16ff0 0d001c49  .!.+......o....I
 4b00 fff7c4fa 6ff00c00 1949fff7 bffa6ff0  ....o....I....o.
 4b10 0b001749 fff7bafa 6ff00a00 1449fff7  ...I....o....I..
 4b20 b5fa6ff0 09001249 fff7b0fa 002460b2  ..o....I.....$`.
 4b30 0f490134 fff7aafa 262cf8d1 0d4ce025  .I.4....&,...L.%
 4b40 01f00cf8 84f82250 2025e577 00f002fc  ......"P %.w....
 4b50 eff31484 14f00104 02d1fff7 b5ff02e0  ................
 4b60 dff814c0 00df0020 38bd0720 38bd00bf  ....... 8.. 8...
 4b70 ed530000 00ed00e0 c94a0000 38b500f0  .S.......J..8...
 4b80 abfb0546 fff774ff 0d4a1468 7cb12369  ...F..t..J.h|.#i
 4b90 eb1a002b 0adb6369 a1690bb1 996100e0  ...+..ci.i...a..
 4ba0 5160a269 13600023 a36100e0 0024fff7  Q`.i.`.#.a...$..
 4bb0 65ff24b1 e0682146 00f01ef8 e2e738bd  e.$..h!F......8.
 4bc0 480e0020 10b50446 fff75bff 024620b9  H.. ...F..[..F .
 4bd0 0748ba21 134600f0 39f8064b 1b6823b1  .H.!.F..9..K.h#.
 4be0 1869001b 20eae070 10bd4ff0 ff3010bd  .i.. ..p..O..0..
 4bf0 ae640000 480e0020 f8b50d46 0646fff7  .d..H.. ...F.F..
 4c00 37ff2b78 07461bb1 bde8f840 fff736bf  7.+x.F.....@..6.
 4c10 01242c70 b268ab60 15603068 0835b560  .$,p.h.`.`0h.5.`
 4c20 48b1827b 022a02d1 00f04cfa 00e01c46  H..{.*....L....F
 4c30 00233360 00e00446 3846fff7 1fff24b1  .#3`...F8F....$.
 4c40 0020bde8 f84000f0 ebb9f8bd 08b5fff7  . ...@..........
 4c50 0fff01f0 29f900b1 00be044b 4ff00042  ....)......KO..B
 4c60 5a60bff3 6f8f01f0 07f900bf 00ed00e0  Z`..o...........
 4c70 08b5044b 5a685a68 da6a9a6a 9a6b5b6b  ...KZhZh.j.j.k[k
 4c80 01f0faf8 00ed00e0 08b5084b 1b685bb1  ...........K.h[.
 4c90 07484ff0 ff3100f0 0ff928b1 00220548  .HO..1....(..".H
 4ca0 22211346 fff7d2ff 08bd00bf 440e0020  "!.F........D.. 
 4cb0 300a0020 bb640000 08b5074b 1b684bb1  0.. .d.....K.hK.
 4cc0 064800f0 b1f828b1 00220548 2d211346  .H....(..".H-!.F
 4cd0 fff7bcff 08bd00bf 440e0020 300a0020  ........D.. 0.. 
 4ce0 bb640000 10b50446 fff7ceff 2046fef7  .d.....F.... F..
 4cf0 d9fd0446 fff7e0ff 204610bd 10b50446  ...F.... F.....F
 4d00 fff7c2ff 2046fef7 17febde8 1040fff7  .... F.......@..
 4d10 d3bf38b5 05460c46 fff7b6ff 21462846  ..8..F.F....!F(F
 4d20 01f0e3f8 0446fff7 c7ff2046 38bd0000  .....F.... F8...
 4d30 70b550b3 4bb30029 27dd002a 25dd9c07  p.P.K..)'..*%...
 4d40 25d112f0 03041abf c4f10404 a4181446  %..............F
 4d50 0260049a 82618160 4160c360 43611d46  .`...a.`A`.`Ca.F
 4d60 0a46012a 04d02e19 2e60013a 3546f8e7  .F.*.....`.:5F..
 4d70 01396143 00225a50 06490261 4b681860  .9aC."ZP.I.aKh.`
 4d80 00f11003 4b601046 70bd0320 70bd0420  ....K`.Fp.. p.. 
 4d90 70bd00bf 30010020 38b50446 68b1fff7  p...0.. 8..Fh...
 4da0 67fea368 2bb16569 013b2a68 6261a360  g..h+.ei.;*hba.`
 4db0 00e01d46 fff762fe 00e00546 284638bd  ...F..b....F(F8.
 4dc0 70b50e46 054610b3 09b30468 c0686b68  p..F.F.....h.hkh
 4dd0 14f00302 16bfc2f1 04022246 12198142  .........."F...B
 4de0 15d303fb 02039942 11d2081a b0fbf2f3  .......B........
 4df0 02fb1304 5cb9fff7 3bfe6b69 3360ab68  ....\...;.ki3`.h
 4e00 6e610133 ab60fff7 39fe2046 70bd0320  na.3.`..9. Fp.. 
 4e10 70bd30b1 00234371 c3808360 03601846  p.0..#Cq...`.`.F
 4e20 70470320 70470000 f8b5214b 1b680446  pG. pG....!K.h.F
 4e30 002b36d0 002836d0 00f0ecf8 e388002b  .+6..(6........+
 4e40 33d0a568 854230d1 013b9bb2 e38033bb  3..h.B0..;....3.
 4e50 fff70efe 63796a7b 9a420746 03d06b73  ....cyj{.B.F..ks
 4e60 284600f0 abf92668 6eb1f269 22b91148  (F....&hn..i"..H
 4e70 68211346 fff7eafe 304600f0 23f90123  h!.F....0F..#..#
 4e80 e380737b 6371a660 00f092f9 04463846  ..s{cq.`.....F8F
 4e90 fff7f4fd ac4202d0 204600f0 c1f80020  .....B.. F..... 
 4ea0 f8bd0920 f8bd0320 f8bd0520 f8bd00bf  ... ... ... ....
 4eb0 440e0020 c5640000 364b1b68 2de9f041  D.. .d..6K.h-..A
 4ec0 06468846 002b5ed0 00285fd0 fff7d0fd  .F.F.+^..(_.....
 4ed0 074600f0 9ff8f588 04462db9 b060437b  .F.......F-..`C{
 4ee0 73710123 f38004e0 b3688342 07d1681c  sq.#.....h.B..h.
 4ef0 f0803846 fff7c2fd 0020bde8 f081b8f1  ..8F..... ......
 4f00 000f05d1 3846fff7 b9fd0620 bde8f081  ....8F..... ....
 4f10 427b597b 914203d9 5a73b068 00f04ef9  B{Y{.B..Zs.h..N.
 4f20 326882b1 657b1346 0021587b a84204d8  2h..e{.F.!X{.B..
 4f30 d86c1946 18b10346 f7e70b46 19b1da6c  .l.F...F...F...l
 4f40 e264dc64 01e0e264 3460e37b e66143f0  .d.d...d4`.{.aC.
 4f50 0403e373 41462046 00f07af8 3846fff7  ...sAF F..z.8F..
 4f60 8dfd0020 00f05cf8 fff782fd e37b23f0  ... ..\......{#.
 4f70 0403e373 fff782fd b068a042 14bf0620  ...s.....h.B... 
 4f80 0020bde8 f0810920 bde8f081 0320bde8  . ..... ..... ..
 4f90 f08100bf 440e0020 38b5837b 012b0446  ....D.. 8..{.+.F
 4fa0 0ad1fff7 65fd0e4a 136893b1 657b597b  ....e..J.h..e{Y{
 4fb0 8d4203d3 5b6cf8e7 022038bd 9a6ca264  .B..[l... 8..l.d
 4fc0 9a6c6364 14604434 9c64fff7 57fd0020  .lcd.`D4.d..W.. 
 4fd0 38bd6364 5368a364 1c604434 5460f4e7  8.cdSh.d.`D4T`..
 4fe0 38010020 084b1a68 824210b5 0bd0c36b  8.. .K.h.B.....k
 4ff0 06490133 c363064b 0c681868 936b0860  .I.3.c.K.h.h.k.`
 5000 03441b1b 936310bd 500e0020 540e0020  .D...c..P.. T.. 
 5010 640e0020 014b1868 704700bf 500e0020  d.. .K.hpG..P.. 
 5020 38b50446 fff724fd 05460cb9 064b1c68  8..F..$..F...K.h
 5030 064b1b68 9c4202d0 2046fff7 0ffd2846  .K.h.B.. F....(F
 5040 bde83840 fff71abd 38010020 500e0020  ..8@....8.. P.. 
 5050 38b5436c 826c0446 0d460bb1 9a6401e0  8.Cl.l.F.F...d..
 5060 16494a60 a26c1360 0223a373 00f034f9  .IJ`.l.`.#.s..4.
 5070 28440135 6063124a 05d1e37b 43f00103  (D.5`c.J...{C...
 5080 e3730023 0ae01368 43b1d97b c9070cd4  .s.#...hC..{....
 5090 596b091a 002908dc 5b6cf5e7 63645368  Yk...)..[l..cdSh
 50a0 a3641c60 44345460 06e09a6c a2649a6c  .d.`D4T`...l.d.l
 50b0 63641460 44349c64 002038bd 38010020  cd.`D4.d. 8.8.. 
 50c0 40010020 08b5837b 022b03d0 1848ce21  @.. ...{.+...H.!
 50d0 002205e0 c369abb1 1a6822b9 1448d321  ."...i...h"..H.!
 50e0 1346fff7 b3fd8242 02d1c26c 1a6006e0  .F.....B...l.`..
 50f0 d36c8342 01d01a46 fae7c36c d3640023  .l.B...F...l.d.#
 5100 c364c361 01238373 00234363 c37b826c  .d.a.#.s.#Cc.{.l
 5110 23f00103 c373436c 0bb19a64 01e00549  #....sCl...d...I
 5120 4a60826c 1360fff7 37ff0020 08bd00bf  J`.l.`..7.. ....
 5130 d0640000 40010020 70b500f0 cdf80546  .d..@.. p......F
 5140 fff796fc 0a4b0446 186858b1 c37bdb07  .....K.F.hX..{..
 5150 08d4436b 466ceb1a 002b03db fff7b2ff  ..CkFl...+......
 5160 3046f2e7 2046bde8 7040fff7 87bc00bf  0F.. F..p@......
 5170 40010020 10b50446 fff783fc 024628b9  @.. ...F.....F(.
 5180 094840f2 17111346 fff760fd 074b1b68  .H@....F..`..K.h
 5190 3bb1da7b d20704d4 586b001b 20eae070  ;..{....Xk.. ..p
 51a0 10bd4ff0 ff3010bd d0640000 40010020  ..O..0...d..@.. 
 51b0 014b1868 704700bf 38010020 837b012b  .K.hpG..8.. .{.+
 51c0 0ad1436c 826c0bb1 9a6401e0 03494a60  ..Cl.l...d...IJ`
 51d0 826c1360 fff7e0be 704700bf 38010020  .l.`....pG..8.. 
 51e0 2de9f047 04461f46 89469246 00215022  -..G.F.F.F.F.!P"
 51f0 ddf82480 0a9dbdf8 2c60fef7 b3fba761  ..$.....,`.....a
 5200 c4f814a0 fff734fc 1f4b1f78 7a1c1a70  ......4..K.xz..p
 5210 fff734fc 9df82030 63730123 2773a373  ..4... 0cs.#'s.s
 5220 04f12007 0023c4f8 10906363 384600f0  .. ..#....cc8F..
 5230 11f938bb b8f1ff3f 01d10023 06e0c4f8  ..8....?...#....
 5240 24803846 00f00ef9 e0b9f6e7 b34204da  $.8F.........B..
 5250 0e4a45f8 23200133 f8e705eb 86053246  .JE.# .3......2F
 5260 20462946 fff712fc 00232364 084b2681   F)F.....##d.K&.
 5270 5a6884e8 21001460 204604f1 40025a60  Zh..!..` F..@.Z`
 5280 fff78afe bde8f087 600e0020 efbeadde  ........`.. ....
 5290 580e0020 30b5d1e9 0045c309 8968e418  X.. 0....E...h..
 52a0 00f07f03 41f68460 00fb0310 094b9060  ....A..`.....K.`
 52b0 45f10005 9842c2e9 004509dd 013445f1  E....B...E...4E.
 52c0 0005a0f5 7420c2e9 0045a0f5 10709060  ....t ...E...p.`
 52d0 30bd00bf 3f420f00 014b1868 704700bf  0...?B...K.hpG..
 52e0 640e0020 f8b5041e 05da0022 16486121  d.. .......".Ha!
 52f0 1346fff7 abfc26d0 144efff7 b9fb3368  .F....&..N....3h
 5300 0746e018 90ea030f 306010d5 104d2946  .F......0`...M)F
 5310 51f8084b 041b0a46 2046fff7 bbff05f1  Q..K...F F......
 5320 18012046 0a46fff7 b5ff3368 2b603846  .. F.F....3h+`8F
 5330 fff7a4fb fff722fc fff7fefe 0020bde8  ......"...... ..
 5340 f840fff7 6dbef8bd db640000 640e0020  .@..m....d..d.. 
 5350 400a0020 684680f3 09882c48 00780230  @.. hF....,H.x.0
 5360 80f31488 bff36f8f 704780e8 f00f7047  ......o.pG....pG
 5370 eff30980 816911f8 021c51b9 90e80f10  .....i....Q.....
 5380 10b5e047 bde81040 eff3098c 8ce80700  ...G...@........
 5390 704710b5 1e4a1268 914209d8 1d4c54f8  pG...J.h.B...LT.
 53a0 214090e8 0f10a047 eff3098c 8ce80f00  !@.....G........
 53b0 bde81040 7047184b 1a68184b 19689142  ...@pG.K.h.K.h.B
 53c0 08bf7047 eff3098c 2ce9f00f c1f800c0  ..pG....,.......
 53d0 1a60d2f8 00c0bce8 f00f8cf3 09887047  .`............pG
 53e0 10b5fff7 37fbbde8 10407047 1ef0040f  ....7....@pG....
 53f0 0cbfeff3 0883eff3 09832de9 f84f6846  ..........-..OhF
 5400 fff736fc bde8f84f 70470000 2c0a0020  ..6....OpG..,.. 
 5410 00000000 fcffffff 38010020 500e0020  ........8.. P.. 
 5420 08b5044b 186820b1 03484ff0 ff31fff7  ...K.h ..HO..1..
 5430 43fd08bd 440e0020 6c0e0020 08b5034b  C...D.. l.. ...K
 5440 186810b1 0248fff7 effc08bd 440e0020  .h...H......D.. 
 5450 6c0e0020 08b50021 1422fef7 83fa0020  l.. ...!."..... 
 5460 08bd0000 10b50446 fff7daff 38b9044b  .......F....8..K
 5470 1a682261 1c60bde8 1040fff7 dfbf10bd  .h"a.`...@......
 5480 700a0020 30b50b46 5c1a9442 0ada13f8  p.. 0..F\..B....
 5490 014b054d 84ea1024 35f81440 84ea0020  .K.M...$5..@... 
 54a0 80b2f1e7 30bd00bf e6640000 034b1a78  ....0....d...K.x
 54b0 0ab90122 1a700020 704700bf 740a0020  ...".p. pG..t.. 
 54c0 024b1a68 02601860 00207047 780a0020  .K.h.`.`. pGx.. 
 54d0 38b5064b 1c680546 34b12846 616800f0  8..K.h.F4.(Fah..
 54e0 30fd08b1 2468f7e7 204638bd 780a0020  0...$h.. F8.x.. 
 54f0 73b50d46 16460949 01aa00f0 2cfd0024  s..F.F.I....,..$
 5500 40b146f8 24000549 002001aa 00f023fd  @.F.$..I. ....#.
 5510 0134f5e7 2c6002b0 70bd00bf 04630000  .4..,`..p....c..
 5520 10b51446 fff7e4ff 20b92068 bde81040  ...F.... . h...@
 5530 fff7cebf 002010bd 70b51446 06460d46  ..... ..p..F.F.F
 5540 00f0e2fd 23689842 01dd0320 70bd3046  ....#h.B... p.0F
 5550 294600f0 83fd0028 f7db2060 002070bd  )F.....(.. `. p.
 5560 70b50326 8c0094fb f6f43444 9c421546  p..&......4D.B.F
 5570 04da0123 00f024fd 284670bd 002070bd  ...#..$.(Fp.. p.
 5580 10b58ab0 0c4602aa 01a9fff7 c9ff30b1  .....F........0.
 5590 c3680198 03a92246 01389847 00e00320  .h...."F.8.G... 
 55a0 0ab010bd 30b50446 8bb040b1 01a902aa  ....0..F..@.....
 55b0 fff7b6ff 80b10069 78b18047 0de0084b  .......ix..G...K
 55c0 1d683db1 2b691bb1 9847002c 08bf0446  .h=.+i...G.,...F
 55d0 2d68f6e7 204600e0 03200bb0 30bd00bf  -h.. F... ..0...
 55e0 780a0020 826808b5 2ab1044a 426000f0  x.. .h..*..JB`..
 55f0 bbf90020 08bd0320 08bd00bf 48010020  ... ... ....H.. 
 5600 826808b5 2ab1044a 426000f0 c1f90020  .h..*..JB`..... 
 5610 08bd0320 08bd00bf 48010020 f7b50c46  ... ....H.. ...F
 5620 19680746 16461d46 00f042fa 002804da  .h.F.F.F..B..(..
 5630 00232b60 4ff0ff30 23e03846 31462246  .#+`O..0#.8F1F"F
 5640 01ab00f0 25fa0028 f2db019b 002befd0  ....%..(.....+..
 5650 b34204bf 03f1ff33 0193019b 00260a21  .B.....3.....&.!
 5660 e6542046 fef786f9 014608b1 067003e0  .T F.....F...p..
 5670 2046fef7 7ff90146 2b68081b 01330344   F.....F+h...3.D
 5680 2b6003b0 f0bd2de9 f041dcb0 06460f46  +`....-..A...F.F
 5690 90468068 01216a46 00f0eef9 f8b90190  .F.h.!jF........
 56a0 04460098 04a94ff4 b07201ab fff7b6ff  .F....O..r......
 56b0 019d75b1 0028f4db 04a802a9 03aa00f0  ..u..(..........
 56c0 cdf80028 edd10298 03994246 0134b847  ...(......BF.4.G
 56d0 e7e70098 00f0d6f9 34612846 00e00220  ........4a(F... 
 56e0 5cb0bde8 f0810000 2de9f041 adf5407d  \.......-..A..@}
 56f0 06460121 80686a46 00f0bef9 05460028  .F.!.hjF.....F.(
 5700 6ed1d6f8 08804046 fef749f9 1b28a8bf  n.....@F..I..(..
 5710 1b200446 08af4146 22463846 00f0dafb  . .F..AF"F8F....
 5720 314b1b68 3b5109ab 38461d55 0a2101aa  1K.h;Q..8F.U.!..
 5730 00f0a2f9 18b10098 00f0a4f9 50e00290  ............P...
 5740 044602ab 009810a9 4ff4b072 fff766ff  .F......O..r..f.
 5750 029b13b3 002820db 10a804a9 05aa00f0  .....( .........
 5760 7df80028 edd1029b 039368ad 00982946  }..(......h...)F
 5770 4ff4b072 03abfff7 51ff0028 1cdd2846  O..r....Q..(..(F
 5780 06a907aa 00f06af8 0028eed1 04980699  ......j..(......
 5790 00f0d7fb 0028e8d1 d3e70198 00f072f9  .....(........r.
 57a0 009800f0 6ff9b068 00f088f9 3846b168  ....o..h....8F.h
 57b0 00f08af9 346113e0 049a059b 28464ff4  ....4a......(FO.
 57c0 b07100f0 88f8b0f5 af7f0246 b9d80a23  .q.........F...#
 57d0 ab540198 29460132 00f064f9 0134b0e7  .T..)F.2..d..4..
 57e0 0df5407d bde8f081 ea660000 f0b50446  ..@}.....f.....F
 57f0 dbb01746 0d4609b9 03202de0 c2682ab1  ...F.F... -..h*.
 5800 01690131 914201db fff76eff 02ae2a46  .i.1.B....n...*F
 5810 30464ff4 b0713b46 00f05df8 b0f5af7f  0FO..q;F..].....
 5820 0546e9d8 0a233354 0621a068 01aa00f0  .F...#3T.!.h....
 5830 23f980b9 01983146 6a1c00f0 33f920b9  #.....1Fj...3. .
 5840 23690133 23610446 00e00224 019800f0  #i.3#a.F...$....
 5850 19f92046 00e00220 5bb0f0bd 70b50024  .. F... [...p..$
 5860 14600546 10f8013b 73b3032c f9d8dfe8  .`.F...;s..,....
 5870 04f0020d 141f202b f3d0a3f1 0906012e  ...... +........
 5880 efd90d2b edd00d60 0124eae7 3d2b0fd1  ...+...`.$..=+..
 5890 002300f8 013c0224 e3e7202b e1d0a3f1  .#...<.$.. +....
 58a0 0906012e ddd90d2b dbd01560 0324d8e7  .......+...`.$..
 58b0 202b05d0 a3f10905 012d01d9 0d2bd0d1   +.......-...+..
 58c0 002300f8 013ccce7 a01e0128 4ff0ff30  .#...<.....(O..0
 58d0 98bf0020 70bd2de9 f8430546 10468946  ... p.-..C.F.F.F
 58e0 90461e46 fef75bf8 074626b1 3046fef7  .F.F..[..F&.0F..
 58f0 56f80446 00e03446 3b190133 4b4514da  V..F..4F;..3KE..
 5900 41463a46 284600f0 e5fa07f1 01083d23  AF:F(F........=#
 5910 eb5505eb 08003146 224600f0 dbfa08eb  .U....1F"F......
 5920 04000023 2b54bde8 f8834ff0 ff30bde8  ...#+T....O..0..
 5930 f883fff7 25be38b5 0d461168 144600f0  ....%.8..F.h.F..
 5940 00fb80b9 616825b9 09b10b78 13b90123  ....ah%....x...#
 5950 01e011b9 0023a360 38bd2846 00f0f1fa  .....#.`8.(F....
 5960 0028f7d1 f3e738bd 084a10b5 14680023  .(....8..J...h.#
 5970 214611b1 0b460968 fbe713b9 04601060  !F...F.h.....`.`
 5980 10bd1a68 02601860 10bd00bf 7c0a0020  ...h.`.`....|.. 
 5990 014b1860 704700bf c80f0020 084b10b5  .K.`pG..... .K..
 59a0 1c683cb1 63680749 1b682046 00229847  .h<.ch.I.h F.".G
 59b0 2468f6e7 2046bde8 1040fff7 f3bd00bf  $h.. F...@......
 59c0 7c0a0020 33590000 f0b50f4b 1d6885b0  |.. 3Y.....K.h..
 59d0 07460e46 9db16b68 01900024 02911b68  .F.F..kh...$...h
 59e0 03942846 094901aa 9847039b 012b08d0  ..(F.I...G...+..
 59f0 6b682846 9b683946 32469847 02e00a20  kh(F.h9F2F.G... 
 5a00 00e02046 05b0f0bd c80f0020 37590000  .. F....... 7Y..
 5a10 034b1a78 0ab90122 1a700020 704700bf  .K.x...".p. pG..
 5a20 800a0020 044b81e8 05005a68 00208860  ... .K....Zh. .`
 5a30 11600831 59607047 58010020 00207047  .`.1Y`pGX.. . pG
 5a40 02207047 02207047 02207047 0346064a  . pG. pG. pG.F.J
 5a50 5a60064a 9a60064a da600020 054a1860  Z`.J.`.J.`. .J.`
 5a60 1a619861 58617047 415a0000 3d5a0000  .a.aXapGAZ..=Z..
 5a70 455a0000 495a0000 014b1b68 1b681847  EZ..IZ...K.h.h.G
 5a80 840a0020 014b1b68 5b681847 840a0020  ... .K.h[h.G... 
 5a90 10b5034c 2468a468 a446bde8 10406047  ...L$h.h.F...@`G
 5aa0 840a0020 014b1b68 db681847 840a0020  ... .K.h.h.G... 
 5ab0 014b1b68 1b691847 840a0020 014b1b68  .K.h.i.G... .K.h
 5ac0 db691847 840a0020 014b1b68 1b6a1847  .i.G... .K.h.j.G
 5ad0 840a0020 034a1368 13b91060 18467047  ... .J.h...`.FpG
 5ae0 0b207047 840a0020 73b51646 012101aa  . pG... s..F.!..
 5af0 1d46fff7 c1ff0446 30b90198 069b3146  .F.....F0.....1F
 5b00 2a46fff7 c5ff0446 0198fff7 bbff2046  *F.....F...... F
 5b10 02b070bd 73b50e46 15460a21 01aafff7  ..p.s..F.F.!....
 5b20 abff0446 28b90198 31462a46 fff7baff  ...F(...1F*F....
 5b30 04460198 fff7a6ff 204602b0 70bd0000  .F...... F..p...
 5b40 00280248 18bf0020 704700bf f0660000  .(.H... pG...f..
 5b50 4ff0ff30 704708b5 00f08ef9 08b50020  O..0pG......... 
 5b60 00f00cf8 0020fff7 f3ff0348 0521bde8  ..... .....H.!..
 5b70 0840fdf7 c3bc00bf 60010020 0d4a08b5  .@......`.. .J..
 5b80 031e1068 07da0c49 03448b42 08d200f0  ...h...I.D.B....
 5b90 d1fa1623 09e00949 091a9942 02db0344  ...#...I...B...D
 5ba0 136008bd 00f0c6fa 0c230360 4ff0ff30  .`.......#.`O..0
 5bb0 08bd00bf 9c010020 d80f0020 50fe0020  ....... ... P.. 
 5bc0 064b074a d2f80024 012a04d0 013bf8d1  .K.J...$.*...;..
 5bd0 4ff0ff30 70470020 704700bf a0860100  O..0pG. pG......
 5be0 00e00140 70b50646 fff7eaff 00bbeff3  ...@p..F........
 5bf0 108572b6 104cd4f8 043543f0 0203c4f8  ..r..L...5C.....
 5c00 0435fff7 ddff40b9 c4f80865 fff7d8ff  .5....@....e....
 5c10 003018bf 01204042 01e04ff0 ff30d4f8  .0... @B..O..0..
 5c20 043523f0 0203c4f8 04351db9 62b670bd  .5#......5..b.p.
 5c30 4ff0ff30 70bd00bf 00e00140 00207047  O..0p......@. pG
 5c40 2de9f347 04460e46 1546fff7 b9ff0028  -..G.F.F.F.....(
 5c50 53d1eff3 108872b6 2a4ad2f8 043514f0  S.....r.*J...5..
 5c60 030a43f0 0103c2f8 043526d0 fff7a8ff  ..C......5&.....
 5c70 10b14ff0 ff3034e0 24f00309 02a8caf1  ..O..04.$.......
 5c80 0407d9f8 003040f8 043daf42 28bf2f46  .....0@..=.B(./F
 5c90 31465044 3a4600f0 1df9019b c9f80030  1FPD:F.........0
 5ca0 3c44ed1b 3e4408e0 fff78aff 0028e0d1  <D..>D.......(..
 5cb0 56f8043b 44f8043b 043d032d f4d86db1  V..;D..;.=.-..m.
 5cc0 02a82368 40f8043d 31462a46 00f002f9  ..#h@..=1F*F....
 5cd0 fff776ff 0028ccd1 019b2360 fff770ff  ..v..(....#`..p.
 5ce0 0020084a d2f80435 23f00103 c2f80435  . .J...5#......5
 5cf0 b8f1000f 03d162b6 01e04ff0 ff3002b0  ......b...O..0..
 5d00 bde8f087 00e00140 08b50346 08461946  .......@...F.F.F
 5d10 00f0e0f8 002008bd 7f2808b5 05dd0022  ..... ...(....."
 5d20 0548af21 1346fef7 91ff0003 4ff48053  .H.!.F......O..S
 5d30 08601360 002008bd 2a630000 002208b5  .`.`. ..*c..."..
 5d40 02485521 1346fef7 81ff00bf 18670000  .HU!.F.......g..
 5d50 b0f1807f 08b502d3 0a484321 04e0b1f1  .........HC!....
 5d60 807f05d3 07484421 00221346 fef76eff  .....HD!.".F..n.
 5d70 401a0302 46bf6fea 40206fea 5020c0f3  @...F.o.@ o.P ..
 5d80 160008bd 18670000 38b50446 fef779fe  .....g..8..F..y.
 5d90 024670b9 0d486721 1346fef7 57ffd5f8  .Fp..Hg!.F..W...
 5da0 04152046 fff7d4ff 02280ddc 084b1b68  .. F.....(...K.h
 5db0 1c44084d 24f07f44 c5f84c45 fef761fe  .D.M$..D..LE..a.
 5dc0 0028ecd1 fff7baff 38bd00bf 18670000  .(......8....g..
 5dd0 cc0f0020 00100140 f8b5fef7 49fe0746  ... ...@....I..F
 5de0 fef74ffe 08b9fff7 a9ff0f4d 0f4ea968  ..O........M.N.h
 5df0 d6f80405 fff7acff 2c6890fb f4f42046  ........,h.... F
 5e00 fff770fa 0023c6f8 4c312868 ab6800fb  ..p..#..L1(h.h..
 5e10 043424f0 7f442044 ac60fff7 b5ff3846  .4$..D D.`....8F
 5e20 bde8f840 fef72abe cc0f0020 00100140  ...@..*.... ...@
 5e30 10b50446 fef725fe 024620b9 0c48b621  ...F..%..F ..H.!
 5e40 1346fef7 03ff54b1 0a4b5a68 18689b68  .F....T..KZh.h.h
 5e50 944228bf 144600fb 0430fff7 95ffbff3  .B(..F...0......
 5e60 4f8f30bf 1cb1bde8 1040fff7 b5bf10bd  O.0......@......
 5e70 18670000 cc0f0020 084b1b68 db0700d5  .g..... .K.h....
 5e80 00bebff3 4f8f0649 064bca68 02f4e062  ....O..I.K.h...b
 5e90 1343cb60 bff34f8f fee700bf f0ed00e0  .C.`..O.........
 5ea0 00ed00e0 0400fa05 024b1868 00f00100  .........K.h....
 5eb0 704700bf f0ed00e0 10b50244 904206d0  pG.........D.B..
 5ec0 10f8013b 11f8014b 1b1bf7d0 00e00023  ...;...K.......#
 5ed0 184610bd 10b5431e 0a449142 04d011f8  .F....C..D.B....
 5ee0 014b03f8 014ff8e7 10bdf8b5 0c460546  .K...O.......F.F
 5ef0 20b90846 bde8f840 fdf7d4bc 19b9fdf7   ..F...@........
 5f00 1bfd2046 f8bd01f1 1f0250f8 0c6c22f0  .. F......P..l".
 5f10 0f04a642 02d3b4eb 960f11d2 2046fdf7  ...B........ F..
 5f20 c1fc0746 38b1a6f1 1002a242 294628bf  ...F8......B)F(.
 5f30 2246fff7 cfff2846 fdf7fefc 3846f8bd  "F....(F....8F..
 5f40 f8bd10f8 012b11f8 013bd31a 01d1002a  .....+...;.....*
 5f50 f7d11846 704738b5 0d461446 00b11060  ...FpG8..F.F...`
 5f60 20462946 00f005f8 10b10378 002bf7d0   F)F.......x.+..
 5f70 38bd38b5 04680546 3cb12046 00f007f8  8.8..h.F<. F....
 5f80 10b10023 03700130 28602046 38bd70b5  ...#.p.0(` F8.p.
 5f90 037893b1 0c460346 10f8015b 3db10a46  .x...F.F...[=..F
 5fa0 144612f8 016b002e f5d0b542 f8d12278  .F...k.....B.."x
 5fb0 002a14bf 18460020 70bd1846 70bd0000  .*...F. p..Fp...
 5fc0 f8b50024 16461546 07462246 8a4232da  ...$.F.F.F"F.B2.
 5fd0 02f1010e 845c8e45 b8bf97f8 01e04fea  .....\.E......O.
 5fe0 0424b8bf 744402f1 020e8e45 b8bf97f8  .$..tD.....E....
 5ff0 02e04fea 0424b8bf 7444c4f3 854cdff8  ..O..$..tD...L..
 6000 58e01ef8 0cc085f8 00c0c4f3 053c0332  X............<.2
 6010 1ef80cc0 85f801c0 c4f3851c 04f03f04  ..............?.
 6020 1ef80cc0 1ef80440 ec7085f8 02c02c46  .......@.p....,F
 6030 03370435 cae75cb1 521a002a 08ddc2f1  .7.5..\.R..*....
 6040 040023b1 20443d21 fdf78cfc 00e02518  ..#. D=!......%.
 6050 00232b70 a81bf8bd 26670000 2de9f041  .#+p....&g..-..A
 6060 0e46c51c 0c4615f8 031cef1e 11b9a01b  .F...F..........
 6070 bde8f081 3d293dd1 3846fdf7 90fc0328  ....=)=.8F.....(
 6080 23d90020 2f1f0346 17f801cf bcf13d0f  #.. /..F......=.
 6090 4fea8313 01d10130 10e0b0b9 19498846  O......0.....I.F
 60a0 0a4611f8 01ebbef1 000f04d0 e645f7d1  .F...........E..
 60b0 c8eb0202 01e04ff0 ff321344 af42e3d1  ......O..2.D.B..
 60c0 022802dc 43ea0060 01e04ff0 ff30421c  .(..C..`..O..0B.
 60d0 4fea1063 14d0020c 012b2270 01d90134  O..c.....+"p...4
 60e0 06e0020a 62700bb1 023401e0 a0700334  ....bp...4...p.4
 60f0 0435b8e7 0348fdf7 3dfc0028 bcd1b6e7  .5...H..=..(....
 6100 bde8f081 26670000 10b50446 fdf747fc  ....&g.....F..G.
 6110 2044a042 a0eb0403 04d010f8 012d3d2a   D.B.........-=*
 6120 f7d000e0 002303eb 43030420 93fbf0f0  .....#..C.. ....
 6130 10bd0000 014b1868 704700bf c8050020  .....K.hpG..... 
 6140 70b50f4e 0f4d761b b61018bf 002405d0  p..N.Mv......$..
 6150 013455f8 043b9847 a642f9d1 0a4e0b4d  .4U..;.G.B...N.M
 6160 761b00f0 15f8b610 18bf0024 06d00134  v..........$...4
 6170 55f8043b 9847a642 f9d170bd 70bd00bf  U..;.G.B..p.p...
 6180 cc050020 cc050020 cc050020 cc050020  ... ... ... ... 
 6190 f8b500bf f8bc08bc 9e467047 f8b500bf  .........FpG....
 61a0 f8bc08bc 9e467047 626f6f74 2e63002f  .....FpGboot.c./
 61b0 6366672f 72756e00 6e666673 2e63006e  cfg/run.nffs.c.n
 61c0 66667300 39040000 1f040000 fb030000  ffs.9...........
 61d0 d1030000 b5030000 c1020000 99030000  ................
 61e0 77030000 51030000 2d030000 07030000  w...Q...-.......
 61f0 eb020000 d3020000 a1040000 71040000  ............q...
 6200 bf610000 6e666673 5f636163 68652e63  .a..nffs_cache.c
 6210 006e6666 735f6669 6c652e63 006e6666  .nffs_file.c.nff
 6220 735f666c 6173682e 63006e66 66735f66  s_flash.c.nffs_f
 6230 6f726d61 742e6300 6e666673 5f686173  ormat.c.nffs_has
 6240 682e6300 6e666673 5f696e6f 64652e63  h.c.nffs_inode.c
 6250 006e6666 735f6d69 73632e63 002f6c6f  .nffs_misc.c./lo
 6260 73742b66 6f756e64 006e6666 735f6669  st+found.nffs_fi
 6270 6c655f70 6f6f6c00 6e666673 5f696e6f  le_pool.nffs_ino
 6280 64655f65 6e747279 5f706f6f 6c006e66  de_entry_pool.nf
 6290 66735f62 6c6f636b 5f656e74 72795f70  fs_block_entry_p
 62a0 6f6f6c00 6e666673 5f636163 68655f69  ool.nffs_cache_i
 62b0 6e6f6465 5f706f6f 6c006e66 66735f63  node_pool.nffs_c
 62c0 61636865 5f626c6f 636b5f70 6f6f6c00  ache_block_pool.
 62d0 6e666673 5f646972 5f706f6f 6c006e66  nffs_dir_pool.nf
 62e0 66735f70 6174682e 63006e66 66735f72  fs_path.c.nffs_r
 62f0 6573746f 72652e63 002f6c6f 73742b66  estore.c./lost+f
 6300 6f756e64 2f006e66 66735f77 72697465  ound/.nffs_write
 6310 2e63006e 6666735f 626c6f63 6b2e6300  .c.nffs_block.c.
 6320 6e666673 5f67632e 63006861 6c5f666c  nffs_gc.c.hal_fl
 6330 6173682e 6300626f 6f742f74 65737400  ash.c.boot/test.
 6340 626f6f74 2f6d6169 6e002f63 66672f62  boot/main./cfg/b
 6350 73740062 6f6f7400 6c6f6164 65722e63  st.boot.loader.c
 6360 00800000 00000000 00000000 00000000  ................
 6370 00000000 00000000 00000000 00000000  ................
 6380 00000000 00000000 00000000 00000000  ................
 6390 00000000 00000000 00000000 00000000  ................
 63a0 00000000 982f8a42 91443771 cffbc0b5  ...../.B.D7q....
 63b0 a5dbb5e9 5bc25639 f111f159 a4823f92  ....[.V9...Y..?.
 63c0 d55e1cab 98aa07d8 015b8312 be853124  .^.......[....1$
 63d0 c37d0c55 745dbe72 feb1de80 a706dc9b  .}.Ut].r........
 63e0 74f19bc1 c1699be4 8647beef c69dc10f  t....i...G......
 63f0 cca10c24 6f2ce92d aa84744a dca9b05c  ...$o,.-..tJ...\
 6400 da88f976 52513e98 6dc631a8 c82703b0  ...vRQ>.m.1..'..
 6410 c77f59bf f30be0c6 4791a7d5 5163ca06  ..Y.....G...Qc..
 6420 67292914 850ab727 38211b2e fc6d2c4d  g))....'8!...m,M
 6430 130d3853 54730a65 bb0a6a76 2ec9c281  ..8STs.e..jv....
 6440 852c7292 a1e8bfa2 4b661aa8 708b4bc2  .,r.....Kf..p.K.
 6450 a3516cc7 19e892d1 240699d6 85350ef4  .Ql.....$....5..
 6460 70a06a10 16c1a419 086c371e 4c774827  p.j......l7.LwH'
 6470 b5bcb034 b30c1c39 4aaad84e 4fca9c5b  ...4...9J..NO..[
 6480 f36f2e68 ee828f74 6f63a578 1478c884  .o.h...toc.x.x..
 6490 0802c78c faffbe90 eb6c50a4 f7a3f9be  .........lP.....
 64a0 f27871c6 69646c65 006f732e 63006f73  .xq.idle.os.c.os
 64b0 5f63616c 6c6f7574 2e63006f 735f6865  _callout.c.os_he
 64c0 61702e63 006f735f 6d757465 782e6300  ap.c.os_mutex.c.
 64d0 6f735f73 63686564 2e63006f 735f7469  os_sched.c.os_ti
 64e0 6d652e63 00000000 21104220 63308440  me.c....!.B c0.@
 64f0 a550c660 e7700881 29914aa1 6bb18cc1  .P.`.p..).J.k...
 6500 add1cee1 eff13112 10027332 5222b552  ......1...s2R".R
 6510 9442f772 d6623993 18837bb3 5aa3bdd3  .B.r.b9...{.Z...
 6520 9cc3fff3 dee36224 43342004 0114e664  ......b$C4 ....d
 6530 c774a444 85546aa5 4bb52885 0995eee5  .t.D.Tj.K.(.....
 6540 cff5acc5 8dd55336 72261116 3006d776  ......S6r&..0..v
 6550 f6669556 b4465bb7 7aa71997 3887dff7  .f.V.F[.z...8...
 6560 fee79dd7 bcc7c448 e5588668 a7784008  .......H.X.h.x@.
 6570 61180228 2338ccc9 edd98ee9 aff94889  a..(#8........H.
 6580 69990aa9 2bb9f55a d44ab77a 966a711a  i...+..Z.J.z.jq.
 6590 500a333a 122afddb dccbbffb 9eeb799b  P.3:.*........y.
 65a0 588b3bbb 1aaba66c 877ce44c c55c222c  X.;....l.|.L.\",
 65b0 033c600c 411caeed 8ffdeccd cddd2aad  .<`.A.........*.
 65c0 0bbd688d 499d977e b66ed55e f44e133e  ..h.I..~.n.^.N.>
 65d0 322e511e 700e9fff beefdddf fccf1bbf  2.Q.p...........
 65e0 3aaf599f 788f8891 a981cab1 eba10cd1  :.Y.x...........
 65f0 2dc14ef1 6fe18010 a100c230 e3200450  -.N.o......0. .P
 6600 25404670 6760b983 9893fba3 dab33dc3  %@Fpg`........=.
 6610 1cd37fe3 5ef3b102 9012f322 d2323542  ....^......".25B
 6620 14527762 5672eab5 cba5a895 89856ef5  .RwbVr........n.
 6630 4fe52cd5 0dc5e234 c324a014 81046674  O.,....4.$....ft
 6640 47642454 0544dba7 fab79987 b8975fe7  Gd$T.D........_.
 6650 7ef71dc7 3cd7d326 f2369106 b0165766  ~...<..&.6....Wf
 6660 76761546 34564cd9 6dc90ef9 2fe9c899  vv.F4VL.m.../...
 6670 e9898ab9 aba94458 65480678 2768c018  ......DXeH.x'h..
 6680 e1088238 a3287dcb 5cdb3feb 1efbf98b  ...8.(}.\.?.....
 6690 d89bbbab 9abb754a 545a376a 167af10a  ......uJTZ7j.z..
 66a0 d01ab32a 923a2efd 0fed6cdd 4dcdaabd  ...*.:....l.M...
 66b0 8bade89d c98d267c 076c645c 454ca23c  ......&|.ld\EL.<
 66c0 832ce01c c10c1fef 3eff5dcf 7cdf9baf  .,......>.].|...
 66d0 babfd98f f89f176e 367e554e 745e932e  .......n6~UNt^..
 66e0 b23ed10e f01e256c 64002e63 6d700000  .>....%ld..cmp..
 66f0 04670000 00000000 00000800 80000000  .g..............
 6700 01000000 095d0000 415c0000 e55b0000  .....]..A\...[..
 6710 195d0000 3d5c0000 68616c5f 6f735f74  .]..=\..hal_os_t
 6720 69636b2e 63004142 43444546 4748494a  ick.c.ABCDEFGHIJ
 6730 4b4c4d4e 4f505152 53545556 5758595a  KLMNOPQRSTUVWXYZ
 6740 61626364 65666768 696a6b6c 6d6e6f70  abcdefghijklmnop
 6750 71727374 75767778 797a3031 32333435  qrstuvwxyz012345
 6760 36373839 2b2f0000 43000000           6789+/..C...    

/Users/briangiori/dev/newt/blegpio/bin/nrf52_boot/apps/boot/boot.elf:     file format elf32-littlearm


/Users/briangiori/dev/newt/blegpio/bin/nrf52_boot/apps/boot/boot.elf:     file format elf32-littlearm

Contents of section .data:
 200000d8 00000000 00000000 af610000 00000000  .........a......
 200000e8 00000000 00000000 ec000020 0090d003  ........... ....
 200000f8 02000000 00000000 f8000020 f8000020  ........... ... 
 20000108 f8000020 f8000020 f1370000 ed370000  ... ... .7...7..
 20000118 00000000 53630000 00000000 d1390000  ....Sc.......9..
 20000128 00000000 00000000 00000000 30010020  ............0.. 
 20000138 00000000 38010020 00000000 40010020  ....8.. ....@.. 
 20000148 87560000 00000000 ed570000 00000000  .V.......W......
 20000158 00000000 58010020 00000000 00000000  ....X.. ........
 20000168 00800000 00000000 00800000 00a00300  ................
 20000178 00000000 00200400 00a00300 00000000  ..... ..........
 20000188 00c00700 00100000 00000000 00d00700  ................
 20000198 00300000 d80f0020 00000000 8c040020  .0..... ....... 
 200001a8 f4040020 5c050020 00000000 00000000  ... \.. ........
 200001b8 00000000 00000000 00000000 00000000  ................
 200001c8 00000000 00000000 00000000 68670000  ............hg..
 200001d8 00000000 00000000 00000000 00000000  ................
 200001e8 00000000 00000000 00000000 00000000  ................
 200001f8 00000000 00000000 00000000 00000000  ................
 20000208 00000000 00000000 00000000 00000000  ................
 20000218 00000000 00000000 00000000 00000000  ................
 20000228 00000000 00000000 00000000 00000000  ................
 20000238 00000000 00000000 00000000 00000000  ................
 20000248 01000000 00000000 0e33cdab 34126de6  .........3..4.m.
 20000258 ecde0500 0b000000 00000000 00000000  ................
 20000268 00000000 00000000 00000000 00000000  ................
 20000278 00000000 00000000 00000000 00000000  ................
 20000288 00000000 00000000 00000000 00000000  ................
 20000298 00000000 00000000 00000000 00000000  ................
 200002a8 00000000 00000000 00000000 00000000  ................
 200002b8 00000000 00000000 00000000 00000000  ................
 200002c8 00000000 00000000 00000000 00000000  ................
 200002d8 00000000 00000000 00000000 00000000  ................
 200002e8 00000000 00000000 00000000 00000000  ................
 200002f8 00000000 00000000 00000000 00000000  ................
 20000308 00000000 00000000 00000000 00000000  ................
 20000318 00000000 00000000 00000000 00000000  ................
 20000328 00000000 00000000 00000000 00000000  ................
 20000338 00000000 00000000 00000000 00000000  ................
 20000348 00000000 00000000 00000000 00000000  ................
 20000358 00000000 00000000 00000000 00000000  ................
 20000368 00000000 00000000 00000000 00000000  ................
 20000378 00000000 00000000 00000000 00000000  ................
 20000388 00000000 00000000 00000000 00000000  ................
 20000398 00000000 00000000 00000000 00000000  ................
 200003a8 00000000 00000000 00000000 00000000  ................
 200003b8 00000000 00000000 00000000 00000000  ................
 200003c8 00000000 00000000 00000000 00000000  ................
 200003d8 00000000 00000000 00000000 00000000  ................
 200003e8 00000000 00000000 00000000 00000000  ................
 200003f8 00000000 00000000 00000000 00000000  ................
 20000408 00000000 00000000 00000000 00000000  ................
 20000418 00000000 00000000 00000000 00000000  ................
 20000428 00000000 00000000 00000000 00000000  ................
 20000438 00000000 00000000 00000000 00000000  ................
 20000448 00000000 00000000 00000000 00000000  ................
 20000458 00000000 00000000 00000000 00000000  ................
 20000468 00000000 00000000 00000000 00000000  ................
 20000478 00000000 00000000 00000000 00000000  ................
 20000488 00000000 00000000 00000000 00000000  ................
 20000498 00000000 00000000 00000000 00000000  ................
 200004a8 00000000 00000000 00000000 00000000  ................
 200004b8 00000000 00000000 00000000 00000000  ................
 200004c8 00000000 00000000 00000000 00000000  ................
 200004d8 00000000 00000000 00000000 00000000  ................
 200004e8 00000000 00000000 00000000 00000000  ................
 200004f8 00000000 00000000 00000000 00000000  ................
 20000508 00000000 00000000 00000000 00000000  ................
 20000518 00000000 00000000 00000000 00000000  ................
 20000528 00000000 00000000 00000000 00000000  ................
 20000538 00000000 00000000 00000000 00000000  ................
 20000548 00000000 00000000 00000000 00000000  ................
 20000558 00000000 00000000 00000000 00000000  ................
 20000568 00000000 00000000 00000000 00000000  ................
 20000578 00000000 00000000 00000000 00000000  ................
 20000588 00000000 00000000 00000000 00000000  ................
 20000598 00000000 00000000 00000000 00000000  ................
 200005a8 00000000 00000000 00000000 00000000  ................
 200005b8 00000000 00000000 00000000 00000000  ................
 200005c8 a0010020                             ...             
   text	   data	    bss	    dec	    hex	filename
  26500	   1268	   2784	  30552	   7758	/Users/briangiori/dev/newt/blegpio/bin/nrf52_boot/apps/boot/boot.elf
